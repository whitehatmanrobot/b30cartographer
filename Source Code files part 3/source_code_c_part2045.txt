              pWait.pPublication.szServer, pWait.pPublication.szPublication,
                                dr["subscriber"], dr["subscriber_db"], ReplicationStatusToString((int)dr["status"])));

                            int status = (int)dr["status"];

                            if (6 == status)
                            {
                                Log(string.Format("Subscription Returned a failed status for Publication: {0}:{1} Subscription: {2}:{3}, errorid:{4}",
                                    pWait.pPublication.szServer, pWait.pPublication.szPublication,
                                    dr["subscriber"], dr["subscriber_db"], dr["error_id"]), true);
                                Interlocked.Increment(ref m_iErrors);
                                break;
                            }

                            if (2 != status)
                            {
                                fReady = false;
                                break;
                            }
                        }

                        if(fReady)
                        {
                            break;
                        }

                        Thread.Sleep(10000);
                    }
                }
                catch (Exception e)
                {
                    LogException(string.Format("Unhandled exception waiting for replication status of publication {0} on server {1}." +
                        "Probably non-fatal. Please check for post-step exceptions",
                        pWait.pPublication.szPublication, pWait.pPublication.szServer), e, false);
                }
                finally
                {
                    pWait.hEvent.Set();
                }
            }
        }
        private void _AddToDBOwner(string szServer, string szDatabase, string szLogin)
        {
            Server pServer;
            Database pDatabase;
            ServerConnection pConn;
            Login pLogin;
            User pUser;

            pConn = new ServerConnection(szServer);

            //
            // Set up the user as a dbo on the distribution database
            //
            pServer = new Server(pConn);
            pDatabase = pServer.Databases[szDatabase];

            // Step 1: Create the login, if necessary
            pLogin = new Login(pServer, szLogin);
            pLogin.LoginType = LoginType.WindowsUser;

            if (null == pServer.Logins[szLogin])
            {
                pLogin.Create();
            }

            // Step 2: Add the user for that login to the distribution database
            pUser = new User(pDatabase, szLogin);
            pUser.Login = szLogin;
            if (null == pDatabase.Users[szLogin])
            {
                pUser.Create();
            }

            // Step 3: Add the user as a db_owner to the distribution database
            pUser.AddToRole("db_owner");
        }

        static private void _CreateFileShare(string server, string localPath, string shareName)
        {
            ManagementPath path = new ManagementPath( @"\\" + server + @"\ROOT\cimv2:Win32_Share");
            ManagementClass shareClass = new ManagementClass(path);

            ManagementBaseObject inParams = shareClass.GetMethodParameters("Create");

            List<ManagementBaseObject> rgDacl = new List<ManagementBaseObject>();

            path = new ManagementPath( @"\\" + server + @"\ROOT\cimv2:Win32_SecurityDescriptor");
            ManagementBaseObject oDescriptor = new ManagementClass(path);
            oDescriptor.Properties["Dacl"].Value = rgDacl.ToArray();

            //Fill in input parameter values
            inParams["Path"] = localPath;
            inParams["Name"] = shareName;
            inParams["Type"] = 0;  // disk
            inParams["Access"] = oDescriptor;

            //Execute the method
            ManagementBaseObject outParams = shareClass.InvokeMethod ("Create", inParams, null);
            uint retcode = (uint)outParams["returnValue"];

            if (retcode!=0)
            {
                throw new ApplicationException( WmiErrorText(retcode) + " from cimv2:Win32_Share");
            }
        }


        static private void _DeleteFileShare(string server, string shareName)
        {
            ManagementPath path = new ManagementPath( @"\\" + server + @"\ROOT\cimv2:Win32_Share.Name='" + shareName + "'");
            uint retcode;

            try
            {
                ManagementObject share = new ManagementObject(path);
                ManagementBaseObject outParams = share.InvokeMethod ("Delete", null, null);
                retcode = (uint)outParams["returnValue"];
            }
            catch (ManagementException ex)
            {
                if (ex.ErrorCode == ManagementStatus.NotFound)
                {
                    return;
                }
                throw;
            }

            if (retcode!=0)
            {
                throw new ApplicationException( WmiErrorText(retcode) + " from cimv2:Win32_Share");
            }
        }

        static private string _GetFileShareLocalPath(string server, string shareName)
        {
            ManagementPath path = new ManagementPath( @"\\" + server + @"\ROOT\cimv2:Win32_Share.Name='" + shareName + "'");
            string localpath = string.Empty;

            ManagementObject share = new ManagementObject(path);
            try
            {
                localpath = share.Properties["Path"].Value.ToString();
            }
            catch
            {
                localpath = null;
            }

            return localpath;
        }

        static private string _GetSQLServerAgentStartName(string server)
        {
            ManagementPath path = new ManagementPath( @"\\" + server + @"\ROOT\cimv2:Win32_Service.Name='SQLSERVERAGENT'");
            string startname = string.Empty;

            ManagementObject service = new ManagementObject(path);
            startname = service.Properties["StartName"].Value.ToString();

            return startname;
        }

        static private ManagementObject _GetTrustee(string szServer, string szDomain, string szUsername)
        {
            ManagementPath path = new ManagementPath( @"\\" + szServer + @"\ROOT\cimv2:Win32_Trustee");
            ManagementObject oUserAccount = null;

            try
            {
                oUserAccount = new ManagementClass(path);

                oUserAccount.Properties["Domain"].Value = szDomain;
                oUserAccount.Properties["Name"].Value = szUsername;
            }
            catch
            {
                throw;
            }

            return oUserAccount;
        }

        static private ManagementObject _GetAce(string szServer, ManagementObject oUserAccount)
        {
            ManagementPath path = new ManagementPath( @"\\" + szServer + @"\ROOT\cimv2:Win32_Ace");
            ManagementObject oAce = null;

            try
            {
                oAce = new ManagementClass(path);

                oAce.Properties["AccessMask"].Value = 0x1F01FF; // This is basically full control
                oAce.Properties["AceFlags"].Value = 0x13; // Inherit settings
                oAce.Properties["AceType"].Value = 0; // Access allowed
                oAce.Properties["Trustee"].Value = oUserAccount;
            }
            catch
            {
                throw;
            }

            return oAce;
        }

        private void _SetNTFSPermissionsOnDirectory(string szServer, string szDirectory, string szUsername)
        {
            ManagementPath path = new ManagementPath( @"\\" + szServer + @"\ROOT\cimv2:Win32_LogicalFileSecuritySetting.Path='" +
                szDirectory + "'");

            LogInfo("Setting NTFS permissions on directory '" + szDirectory + "' at '" + szServer + "' for '" + szUsername + "'");
            try
            {
                _SetPermissions(path, szServer, szUsername);
            }
            catch (Exception e)
            {
                LogException(string.Format("Error trying to set NTFS permissions on {0}.",
                    szDirectory), e);
                Interlocked.Increment(ref m_iErrors);
            }
        }

        private void _SetSharePermissions(string szServer, string szShare, string szUsername)
        {
            ManagementPath path = new ManagementPath( @"\\" + szServer + @"\ROOT\cimv2:Win32_LogicalShareSecuritySetting.Name='" +
                szShare + "'");

            LogInfo("Setting permissions on share '" + szShare + "' at '" + szServer + "' for '" + szUsername + "'");
            try
            {
                _SetPermissions(path, szServer, szUsername);
            }
            catch (Exception e)
            {
                LogException(string.Format("Error trying to set share permissions on {0}.",
                    szShare), e);
                Interlocked.Increment(ref m_iErrors);
            }
        }

        private void _SetPermissions(ManagementPath path, string szServer, string szUsername)
        {
            uint iRet = 0;
            string loc = "unknown";

            ManagementObject oUserAccount;
            ManagementObject oAce;

            string szBareUsername;
            string szDomain;

            if (szUsername.Contains(@"\"))
            {
                szDomain = szUsername.Split(new char[] {'\\'})[0];
                szBareUsername = szUsername.Split(new char[] {'\\'})[1];
            }
            else
            {
                szDomain = szServer;
                szBareUsername = szUsername;
            }

            if ("NetworkService" == szBareUsername)
            {
                szBareUsername = "NETWORK SERVICE";
            }
            else if ("LocalSystem" == szBareUsername)
            {
                szDomain = "NT AUTHORITY";
                szBareUsername = "SYSTEM";
            }

            oUserAccount = _GetTrustee(szServer, szDomain, szBareUsername);
            oAce = _GetAce(szServer, oUserAccount);

            try
            {
                ManagementObject oDirectory = new ManagementObject(path);

                loc = "GetSecurityDescriptor";
                ManagementBaseObject outParams = oDirectory.InvokeMethod("GetSecurityDescriptor", null, null);

                ManagementBaseObject oDescriptor = (ManagementBaseObject)outParams.Properties["Descriptor"].Value;
                ManagementBaseObject[] rgDacl = (ManagementBaseObject[])oDescriptor.Properties["Dacl"].Value;

                //
                // Only set permissions if we can't find the user in the existing ACL tree
                //
                if (null != rgDacl)
                {
                    foreach (ManagementBaseObject oDacl in rgDacl)
                    {
                        ManagementBaseObject oTrustee = oDacl["Trustee"] as ManagementBaseObject;
                        if (null != oTrustee)
                        {
                            Int32 iAccessMask;

                            if ((null == oTrustee.Properties["Domain"].Value) ||
                                (String.IsNullOrEmpty(oTrustee.Properties["Domain"].Value.ToString())) ||
                                (null == oTrustee.Properties["Name"].Value) ||
                                (String.IsNullOrEmpty(oTrustee.Properties["Name"].Value.ToString())) ||
                                (null == oDacl.Properties["AccessMask"].Value) ||
                                (String.IsNullOrEmpty(oDacl.Properties["AccessMask"].Value.ToString())) ||
                                !(Int32.TryParse(oDacl.Properties["AccessMask"].Value.ToString(), out iAccessMask)))
                                continue;

                            if ((oTrustee.Properties["Domain"].Value.ToString().ToLower() == szDomain.ToLower()) &&
                                (oTrustee.Properties["Name"].Value.ToString().ToLower() == szBareUsername.ToLower()) &&
                                ((iAccessMask & 0x1F01FF) == 0x1F01FF))
                            {
                                return;
                            }
                        }
                    }
                }

                List<ManagementBaseObject> rgNewDacl;

                if (null != rgDacl)
                {
                    rgNewDacl = new List<ManagementBaseObject>(rgDacl);
                }
                else
                {
                    rgNewDacl = new List<ManagementBaseObject>();
                }
                rgNewDacl.Add(oAce);

                oDescriptor.Properties["Dacl"].Value = rgNewDacl.ToArray();

                loc = "SetSecurityDescriptor";
                ManagementBaseObject inParams = oDirectory.GetMethodParameters("SetSecurityDescriptor");

                inParams.Properties["Descriptor"].Value = oDescriptor;

                outParams = oDirectory.InvokeMethod("SetSecurityDescriptor", inParams, null);
                iRet = (uint)outParams["returnValue"];
            }
            catch (ManagementException ex)
            {
                if (ex.ErrorCode == ManagementStatus.NotFound)
                {
                    return;
                }
                throw;
            }

            if (iRet!=0)
            {
                throw new ApplicationException(WmiErrorText(iRet) + " from cimv2:" + loc);
            }
        }

        private bool _VerifyNTFSPermissionsOnDirectory(
            string szServer,
            string szDirectory,
            string szUsername
            )
        {
            ManagementPath path = new ManagementPath( @"\\" + szServer + @"\ROOT\cimv2:Win32_LogicalFileSecuritySetting.Path='" +
                szDirectory + "'");

            try
            {
                return _VerifyPermissions(path, szServer, szUsername);
            }
            catch (Exception e)
            {
                LogException(string.Format("Error trying to verify NTFS permissions on {0}.",
                    szDirectory), e);
                Interlocked.Increment(ref m_iErrors);
            }

            return false;
        }

        private bool _VerifySharePermissions(
            string szServer,
            string szShare,
            string szUsername
            )
        {
            ManagementPath path = new ManagementPath( @"\\" + szServer + @"\ROOT\cimv2:Win32_LogicalShareSecuritySetting.Name='" +
                szShare + "'");

            try
            {
                return _VerifyPermissions(path, szServer, szUsername);
            }
            catch (Exception e)
            {
                LogException(string.Format("Error trying to verify share permissions on {0}.",
                    szShare), e);
                Interlocked.Increment(ref m_iErrors);
            }

            return false;
        }

        private bool _VerifyPermissions(
            ManagementPath path,
            string szServer,
            string szUsername
            )
        {
            uint iRet = 0;
            string loc = "unknown";

            ManagementObject oUserAccount;
            ManagementObject oAce;

            string szBareUsername;
            string szDomain;

            if (szUsername.Contains(@"\"))
            {
                szDomain = szUsername.Split(new char[] {'\\'})[0];
                szBareUsername = szUsername.Split(new char[] {'\\'})[1];
            }
            else
            {
                szDomain = szServer;
                szBareUsername = szUsername;
            }

            if ("NetworkService" == szBareUsername)
            {
                szBareUsername = "NETWORK SERVICE";
            }
            else if ("LocalSystem" == szBareUsername)
            {
                szDomain = "NT AUTHORITY";
                szBareUsername = "SYSTEM";
            }
            oUserAccount = _GetTrustee(szServer, szDomain, szBareUsername);
            oAce = _GetAce(szServer, oUserAccount);

            try
            {
                ManagementObject oDirectory = new ManagementObject(path);

                loc = "GetSecurityDescriptor";
                ManagementBaseObject outParams = oDirectory.InvokeMethod("GetSecurityDescriptor", null, null);

                ManagementBaseObject oDescriptor = (ManagementBaseObject)outParams.Properties["Descriptor"].Value;
                ManagementBaseObject[] rgDacl = (ManagementBaseObject[])oDescriptor.Properties["Dacl"].Value;

                //
                // If we find the user in the existing ACL tree with the correct permissions, return true
                //
                if (null == rgDacl)
                {
                    return false;
                }

                foreach (ManagementBaseObject oDacl in rgDacl)
                {
                    ManagementBaseObject oTrustee = oDacl["Trustee"] as ManagementBaseObject;
                    if (null != oTrustee)
                    {
                        Int32 iAccessMask;

                        if ((null == oTrustee.Properties["Domain"].Value) ||
                            (String.IsNullOrEmpty(oTrustee.Properties["Domain"].Value.ToString())) ||
                            (null == oTrustee.Properties["Name"].Value) ||
                            (String.IsNullOrEmpty(oTrustee.Properties["Name"].Value.ToString())) ||
                            (null == oDacl.Properties["AccessMask"].Value) ||
                            (String.IsNullOrEmpty(oDacl.Properties["AccessMask"].Value.ToString())) ||
                            !(Int32.TryParse(oDacl.Properties["AccessMask"].Value.ToString(), out iAccessMask)))
                            continue;

                        if ((oTrustee.Properties["Domain"].Value.ToString().ToLower() == szDomain.ToLower()) &&
                            (oTrustee.Properties["Name"].Value.ToString().ToLower() == szBareUsername.ToLower()) &&
                            ((iAccessMask & 0x1F01FF) == 0x1F01FF))
                        {
                            return true;
                        }
                    }
                }
            }
            catch (ManagementException ex)
            {
                if (ex.ErrorCode == ManagementStatus.NotFound)
                {
                    return false;
                }
                throw;
            }

            if (iRet!=0)
            {
                throw new ApplicationException(WmiErrorText(iRet) + " from cimv2:" + loc);
            }

            return false;
        }

        private void _DisableSnapshotAgentSchedule(
            string szServer,
            string szPublicationDb,
            string szPublication
            )
        {
            Server pServer;
            ServerConnection pConnDist;
            ServerConnection pConnPub;
            DistributionPublication pPublication;
            Job pJob;

            pConnDist = new ServerConnection(_GetMappedDistributionServerName(szServer));
            pConnPub = new ServerConnection(szServer);

            try
            {
                pServer = new Server(pConnPub);
                pConnPub.Connect();
                pConnDist.Connect();

                string szDistributionDb = _GetDistributionDatabaseName(pConnDist.TrueName);

                pPublication = new DistributionPublication(szPublication, szDistributionDb, szServer, szPublicationDb, pConnDist);
                if (!pPublication.LoadProperties())
                {
                    Log(string.Format("Unable to find publication {0}.{1} on {2}.", szPublicationDb, szPublication, szServer));
                    Interlocked.Increment(ref m_iErrors);
                    return;
                }

                //
                // Disable the snapshot agent
                //
                pJob = pServer.JobServer.Jobs[pPublication.SnapshotAgent];
                if (null != pJob)
                {
                    pJob.RemoveAllJobSchedules();
                }
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception disabling the snapshot agent schedule on {0} of database {1} and publication {2}.",
                    szServer, szPublicationDb, szPublication), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pConnPub.Disconnect();
                pConnDist.Disconnect();
            }
        }

        private void _UpdateLogreaderAgentSchedules(
            string szServer,
            string szPublicationDb
            )
        {
            Server pServer;
            ServerConnection pConn;
            ReplicationDatabase pPublicationDb;
            Job pJob;

            pConn = new ServerConnection(szServer);

            string szTrueName = pConn.TrueName;
            pConn = new ServerConnection(szTrueName);

            try
            {
                pServer = new Server(pConn);
                pConn.Connect();

                pPublicationDb = new ReplicationDatabase(szPublicationDb, pConn);
                if (!pPublicationDb.LoadProperties())
                {
                    Log(string.Format("Unable to find database {0} on {1}.", szPublicationDb, szServer));
                    Interlocked.Increment(ref m_iErrors);
                    return;
                }

                //
                // Set the schedule for the log reader
                //
                pJob = pServer.JobServer.Jobs[pPublicationDb.LogReaderAgentName];
                if (null != pJob)
                {
                    _UpdateJobSchedule( pJob );
                }
                /*
                //
                // Set the schedule for all associated distributors
                //
                foreach (TransPublication pPublication in pPublicationDb.TransPublications)
                {
                    foreach (TransSubscription pSubscription in pPublication.TransSubscriptions)
                    {
                        pJob = pServer.JobServer.Jobs[pSubscription.SynchronizationAgentName];
                        if (null != pJob)
                        {
                            _UpdateJobSchedule( pJob );
                        }
                    }
                }
                */
            }
            catch (Exception e)
            {
                LogException(string.Format("Unhandled exception updating the log reader agent schedule on {0} of database {1}.",
                    szServer, szPublicationDb), e);
                Interlocked.Increment(ref m_iErrors);
            }
            finally
            {
                pConn.Disconnect();
            }
        }

        private void _UpdateJobSchedule(
            Job pJob
            )
        {
            JobSchedule pSched = pJob.JobSchedules[0];
            pSched.FrequencyTypes = FrequencyTypes.Daily;
            pSched.FrequencyInterval = 1;
            pSched.FrequencySubDayTypes = FrequencySubDayTypes.Minute;
            pSched.FrequencySubDayInterval = 1;
            pSched.FrequencyRelativeIntervals = FrequencyRelativeIntervals.First;
            pSched.FrequencyRecurrenceFactor = 0;
            pSched.ActiveStartDate = new DateTime(1990, 1, 1);
            pSched.ActiveStartTimeOfDay = new TimeSpan(0, 0, 0);
            pSched.Alter();

            LogInfo("Updated Agent Job: " + pJob.Name);
        }

        private string _GetDistributionDatabaseName(string szServer)
        {
            if (m_hashDistributionDB.Contains(szServer))
            {
                return m_hashDistributionDB[szServer].ToString();
            }
            else
            {
                return m_szDistributionDb;
            }
        }

        private IInterfaceInfo _GetMappedDistributionServer(string szServer)
        {
            if (m_hashRemoteDistributionMap.Contains(szServer))
            {
                return ((IInterfaceInfo) m_hashRemoteDistributionMap[szServer]);
            }
            else
            {
                return null;
            }
        }

        private string _GetMappedDistributionServerName(string szServer)
        {
            if (m_hashRemoteDistributionMap.Contains(szServer))
            {
                return ((IInterfaceInfo) m_hashRemoteDistributionMap[szServer]).ServerName;
            }
            else
            {
                return szServer;
            }
        }

        // wmi error code for Win32_Process.Create, Win32_Share.Delete and Win32_Share.Create
        static private string WmiErrorText(uint errorCode)
        {
            switch (errorCode)
            {
                case 0:  return "No error";
                case 2:  return "Access denied";
                case 3:  return "Insufficient privilege";
                case 8:  return "Unknown failure";
                case 9:  return "Invalid name";
                case 10: return "Invalid level";
                case 21: return "Invalid parameter";
                case 22: return "Duplicate share";
                case 23: return "Redirected path";
                case 24: return "Unknown device or directory";
                case 25: return "Net name not found";
                default: return string.Format("unknown error ({0})", errorCode);
            }
        }

        static private void Log(
            string szLog,
            bool fError
            )
        {
            string szLogWithTime;

            szLogWithTime = string.Format("{0}: {1}", DateTime.Now.ToLongTimeString(), szLog);
            Console.WriteLine( szLogWithTime );
            if( fError )
            {
                Console.Error.WriteLine( szLogWithTime );
            }
        }

        static private void Log(
            string szLog
            )
        {
            Log(szLog, true);
        }

        static private void LogVerbose(
            string szLog
            )
        {
            if (s_fVerbose)
            {
                Log(szLog, false);
            }
        }

        static private void LogInfo(
            string szLog
            )
        {
            Log(szLog, false);
        }

        static object objLock = new object();

        static private void LogException(
            string szLog,
            Exception e
            )
        {
            LogException(szLog, e, true);
        }

        static private void LogException(
            string szLog,
            Exception e,
            bool fError
            )
        {
            lock (objLock)
            {
                Log(szLog + "  Exception Messages follow:", fError);
                Log("Exception stack:", fError);
                Log("--------------", fError);
                Log(e.StackTrace, fError);

                int i = 0;
                do
                {
                    Log("--------------", fError);
                    Log(string.Format("Exception {0}: Type:{1}, Message: [[{2}]]", i, e.GetType().Name, e.Message), fError);
                    e = e.InnerException;
                    i++;
                } while (e != null);
                Log("==============", fError);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\core\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_3_none_12.4.56.0_none_e91db5cc1ac36456
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_MANIFEST_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_CATALOG_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_PAYLOAD_PATH=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\core\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_3_none_12.4.56.0_none_e91db5cc1ac36456
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_MANIFEST_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_CATALOG_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_PAYLOAD_PATH=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\installer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\installer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\console\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\installer\RosettaInstallInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using xonline.tools.reporting.rosetta.core;

namespace xonline.tools.reporting.rosetta.installer
{
    [RunInstaller(true)]
    public class RosettaInstallInstaller : System.Configuration.Install.Installer
    {
        private EventLog _eventLog;

        public RosettaInstallInstaller( )
        {
            _eventLog = new EventLog( );
            _eventLog.Log = "Application";
            _eventLog.Source = "RosettaInstaller";
        }

        public override void Install(IDictionary stateSaver)
        {
            string message = null;
            string szReportMgrPath;

            base.Install (stateSaver);

            RosettaInstall pRosetta;

            szReportMgrPath = Path.GetDirectoryName(Context.Parameters[ "xlreportmgrDir" ]);

            try
            {
                message = String.Format("Rosetta Installer started processing at {0}",  DateTime.Now.ToString());
                _eventLog.WriteEntry(message, EventLogEntryType.Information);
                Context.LogMessage(message);

                pRosetta = new RosettaInstall( );
                pRosetta.OnMessage += new MessageEventHandler(_OnMessage);
                pRosetta.Execute( szReportMgrPath );
            }
            catch( Exception exc )
            {
                Context.LogMessage( "ERROR: Exception encountered executing RosettaInstall. - " + exc.Message );
                Context.LogMessage( exc.ToString( ) );
                _eventLog.WriteEntry( "ERROR: Exception encountered executing RosettaInstall: \r\n" + exc.ToString( ), EventLogEntryType.Error, 65000 );
                throw exc;
            }
        }

        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            base.Commit (savedState);
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);
        }

        private void _OnMessage(object sender, MessageEventArgs e)
        {
            Context.LogMessage(e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\console\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\console\ReportSSASConsole.cs ===
using System;
using System.IO;
using System.Xml;
using xonline.tools.reporting.ssas.core;

namespace xonline.tools.reporting.ssas.console
{
    class ReportSSASConsole
    {
        [STAThread]
        static void Main( string[] rgszArgs )
        {
            CubeInstall pCubeInstall;

                pCubeInstall = new CubeInstall( );
                try
                {
                    pCubeInstall.Execute(rgszArgs[0]);
                }
                catch( Exception exc )
                {
                    Console.WriteLine( exc.ToString( ) );
                }
            }


        static void Usage( )
        {
            Console.WriteLine( "Usage: CubeInstall.exe <XML File>" );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\core\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_1_none_12.4.56.0_none_e91db2001ac36a08
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.manifest
XP_MANIFEST_PATH=manifests\x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.cat
XP_CATALOG_PATH=manifests\x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.cat
XP_PAYLOAD_PATH=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\RosettaInstall\core\RosettaInstall.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Management;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.RegularExpressions;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.wmi.iisv2;

namespace xonline.tools.reporting.rosetta.core
{
    class RosettaInstall
    {
        private ManagementClass rosettaRSConfigSettingsManagementClass = null;
        private StringBuilder m_szOutput = new StringBuilder("");
        private int m_iOutput = 0;

        public virtual ManagementClass MSReportServerConfigurationSettingsClass
        {
            get
            {
                if (rosettaRSConfigSettingsManagementClass == null)
                {
                    ConnectionOptions cnOpts = new ConnectionOptions();
                    cnOpts.Authentication = AuthenticationLevel.Default;

                    ManagementScope rosettaManagementScope = new ManagementScope(@"\\"+ Config.Server +@"\root\Microsoft\SqlServer\ReportServer\v9", cnOpts);
                    rosettaManagementScope.Connect();

                    ObjectGetOptions getOptions = new ObjectGetOptions();
                    getOptions.Timeout = new System.TimeSpan(0,0,30);

                    ManagementScope pRSConfigscope = null;

                    pRSConfigscope = new ManagementScope(@"\\"+ Config.Server +@"\root\Microsoft\SqlServer\ReportServer\v9\Admin", cnOpts);
                    pRSConfigscope.Connect();

                    ManagementPath path = new ManagementPath("MSReportServer_ConfigurationSetting");
                    rosettaRSConfigSettingsManagementClass = new ManagementClass(pRSConfigscope, path, getOptions);
                }
                return rosettaRSConfigSettingsManagementClass;
            }
        }

        public void Execute( string szReportMgrPath )
        {
            IInterfaceInfo iiInfo;
            string[] rgszServers;

            string szReportingDB;
            string szReportRealtimeDB;
            string szOLAPGameDB;
            string szOLAPCruxDB;
            string szOLAPAchDB;
            string szOLAPRealtimeDB;
            string szOLAPCdbCruxDB;
            string szRosettaUser;
            string szRosettaPassword;
            string szRSUtilPath;
            string szRosettaURL;
            string[] rgszAllowedIPs;

            string szDeleteRosettaRoot;
            string installationErrorString = "/************************************************\r\nError in RosettaInstaller.cs. Please investigate immediately.\r\n";
            bool fSetupSubscriptions;

            CSetupSecureResolver setupResolver = new CSetupSecureResolver();

            string szCurrDir;
            string szError;

            Process procSetup;
            ProcessStartInfo psInfo;
            int iExitCode;
            ManagementObjectCollection pInstances;

            bool fSSLCertAvailable;
            bool fInstallReports;

            fSSLCertAvailable = _IsSSLCertificatePresent();
            fInstallReports = _IsPrimaryRosettaWebsite();

            //
            // Some WMI setup work so we can do cool WMI things
            //
            XomIisConfigurator pConfigurator = new XomIisConfigurator();
            ManagementScope mScope = pConfigurator.IisManagementScope;
            ManagementClass pRSClass = MSReportServerConfigurationSettingsClass;

            IIsWebService webService = new IIsWebService(mScope, "W3SVC");

            //
            // Pull out the allowed IP list from npdb
            //
            rgszAllowedIPs = Config.GetMultiSetting( MultiSetting.reporting_ReportServerAllowedIPs );

            //
            // Set up the auth restrictions on the Reports vdir
            //
            IIsWebVirtualDirSetting.IIsWebVirtualDirSettingCollection pReportsCollection =
                IIsWebVirtualDirSetting.GetInstances();

            foreach( IIsWebVirtualDirSetting pDirSetting in pReportsCollection )
            {
                if( String.Compare( pDirSetting.Name, "W3SVC/1/ROOT/Reports", true ) == 0 )
                {
                    if( fSSLCertAvailable )
                    {
                        // Require SSL
                        // Require Client SSL Cert Negotiation
                        // Require Client SSL Cert
                        pDirSetting.AccessSSLFlags = 0x68;
                    }
                    else
                    {
                        pDirSetting.AccessSSLFlags = 0x0;
                    }

                    // NTLM Auth
                    pDirSetting.AuthFlags = 0x4;

                    pDirSetting.CommitObject();
                }
            }

            //
            // Set up the auth restrictions on the ReportServer vdir
            //
            IIsWebVirtualDirSetting.IIsWebVirtualDirSettingCollection pReportServerCollection =
                IIsWebVirtualDirSetting.GetInstances();

            foreach( IIsWebVirtualDirSetting pDirSetting in pReportServerCollection )
            {
                if( String.Compare( pDirSetting.Name, "W3SVC/1/ROOT/ReportServer", true ) == 0 )
                {
                    pDirSetting.AccessSSLFlags = 0x0;

                    // NTLM Auth
                    pDirSetting.AuthFlags = 0x4;

                    pDirSetting.CommitObject();
                }
            }

            //
            // Set up the IP restrictions on the ReportServer vdir
            //
            IIsIPSecuritySetting.IIsIPSecuritySettingCollection pReportServerIPCollection =
                IIsIPSecuritySetting.GetInstances();

            foreach( IIsIPSecuritySetting pIPSecSetting in pReportServerIPCollection )
            {
                if( String.Compare( pIPSecSetting.Name, "W3SVC/1/ROOT/ReportServer", true ) == 0 )
                {
                    ArrayList rgAllow = new ArrayList();

                    //
                    // Build the list of local IP addresses
                    //
                    IPHostEntry pHostEntry = Dns.GetHostEntry(Dns.GetHostName());
                    foreach(IPAddress ipA in pHostEntry.AddressList)
                    {
                        rgAllow.Add( ipA.ToString() );
                    }

                    if( !rgAllow.Contains( "127.0.0.1" ) )
                    {
                        rgAllow.Add( "127.0.0.1" );
                    }

                    foreach( string szIP in rgszAllowedIPs )
                    {
                        if( !rgAllow.Contains( szIP ) )
                        {
                            rgAllow.Add( szIP );
                        }
                    }

                    pIPSecSetting.GrantByDefault = false;
                    pIPSecSetting.IPGrant = (string[]) rgAllow.ToArray( typeof( string ) );

                    pIPSecSetting.CommitObject();
                }
            }

            if( fInstallReports )
            {
                //
                // Find where rs.exe lives
                //
                szRSUtilPath = Config.GetSetting( Setting.reporting_RSUtilPath );

                if( !File.Exists( szRSUtilPath ) )
                {
                    throw new Exception( installationErrorString + "Unable to find RS.exe at the location: " + szRSUtilPath );
                }

                szCurrDir = Path.GetDirectoryName( Assembly.GetExecutingAssembly().GetModules()[0].FullyQualifiedName );

                //
                // Get the rosetta_user information for setting up the data sources
                //
                rgszServers = Config.GetServerListByInterface( Interface.rosetta );
                iiInfo = Config.GetInterface( rgszServers[0], Interface.rosetta );

                szRosettaUser = iiInfo.Username;
                szRosettaPassword = setupResolver.UserSecret( iiInfo.Password );

                szRosettaURL = "http://" + iiInfo.IPAddressString + "/ReportServer";

                //
                // Get the datasource connection information
                //
                rgszServers = Config.GetServerListByInterface( Interface.reportingdb );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString + "Unable to find a reportingdb server" );
                }
                szReportingDB = Config.GetInterface( rgszServers[0], Interface.reportingdb ).IPAddressString;

                rgszServers = Config.GetServerListByInterface( Interface.reportrealtimedb );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString +"Unable to find a reportrealtimedb server" );
                }
                szReportRealtimeDB = Config.GetInterface( rgszServers[0], Interface.reportrealtimedb ).IPAddressString;

                rgszServers = Config.GetServerListByInterface( Interface.olapGameUsage );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString + "Unable to find a game usage SSAS server" );
                }
                szOLAPGameDB = Config.GetInterface( rgszServers[0], Interface.olapGameUsage ).IPAddressString;

                rgszServers = Config.GetServerListByInterface( Interface.olapCruxUsage );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString + "Unable to find a video/music usage SSAS server" );
                }
                szOLAPCruxDB = Config.GetInterface( rgszServers[0], Interface.olapCruxUsage ).IPAddressString;

                rgszServers = Config.GetServerListByInterface( Interface.olapAchievements );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString + "Unable to find an achievements SSAS server" );
                }
                szOLAPAchDB = Config.GetInterface( rgszServers[0], Interface.olapAchievements ).IPAddressString;

                rgszServers = Config.GetServerListByInterface( Interface.olapRealtime );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString + "Unable to find a realtime usage SSAS server" );
                }
                szOLAPRealtimeDB = Config.GetInterface( rgszServers[0], Interface.olapRealtime ).IPAddressString;

                rgszServers = Config.GetServerListByInterface( Interface.olapCdbCruxUsage );
                if( 0 == rgszServers.Length )
                {
                    throw new Exception( installationErrorString + "Unable to find a unified catalog video/music usage SSAS server" );
                }
                szOLAPCdbCruxDB = Config.GetInterface( rgszServers[0], Interface.olapCdbCruxUsage ).IPAddressString;

                //
                // Should we delete the root folder
                //
                szDeleteRosettaRoot = Config.GetSetting( Setting.reporting_DeleteRoot );

                //
                // Set up email subscriptions on non-xblob environments
                //
                fSetupSubscriptions = Config.Environment.ToLower() != "xblob";

                try
                {
                    pRSClass.Get();
                }
                catch( Exception exc )
                {
                    throw new Exception( installationErrorString + "Could not get WMI information: " + exc.Message );
                }

                if( null == pRSClass )
                {
                    throw new Exception( installationErrorString + "No WMI class found. Unable to retrieve Reporting Services configuration." );
                }

                //
                // Disable SSL requirements on the ReportServer
                //
                pInstances = pRSClass.GetInstances();
                foreach(ManagementObject pInstance in pInstances)
                {
                    ManagementBaseObject pInParams = pInstance.GetMethodParameters("SetSecureConnectionLevel");
                    pInParams["Level"] = 0;

                    ManagementBaseObject pOutParams = pInstance.InvokeMethod("SetSecureConnectionLevel", pInParams, null);
                }

                //
                // Stop/start the web server so we can pick up changes we make to the
                // config file
                //
                webService.StopService();

                System.Threading.Thread.Sleep(15000);

                webService.StartService();

                //
                // Install with no SSL enabled
                //
                //IMPORTANT NOTE: To save time for the Feb 08 video cube release
                //we did not add a new server type for the Feb 08 video cube
                //and instead we are using the OlapCdbCruxDB server
                psInfo = new ProcessStartInfo( szRSUtilPath );
                psInfo.Arguments = "-i \"" + szCurrDir + "\\rosetta_setup.rss\" -s " + szRosettaURL + " -v rdlsrc=\"" +
                    szCurrDir + "\" -v LogFile=\"" + szCurrDir + "\\rs_setup.log\" -v ReportingDB=\"" + szReportingDB +
                    "\" -v ReportRealtimeDB=\"" + szReportRealtimeDB + "\" -v OlapDB=\"" + szOLAPGameDB + "\" -v OlapCruxDB=\"" +
                    szOLAPCruxDB + "\" -v OlapAchDB=\"" + szOLAPAchDB + "\" -v OlapRTDB=\"" + szOLAPRealtimeDB + "\" -v RosettaUser=\"" +
                    szRosettaUser + "\" -v RosettaPassword=\"" + szRosettaPassword + "\" -v DeleteRoot=\"" +
                    szDeleteRosettaRoot + "\" -v SetupSubscriptions=\"" + fSetupSubscriptions.ToString().ToLower() + "\" -v OlapCdbCruxDB=\"" +
                    szOLAPCdbCruxDB + "\" -v OlapVideoCube=\"" + szOLAPCdbCruxDB + "\" -t";
                psInfo.RedirectStandardOutput = true;
                psInfo.RedirectStandardError = true;
                psInfo.UseShellExecute = false;

                procSetup = new Process();
                procSetup.StartInfo = psInfo;
                procSetup.OutputDataReceived += new DataReceivedEventHandler(this._OutputHandler);

                procSetup.Start();

                procSetup.BeginOutputReadLine();
                szError = procSetup.StandardError.ReadToEnd();

                procSetup.WaitForExit();

                iExitCode = procSetup.ExitCode;

                procSetup.Close();

                if( 0 != iExitCode )
                {
                    throw new Exception( installationErrorString + "Failed to execute with arguments: [[" + psInfo.Arguments + "]]\r\n -- stdout was: [[" +
                        m_szOutput + "]]\r\n -- stderr was: [[" + szError + "]]" );
                }
            }

            //
            // Re-enable SSL on the ReportServer
            //
            if( fSSLCertAvailable )
            {
                pInstances = pRSClass.GetInstances();
                foreach(ManagementObject pInstance in pInstances)
                {
                    ManagementBaseObject pInParams = pInstance.GetMethodParameters("SetSecureConnectionLevel");
                    pInParams["Level"] = 3;

                    ManagementBaseObject pOutParams = pInstance.InvokeMethod("SetSecureConnectionLevel", pInParams, null);
                }
            }

            //
            // Stop/start the web server so we can pick up changes we make to the
            // config file
            //
            webService.StopService();

            System.Threading.Thread.Sleep(15000);

            webService.StartService();

            if( null != szReportMgrPath )
            {
                _SetupReportRecipientManager(szReportMgrPath, fSSLCertAvailable);
            }
        }

        private void _OutputHandler(object pSender, DataReceivedEventArgs pArgs)
        {
            if( !String.IsNullOrEmpty(pArgs.Data) )
            {
                m_iOutput++;
                m_szOutput.Append(Environment.NewLine + "[" + m_iOutput.ToString() + "] - " + pArgs.Data);
            }
        }

        private bool _IsSSLCertificatePresent()
        {
            bool fRet;
            X509Store pStore;
            X509Certificate2Collection pCollection;
            Regex reCert;

            fRet = false;

            reCert = new Regex( @"reports.*xboxlive\.com" );
            pStore = new X509Store( StoreName.My, StoreLocation.LocalMachine );
            pStore.Open( OpenFlags.ReadOnly );

            pCollection = pStore.Certificates as X509Certificate2Collection;
            if( null != pCollection )
            {
                foreach( X509Certificate2 pCert in pCollection )
                {
                    Match maCert = reCert.Match( pCert.FriendlyName );

                    if( maCert.Success )
                    {
                        fRet = true;
                        break;
                    }
                }
            }

            return fRet;
        }

        private bool _IsPrimaryRosettaWebsite()
        {
            bool fRet;
            string[] rgszServers;

            fRet = false;

            rgszServers = Config.GetServerListByInterface( Interface.rosetta );
            if( rgszServers[0].ToLower() == Config.Server.ToLower() )
            {
                fRet = true;
            }

            return fRet;
        }

        private void _SetupReportRecipientManager(string szPath, bool fSSLCertAvailable)
        {
            XomIisConfigurator pConfigurator = new XomIisConfigurator();
            ManagementScope mScope = pConfigurator.IisManagementScope;
            IIsWebVirtualDirSetting pDirSetting;
            IIsWebVirtualDir pVirtDir;

            string szKeyName;

            szKeyName = "W3SVC/1/ROOT/ReportRecipient";

            pDirSetting = new IIsWebVirtualDirSetting(mScope, szKeyName);
            try
            {
                pDirSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The virtual directory did not exist. ignore the exception
                LogMessage("Exception Deleting VDir: " + szKeyName);
            }

            pVirtDir = IIsWebVirtualDir.CreateInstance();

            pVirtDir.LateBoundObject["Name"] = szKeyName;
            pVirtDir.CommitObject();

            pVirtDir.AppCreate3(2, "DefaultAppPool", false);

            pDirSetting = new IIsWebVirtualDirSetting(mScope, szKeyName);

            pDirSetting.AppFriendlyName = "ReportRecipient Application";
            pDirSetting.Path0 = szPath;

            if( fSSLCertAvailable )
            {
                // Require SSL
                // Require Client SSL Cert Negotiation
                // Require Client SSL Cert
                pDirSetting.AccessSSLFlags = 0x68;
            }
            else
            {
                pDirSetting.AccessSSLFlags = 0x0;
            }

            // NTLM Auth
            pDirSetting.AuthFlags = 0x4;

            pDirSetting.CommitObject();
        }

        public event MessageEventHandler OnMessage;

        public void LogMessage(string message)
        {
            MessageEventArgs e = new MessageEventArgs(message);
            OnMessageNotifier(e);
        }

        protected virtual void OnMessageNotifier(MessageEventArgs e)
        {
            if (OnMessage != null)
            {
                // Invokes the delegates.
                OnMessage(this, e);
            }
        }
    }

    public delegate void MessageEventHandler(object sender, MessageEventArgs e);
    public class MessageEventArgs : EventArgs
    {
        private string message = "";

        /// <summary>
        ///
        /// </summary>
        /// <param name="message"></param>
        public MessageEventArgs(string message)
        {
            Message = message;
        }

        /// <summary>
        ///
        /// </summary>
        public string Message
        {
            get {return message;}
            set
            {
                if (value == null)
                {
                    message = "";
                }
                else
                {
                    message = value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\core\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_1_none_12.4.56.0_none_e91db2001ac36a08
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.manifest
XP_MANIFEST_PATH=manifests\x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.cat
XP_CATALOG_PATH=manifests\x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6.cat
XP_PAYLOAD_PATH=x86__core_1_no-public-key_12.4.56.0_x-ww_c4dbfae6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\installer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\installer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSASQueryCube\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSASQueryCube\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\installer\ReportSSASInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Reflection;

using xonline.tools.reporting.ssas.core;

namespace xonline.tools.reporting.ssas.installer
{
    [RunInstaller(true)]
    public class ReportSSASInstaller : System.Configuration.Install.Installer
    {
        private EventLog _eventLog;

        public ReportSSASInstaller( )
        {
            _eventLog = new EventLog( );
            _eventLog.Log = "Application";
            _eventLog.Source = "ReportSSASInstaller";
        }

        public override void Install(IDictionary stateSaver)
        {
            base.Install (stateSaver);

            CubeInstall pCubeInstall;
            string szXmlFile;

            szXmlFile = Context.Parameters[ "ReportSSASFile" ];

            try
            {
                pCubeInstall = new CubeInstall( );
                pCubeInstall.Execute(szXmlFile);
            }
            catch( Exception exc )
            {
                Context.LogMessage( "ERROR: Exception encountered executing ReportSSAS. - " + exc.Message );
                Context.LogMessage( exc.ToString( ) );
                _eventLog.WriteEntry( "ERROR: Exception encountered executing ReportSSAS: \r\n" + exc.ToString( ), EventLogEntryType.Error, 65000 );
                throw;
            }
        }

        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            base.Commit (savedState);
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\console\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\console\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSAS\core\ReportSSAS.cs ===
using System;
using System.IO;
using System.Xml;
using System.Net;
using System.Net.Sockets;


using Microsoft.AnalysisServices;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.tools.reporting.ssas.core
{
    class CubeInstall
    {
        static string OlapRoleNameXmlPath = "def:ObjectDefinition/def:Role/def:Name";
        static string OlapRoleMemberNameXmlPath = "def:ObjectDefinition/def:Role/def:Members/def:Member/def:Name";
        static string OlapRoleInterfaceNameXmlPath = "def:ParentObject/def:DatabaseID";
        static string OlapPermissionsFileName = "OlapCubePermissions";
        static string OlapPermissionsGrantingFileName = "OlapCubePermissionsGranting";
        static string OlapObjectDatabaseIDXmlPath = "def:Object/def:DatabaseID";

        public void Execute(string szXmlFile)
        {
            XmlDocument xmlDoc;
            XmlNodeList xmlList;
            string szInterface;
            string szXmlaFile;
            string szXmlaPath;
            IInterfaceInfo face;

            szXmlaPath = Path.GetFullPath(Path.GetDirectoryName(szXmlFile));

            xmlDoc = new XmlDocument( );
            xmlDoc.Load( szXmlFile );

            xmlList = xmlDoc.DocumentElement.SelectNodes( "SSASDatabases/Database" );
            foreach (XmlNode xnT in xmlList)
            {
                szInterface = xnT.Attributes["Interface"].Value;
                szXmlaFile = xnT.Attributes["File"].Value;
                face = GetServerInterface(szInterface);
                if (face != null)
                {
                    InstallOlapDb(szXmlaFile, szXmlaPath, szInterface, face);
                }
            }
        }

        private IInterfaceInfo GetServerInterface(string faceName)
        {
            string[]  rgszServers = Config.GetServerListByInterface( faceName );
            if ( rgszServers == null )
            {
                return null;
            }
            IPHostEntry iphostentry = Dns.GetHostEntry(Dns.GetHostName());
            IInterfaceInfo face = null;
            IInterfaceInfo curFace = null;

            for(int i=0; i < rgszServers.Length; i++)
            {
                curFace = Config.GetInterface(rgszServers[i], faceName);
                foreach(IPAddress ipaddress in iphostentry.AddressList)
                {
                    if (curFace.IPAddress.Equals( ipaddress))
                    {
                        face = curFace;
                        break;
                    }
                }
                if (face != null)
                {
                    break;
                }
            }
            return face;
        }

        //josszy -- changing from error count to immediate execption throwing
        private void InstallOlapDb(string xmlFile, string xmlaPath, string faceName, IInterfaceInfo face)
        {
            Microsoft.AnalysisServices.Server olapServer;
            Microsoft.AnalysisServices.Database olapDb;
            Microsoft.AnalysisServices.XmlaResultCollection resColl;

            int errorCount = 0;
            int warningCount = 0;

            XmlDocument xmlDoc;
            string szDatabase;
            string[] rgszServers;
            IInterfaceInfo iiInfo;
            xmlDoc = new XmlDocument();

            xmlDoc.Load(Path.Combine(xmlaPath, xmlFile));

            XmlNamespaceManager nsmgr = new XmlNamespaceManager( xmlDoc.NameTable );
            nsmgr.AddNamespace( String.Empty, "http://schemas.microsoft.com/analysisservices/2003/engine" );
            nsmgr.AddNamespace( "def", "http://schemas.microsoft.com/analysisservices/2003/engine" );
            nsmgr.AddNamespace( "xsd", "http://www.w3.org/2001/XMLSchema" );
            nsmgr.AddNamespace( "xsi", "http://www.w3.org/2001/XMLSchema-instance" );

            //
            // Only handle creates and alters
            //
            if (xmlDoc.DocumentElement.Name.ToLower() != "create" && xmlDoc.DocumentElement.Name.ToLower() != "alter")
            {
                throw new ApplicationException( "Unexpected XML root element. Instead of <Create> or <Alter>, we received <" +
                    xmlDoc.DocumentElement.Name + ">" );
            }


            szDatabase = xmlDoc.DocumentElement.SelectSingleNode("def:ObjectDefinition/def:Database/def:Name", nsmgr).InnerXml;

            olapServer = new Microsoft.AnalysisServices.Server();
            olapServer.Connect( face.IPAddressString );

            olapDb = new Microsoft.AnalysisServices.Database();
            olapDb = olapServer.Databases.FindByName( szDatabase );

            if( null != olapDb )
            {
                olapDb.Drop();
            }

            resColl = olapServer.Execute( xmlDoc.OuterXml );
            foreach (XmlaResult res in resColl)
            {
                foreach (XmlaMessage msg in res.Messages)
                {
                    if (msg is XmlaError)
                    {
                        errorCount++;
                      Xom.NtEvent( XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube install failed. Error message returned: " + msg.Description );
                        throw new ApplicationException("Cube install failed in executing outerXML to create. This was a count error before." + msg.Description);

                    }
                    else if (msg is XmlaWarning)
                    {
                        warningCount++;
                    }
                }
            }

            //Why are we loading a new document? We need to use the same connection as before, so we can alter the object in scope.
            xmlDoc = new XmlDocument();
            //OlapPermissionsFileName creates a user group for the user.
            xmlDoc.Load(Path.Combine(xmlaPath, OlapPermissionsFileName) + ".xmla");
            //Alter the XML to load the correct user name for the environment
            try
            {
                string[] RosettaRgszServers = Config.GetServerListByInterface(Interface.rosetta);
                IInterfaceInfo iiInfoRosetta = Config.GetInterface(RosettaRgszServers[0], Interface.rosetta);

                string RosettaUser = iiInfoRosetta.Username;
                //Get rid of the domain name and the slash, leaving just the username. But first ensure we have a domain name.
                int whereDomainSlash = RosettaUser.IndexOf('\\');
                if ((whereDomainSlash > 0) && (whereDomainSlash < RosettaUser.Length))
                {
                    //Why the plus one? Because we don't want to include the slash in the domain name.
                    RosettaUser = RosettaUser.Substring(whereDomainSlash + 1);
                }

                XmlNode userAlterationNode = xmlDoc.DocumentElement.SelectSingleNode(OlapRoleNameXmlPath, nsmgr);
                userAlterationNode.InnerText = RosettaUser;

                userAlterationNode = xmlDoc.DocumentElement.SelectSingleNode(OlapRoleMemberNameXmlPath, nsmgr);
                userAlterationNode.InnerText = RosettaUser;

                userAlterationNode = xmlDoc.DocumentElement.SelectSingleNode(OlapRoleInterfaceNameXmlPath, nsmgr);
                userAlterationNode.InnerText = szDatabase;
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube install failed due to XML modification issue.");
                throw new ApplicationException("Cube install failed. Error information: " + e.Message);
            }
            resColl = olapServer.Execute(xmlDoc.OuterXml);
            foreach (XmlaResult res in resColl)
            {
                foreach (XmlaMessage msg in res.Messages)
                {
                    if (msg is XmlaError)
                    {
                        errorCount++;
                      Xom.NtEvent(XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube permission creation failed. Error message returned: " + msg.Description);
                        throw new ApplicationException("Cube install failed in  permissions creation. This was a count error before." + msg.Description);
                    }
                }
            }

            //Now, alter the role we just created to grant it the permissions we need, in the same connection.
            xmlDoc = new XmlDocument();
            //OlapPermissionsGrantingFileName alters the user group for the user to give it the permissions the group needs.
            xmlDoc.Load(Path.Combine(xmlaPath, OlapPermissionsGrantingFileName) + ".xmla");
            //Alter the XML to have the correct database name.
            try
            {
                XmlNode userAlterationNode = xmlDoc.DocumentElement.SelectSingleNode(OlapObjectDatabaseIDXmlPath, nsmgr);
                userAlterationNode.InnerText = szDatabase;
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube install failed due to XML permissions modification issue.");
                throw new ApplicationException("Cube install failed. Error information: " + e.Message);
            }
            resColl = olapServer.Execute(xmlDoc.OuterXml);
            foreach (XmlaResult res in resColl)
            {
                foreach (XmlaMessage msg in res.Messages)
                {
                    if (msg is XmlaError)
                    {
                        errorCount++;
                      Xom.NtEvent(XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube permission alteration failed. Error message returned: " + msg.Description);
                        throw new ApplicationException("Cube install failed in permission alteration. This was a count error before." + msg.Description);
                    }
                }
            }

            if (errorCount > 0)
            {
              Xom.NtEvent( XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube install failed. Number of errors found: " + errorCount );
                throw new ApplicationException("Cube install failed. Number of errors found: " + errorCount );
            }

            olapServer.Refresh();

            olapDb = olapServer.Databases.FindByName( szDatabase );
            if (olapDb == null)
            {
              Xom.NtEvent( XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cannot find OLAP database " + szDatabase );
                throw new ApplicationException( "Invalid configuration. OLAP database " + szDatabase + " does not exist.");
            }

            foreach( DataSource ds in olapDb.DataSources )
            {
                rgszServers = Config.GetServerListByInterface( ds.ID );
                if (rgszServers == null)
                {
                  Xom.NtEvent(  XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube install failed.  Configuration error. Unknown data source: "+ ds.ID );
                    throw new ApplicationException("Cube install failed. Data sources are misconfigured");
                }
                iiInfo = Config.GetInterface( rgszServers[0], ds.ID );

                if ( iiInfo == null )
                {
                  Xom.NtEvent(  XEvent.Id.REPORTING_CUBE_INSTALL_FAILED, "Cube install failed.  Configuration error. In order to build a cube there should be multiple data sources associated with OLAP cube.");
                    throw new ApplicationException("Cube install failed. Data sources are misconfigured");
                }
                ds.ConnectionString = string.Format( "Provider=SQLNCLI.1;Data Source={0};Integrated Security=SSPI;Initial Catalog={1}",
                    iiInfo.IPAddressString, iiInfo.DBName );

                ds.Update();
            }

            olapDb.Update();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\core\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_3_none_12.4.56.0_none_e91db5cc1ac36456
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_MANIFEST_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_CATALOG_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_PAYLOAD_PATH=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSASQueryCube\SSASQueryCube.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Microsoft.AnalysisServices;
using System.Collections;
using System.Collections.Specialized;
using System.Xml;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Threading;

using Microsoft.AnalysisServices.AdomdClient;
using System.Text.RegularExpressions;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

[assembly: XomAreaDefinition(XomAreaName.log)]


namespace SSASQueryCube
{
    class SSASQueryCube
    {
        static int Main(string[] args)
        {
            int hresult = 0;

            if(args.Length != 1)
            {
                Usage();
                return -1;
            }

           MDXQueryProcessor qp = new MDXQueryProcessor();
            try
            {               
                qp.Init();
                qp.QueryIDateTimeParameter = Int32.Parse(args[0]);//Convert.ToInt32(args[0],16);
                qp.Process();
            }
            catch (Exception e)
            {
                string message = "SSASQueryCube failed. Exception thrown: " + e.ToString();
              Xom.NtEvent(XEvent.Id.REPORTING_SSASQUERYCUBE_ERROR, string.Format ("SSASQueryCube failed. Exception thrown: {0} ", message));
                Xom.Log(XomAreaName.log, message);
                hresult = -1;
            }
            finally
            {
                qp.Cleanup();
            }
            return hresult;
        }

        static void Usage()
        {
            Console.WriteLine("Invalid usage. \nUsage: SSASQueryCube.exe <date>. <date> is an integer in HEXA decimal form for which the aggregates should be retrieved.");      
          Xom.NtEvent(XEvent.Id.REPORTING_SSASQUERYCUBE_ERROR, "Invalid parameters are passed to SSASQueryCube. The run failed");

        }
    }

    class MDXQueryProcessor
    {
        private string reportingdbConnectionString = "";
        private string cdbCruxConnectionString = "";
        private DataTable queryResultSet ;
        private int queryIDateTimeParameter; 

        public  int QueryIDateTimeParameter
        {
            get { return queryIDateTimeParameter;  }
            set { queryIDateTimeParameter = value; }
        }

        public void Init()
        {
            IInterfaceInfo face;
            // retrieve configuration  from Config object
            string [] rgszServers = Config.GetServerListByInterface( Interface.olapCdbCruxUsage );
            if( rgszServers.Length!= 1 )
            {
                throw new Exception(  "Cannot find olapCdbCruxUsage cube" );                
            }
            face = Config.GetInterface(rgszServers[0], Interface.olapCdbCruxUsage);
            cdbCruxConnectionString = face.SqlConnectionString;

            rgszServers = Config.GetServerListByInterface( Interface.reportingdb );
            if( rgszServers.Length!= 1 )
            {
                throw new Exception(  "Cannot find reportingdb" );                
            }
            face = Config.GetInterface(rgszServers[0], Interface.reportingdb);
            reportingdbConnectionString = face.SqlConnectionString;
        }

        public void Process()
        {
          Xom.NtEvent( XEvent.Id.REPORTING_SSASQUERYCUBE_INFO, string.Format ("SSASQueryCube started retrieving data for {0}", queryIDateTimeParameter.ToString()) );

            //create and load DataTable object based off t_rcdb_usage_aggregate_stage
            PrepareResultDataTable();

            //execute LTD MDX query
            ExecuteMDXQuery(usageAggregateType.mediaPurchaseCountTotal);
            //bulkcopy data into reportingdb
            WriteResultSet();
            
            queryResultSet.Clear();
            // execute daily MDX query
            ExecuteMDXQuery(usageAggregateType.mediaPurchaseCountDaily);
            // bulkcopy data into reportingdb
            WriteResultSet();

          Xom.NtEvent( XEvent.Id.REPORTING_SSASQUERYCUBE_INFO, string.Format ("SSASQueryCube finished retrieving data for {0}", queryIDateTimeParameter.ToString()) );

        }

        private void ExecuteMDXQuery(usageAggregateType queryType)
        {
            using(AdomdConnection cdbCruxConnection = new AdomdConnection(cdbCruxConnectionString))
            {
                cdbCruxConnection.Open();
                AdomdCommand command = new AdomdCommand();
                command.Connection = cdbCruxConnection;
                command.CommandText = queryType == usageAggregateType.mediaPurchaseCountTotal ? purchaseLTDMdx: string.Format(purchaseDailyMdxFormat, queryIDateTimeParameter);
                Xom.Log(XomAreaName.log, string.Format("Executing mdx query: {0}", command.CommandText));
                
                CellSet cs = command.ExecuteCellSet();
                int records = 0;
                
                for (int irow = 0; irow < cs.Axes[1].Set.Tuples.Count; irow++)
                    for (int icol = 0; icol < cs.Axes[0].Set.Tuples.Count; icol++)
                    {
                        string videoGuid = cs.Axes[1].Set.Tuples[irow].Members[0].Caption;
                        string countryCode = (cs.Axes[0].Set.Tuples[icol]).Members[0].Name;
                        
                        Regex regExCountryCode = new Regex(regExCountryCodeDef, RegexOptions.Compiled);
                        countryCode = regExCountryCode.Match(countryCode).Groups[0].Value;

                        string purchaseCount = null;
                        if (cs.Cells[icol, irow].CellProperties["FORMATTED_VALUE"].Value != null)                            
                        {
                            purchaseCount = cs.Cells[icol, irow].CellProperties["FORMATTED_VALUE"].Value.ToString();
                            Xom.Log(XomAreaName.log, string.Format("{0} : {1} : {2}", purchaseCount, videoGuid, countryCode));

                            DataRow dr = queryResultSet.NewRow();
                            dr["uid_media_id"] = videoGuid;
                            dr["ti_country_id"] = Convert.ToInt16(countryCode);
                            dr["i_date"] = queryIDateTimeParameter;
                            dr["i_usage_aggregate_type_id"] = queryType;
                            dr["bi_count"] = Convert.ToInt64(purchaseCount);
                            
                            queryResultSet.Rows.Add(dr);                        
                            records++;
                        }

                }

                Xom.Log(XomAreaName.log, string.Format("{0} sets retrieved from the cube", records.ToString()));

                
            }

        }


        private void PrepareResultDataTable()
        {
            queryResultSet = new DataTable();
            using(SqlConnection rdbConnection = new SqlConnection(reportingdbConnectionString))
            {
                rdbConnection.Open();
                
                SqlCommand command = rdbConnection.CreateCommand();
                command.CommandText = "p_rcdb_get_usage_aggregate_stage";
                command.CommandType = CommandType.StoredProcedure;
                SqlDataAdapter da = new SqlDataAdapter(command);
                da.Fill(queryResultSet);
            }
        }

        private void WriteResultSet()
        {
            using (SqlBulkCopy bulkcopy = new SqlBulkCopy(reportingdbConnectionString, SqlBulkCopyOptions.TableLock))
            {
                bulkcopy.DestinationTableName = "dbo.t_rcdb_usage_aggregate_stage";
                bulkcopy.WriteToServer(queryResultSet);
            }            
        }
        
        public void Cleanup()
        {
        }

        private static string purchaseLTDMdx = @"
            SELECT 
                NON EMPTY [UserRegionCountry].[Country].Children  ON COLUMNS,
                NON EMPTY [OfferInstance].[VideoGUID].Children ON ROWS
            FROM [Usage] 
            WHERE ([Measures].[OfferInstancePurchase])";

        private static string purchaseDailyMdxFormat = @"
            SELECT 
                NON EMPTY [UserRegionCountry].[Country].Children  ON COLUMNS,
                NON EMPTY [OfferInstance].[VideoGUID].Children ON ROWS
            FROM [Usage] 
            WHERE ([Measures].[OfferInstancePurchase], [Date].[Date].&[{0}])";

        private static string regExCountryCodeDef = @"(?<=\&\[)[0-9]+";

        private enum usageAggregateType            
        {
          mediaPurchaseCountTotal = 20, 
          mediaPurchaseCountDaily =21             
        }


    }

        

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\core\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_3_none_12.4.56.0_none_e91db5cc1ac36456
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_MANIFEST_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_CATALOG_PATH=manifests\x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8.cat
XP_PAYLOAD_PATH=x86__core_3_no-public-key_12.4.56.0_x-ww_c5d819e8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\installer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\installer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\Video_Cube_FirstLoad_Purchase\makefile.inc ===
VideoCubeQFECopy : makefile.inc
    -md %_NT386TREE%\tools\xereports\VideoCubeQFE
    -robocopy . %_NT386TREE%\tools\xereports\VideoCubeQFE *.sql *.txt /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\console\ReportSSISConsole.cs ===
using System;
using System.IO;
using System.Xml;
using xonline.tools.reporting.ssis.core;

namespace xonline.tools.reporting.ssis.console
{
    class ReportSSISConsole
    {
        [STAThread]
        static void Main( string[] rgszArgs )
        {
            ReportingSSIS pReportSSIS;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;

            bool fDelete = false;
            string szFile = string.Empty;
            string szInterface = string.Empty;

            if( 1 == rgszArgs.Length )
            {
                szFile = rgszArgs[ 0 ];
            }
            else if( 2 <= rgszArgs.Length )
            {
                foreach( string szArg in rgszArgs )
                {
                    if( szArg[ 0 ] == '-' )
                    {
                        if( szArg.ToLower( ) == "-d" )
                        {
                            fDelete = true;
                        }
                        else
                        {
                            Usage( );
                            goto lDone;
                        }
                    }
                    else
                    {
                        szFile = szArg;
                    }
                }
            }
            else
            {
                Usage( );
                goto lDone;
            }

            try
            {
                xmlDoc = new XmlDocument( );
                xmlDoc.Load( szFile );

                XmlNode xnInterface = xmlDoc.DocumentElement.SelectSingleNode( "SSISPackages/@Interface" );
                if( null == xnInterface )
                {
                    throw new Exception( "Unable to determine the interface on which to install the SSIS packages." );
                }

                szInterface = xnInterface.InnerText;

                xmlList = xmlDoc.DocumentElement.SelectNodes("SSISPackages/Package");
                foreach( XmlNode xnT in xmlList )
                {
                    pReportSSIS = new ReportingSSIS( );
                    if ((null != xnT.Attributes["Delete"] &&
                        "true" == xnT.Attributes["Delete"].Value.ToLower())
                        || fDelete)
                    {
                        pReportSSIS.Delete(Path.Combine(Path.GetDirectoryName(Path.GetFullPath(szFile)), xnT.SelectSingleNode("@File").InnerText), szInterface);
                    }
                    else
                    {
                        pReportSSIS.Install(Path.Combine(Path.GetDirectoryName(Path.GetFullPath(szFile)), xnT.SelectSingleNode("@File").InnerText), szInterface);
                    }
                }
            }
            catch( Exception exc )
            {
                Console.WriteLine( exc.ToString( ) );
            }

        lDone:

            return;
        }

        static void Usage( )
        {
            Console.WriteLine( "Usage: ReportSSIS.exe [options] <SSIS XML Wrapper File>" );
            Console.WriteLine( "     -d Delete the SSIS package(s)" );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\installer\ReportSSISInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Diagnostics;
using System.IO;
using System.Xml;
using xonline.tools.reporting.ssis.core;

namespace xonline.tools.reporting.ssis.installer
{
    [RunInstaller(true)]
    public class ReportSSISInstaller : System.Configuration.Install.Installer
    {
        private EventLog _eventLog;
    
        public ReportSSISInstaller( )
        {
            _eventLog = new EventLog( );
            _eventLog.Log = "Application";
            _eventLog.Source = "ReportSSISInstaller";
        }
        
        public override void Install(IDictionary stateSaver)
        {
            base.Install (stateSaver);

            ReportingSSIS pReportSSIS;
            string szXmlFile;
            string szInterface;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;
            XmlNode xnInterface;

            szXmlFile = Context.Parameters[ "ReportSSISFile" ];

            try
            {
                xmlDoc = new XmlDocument( );
                xmlDoc.Load( szXmlFile );

                xnInterface = xmlDoc.DocumentElement.SelectSingleNode( "SSISPackages/@Interface" );
                if( null == xnInterface )
                {
                    throw new Exception( "Unable to determine the interface on which to install the SSIS packages." );
                }

                szInterface = xnInterface.InnerText;

                xmlList = xmlDoc.DocumentElement.SelectNodes( "SSISPackages/Package" );
                foreach( XmlNode xnT in xmlList )
                {
                    pReportSSIS = new ReportingSSIS( );
                    if( null != xnT.Attributes["Delete"] && 
                        "true" == xnT.Attributes["Delete"].Value.ToLower())
                    {
                        pReportSSIS.Delete( Path.Combine( Path.GetDirectoryName( Path.GetFullPath( szXmlFile ) ), xnT.SelectSingleNode( "@File" ).InnerText ), szInterface );
                    }
                    else
                    {
                        pReportSSIS.Install( Path.Combine( Path.GetDirectoryName( Path.GetFullPath( szXmlFile ) ), xnT.SelectSingleNode( "@File" ).InnerText ), szInterface );
                    }
                }
            }
            catch( Exception exc )
            {
                Context.LogMessage( "ERROR: Exception encountered executing ReportSSIS. - " + exc.Message );
                Context.LogMessage( exc.ToString( ) );
                _eventLog.WriteEntry( "ERROR: Exception encountered executing ReportSSIS: \r\n" + exc.ToString( ), EventLogEntryType.Error, 65000 );
                throw;
            }
        }
    
        // even though these overriddent methods appear to do nothing,
        // omiting them will leave temp files behind after the install.
        public override void Commit(IDictionary savedState)
        {
            base.Commit (savedState);
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);

            ReportingSSIS pReportSSIS;
            string szXmlFile;
            string szInterface;
            XmlDocument xmlDoc;
            XmlNodeList xmlList;
            XmlNode xnInterface;
            
            szXmlFile = Context.Parameters[ "ReportSSISFile" ];
            
            try
            {
                xmlDoc = new XmlDocument( );
                xmlDoc.Load( szXmlFile );
            
                xnInterface = xmlDoc.DocumentElement.SelectSingleNode( "SSISPackages/@Interface" );
                if( null == xnInterface )
                {
                    throw new Exception( "Unable to determine the interface on which to install the SSIS packages." );
                }

                szInterface = xnInterface.InnerText;

                xmlList = xmlDoc.DocumentElement.SelectNodes( "SSISPackages/Package/@File" );
                foreach( XmlNode xnT in xmlList )
                {
                    pReportSSIS = new ReportingSSIS( );
                    pReportSSIS.Delete( Path.Combine( Path.GetDirectoryName( Path.GetFullPath( szXmlFile ) ), xnT.InnerText ), szInterface );
                }
            }
            catch( Exception exc )
            {
                Context.LogMessage( "ERROR: Exception encountered executing ReportSSIS. - " + exc.Message );
                Context.LogMessage( exc.ToString( ) );
                _eventLog.WriteEntry( "ERROR: Exception encountered executing ReportSSIS: \r\n" + exc.ToString( ), EventLogEntryType.Error, 65000 );
                throw;
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\Video_Cube_FirstLoad_Purchase\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__video_cube_firstload_purchase_3_none_12.4.56.0_none_9f3c82392ece37d5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_video_cube_firstload_purchase_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.manifest
XP_MANIFEST_PATH=manifests\x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.cat
XP_CATALOG_PATH=manifests\x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.cat
XP_PAYLOAD_PATH=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_video_cube_firstload_purchase_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\SSIS\core\ReportSSIS.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using Microsoft.SqlServer.Dts.Runtime;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;
using xonline.common.config;

namespace xonline.tools.reporting.ssis.core
{
    class ReportingSSIS
    {
        public void Delete( string szPackageFile, string szInterface )
        {
            Application app;
            IInterfaceInfo iiInfo;

            app = new Application( );

            iiInfo = Config.GetSingleInterface( szInterface );

            if( app.ExistsOnSqlServer( Path.GetFileNameWithoutExtension(szPackageFile), iiInfo.IPAddressString, null, null ) )
            {
                app.RemoveFromSqlServer( Path.GetFileNameWithoutExtension(szPackageFile), iiInfo.IPAddressString, null, null );
            }
        }

        public void Install( string szPackageFile, string szInterface )
        {
            Application app;
            Package pkg;
            IInterfaceInfo iiInfo;

            app = new Application( );
            pkg = app.LoadPackage( szPackageFile, null );

            foreach( ConnectionManager cm in pkg.Connections )
            {
                if(cm.Name.ToLower().StartsWith("smo-"))
                {
                    SetSMOConnectionString(cm);
                    continue;
                }

                //Josszy -- flat file connections won't be in the server list but are nontheless okay.
                if (cm.Name.Contains("Flat"))
                {
                    continue;
                }

                iiInfo = _RetrieveFirstInterface( cm.Name );

                //
                // For UODB, set the connection string to the replica we keep on the reportssisdb machine.
                //
                if (("webstore" == iiInfo.Protocol.ToLower()) && ("uodb" == cm.Name.ToLower()))
                {
                    string[] rgszServers = Config.GetServerListByInterface(szInterface);
                    iiInfo = Config.GetInterface( rgszServers[0], "reportssisuodb" );
                }

                cm.ConnectionString = string.Format("Data Source={0};Initial Catalog={1};Provider=SQLNCLI10.1;Integrated Security=SSPI;Auto Translate=False;",
                    iiInfo.IPAddressString, iiInfo.DBName );
            }

            iiInfo = Config.GetSingleInterface( szInterface );

            app.SaveToSqlServerAs( pkg, null, Path.GetFileNameWithoutExtension(szPackageFile), iiInfo.IPAddressString, null, null );
         }

        private void SetSMOConnectionString(ConnectionManager cm)
        {
            string interfaceName = cm.Name.Substring(4); // skip prefix "SMO-" for SMOServer connections

            IInterfaceInfo iiInfo = _RetrieveFirstInterface(interfaceName);

            string [] tokens = (cm.ConnectionString).Split(';');
            StringBuilder connectionString = new StringBuilder();
            foreach (string s in tokens)
            {
                if(s.StartsWith("SqlServerName"))
                {
                    connectionString.Append("SqlServerName=");
                    connectionString.Append(iiInfo.IPAddress);
                }
                else
                {
                    connectionString.Append(s);
                }
                connectionString.Append(";");
            }

            cm.ConnectionString = connectionString.ToString();
        }

        private IInterfaceInfo _RetrieveFirstInterface(string szInterface)
        {
            string[] rgszServers;
            IInterfaceInfo iiReportSSISDB;
            WstConnection pConnection;
            InterfaceInfo iiWebstore;
            IInterfaceInfo iiFirst;

            iiFirst = null;
            iiWebstore = null;
            iiReportSSISDB = null;

            rgszServers = Config.GetServerListByInterface(szInterface);
            if( rgszServers.Length > 0 )
            {
                iiReportSSISDB = Config.GetInterface(rgszServers[0], szInterface);
            }

            //
            // First, try finding them in webstore;
            // If possible, try and keep it on the ReportSSISDB server
            //
            pConnection = new WstConnection(szInterface);
            try
            {
                pConnection.Open();

                foreach(WebstoreSQLFss pPartition in pConnection.SqlPartitions)
                {
                    foreach(WebstoreDatabase pDatabase in pPartition.Databases)
                    {
                        bool fReassign = false;

                        if (null == iiWebstore)
                        {
                            fReassign = true;
                        }

                        if ((null != iiReportSSISDB) &&
                            ((pDatabase.ServerName.ToLower() == iiReportSSISDB.ServerName.ToLower()) ||
                            (pDatabase.ServerName.ToLower() == iiReportSSISDB.IPAddressString.ToLower())))
                        {
                            fReassign = true;
                        }

                        if (fReassign)
                        {
                            iiWebstore = new InterfaceInfo();
                            iiWebstore.ServerName = pDatabase.ServerName;
                            iiWebstore.Protocol = "webstore";
                            IPHostEntry pHostEntry;
                            pHostEntry = Dns.GetHostEntry(iiWebstore.ServerName);
                            iiWebstore.IPAddress = pHostEntry.AddressList[0];
                            iiWebstore.DBName = pDatabase.Name;
                            iiWebstore.Timeout = 30000;
                        }
                    }
                }

                if (null != iiWebstore)
                {
                    iiFirst = iiWebstore as IInterfaceInfo;
                }
            }
            catch
            {
                //
                // Couldn't find this interface in webstore - let's try npdb
                //
            }

            //
            // We couldn't find it in webstore - try npdb next
            //
            if (null == iiFirst)
            {
                rgszServers = Config.GetServerListByInterface(szInterface);
                if( 0 == rgszServers.Length )
                {
                    throw new ArgumentOutOfRangeException( "Unable to find any servers with the interface " + szInterface );
                }

                iiFirst = Config.GetInterface( rgszServers[0], szInterface );
            }

            return iiFirst;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\Video_Cube_FirstLoad_Purchase\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__video_cube_firstload_purchase_3_none_12.4.56.0_none_9f3c82392ece37d5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_video_cube_firstload_purchase_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.manifest
XP_MANIFEST_PATH=manifests\x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.cat
XP_CATALOG_PATH=manifests\x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b.cat
XP_PAYLOAD_PATH=x86__video_cube_firstload_purchase_3_no-public-key_12.4.56.0_x-ww_fa06d69b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_video_cube_firstload_purchase_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\AddRecipient.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for AddRecipient.
    /// </summary>
    public class AddRecipient : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Label Label2;
        protected System.Data.SqlClient.SqlConnection ReportDB;
        protected System.Web.UI.WebControls.DataList RecipientReportsList;
        protected System.Web.UI.WebControls.TextBox EMailEdit;
        protected System.Data.SqlClient.SqlCommand GetTitlesCmd;
        protected System.Data.SqlClient.SqlDataAdapter GetTitlesAdapter;
        protected System.Data.DataSet AddRecipientReportDataSet;
        protected System.Data.SqlClient.SqlCommand GetRegionsCmd;
        protected System.Data.SqlClient.SqlDataAdapter GetRegionsAdapter;
        protected System.Web.UI.WebControls.Button OKButton;
        protected System.Web.UI.WebControls.Button CancelButton;
        protected System.Data.SqlClient.SqlCommand AddRecipientCommand;
        protected xlreportmgr.GetTitlesDataSetType getTitlesDataSet;
        protected System.Web.UI.WebControls.HyperLink hyperLink3;
        protected System.Web.UI.WebControls.Panel Panel5;
        protected System.Web.UI.WebControls.HyperLink hyperLink2;
        protected System.Web.UI.WebControls.Panel Panel4;
        protected System.Web.UI.WebControls.Label label1;
        protected System.Web.UI.WebControls.Panel Panel1;
        protected System.Web.UI.WebControls.HyperLink hyperLink1;
        protected System.Web.UI.WebControls.Panel Panel2;
        protected System.Web.UI.WebControls.Panel Panel3;
        protected System.Web.UI.WebControls.Panel InnerMainPanel;
        protected System.Web.UI.WebControls.Panel OuterBorderPanel;
        
        protected System.Web.UI.WebControls.DropDownList AddRecip_Titles;
        protected System.Web.UI.WebControls.DropDownList AddRecip_Reports;
        protected System.Web.UI.WebControls.DropDownList AddRecip_Regions;
        protected System.Web.UI.WebControls.DropDownList AddRecip_Formats;

        private void Page_Load(object sender, System.EventArgs e)
        {
            try
            {
                ReportDB.Open();

                if(AddRecip_Titles.SelectedIndex == -1)
                {
                    GetTitlesAdapter.Fill(getTitlesDataSet);
                    AddRecip_Titles.DataSource = getTitlesDataSet.Tables[0].DefaultView;
                    AddRecip_Titles.DataTextField = "vcTitleName";
                    AddRecip_Titles.DataValueField = "iTitleID";
                    AddRecip_Titles.DataBind();
                }
            }
            finally
            {
                if(ReportDB.State == ConnectionState.Open)
                    ReportDB.Close();
            }
        }

        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            System.Configuration.AppSettingsReader configurationAppSettings = new System.Configuration.AppSettingsReader();
            this.ReportDB = new System.Data.SqlClient.SqlConnection();
            this.GetTitlesCmd = new System.Data.SqlClient.SqlCommand();
            this.GetTitlesAdapter = new System.Data.SqlClient.SqlDataAdapter();
            this.GetRegionsCmd = new System.Data.SqlClient.SqlCommand();
            this.GetRegionsAdapter = new System.Data.SqlClient.SqlDataAdapter();
            this.AddRecipientCommand = new System.Data.SqlClient.SqlCommand();
            this.getTitlesDataSet = new xlreportmgr.GetTitlesDataSetType();
            ((System.ComponentModel.ISupportInitialize)(this.getTitlesDataSet)).BeginInit();
            // 
            // ReportDB
            // 
            this.ReportDB.ConnectionString = ((string)(configurationAppSettings.GetValue("ReportDB.ConnectionString", typeof(string))));
            // 
            // GetTitlesCmd
            // 
            this.GetTitlesCmd.CommandText = "p_XRSupp_GetTitles";
            this.GetTitlesCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.GetTitlesCmd.Connection = this.ReportDB;
            this.GetTitlesCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@si_DownloadOnly", System.Data.SqlDbType.SmallInt, 0, System.Data.ParameterDirection.Input, false, ((System.Byte)(0)), ((System.Byte)(0)), "", System.Data.DataRowVersion.Current, "255"));
            // 
            // GetTitlesAdapter
            // 
            this.GetTitlesAdapter.SelectCommand = this.GetTitlesCmd;
            // 
            // GetRegionsCmd
            // 
            this.GetRegionsCmd.CommandText = "p_XRSupp_GetRegions";
            this.GetRegionsCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.GetRegionsCmd.Connection = this.ReportDB;
            this.GetRegionsCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@i_IncludeWW", System.Data.SqlDbType.Int, 0, System.Data.ParameterDirection.Input, false, ((System.Byte)(0)), ((System.Byte)(0)), "", System.Data.DataRowVersion.Current, "1"));
            // 
            // GetRegionsAdapter
            // 
            this.GetRegionsAdapter.SelectCommand = this.GetRegionsCmd;
            // 
            // AddRecipientCommand
            // 
            this.AddRecipientCommand.CommandText = "p_XR_InsertReportRecipient";
            this.AddRecipientCommand.CommandType = System.Data.CommandType.StoredProcedure;
            this.AddRecipientCommand.Connection = this.ReportDB;
            this.AddRecipientCommand.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcEmail", System.Data.SqlDbType.VarChar, 128));
            this.AddRecipientCommand.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcReportType", System.Data.SqlDbType.VarChar, 128));
            this.AddRecipientCommand.Parameters.Add(new System.Data.SqlClient.SqlParameter("@iTitleID", System.Data.SqlDbType.Int));
            this.AddRecipientCommand.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcRegion", System.Data.SqlDbType.VarChar, 128));
            this.AddRecipientCommand.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcFormat", System.Data.SqlDbType.VarChar, 128));
            // 
            // getTitlesDataSet
            // 
            this.getTitlesDataSet.DataSetName = "GetTitlesDataSetType";
            this.getTitlesDataSet.Locale = new System.Globalization.CultureInfo("en-US");
            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);
            this.CancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            this.Load += new System.EventHandler(this.Page_Load);
            ((System.ComponentModel.ISupportInitialize)(this.getTitlesDataSet)).EndInit();

        }
		
        private void OKButton_Click(object sender, System.EventArgs e)
        {
            if(EMailEdit.Text.Length == 0 ||
                AddRecip_Titles.SelectedIndex == -1 ||
                AddRecip_Reports.SelectedIndex == -1 ||
                AddRecip_Regions.SelectedIndex == -1 ||
                AddRecip_Formats.SelectedIndex == -1)
                return;

            AddRecipientCommand.Parameters[0].Value = EMailEdit.Text;
            AddRecipientCommand.Parameters[1].Value = AddRecip_Reports.SelectedValue;
            AddRecipientCommand.Parameters[2].Value = Int32.Parse(AddRecip_Titles.SelectedValue);
            AddRecipientCommand.Parameters[3].Value = AddRecip_Regions.SelectedItem.Text;
            AddRecipientCommand.Parameters[4].Value = AddRecip_Formats.SelectedItem.Text;

            try
            {
                ReportDB.Open();
                AddRecipientCommand.ExecuteNonQuery();
            }
            catch(Exception)
            {
                return;
            }
            finally
            {
                if(ReportDB.State == ConnectionState.Open)
                    ReportDB.Close();
            }

            Response.Redirect("EditRecipient.aspx?UserID=" + HttpUtility.UrlEncode(EMailEdit.Text));        
        }

        private void CancelButton_Click(object sender, System.EventArgs e)
        {
            Response.Redirect("EditRecipient.aspx");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\Content.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for Content.
    /// </summary>
    public class Content : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Label DataErrorLabel;
        protected System.Web.UI.WebControls.Label Label1;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Put user code to initialize the page here
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\Banner.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for Banner.
    /// </summary>
    public class Banner : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Label Label1;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Put user code to initialize the page here
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\EditRecipient.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for EditRecipient.
    /// </summary>
    public class EditRecipient : System.Web.UI.Page
    {
        protected System.Data.DataSet getRecipientReportsDataSet;

        protected xlreportmgr.GetTitlesDataSetType getTitlesDataSet;
        protected xlreportmgr.GetRecipientsListDataSetType getRecipientsListDataSet;
        protected System.Web.UI.WebControls.Button addReportButton;
        protected System.Web.UI.WebControls.Button deleteAllReportsButton;
        protected System.Web.UI.WebControls.Label recipientNameLabel;
        protected System.Web.UI.WebControls.DataList recipientReportsList;

        protected System.Data.SqlClient.SqlConnection reportDB;
        protected System.Data.SqlClient.SqlCommand getRecipientsListCmd;
        protected System.Data.SqlClient.SqlCommand getRecipientReportsCmd;
        protected System.Data.SqlClient.SqlCommand deleteRecipientReportCmd;
        protected System.Data.SqlClient.SqlCommand insertRecipientReportCmd;
        protected System.Data.SqlClient.SqlCommand getTitlesCmd;
        protected System.Data.SqlClient.SqlDataAdapter getRecipientsListAdapter;
        protected System.Data.SqlClient.SqlDataAdapter getRecipientReportsAdapter;
        protected System.Web.UI.WebControls.HyperLink hyperLink2;
        protected System.Web.UI.WebControls.HyperLink hyperLink3;
        protected System.Web.UI.WebControls.Label label1;
        protected System.Web.UI.WebControls.Panel Panel1;
        protected System.Web.UI.WebControls.Panel Panel3;
        protected System.Web.UI.WebControls.Panel Panel4;
        protected System.Web.UI.WebControls.Panel Panel5;
        protected System.Web.UI.WebControls.Panel Panel2;
        protected System.Web.UI.WebControls.HyperLink hyperLink1;
        protected System.Web.UI.WebControls.Panel InnerMainPanel;
        protected System.Web.UI.WebControls.Panel OuterBorderPanel;
        protected System.Web.UI.WebControls.DropDownList SortList;
        protected System.Web.UI.WebControls.Panel ChangeRecipient;
        protected System.Web.UI.WebControls.Button Button1;
        protected System.Web.UI.WebControls.TextBox newRecipient;
        protected System.Web.UI.WebControls.DropDownList recipientsList;
        protected System.Data.SqlClient.SqlDataAdapter getTitlesAdapter;

    
        private void FillRecipientReportsDataSet(string recipientName, string sortListValue)
        {
            getRecipientReportsCmd.Parameters[0].Value = recipientName;
            getRecipientReportsCmd.Parameters[1].Value = sortListValue; 

            getRecipientReportsAdapter = new SqlDataAdapter();
            getRecipientReportsAdapter.SelectCommand = getRecipientReportsCmd;
            getRecipientReportsAdapter.InsertCommand = insertRecipientReportCmd;
            getRecipientReportsAdapter.DeleteCommand = deleteRecipientReportCmd;
            getRecipientReportsDataSet = new DataSet();
            getRecipientReportsAdapter.Fill(getRecipientReportsDataSet);

        }

        private void BindRecipientReportsList(int editItemIndex)
        {
            recipientReportsList.DataSource = getRecipientReportsDataSet.Tables[0].DefaultView;
            recipientReportsList.DataKeyField = "DataKey";
            recipientReportsList.EditItemIndex = editItemIndex;
            recipientReportsList.DataBind();
        }

        private void FillRecipientsList()
        {
            getRecipientsListAdapter.Fill(getRecipientsListDataSet);
            recipientsList.DataSource = getRecipientsListDataSet._Table.DefaultView;
            recipientsList.DataTextField = "vc_email";
            recipientsList.DataBind();
        }

        private void FillRecipientsList(string selectedValue)
        {
            FillRecipientsList();

            if(recipientsList.Items.FindByValue(selectedValue) != null)
                recipientsList.SelectedValue = selectedValue;
        }

        private void FillRecipientsList(int selectedItemIndex)
        {
            FillRecipientsList();

            recipientsList.SelectedIndex = selectedItemIndex;
        }
		
        private void ExtraRefresh()
        {
            Response.Redirect("EditRecipient.aspx?UserID="+recipientsList.SelectedItem.Text);
        }

        private void Page_Load(object sender, System.EventArgs e)
        {
            try
            {
                reportDB.Open();
				
                // Get all the titles listing
                getTitlesAdapter.Fill(getTitlesDataSet);   
			
                //
                //  Populate adapter and grid
                //
                if(recipientsList.SelectedIndex == -1)
                {
                    if ( Request.QueryString.GetValues("UserID") != null)
                    {
                        FillRecipientsList(Request.QueryString.GetValues("UserID")[0]);
                    }
                    else
                    {
                        FillRecipientsList(0);
                    }
					
                    FillRecipientReportsDataSet(recipientsList.SelectedValue,SortList.SelectedValue);
                    BindRecipientReportsList(recipientReportsList.EditItemIndex);
                }
                else
                {
                    FillRecipientReportsDataSet(recipientsList.SelectedValue,SortList.SelectedValue);
                }
				
				
                deleteAllReportsButton.Attributes["onclick"] = "javascript:return " +  "confirm('Are you sure you want to delete all the reports for " + recipientsList.SelectedItem.Text +"?')";
				
                recipientNameLabel.Text = recipientsList.SelectedItem.Text;	
				
            }
            finally
            {
                if(reportDB.State == ConnectionState.Open)
                    reportDB.Close();
            }
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            System.Configuration.AppSettingsReader configurationAppSettings = new System.Configuration.AppSettingsReader();
            this.reportDB = new System.Data.SqlClient.SqlConnection();
            this.getRecipientsListCmd = new System.Data.SqlClient.SqlCommand();
            this.getRecipientsListAdapter = new System.Data.SqlClient.SqlDataAdapter();
            this.getRecipientReportsCmd = new System.Data.SqlClient.SqlCommand();
            this.getRecipientReportsAdapter = new System.Data.SqlClient.SqlDataAdapter();
            this.deleteRecipientReportCmd = new System.Data.SqlClient.SqlCommand();
            this.insertRecipientReportCmd = new System.Data.SqlClient.SqlCommand();
            this.getTitlesCmd = new System.Data.SqlClient.SqlCommand();
            this.getTitlesAdapter = new System.Data.SqlClient.SqlDataAdapter();
            this.getTitlesDataSet = new xlreportmgr.GetTitlesDataSetType();
            this.getRecipientReportsDataSet = new System.Data.DataSet();
            this.getRecipientsListDataSet = new xlreportmgr.GetRecipientsListDataSetType();
            ((System.ComponentModel.ISupportInitialize)(this.getTitlesDataSet)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.getRecipientReportsDataSet)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.getRecipientsListDataSet)).BeginInit();
            // 
            // reportDB
            // 
            this.reportDB.ConnectionString = ((string)(configurationAppSettings.GetValue("reportDB.ConnectionString", typeof(string))));
            // 
            // getRecipientsListCmd
            // 
            this.getRecipientsListCmd.CommandText = "[p_XR_Get_Recipient_List]";
            this.getRecipientsListCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.getRecipientsListCmd.Connection = this.reportDB;
            // 
            // getRecipientsListAdapter
            // 
            this.getRecipientsListAdapter.SelectCommand = this.getRecipientsListCmd;
            // 
            // getRecipientReportsCmd
            // 
            this.getRecipientReportsCmd.CommandText = "[p_XR_Get_Recipient_Reports]";
            this.getRecipientReportsCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.getRecipientReportsCmd.Connection = this.reportDB;
            this.getRecipientReportsCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcEmail", System.Data.SqlDbType.VarChar, 128));
            this.getRecipientReportsCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@sortBy", System.Data.SqlDbType.VarChar, 128));
            // 
            // getRecipientReportsAdapter
            // 
            this.getRecipientReportsAdapter.DeleteCommand = this.deleteRecipientReportCmd;
            this.getRecipientReportsAdapter.InsertCommand = this.insertRecipientReportCmd;
            this.getRecipientReportsAdapter.SelectCommand = this.getRecipientReportsCmd;
            // 
            // deleteRecipientReportCmd
            // 
            this.deleteRecipientReportCmd.CommandText = "p_XR_DeleteReportRecipient";
            this.deleteRecipientReportCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.deleteRecipientReportCmd.Connection = this.reportDB;
            this.deleteRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcEmail", System.Data.SqlDbType.VarChar, 128));
            this.deleteRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcReportType", System.Data.SqlDbType.VarChar, 128));
            this.deleteRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@iTitleID", System.Data.SqlDbType.Int));
            this.deleteRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcRegion", System.Data.SqlDbType.VarChar, 128));
            this.deleteRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcFormat", System.Data.SqlDbType.VarChar, 128));
            // 
            // insertRecipientReportCmd
            // 
            this.insertRecipientReportCmd.CommandText = "p_XR_InsertReportRecipient";
            this.insertRecipientReportCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.insertRecipientReportCmd.Connection = this.reportDB;
            this.insertRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcEmail", System.Data.SqlDbType.VarChar, 128));
            this.insertRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcReportType", System.Data.SqlDbType.VarChar, 128));
            this.insertRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@iTitleID", System.Data.SqlDbType.Int));
            this.insertRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcRegion", System.Data.SqlDbType.VarChar, 128));
            this.insertRecipientReportCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcFormat", System.Data.SqlDbType.VarChar, 128));
            // 
            // getTitlesCmd
            // 
            this.getTitlesCmd.CommandText = "p_XRSupp_GetTitles";
            this.getTitlesCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.getTitlesCmd.Connection = this.reportDB;
            this.getTitlesCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@si_DownloadOnly", System.Data.SqlDbType.TinyInt, 0, System.Data.ParameterDirection.Input, false, ((System.Byte)(0)), ((System.Byte)(0)), "", System.Data.DataRowVersion.Current, "255"));
            // 
            // getTitlesAdapter
            // 
            this.getTitlesAdapter.SelectCommand = this.getTitlesCmd;
            // 
            // getTitlesDataSet
            // 
            this.getTitlesDataSet.DataSetName = "GetTitlesDataSetType";
            this.getTitlesDataSet.Locale = new System.Globalization.CultureInfo("en-US");
            // 
            // getRecipientReportsDataSet
            // 
            this.getRecipientReportsDataSet.DataSetName = "GetRecipientReportsDataSetType";
            this.getRecipientReportsDataSet.Locale = new System.Globalization.CultureInfo("en-US");
            // 
            // getRecipientsListDataSet
            // 
            this.getRecipientsListDataSet.DataSetName = "GetRecipientsListDataSetType";
            this.getRecipientsListDataSet.Locale = new System.Globalization.CultureInfo("en-US");
            this.addReportButton.Click += new System.EventHandler(this.AddReportButton_Click);
            this.deleteAllReportsButton.Click += new System.EventHandler(this.DeleteAllReportsButton_Click);
            this.SortList.SelectedIndexChanged += new System.EventHandler(this.SortList_SelectedIndexChanged);
            this.recipientReportsList.CancelCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.recipientReportsList_CancelCommand);
            this.recipientReportsList.EditCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.recipientReportsList_EditCommand);
            this.recipientReportsList.UpdateCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.recipientReportsList_UpdateCommand);
            this.recipientReportsList.DeleteCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.RecipientsReportsList_DeleteCommand);
            this.recipientReportsList.SelectedIndexChanged += new System.EventHandler(this.recipientReportsList_SelectedIndexChanged);
            this.Load += new System.EventHandler(this.Page_Load);
            ((System.ComponentModel.ISupportInitialize)(this.getTitlesDataSet)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.getRecipientReportsDataSet)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.getRecipientsListDataSet)).EndInit();

            this.recipientsList.SelectedIndexChanged += new System.EventHandler(this.RecipientsList_SelectedIndexChanged);
			
        }
        #endregion
		
        public void Item_Bound(Object sender, DataListItemEventArgs e)
        {
			
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                Button deleteButton = (Button)e.Item.FindControl("deleteButton");
                if ( deleteButton != null)
                {
                    deleteButton.Attributes["onclick"] = "javascript:return confirm('Are you sure you want to delete this title?')";   
                }
            }
			
        }

        public void SortByTitle_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortTitle");
        }
		
        public void SortByReportType_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortReportType");
        }

        public void SortByRegion_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortRegion");
        }

        public void SortByFormat_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortFormat");
        }

        private void SortByHeading(string param)
        {
            SortList.SelectedValue = param;
            FillRecipientReportsDataSet(recipientsList.SelectedValue,SortList.SelectedValue);
            BindRecipientReportsList(-1);
            /*
            if (recipientReportsList.EditItemIndex != -1 )
            {
                InEditMode(recipientReportsList.EditItemIndex - 1);
            }
            else
            {
                BindRecipientReportsList(-1);
            }	
            */
        }

        private void InEditMode(int index)
        {
            DataRow srcRow = getRecipientReportsDataSet.Tables[0].Rows[index];            
            DataRow addRow = getRecipientReportsDataSet.Tables[0].NewRow();

            addRow["TitleID"] = srcRow["TitleID"];
            addRow["ReportType"] = srcRow["ReportType"];
            addRow["Region"] = srcRow["Region"];
            addRow["Format"] = srcRow["Format"];

            getRecipientReportsDataSet.Tables[0].Rows.InsertAt(addRow, index + 1);
            BindRecipientReportsList(index + 1);        
        }


        private void RecipientsReportsList_DeleteCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            DataRow delRow = getRecipientReportsDataSet.Tables[0].Rows[e.Item.ItemIndex];

            deleteRecipientReportCmd.Parameters[0].Value = recipientsList.SelectedValue;
            deleteRecipientReportCmd.Parameters[1].Value = delRow["ReportType"];
            deleteRecipientReportCmd.Parameters[2].Value = delRow["TitleID"];
            deleteRecipientReportCmd.Parameters[3].Value = delRow["Region"];
            deleteRecipientReportCmd.Parameters[4].Value = delRow["Format"];

            delRow.Delete();

            getRecipientReportsAdapter.Update(getRecipientReportsDataSet);
			
            if (getRecipientReportsDataSet.Tables[0].Rows.Count == 0)
            {
                FillRecipientsList(recipientsList.SelectedIndex - 1);
                FillRecipientReportsDataSet(recipientsList.SelectedValue, SortList.SelectedValue);
                BindRecipientReportsList(-1);
                recipientNameLabel.Text = recipientsList.SelectedItem.Text;
            }
            else
            {
                BindRecipientReportsList(-1);
            }
            ExtraRefresh();
        }

        private void DeleteAllReportsButton_Click(object sender, System.EventArgs e)
        {
            while(getRecipientReportsDataSet.Tables[0].Rows.Count != 0)
            {
                DataRow delRow = getRecipientReportsDataSet.Tables[0].Rows[0];

                deleteRecipientReportCmd.Parameters[0].Value = recipientsList.SelectedValue;
                deleteRecipientReportCmd.Parameters[1].Value = delRow["ReportType"];
                deleteRecipientReportCmd.Parameters[2].Value = delRow["TitleID"];
                deleteRecipientReportCmd.Parameters[3].Value = delRow["Region"];
                deleteRecipientReportCmd.Parameters[4].Value = delRow["Format"];

                delRow.Delete();

                getRecipientReportsAdapter.Update(getRecipientReportsDataSet);
            }

            FillRecipientsList(recipientsList.SelectedIndex - 1);
            FillRecipientReportsDataSet(recipientsList.SelectedValue, SortList.SelectedValue);
            BindRecipientReportsList(-1);
            recipientNameLabel.Text = recipientsList.SelectedItem.Text;
        }

        private void AddReportButton_Click(object sender, System.EventArgs e)
        {
            int insertRow = 0;
            DataRow addRow = getRecipientReportsDataSet.Tables[0].NewRow();

            addRow["TitleID"] = 0;
            addRow["ReportType"] = "";
            addRow["Region"] = "";
            addRow["Format"] = "";

            getRecipientReportsDataSet.Tables[0].Rows.InsertAt(addRow, insertRow);
            BindRecipientReportsList(insertRow);
        }

        private void recipientReportsList_CancelCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            BindRecipientReportsList(-1);
        }

        private void recipientReportsList_UpdateCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            DropDownList TitlesList = (DropDownList)e.Item.FindControl("EditRecip_Titles");
            DropDownList ReportTypesList = (DropDownList)e.Item.FindControl("EditRecip_Reports");
            DropDownList RegionsList = (DropDownList)e.Item.FindControl("EditRecip_Regions");
            DropDownList FormatsList = (DropDownList)e.Item.FindControl("EditRecip_Formats");
            
            //
            //  Make sure all three controls are set
            //
            
            if(TitlesList.SelectedIndex == -1 ||
                ReportTypesList.SelectedIndex == -1 ||
                RegionsList.SelectedIndex == -1 ||
                FormatsList.SelectedIndex == -1)
            {
                BindRecipientReportsList(e.Item.ItemIndex);
                return;
            }

            //
            //  Create new row and add to data set
            //

            DataRow addRow = getRecipientReportsDataSet.Tables[0].NewRow();
            addRow["TitleID"] = Int32.Parse(TitlesList.SelectedValue);
            addRow["ReportType"] = ReportTypesList.SelectedValue;
            addRow["Region"] = RegionsList.SelectedItem.Text;
            addRow["Format"] = FormatsList.SelectedItem.Text;

            //
            //  Check for dups
            //

            foreach(DataRow curRow in getRecipientReportsDataSet.Tables[0].Rows)
            {
                if((int)curRow["TitleID"] == Int32.Parse(TitlesList.SelectedValue) &&
                    (string)curRow["ReportType"] == ReportTypesList.SelectedValue &&
                    (string)curRow["Region"] == RegionsList.SelectedItem.Text &&
                    (string)curRow["Format"] == FormatsList.SelectedItem.Text)
                {
                    //
                    //  We found a dup, just re-edit the row
                    //  TODO - Some kind of notification to the user that a collision occurred
                    //

                    getRecipientReportsDataSet.Tables[0].Rows.InsertAt(addRow, e.Item.ItemIndex);
                    BindRecipientReportsList(e.Item.ItemIndex);
                    return;
                }
            }

            //
            //  Add new row to dataset and update db
            //

            getRecipientReportsDataSet.Tables[0].Rows.InsertAt(addRow, e.Item.ItemIndex);

            insertRecipientReportCmd.Parameters[0].Value = recipientsList.SelectedValue;
            insertRecipientReportCmd.Parameters[1].Value = addRow["ReportType"];
            insertRecipientReportCmd.Parameters[2].Value = addRow["TitleID"];
            insertRecipientReportCmd.Parameters[3].Value = addRow["Region"];
            insertRecipientReportCmd.Parameters[4].Value = addRow["Format"];

            getRecipientReportsAdapter.Update(getRecipientReportsDataSet);

            FillRecipientReportsDataSet(recipientsList.SelectedValue, SortList.SelectedValue);
            BindRecipientReportsList(-1);
			
            ExtraRefresh();
        }

        /// <summary>
        /// This is actually the handler for the "Clone" link, overrode Edit command for this purpose.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        private void recipientReportsList_EditCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            EditRecipientList(e.Item.ItemIndex);
        }

        private void EditRecipientList(int index)
        {
            DataRow srcRow = getRecipientReportsDataSet.Tables[0].Rows[index];            
            DataRow addRow = getRecipientReportsDataSet.Tables[0].NewRow();

            addRow["TitleID"] = srcRow["TitleID"];
            addRow["ReportType"] = srcRow["ReportType"];
            addRow["Region"] = srcRow["Region"];
            addRow["Format"] = srcRow["Format"];

            getRecipientReportsDataSet.Tables[0].Rows.InsertAt(addRow, index + 1);
            BindRecipientReportsList(index + 1);        
        }
		
        public int GetTitleSelectedIndex(string titleID)
        {
            int index = 0;
            foreach (DataRow row in getTitlesDataSet.Tables[0].Rows)
            {
                if ( row["iTitleID"].ToString().Equals(titleID) ) 
                {
                    return index;
                }
                index++;
            }
            return 0;

        }

        private void recipientReportsList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
			
        }

        private void RecipientsList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            BindRecipientReportsList(-1);
        }

        private void SortList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            BindRecipientReportsList(-1);
            /*
            if (recipientReportsList.EditItemIndex != -1 )
            {
                EditRecipientList(recipientReportsList.EditItemIndex - 1);
            }
            else
            {
                BindRecipientReportsList(-1);
            }
            */	
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\Titles.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for Titles.
    /// </summary>
    public class Titles : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Label DataErrorLabel;
        protected System.Web.UI.WebControls.Label Label1;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Put user code to initialize the page here
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace xlreportmgr 
{
    /// <summary>
    /// Summary description for Global.
    /// </summary>
    public class Global : System.Web.HttpApplication
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        public Global()
        {
            InitializeComponent();
        }	
		
        protected void Application_Start(Object sender, EventArgs e)
        {

        }
 
        protected void Session_Start(Object sender, EventArgs e)
        {

        }

        protected void Application_BeginRequest(Object sender, EventArgs e)
        {

        }

        protected void Application_EndRequest(Object sender, EventArgs e)
        {

        }

        protected void Application_AuthenticateRequest(Object sender, EventArgs e)
        {

        }

        protected void Application_Error(Object sender, EventArgs e)
        {

        }

        protected void Session_End(Object sender, EventArgs e)
        {

        }

        protected void Application_End(Object sender, EventArgs e)
        {

        }
			
        #region Web Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.components = new System.ComponentModel.Container();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\Groups.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for Groups.
    /// </summary>
    public class Groups : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Label DataErrorLabel;
        protected System.Web.UI.WebControls.Label Label1;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Put user code to initialize the page here
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\GetRecipientsListDataSetType.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace xlreportmgr 
{
    using System;
    using System.Data;
    using System.Xml;
    using System.Runtime.Serialization;
    
    
    [Serializable()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    [System.ComponentModel.ToolboxItem(true)]
    public class GetRecipientsListDataSetType : DataSet 
    {
        
        private _TableDataTable table_Table;
        
        public GetRecipientsListDataSetType() 
        {
            this.InitClass();
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        protected GetRecipientsListDataSetType(SerializationInfo info, StreamingContext context) 
        {
            string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
            if ((strSchema != null)) 
            {
                DataSet ds = new DataSet();
                ds.ReadXmlSchema(new XmlTextReader(new System.IO.StringReader(strSchema)));
                if ((ds.Tables["Table"] != null)) 
                {
                    this.Tables.Add(new _TableDataTable(ds.Tables["Table"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else 
            {
                this.InitClass();
            }
            this.GetSerializationData(info, context);
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DesignerSerializationVisibilityAttribute(System.ComponentModel.DesignerSerializationVisibility.Content)]
        public _TableDataTable _Table 
        {
            get 
            {
                return this.table_Table;
            }
        }
        
        public override DataSet Clone() 
        {
            GetRecipientsListDataSetType cln = ((GetRecipientsListDataSetType)(base.Clone()));
            cln.InitVars();
            return cln;
        }
        
        protected override bool ShouldSerializeTables() 
        {
            return false;
        }
        
        protected override bool ShouldSerializeRelations() 
        {
            return false;
        }
        
        protected override void ReadXmlSerializable(XmlReader reader) 
        {
            this.Reset();
            DataSet ds = new DataSet();
            ds.ReadXml(reader);
            if ((ds.Tables["Table"] != null)) 
            {
                this.Tables.Add(new _TableDataTable(ds.Tables["Table"]));
            }
            this.DataSetName = ds.DataSetName;
            this.Prefix = ds.Prefix;
            this.Namespace = ds.Namespace;
            this.Locale = ds.Locale;
            this.CaseSensitive = ds.CaseSensitive;
            this.EnforceConstraints = ds.EnforceConstraints;
            this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
            this.InitVars();
        }
        
        protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() 
        {
            System.IO.MemoryStream stream = new System.IO.MemoryStream();
            this.WriteXmlSchema(new XmlTextWriter(stream, null));
            stream.Position = 0;
            return System.Xml.Schema.XmlSchema.Read(new XmlTextReader(stream), null);
        }
        
        internal void InitVars() 
        {
            this.table_Table = ((_TableDataTable)(this.Tables["Table"]));
            if ((this.table_Table != null)) 
            {
                this.table_Table.InitVars();
            }
        }
        
        private void InitClass() 
        {
            this.DataSetName = "GetRecipientsListDataSetType";
            this.Prefix = "";
            this.Namespace = "http://www.tempuri.org/GetRecipientsListDataSetType.xsd";
            this.Locale = new System.Globalization.CultureInfo("en-US");
            this.CaseSensitive = false;
            this.EnforceConstraints = true;
            this.table_Table = new _TableDataTable();
            this.Tables.Add(this.table_Table);
        }
        
        private bool ShouldSerialize_Table() 
        {
            return false;
        }
        
        private void SchemaChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e) 
        {
            if ((e.Action == System.ComponentModel.CollectionChangeAction.Remove)) 
            {
                this.InitVars();
            }
        }
        
        public delegate void _TableRowChangeEventHandler(object sender, _TableRowChangeEvent e);
        
        [System.Diagnostics.DebuggerStepThrough()]
            public class _TableDataTable : DataTable, System.Collections.IEnumerable 
        {
            
            private DataColumn columnvc_email;
            
            internal _TableDataTable() : 
                base("Table") 
            {
                this.InitClass();
            }
            
            internal _TableDataTable(DataTable table) : 
                base(table.TableName) 
            {
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) 
                {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) 
                {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) 
                {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
                this.DisplayExpression = table.DisplayExpression;
            }
            
            [System.ComponentModel.Browsable(false)]
            public int Count 
            {
                get 
                {
                    return this.Rows.Count;
                }
            }
            
            internal DataColumn vc_emailColumn 
            {
                get 
                {
                    return this.columnvc_email;
                }
            }
            
            public _TableRow this[int index] 
            {
                get 
                {
                    return ((_TableRow)(this.Rows[index]));
                }
            }
            
            public event _TableRowChangeEventHandler _TableRowChanged;
            
            public event _TableRowChangeEventHandler _TableRowChanging;
            
            public event _TableRowChangeEventHandler _TableRowDeleted;
            
            public event _TableRowChangeEventHandler _TableRowDeleting;
            
            public void Add_TableRow(_TableRow row) 
            {
                this.Rows.Add(row);
            }
            
            public _TableRow Add_TableRow(string vc_email) 
            {
                _TableRow row_TableRow = ((_TableRow)(this.NewRow()));
                row_TableRow.ItemArray = new object[] {
                                                          vc_email};
                this.Rows.Add(row_TableRow);
                return row_TableRow;
            }
            
            public System.Collections.IEnumerator GetEnumerator() 
            {
                return this.Rows.GetEnumerator();
            }
            
            public override DataTable Clone() 
            {
                _TableDataTable cln = ((_TableDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            protected override DataTable CreateInstance() 
            {
                return new _TableDataTable();
            }
            
            internal void InitVars() 
            {
                this.columnvc_email = this.Columns["vc_email"];
            }
            
            private void InitClass() 
            {
                this.columnvc_email = new DataColumn("vc_email", typeof(string), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columnvc_email);
                this.columnvc_email.AllowDBNull = false;
            }
            
            public _TableRow New_TableRow() 
            {
                return ((_TableRow)(this.NewRow()));
            }
            
            protected override DataRow NewRowFromBuilder(DataRowBuilder builder) 
            {
                return new _TableRow(builder);
            }
            
            protected override System.Type GetRowType() 
            {
                return typeof(_TableRow);
            }
            
            protected override void OnRowChanged(DataRowChangeEventArgs e) 
            {
                base.OnRowChanged(e);
                if ((this._TableRowChanged != null)) 
                {
                    this._TableRowChanged(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowChanging(DataRowChangeEventArgs e) 
            {
                base.OnRowChanging(e);
                if ((this._TableRowChanging != null)) 
                {
                    this._TableRowChanging(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleted(DataRowChangeEventArgs e) 
            {
                base.OnRowDeleted(e);
                if ((this._TableRowDeleted != null)) 
                {
                    this._TableRowDeleted(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleting(DataRowChangeEventArgs e) 
            {
                base.OnRowDeleting(e);
                if ((this._TableRowDeleting != null)) 
                {
                    this._TableRowDeleting(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            public void Remove_TableRow(_TableRow row) 
            {
                this.Rows.Remove(row);
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
            public class _TableRow : DataRow 
        {
            
            private _TableDataTable table_Table;
            
            internal _TableRow(DataRowBuilder rb) : 
                base(rb) 
            {
                this.table_Table = ((_TableDataTable)(this.Table));
            }
            
            public string vc_email 
            {
                get 
                {
                    return ((string)(this[this.table_Table.vc_emailColumn]));
                }
                set 
                {
                    this[this.table_Table.vc_emailColumn] = value;
                }
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
            public class _TableRowChangeEvent : EventArgs 
        {
            
            private _TableRow eventRow;
            
            private DataRowAction eventAction;
            
            public _TableRowChangeEvent(_TableRow row, DataRowAction action) 
            {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            public _TableRow Row 
            {
                get 
                {
                    return this.eventRow;
                }
            }
            
            public DataRowAction Action 
            {
                get 
                {
                    return this.eventAction;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\RecipientManager.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for RecipientManager.
    /// </summary>
    public class RecipientManager : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.HyperLink HyperLink3;
        protected System.Web.UI.WebControls.HyperLink HyperLink2;
        protected System.Web.UI.WebControls.HyperLink HyperLink1;
        protected System.Web.UI.WebControls.Label Label1;
        protected System.Web.UI.WebControls.Label Label3;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            string command = Page.Request.Params["cmd"];

            switch(command)
            {
                case "users":
                    break;

                case "titles":
                    break;

                case "groups":
                    break;

            }
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\TitleRecipients.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for WebForm1.
    /// </summary>
    public class TitleRecipientsForm : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.DropDownList TitlesList;
        protected System.Data.SqlClient.SqlCommand GetTitlesCmd;
        protected System.Data.SqlClient.SqlConnection ReportDB;
        protected System.Web.UI.WebControls.Label Label2;
        protected System.Web.UI.WebControls.Label Label4;
        protected System.Web.UI.WebControls.DataList TitleRecipientsList;
        protected System.Data.SqlClient.SqlDataAdapter titleRecipientsAdapter;
        protected System.Data.SqlClient.SqlCommand GetTitleListCmd;
        protected System.Data.SqlClient.SqlDataAdapter GetTitleListAdapter;
        protected System.Data.DataSet titleRecipientsDataSet;
        protected System.Data.SqlClient.SqlCommand GetTitleRecipientsCmd;
        protected System.Data.SqlClient.SqlCommand InsertRecipientCmd;
        protected System.Data.SqlClient.SqlCommand DeleteRecipientCmd;
        protected System.Web.UI.WebControls.HyperLink Hyperlink4;
        protected System.Web.UI.WebControls.Panel Panel5;
        protected System.Web.UI.WebControls.HyperLink Hyperlink5;
        protected System.Web.UI.WebControls.Panel Panel4;
        protected System.Web.UI.WebControls.Label Label3;
        protected System.Web.UI.WebControls.Panel Panel1;
        protected System.Web.UI.WebControls.HyperLink Hyperlink6;
        protected System.Web.UI.WebControls.Panel Panel2;
        protected System.Web.UI.WebControls.Panel Panel3;
        protected System.Web.UI.WebControls.Label TitleNameLabel;
        protected System.Web.UI.WebControls.Button AddRecipientButton;
        protected System.Data.DataSet GetTitleListDataSet;
        protected System.Web.UI.WebControls.DropDownList SortList;
    
        private void FillTitleRecipientsDataSet(string TitleID)
        {
            FillTitleRecipientsDataSet(Int32.Parse(TitleID),SortList.SelectedValue);
        }

        private void FillTitleRecipientsDataSet(int iTitleID, string sortListValue)
        {
            GetTitleRecipientsCmd.Parameters[0].Value = iTitleID;
            GetTitleRecipientsCmd.Parameters[1].Value = sortListValue;

            titleRecipientsAdapter = new SqlDataAdapter();
            titleRecipientsAdapter.SelectCommand = GetTitleRecipientsCmd;
            titleRecipientsAdapter.InsertCommand = InsertRecipientCmd;
            titleRecipientsAdapter.DeleteCommand = DeleteRecipientCmd;
            titleRecipientsDataSet = new DataSet();
            titleRecipientsAdapter.Fill(titleRecipientsDataSet);
        }

        private void BindTitleRecipientsList(int iEditItemIndex)
        {
            TitleRecipientsList.DataSource = titleRecipientsDataSet.Tables[0].DefaultView;
            TitleRecipientsList.DataKeyField = "EMail";
            TitleRecipientsList.EditItemIndex = iEditItemIndex;
            TitleRecipientsList.DataBind();
        }

        private void Page_Load(object sender, System.EventArgs e)
        {
            try
            {
                ReportDB.Open();

                //
                //  Populate adapter and grid
                //
				
                if(TitlesList.SelectedIndex == -1)
                {
                    GetTitleListDataSet = new DataSet();
                    GetTitleListAdapter.Fill(GetTitleListDataSet);
                    TitlesList.DataSource = GetTitleListDataSet.Tables[0].DefaultView;
                    TitlesList.DataTextField = "vcTitleName";
                    TitlesList.DataValueField = "iTitleID";
                    TitlesList.DataBind();
                    if ( Request.QueryString.GetValues("iTitleID") != null)
                    {
                        TitlesList.SelectedValue = Request.QueryString.GetValues("iTitleID")[0];
                    }
                    else
                    {
                        TitlesList.SelectedIndex= 0;
                    }
				
				
                    FillTitleRecipientsDataSet(TitlesList.SelectedValue);
                    BindTitleRecipientsList(-1);
                }
                else
                    FillTitleRecipientsDataSet(TitlesList.SelectedValue);
            
                TitleNameLabel.Text = TitlesList.SelectedItem.Text;
				
            }
            finally
            {
                if(ReportDB.State == ConnectionState.Open)
                    ReportDB.Close();
            }
        }


        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            System.Configuration.AppSettingsReader configurationAppSettings = new System.Configuration.AppSettingsReader();
            this.GetTitleListCmd = new System.Data.SqlClient.SqlCommand();
            this.ReportDB = new System.Data.SqlClient.SqlConnection();
            this.GetTitleListAdapter = new System.Data.SqlClient.SqlDataAdapter();
            this.GetTitleRecipientsCmd = new System.Data.SqlClient.SqlCommand();
            this.InsertRecipientCmd = new System.Data.SqlClient.SqlCommand();
            this.DeleteRecipientCmd = new System.Data.SqlClient.SqlCommand();
            // 
            // GetTitleListCmd
            // 
            this.GetTitleListCmd.CommandText = "p_XRSupp_GetTitles";
            this.GetTitleListCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.GetTitleListCmd.Connection = this.ReportDB;
            this.GetTitleListCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@si_DownloadOnly", System.Data.SqlDbType.SmallInt, 0, System.Data.ParameterDirection.Input, false, ((System.Byte)(0)), ((System.Byte)(0)), "", System.Data.DataRowVersion.Current, "255"));
            // 
            // ReportDB
            // 
            this.ReportDB.ConnectionString = ((string)(configurationAppSettings.GetValue("ReportDB.ConnectionString", typeof(string))));
            // 
            // GetTitleListAdapter
            // 
            this.GetTitleListAdapter.SelectCommand = this.GetTitleListCmd;
            // 
            // GetTitleRecipientsCmd
            // 
            this.GetTitleRecipientsCmd.CommandText = "p_XR_Get_Title_Report_Recipients";
            this.GetTitleRecipientsCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.GetTitleRecipientsCmd.Connection = this.ReportDB;
            this.GetTitleRecipientsCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@iTitleID", System.Data.SqlDbType.Int));
            this.GetTitleRecipientsCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@sortBy", System.Data.SqlDbType.VarChar, 128));
            // 
            // InsertRecipientCmd
            // 
            this.InsertRecipientCmd.CommandText = "p_XR_InsertReportRecipient";
            this.InsertRecipientCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.InsertRecipientCmd.Connection = this.ReportDB;
            this.InsertRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcEmail", System.Data.SqlDbType.VarChar, 128));
            this.InsertRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcReportType", System.Data.SqlDbType.VarChar, 128));
            this.InsertRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@iTitleID", System.Data.SqlDbType.Int));
            this.InsertRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcRegion", System.Data.SqlDbType.VarChar, 128));
            this.InsertRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcFormat", System.Data.SqlDbType.VarChar, 128));
            // 
            // DeleteRecipientCmd
            // 
            this.DeleteRecipientCmd.CommandText = "p_XR_DeleteReportRecipient";
            this.DeleteRecipientCmd.CommandType = System.Data.CommandType.StoredProcedure;
            this.DeleteRecipientCmd.Connection = this.ReportDB;
            this.DeleteRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcEmail", System.Data.SqlDbType.VarChar, 128));
            this.DeleteRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcReportType", System.Data.SqlDbType.VarChar, 128));
            this.DeleteRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@iTitleID", System.Data.SqlDbType.Int));
            this.DeleteRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcRegion", System.Data.SqlDbType.VarChar, 128));
            this.DeleteRecipientCmd.Parameters.Add(new System.Data.SqlClient.SqlParameter("@vcFormat", System.Data.SqlDbType.VarChar, 128));
            this.TitlesList.SelectedIndexChanged += new System.EventHandler(this.TitlesList_SelectedIndexChanged);
            this.TitleRecipientsList.CancelCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.TitleRecipientsList_CancelCommand);
            this.TitleRecipientsList.EditCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.TitleRecipientsList_Clone);
            this.TitleRecipientsList.UpdateCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.TitleRecipientsList_UpdateCommand);
            this.TitleRecipientsList.DeleteCommand += new System.Web.UI.WebControls.DataListCommandEventHandler(this.TitleRecipientsList_DeleteCommand);
            this.AddRecipientButton.Click += new System.EventHandler(this.TitleRecipientsList_Add);
            this.Load += new System.EventHandler(this.Page_Load);

            // SortList
            this.SortList.SelectedIndexChanged += new System.EventHandler(this.SortList_SelectedIndexChanged);

        }
        #endregion
		
		
        public void Item_Bound(Object sender, DataListItemEventArgs e)
        {
			
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                Button deleteButton = (Button)e.Item.FindControl("deleteButton");
                if ( deleteButton != null)
                {
                    deleteButton.Attributes["onclick"] = "javascript:return confirm('Are you sure you want to delete this recipient from this title?')";   
                }
            }
			
        }

        public void SortByEmail_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortEmail");
        }
		
        public void SortByReportType_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortReportType");
        }

        public void SortByRegion_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortRegion");
        }

        public void SortByFormat_Click(object sender, System.EventArgs e)
        {
            SortByHeading("sortFormat");
        }

        private void SortByHeading(string param)
        {
            SortList.SelectedValue = param;
            FillTitleRecipientsDataSet(TitlesList.SelectedValue);
            BindTitleRecipientsList(-1);
            //BindTitleRecipientsList(TitleRecipientsList.EditItemIndex);
        }
		
        private void ExtraRefresh()
        {
            Response.Redirect("TitleRecipients.aspx?iTitleID="+TitlesList.SelectedValue);
        }

        private void TitleRecipientsList_EditCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            BindTitleRecipientsList(e.Item.ItemIndex);
        }

        private void TitleRecipientsList_CancelCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            BindTitleRecipientsList(-1);
        }

        private void TitleRecipientsList_DeleteCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
			
            DataRow delRow = titleRecipientsDataSet.Tables[0].Rows[e.Item.ItemIndex];

            DeleteRecipientCmd.Parameters[0].Value = delRow["EMail"];
            DeleteRecipientCmd.Parameters[1].Value = delRow["ReportType"];
            DeleteRecipientCmd.Parameters[2].Value = TitlesList.SelectedValue;
            DeleteRecipientCmd.Parameters[3].Value = delRow["Region"];
            DeleteRecipientCmd.Parameters[4].Value = delRow["Format"];

            delRow.Delete();

            titleRecipientsAdapter.Update(titleRecipientsDataSet);

            BindTitleRecipientsList(-1);
			
            ExtraRefresh();
        }

        private void TitleRecipientsList_UpdateCommand(object source, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            TextBox EMailEdit = (TextBox)e.Item.FindControl("EditRecip_Email");
            DropDownList ReportTypeList = (DropDownList)e.Item.FindControl("EditRecip_Reports");
            DropDownList RegionList = (DropDownList)e.Item.FindControl("EditRecip_Regions");
            DropDownList FormatList = (DropDownList)e.Item.FindControl("EditRecip_Formats");

            //
            //  Make sure all three controls are set
            //

            if(EMailEdit.Text.Length == 0 ||
                ReportTypeList.SelectedIndex == -1 ||
                RegionList.SelectedIndex == -1 ||
                FormatList.SelectedIndex == -1)
            {
                BindTitleRecipientsList(e.Item.ItemIndex);
                return;
            }

            //
            //  Create new row and add to data set
            //

            DataRow editRow = titleRecipientsDataSet.Tables[0].NewRow();
            editRow["EMail"] = EMailEdit.Text;
            editRow["ReportType"] = ReportTypeList.SelectedValue;
            editRow["Region"] = RegionList.SelectedItem.Text;
            editRow["Format"] = FormatList.SelectedItem.Text;

            //
            //  Check for dups
            //

            foreach(DataRow r in titleRecipientsDataSet.Tables[0].Rows)
            {
                if((string)r["EMail"] == EMailEdit.Text &&
                    (string)r["ReportType"] == ReportTypeList.SelectedValue &&
                    (string)r["Region"] == RegionList.SelectedItem.Text &&
                    (string)r["Format"] == FormatList.SelectedItem.Text)
                {
                    //
                    //  We found a dup, just re-edit the row
                    //  TODO - Some kind of notification to the user that a collision occurred
                    //

                    titleRecipientsDataSet.Tables[0].Rows.InsertAt(editRow, e.Item.ItemIndex);
                    BindTitleRecipientsList(e.Item.ItemIndex);
                    return;
                }
            }

            //
            //  Add new row to dataset and update db
            //

            titleRecipientsDataSet.Tables[0].Rows.InsertAt(editRow, e.Item.ItemIndex);

            InsertRecipientCmd.Parameters[0].Value = editRow["EMail"];
            InsertRecipientCmd.Parameters[1].Value = editRow["ReportType"];
            InsertRecipientCmd.Parameters[2].Value = TitlesList.SelectedValue;
            InsertRecipientCmd.Parameters[3].Value = editRow["Region"];
            InsertRecipientCmd.Parameters[4].Value = editRow["Format"];

            titleRecipientsAdapter.Update(titleRecipientsDataSet);

            FillTitleRecipientsDataSet(TitlesList.SelectedValue);
            BindTitleRecipientsList(-1);
            ExtraRefresh();
        }

        private void TitleRecipientsList_Add(object sender, System.EventArgs e)
        {
            DataRow newRow = titleRecipientsDataSet.Tables[0].NewRow();

            newRow["EMail"] = "";
            newRow["ReportType"] = "";
            newRow["Region"] = "";
            newRow["Format"] = "";

            titleRecipientsDataSet.Tables[0].Rows.InsertAt(newRow, 0);

            BindTitleRecipientsList(0);
        }

        private void TitleRecipientsList_Clone(object sender, System.Web.UI.WebControls.DataListCommandEventArgs e)
        {
            DataRow cloneRow = titleRecipientsDataSet.Tables[0].NewRow();
            DataRow originalRow = titleRecipientsDataSet.Tables[0].Rows[e.Item.ItemIndex];

            cloneRow["EMail"] = originalRow["EMail"];
            cloneRow["ReportType"] = originalRow["ReportType"];
            cloneRow["Region"] = originalRow["Region"];
            cloneRow["Format"] = originalRow["Format"];
			
            titleRecipientsDataSet.Tables[0].Rows.InsertAt(cloneRow, e.Item.ItemIndex + 1);

            BindTitleRecipientsList(e.Item.ItemIndex + 1);
        }

        private void TitlesList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            FillTitleRecipientsDataSet(TitlesList.SelectedValue);
            BindTitleRecipientsList(-1);
        }
        private void SortList_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            BindTitleRecipientsList(-1);
            //BindTitleRecipientsList(TitleRecipientsList.EditItemIndex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\GetTitlesDataSetType.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace xlreportmgr 
{
    using System;
    using System.Data;
    using System.Xml;
    using System.Runtime.Serialization;
    
    
    [Serializable()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Diagnostics.DebuggerStepThrough()]
    [System.ComponentModel.ToolboxItem(true)]
    public class GetTitlesDataSetType : DataSet 
    {
        
        private _TableDataTable table_Table;
        
        public GetTitlesDataSetType() 
        {
            this.InitClass();
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        protected GetTitlesDataSetType(SerializationInfo info, StreamingContext context) 
        {
            string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
            if ((strSchema != null)) 
            {
                DataSet ds = new DataSet();
                ds.ReadXmlSchema(new XmlTextReader(new System.IO.StringReader(strSchema)));
                if ((ds.Tables["Table"] != null)) 
                {
                    this.Tables.Add(new _TableDataTable(ds.Tables["Table"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else 
            {
                this.InitClass();
            }
            this.GetSerializationData(info, context);
            System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            this.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        [System.ComponentModel.Browsable(false)]
        [System.ComponentModel.DesignerSerializationVisibilityAttribute(System.ComponentModel.DesignerSerializationVisibility.Content)]
        public _TableDataTable _Table 
        {
            get 
            {
                return this.table_Table;
            }
        }
        
        public override DataSet Clone() 
        {
            GetTitlesDataSetType cln = ((GetTitlesDataSetType)(base.Clone()));
            cln.InitVars();
            return cln;
        }
        
        protected override bool ShouldSerializeTables() 
        {
            return false;
        }
        
        protected override bool ShouldSerializeRelations() 
        {
            return false;
        }
        
        protected override void ReadXmlSerializable(XmlReader reader) 
        {
            this.Reset();
            DataSet ds = new DataSet();
            ds.ReadXml(reader);
            if ((ds.Tables["Table"] != null)) 
            {
                this.Tables.Add(new _TableDataTable(ds.Tables["Table"]));
            }
            this.DataSetName = ds.DataSetName;
            this.Prefix = ds.Prefix;
            this.Namespace = ds.Namespace;
            this.Locale = ds.Locale;
            this.CaseSensitive = ds.CaseSensitive;
            this.EnforceConstraints = ds.EnforceConstraints;
            this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
            this.InitVars();
        }
        
        protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() 
        {
            System.IO.MemoryStream stream = new System.IO.MemoryStream();
            this.WriteXmlSchema(new XmlTextWriter(stream, null));
            stream.Position = 0;
            return System.Xml.Schema.XmlSchema.Read(new XmlTextReader(stream), null);
        }
        
        internal void InitVars() 
        {
            this.table_Table = ((_TableDataTable)(this.Tables["Table"]));
            if ((this.table_Table != null)) 
            {
                this.table_Table.InitVars();
            }
        }
        
        private void InitClass() 
        {
            this.DataSetName = "GetTitlesDataSetType";
            this.Prefix = "";
            this.Namespace = "http://www.tempuri.org/GetTitlesDataSetType.xsd";
            this.Locale = new System.Globalization.CultureInfo("en-US");
            this.CaseSensitive = false;
            this.EnforceConstraints = true;
            this.table_Table = new _TableDataTable();
            this.Tables.Add(this.table_Table);
        }
        
        private bool ShouldSerialize_Table() 
        {
            return false;
        }
        
        private void SchemaChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e) 
        {
            if ((e.Action == System.ComponentModel.CollectionChangeAction.Remove)) 
            {
                this.InitVars();
            }
        }
        
        public delegate void _TableRowChangeEventHandler(object sender, _TableRowChangeEvent e);
        
        [System.Diagnostics.DebuggerStepThrough()]
            public class _TableDataTable : DataTable, System.Collections.IEnumerable 
        {
            
            private DataColumn columniTitleID;
            
            private DataColumn columnvcTitleName;
            
            private DataColumn columntiDownloadOnly;
            
            private DataColumn columntiBetaTitle;
            
            private DataColumn columntiPackinTitle;
            
            internal _TableDataTable() : 
                base("Table") 
            {
                this.InitClass();
            }
            
            internal _TableDataTable(DataTable table) : 
                base(table.TableName) 
            {
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) 
                {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) 
                {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) 
                {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
                this.DisplayExpression = table.DisplayExpression;
            }
            
            [System.ComponentModel.Browsable(false)]
            public int Count 
            {
                get 
                {
                    return this.Rows.Count;
                }
            }
            
            internal DataColumn iTitleIDColumn 
            {
                get 
                {
                    return this.columniTitleID;
                }
            }
            
            internal DataColumn vcTitleNameColumn 
            {
                get 
                {
                    return this.columnvcTitleName;
                }
            }
            
            internal DataColumn tiDownloadOnlyColumn 
            {
                get 
                {
                    return this.columntiDownloadOnly;
                }
            }
            
            internal DataColumn tiBetaTitleColumn 
            {
                get 
                {
                    return this.columntiBetaTitle;
                }
            }
            
            internal DataColumn tiPackinTitleColumn 
            {
                get 
                {
                    return this.columntiPackinTitle;
                }
            }
            
            public _TableRow this[int index] 
            {
                get 
                {
                    return ((_TableRow)(this.Rows[index]));
                }
            }
            
            public event _TableRowChangeEventHandler _TableRowChanged;
            
            public event _TableRowChangeEventHandler _TableRowChanging;
            
            public event _TableRowChangeEventHandler _TableRowDeleted;
            
            public event _TableRowChangeEventHandler _TableRowDeleting;
            
            public void Add_TableRow(_TableRow row) 
            {
                this.Rows.Add(row);
            }
            
            public _TableRow Add_TableRow(int iTitleID, string vcTitleName, System.Byte tiDownloadOnly, System.Byte tiBetaTitle, System.Byte tiPackinTitle) 
            {
                _TableRow row_TableRow = ((_TableRow)(this.NewRow()));
                row_TableRow.ItemArray = new object[] {
                                                          iTitleID,
                                                          vcTitleName,
                                                          tiDownloadOnly,
                                                          tiBetaTitle,
                                                          tiPackinTitle};
                this.Rows.Add(row_TableRow);
                return row_TableRow;
            }
            
            public System.Collections.IEnumerator GetEnumerator() 
            {
                return this.Rows.GetEnumerator();
            }
            
            public override DataTable Clone() 
            {
                _TableDataTable cln = ((_TableDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            protected override DataTable CreateInstance() 
            {
                return new _TableDataTable();
            }
            
            internal void InitVars() 
            {
                this.columniTitleID = this.Columns["iTitleID"];
                this.columnvcTitleName = this.Columns["vcTitleName"];
                this.columntiDownloadOnly = this.Columns["tiDownloadOnly"];
                this.columntiBetaTitle = this.Columns["tiBetaTitle"];
                this.columntiPackinTitle = this.Columns["tiPackinTitle"];
            }
            
            private void InitClass() 
            {
                this.columniTitleID = new DataColumn("iTitleID", typeof(int), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columniTitleID);
                this.columnvcTitleName = new DataColumn("vcTitleName", typeof(string), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columnvcTitleName);
                this.columntiDownloadOnly = new DataColumn("tiDownloadOnly", typeof(System.Byte), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columntiDownloadOnly);
                this.columntiBetaTitle = new DataColumn("tiBetaTitle", typeof(System.Byte), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columntiBetaTitle);
                this.columntiPackinTitle = new DataColumn("tiPackinTitle", typeof(System.Byte), null, System.Data.MappingType.Element);
                this.Columns.Add(this.columntiPackinTitle);
                this.columniTitleID.AllowDBNull = false;
                this.columnvcTitleName.AllowDBNull = false;
                this.columntiDownloadOnly.AllowDBNull = false;
                this.columntiBetaTitle.AllowDBNull = false;
                this.columntiPackinTitle.AllowDBNull = false;
            }
            
            public _TableRow New_TableRow() 
            {
                return ((_TableRow)(this.NewRow()));
            }
            
            protected override DataRow NewRowFromBuilder(DataRowBuilder builder) 
            {
                return new _TableRow(builder);
            }
            
            protected override System.Type GetRowType() 
            {
                return typeof(_TableRow);
            }
            
            protected override void OnRowChanged(DataRowChangeEventArgs e) 
            {
                base.OnRowChanged(e);
                if ((this._TableRowChanged != null)) 
                {
                    this._TableRowChanged(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowChanging(DataRowChangeEventArgs e) 
            {
                base.OnRowChanging(e);
                if ((this._TableRowChanging != null)) 
                {
                    this._TableRowChanging(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleted(DataRowChangeEventArgs e) 
            {
                base.OnRowDeleted(e);
                if ((this._TableRowDeleted != null)) 
                {
                    this._TableRowDeleted(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            protected override void OnRowDeleting(DataRowChangeEventArgs e) 
            {
                base.OnRowDeleting(e);
                if ((this._TableRowDeleting != null)) 
                {
                    this._TableRowDeleting(this, new _TableRowChangeEvent(((_TableRow)(e.Row)), e.Action));
                }
            }
            
            public void Remove_TableRow(_TableRow row) 
            {
                this.Rows.Remove(row);
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
            public class _TableRow : DataRow 
        {
            
            private _TableDataTable table_Table;
            
            internal _TableRow(DataRowBuilder rb) : 
                base(rb) 
            {
                this.table_Table = ((_TableDataTable)(this.Table));
            }
            
            public int iTitleID 
            {
                get 
                {
                    return ((int)(this[this.table_Table.iTitleIDColumn]));
                }
                set 
                {
                    this[this.table_Table.iTitleIDColumn] = value;
                }
            }
            
            public string vcTitleName 
            {
                get 
                {
                    return ((string)(this[this.table_Table.vcTitleNameColumn]));
                }
                set 
                {
                    this[this.table_Table.vcTitleNameColumn] = value;
                }
            }
            
            public System.Byte tiDownloadOnly 
            {
                get 
                {
                    return ((System.Byte)(this[this.table_Table.tiDownloadOnlyColumn]));
                }
                set 
                {
                    this[this.table_Table.tiDownloadOnlyColumn] = value;
                }
            }
            
            public System.Byte tiBetaTitle 
            {
                get 
                {
                    return ((System.Byte)(this[this.table_Table.tiBetaTitleColumn]));
                }
                set 
                {
                    this[this.table_Table.tiBetaTitleColumn] = value;
                }
            }
            
            public System.Byte tiPackinTitle 
            {
                get 
                {
                    return ((System.Byte)(this[this.table_Table.tiPackinTitleColumn]));
                }
                set 
                {
                    this[this.table_Table.tiPackinTitleColumn] = value;
                }
            }
        }
        
        [System.Diagnostics.DebuggerStepThrough()]
            public class _TableRowChangeEvent : EventArgs 
        {
            
            private _TableRow eventRow;
            
            private DataRowAction eventAction;
            
            public _TableRowChangeEvent(_TableRow row, DataRowAction action) 
            {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            public _TableRow Row 
            {
                get 
                {
                    return this.eventRow;
                }
            }
            
            public DataRowAction Action 
            {
                get 
                {
                    return this.eventAction;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xlreportmgr_none_12.4.56.0_none_36eab0a149888c4f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlreportmgr
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.manifest
XP_MANIFEST_PATH=manifests\msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.cat
XP_CATALOG_PATH=manifests\msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.cat
XP_PAYLOAD_PATH=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlreportmgr,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xlreportmgr_none_12.4.56.0_none_36eab0a149888c4f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlreportmgr
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.manifest
XP_MANIFEST_PATH=manifests\msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.cat
XP_CATALOG_PATH=manifests\msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573.cat
XP_PAYLOAD_PATH=msil_xlreportmgr_no-public-key_12.4.56.0_x-ww_f7406573
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlreportmgr,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xereports\xlreportmgr\TOC.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xlreportmgr
{
    /// <summary>
    /// Summary description for Contents.
    /// </summary>
    public class TableOfContents : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.HyperLink HyperLink3;
        protected System.Web.UI.WebControls.HyperLink HyperLink1;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Put user code to initialize the page here
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
		
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xerr\extension\qmacros_empty.h ===
/*++

  QMACROS_EMPTY.H

  Copyright (C) 2004 Microsoft Corporation, all rights reserved

  DESCRIPTION: This header disables the macros that aren't 
  defined (so including a TBL file won't cause compile errors)

  Created, Nov 9, 2005 by David L. Christiansen

--*/

#ifndef QQ
#define QQ( x ) // nothing
#endif

#ifndef QMSG
#define QMSG( x, y, z ) // nothing
#endif

#ifndef QNUM
#define QNUM( x, y ) // nothing
#endif

#ifndef POST
#define POST( x, y ) // nothing
#endif

#ifndef PRE
#define PRE( x, y ) // nothing
#endif

#ifndef OBSOLETE
#define OBSOLETE( x ) // nothing
#endif

#ifndef PRE_HR
#define PRE_HR( x, y ) //nothing
#endif

#ifndef HR_FAC
#define HR_FAC( x, y ) // nothing
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xerr\extension\errext.h ===
/*++

  ERREXT.H

  Copyright (C) 2005 Microsoft Corporation, all rights reserved

  DESCRIPTION: This header describes how extenders can add their errors to
  ERR or EVT, and what datastructures and interfaces are necessary.

  When the application is invoked, it checks its run directory for DLLs
  named "err_*.dll" (or evt_*.dll).  Those it finds it loads.

  When it loads that DLL, it will call its RegisterIdentifierTable function,
  which will fill in a structure that lists all tables exported by the DLL.

  ERR will merge these tables into its own list for queries.

  Created, Nov 8, 2005 by David L. Christiansen

--*/

/*++**********************************************************
  SIMPLE_MAPPING:
  This structure defines a single result code.
 ************************************************************/

typedef struct {

  PCHAR Name;        // Example: "ERROR_SUCCESS"
  DWORD Value;       // Example: ERROR_SUCCESS (or 0)
  LPSTR MessageText; // OPTIONAL.  Example: "Everything is okay."
  
} SIMPLE_MAPPING, *PSIMPLE_MAPPING;

/*++***********************************************************
  ERROR_TABLE_v1:
  
  This structure lists out a source (usually a header file),
  and points to arrays of result codes and hresult facilities
  (these are arrays of SIMPLE_MAPPINGs, above)
 *************************************************************/

typedef struct {

  LPSTR           SourceDescription; // Example:  "winerror.h"
  PSIMPLE_MAPPING pResultCodes;      // an array of error codes
  ULONG           cResultCodes;      // #entries in that array

  // these next two are if you want to include your own HRESULTs
  // (so ERR can decode malformed errors built with your results,
  // which can be very useful -- it does happen)

  PSIMPLE_MAPPING pFacilities;       // an array of HRESULT facility codes
  ULONG           cFacilities;       // #entries in that array

} ERROR_TABLE_V1, *PERROR_TABLE_V1;

/*++**********************************************************
  TABLE_REGISTRATION_V1:

  Each extender will have one or more sources (headers), each
  of which needs an ERROR_TABLE_V1 entry to be indexed by ERR.

  Each source will have one or more Results (error codes), each
  of which needs a SIMPLE_MAPPING entry to be indexed by ERR.
    
 *************************************************************/

typedef struct {
  
  OUT ULONG           cTables;       // you may have more than one source
  OUT PERROR_TABLE_V1 pTables;       // if so, list them all

} TABLE_REGISTRATION_V1, *PTABLE_REGISTRATION_V1;


/*++**********************************************************
  RegisterIdentifierTable_v1:
  
  This is the function you need to implement.
  When called, it needs to fill out its cTables and pTables with
  ERROR_TABLE data.  

  Note that this function can fail, although I don't expect anyone
  to do so (the DLLs are just static data).  If the function fails,
  ERR will print a diagnostic message and terminate.  Likelihood is
  that the user will uninstall your DLL if you do this, so don't do
  it without a good reason. 

  Note that there is no cleanup.  ERR is a short-lived EXE, so
  if you allocate memory, it will happily leak until the app 
  terminates less than a second later.  :-)
  --***********************************************************/

typedef BOOL (__cdecl REGISTER_IDENT_FUNCTION_V1)( IN OUT PTABLE_REGISTRATION_V1 );

REGISTER_IDENT_FUNCTION_V1
RegisterIdentifierTable_v1;

#define REGISTER_IDENT_FUNCTION_V1_NAME "RegisterIdentifierTable_v1"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xerr\extension\qmacros_off.h ===
/*++

  QMACROS_OFF.H

  Copyright (C) 2004 Microsoft Corporation, all rights reserved

  DESCRIPTION: This header undefines all the 'Q' macros

  Created, Nov 9, 2005 by David L. Christiansen

--*/

#undef PRE
#undef QQ
#undef QMSG
#undef QNUM
#undef POST
#undef OBSOLETE
#undef PRE_HR
#undef HR_FAC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xerr\xerr\err_xonline.c ===
#include <xboxverp.h>
#include <common.ver>

#include <windows.h>
//typedef DWORD NTSTATUS;

#include "errext.h" // ...for your extension needs...

#include "qmacros_SIMPLE_MAPPING.h" // for working with .tbl files
#include "tablefiles\bdkerror_cs.tbl"
#include "tablefiles\hresult_cs.tbl"
#include "tablefiles\passportrpsutil_cs.tbl"
#include "tablefiles\XonCTPHResult_cs.tbl"

#include "qmacros_off.h" // switch off the Q macros


ERROR_TABLE_V1
ErrorTables[] = {

  { "bdkerror.cs",
    bdkerrorTable,
    ARRAYSIZE(bdkerrorTable),
  },
  { "hresult.cs",
    hresultTable,
    ARRAYSIZE(hresultTable),
  },
  { "passportrpsutil.cs",
    passportrpsutilTable,
    ARRAYSIZE(passportrpsutilTable),
  },
  { "xonctphresult.cs",
    xonctphresultTable,
    ARRAYSIZE(xonctphresultTable),
  }
};


BOOL
__cdecl
RegisterIdentifierTable_v1( OUT PTABLE_REGISTRATION_V1 p ) {

    p->cTables = ARRAYSIZE( ErrorTables );
    p->pTables = ErrorTables;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xerr\xerr\makefile.inc ===
UpdateTableFiles:
	create-service-error-files.cmd $(_NTDRIVE)$(_NTROOT)
CopyToErrDir:
!if "$(BUILD_PASS)" == "PASS2" || "$(BUILD_PASS)" == "ALL"
!if "$(386)" == "1"
	copy /Y $(O)\err_xonline.dll $(_NTDRIVE)$(_NTROOT)\public\ext\tools\x86\xerr
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\addfreq.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

BOOL AddFrequentlyUsedKey(
    ULONG   ulKeyType,
    ULONG   ulKeyVersion,
    LPCSTR  szPublicKeyFile,
    LPCSTR  szKeyFile,
    ULONG   ulKeyLen,
    LPCSTR  szKeyData1,
    LPCSTR  szKeyData2,
    ULONG   ulSiteID,
    ULONG   ulLifetime,
    LPCSTR  szSGConfigFile,
    BOOL    fUpdate
    )
{
    XOCryptoMasterKeyEncryptedStruct    key;
    LPBYTE                              pKey = NULL;
    LPBYTE                              pPublicKey = NULL;
    DWORD                               cbPublicKey;
    HRESULT                             hr;
    XCmdInsertKey                       cmd;
    CComPtr<IWSTStore>                  piWebstore;
    CComPtr<IWSTCommand>                piCommand;
    CComPtr<IWSTDTC>                    piDTC;
    ULONG                               ulMasterKeyVersion;
    LPSTR                               szKeyString = NULL;
    BOOL                                ok = FALSE;
    BOOL                                fValidated = FALSE;

    //
    //  Validate parameters
    //

    if(szKeyFile != NULL && ulKeyLen != 0xFFFFFFFF)
    {
        PrintError("Specify either a file containing the key to add, or the length of the key to be randomly generated, but not both.\r\n");
        goto Cleanup;
    }

    if(szKeyFile == NULL && ulKeyLen == 0xFFFFFFFF)
    {
        PrintError("You must specify either the name of a file containing the key to add, or the length of the key to be randomly generated.\r\n");
        goto Cleanup;
    }

    if(ulKeyLen != 0xFFFFFFFF && (ulKeyLen > SERVICE_KEY_SIZE || ulKeyLen < 1))
    {
        PrintError("Specified key length is too big.  Must be between 1 and %d bytes, inclusive.\r\n", SERVICE_KEY_SIZE);
        goto Cleanup;
    }

    if(ulKeyType == KEY_TYPE_SECURITY_GATEWAY && (szSGConfigFile == NULL || ulSiteID == 0xFFFFFFFF))
    {
        PrintError("-s and -c parameters are required for security gateway keys.\r\n");
        goto Cleanup;
    }

    //
    //  Get public key from file.
    //

    if(!ReadBlobFromFile(szPublicKeyFile, pPublicKey, cbPublicKey))
        goto Cleanup;

    ulMasterKeyVersion = *(PULONG)pPublicKey;

    hr = ValidatePublicKey(pPublicKey, cbPublicKey, &fValidated);
    if(SUCCEEDED(hr) && !fValidated)
    {
        PrintError("WARNING: public key does not match stored private key.\r\n");
    }

    //
    //  Create and initialize the webstore object.
    //

    hr = GetNPDBWebstore(&piWebstore);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Get the command interface
    //

    hr = piWebstore->QueryInterface(&piCommand);
    if(FAILED(hr))
    {
        PrintError("Failed to get command interface on webstore client.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    hr = piCommand->GetDTC(&piDTC);
    if(FAILED(hr))
    {
        PrintError("Failed to get DTC interface on webstore client.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Read the key from the file into the key struct in 
    //  preparation for encrypting.
    //

    if(szKeyFile != NULL)
    {
        if(!ReadBlobFromFile(szKeyFile, pKey, key.dwKeyLen))
            goto Cleanup;
        
        if(key.dwKeyLen > SERVICE_KEY_SIZE)
        {
            PrintError("The key read from the file is too big.  Maximum key size is %d bytes, %u bytes were read from %s.\r\n",
                SERVICE_KEY_SIZE,
                key.dwKeyLen,
                szKeyFile);
            goto Cleanup;
        }

        memcpy(key.abKey, pKey, key.dwKeyLen);
    }

    if(ulKeyLen != 0xFFFFFFFF)
    {
        key.dwKeyLen = ulKeyLen;
        XOCryptGenRandom(key.abKey, key.dwKeyLen);
    }

    //
    //  If we're going to be writing the key to a config file, format the key string
    //

    if(szSGConfigFile != NULL)
    {
        ULONG ulCurByte;

        szKeyString = (LPSTR)malloc((key.dwKeyLen * 2) + 1);
        if(szKeyString == NULL)
        {
            PrintError("Out of memory allocating buffer for key string.\r\n");
            goto Cleanup;
        }

        for(ulCurByte = 0; ulCurByte < key.dwKeyLen; ++ulCurByte)
        {
            sprintf(szKeyString + (2 * ulCurByte),
                    "%02X",
                    key.abKey[ulCurByte]);
        }
    }

    //
    //  Now encrypt the key, in place.
    //

    hr = EncryptWithMasterKey(ulMasterKeyVersion, 
                              pPublicKey + sizeof(ULONG), 
                              cbPublicKey - sizeof(ULONG), 
                              &key);
    if(hr != S_OK)
    {
        PrintError("Failed to encrypt the new key.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Now shove the key into the DB
    //

    //  first initialize command object

    cmd.m_i_key_type = ulKeyType;
    cmd.m_i_key_ver  = ulKeyVersion;
    cmd.m_i_master_key_ver = ulMasterKeyVersion;
    cmd.m_i_site_id = ulSiteID;
    cmd.m_i_lifetime = ulLifetime;
    cmd.m_i_update = fUpdate;

    if(szKeyData1 != NULL)
    {
        int nNameLen = strlen(szKeyData1);
        if(nNameLen > 199)
            nNameLen = 199;
        else
            ++nNameLen;
        
        cmd.m_i_data1_len = MultiByteToWideChar(
                                CP_ACP, 
                                0, szKeyData1, 
                                nNameLen, 
                                cmd.m_nvc_data1, 
                                sizeof(cmd.m_nvc_data1)/sizeof(WCHAR));
        cmd.m_nvc_data1[199] = L'\0';
    }
    else
    {
        cmd.m_i_data1_len = 0;
        memset(cmd.m_nvc_data1, 0, sizeof(cmd.m_nvc_data1));
    }

    if(szKeyData2 != NULL)
    {
        int nNameLen = strlen(szKeyData2);
        if(nNameLen > 199)
            nNameLen = 199;
        else
            ++nNameLen;
        
        cmd.m_i_data2_len = MultiByteToWideChar(
                                CP_ACP, 
                                0, szKeyData2, 
                                nNameLen, 
                                cmd.m_nvc_data2, 
                                sizeof(cmd.m_nvc_data2)/sizeof(WCHAR));
        cmd.m_nvc_data2[199] = L'\0';
    }
    else
    {
        cmd.m_i_data2_len = 0;
        memset(cmd.m_nvc_data2, 0, sizeof(cmd.m_nvc_data2));
    }

    cmd.m_i_key_len = key.dwKeyLen;
    memcpy(cmd.m_bin_key, key.abKey, key.dwKeyLen);

    //  execute the command, within a transaction

    hr = ExecuteWithParameters(
            piCommand, 
            cmd, 
            WRITEONLY_COMMANDTYPE,
            ALL_DATABASES);
    if(FAILED(hr))
    {
        PrintError("Failed to insert key into database.  Error = 0x%08X.\r\n", hr);
        PrintExtendedDatabaseError();
        goto Cleanup;
    }

    if(cmd.m_RETURNVALUE == XONLINE_E_UODB_KEY_ALREADY_EXISTS)
    {
        PrintError("This key already exists in the database.  The existing key was not modified.\r\n");
        goto Cleanup;
    }
    else if(cmd.m_RETURNVALUE != 0)
    {
        PrintError("Failed to insert key into database.  Error = 0x%08X.\r\n", cmd.m_RETURNVALUE);
        goto Cleanup;
    }

    printf("The key has been encrypted with master key version %u and inserted into the database.\r\n",
           ulMasterKeyVersion);

    //
    //  If a config file was specified, format the data and write to the file.
    //

    if(szSGConfigFile != NULL)
    {
        CHAR szConfig[256];

        wsprintfA(szConfig, 
                  "SiteKey { SiteId %u Version %u Data %s }\n",
                  ulSiteID,
                  ulKeyVersion,
                  szKeyString);

        if(!WriteBlobToFile(szSGConfigFile, (LPBYTE)szConfig, lstrlenA(szConfig) + 1, FALSE))
            goto Cleanup;

        printf("Key configuration successfully written to \"%s\".\r\n", szSGConfigFile);
    }

    ok = TRUE;

Cleanup:

    if(szKeyString != NULL)
        free(szKeyString);

    if(pKey != NULL)
        free(pKey);

    if(pPublicKey != NULL)
        free(pPublicKey);

    if(piWebstore != NULL)
    {
        piWebstore->DeInitialize();
    }

    return ok;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\addplayreadycert.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

// --------------------------------------------------------------------------------------
// AddWmdrmCert
//
// Stores a PlayReady model certificate in NPDB.t_settings and the corresponding
// private key in NPDB.t_service_keys.
//
// The certificate is stored in t_config_blobs as "xsig_playready_xbox360_model_cert"
//
// The private key is encrypted with the master key and stored with key type KEY_TYPE_PLAYREADY_XBOX360_MODEL_PRIVATE_KEY (17)
//
// szPlayReadyXbox360ModelPrivKeyFile: name of the file containing the playready xbox360 device private key
// szPlayRedyXbox360ModelCertFile: name of the file containing the playreday xbox360 device certificate
// --------------------------------------------------------------------------------------
void AddPlayReadyCert(LPCSTR szMasterKeyPubFile,
                 LPCSTR szPlayReadyXbox360ModelPrivKeyFile,
                 LPCSTR szPlayReadyXbox360ModelCertFile)
{
    BYTE*  pCertBytes     = NULL;
    DWORD  cbCertBytes    = 0;
    HRESULT hr;
    BOOL ok;

    //
    // Store the (encrypted) private key...
    //
    printf("Writing private key from file %s to npdb.t_service_keys with key-type %d\n",
           szPlayReadyXbox360ModelPrivKeyFile, KEY_TYPE_PLAYREADY_XBOX360_MODEL_PRIVATE_KEY);

    ok = AddFrequentlyUsedKey(
        KEY_TYPE_PLAYREADY_XBOX360_MODEL_PRIVATE_KEY,
        1,                                          // ulKeyVersion
        szMasterKeyPubFile,                         // szPublicKeyFile
        szPlayReadyXbox360ModelPrivKeyFile,
        0xFFFFFFFF,                                 // ulKeyLen
        "PlayReady Xbox 360 Device Private Key",    // szKeyData1
        NULL,                                       // szKeyData2
        0xFFFFFFFF,                                 // ulSiteID
        0xFFFFFFFF,                                 // ulLifeTime
        NULL,                                       // szSGConfigFile
        TRUE                                        // fUpdateIfExists
        );

    if(!ok)
    {
        PrintError("Failed to write private key to npdb. Aborting.\n");
        goto Exit;
    }

    //
    // Read certificate file
    //
    printf("Reading Wmdrm certificate file: %s\n", szPlayReadyXbox360ModelCertFile);

    if(!ReadBlobFromFile(szPlayReadyXbox360ModelCertFile, /*OUT*/pCertBytes, /*OUT*/cbCertBytes))
    {
        goto Exit;
    }

    printf("Size of certificate: %u\n", cbCertBytes);

    //
    // Store certificate in npdb
    //
    printf("Writting certificate to Npdb.t_config_blobs with name "
           "'playready_model_cert'\n");

    {
        CODBWSession npdb;
        static CWSProcCache pc;

        const WCHAR *pConnStr = GetNpdbConnectionString();
        if (pConnStr == NULL)
        {
            goto Exit;
        }

        if(FAILED(hr = npdb.InitializeEx(pConnStr)))
        {
            PrintError("Failed to connect to NPDB. InitializeEx failed. hr=0x%08x\n", hr);
            goto Exit;
        }

        if(FAILED(hr = npdb.CallProc(
                    &pc, L"dbo.p_config_blob_set %64S, %vlB",
                    "playready_model_cert",
                    pCertBytes,
                    cbCertBytes)))
        {
            PrintError("Failed to execute dbo.p_config_blob_set. hr=0x%08x\n", hr);
            PrintExtendedDatabaseError();
            goto Exit;
        }
    }

    printf("Done!\n");

Exit:

    if(pCertBytes)
    {
        free(pCertBytes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xerr\extension\qmacros_SIMPLE_MAPPING.h ===
/*++

  QMACROS_SIMPLE_MAPPING.H

  Copyright (C) 2004 Microsoft Corporation, all rights reserved

  DESCRIPTION: this file defines the qmacros so that including a .tbl
  file will generate a SIMPLE_MAPPING.

  USAGE: 
  #include "qmacros_SIMPLE_MAPPING.h"
  #include "myfile.tbl"
  #include "qmacros_off.h"

  ...where myfile.tbl includes:

  PRE( winerror, ".h" )
  QQ( ERROR_SUCCESS )
  QQ( ERROR_NOT_ENOUGH_MEMORY )
  POST( winerror, ".h" )

  ...will produce:

  SIMPLE_MAPPING winerrorTable[] = {  // from PRE
    { "ERROR_SUCCESS", ERROR_SUCCESS }, // QQ
    { "ERROR_NOT_ENOUGH_MEMORY", ERROR_NOT_ENOUGH_MEMORY },  // QQ
  }; // from POST

  Note that the last entry in the array still ends with a comma.
  That's okay.

  Created, Nov 9, 2005 by David L. Christiansen

--*/

#define PRE( x, y ) SIMPLE_MAPPING x ## Table[] = {
#define PRE_HR( x, y ) PRE( x, y )
#define OBSOLETE( x ) SIMPLE_MAPPING Obsolete_ ## x ## Table[] = {
#define QQ( x ) { #x, x },
#define QNUM( x, y ) { #x, y },
#define QMSG( x, y, z ) { y, x, z },
#define POST( x, y ) };
#define HR_FAC( x, y ) // nothing
#define POST_HR( x, y ) POST( x, y )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\createrk.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

void CreateRandomKey(
    LPCSTR  szFilePath, 
    ULONG   ulNumRandomBytes
    )
{
    LPBYTE  pKey = NULL;

    //
    //  Allocate buffer for key
    //

    pKey = (LPBYTE)malloc(ulNumRandomBytes);
    if(pKey == NULL)
    {
        printf("Failed to allocate buffer for key, out of memory.\r\n");
        goto Cleanup;
    }

    //
    //  Generate key
    //

    if(!XOCryptGenRandom(pKey, ulNumRandomBytes))
    {
        printf("Failed to generate new random key.  Error = 0x%08X.\r\n", HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //
    //  Write key to file
    //

    if(WriteBlobToFile(szFilePath, pKey, ulNumRandomBytes, TRUE))
        printf("Public key written to %s.\r\n", szFilePath);

Cleanup:

    if(pKey != NULL)
        free(pKey);

    return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\createmk.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

void CreateMasterKey(
    ULONG   ulMasterKeyVer,
    LPCSTR  szPublicFilePath,
    LPCSTR  szPrivateFilePath
    )
{
    WCHAR       szContainerName[256];
    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    HCRYPTKEY   hSymKey = NULL;
    HANDLE      hPublicFile = NULL;
    HANDLE      hPrivateFile = NULL;
    LPBYTE      pPublicKey = NULL;
    LPBYTE      pPrivateKey = NULL;
    DWORD       cbPublicKey;
    DWORD       cbPrivateKey;

    //
    //  Format container names
    //

    _snwprintf( 
        szContainerName, 
        sizeof(szContainerName)/sizeof(WCHAR), 
        MASTER_KEY_CONTAINER_NAME, 
        ulMasterKeyVer );

    //
    //  Make sure that the public and private containers for this key version do not already
    //  exist on this machine.
    //

    if(CryptAcquireContextW(
            &hProv,
            szContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            CRYPT_ACQUIRE_CONTEXT_FLAGS))
    {
        CryptReleaseContext(hProv, 0);
        hProv = NULL;
        PrintError("The master key with version %u already exists in the machine keyset on this machine.\r\n\r\n", ulMasterKeyVer);
        goto Cleanup;
    }
    
    //
    //  Create key container we'll use to generate the keys.  We'll delete the
    //  keys from this container when we're done encrypting and writing them to disk.
    //

    if(!CryptAcquireContextW(
            &hProv,
            szContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_NEWKEYSET))
    {
        PrintError("Failed to create the crypto context for the new key pair.  Error = 0x%08X.\r\n\r\n", 
            HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //  generate the key.  The 19 below is: 16 (to put it in the high word) + 3 (to convert
    //  bytes to bits)
    if(!CryptGenKey(
        hProv, 
        AT_KEYEXCHANGE,
        (MASTER_KEY_SIZE << 19) | CRYPT_EXPORTABLE,
        &hKey))
    {
        PrintError("Failed to generate new key pair.  Error = 0x%08X.\r\n\r\n",
            HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //
    //  Get the symmetric key for encrypting the private key blob.
    //

    if(!GetSymmetricKey(hProv, hSymKey))
        goto Cleanup;

    // get the size of the public key blob
    if(!CryptExportKey(
        hKey,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &cbPublicKey))
    {
        PrintError("Error during sizing call to CryptExportKey!  Error = 0x%08X.\r\n\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    // get the size of the public/private key blob
    if(!CryptExportKey(
        hKey,
        hSymKey,
        PRIVATEKEYBLOB,
        0,
        NULL,
        &cbPrivateKey))
    {
        PrintError("Error during sizing call to CryptExportKey!  Error = 0x%08X.\r\n\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    //
    //  Now we know how much buffer we need for the key blobs, allocate the memory.
    //

    pPublicKey = (LPBYTE)malloc(cbPublicKey + sizeof(ULONG));
    pPrivateKey = (LPBYTE)malloc(cbPrivateKey + sizeof(ULONG));

    if(pPublicKey == NULL || pPrivateKey == NULL)
    {
        PrintError("Out of memory allocating key blob.\r\n\r\n");
        goto Cleanup;
    }

    *(PULONG)pPublicKey = ulMasterKeyVer;
    *(PULONG)pPrivateKey = ulMasterKeyVer;

    if(!CryptExportKey(
        hKey,
        NULL,
        PUBLICKEYBLOB,
        0,
        pPublicKey + sizeof(ULONG),
        &cbPublicKey))
    {
        PrintError("Error during CryptExportKey!  Error = 0x%08X.\r\n\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    if(!CryptExportKey(
        hKey,
        hSymKey,
        PRIVATEKEYBLOB,
        0,
        pPrivateKey + sizeof(ULONG),
        &cbPrivateKey))
    {
        PrintError("Error during CryptExportKey!  Error = 0x%08X.\r\n\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    if(WriteBlobToFile(szPublicFilePath, pPublicKey, cbPublicKey + sizeof(ULONG), FALSE))
        printf("Public key written to %s.\r\n", szPublicFilePath);

    if(WriteBlobToFile(szPrivateFilePath, pPrivateKey, cbPrivateKey + sizeof(ULONG), FALSE))
        printf("Private key written to %s.\r\n", szPrivateFilePath);

Cleanup:

    //
    //  We're done, cleanup objects, close the context and delete the keyset.
    //

    if(pPublicKey != NULL)
    {
        memset(pPublicKey, 0, cbPublicKey);
        free(pPublicKey);
    }

    if(pPrivateKey != NULL)
    {
        memset(pPrivateKey, 0, cbPrivateKey);
        free(pPrivateKey);
    }

    if(hKey != NULL)
        CryptDestroyKey(hKey);

    if(hSymKey != NULL)
        CryptDestroyKey(hSymKey);

    if(hProv != NULL)
    {
        CryptReleaseContext(hProv, 0);
        CryptAcquireContextW(
            &hProv, 
            szContainerName, 
            MS_ENHANCED_PROV_W, 
            PROV_RSA_FULL, 
            CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_DELETEKEYSET);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\encryptblob.cpp ===
#include "precomp.h"

BOOL EncryptBlob (
    char const * const szPublicKeyFile,
    char const * const szFileToEncrypt,
    char const * const szOutFile)
{
    printf("Encrypting blob in file '%s' with public key '%s' into output file '%s'...\r\n", szFileToEncrypt, szPublicKeyFile, szOutFile);

    BOOL fRet = FALSE;
    LPBYTE pPublicKey = NULL;
    DWORD cbPublicKey = 0;
    ULONG ulMasterKeyVersion = 0;
    LPBYTE pBlob = NULL;
    DWORD cbBlob = 0;
    HRESULT hr = S_OK;
    XOCryptoMasterKeyEncryptedStruct mkeyBlob = {0};

    BOOL fValidated = FALSE;

    // Get the master public key.
    if (!ReadBlobFromFile(szPublicKeyFile, pPublicKey, cbPublicKey))
    {
        goto Cleanup;
    }
    ulMasterKeyVersion = *(PULONG)pPublicKey;
    printf("Loading public key version %u.\r\n", ulMasterKeyVersion);

    hr = ValidatePublicKey(pPublicKey, cbPublicKey, &fValidated);
    if( SUCCEEDED(hr) && !fValidated)
    {
        PrintError("WARNING: public key does not match stored private key.\r\n");
    }

    // Get the blob we intend to encrypt.
    if (!ReadBlobFromFile(szFileToEncrypt, pBlob, cbBlob))
    {
        goto Cleanup;
    }
    if (cbBlob > sizeof(mkeyBlob.abKey))
    {
        PrintError("The blob read from the file is too big.  Maximum key size is %u bytes, %u bytes were read from %s.\r\n",
            sizeof(mkeyBlob.abKey),
            cbBlob,
            szFileToEncrypt);
        goto Cleanup;
    }
    mkeyBlob.dwKeyLen = cbBlob;
    memcpy(mkeyBlob.abKey, pBlob, mkeyBlob.dwKeyLen);
    printf("Read blob to encrypt, size %u.\r\n", mkeyBlob.dwKeyLen);

    // Encrypt the blob with the master key.
    // Note: the error check below is temporarilly done as such due to a bug
    // in the called function (returns win32 error)
    hr = EncryptWithMasterKey(ulMasterKeyVersion,
                              pPublicKey + sizeof(ULONG),
                              cbPublicKey - sizeof(ULONG),
                              &mkeyBlob);
    if (hr != S_OK)
    {
        PrintError("Failed to encrypt the blob.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }
    printf("Encrypted blob, encrypted size is %u.\r\n", mkeyBlob.dwKeyLen);

    // Write the encrypted blob to the specified file.
    if (!WriteBlobToFile(szOutFile, mkeyBlob.abKey, mkeyBlob.dwKeyLen, FALSE /*bFailIfExists*/))
    {
        goto Cleanup;
    }
    printf("Wrote encrypted blob to file %s.\r\n", szOutFile);

    fRet = TRUE;

Cleanup:

    if (NULL != pPublicKey)
    {
        free(pPublicKey);
    }

    if (NULL != pBlob)
    {
        free(pBlob);
    }

    return fRet;
}


BOOL DecryptBlob (
    ULONG const ulKeyVer,
    char const * const szFileToDecrypt,
    char const * const szOutFile)
{
    BOOL fRet = FALSE;
    HRESULT hr = S_OK;
    LPBYTE pBlob = NULL;
    DWORD cbBlob = 0;
    XOCryptoMasterKeyEncryptedStruct mkeyBlob = {0};

    printf("Decrypting file '%s' with master key version %u into file '%s'...\r\n", szFileToDecrypt, ulKeyVer, szOutFile);

    // Get the blob to decrypt.
    if (!ReadBlobFromFile(szFileToDecrypt, pBlob, cbBlob))
    {
        goto Cleanup;
    }
    if (cbBlob > sizeof(mkeyBlob.abKey))
    {
        PrintError("The blob read from the file is too big.  Maximum key size is %u bytes, %u bytes were read from %s.\r\n",
            sizeof(mkeyBlob.abKey),
            cbBlob,
            szFileToDecrypt);
        goto Cleanup;
    }
    mkeyBlob.dwKeyLen = cbBlob;
    memcpy(mkeyBlob.abKey, pBlob, mkeyBlob.dwKeyLen);
    printf("Read blob to decrypt, size %u.\r\n", mkeyBlob.dwKeyLen);

    hr = DecryptWithMasterKey(ulKeyVer, &mkeyBlob);
    if (FAILED(hr))
    {
        PrintError("Failed to decrypt the blob.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }
    printf("Decrypted blob. Decrypted size %u.\r\n", mkeyBlob.dwKeyLen);

    // Write the encrypted blob to the specified file.
    if (!WriteBlobToFile(szOutFile, mkeyBlob.abKey, mkeyBlob.dwKeyLen, FALSE /*bFailIfExists*/))
    {
        goto Cleanup;
    }
    printf("Wrote decrypted blob to file %s.\r\n", szOutFile);

    fRet = TRUE;

Cleanup:
    if (NULL != pBlob)
    {
        free(pBlob);
    }

    return fRet;
}

BOOL MigrateBlob(
    ULONG const ulOldKeyVer,
    char const * const szPublicKeyFile,
    char const * const szFileToDecrypt,
    char const * const szOutFile)
{
    BOOL fRet = FALSE;
    HRESULT hr = S_OK;

    LPBYTE pPublicKey = NULL;
    DWORD cbPublicKey = 0;
    ULONG ulMasterKeyVersion = 0;

    LPBYTE pBlob = NULL;
    DWORD cbBlob = 0;

    XOCryptoMasterKeyEncryptedStruct mkeyBlob = {0};

    printf("Migrating file '%s' with old master key version %u with new public key '%s' into file '%s'...\r\n",
           szFileToDecrypt,
           ulOldKeyVer,
           szPublicKeyFile,
           szOutFile);

    // Get the new master public key.
    if (!ReadBlobFromFile(szPublicKeyFile, pPublicKey, cbPublicKey))
    {
        goto Cleanup;
    }
    ulMasterKeyVersion = *(PULONG)pPublicKey;
    printf("Loading public key version %u.\r\n", ulMasterKeyVersion);

    // Get the blob to decrypt.
    if (!ReadBlobFromFile(szFileToDecrypt, pBlob, cbBlob))
    {
        goto Cleanup;
    }
    if (cbBlob > sizeof(mkeyBlob.abKey))
    {
        PrintError("The blob read from the file is too big.  Maximum key size is %u bytes, %u bytes were read from %s.\r\n",
            sizeof(mkeyBlob.abKey),
            cbBlob,
            szFileToDecrypt);
        goto Cleanup;
    }
    mkeyBlob.dwKeyLen = cbBlob;
    memcpy(mkeyBlob.abKey, pBlob, mkeyBlob.dwKeyLen);
    printf("Read blob to decrypt, size %u.\r\n", mkeyBlob.dwKeyLen);

    hr = DecryptWithMasterKey(ulOldKeyVer, &mkeyBlob);
    if (FAILED(hr))
    {
        PrintError("Failed to decrypt the blob.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }
    printf("Decrypted blob. Decrypted size %u.\r\n", mkeyBlob.dwKeyLen);

    // Encrypt the blob with the new master key.
    // Note: the error check below is temporarilly done as such due to a bug
    // in the called function (returns win32 error)
    hr = EncryptWithMasterKey(ulMasterKeyVersion,
                              pPublicKey + sizeof(ULONG),
                              cbPublicKey - sizeof(ULONG),
                              &mkeyBlob);
    if (hr != S_OK)
    {
        PrintError("Failed to encrypt the blob.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }
    printf("Encrypted blob, encrypted size is %u.\r\n", mkeyBlob.dwKeyLen);

    // Write the encrypted blob to the specified file.
    if (!WriteBlobToFile(szOutFile, mkeyBlob.abKey, mkeyBlob.dwKeyLen, FALSE /*bFailIfExists*/))
    {
        goto Cleanup;
    }
    printf("Wrote encrypted blob to file %s.\r\n", szOutFile);

    fRet = TRUE;

Cleanup:
    if (NULL != pPublicKey)
    {
        free(pPublicKey);
    }

    if (NULL != pBlob)
    {
        free(pBlob);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\addwmdrmcert.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

// --------------------------------------------------------------------------------------
// AddWmdrmCert
// 
// Stores a WMDRM certificate in NPDB..t_settings and the corresponding private key in 
// UODB..t_service_keys. The certificate is stored in t_config_blobs with the name 
// 'xbos_wmdrm_groupcert' after being base64 encoded. The private key is encrypted with 
// the master key before being stored in t_service_keys with key-type = 
// KEY_TYPE_WMDRM_GROUP_PRIVATE_KEY(8).
//
//  * szPrivKeyFile: name of the file containing the Wmdrm group cert private key
//  * szCertFile: name of the file containing the Wmdrm group cert.
// 
// --------------------------------------------------------------------------------------
void AddWmdrmCert(
    LPCSTR szMasterKeyPubFile,
    LPCSTR szPrivKeyFile,
    LPCSTR szCertFile
)
{
    BYTE*  pCertBytes     = NULL;
    DWORD  cbCertBytes    = 0;
    HRESULT hr;
    BOOL ok;
    
    // Add / update private key in Uodb

    printf("Writing private key from file %s to Uodb.t_service_keys with key-type 8\n",
           szPrivKeyFile);
    
    ok = AddFrequentlyUsedKey(
        KEY_TYPE_WMDRM_GROUP_PRIVATE_KEY,
        1,                                  // ulKeyVersion
        szMasterKeyPubFile,                 // szPublicKeyFile
        szPrivKeyFile,
        0xFFFFFFFF,                         // ulKeyLen
        "Wmdrm Group Private Key",          // szKeyData1
        NULL,                               // szKeyData2
        0xFFFFFFFF,                         // ulSiteID
        0xFFFFFFFF,                         // ulLifeTime
        NULL,                               // szSGConfigFile
        TRUE                                // fUpdateIfExists
        );

    if(!ok)
    {
        PrintError("Failed to write private key to Uodb. Aborting.\n");
        goto Exit;
    }

    // Read certificate file
    
    PrintError("Reading Wmdrm certificate file: %s\n", szCertFile);
    if(!ReadBlobFromFile(szCertFile, /*OUT*/pCertBytes, /*OUT*/cbCertBytes))
    {
        goto Exit;
    }
    printf("Size of certificate: %u\n", cbCertBytes);
    

    // Store certificate in npdb
    
    printf("Writting certificate to Npdb.t_config_blobs with name "
           "'xbos_wmdrm_groupcert'\n");

    {
        CODBWSession npdb;
        static CWSProcCache pc;
        
        const WCHAR *pConnStr = GetNpdbConnectionString();
        if (pConnStr == NULL)
        {
            goto Exit;
        }

        if(FAILED(hr = npdb.InitializeEx(pConnStr)))
        {
            PrintError("Failed to connect to NPDB. InitializeEx failed. hr=0x%08x\n", hr);
            goto Exit;
        }

        if(FAILED(hr = npdb.CallProc(
                    &pc, L"dbo.p_config_blob_set %64S, %vlB", 
                    "xbos_wmdrm_groupcert",
                    pCertBytes,
                    cbCertBytes)))
        {
            PrintError("Failed to execute dbo.p_config_blob_set. hr=0x%08x\n", hr);
            PrintExtendedDatabaseError();
            goto Exit;
        }
    }

    printf("Done!\n");

Exit:

    if(pCertBytes)
    {
        free(pCertBytes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\common.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"
#include <commonconfig.h>
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers

void Usage(void)
{
    printf("XBox service master key manager.\r\n");
    printf("XKEYMGR CREATEMK mkver pubkeyfile privkeyfile\r\n");
    printf("XKEYMGR STOREMK privkeyfile\r\n");
    printf("XKEYMGR REMOVEMK mkver\r\n");
    printf("XKEYMGR CREATERAND keyfile keysize\r\n");
    printf("XKEYMGR ADDFREQ ktype kver pubkeyfile [ -f kfile | -r len ] [-d1 kdata1] [-d2 kdata2] [-s siteid] [-l lifetime] [-c sgconfigfile]\r\n");
    printf("XKEYMGR REMOVEFREQ ktype kver kdata1 kdata2 mkver\r\n");
    printf("XKEYMGR PROTECT inputfile outputfile\r\n");
    printf("XKEYMGR MIGRATEMK oldmkver newpubkeyfile\r\n");
    printf("XKEYMGR MIGRATEKEK oldkekver newkekver mkver [xname]\r\n");
    printf("XKEYMGR ADDWMDRMCERT pubkeyfile wdprvkeyfile wdcertfile\r\n");
    printf("XKEYMGR ADDPLAYREADYCERT pubkeyfile prvkeyfile certfile\r\n");
    printf("XKEYMGR ENCRYPTBLOB pubkeyfile filetoencrypt outfile\r\n");
    printf("XKEYMGR DECRYPTBLOB mkver encryptedfile outfile\r\n");
    printf("XKEYMGR MIGRATEBLOB oldmkver pubkeyfile encryptedfile outfile\r\n");
    printf("XKEYMGR VALIDATE pubkeyfile\r\n");
    printf("XKEYMGR REMOVECONTAINER keycontainer\r\n");
    printf("XKEYMGR DUMPMK mkver \r\n");
    printf("XKEYMGR DUMPCONTAINER keycontainer\r\n");


    printf("\r\n");

    printf("  mkver             Version number of master key\r\n");
    printf("  kekver            Version number of key encryption key\r\n");
    printf("  pubkeyfile        Name of public key file\r\n");
    printf("  newpubkeyfile     Name of public key file\r\n");
    printf("  privkeyfile       Name of private key file\r\n");
    printf("  keycontainer      Name of the crypto container holding the key\r\n");
    printf("  keyfile           Name of file to contain generated key\r\n");
    printf("  keysize           Size of the generated key in bytes\r\n");
    printf("  ktype             Type of frequently used key being added or removed\r\n");
    printf("  kver              Version of the frequently used key being added or removed\r\n");
    printf("  kdata1            Additional key data\r\n");
    printf("  kdata2            Additional key data\r\n");
    printf("  siteid            Optional Site ID\r\n");
    printf("  lifetime          Optional ticket lifetime\r\n");
    printf("  sgconfigfile      Optional SG configuration file to generate\r\n");
    printf("  kfile             Path to a file containing the unencrypted frequently used key\r\n");
    printf("  len               Desired length for randomly generated key\r\n");
    printf("  inputfile         Input SG configuration file to protect\r\n");
    printf("  outputfile        Filename to store protected configuration file\r\n");
    printf("  oldmkver          Version of the master being migrated from\r\n");
    printf("  oldkekver         Version of the key encryption key being migrated from\r\n");
    printf("  newkekver         Version of the key encryption key being migrated to\r\n");
    printf("  xname             Name of a specific user account whose key will be migrated\r\n");
    printf("                    If this name is not specified, then all users' keys will be migrated\r\n");
    printf("  wdprvkeyfile      Name of Wmdrm group private key file\n");
    printf("  wdcertfile        Name of Wmdrm group certificate file\n");
    printf("  prvkeyfile        Name of PlayReady group private key file\n");
    printf("  certfile          Name of PlayReady group certificate file\n");
    printf("  filetoencrypt     Name of file with blob to encrypt\r\n");
    printf("  encryptedfile     Name of file with the encrypted blob\r\n");
    printf("  outfile           Name of file to put encrypted or decrypted blob into\r\n");
}

BOOL WriteBlobToFile(
    LPCSTR  szFileName,
    LPBYTE  pBlob,
    DWORD   cbBlobLen,
    BOOL    bFailIfExists
    )
{
    BOOL    bReturn;
    HANDLE  hFile = NULL;
    DWORD   cbWritten=0;

    //
    //  Create the file
    //

    hFile = CreateFileA(
            szFileName,
            GENERIC_WRITE,
            0,
            NULL,
            bFailIfExists ? CREATE_NEW : CREATE_ALWAYS,
            0,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        switch(GetLastError())
        {
        case ERROR_FILE_EXISTS:
            fprintf(stderr, "Specified file already exists, specify a different file name.\r\n");
            break;

        default:
            fprintf(stderr, "Error during CreateFile!  Error = 0x%08X.\r\n",
                HRESULT_FROM_WIN32(GetLastError()));
            break;
        }

        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Write blob to file
    //

    if (!WriteFile(
            hFile,
            pBlob,
            cbBlobLen,
            &cbWritten,
            NULL))
    {
        fprintf(stderr, "Error during WriteFile!  Error = 0x%08X.\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        bReturn = FALSE;
        goto Cleanup;
    }
    if (cbWritten != cbBlobLen)
    {
        fprintf(stderr, "WriteFile incomplete!\r\n");
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if(hFile != NULL)
        CloseHandle(hFile);

    return bReturn;
}

BOOL ReadBlobFromFile(
    LPCSTR  szFileName,
    LPBYTE& pBlob,
    DWORD&  cbBlobLen
    )
{
    BOOL    bReturn;
    HANDLE  hFile = NULL;
    DWORD   cbRead=0;
    DWORD   cbFileSizeHigh;

    pBlob = NULL;
    cbBlobLen = 0;

    //
    //  Create the file
    //

    hFile = CreateFileA(
            szFileName,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwError = GetLastError();
        switch(dwError)
        {
        case ERROR_FILE_NOT_FOUND:
            fprintf(stderr, "The system cannot find the file specified.");
            break;
        default:
            fprintf(stderr, "Error during CreateFile!  Error = 0x%08X.\r\n", HRESULT_FROM_WIN32(dwError));
            break;
        }

        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Get the file size in cbBlobLen
    //

    cbBlobLen = GetFileSize(hFile, &cbFileSizeHigh);
    if(cbFileSizeHigh != 0)
    {
        fprintf(stderr,
            "Specified file (%s) is too big.\r\n",
            szFileName);
        cbBlobLen = 0;
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Allocate the buffer
    //

    pBlob = (LPBYTE)malloc(cbBlobLen);
    if(pBlob == NULL)
    {
        fprintf(stderr, "Out of memory allocating buffer for file.\r\n");
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Read blob from file
    //

    if (!ReadFile(
            hFile,
            pBlob,
            cbBlobLen,
            &cbRead,
            NULL))
    {
        fprintf(stderr, "Error during ReadFile!  Error = 0x%08X.\r\n",
            HRESULT_FROM_WIN32(GetLastError()));
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if(pBlob != NULL && !bReturn)
    {
        free(pBlob);
        pBlob = NULL;
    }

    if(hFile != NULL)
        CloseHandle(hFile);

    return bReturn;
}

BOOL GetSymmetricKey(
    HCRYPTPROV  hProv,
    HCRYPTKEY&  hSymKey
    )
{
    BOOL        bReturn;
    HCRYPTHASH  hHash = NULL;

    hSymKey = NULL;

    // create the hash object
    if(!CryptCreateHash(
        hProv,
        CALG_SHA1,
        0,
        0,
        &hHash))
    {
        fprintf(stderr, "Error during CryptCreateHash!  Error = 0x%08X.\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        bReturn = FALSE;
        goto Cleanup;
    }

    // Hash the password
    if(!CryptHashData(
        hHash,
        (BYTE *)MASTER_KEYSET_PASSWORD,
        strlen(MASTER_KEYSET_PASSWORD),
        0))
    {
        fprintf(stderr, "Error during CryptHashData!  Error = 0x%08X.\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        bReturn = FALSE;
        goto Cleanup;
    }

    // Create a session key based on the hash of the password.
    if(!CryptDeriveKey(
        hProv,
        CALG_3DES,
        hHash,
        0,
        &hSymKey))
    {
        fprintf(stderr, "Error during CryptDeriveKey!  Error = 0x%08X.\r\n",
               HRESULT_FROM_WIN32(GetLastError()));
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if(hHash != NULL)
        CryptDestroyHash(hHash);

    return bReturn;
}

static HRESULT GetSiteName(BSTR * const pbstrSite, CComBSTR& bstrVirtualInterface)
{
    using namespace XblConfig;

    HRESULT hr = S_OK;
    CComPtr<IVirtualInterfaceInfo> spiVirtualInterfaceInfo;
    CComPtr<IConfig> spiConfig;
    CComBSTR bstrAppDomain;
    long lSiteId = 0;

    if (pbstrSite == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pbstrSite = NULL;

    hr = spiConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr)) goto Cleanup;

    hr = spiConfig->get_SiteId(&lSiteId);
    if (FAILED(hr)) goto Cleanup;

    hr = spiConfig->GetVirtualInterface(bstrVirtualInterface, lSiteId,  &spiVirtualInterfaceInfo);
    if (FAILED(hr)) goto Cleanup;

    hr = spiVirtualInterfaceInfo->get_WebstoreApp(&bstrAppDomain);

    *pbstrSite = bstrAppDomain.Detach();

Cleanup:
    return hr;
}

HRESULT GetWebstore(IWSTStore** ppiWebstore, CComBSTR& bstrVirtualInterface)
{	
    HRESULT hr;
    CComBSTR bstrSite;

    if(ppiWebstore == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppiWebstore = NULL;

    //
    //  Create instance of webstore client.
    //

    hr = CoCreateInstance(CLSID_WSTStore, NULL, CLSCTX_SERVER, IID_IWSTStore, (void**)ppiWebstore);
    if(FAILED(hr))
    {
        fprintf(stderr, "Could not create instance of webstore client for %S.  Error = 0x%08X.\r\n", bstrVirtualInterface, hr);
        goto Cleanup;
    }

    //
    // Get the site name.
    //

    hr = GetSiteName(&bstrSite, bstrVirtualInterface);
    if (FAILED(hr))
    {
        fprintf(stderr, "Failed to get the site name for %S.  Error = 0x%08X.\r\n", bstrVirtualInterface, hr);
        goto Cleanup;
    }

    //
    //  Initialize the client.
    //

    hr = (*ppiWebstore)->Initialize(bstrSite);
    if(FAILED(hr))
    {
        fprintf(stderr, "Failed to initialize %S webstore application.  Error = 0x%08X.\r\n", bstrVirtualInterface, hr);
        goto Cleanup;
    }

Cleanup:

    if(FAILED(hr) && *ppiWebstore != NULL)
    {
        (*ppiWebstore)->Release();
        *ppiWebstore = NULL;
    }

    return hr;
}

HRESULT GetUODBWebstore(IWSTStore** ppiWebstore)
{
	return GetWebstore(ppiWebstore, VirtualInterface_uodb);
}

HRESULT GetNPDBWebstore(IWSTStore** ppiWebstore)
{
	return GetWebstore(ppiWebstore, VirtualInterface_npdb);
}

BOOL GetNumArg(
    LPCSTR  szArg,
    ULONG&  ulArg
    )
{
    LPSTR szEnd;

    ulArg = strtoul(szArg, &szEnd, 10);

    return !((szArg == szEnd) || isspace(*szEnd));
}


static const char ConfigRegistryKey[] = "Software\\Microsoft\\XboxLive\\CommonConfig";

// --------------------------------------------------------------------------------------
// GetNpdbConnectionString
// Returns:
//  Pointer to Npdb connection string (WCHAR)
//  --------------------------------------------------------------------------------------
LPCWSTR GetNpdbConnectionString()
{
    using namespace XblConfig;

    HRESULT             hr;
    CComPtr<IConfig>    pConfig;
    CComBSTR            bstrConnectionString;
    static CSmallWStr   strConnect;

    strConnect.SetAllocator(CMemAlloc::Default()); // grows when necessary, cleans up automatically

    if(!strConnect.IsEmpty())
    {
        // We have already done this. Use cached value.

        return (LPCWSTR)strConnect.cstr();
    }

    hr = pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr)) {
        fprintf(stderr, "Failed to CoCreateInstance of CommonConfig - is commonconfig.dll present?\n");
        goto Cleanup;
    }

    hr = pConfig->get_NpdbConnectionString(&bstrConnectionString);
    if (FAILED(hr)) {
        fprintf(stderr, "get_NpdbConnectionString failed\n");
        goto Cleanup;
    }

    strConnect.CopyFrom(bstrConnectionString);
    if (strConnect.HasFailedOrTruncated()) {
        fprintf(stderr, "Copying connection string truncated. This is very unusual. GetLength=%u, GetCapacity=%u\n", 
                strConnect.GetLength(), strConnect.GetCapacity());
        DBGASSERT(!"HasFailedOrTruncated");
        goto Cleanup;
    }

    printf("Using NPDB connection string: %S\n", strConnect.cstr());
    return (LPCWSTR)strConnect.cstr();

Cleanup:

    fprintf(stderr, "Failed to get NPDB connection string from CommonConfig. hr=0x%X\n", hr);
    return NULL;
}

// --------------------------------------------------------------------------------------
// PrintExtendedDatabaseError
// Best attempt to get extended error information from a failed database operation
// --------------------------------------------------------------------------------------
void PrintExtendedDatabaseError()
{
    HRESULT hr;
    CComPtr<IErrorInfo> pErrorInfo;
    CComPtr<IErrorRecords> pErrorRecords;
    CComBSTR description;
    CComBSTR source;

#define CHECK(x) \
    if(FAILED(x)) return;

    // Process GetErrorInfo

    CHECK(GetErrorInfo(0, &pErrorInfo));

    if(!pErrorInfo)
        return;

    CHECK(pErrorInfo->GetDescription(&description));
    CHECK(pErrorInfo->GetSource(&source));

    fprintf(stderr,
        "*** GetErrorInfo reported:\n"
        "Source: %S\n"
        "Description: %S\n",
        (BSTR)source,
        (BSTR)description);

    // Maybe we got some error records?

    CHECK(pErrorInfo.QueryInterface(&pErrorRecords));

    ULONG cRecords = 0;
    CHECK(pErrorRecords->GetRecordCount(&cRecords));

    LCID lcid = GetUserDefaultLCID();
    for(ULONG i=0; i < cRecords; i++)
    {
        pErrorInfo.Release();
        description.Empty();
        source.Empty();

        CHECK(pErrorRecords->GetErrorInfo(i, lcid, &pErrorInfo));
        CHECK(pErrorInfo->GetDescription(&description));
        CHECK(pErrorInfo->GetSource(&source));

        fprintf(stderr,
            "*** Error record #%u :\n"
            "Source: %S\n"
            "Description: %S\n",
            i,
            (BSTR)source,
            (BSTR)description);
    }
}

// --------------------------------------------------------------------------------------
// ValidatePublicKey
// Best attempt to validate the public key used matches the stored private key
// --------------------------------------------------------------------------------------
HRESULT ValidatePublicKey(
        IN LPBYTE pPublicKey,
        IN DWORD  cbPublicKey,
        OUT BOOL* pfResult)
{
    HRESULT hr = S_OK;

    XOCryptoMasterKeyEncryptedStruct mkeyBlob = {0};

    CHAR szKnownData[] = "This is a known, reasonable sized blob of data.";

    // Use known data.
    mkeyBlob.dwKeyLen = sizeof(szKnownData);
    memcpy(mkeyBlob.abKey, LPBYTE(szKnownData), mkeyBlob.dwKeyLen);

    // Encrypt the known blob with the master key.
    hr = EncryptWithMasterKey(*(PULONG)pPublicKey,
                              pPublicKey + sizeof(ULONG),
                              cbPublicKey - sizeof(ULONG),
                              &mkeyBlob);
    if( FAILED(hr) )
    {
        goto Cleanup;
    }

    // Decrypt the known blob with the master key.
    hr = DecryptWithMasterKey(*(PULONG)pPublicKey, &mkeyBlob);
    if( FAILED(hr) )
    {
        if( NTE_BAD_DATA == hr )
        {
            // this is likely because of key mismatches as well
            *pfResult = FALSE;
            hr = S_OK;
        }
        goto Cleanup;
    }

    // Check the result
    *pfResult = FALSE;
    if( sizeof(szKnownData) == mkeyBlob.dwKeyLen )
    {
        if( 0 == memcmp(mkeyBlob.abKey, LPBYTE(szKnownData), mkeyBlob.dwKeyLen) )
        {
            *pfResult = TRUE;
        }
    }

Cleanup:

    return hr;
}


// --------------------------------------------------------------------------------------
// ValidatePublicKeyFromFile
// Best attempt to validate the public key used matches the stored private key
// --------------------------------------------------------------------------------------
HRESULT ValidatePublicKeyFromFile(LPCSTR szPublicKeyFile)
{
    BOOL fValidated = FALSE;
    HRESULT hr = S_OK;

    LPBYTE pPublicKey = NULL;
    DWORD cbPublicKey = 0;

    ULONG ulMasterKeyVersion = 0;

    printf("Validating public key from '%s'\r\n", szPublicKeyFile);

    // Get the master public key.
    if( !ReadBlobFromFile(szPublicKeyFile, pPublicKey, cbPublicKey) )
    {
        goto Cleanup;
    }

    ulMasterKeyVersion = *(PULONG)pPublicKey;
    printf("Using private key version %u.\r\n", ulMasterKeyVersion);

    hr = ValidatePublicKey(pPublicKey, cbPublicKey, &fValidated);
    if( SUCCEEDED(hr) )
    {
        if( fValidated )
        {
            printf("SUCCESS: public key matches stored private key.\r\n");
        }
        else
        {
            printf("ERROR: public key does not match stored private key.\r\n");
        }
    }
    else
    {
        fprintf(stderr, "ERROR: Could not validate public key. Error = 0x%08X.\r\n", hr);
    }

Cleanup:

    if( pPublicKey )
    {
        free(pPublicKey);
    }

    return hr;
}

// --------------------------------------------------------------------------------------
// DumpMasterKeyContainer
// Best attempt to validate the public key used matches the stored private key
// --------------------------------------------------------------------------------------
void DumpMasterKeyContainer(
    ULONG   ulMasterKeyVer)
{
    WCHAR       szContainerName[256];

    //
    //  Format container names
    //
    _snwprintf( 
        szContainerName, 
        sizeof(szContainerName)/sizeof(WCHAR), 
        MASTER_KEY_CONTAINER_NAME, 
        ulMasterKeyVer );

    DumpKeyContainer( szContainerName );
}


void DumpKeyContainer(
    LPCWSTR szContainerName)
{
    HCRYPTPROV  hProv = NULL;
    LPSTR       pszContainerName = NULL;
    LPWSTR      pwszAllUsersPath = NULL;
    DWORD       cbSize = 0;
    HRESULT     hr = S_OK;

    //
    //  Make sure that the public and private containers for this key version do not already
    //  exist on this machine.
    //
    if (!CryptAcquireContextW(
            &hProv,
            szContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            CRYPT_ACQUIRE_CONTEXT_FLAGS))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (E_HANDLE == hr)
        {
            fprintf(stderr,
                    "Error acquiring crypto context. Error = 0x%08X.\n"
                    "Suspecting wrong ACL on the master key - try running same command while running as SYSTEM\n",
                    hr);
        }
        else if (NTE_BAD_KEYSET == hr)
        {
            fprintf(stderr,
                    "Error acquiring crypto context. Error = 0x%08X.\n"
                    "Suspecting missing master key or using the wrong version for query.\n",
                    hr);
        }
        else
        {
            fprintf(stderr,
                    "Error acquiring crypto context. Error = 0x%08X.\n",
                    hr);
        }
        goto Cleanup;
    }

    //
    // Get name of default key container.
    //
    if (!CryptGetProvParam(
            hProv,
            PP_UNIQUE_CONTAINER,
            NULL,
            &cbSize,
            0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        fprintf(stderr,
                "Error querying for container size.  Error = 0x%08X.\n",
                hr);
        goto Cleanup;
    }

    pszContainerName = (LPSTR) malloc(cbSize);
    if (NULL == pszContainerName)
    {
        fprintf(stderr,
                "Error allocating memory for the container name.\n");
        goto Cleanup;
    }

    if (!CryptGetProvParam(
            hProv,
            PP_UNIQUE_CONTAINER,
            (BYTE *) pszContainerName,
            &cbSize,
            0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        fprintf(stderr,
                "Error querying for container name.  Error = 0x%08X.\n",
                hr);
        goto Cleanup;
    }


    GetAllUsersProfileDirectory(NULL, &cbSize);
    pwszAllUsersPath = (LPWSTR)malloc(cbSize * sizeof(WCHAR));

    if (NULL == pwszAllUsersPath)
    {
        fprintf(stderr,
                "Error allocating memory for all user path.\n");
        goto Cleanup;
    }

    if (!GetAllUsersProfileDirectory(pwszAllUsersPath, &cbSize))
    {
        fprintf(stderr,
                "Error allocating memory for all user path.\n");
        goto Cleanup;
    }

    //
    // Assumptions when building the path:
    //  Machine keyset
    //  RSA container
    //  CAPI not CNG
    //
    printf("%ws%s%s\n",
            pwszAllUsersPath,
            "\\Application Data\\Microsoft\\Crypto\\RSA\\MachineKeys\\",
            pszContainerName);

    printf("\nFor key access problems run:\n"
            "cacls \"%ws%s%s\"\n",
            pwszAllUsersPath,
            "\\Application Data\\Microsoft\\Crypto\\RSA\\MachineKeys\\",
            pszContainerName);

Cleanup:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    if (NULL != pszContainerName)
    {
        free(pszContainerName);
    }

    if (NULL != pwszAllUsersPath)
    {
        free(pwszAllUsersPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\precomp.h ===
//  Precompiled headers.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

#ifndef __PRECOMP_H
#define __PRECOMP_H

#include <windows.h>
#include <wincrypt.h>
#include <userenv.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlconv.h>

#include "wsockntp.h"
#include "xonlinep.h"
#include "cryptohelper.h"
#include "wststore.h"
#include "atldbcli_.h"
#include "cutil.h"
#include "oledbwrapper.h"

#include "xkeymgr.h"
#include "xaccessors.h"

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XStorageSmoke.rc
// Copyright (c) Microsoft Corporation.  All rights reserved

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\migratekek.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

void MigrateKeyEncryptionKey(
    ULONG   ulOldVersion,
    ULONG   ulNewVersion,
    ULONG   ulMasterKeyVersion,
    LPCSTR  szXName
    )
{
    HRESULT                             hr;
	CComPtr<IWSTStore>                  piNpdbWebstore;
    CComPtr<IWSTCommand>                piNpdbCommand;
    CComPtr<IWSTStore>                  piWebstore;
    CComPtr<IWSTCommand>                piCommand;
    CComPtr<IWSTHash>                   piHash;
    XCmdGetKey                          cmdGetOldKey;
    XCmdGetKey                          cmdGetNewKey;
    XOCryptoMasterKeyEncryptedStruct    oldKey;
    XOCryptoMasterKeyEncryptedStruct    newKey;
    ULONG                               ulUsersProcessed;
    ULONG                               ulQueueInfoProcessed;
    BYTE                                rawPaymentInfo[MAX_PAYINFO_BYTES];

    //
    //  Create and initialize the webstore object for NPDB.
    //
    hr = GetNPDBWebstore(&piNpdbWebstore);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Get the command interface
    //

    hr = piNpdbWebstore->QueryInterface(&piNpdbCommand);
    if(FAILED(hr))
    {
        PrintError("Failed to get command interface on webstore client for NPDB.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Get the old and new key encryption keys.
    //

    cmdGetOldKey.m_i_key_type = KEY_TYPE_KEY_ENCRYPTION_KEY;
    cmdGetOldKey.m_i_data1_len = 0;
    cmdGetOldKey.m_i_data2_len = 0;
    memset(cmdGetOldKey.m_nvc_key_data1, 0, sizeof(cmdGetOldKey.m_nvc_key_data1));
    memset(cmdGetOldKey.m_nvc_key_data2, 0, sizeof(cmdGetOldKey.m_nvc_key_data2));
    cmdGetOldKey.m_i_master_key_ver = ulMasterKeyVersion;
    cmdGetOldKey.m_i_key_ver        = ulOldVersion;

    hr = ExecuteWithParameters(piNpdbCommand,
                                cmdGetOldKey,
                                WRITETHENREAD_COMMANDTYPE,
                                ANY_PARTITION);
    if(FAILED(hr))
    {
        PrintError("Failed to retrieve old key encryption key from database.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    cmdGetOldKey.MoveFirst();

    cmdGetNewKey.m_i_key_type = KEY_TYPE_KEY_ENCRYPTION_KEY;
    cmdGetNewKey.m_i_data1_len = 0;
    cmdGetNewKey.m_i_data2_len = 0;
    memset(cmdGetNewKey.m_nvc_key_data1, 0, sizeof(cmdGetNewKey.m_nvc_key_data1));
    memset(cmdGetNewKey.m_nvc_key_data2, 0, sizeof(cmdGetNewKey.m_nvc_key_data2));
    cmdGetNewKey.m_i_master_key_ver = ulMasterKeyVersion;
    cmdGetNewKey.m_i_key_ver        = ulNewVersion;

    hr = ExecuteWithParameters(piNpdbCommand,
                                cmdGetNewKey,
                                WRITETHENREAD_COMMANDTYPE,
                                ANY_PARTITION);
    if(FAILED(hr))
    {
        PrintError("Failed to retrieve new key encryption key from database.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    cmdGetNewKey.MoveFirst();

    //
    //  Decrypt the key encryption keys with the master key.
    //

    memcpy(oldKey.abKey, cmdGetOldKey.m_bin_key, cmdGetOldKey.m_i_key_len);
    memcpy(newKey.abKey, cmdGetNewKey.m_bin_key, cmdGetNewKey.m_i_key_len);

    oldKey.dwKeyLen = cmdGetOldKey.m_i_key_len;
    newKey.dwKeyLen = cmdGetNewKey.m_i_key_len;

    hr = DecryptWithMasterKey(ulMasterKeyVersion, &oldKey);
    if(FAILED(hr))
    {
        if(hr == NTE_BAD_KEYSET)
            PrintError("Master key version %u does not exist on this machine.\r\n", ulMasterKeyVersion);
        else
            PrintError("Failed to decrypt key encryption key.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    hr = DecryptWithMasterKey(ulMasterKeyVersion, &newKey);
    if(FAILED(hr))
    {
        if(hr == NTE_BAD_KEYSET)
            PrintError("Master key version %u does not exist on this machine.\r\n", ulMasterKeyVersion);
        else
            PrintError("Failed to decrypt key encryption key.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

	//
    //  Create and initialize the webstore object for UODB.
    //
	hr = GetUODBWebstore(&piWebstore);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Get the command interface
    //

    hr = piWebstore->QueryInterface(&piCommand);
    if(FAILED(hr))
    {
        PrintError("Failed to get command interface on webstore client.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Get the Hash interface
    //

    hr = piWebstore->QueryInterface(&piHash);
    if(FAILED(hr))
    {
        PrintError("Failed to get hash interface on webstore client.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Now loop through all the user keys, converting them and storing them.
    //  This will probably take a while, make sure to send lots of output to screen
    //  so we know it's still working
    //

    ulUsersProcessed = 0;
    ulQueueInfoProcessed = 0;

    //
    //  Are we migrating a single user, or all of them?
    //

    if(szXName != NULL)
    {
        XCmdGetUserKey              cmdGetUserKey;
        XOCryptoKeyStruct           userKey;
        XCmdUpdateUserKey           cmdUpdateUserKey;
        XCmdGetQueueInfo            cmdGetQueueInfo;
        XCmdUpdateQueueInfo         cmdUpdateQueueInfo;
        XOCryptoKeyEncryptionHelper cryptoHelpOld((XOCryptoKeyEncryptionKey*)(oldKey.abKey));
        XOCryptoKeyEncryptionHelper cryptoHelpNew((XOCryptoKeyEncryptionKey*)(newKey.abKey));
        LONG                        lHash;
        LARGE_INTEGER               liPuid;

        //
        //  Get the desired user key
        //

        MultiByteToWideChar(CP_ACP, 0,
                            szXName, -1, 
                            cmdGetUserKey.m_nvc_nickname, 
                            sizeof(cmdGetUserKey.m_nvc_nickname)/sizeof(WCHAR));
        cmdGetUserKey.m_lOldKeyEncKeyVersion = ulOldVersion;
        cmdGetUserKey.m_lNewKeyEncKeyVersion = ulNewVersion;

        piHash->HashBSTR(cmdGetUserKey.m_nvc_nickname, &lHash);

        hr = ExecuteWithParameters(piCommand,
                                cmdGetUserKey,
                                WRITEONLY_COMMANDTYPE,
                                lHash);
        if(FAILED(hr))
        {
            goto Cleanup;
        }

        hr = cmdGetUserKey.MoveFirst();
        if(hr == DB_S_ENDOFROWSET)
        {
            PrintError("User %s was not found in the database.\r\n", szXName);
            goto Cleanup;
        }

        //
        //  Convert key
        //

        cryptoHelpOld.DecryptKey(
            (XOCryptoIVStruct*)(cmdGetUserKey.m_bin_iv),
            (XOCryptoKeyStruct*)(cmdGetUserKey.m_bin_key),
            &userKey);

        cryptoHelpNew.EncryptKey(
            &userKey,
            (XOCryptoIVStruct*)(cmdUpdateUserKey.m_bin_new_iv),
            (XOCryptoKeyStruct*)(cmdUpdateUserKey.m_bin_new_key));

        memset(&userKey, 0, sizeof(userKey));

        //
        //  Prepare to update the key
        //

        memcpy(cmdUpdateUserKey.m_nvc_nickname, cmdGetUserKey.m_nvc_nickname, sizeof(cmdGetUserKey.m_nvc_nickname));
        cmdUpdateUserKey.m_i_key_version = cmdGetUserKey.m_i_key_version;
        cmdUpdateUserKey.m_i_old_key_enc_key_version = cmdGetUserKey.m_i_key_enc_key_version;
        cmdUpdateUserKey.m_i_new_key_enc_key_version = ulNewVersion;

        //
        //  Update the key
        //

        hr = ExecuteWithParameters(piCommand,
                                cmdUpdateUserKey,
                                WRITEONLY_COMMANDTYPE,
                                lHash);
        if(FAILED(hr))
        {
            PrintError("Failed to update key in database.  Error = 0x%08X.\r\n", hr);
            goto Cleanup;
        }

        if(cmdUpdateUserKey.m_RETURNVALUE != 0)
        {
            PrintError("Failed to update key in database.  Error = 0x%08X.\r\n", cmdUpdateUserKey.m_RETURNVALUE);
            goto Cleanup;
        }

        printf("Migrated user key for \"%s\" from version %u to version %u.\r\n",
               szXName,
               ulOldVersion,
               ulNewVersion);

        //
        //  Get any billing queue key for this user
        //

        cmdGetQueueInfo.m_bi_user_puid = cmdGetUserKey.m_bi_user_puid;

        liPuid.QuadPart = cmdGetUserKey.m_bi_user_puid;
        piHash->HashLARGEINTEGER(liPuid, &lHash);

        hr = ExecuteWithParameters(piCommand,
                                   cmdGetQueueInfo,
                                   WRITEONLY_COMMANDTYPE,
                                   lHash);

        if(FAILED(hr))
        {
            PrintError("Failed to retrieve user billing queue info from database.  Error = 0x%08X.\r\n", hr);
            goto Cleanup;
        }

        if(cmdGetQueueInfo.m_RETURNVALUE != 0)
        {
            PrintError("Failed to retrieve user billing queue info from database.  Error = 0x%08X.\r\n", cmdUpdateUserKey.m_RETURNVALUE);
            goto Cleanup;
        }

        hr = cmdGetQueueInfo.MoveFirst();
        if(hr == DB_S_ENDOFROWSET)
        {
            PrintError("User %s did not have billing queue information in the database.\r\n", szXName);
            goto Cleanup;
        }

        //
        //  Convert key
        //

        cryptoHelpOld.Decrypt(
            (XOCryptoIVStruct*)(cmdGetQueueInfo.m_bin_iv),
            cmdGetQueueInfo.m_bin_payment_info,
            MAX_PAYINFO_BYTES,
            rawPaymentInfo);

        cryptoHelpNew.Encrypt(
            rawPaymentInfo,
            MAX_PAYINFO_BYTES,
            (XOCryptoIVStruct*)(cmdUpdateQueueInfo.m_bin_iv),
            cmdUpdateQueueInfo.m_bin_payment_info);

        cmdUpdateQueueInfo.m_bi_user_puid = cmdGetQueueInfo.m_bi_user_puid;
        cmdUpdateQueueInfo.m_si_old_key_enc_key_version = (SHORT)ulOldVersion;
        cmdUpdateQueueInfo.m_si_new_key_enc_key_version = (SHORT)ulNewVersion;
        
        hr = ExecuteWithParameters(piCommand,
                                   cmdUpdateQueueInfo,
                                   WRITEONLY_COMMANDTYPE,
                                   lHash);
        if(FAILED(hr))
        {
            PrintError("Failed to update user billing queue info from database.  Error = 0x%08X.\r\n", hr);
            goto Cleanup;
        }

        if(cmdUpdateUserKey.m_RETURNVALUE != 0)
        {
            PrintError("Failed to update user billing queue info from database.  Error = 0x%08X.\r\n", cmdUpdateUserKey.m_RETURNVALUE);
            goto Cleanup;
        }

        printf("Migrated user billing queue info for \"%s\" from version %u to version %u.\r\n",
               szXName,
               ulOldVersion,
               ulNewVersion);

    }
    else
    {
        LONG                        lRowsAffected;
        XOCryptoKeyEncryptionHelper cryptoHelpOld((XOCryptoKeyEncryptionKey*)(oldKey.abKey));
        XOCryptoKeyEncryptionHelper cryptoHelpNew((XOCryptoKeyEncryptionKey*)(newKey.abKey));
        XCmdGetAllUserKeys          cmdGetAllUserKeys;
        XCmdGetAllQueueInfo         cmdGetAllQueueInfo;

        printf("Migrating users...\r\n");

        //
        //  Get the next set of un-migrated user keys
        //

        cmdGetAllUserKeys.m_lOldKeyEncKeyVersion = ulOldVersion;
        cmdGetAllUserKeys.m_lNewKeyEncKeyVersion = ulNewVersion;

        hr = ExecuteWithParameters(piCommand,
                                cmdGetAllUserKeys,
                                WRITEONLY_COMMANDTYPE,
                                ALL_DATABASES);
        if(FAILED(hr))
        {
            goto Cleanup;
        }

        //
        //  See if we got back another user.  ExecuteWithParameters automatically calls
        //  GetNextResult internally, so we're positioned on the first result set.
        //  The stored procedure being called only ever returns a single row, so each
        //  result set will have at most one row in it.
        //

        do
        {
            hr = cmdGetAllUserKeys.MoveFirst();
            if(hr != DB_S_ENDOFROWSET)
            {
                do
                {
                    XOCryptoKeyStruct   userKey;
                    XCmdUpdateUserKey   cmdUpdateUserKey;

                    //
                    //  Convert user key
                    //

                    cryptoHelpOld.DecryptKey(
                        (XOCryptoIVStruct*)(cmdGetAllUserKeys.m_bin_iv),
                        (XOCryptoKeyStruct*)(cmdGetAllUserKeys.m_bin_key),
                        &userKey);

                    cryptoHelpNew.EncryptKey(
                        &userKey,
                        (XOCryptoIVStruct*)(cmdUpdateUserKey.m_bin_new_iv),
                        (XOCryptoKeyStruct*)(cmdUpdateUserKey.m_bin_new_key));

                    memset(&userKey, 0, sizeof(userKey));

                    //
                    //  Prepare to update the key
                    //

                    memcpy(cmdUpdateUserKey.m_nvc_nickname, cmdGetAllUserKeys.m_nvc_nickname, sizeof(cmdGetAllUserKeys.m_nvc_nickname));
                    cmdUpdateUserKey.m_i_key_version = cmdGetAllUserKeys.m_i_key_version;
                    cmdUpdateUserKey.m_i_old_key_enc_key_version = cmdGetAllUserKeys.m_i_key_enc_key_version;
                    cmdUpdateUserKey.m_i_new_key_enc_key_version = ulNewVersion;

                    //
                    //  Update the key
                    //

                    hr = ExecuteWithParameters(piCommand,
                                            cmdUpdateUserKey,
                                            WRITEONLY_COMMANDTYPE,
                                            cmdGetAllUserKeys.m_si_hash_bucket);
                    if(FAILED(hr))
                    {
                        PrintError("Failed to update key in database.  Error = 0x%08X.\r\n", hr);
                        break;
                    }

                    if(cmdUpdateUserKey.m_RETURNVALUE != 0)
                    {
                        PrintError("Failed to update key in database.  Error = 0x%08X.\r\n", cmdUpdateUserKey.m_RETURNVALUE);
                        break;
                    }

                    //  Process indicator

                    printf("\rUsers migrated = %d", ++ulUsersProcessed);
                }
                while(cmdGetAllUserKeys.MoveNext() != DB_S_ENDOFROWSET);
            }
        }
        while(cmdGetAllUserKeys.GetNextResult(&lRowsAffected) != DB_S_NORESULT);

        //
        //  Now get all items in billing queue and migrate them
        //

        printf("\rMigrating queued user billing information...\r\n");

        cmdGetAllQueueInfo.m_si_old_key_enc_key_version = (SHORT)ulOldVersion;
        cmdGetAllQueueInfo.m_si_new_key_enc_key_version = (SHORT)ulNewVersion;

        hr = ExecuteWithParameters(piCommand,
                                   cmdGetAllQueueInfo,
                                   WRITEONLY_COMMANDTYPE,
                                   ALL_DATABASES);
        if(FAILED(hr))
        {
            goto Cleanup;
        }

        do
        {
            hr = cmdGetAllQueueInfo.MoveFirst();
            if(hr != DB_S_ENDOFROWSET)
            {
                do
                {
                    XCmdUpdateQueueInfo cmdUpdateQueueInfo;

                    //
                    //  Convert user queue info
                    //

                    cryptoHelpOld.Decrypt(
                        (XOCryptoIVStruct*)(cmdGetAllQueueInfo.m_bin_iv),
                        cmdGetAllQueueInfo.m_bin_payment_info,
                        MAX_PAYINFO_BYTES,
                        rawPaymentInfo);

                    cryptoHelpNew.Encrypt(
                        rawPaymentInfo,
                        MAX_PAYINFO_BYTES,
                        (XOCryptoIVStruct*)(cmdUpdateQueueInfo.m_bin_iv),
                        cmdUpdateQueueInfo.m_bin_payment_info);

                    memset(rawPaymentInfo, 0, MAX_PAYINFO_BYTES);

                    //
                    //  Prepare to update the queue info
                    //

                    cmdUpdateQueueInfo.m_bi_user_puid = cmdGetAllQueueInfo.m_bi_user_puid;                
                    cmdUpdateQueueInfo.m_si_old_key_enc_key_version = (SHORT)ulOldVersion;
                    cmdUpdateQueueInfo.m_si_new_key_enc_key_version = (SHORT)ulNewVersion;

                    //
                    //  Update the queue info
                    //

                    hr = ExecuteWithParameters(piCommand,
                                            cmdUpdateQueueInfo,
                                            WRITEONLY_COMMANDTYPE,
                                            cmdGetAllQueueInfo.m_si_hash_bucket);
                    if(FAILED(hr))
                    {
                        PrintError("Failed to update queue info in database.  Error = 0x%08X.\r\n", hr);
                        break;
                    }

                    if(cmdUpdateQueueInfo.m_RETURNVALUE != 0)
                    {
                        PrintError("Failed to update queue info in database.  Error = 0x%08X.\r\n", cmdUpdateQueueInfo.m_RETURNVALUE);
                        break;
                    }

                    //  Process indicator

                    printf("\rQueued billing records migrated = %d", ++ulQueueInfoProcessed);
                }
                while(cmdGetAllQueueInfo.MoveNext() != DB_S_ENDOFROWSET);
            }
        }
        while(cmdGetAllQueueInfo.GetNextResult(&lRowsAffected) != DB_S_NORESULT);

        //
        //  Done
        //

        printf("\rDone!                                                   \r\n%u user keys migrated from version %u to version %u.\r\n%u queued billing records migrated from version %u to version %u.\r\n",
               ulUsersProcessed,
               ulOldVersion,
               ulNewVersion,
               ulQueueInfoProcessed,
               ulOldVersion,
               ulNewVersion);
    }

Cleanup:

	if(piNpdbWebstore != NULL)
    {
        piNpdbWebstore->DeInitialize();
    }

    if(piWebstore != NULL)
    {
        piWebstore->DeInitialize();
    }

    return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\migratemk.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

void MigrateMasterKey(
    ULONG   ulOldVersion,
    LPCSTR  szPublicKeyFile
    )
{
    HRESULT                             hr;
    CComPtr<IWSTStore>                  piWebstore;
    CComPtr<IWSTCommand>                piCommand;
    XCmdGetAllKeys                      cmdGetAll;
    LPBYTE                              pBlob = NULL;
    DWORD                               cbBlob;
    ULONG                               ulNewVersion;
    ULONG                               ulKeysProcessed;
    ULONG                               ulKeysMigrated;

    //
    //  Read public key from file.
    //

    if(!ReadBlobFromFile(szPublicKeyFile, pBlob, cbBlob))
        goto Cleanup;

    ulNewVersion = *(PULONG)pBlob;

    //
    //  Create and initialize the webstore object.
    //

    hr = GetNPDBWebstore(&piWebstore);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Get the command interface
    //

    hr = piWebstore->QueryInterface(&piCommand);
    if(FAILED(hr))
    {
        PrintError("Failed to get command interface on webstore client.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Get all keys from service keys table.
    //

    hr = ExecuteWithParameters(
            piCommand, 
            cmdGetAll, 
            WRITEONLY_COMMANDTYPE,
            ANY_PARTITION);
    if(FAILED(hr))
    {
        PrintError("Failed to retrieve keys from database.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    if(cmdGetAll.m_RETURNVALUE != 0)
    {
        PrintError("Failed to retrieve keys from database.  Error = 0x%08X.\r\n", cmdGetAll.m_RETURNVALUE);
        goto Cleanup;
    }

    //
    //  Now begin looping through the result set.  For each key, decrypt with old key
    //  and encrypt with new key, then insert newly encrypted key into db.
    //

    ulKeysProcessed = 0;
    ulKeysMigrated  = 0;

    hr = cmdGetAll.MoveFirst();
    if(FAILED(hr))
    {
        PrintError("Failed to retrieve keys from database.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    while(hr != DB_S_ENDOFROWSET)
    {
        //
        //  Only process keys encrypted with the specified old key version,
        //  they're the only ones we can properly decrypt.
        //

        if(cmdGetAll.m_i_master_key_ver == (LONG)ulOldVersion)
        {
            XCmdInsertKey                       cmdInsert;
            XOCryptoMasterKeyEncryptedStruct    key;

            ++ulKeysProcessed;

            //
            //  Get the existing key.
            //

            key.dwKeyLen = cmdGetAll.m_i_key_len;
            memcpy(key.abKey, cmdGetAll.m_bin_key, cmdGetAll.m_i_key_len);

            //
            //  Decrypt with old mk then encrypt with new
            //

            hr = DecryptWithMasterKey(ulOldVersion, &key);
            if(hr != S_OK)
            {
                PrintError("Failed to decrypt key: type=%u ver=%u mkver=%u data1=\"%S\" data2=\"%S\".  Error = 0x%08X.\r\n",
                    cmdGetAll.m_i_key_type,
                    cmdGetAll.m_i_key_ver,
                    cmdGetAll.m_i_master_key_ver,
                    cmdGetAll.m_nvc_key_data1,
                    cmdGetAll.m_nvc_key_data2,
                    hr);
                goto NextRow;
            }

            hr = EncryptWithMasterKey(ulNewVersion, pBlob + sizeof(ULONG), cbBlob - sizeof(ULONG), &key);
            if(hr != S_OK)
            {
                PrintError("Failed to encrypt key: type=%u ver=%u mkver=%u data1=\"%S\" data2=\"%S\".  Error = 0x%08X.\r\n",
                    cmdGetAll.m_i_key_type,
                    cmdGetAll.m_i_key_ver,
                    cmdGetAll.m_i_master_key_ver,
                    cmdGetAll.m_nvc_key_data1,
                    cmdGetAll.m_nvc_key_data2,
                    hr);
                goto NextRow;
            }

            //
            //  Insert newly encrypted key into db
            //

            cmdInsert.m_i_key_type          = cmdGetAll.m_i_key_type;
            cmdInsert.m_i_key_ver           = cmdGetAll.m_i_key_ver;
            cmdInsert.m_i_master_key_ver    = ulNewVersion;
            cmdInsert.m_i_data1_len         = cmdGetAll.m_i_data1_len;
            cmdInsert.m_i_data2_len         = cmdGetAll.m_i_data2_len;
            cmdInsert.m_i_site_id           = cmdGetAll.m_i_site_id;
            cmdInsert.m_i_lifetime          = cmdGetAll.m_i_lifetime;
            cmdInsert.m_i_key_len           = key.dwKeyLen;

            memcpy(cmdInsert.m_nvc_data1, cmdGetAll.m_nvc_key_data1, sizeof(cmdInsert.m_nvc_data1));
            memcpy(cmdInsert.m_nvc_data2, cmdGetAll.m_nvc_key_data2, sizeof(cmdInsert.m_nvc_data2));
            memcpy(cmdInsert.m_bin_key, key.abKey, key.dwKeyLen);

            hr = ExecuteWithParameters(
                    piCommand, 
                    cmdInsert, 
                    WRITEONLY_COMMANDTYPE,
                    ALL_DATABASES);
            if(FAILED(hr))
            {
                PrintError("Failed to insert key into database.  Error = 0x%08X.\r\n", hr);
                goto NextRow;
            }

            if(cmdGetAll.m_RETURNVALUE != 0)
            {
                PrintError("Failed to insert key into database.  Error = 0x%08X.\r\n", cmdGetAll.m_RETURNVALUE);
                goto NextRow;
            }

            printf("Key migrated: type=%u ver=%u mkver=%u data1=\"%S\" data2=\"%S\"\r\n",
                cmdGetAll.m_i_key_type,
                cmdGetAll.m_i_key_ver,
                cmdGetAll.m_i_master_key_ver,
                cmdGetAll.m_nvc_key_data1,
                cmdGetAll.m_nvc_key_data2);

            ++ulKeysMigrated;
        }

        //
        //  Next key
        //

NextRow:

        hr = cmdGetAll.MoveNext(0);
        if(FAILED(hr))
        {
            PrintError("Failed to retrieve keys from database.  Error = 0x%08X.\r\n", hr);
            goto Cleanup;
        }
    }

    if(ulKeysProcessed == ulKeysMigrated)
        printf("All keys successfully migrated.\r\n");
    else
        printf("%u keys processed.\r\n%u keys successfully migrated.\r\n", ulKeysProcessed, ulKeysMigrated);

Cleanup:

    if(pBlob != NULL)
        free(pBlob);

    if(piWebstore != NULL)
    {
        piWebstore->DeInitialize();
    }

    return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\protect.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"


// Entropy for encrypting configuration. Must match abEntropy in sglib.

BYTE abEntropy[] = {
    0x6a, 0xd4, 0xbf, 0x5a, 0x98, 0xe3, 0x88, 0x4b, 0xbf, 0xa2, 0x20, 0x53, 0x30, 0xc0, 0x38, 0xe3,
    0x5e, 0xcb, 0x9a, 0x6, 0xe2, 0x37, 0x2c, 0x74, 0x7f, 0xd8, 0x10, 0xd7, 0xf, 0x23, 0x89, 0x75,
    0x9b, 0x85, 0xf5, 0x82, 0x1b, 0x9b, 0xa8, 0xd7, 0x7a, 0x55, 0x25, 0xca, 0x9f, 0x93, 0xca, 0xb4,
    0x9f, 0xbd, 0x13, 0xcc, 0x64, 0xec, 0x9, 0xa1, 0xd2, 0xf8, 0x9, 0x71, 0xd, 0x2a, 0x1b, 0x87,
    0xba, 0xe, 0x1e, 0x4d, 0x7e, 0x52, 0x1b, 0x4d, 0xc6, 0xcc, 0x4b, 0x9d, 0xc7, 0xf3, 0x87, 0xf6,
    0x2e, 0x74, 0xea, 0xe3, 0xcd, 0x97, 0x3a, 0x49, 0x83, 0x80, 0xa4, 0xa1, 0xc, 0xc6, 0x98, 0x97,
    0xd4, 0xd1, 0x88, 0x3c, 0xee, 0x8e, 0xb0, 0x3b, 0xb4, 0x6e, 0xb5, 0xb2, 0xed, 0x43, 0xdb, 0x7e,
    0x96, 0xf3, 0xfb, 0x60, 0x8b, 0x45, 0x5c, 0x43, 0x9d, 0x7f, 0x8f, 0x5d, 0xcf, 0xf2, 0xd, 0x76,
    0x71, 0xa, 0xc5, 0x29, 0x6, 0x6c, 0x85, 0xa3, 0x33, 0xe, 0x83, 0x5, 0xa0, 0x75, 0xba, 0xc1,
    0xe5, 0xf3, 0x5a, 0x11, 0x72, 0x29, 0xd2, 0xfd, 0x7e, 0xe8, 0xbd, 0x39, 0x30, 0x95, 0x5f, 0xde,
    0xee, 0x21, 0xa8, 0x25, 0xa9, 0xcd, 0x45, 0x31, 0x12, 0x29, 0x59, 0x24, 0x19, 0x22, 0xc5, 0x6a,
    0xbc, 0x71, 0x2b, 0x16, 0x8f, 0xaf, 0xb, 0xd, 0xa, 0xf5, 0xc9, 0xad, 0xe9, 0x21, 0xab, 0xd,
    0x63, 0xea, 0xa3, 0x99, 0x99, 0x31, 0xd7, 0x4e, 0x87, 0xcb, 0x38, 0xb2, 0x33, 0xc2, 0xf7, 0xf8,
    0x32, 0xb, 0xee, 0x9, 0xcc, 0x2f, 0xea, 0x4f, 0xd, 0xa3, 0x5c, 0x7, 0x4a, 0x9a, 0xe0, 0x75,
    0xcb, 0x5b, 0x48, 0x1, 0x99, 0xdb, 0x4f, 0xb, 0x54, 0xde, 0x8a, 0x18, 0xaf, 0x97, 0x4f, 0xdc,
    0x19, 0xf1, 0x7c, 0x48, 0x30, 0xcd, 0xd0, 0xe2, 0x72, 0xe1, 0x2f, 0x4b, 0x84, 0xbe, 0x2b, 0x5c
};


void Protect(
    LPCSTR  szInputFile,
    LPCSTR  szOutputFile
    )
{
    DATA_BLOB   DataIn      = {0, NULL};
    DATA_BLOB   DataOut     = {0, NULL};
    DATA_BLOB   DataEntropy = { sizeof(abEntropy), abEntropy };

    //
    //  Read the data to be protected
    //

    if(!ReadBlobFromFile(szInputFile, DataIn.pbData, DataIn.cbData))
    {
        goto Cleanup;
    }

    //
    //  Protect the data
    //

    if(!CryptProtectData(&DataIn,
                         L"Security Gateway Key Configuration",
                         &DataEntropy,
                         NULL,
                         NULL,
                         CRYPTPROTECT_LOCAL_MACHINE,
                         &DataOut))
    {
        DWORD dwError = GetLastError();
        PrintError("Error protecting data.  Error = 0x%08X.\r\n", HRESULT_FROM_WIN32(dwError));
        goto Cleanup;
    }

    //
    //  Write the protected data to disk.
    //

    if(!WriteBlobToFile(szOutputFile, DataOut.pbData, DataOut.cbData, FALSE))
    {
        goto Cleanup;
    }

    printf("The data in \"%s\" has been protected and stored in \"%s\".\r\n",
           szInputFile,
           szOutputFile);

Cleanup:

    if(DataOut.pbData != NULL)
        LocalFree(DataOut.pbData);
    if(DataIn.pbData != NULL)
        free(DataIn.pbData);

    return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\removefreq.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

void RemoveFrequentlyUsedKey(
    ULONG   ulKeyType,
    ULONG   ulKeyVersion,
    LPCSTR  szKeyData1,
    LPCSTR  szKeyData2,
    ULONG   ulMasterKeyVersion
    )
{
    HRESULT                             hr;
    CComPtr<IWSTStore>                  piWebstore;
    CComPtr<IWSTCommand>                piCommand;
    XCmdRemoveKey                       cmd;

    //
    //  Create and initialize the webstore object.
    //

    hr = GetNPDBWebstore(&piWebstore);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Get the command interface
    //

    hr = piWebstore->QueryInterface(&piCommand);
    if(FAILED(hr))
    {
        PrintError("Failed to get command interface on webstore client.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Initialize command object and execute
    //

    cmd.m_i_key_type       = ulKeyType;
    cmd.m_i_key_ver        = ulKeyVersion;
    cmd.m_i_master_key_ver = ulMasterKeyVersion;

    if(szKeyData1 != NULL)
    {
        int nDataLen = strlen(szKeyData1);
        if(nDataLen > 199)
            nDataLen = 199;
        else
            ++nDataLen;
        
        cmd.m_i_data1_len = MultiByteToWideChar(
                                CP_ACP, 
                                0, szKeyData1, 
                                nDataLen, 
                                cmd.m_nvc_data1, 
                                sizeof(cmd.m_nvc_data1)/sizeof(WCHAR));
        cmd.m_nvc_data1[199] = L'\0';
    }
    else
    {
        cmd.m_i_data1_len = 0;
        memset(cmd.m_nvc_data1, 0, sizeof(cmd.m_nvc_data1));
    }

    if(szKeyData2 != NULL)
    {
        int nDataLen = strlen(szKeyData2);
        if(nDataLen > 199)
            nDataLen = 199;
        else
            ++nDataLen;
        
        cmd.m_i_data2_len = MultiByteToWideChar(
                                CP_ACP, 
                                0, szKeyData2, 
                                nDataLen, 
                                cmd.m_nvc_data2, 
                                sizeof(cmd.m_nvc_data2)/sizeof(WCHAR));
        cmd.m_nvc_data2[199] = L'\0';
    }
    else
    {
        cmd.m_i_data1_len = 0;
        memset(cmd.m_nvc_data1, 0, sizeof(cmd.m_nvc_data1));
    }

    hr = ExecuteWithParameters(
            piCommand, 
            cmd, 
            WRITEONLY_COMMANDTYPE,
            ALL_DATABASES);
    if(FAILED(hr))
    {
        PrintError("Failed to remove key from database.  Error = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    if(cmd.m_RETURNVALUE == 1)
    {
        PrintError("Error: Key not found in database.\r\n");
    }
    else if(cmd.m_RETURNVALUE != 0)
    {
        PrintError("Failed to remove key from database.  Error = 0x%08X.\r\n", cmd.m_RETURNVALUE);
    }
    else
    {
        printf("Removed key from database.\r\n");
    }

Cleanup:

    if(piWebstore != NULL)
    {
        piWebstore->DeInitialize();
    }

    return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\storemk.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"


void StoreMasterKey(
    LPCSTR  szFileName
    )
{
    LPBYTE      pBlob = NULL;
    DWORD       cbBlobLen;
    WCHAR       szContainerName[256];
    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    HCRYPTKEY   hSymKey = NULL;
    ULONG       ulMasterKeyVer;

    //
    //  First get the file size.
    //

    if(!ReadBlobFromFile(szFileName, pBlob, cbBlobLen))
        goto Cleanup;

    ulMasterKeyVer = *(PULONG)pBlob;

    //
    //  Format container name.
    //

    _snwprintf( 
        szContainerName, 
        sizeof(szContainerName)/sizeof(WCHAR), 
        MASTER_KEY_CONTAINER_NAME, 
        ulMasterKeyVer );

    //
    //  Get the crypto context
    //

    if(!CryptAcquireContextW(
            &hProv,
            szContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_NEWKEYSET))
    {
        DWORD dwError = GetLastError();
        switch(dwError)
        {
        case NTE_EXISTS:
            PrintError("This master key already exists on this machine.\r\n");
            break;

        default:
            PrintError("Error acquiring crypto context.  Error = 0x%08X.\r\n", HRESULT_FROM_WIN32(dwError));
            break;
        }

        goto Cleanup;
    }

    //
    //  Generate the symmetric key for encrypting/decrypting key pair.
    //

    if(!GetSymmetricKey(hProv, hSymKey))
            goto Cleanup;

    //
    //  Now import the key
    //

    if(!CryptImportKey(
        hProv,
        pBlob + sizeof(ULONG),
        cbBlobLen - sizeof(ULONG),
        hSymKey,
        0,
        &hKey))
    {
        DWORD dwError = GetLastError();
        switch(dwError)
        {
        case NTE_BAD_DATA:
        case NTE_BAD_VER:
            PrintError("The file contained invalid key data.\r\n");
            break;

        default:
            PrintError("Failed to import key.  Error = 0x%08X.\r\n", HRESULT_FROM_WIN32(dwError));
            break;
        }

        goto Cleanup;
    }
       
    CryptDestroyKey(hKey);
    hKey = NULL;

    if(!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey))
    {
        PrintError("Unable to retrieve stored key.  Error = 0x%08X.\r\n", HRESULT_FROM_WIN32(GetLastError()));
        goto Cleanup;
    }

    CryptDestroyKey(hKey);
    hKey = NULL;

    printf("The key has been stored.\r\n");

Cleanup:

    if(hKey != NULL)
        CryptDestroyKey(hKey);
    if(hSymKey != NULL)
        CryptDestroyKey(hSymKey);
    if(hProv != NULL)
        CryptReleaseContext(hProv, 0);
    if(pBlob != NULL)
        free(pBlob);

    return;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\xaccessors.h ===
#pragma once
#ifndef __XAccessorsAuth
#define __XAccessorsAuth

#define MAX_PAYINFO_BYTES 1984 // see also:  billingqueue.cs

//-----------------------------------------------
//  class XInsertKey
//
class XInsertKey
{
public:
    XInsertKey() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XInsertKey)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_i_key_type)
    COLUMN_ENTRY(3, m_i_key_ver)
    COLUMN_ENTRY(4, m_i_master_key_ver)
    COLUMN_ENTRY(5, m_i_site_id)
    COLUMN_ENTRY(6, m_i_lifetime)
    COLUMN_ENTRY_TYPE_SIZE(7, DBTYPE_WSTR, m_i_data1_len, m_nvc_data1)
    COLUMN_ENTRY_TYPE_SIZE(8, DBTYPE_WSTR, m_i_data2_len, m_nvc_data2)
    COLUMN_ENTRY_TYPE_SIZE(9, DBTYPE_BYTES, m_i_key_len, m_bin_key)
    COLUMN_ENTRY(10, m_i_update)
END_PARAM_MAP()

DEFINE_COMMAND_EX(XInsertKey, L"{ ? = CALL dbo.p_kmgr_insert_key;1 ( ?, ?, ?, ?, ?, ?, ?, ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    LONG        m_i_key_type;
    LONG        m_i_master_key_ver;
    LONG        m_i_key_ver;
    LONG        m_i_site_id;
    LONG        m_i_lifetime;
    WCHAR       m_nvc_data1[200];
    WCHAR       m_nvc_data2[200];
    BYTE        m_bin_key[SERVICE_KEY_SIZE];
    LONG        m_i_update;

    // Length of buffer
    LONG        m_i_key_len;
    LONG        m_i_data1_len;
    LONG        m_i_data2_len;
};

typedef CCommand<CAccessor<XInsertKey>, CRowset, CMultipleResults> XCmdInsertKey;

//-----------------------------------------------
//  class XRemoveKey
//
class XRemoveKey
{
public:
    XRemoveKey() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XRemoveKey)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_i_key_type)
    COLUMN_ENTRY(3, m_i_key_ver)
    COLUMN_ENTRY(4, m_i_master_key_ver)
    COLUMN_ENTRY_TYPE_SIZE(5, DBTYPE_WSTR, m_i_data1_len, m_nvc_data1)
    COLUMN_ENTRY_TYPE_SIZE(6, DBTYPE_WSTR, m_i_data2_len, m_nvc_data2)
END_PARAM_MAP()

DEFINE_COMMAND_EX(XRemoveKey, L"{ ? = CALL dbo.p_kmgr_remove_key;1 ( ?, ?, ?, ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    LONG        m_i_key_type;
    LONG        m_i_key_ver;
    LONG        m_i_master_key_ver;
    WCHAR       m_nvc_data1[200];
    WCHAR       m_nvc_data2[200];

    // Length of buffer
    LONG        m_i_data1_len;
    LONG        m_i_data2_len;
};

typedef CCommand<CAccessor<XRemoveKey>, CRowset, CMultipleResults> XCmdRemoveKey;

//-----------------------------------------------
//  class XGetKeyAccessor
//
class XGetKeyAccessor
{
public:
    XGetKeyAccessor() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XGetKeyAccessor)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_i_key_type)
    COLUMN_ENTRY(3, m_i_key_ver)
    COLUMN_ENTRY_LENGTH(4, m_nvc_key_data1, m_i_data1_len)
    COLUMN_ENTRY_LENGTH(5, m_nvc_key_data2, m_i_data2_len)
    COLUMN_ENTRY(6, m_i_master_key_ver)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(XGetKeyAccessor)
    COLUMN_ENTRY_LENGTH(1, m_bin_key, m_i_key_len)
END_COLUMN_MAP()

DEFINE_COMMAND_EX(XGetKeyAccessor, L"{ ? = CALL dbo.p_kmgr_get_service_key;1 ( ?, ?, ?, ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    LONG        m_i_key_type;
    WCHAR       m_nvc_key_data1[200];
    WCHAR       m_nvc_key_data2[200];
    LONG        m_i_master_key_ver;
    LONG        m_i_key_ver;
    
    BYTE        m_bin_key[256];

    // length of buffer
    LONG        m_i_data1_len;
    LONG        m_i_data2_len;
    
    LONG        m_i_key_len;
};

typedef CCommand<CAccessor<XGetKeyAccessor>, CRowset, CMultipleResults> XCmdGetKey;


//-----------------------------------------------
//  class XGetAllKeysAccessor
//
class XGetAllKeysAccessor
{
public:
    XGetAllKeysAccessor() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XGetAllKeysAccessor)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(XGetAllKeysAccessor)
    COLUMN_ENTRY(1, m_i_key_type)
    COLUMN_ENTRY_LENGTH(2, m_nvc_key_data1, m_i_data1_len)
    COLUMN_ENTRY_LENGTH(3, m_nvc_key_data2, m_i_data2_len)
    COLUMN_ENTRY(4, m_i_site_id)
    COLUMN_ENTRY(5, m_i_lifetime)
    COLUMN_ENTRY(6, m_i_master_key_ver)
    COLUMN_ENTRY(7, m_i_key_ver)
    COLUMN_ENTRY_LENGTH(8, m_bin_key, m_i_key_len)
END_COLUMN_MAP()

DEFINE_COMMAND_EX(XGetAllKeysAccessor, L"{ ? = CALL dbo.p_kmgr_get_all_keys;1 }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    LONG        m_i_key_type;
    WCHAR       m_nvc_key_data1[200];
    WCHAR       m_nvc_key_data2[200];
    LONG        m_i_site_id;
    LONG        m_i_lifetime;
    LONG        m_i_master_key_ver;
    LONG        m_i_key_ver;
    BYTE        m_bin_key[256];

    // length of buffer
    LONG        m_i_data1_len;
    LONG        m_i_data2_len;
    LONG        m_i_key_len;
};

typedef CCommand<CAccessor<XGetAllKeysAccessor>, CRowset, CMultipleResults> XCmdGetAllKeys;


//-----------------------------------------------
//  class XGetAllUserKeysAccessor
//
class XGetAllUserKeysAccessor
{
public:
    XGetAllUserKeysAccessor() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XGetAllUserKeysAccessor)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_lOldKeyEncKeyVersion)
    COLUMN_ENTRY(3, m_lNewKeyEncKeyVersion)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(XGetAllUserKeysAccessor)
    COLUMN_ENTRY(1, m_nvc_nickname)
    COLUMN_ENTRY(2, m_bi_user_puid)
    COLUMN_ENTRY(3, m_i_key_enc_key_version)
    COLUMN_ENTRY(4, m_i_key_version)
    COLUMN_ENTRY(5, m_bin_iv)
    COLUMN_ENTRY(6, m_bin_key)
    COLUMN_ENTRY(7, m_si_hash_bucket)
END_COLUMN_MAP()

DEFINE_COMMAND_EX(XGetAllUserKeysAccessor, L"{ ? = CALL dbo.p_kmgr_get_all_user_keys;1 ( ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    LONG        m_lOldKeyEncKeyVersion;
    LONG        m_lNewKeyEncKeyVersion;

    WCHAR       m_nvc_nickname[100];
    ULONGLONG   m_bi_user_puid;
    LONG        m_i_key_enc_key_version;
    LONG        m_i_key_version;
    BYTE        m_bin_iv[16];
    BYTE        m_bin_key[16];
    SHORT       m_si_hash_bucket;
};

typedef CCommand<CAccessor<XGetAllUserKeysAccessor>, CRowset, CMultipleResults> XCmdGetAllUserKeys;

//-----------------------------------------------
//  class XGetUserKeyAccessor
//
class XGetUserKeyAccessor
{
public:
    XGetUserKeyAccessor() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XGetUserKeyAccessor)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_nvc_nickname)
    COLUMN_ENTRY(3, m_lOldKeyEncKeyVersion)
    COLUMN_ENTRY(4, m_lNewKeyEncKeyVersion)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(XGetUserKeyAccessor)
    COLUMN_ENTRY(1, m_nvc_nickname)
    COLUMN_ENTRY(2, m_bi_user_puid)
    COLUMN_ENTRY(3, m_i_key_enc_key_version)
    COLUMN_ENTRY(4, m_i_key_version)
    COLUMN_ENTRY(5, m_bin_iv)
    COLUMN_ENTRY(6, m_bin_key)
END_COLUMN_MAP()

DEFINE_COMMAND_EX(XGetUserKeyAccessor, L"{ ? = CALL dbo.p_kmgr_get_user_key;1 ( ?, ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    LONG        m_lOldKeyEncKeyVersion;
    LONG        m_lNewKeyEncKeyVersion;

    WCHAR       m_nvc_nickname[100];
    ULONGLONG   m_bi_user_puid;
    LONG        m_i_key_enc_key_version;
    LONG        m_i_key_version;
    BYTE        m_bin_iv[16];
    BYTE        m_bin_key[16];
};

typedef CCommand<CAccessor<XGetUserKeyAccessor>, CRowset, CMultipleResults> XCmdGetUserKey;

//-----------------------------------------------
//  class XUpdateUserKey
//
class XUpdateUserKey
{
public:
    XUpdateUserKey() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XUpdateUserKey)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_nvc_nickname)
    COLUMN_ENTRY(3, m_i_key_version)
    COLUMN_ENTRY(4, m_i_old_key_enc_key_version)
    COLUMN_ENTRY(5, m_i_new_key_enc_key_version)
    COLUMN_ENTRY(6, m_bin_new_iv)
    COLUMN_ENTRY(7, m_bin_new_key)
END_PARAM_MAP()

DEFINE_COMMAND_EX(XUpdateUserKey, L"{ ? = CALL dbo.p_kmgr_update_user_key;1 ( ?, ?, ?, ?, ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    WCHAR       m_nvc_nickname[100];
    LONG        m_i_key_version;
    LONG        m_i_old_key_enc_key_version;
    LONG        m_i_new_key_enc_key_version;
    BYTE        m_bin_new_iv[AES_BLOCKLEN];
    BYTE        m_bin_new_key[ONLINE_KEY_LEN];
};

typedef CCommand<CAccessor<XUpdateUserKey>, CRowset, CMultipleResults> XCmdUpdateUserKey;

//-----------------------------------------------
//  class XGetAllQueueInfo
//
class XGetAllQueueInfo
{
public:
    XGetAllQueueInfo() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XGetAllQueueInfo)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_si_old_key_enc_key_version)
    COLUMN_ENTRY(3, m_si_new_key_enc_key_version)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(XGetAllQueueInfo)
    COLUMN_ENTRY(1, m_bi_user_puid)
    COLUMN_ENTRY(2, m_si_key_enc_key_version)
    COLUMN_ENTRY(3, m_bin_iv)
    COLUMN_ENTRY(4, m_bin_payment_info)
    COLUMN_ENTRY(5, m_si_hash_bucket)
END_COLUMN_MAP()

DEFINE_COMMAND_EX(XGetAllQueueInfo, L"{ ? = CALL dbo.p_kmgr_get_all_billing_queue_info;1 ( ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;
    SHORT       m_si_old_key_enc_key_version;
    SHORT       m_si_new_key_enc_key_version;

    // Output columns
    ULONGLONG   m_bi_user_puid;
    SHORT       m_si_key_enc_key_version;
    BYTE        m_bin_iv[AES_BLOCKLEN];
    BYTE        m_bin_payment_info[MAX_PAYINFO_BYTES];
    SHORT       m_si_hash_bucket;
};

typedef CCommand<CAccessor<XGetAllQueueInfo>, CRowset, CMultipleResults> XCmdGetAllQueueInfo;

//-----------------------------------------------
//  class XGetQueueInfo
//
class XGetQueueInfo
{
public:
    XGetQueueInfo() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XGetQueueInfo)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_bi_user_puid)
    COLUMN_ENTRY(3, m_si_old_kek_version)
END_PARAM_MAP()

BEGIN_COLUMN_MAP(XGetQueueInfo)
    COLUMN_ENTRY(1, m_bin_iv)
    COLUMN_ENTRY(2, m_bin_payment_info)
END_COLUMN_MAP()

DEFINE_COMMAND_EX(XGetQueueInfo, L"{ ? = CALL dbo.p_kmgr_get_billing_queue_info;1 ( ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    ULONGLONG   m_bi_user_puid;
    SHORT       m_si_old_kek_version;

    BYTE        m_bin_iv[AES_BLOCKLEN];
    BYTE        m_bin_payment_info[MAX_PAYINFO_BYTES];
};

typedef CCommand<CAccessor<XGetQueueInfo>, CRowset, CMultipleResults> XCmdGetQueueInfo;

//-----------------------------------------------
//  class XUpdateQueueInfo
//
class XUpdateQueueInfo
{
public:
    XUpdateQueueInfo() 
    {
        ZeroMemory(this, sizeof(*this)); 
    }

BEGIN_PARAM_MAP(XUpdateQueueInfo)
    SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
    COLUMN_ENTRY(1, m_RETURNVALUE)
    SET_PARAM_TYPE(DBPARAMIO_INPUT)
    COLUMN_ENTRY(2, m_bi_user_puid)
    COLUMN_ENTRY(3, m_si_old_key_enc_key_version)
    COLUMN_ENTRY(4, m_si_new_key_enc_key_version)
    COLUMN_ENTRY(5, m_bin_iv)
    COLUMN_ENTRY(6, m_bin_payment_info)
END_PARAM_MAP()

DEFINE_COMMAND_EX(XUpdateQueueInfo, L"{ ? = CALL dbo.p_kmgr_update_billing_queue_info;1 ( ?, ?, ?, ?, ? ) }")

    // Command Parameters
    LONG        m_RETURNVALUE;

    ULONGLONG   m_bi_user_puid;
    SHORT       m_si_old_key_enc_key_version;
    SHORT       m_si_new_key_enc_key_version;
    BYTE        m_bin_iv[AES_BLOCKLEN];
    BYTE        m_bin_payment_info[MAX_PAYINFO_BYTES];
};

typedef CCommand<CAccessor<XUpdateQueueInfo>, CRowset, CMultipleResults> XCmdUpdateQueueInfo;


#endif // __XAccessorsAuth

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkeymgr_none_12.4.56.0_none_2d1ab9e6786ba825
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkeymgr
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.manifest
XP_MANIFEST_PATH=manifests\x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.cat
XP_CATALOG_PATH=manifests\x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.cat
XP_PAYLOAD_PATH=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkeymgr,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\removemk.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"


void RemoveMasterKey(
    ULONG   ulMasterKeyVer
    )
{
    WCHAR       szContainerName[256];
    HCRYPTPROV  hProv;

    //
    //  Format container names
    //

    _snwprintf( 
        szContainerName, 
        sizeof(szContainerName)/sizeof(WCHAR), 
        MASTER_KEY_CONTAINER_NAME, 
        ulMasterKeyVer );
    szContainerName[(sizeof(szContainerName)/sizeof(szContainerName[0]))-1] = L'\0';

    //
    //  Delete the keyset
    //

    if(!CryptAcquireContextW(
        &hProv,
        szContainerName,
        MS_ENHANCED_PROV_W,
        PROV_RSA_FULL,
        CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_DELETEKEYSET))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        switch(hr)
        {
        case NTE_BAD_KEYSET:
            PrintError("Either the master key %u does not exist or you do not have permission to remove it.\r\n", 
                ulMasterKeyVer);
            break;

        default:
            PrintError("Failed to delete keyset for master key version %u.  Error = 0x%08X.\r\n",
                ulMasterKeyVer,
                hr);
            break;
        }
    }
    else
        printf("Deleted keyset for master key version %u.\r\n", 
               ulMasterKeyVer);

    return;
}

void RemoveKey(
    LPCSTR szKeyContainer
    )
{
    WCHAR       szContainerName[256];
    HCRYPTPROV  hProv;
    
    //
    //  Format container names
    //

    _snwprintf(
        szContainerName, 
        sizeof(szContainerName)/sizeof(WCHAR), 
        L"%S",
        szKeyContainer);
    szContainerName[(sizeof(szContainerName)/sizeof(szContainerName[0]))-1] = L'\0';
    
    //
    //  Delete the keyset
    //

    if(!CryptAcquireContextW(
        &hProv,
        szContainerName,
        MS_ENHANCED_PROV_W,
        PROV_RSA_FULL,
        CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_DELETEKEYSET))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        switch(hr)
        {
        case NTE_BAD_KEYSET:
            printf(
                "Either the container %S does not exist or you do not have permission to remove it.\r\n", 
                szContainerName);
            break;

        default:
            printf(
                "Failed to delete container %S. Error = 0x%08X.\r\n",
                szContainerName,
                hr);
            break;
        }
    }
    else
        printf("Deleted keyset for container %S.\r\n", 
               szContainerName);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkeymgr_none_12.4.56.0_none_2d1ab9e6786ba825
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkeymgr
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.manifest
XP_MANIFEST_PATH=manifests\x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.cat
XP_CATALOG_PATH=manifests\x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447.cat
XP_PAYLOAD_PATH=x86_xkeymgr_no-public-key_12.4.56.0_x-ww_283e1447
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkeymgr,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\xkeymgr.h ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once
#ifndef __XKEYMGR_H
#define __XKEYMGR_H

#define PrintError(fmt, ...) printf("ERROR: " fmt, __VA_ARGS__)


//
//  Function prototypes
//

void Usage(void);
BOOL WriteBlobToFile(LPCSTR, LPBYTE, DWORD, BOOL);
BOOL ReadBlobFromFile(LPCSTR, LPBYTE&, DWORD&);
BOOL GetSymmetricKey(HCRYPTPROV, HCRYPTKEY&);
BOOL GetNumArg(LPCSTR, ULONG&);
HRESULT GetUODBWebstore(IWSTStore**);
HRESULT GetNPDBWebstore(IWSTStore**);
LPCWSTR GetNpdbConnectionString();
void PrintExtendedDatabaseError();

BOOL AddFrequentlyUsedKey(ULONG, ULONG, LPCSTR, LPCSTR, ULONG, LPCSTR, LPCSTR, ULONG, ULONG, LPCSTR, BOOL);
void CreateMasterKey(ULONG, LPCSTR, LPCSTR);
void CreateRandomKey(LPCSTR, ULONG);
void MigrateMasterKey(ULONG, LPCSTR);
void MigrateKeyEncryptionKey(ULONG, ULONG, ULONG, LPCSTR);
void Protect(LPCSTR, LPCSTR);
void RemoveFrequentlyUsedKey(ULONG, ULONG, LPCSTR, LPCSTR, ULONG);
void RemoveMasterKey(ULONG);
void RemoveKey(LPCSTR);
void StoreMasterKey(LPCSTR);
void AddWmdrmCert(LPCSTR , LPCSTR , LPCSTR );
void AddPlayReadyCert(LPCSTR , LPCSTR , LPCSTR );
BOOL EncryptBlob(LPCSTR, LPCSTR, LPCSTR);
BOOL DecryptBlob(ULONG, LPCSTR, LPCSTR);
BOOL MigrateBlob(ULONG, LPCSTR, LPCSTR, LPCSTR);

HRESULT ValidatePublicKey(LPBYTE, DWORD, BOOL*);
HRESULT ValidatePublicKeyFromFile(LPCSTR);

void DumpMasterKeyContainer(ULONG);
void DumpKeyContainer(LPCWSTR);

#endif // __XKEYMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\App\xkeymgr.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

#include "wststore_i.c"
#include "wststoreidl_i.c"

//
//  Main entrypoint
//

int __cdecl main(
    int     argc,
    char**  argv
    )
{
    //
    //  Initialize COM.  Not all commands need this, but some do.
    //

    if(FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        PrintError("COM failed to initialize.\r\n");
        goto Cleanup;
    }

    // Initialize mem allocator for cu_string.h usage.
    CMemAlloc::Init();

    //
    //  Process parameters
    //

    if(argc < 2)
    {
        Usage();
        goto Cleanup;
    }

    if(lstrcmpA(argv[1], "/?") == 0)
    {
        Usage();
        goto Cleanup;
    }

    //
    //  What command is being executed?
    //

    switch(tolower(argv[1][0]))
    {
    case 'a':
        if(lstrcmpiA(argv[1], "addfreq") == 0)
        {
            if(argc < 5)
                Usage();
            else
            {
                ULONG ulKeyType;
                ULONG ulKeyVersion;
                ULONG ulKeyLen = 0xFFFFFFFF;
                ULONG ulSiteID = 0xFFFFFFFF;
                ULONG ulLifetime = 0xFFFFFFFF;
                LPSTR szPublicKeyFile = NULL;
                LPSTR szKeyFile = NULL;
                LPSTR szData1 = NULL;
                LPSTR szData2 = NULL;
                LPSTR szSGConfigFile = NULL;
                CHAR  szSiteData2[32];

                if(!GetNumArg(argv[2], ulKeyType) ||
                   !GetNumArg(argv[3], ulKeyVersion))
                    Usage();
                else
                {
                    LONG lCurArg;

                    //
                    //  Set up default parameters based on key type, so parameters can be omitted for these types
                    //

                    switch(ulKeyType)
                    {
                    case KEY_TYPE_KDC_PASSPORT_NET:
                        ulKeyLen = 16;
                        szData1 = "krbtgt";
                        szData2 = "PASSPORT.NET";
                        ulLifetime = 2592000;
                        break;

                    case KEY_TYPE_KDC_XBOX_COM:
                        ulKeyLen = 16;
                        szData1 = "krbtgt";
                        szData2 = "XBOX.COM";
                        ulLifetime = 2592000;
                        break;

                    case KEY_TYPE_KEY_ENCRYPTION_KEY:
                        ulKeyLen = 32;
                        break;

                    case KEY_TYPE_SECURITY_GATEWAY:
                        ulKeyLen = 16;
                        szData1 = "sg";
                        szData2 = "site%u";
                        ulLifetime = 129600;
                        break;

                    case KEY_TYPE_SIGNATURE_SERVER:
                        ulKeyLen = 32;
                        break;

                    case KEY_TYPE_MUSICNET_AES_KEY:
                        ulKeyLen = 16;
                        szData1 = "MusicNet AES Key for Auth Token";
                        szData2 = "musicnet.com";
                        break;

                    case KEY_TYPE_KDC_ECHO_DATA:
                        ulKeyLen = 32;
                        szData1 = "ASKDC Echo Data Key";
                        break;

                    case KEY_TYPE_PASSPORT_DELADMIN:
                    case KEY_TYPE_BILLING:
                        // no defaults for these yet
                        break;

                    case KEY_TYPE_WMRM_EMS_SEED_ID:
                        szData1 = "WMRM Seed ID for EMS-protected content";
                        break;

                    case KEY_TYPE_WMRM_SYNCCAST_AES_KEY:
                        szData1 = "AES Key to decrypt WMRM seed ids for SyncCast-protected content.";
                        break;

                    case KEY_TYPE_WIREDATA_PRIVATE_KEY:
                        szData1 = "Wiredata Private Key";
                        break;

                    case KEY_TYPE_WIREDATA_PUBLIC_KEY:
                        szData1 = "Wiredata Public Key";
                        break;

                    case KEY_TYPE_SECP_DB_PRIVATE_KEY:
                        szData1 = "Secp DB Private Key";
                        break;

                    case KEY_TYPE_SECP_DB_PUBLIC_KEY:
                        szData1 = "Secp DB Public Key";
                        break;

                    case KEY_TYPE_TOKEN_KEY_ENCRYPTION_KEY:
                        ulKeyLen = 16;
                        szData1 = "Token File Key Encryption Key";
                        break;

                    case KEY_TYPE_XAUTHDATA_SIGNING_KEY:
                        ulKeyLen = 64;
                        szData1 = "XAuthdata Signing Key";
                        break;

                    case KEY_TYPE_TESTONLY_XKEYMGR:
                        //used for testing purposes only
                        break;

//                     default:
//                         // invalid key type specified!!!
//                         PrintError("Invalid key type %u.\r\n", ulKeyType);
//                         goto Cleanup;
                    }

                    // file containing public key

                    szPublicKeyFile = argv[4];

                    //  Process any remaining args, these all come in pairs of command flag and param

                    lCurArg = 5;
                    while(lCurArg < argc)
                    {
                        //  did we get a command flag w/o the associated parameter?
                        if(argc - lCurArg == 1)
                        {
                            Usage();
                            goto Cleanup;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-f") == 0)
                        {
                            szKeyFile = argv[lCurArg + 1];
                            lCurArg += 2;
                            ulKeyLen = 0xFFFFFFFF;
                            continue;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-r") == 0)
                        {
                            szKeyFile = NULL;
                            if(!GetNumArg(argv[lCurArg + 1], ulKeyLen))
                            {
                                Usage();
                                goto Cleanup;
                            }

                            lCurArg += 2;
                            continue;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-d1") == 0)
                        {
                            szData1 = argv[lCurArg + 1];
                            lCurArg += 2;
                            continue;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-d2") == 0)
                        {
                            szData2 = argv[lCurArg + 1];
                            lCurArg += 2;
                            continue;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-s") == 0)
                        {
                            if(!GetNumArg(argv[lCurArg + 1], ulSiteID))
                            {
                                Usage();
                                goto Cleanup;
                            }

                            lCurArg += 2;
                            continue;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-l") == 0)
                        {
                            if(!GetNumArg(argv[lCurArg + 1], ulLifetime))
                            {
                                Usage();
                                goto Cleanup;
                            }

                            lCurArg += 2;
                            continue;
                        }

                        if(lstrcmpiA(argv[lCurArg], "-c") == 0)
                        {
                            szSGConfigFile = argv[lCurArg + 1];
                            lCurArg += 2;
                            continue;
                        }

                        Usage();
                        goto Cleanup;
                    }

                    //
                    //  format d2 param if necessary
                    //

                    if(lstrcmpA(szData2, "site%u") == 0)
                    {
                        if(ulSiteID == 0xFFFFFFFF)
                            szData2 = NULL;
                        else
                        {
                            wsprintfA(szSiteData2, szData2, ulSiteID);
                            szData2 = szSiteData2;
                        }
                    }

                    // do it !

                    AddFrequentlyUsedKey(ulKeyType,
                                         ulKeyVersion,
                                         szPublicKeyFile,
                                         szKeyFile,
                                         ulKeyLen,
                                         szData1,
                                         szData2,
                                         ulSiteID,
                                         ulLifetime,
                                         szSGConfigFile,
                                         FALSE              // fUpdate
                                         );
                }
            }
        }
        else if(lstrcmpiA(argv[1], "addwmdrmcert") == 0)
        {
            if(argc == 5)
            {
                LPSTR szMasterPubKeyFile = argv[2];
                LPSTR szWmdrmPrivKeyFile = argv[3];
                LPSTR szWmdrmCertFile    = argv[4];

                AddWmdrmCert(szMasterPubKeyFile,
                             szWmdrmPrivKeyFile,
                             szWmdrmCertFile);
            }
            else
            {
                Usage();
            }
        }
        else if (lstrcmpiA(argv[1], "addplayreadycert") == 0)
        {
            if (argc == 5)
            {
                LPSTR szMasterPubKeyFile = argv[2];
                LPSTR szPlayReadyXbox360ModelPrivKeyFile = argv[3];
                LPSTR szPlayRedyXbox360ModelCertFile = argv[4];

                AddPlayReadyCert(szMasterPubKeyFile,
                                 szPlayReadyXbox360ModelPrivKeyFile,
                                 szPlayRedyXbox360ModelCertFile);
            }
            else
            {
                Usage();
            }
        }
        else
            Usage();
        break;

    case 'c':
        if(lstrcmpiA(argv[1], "createmk") == 0)
        {
            if(argc != 5)
                Usage();
            else
            {
                ULONG ulKeyVer;

                if(!GetNumArg(argv[2], ulKeyVer))
                    Usage();
                else
                    CreateMasterKey(ulKeyVer, argv[3], argv[4]);
            }
        }
        else if(lstrcmpiA(argv[1], "createrand") == 0)
        {
            if(argc != 4)
                Usage();
            else
            {
                ULONG   ulNumRandBytes;

                if(!GetNumArg(argv[3], ulNumRandBytes))
                    Usage();
                else
                    CreateRandomKey(argv[2], ulNumRandBytes);
            }
        }
        else
            Usage();
        break;

    case 'd':
        //  printf("XKEYMGR DECRYPTBLOB mkver encryptedfile outfile\r\n");
        if (lstrcmpiA(argv[1], "decryptblob") == 0)
        {
            if (argc != 5)
            {
                Usage();
                break;
            }

            ULONG ulKeyVer = 0;
            char const * const szEncryptedFileName = argv[3];
            char const * const szOutfile = argv[4];

            if(!GetNumArg(argv[2], ulKeyVer))
            {
                Usage();
                break;
            }

            DecryptBlob(ulKeyVer, szEncryptedFileName, szOutfile);
        }
        else if (lstrcmpiA(argv[1], "dumpmk") == 0)
        {
            //  printf("XKEYMGR DUMPMK mkver \r\n");
            if(argc != 3)
            {
                Usage();
            }
            else
            {
                ULONG ulKeyVer;

                if(!GetNumArg(argv[2], ulKeyVer))
                {
                    Usage();
                }
                else
                {
                    DumpMasterKeyContainer(ulKeyVer);
                }
            }
        }
        else if (lstrcmpiA(argv[1], "dumpcontainer") == 0)
        {
            //  printf("XKEYMGR DUMPCONTAINER keycontainer \r\n");
            if(argc != 3)
            {
                Usage();
            }
            else
            {
                CComBSTR arg = argv[2];
                DumpKeyContainer(arg);
            }
        }
        else
        {
            Usage();
        }
        break;

    case 'e':
        //  printf("XKEYMGR ENCRYPTBLOB pubkeyfile file_to_encrypt outfile\r\n");
        if (lstrcmpiA(argv[1], "encryptblob") == 0)
        {
            if (argc != 5)
            {
                Usage();
                break;
            }

            char const * const szPublicKeyFile = argv[2];
            char const * const szFileToEncrypt = argv[3];
            char const * const szOutFile = argv[4];

            EncryptBlob(szPublicKeyFile, szFileToEncrypt, szOutFile);
        }
        else
        {
            Usage();
        }
        break;


    case 'm':
        if(lstrcmpiA(argv[1], "migratemk") == 0)
        {
            if(argc != 4)
                Usage();
            else
            {
                ULONG ulOldKeyVer;

                if(!GetNumArg(argv[2], ulOldKeyVer))
                    Usage();
                else
                    MigrateMasterKey(ulOldKeyVer, argv[3]);
            }
        }
        else if(lstrcmpiA(argv[1], "migratekek") == 0)
        {
            if(argc != 5 && argc != 6)
                Usage();
            else
            {
                ULONG ulOldKeyVer;
                ULONG ulNewKeyVer;
                ULONG ulMasterKeyVer;

                if(!GetNumArg(argv[2], ulOldKeyVer) ||
                   !GetNumArg(argv[3], ulNewKeyVer) ||
                   !GetNumArg(argv[4], ulMasterKeyVer))
                    Usage();
                else
                    MigrateKeyEncryptionKey(ulOldKeyVer, ulNewKeyVer, ulMasterKeyVer, (argc == 6 ? argv[5] : NULL));
            }
        }
        else  if(lstrcmpiA(argv[1], "migrateblob") == 0)
        {
            if(argc != 6)
            {
                Usage();
            }
            else
            {
                ULONG ulOldKeyVer;
                if(!GetNumArg(argv[2], ulOldKeyVer))
                {
                    Usage();
                }
                else
                {
                    MigrateBlob(ulOldKeyVer, argv[3], argv[4], argv[5]);
                }
            }
        }
        else
        {
            Usage();
        }
        break;

    case 'p':
        if(lstrcmpiA(argv[1], "protect") == 0)
        {
            if(argc != 4)
                Usage();
            else
            {
                Protect(argv[2], argv[3]);
            }
        }
        else
            Usage();

        break;

    case 'r':
        if(lstrcmpiA(argv[1], "removemk") == 0)
        {
            if(argc != 3)
                Usage();
            else
            {
                ULONG ulKeyVer;

                if(!GetNumArg(argv[2], ulKeyVer))
                    Usage();
                else
                    RemoveMasterKey(ulKeyVer);
            }
        }
        else if(lstrcmpiA(argv[1], "removefreq") == 0)
        {
            if(argc != 7)
                Usage();
            else
            {
                ULONG ulKeyType;
                ULONG ulKeyVersion;
                ULONG ulMasterKeyVersion;

                if(!GetNumArg(argv[2], ulKeyType) ||
                   !GetNumArg(argv[3], ulKeyVersion) ||
                   !GetNumArg(argv[6], ulMasterKeyVersion))
                    Usage();
                else
                    RemoveFrequentlyUsedKey(ulKeyType, ulKeyVersion, argv[4], argv[5], ulMasterKeyVersion);
            }
        }
        else if(lstrcmpiA(argv[1], "removecontainer") == 0)
        {
            if(argc != 3)
                Usage();
            else
            {
                RemoveKey(argv[2]);
            }
        }
        else
            Usage();
        break;

    case 's':
        if(lstrcmpiA(argv[1], "storemk") == 0)
        {
            if(argc != 3)
                Usage();
            else
                StoreMasterKey(argv[2]);
        }
        else
            Usage();
        break;

    case 'v':
        if(lstrcmpiA(argv[1], "validate") == 0)
        {
            if(argc != 3)
            {
                Usage();
            }
            else
            {
                ValidatePublicKeyFromFile(argv[2]);
            }
        }
        else
            Usage();
        break;

    default:
        Usage();
        break;
    }

Cleanup:

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xkeymgrtest_none_12.4.56.0_none_f9912f30d339ed4e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkeymgrtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.manifest
XP_MANIFEST_PATH=manifests\msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.cat
XP_CATALOG_PATH=manifests\msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.cat
XP_PAYLOAD_PATH=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkeymgrtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\Freq.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;

using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data;
using System.Net;
using System;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

namespace XKeyMgrTest
{
    //Tests
    [TestGroup, Description("Tests for the freq related commands."), TestCasePriority(1), TestFrequency("Regression")]
    public class Freq: TestNode
    {
        public static void VerifyOutputDoesNotContainHelp(string output)
        {
            string lower=output.ToLower();
            if (lower.Contains("xbox service master key manager"))
            {
                throw new UnexpectedTestResultException("Output unexpectedly contains help message.");
            }
        }

        public static void CheckOutputForErrors(string output)
        {
            string lower=output.ToLower();
            if (lower.Contains("invalid key"))
            {
                throw new UnexpectedTestResultException("Output contains invalid key error");
            }

            if (lower.Contains("error ="))
            {
                throw new UnexpectedTestResultException("Output contains error");
            }

            if (lower.Contains("exception"))
            {
                throw new UnexpectedTestResultException("Output contains an exception.");
            }

            if (lower.Contains("failed to"))
            {
                throw new UnexpectedTestResultException("Output contains a failure.");
            }
        }

        [TestCase, Description("A very minimalistic \"Add a key then remove the key\" test")]
        public class AddRemove: TestNode
        {
            public override void Run()
            {
                // Add key #999 version 888.
                Global.RO.Info("Adding a key...");
                string output=Util.RunXKeyMgr("addfreq 999 888 SuitesData\\MasterKeyV1.pub -d1 \"XKeyMgrTest999_d1\" -d2 \"XKeyMgrTest999_d2\" -r 16"); 
                CheckOutputForErrors(output);
                VerifyOutputDoesNotContainHelp(output);

                //
                // Check that the key made it into NPDB
                //
                Global.RO.Info("Checking NPDB...");
                Npdb npdb = new Npdb();
                SqlDataReader reader;
                npdb.ConnectToServer();
                string query = "select vc_service_data1, vc_service_data2, i_key_version from t_service_keys where i_key_type=999";
                
                npdb.ReadData(query, out reader);

                if (!reader.Read())
                {
                        throw new UnexpectedTestResultException("NPDB had no results.");
                }

                string vcd1 = (string)reader[0];
                string vcd2 = (string)reader[1];
                int keyver = (int)reader[2];

                ValueCheck.Test("vc_service_data1", "XKeyMgrTest999_d1", vcd1);
                ValueCheck.Test("vc_service_data",  "XKeyMgrTest999_d2", vcd2);
                ValueCheck.Test("i_key_version", 888, keyver);
                reader.Close();
                
                //
                // Remove that key
                //
                Global.RO.Info("Removing the key...");
                output=Util.RunXKeyMgr("removefreq 999 888 \"XKeyMgrTest999_d1\" \"XKeyMgrTest999_d2\" 1");
                CheckOutputForErrors(output);
                VerifyOutputDoesNotContainHelp(output);

                //
                // Check that the key was removed from NPDB
                //
                Global.RO.Info("Checking NPDB...");
                query = "select i_key_version from t_service_keys where i_key_type=999";

                npdb.ReadData(query, out reader);

                if (reader.Read())
                {
                    throw new UnexpectedTestResultException("NPDB had results but shouldn't.");
                }

                reader.Close();
            }

            //cleanup up the key manually to be on the safe side (in the event of some run failure)
            public override void PreRun()
            {
                Global.RO.Info("Cleaning out test keys from t_service_keys in NPDB...");
                Npdb npdb = new Npdb();
                npdb.ConnectToServer();
                string query = "delete from t_service_keys where i_key_type=999";

                npdb.IssueCommand(query);
            }

            public override void PostRun()
            {
                PreRun();
            }
        }
    }; //class Freq
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xkeymgrtest_none_12.4.56.0_none_f9912f30d339ed4e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkeymgrtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.manifest
XP_MANIFEST_PATH=manifests\msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.cat
XP_CATALOG_PATH=manifests\msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806.cat
XP_PAYLOAD_PATH=msil_xkeymgrtest_no-public-key_12.4.56.0_x-ww_0d39b806
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkeymgrtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\FilterRows.cs ===
using System;
using System.IO;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// Summary description for FilterRows.
	/// </summary>
	public class FilterRows : ParseLog
	{
		private Filters m_ftrType;

		public FilterRows( string szFileMask, string szOutFile, Filters ftrType) : base( szFileMask, szOutFile)
		{
			m_ftrType = ftrType;
		}

		public override bool Run()
		{
			return Run(false);
		}

		public override bool Run( bool fIgnore)
		{
			Console.WriteLine("Filtering logs, stripping rows.");
			bool	fSucc = true;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);
			
			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			
			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false);
			//sw.AutoFlush = true;
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( null != ( szLineOut = FilterLine( szLineIn, m_ftrType) ) ) 
					{
						sw.WriteLine( szLineOut);
						lLinesWrite++;
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

		private string FilterLine( string szLine, Filters ftrType)
		{
			string[] rgszFields = szLine.Split( m_rgchSeparator);
			bool fMatch = false;

			switch ( ftrType )
			{
				case Filters.ftrFeedback:
					for (int i = 0; i < rgszFields.Length && !fMatch; i++)
					{
						if ( 0 == rgszFields[i].CompareTo( "1481375749") )
						{
							fMatch = true;
						}
					}
					return (!fMatch)? szLine : null;
				case Filters.ftrMatch:
					return ( rgszFields.Length > 2 && 
							( 0 == rgszFields[2].CompareTo( "SESSIONINSERT") || 0 == rgszFields[2].CompareTo( "SESSIONDELETE") ) )?
						szLine : null;
				case Filters.ftrPres:
					return ( rgszFields.Length > 2 && 0 != rgszFields[2].CompareTo( "STATE") )? szLine : null;
				case Filters.ftrSPS:
					return ( rgszFields.Length > 2 && 0 == rgszFields[2].CompareTo( "CreateAccount") )? szLine : null;
				case Filters.ftrXPNF:
					if ( rgszFields.Length >= 7 && 0 == rgszFields[2].CompareTo( "FDALIVE") )
					{
						string szOut = rgszFields[0] + "|" + rgszFields[4] + "|" + rgszFields[6] + "|" + rgszFields[7];
						return szOut;
					}
					else
					{
						return null;
					}
				default:
					return szLine;
			}

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xkeymgr\Test\Util.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using System.IO;
using System.Text;

using xonline.common.config;

[assembly: RootNode(typeof(XKeyMgrTest.XKeyMgrTest))]

namespace XKeyMgrTest
{
    [Owner("LukeL"), TestFrequency("Daily")]
    public class XKeyMgrTest: TestNode
    {
        /*
        Note: to manually register commonconfig, run this:
        C:\WINNT\Microsoft.NET\Framework\v2.0.50727\regasm /codebase CommonConfig.dll
        */

        public override void PreRun()
        {
            //register commonconfig
            Global.RO.Debug("Registering XblConfig.dll...");
            System.Runtime.InteropServices.RegistrationServices managedReg=new System.Runtime.InteropServices.RegistrationServices();
            System.Reflection.Assembly commonconfigAssembly=System.Reflection.Assembly.LoadFile(System.Environment.CurrentDirectory+"\\XblConfig.dll");
            if (!managedReg.RegisterAssembly(commonconfigAssembly, System.Runtime.InteropServices.AssemblyRegistrationFlags.SetCodeBase))
            {
                throw new System.Exception("XblConfig.dll regasm register failed.");
            }

            //dunno if we need this:
            /*Global.RO.Debug("Registering CryptoWrapper.dll...");
            ProcessWrapper pr=new ProcessWrapper("regsvr32","regsvr32.exe");
            pr.ExecutionTimeout=(int)120;
            pr.EchoOutput=true;
            pr.Run("/s CryptoWrapper.dll");*/
        }

        public override void PostRun()
        {
            //unregister commonconfig
            Global.RO.Debug("Unregistering XblConfig.dll...");
            System.Runtime.InteropServices.RegistrationServices managedReg=new System.Runtime.InteropServices.RegistrationServices();
            System.Reflection.Assembly commonconfigAssembly=System.Reflection.Assembly.LoadFile(System.Environment.CurrentDirectory+"\\XblConfig.dll");
            managedReg.UnregisterAssembly(commonconfigAssembly);

            //dunno if we need this:
            /*Global.RO.Debug("Unregistering CryptoWrapper.dll...");
            ProcessWrapper pr=new ProcessWrapper("regsvr32","regsvr32.exe");
            pr.ExecutionTimeout=(int)120;
            pr.EchoOutput=true;
            pr.Run("/s /u CryptoWrapper.dll");*/
        }
    };
    
    // --

    public static class Util
    {
        //runs xblcfg tool with specific arguments, and returns the commandline output
        public static string RunXKeyMgr(string args)
        {
            return RunXKeyMgr(args, 300);
        }
        public static string RunXKeyMgr(string args, uint timeoutInS)
        {
            //run it, capturing the output
            ProcessWrapper pr=new ProcessWrapper("xkeymgr","xkeymgr.exe");
            pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
            pr.ExecutionTimeout=(int)timeoutInS;
            pr.EchoOutput=true;
            pr.Run(args);

            //check for errors. xkeymgr no longer writes to stderr, errors go to stdout 
            //with an "ERROR: " prefix.
            if (pr.Output.Contains("ERROR:"))
            {
                if (pr.Output.Contains("Error = 0x80040154")) //commonconfig.dll isn't registered... give them instructions.
                {
                    Global.RO.Warn("This error probably means that some .dll needed by xkeymgr isn't registered.  This should be done automatically, but you might try: C:\\WINNT\\Microsoft.NET\\Framework\\v2.0.50727\\regasm /codebase CommonConfig.dll");
                }

                throw new System.Exception("xkeymgr failed with output: " + pr.Output);
            }

            //
            return pr.Output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseContent.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// ParseContent will open all log files that satisfy given criteria, parse them and save bcp file.
	/// </summary>
	
	enum ContentType
	{
		bContentRef,
		bEnumerate
	}
	/*
	public class ContentRow
	{
		public string m_sDTStart;
		public long m_lMachineID;
		public long m_lUserPUID0;
		public long m_lUserPUID1;
		public long m_lUserPUID2;
		public long m_lUserPUID3;
		public int  m_iTitleID;
		public long m_lOfferingID;
		
		public ContentRow( string sDT, long lMID, long lU0, long lU1, long lU2, long lU3, int iTID, long lOID)
		{
			m_sDTStart   = sDT;
			m_lMachineID = lMID;
			m_lUserPUID0 = lU0;
			m_lUserPUID1 = lU1;
			m_lUserPUID2 = lU2;
			m_lUserPUID3 = lU3;
			m_iTitleID   = iTID;
			m_lOfferingID= lOID;
		}
	}
	*/

	public class ParseContent : ParseLog
	{
		// member-vars
		// input
		private Regex			m_reContent;
		private Regex			m_reEnumerate;
		private const string	m_szServerMask = "(?:xbos|xuac)(\\d{3})";
		// 	2002/11/01 12:56:05.127|904|CONTENTREF|123456|123456|123456|123456|123456|12456|11233456
		//	Time Stamp|LineType|LineDesc|lMachineID|lUserID0|lUserID1|lUserID2|lUserID3|iTitleID|lOfferingID
		private const string	m_szContentMask = 
			"^(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|\\d*\\|CONTENTREF\\|" + 
		//			$1		$2		$3			$4
		//			year	month	day			hour	min		sec		ms
			"(\\-?\\d{1,20})\\|(\\-?\\d{1,20})\\|(\\-?\\d{1,20})\\|(\\-?\\d{1,20})\\|(\\-?\\d{1,20})\\|(\\-?\\d{1,10})\\|(\\-?\\d{1,20})$";
		//		$5					$6				$7				$8					$9				$10				$11
		//		machineID			User0			User1			User2				User3			title			OfferID
		private const string	m_szEnumerateMask =
			"^(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|\\d*\\|ENUMERATE\\|" + 
		//		$1			$2			$3		$4
		//		year		month		day		time
			"(\\-?\\d{1,20})\\|(\\-?\\d{1,10})\\|(\\-?\\d{1,10})\\|(\\-?\\d{1,10})\\|(\\-?\\d{1,10})\\|(\\-?\\d{1,10})\\|" +
		//		$5				$6					$7				$8					$9					$10
		//		biUserPUID		iTitleID			iOfferingType	iBitFilter			iRating				iDescIndex
			"(\\-?\\d{1,10})\\|(\\-?\\d{1,10})\\|([^\\|]{1,25})\\|([^\\|]{1,25})\\|([^\\|]{1,25})\\|(\\-?\\d{1,10})\\|" + 
		//		$11					$12				$13					$14				$15				$16
		//		iStartIndex			iMaxResults		dtClientLastChanged	dtSrvLastChng	dtNewLastChng	siMoreRecords
			"(\\-?\\d{1,10})\\|(\\-?\\d{1,10})$";
		//			$17				$18
		//			siNumRecords	iNumBytes
		// TimeStamp|LineType|LineDesc|UserPUID|TitleID|OfferingType|BitFilter|Rating|DescriptionIndex|StartIndex|MaxResults|ClientLastChangeDate|ServerLastChangeDate|NewLastChangeDate|MoreRecords|NumRecords|NumBytes

		

		// member-func
		public ParseContent( string szFileMask, string szOutFile) : base ( szFileMask, szOutFile)
		{
			m_reContent	 = new Regex( m_szContentMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_reEnumerate= new Regex( m_szEnumerateMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
		}

		public override bool Run( bool fUseRegex)
		{
			Console.WriteLine("ParseContent is " + (fUseRegex? "" : "not ") + "using regular expressions.");
			bool	fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);
			
			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;
			Match		 mtch = null;
			long		 lLinesRead  = 0;
			long		 lLinesWrite1= 0;
			long		 lLinesWrite2= 0;
			Regex		 reServID = new Regex( m_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;
			int			 iLineType = 0;
			
			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			string szOutFName = m_szOutFile.Substring( 0, m_szOutFile.LastIndexOf( ".") );
			string szOutFExt  = m_szOutFile.Substring( m_szOutFile.LastIndexOf( ".") );
			StreamWriter sw1 = new StreamWriter( szOutFName + "Cont" + szOutFExt, false);
			StreamWriter sw2 = new StreamWriter( szOutFName + "Enum" + szOutFExt, false);
			//sw.AutoFlush = true;
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id
				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( !fUseRegex )
					{
						if ( null != (szLineOut = ParseLine( szLineIn, iServID, ref iLineType) ) )
						{
							if ( (int) ContentType.bContentRef == iLineType )
							{
								sw1.WriteLine( szLineOut);
								lLinesWrite1++;
							}
							else if ( (int) ContentType.bEnumerate == iLineType )
							{
								// not in use
								//sw2.WriteLine( szLineOut);
								lLinesWrite2++;
							}
						}
					}
					else
					{
						if ( null != ( szLineOut = ParseLine( szLineIn, ref iLineType) ) )
						{
							// write line
							if ( (int) ContentType.bContentRef == iLineType )
							{
								sw1.WriteLine( szLineOut + "," + iServID.ToString("d") );
								lLinesWrite1++;
							}
							else if ( (int) ContentType.bEnumerate == iLineType )
							{
								// not in use
								//sw2.WriteLine( szLineOut + "," + iServID.ToString("d") );
								lLinesWrite2++;
							}
						}
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw1.Flush();
			sw1.Close();
			sw1 = null;
			sw2.Flush();
			sw2.Close();
			sw2 = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} CONTENTREF line(s)\tWrote {2} ENUMERATE line(2)", lLinesRead, lLinesWrite1, lLinesWrite2);
			
			return fSucc;
		}

		private string ParseLine( string szLine, ref int iType)
		{
			// CONTENT
			//	$1		$2		$3		$4				$5			$6		$7		$8		$9		$10		$11
			//	year	month	day		hour:min:sec.ms	machineID	User0	User1	User2	User3	title	OfferID
			// ENUMERATE
			// TimeStamp|LineType|LineDesc|UserPUID|TitleID|OfferingType|BitFilter|Rating|DescriptionIndex|StartIndex|MaxResults|ClientLastChangeDate|ServerLastChangeDate|NewLastChangeDate|MoreRecords|NumRecords|NumBytes
			//	$1-$4						$5			$6		$7			$8		$10			$11			$12			$13					$14					$15				$16				$17			$18		$19
			string szRet = null;
			
			Match mc = m_reContent.Match( szLine);
			Match me = null;
			
			if ( mc.Success )
			{
				// get dtWhen
				string sDTWhen = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " + mc.Groups[4].Value;

				szRet = "'" + sDTWhen + "'," + mc.Groups[5].Value + "," + mc.Groups[6].Value + "," + mc.Groups[7].Value + "," +
					mc.Groups[8].Value + "," + mc.Groups[9].Value + "," + mc.Groups[10].Value + "," + mc.Groups[11].Value;
				iType = (int) ContentType.bContentRef;
			}
			else if ( ( me = m_reEnumerate.Match( szLine) ).Success )
			{
				string sDTWhen = me.Groups[2].Value + "/" + me.Groups[3].Value + "/" + me.Groups[1].Value + " " + me.Groups[4].Value;

				szRet = sDTWhen;
				for (int i = 5; i < 19; i++)
				{
					if ( i == 15 && 0 == me.Groups[i].Value.CompareTo( "1/1/0001 12:00:00 AM") )
					{
						szRet += ",1/1/2000";
					}
					else
					{
						szRet += "," + me.Groups[i].Value;
					}
				}
				iType = (int) ContentType.bEnumerate;
			}


			return szRet;
		}

		private string ParseLine( string szLine, int iServID, ref int iType)
		{
			// CONTENTREF
			//Time Stamp|LineType|LineDesc|lMachineID|lUserID0|lUserID1|lUserID2|lUserID3|iTitleID|lOfferingID
			// 0			1		2		3			4		5			6		7		8		9
			// ENUMERATE
			// TimeStamp|LineType|LineDesc|UserPUID|TitleID|OfferingType|BitFilter|Rating|DescriptionIndex|StartIndex|MaxResults|ClientLastChangeDate|ServerLastChangeDate|NewLastChangeDate|MoreRecords|NumRecords|NumBytes
			//	0			1		2		3			4		5			6		7		8				10			11			12					13					14					15			16		17
			string[] szFields = szLine.Split( m_rgchSeparator, 17);
			string szRet = null;

			if ( szFields.Length < 10 )
			{
				// bad row
			}
			else if ( 0 == szFields[2].ToUpper().CompareTo( "CONTENTREF") )
			{
				string szYear = szFields[0].Substring( 0, 4);
				string szMonth= szFields[0].Substring( 5, 2);
				string szDay  = szFields[0].Substring( 8, 2);
				string szTime = szFields[0].Substring( 11);
				
				szRet = szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				for (int i = 3; i < szFields.Length; i++)
				{
					szRet += "," + szFields[i];
				}
				szRet += "," + iServID.ToString("d");
				iType = (int) ContentType.bContentRef;
			}
			else if ( 0 == szFields[2].ToUpper().CompareTo( "ENUMERATE") )
			{
				string szYear = szFields[0].Substring( 0, 4);
				string szMonth= szFields[0].Substring( 5, 2);
				string szDay  = szFields[0].Substring( 8, 2);
				string szTime = szFields[0].Substring( 11);
				
				szRet = szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				if ( 0 == szFields[13].CompareTo( "1/1/0001 12:00:00 AM") )
				{
	                szFields[13] = "1/1/2000";
		        }
				for (int i = 3; i < szFields.Length; i++)
				{
					szRet += "," + szFields[i];
				}
				szRet += "," + iServID.ToString("d");
				iType = (int) ContentType.bEnumerate;
			}

			return szRet;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseCust.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// ParseCust - script that parses customer relations logs.  Currently only processes MAC & RPW rows.
	/// </summary>
	public class ParseCust : ParseLog
	{
		// member-vars
		// input
		private Regex			m_reMAC;
		private Regex			m_reRPW;
		private const string	m_szServerMask = "cust(\\d{3})";
		private const string	m_szMACMask =
			"(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|MAC\\|" +
			//	year	month		day			time
			"([\\da-fA-F]{1,16})\\|([a-zA-Z]{1,5})\\|([a-zA-Z]{1,5})\\|([a-zA-Z]{1,5})\\|([a-zA-Z]{1,5})\\|" + 
			// puid					isLockedOut		isVoiceBanned		isNickBanned	mustChangeName
			"([^\\]*)\\|([\\da-fA-F]{1,16})";
			//	errorString		hr
		private const string	m_szRPWMask =
			"(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|RPW\\|" +
			//	year	month		day			time
			"([\\da-fA-F]{1,16})\\|([^\\]*)\\|([\\da-fA-F]{1,16})";
			//	puid				errorString		hr

		// member-func
		public ParseCust( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_reMAC = new Regex( m_szMACMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_reRPW = new Regex( m_szRPWMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
		}

		public override bool Run( bool fUseRegex)
		{
			Console.WriteLine( "ParseCust is " + (fUseRegex? "" : "not ") + "using regular expressions.");
			bool fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);

			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;

			Match		 mtch = null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			Regex		 reServID = new Regex( m_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;

			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false);
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id

				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( fUseRegex)
					{
						if ( null != ( szLineOut = ParseLine( szLineIn) ) )
						{
							// write line
							sw.Write( szLineOut + "\t" + iServID.ToString("d") + "\r\n" );
							lLinesWrite++;
						}
					}
					else
					{
						if ( null != ( szLineOut = ParseLine( szLineIn, iServID) ) )
						{
							sw.Write( szLineOut + "\r\n");
							lLinesWrite++;
						}
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

		private string ParseLine( string szLine)
		{
			// use regex
			// MAC|<puid>|<isLockedOut>|<isVoiceBanned>|<isNicknameBanned>|<mustChangeXName>|<errorString>|<hr>
			//2003/09/04 14:18:34.441|MAC|93A83A83A8D57|False|False|False|True|Success|0
			Match	mc = m_reMAC.Match( szLine);
			string	sz = null;

			if ( mc.Success )
			{
				// timestamp
				sz = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
					mc.Groups[4].Value;
				// puid
				sz += "," + Convert.ToInt64( mc.Groups[5].Value, 16).ToString( "d");
				sz += ",0";	// api
				// flags
				for (int i = 6; i < 10; i++)
				{
					sz += ",";
					if ( mc.Groups[i].Value == "True" )
					{
						sz += "1";
					}
					else if (mc.Groups[i].Value == "False" )
					{
						sz += "0";
					}
				}
			}
			else
			{
				// RPW|<puid>|<errorString>|<hr>
				mc = m_reRPW.Match( szLine);
				if ( mc.Success )
				{
					// timestamp
					sz = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
						mc.Groups[4].Value;
					// puid
					sz += "," + Convert.ToInt64( mc.Groups[5].Value, 16).ToString( "d");
					sz += ",1,0,0,0,0";	// api
				}
			}

			return sz;
		}

		private string ParseLine( string szLine, int iServID)
		{
			// don't use regex
			string[] rgszFields = szLine.Split( m_rgchSeparator);
			string szOut = null;

			if ( 1 == rgszFields.Length )
			{
				// do nothing
			}
			else if ( rgszFields[1] == "MAC" && rgszFields[8] == "0" )
				// filter out error entries
			{
				// MAC|<puid>|<isLockedOut>|<isVoiceBanned>|<isNicknameBanned>|<mustChangeXName>|<errorString>|<hr>
				//2003/09/04 14:18:34.441|MAC|93A83A83A8D57|False|False|False|True|Success|0
				// 0						1	2			3		4	5		6	7		8
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMonth= rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);
				string szTime = rgszFields[0].Substring( 11);
				
				// timestamp
				szOut = szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				// puid
				szOut += "," + Convert.ToInt64( rgszFields[2], 16).ToString( "d");
				// api
				szOut += ",0";	
				// flags
				for (int i = 3; i < 7; i++)
				{
					szOut += ",";
					if ( rgszFields[i] == "True" )
					{
						szOut += "1";
					}
					else if( rgszFields[i] == "False" )
					{
						szOut += "0";
					}
				}
				szOut += "," + iServID.ToString( "d");
			}
			else if ( rgszFields[1] == "RPW" && rgszFields[4] == "0" )
				// filter out error entries
			{
				// timestamp|RPW|<puid>|<errorString>|<hr>
				//		0	 1		 2		3			4
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMonth= rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);
				string szTime = rgszFields[0].Substring( 11);
				
				// timestamp
				szOut = szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				// puid
				szOut += "," + Convert.ToInt64( rgszFields[2], 16).ToString( "d");
				// api
				szOut += ",1,0,0,0,0";
				szOut += "," + iServID.ToString( "d");
			}
			return szOut;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseSTFD.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// ParseSTFD - parses storage logs.
	/// </summary>
	public class ParseSTFD : ParseLog
	{
		// member-vars
		private Regex			m_reSTFD;
		private const string	m_szServerMask = "stfd(\\d{3})";
		private Char[]			m_rgchSplit = null;
		private const string	m_szSTFDMask = 
			"(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|(WRF|RDF)\\|([\\da-fA-F]{1,16})\\|" + 
		//	year		month		day			time							Type			HResult
			"([\\da-fA-F]{1,16})\\|([\\da-fA-F]{1,16})\\|([\\da-fA-F]{1,16})\\|(\\d{1,4})\\|([\\da-fA-F]{1,16})\\|" + 
		//	TitleID						titleVersion		User PUID			User Country	Machine PUID
			"(\\d{0,32})\\|(\\d{1,16})\\|(\\d{0,32})\\|([\\da-fA-F]{1,16})\\|(\\d{1,32})\\|([^$]*)";
		//	Nonce			Domain			KeyType			KeyValue		BlobSize		Path
		/*
        #                          HRESULT   TITLEVER               USER COUNTRY        NONCE   KEY TYPE
        #                             v         v                       v                   v   v
        # 2003/07/24 18:00:00.039|WRF|0|115C|62F23A89|C5E475138BC8E800|197|C5E475138BC8E800|0|0|1|A4DF293149BE5000|15360|/cf926e83-b1c6-46b4-8ef8-0b2174b89dad
        # 2003/07/24 18:00:00.039|RDF|0|115C|62F23A89|C5E475138BC8E800|197|C5E475138BC8E800|0|0|1|A4DF293149BE5000|15360|/cf926e83-b1c6-46b4-8ef8-0b2174b89dad
        # YYYY/MM/DD HH:MM:SS.ms_         ^              USER PUID           MACHINE PUID     ^      KEY VALUE       ^                PATH
        #                               TITLEID                                             DOMAIN               BLOB SIZE
		*/
		
		// member-func
		public ParseSTFD( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_reSTFD = new Regex( m_szSTFDMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_rgchSplit = new Char[] {'/'};
		}

	
		public override bool Run( bool fUseRegex)
		{
			Console.WriteLine( "ParseSTFD is " + (fUseRegex? "" : "not ") + "using regular expressions.");
			bool fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);

			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;

			Match		 mtch = null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			Regex		 reServID = new Regex( m_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;

			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false);
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id

				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( fUseRegex)
					{
						if ( null != ( szLineOut = ParseLine( szLineIn) ) )
						{
							// write line
							sw.Write( szLineOut + "\t" + iServID.ToString("d") + "\r\n" );
							lLinesWrite++;
						}
					}
					else
					{
						if ( null != ( szLineOut = ParseLine( szLineIn, iServID) ) )
						{
							sw.Write( szLineOut + "\r\n");
							lLinesWrite++;
						}
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

	
		private string ParseLine( string szLine)
		{
			// use regex
			/* in																				Domain
										HResult		TitleVer			User Country		Nonce  KeyType
				timestamp			 type V TitleID V		User PUID		V	Machine PUID	V V V	KeyValue		BlobSize	Path
			# 2003/07/24 18:00:00.039|WRF|0|115C|62F23A89|C5E475138BC8E800|197|C5E475138BC8E800|0|0|1|A4DF293149BE5000|15360|/cf926e83-b1c6-46b4-8ef8-0b2174b89dad
			# 2003/07/24 18:00:00.039|RDF|0|115C|62F23A89|C5E475138BC8E800|197|C5E475138BC8E800|0|0|1|A4DF293149BE5000|15360|/cf926e83-b1c6-46b4-8ef8-0b2174b89dad
			# 1		2 3		4			5 6	7		8		9				10	11			   12 13 14	15				16		17 
			   out:
			   $idtWhen, $opcode, $titleid, tostring64($upuid), $size, $servnum
			*/

			Match	mc = m_reSTFD.Match( szLine);
			string	sz = null;

			if ( mc.Success )
			{
				// timestamp
				sz = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
					mc.Groups[4].Value;
				// opcode
				sz += "," + mc.Groups[5].Value;
				// titleID
				sz += "," + Convert.ToInt32( mc.Groups[7].Value, 16).ToString( "d");
				// userIP
				sz += "," + Convert.ToInt64( mc.Groups[9].Value, 16).ToString( "d");
				// size
				sz += "," + mc.Groups[16].Value;
			}
			return sz;
		}


		private string ParseLine( string szLine, int iServID)
		{
			/* in																				Domain
										HResult		TitleVer			User Country		Nonce  KeyType
				timestamp			 type V TitleID V		User PUID		V	Machine PUID	V V V	KeyValue		BlobSize	Path
			# 2003/07/24 18:00:00.039|WRF|0|115C|62F23A89|C5E475138BC8E800|197|C5E475138BC8E800|0|0|1|A4DF293149BE5000|15360|/cf926e83-b1c6-46b4-8ef8-0b2174b89dad
			# 2003/07/24 18:00:00.039|RDF|0|115C|62F23A89|C5E475138BC8E800|197|C5E475138BC8E800|0|0|1|A4DF293149BE5000|15360|/cf926e83-b1c6-46b4-8ef8-0b2174b89dad
			#			0				1 2	3		4		5				6		7			8 9 10	11				12		13
			   out:
			   $idtWhen, $opcode, $titleid, tostring64($upuid), $size, $servnum
			*/
			string sz = null;
			string[] rgszFields = szLine.Split( m_rgchSeparator);

			if ( rgszFields.Length == 14 && (rgszFields[1] == "WRF" || rgszFields[1] == "RDF") )
			{
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMon  = rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);

				// timestamp
				sz = szMon + "/" + szDay + "/" + szYear + rgszFields[0].Substring( 10);
				// opcode
				sz += "," + rgszFields[1];
				// titleID
				sz += "," + Convert.ToInt32( rgszFields[3], 16).ToString( "d");
				// user PUID
				sz += "," + Convert.ToInt64( rgszFields[5], 16).ToString( "d");
				// size
				sz += "," + rgszFields[12];
				// servID
				sz += "," + iServID.ToString( "d");
			}
			return sz;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseFeedBack.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// Summary description for ParseFeedBack.
	/// </summary>
	public class ParseFeedBack : ParseLog
	{
		private Regex			m_reFeedBack;
		private const string	c_szServerMask = "^fdbk(\\d{3})";
		// TimeStamp|LineType|LineDesc|SendPUID|TargetPUID|TitleID|FeedbackType|Nickname(optional)
		//2002/11/01 01:10:57.733|801|FEEDBACK|2697468526810295|2697468526810295|-1238533|5|nonickname
		private const string	c_szLineMask =
			"^(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|\\d*\\|FEEDBACK\\|" +
		//		$1			$2			$3		$4
		//		year		month		day		time
			"(\\-?\\d{1,20})\\|(\\-?\\d{1,20})\\|(\\-?\\d{1,10})\\|(\\-?\\d{3})\\|(.*)$";
		//		$5					$6				$7				$8				$9
		//		SendPUID			TargetPUID		iTitleID		FeedbackType	Nickname
		// bcp_line = "when\t$sender\t$target\t$titleid\t$feedbacktype\t$feedbacktext\t$servnum\r\n";

		public ParseFeedBack( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_reFeedBack = new Regex( c_szLineMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
		}

		public override bool Run()
		{
			return Run(false);
		}

		public override bool Run( bool fUseRegex)
		{
			Console.WriteLine("ParseFeedback is " + (fUseRegex? "" : "not ") + "using regular expressions.");
			bool	fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);
			
			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;
			Match		 mtch = null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			Regex		 reServID = new Regex( c_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;
			
			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false, System.Text.Encoding.Unicode);
			//sw.AutoFlush = true;
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id
				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( fUseRegex)
					{
						if ( null != ( szLineOut = ParseLine( szLineIn) ) )
						{
							// write line
							sw.Write( szLineOut + "\t" + iServID.ToString("d") + "\r\n" );
							lLinesWrite++;
						}
					}
					else
					{
						if ( null != ( szLineOut = ParseLine( szLineIn, iServID) ) )
						{
							sw.Write( szLineOut + "\r\n");
							lLinesWrite++;
						}
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

		private string ParseLine( string szLine)
		{
			//		$1		$2		$3		$4		$5			$6			$7			$8				$9
			//		year	month	day		time	SendPUID	TargetPUID	iTitleID	FeedbackType	Nickname
			//		bcp_line = "$dt_when\t$sender\t$target\t$titleid\t$feedbacktype\t$feedbacktext\t$servnum\r\n";

			string szOut = null;
			
			Match mc = this.m_reFeedBack.Match( szLine);
			
			if ( mc.Success )
			{
				// get dtEnd
				szOut = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
					mc.Groups[4].Value;
				
				for (int i = 5; i <= mc.Groups.Count; i++)
				{
					szOut += "\t" + mc.Groups[i].Value;
				}
			}

			return szOut;
		}

		private string ParseLine( string szLine, int iServID)
		{
			string szRet = null;
			string[] rgszFields = szLine.Split( m_rgchSeparator, 8);
			//	year/month/day	time|#|FEEDBACK|SendPUID|TargetPUID|Title|FBType|FeedbackText
			//	0					 1		2		3		4		5		6	 7

			if ( rgszFields.Length == 8 && 0 == rgszFields[2].ToUpper().CompareTo( "FEEDBACK") )
			{
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMonth= rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);
				string szTime = rgszFields[0].Substring( 11);
				
				szRet = szYear + "-" + szMonth + "-" + szDay + " " + szTime;
				
				for (int i = 3; i < rgszFields.Length; i++)
				{
					szRet += "\t" + rgszFields[i];
				}
				szRet += "\t" + iServID.ToString();
			}
						
			return szRet;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParsePres.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// ParsePres - script that parses presence log.  Currently only looks for KILLED entries.
	/// </summary>
	
	public class KilledRow
	{
		public string	sDTStart;
		public string	sDTEnd;
		public int		iTitleID;
		public int		iState;
		public long		biUserID;
		public long		biSessionID;
		public int		iServerID;

		public KilledRow( string sStart, string sEnd, int iT, int iS, long lU, long lS)
		{
			sDTStart = sStart;
			sDTEnd	 = sEnd;
			iTitleID = iT;
			iState	 = iS;
			biUserID = lU;
			biSessionID = lS;
			iServerID= 0;
		}

		public KilledRow( string sStart, string sEnd, int iT, int iS, long lU, long lS, int iSrvID)
		{
			sDTStart = sStart;
			sDTEnd	 = sEnd;
			iTitleID = iT;
			iState	 = iS;
			biUserID = lU;
			biSessionID = lS;
			iServerID= iSrvID;
		}
	}
	
	public class ParsePres : ParseLog
	{
		// member-vars
		// input
		private Regex			m_reKilled1;
		private Regex			m_reKilled2;
		private const string	m_szServerMask = "pres(\\d{3})";
		private const string	m_szKilledMask1 =					// old presence log format
			"(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|\\d*\\|KILLED\\|" + 
		//		year	month		day			time
		//		$1		$2			$3			$4
			"(\\-?\\d{1,32})\\|(\\-?\\d{1,16})\\|(\\-?\\d*)\\|(\\-?\\d*)\\|(\\-?\\d*)";
		//		PUID			Title				State		Session		duration
		//		$5				$6					$7			$8			$9
		private const string	m_szKilledMask2 =					// new presence log format
			"(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\|KIA|[\\da-fA-F]{1,16}\\|[\\da-fA-F]*\\|[\\da-fA-F]*\\|" +
		//		year	month		day			time								Machine PUID		Nonce			SGIP
		//		$1		$2			$3			$4
			"[\\da-fA-F]*\\|([\\da-fA-F]{1,16})\\|([\\da-fA-F]{1,8})\\|[\\da-fA-F]*\\|[\\da-fA-F]*\\|[\\da-fA-F]{1,8}\\|[\\da-fA-F]{1,4}\\|([\\da-fA-F]*)";
		//		SPI			User PUID				TitleID				Title Version	Title Region	Xbox IP			XBox Port			Duration
		//					$5						$6																						$7
		//	2003/07/21 21:00:08.998|KIA|984E04E04DFBA|C830364530BE43AA|100C00A|FED28100|9D4B94B9504C5|A7049955|10130100|80000007|200D389D|20C|724
		//	year mo da  time			Machine PUID	Nonce			SGIP	SPI		User PUID	  TitleID  TitleVer	TitleReg XBox IP  port Duration

		// member-func
		public ParsePres( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_reKilled1	 = new Regex( m_szKilledMask1, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_reKilled2	 = new Regex( m_szKilledMask2, RegexOptions.Compiled | RegexOptions.IgnoreCase);
		}

		public override bool Run(bool fUseRegex)
		{
			Console.WriteLine("ParsePresence is " + (fUseRegex? "" : "not ") + "using regular expressions.");
			bool	fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);
			
			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;
			KilledRow	 kr = null;
			Match		 mtch = null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			Regex		 reServID = new Regex( m_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;
			
			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false);
			//sw.AutoFlush = true;
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id
				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( fUseRegex)
					{
						if ( null != ( kr = ParseLine( szLineIn) ) )
						{
							// put ServerID in
							kr.iServerID = iServID;
							// write line
							sw.WriteLine("{0},{1},{2},{3},{4},{5},{6}", kr.sDTStart, kr.sDTEnd, kr.iTitleID, kr.biUserID,
								kr.iState, kr.biSessionID, kr.iServerID);
							lLinesWrite++;
						}
					}
					else
					{
						if ( null != ( szLineOut = ParseLine( szLineIn, iServID) ) )
						{
							sw.WriteLine( szLineOut);
							lLinesWrite++;
						}
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

		private KilledRow ParseLine( string szLine)
		{
			//  old format
			//	year	month	day	time	PUID	Title	State	Session		duration
			//	$1		$2		$3	$4		$5		$6		$7		$8			$9
			//  new format
			//	$1		$2		$3	$4		$5		$6		-		-			$7

			KilledRow kr = null;
			
			// old format
			Match mc = m_reKilled1.Match( szLine);
			
			if ( mc.Success )
			{
				// get dtEnd
				string sDTEnd = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
					mc.Groups[4].Value;
				// get dtStart
				DateTime dtStart = DateTime.Parse( sDTEnd);
				dtStart = dtStart.AddMilliseconds( -Convert.ToDouble( mc.Groups[9].Value ) );
				string sDTStart = dtStart.Month + "/" + dtStart.Day + "/" + dtStart.Year + " " + dtStart.TimeOfDay.ToString();
				// truncate trailing 0's
				if ( sDTStart.IndexOf( ".") > 0 )
				{
					sDTStart = sDTStart.Substring( 0, sDTStart.IndexOf( ".") + 4 );
				}

				kr = new KilledRow( sDTStart, sDTEnd, Convert.ToInt32( mc.Groups[6].Value ), Convert.ToInt32( mc.Groups[7].Value ),
					Convert.ToInt64( mc.Groups[5].Value ), Convert.ToInt64( mc.Groups[8].Value ) );
			}
			else
			{
				// new format
				mc = m_reKilled2.Match( szLine);
				if ( mc.Success )
				{
					// get dtEnd
					string sDTEnd = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
						mc.Groups[4].Value;
					// get dtStart
					DateTime dtStart = DateTime.Parse( sDTEnd);
					dtStart = dtStart.AddMilliseconds( -Convert.ToDouble( mc.Groups[7].Value ) );
					string sDTStart = dtStart.Month + "/" + dtStart.Day + "/" + dtStart.Year + " " + dtStart.TimeOfDay.ToString();
					// truncate trailing 0's
					if ( sDTStart.IndexOf( ".") > 0 )
					{
						sDTStart = sDTStart.Substring( 0, sDTStart.IndexOf( ".") + 4 );
					}

					kr = new KilledRow( sDTStart, sDTEnd, Convert.ToInt32( mc.Groups[6].Value ), 0, Convert.ToInt64( mc.Groups[5].Value ), 0);
				}
			}

			return kr;
		}

		private string ParseLine( string szLine, int iServID)
		{
			string szRet = null;
			string[] rgszFields = szLine.Split( m_rgchSeparator, 13);
			//  old format
			//	year/month/day	time|#|KILLED|PUID|Title|State|Session|duration
			//	0					 1	2		3	4		5	6		7
			//	new format
			//	year/month/day time|KIA|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|TitleID|TitleVer|TitleRegion|Xbox IP|Xbox port|Duration(ms)
			//	0					1		2		3		4		5		6		7		8		9			10		11		12

			if ( rgszFields.Length == 8 && 0 == rgszFields[2].ToUpper().CompareTo( "KILLED") )
			{
				// old format
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMonth= rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);
				string szTime = rgszFields[0].Substring( 11);
				
				szRet = szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				DateTime dtStart = DateTime.Parse( szRet);
				dtStart = dtStart.AddMilliseconds( -Convert.ToDouble( rgszFields[7]) );
				szRet = dtStart.Month + "/" + dtStart.Day + "/" + dtStart.Year + " " + dtStart.TimeOfDay.ToString();
				// truncate trailing 0's
				if ( szRet.IndexOf( ".") > 0 )
				{
					szRet = szRet.Substring( 0, szRet.IndexOf( ".") + 4 );
				}
				szRet += "," + szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				szRet += "," + rgszFields[4]; // iTitleID
				szRet += "," + rgszFields[3]; // biUserID
				szRet += "," + rgszFields[5]; // iState
				szRet += "," + rgszFields[6]; // biSessionID
				szRet += "," + iServID.ToString();
			}
			else if ( rgszFields.Length == 13 && 0 == rgszFields[1].ToUpper().CompareTo( "KIA") )
			{
				// new format
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMonth= rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);
				string szTime = rgszFields[0].Substring( 11);

				szRet = szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				DateTime dtStart = DateTime.Parse( szRet);
				dtStart = dtStart.AddMilliseconds( -Convert.ToDouble( Convert.ToInt64( rgszFields[12], 16) ) );
				szRet = dtStart.Month + "/" + dtStart.Day + "/" + dtStart.Year + " " + dtStart.TimeOfDay.ToString();
				// truncate trailing 0's
				if ( szRet.IndexOf( ".") > 0 )
				{
					szRet = szRet.Substring( 0, szRet.IndexOf( ".") + 4 );
				}
				szRet += "," + szMonth + "/" + szDay + "/" + szYear + " " + szTime;
				szRet += "," + Convert.ToInt32( rgszFields[7], 16).ToString();	// iTitleID
				szRet += "," + Convert.ToInt64( rgszFields[6], 16).ToString();	// biUserID
				szRet += "," + 0;	// iState
				szRet += "," + 0;	// biSessionID
				szRet += "," + iServID.ToString();
			}
			
			return szRet;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseSPS.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// Summary description for ParseSPS.
	/// </summary>
	public class ParseSPS : ParseLog
	{
		private Regex			m_reSPSAccountInfo;
		private Regex			m_reSPSAddressInfo;
		private Regex			m_reSPSErrorInfo;
		
		private const string	c_szServerMask = "^sps(\\d{3})";
		private const string	c_szSPSAcctMask = 
			"\\<FirstName\\>([^\\<]*)\\<\\/FirstName\\>\\<LastName\\>([^\\<]*)\\<\\/LastName\\>\\<Email\\>([^\\<]*)\\<\\/Email\\>";
			//					$1										$2									$3
			//					firstName								lastName							email
		private const string	c_szSPSAddrMask =
			".+\\<PhonePrefix\\>([^\\<]*)\\<\\/PhonePrefix\\>\\<PhoneNumber\\>([^\\<]*)\\<\\/PhoneNumber\\>\\<CountryCode\\>([^\\<]*)\\<\\/CountryCode\\>" +
			//						$1											$2												$3
			//						area										phone											country
			".+\\<Street1\\>([^\\<]*)\\<\\/Street1\\>(?:\\<Street2\\>(.*)\\<\\/Street2\\>)?\\<City\\>([^\\<]*)\\<\\/City\\>" + 
			
			//					$4									$5									$6
			//					street								street2								city
			"(?:\\<District\\>(.*)\\<\\/District\\>)?\\<State\\>([^\\<]*)\\<\\/State\\>\\<CountryCode\\>([^\\<]*)\\<\\/CountryCode\\>" + 
			//				$7									$8										$9
			//				district							state									country
			"\\<PostalCode\\>([^\\<]*)\\<\\/PostalCode\\>";
			//					$10
			//					postal
		private const string	c_szSPSErrMask =
			"^\\<ErrorPackage\\>\\<ErrorHResult\\>([^\\<]*)\\<\\/ErrorHResult\\>\\<ErrorMessage\\>([^\\<]*)\\<\\/ErrorMessage\\>";
			//
			//
		/*
		2002/11/01 13:49:38.811|CreateAccount|1|1|625556|-1186228786|Casaubon_Eco|802cdb5a-094d-4304-91e2-b9023fa685b6|
		YYYY/MM/DD HH:MM:SS.ms				  ^ ^	^^^		^^^			^^^			^^^
		  YY/MM/DD					DelegateHi/Lo	UserIDHi/Lo			GamerTag	Guid
		<AccountInfo xmlns="urn:schemas-microsoft-com:billing-data"><CustomerType>PERSONAL</CustomerType><FriendlyName>XBOX Live</FriendlyName>
			<FirstName>mario</FirstName><LastName>zales</LastName><Email>casaubone@hotmail.com</Email><Locale>en-US</Locale><Currency>USD</Currency>
						^^^							^^^						^^^
			<PhoneSet><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>281</PhonePrefix><PhoneNumber>8473559</PhoneNumber><CountryCode>US</CountryCode>
																		^^^								^^^								^^
			</Phone></PhoneSet><AddressInfoSet><AddressInfo><FriendlyName>XBOX Live</FriendlyName><Street1>4306 cypresswood dr.</Street1>
																											^^^
			<City>spring</City><State>TX</State><CountryCode>US</CountryCode><PostalCode>77379</PostalCode></AddressInfo></AddressInfoSet>
					^^^				  ^^					 ^^							  ^^^
		</AccountInfo>|
		<PaymentInstrumentInfo xmlns="urn:schemas-microsoft-com:billing-data"><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType>
			<FriendlyName>XBOX Live</FriendlyName><CreditCardInfo><AccountHolderName>mario zales</AccountHolderName>
			<EncryptedAccountNumber>3000320030003500320038003000310054008c000000010200000266000000a40000097770f0c5e3a0cd6309f7aa4a528aab6830787cb3ee14660522936da95b6ddad11e98a769226aebb7fdbfe6105fe866fdeea6bf34bf53e7b1e94a7fe206d936a1a48b5c561a69c721e1fcc612c702623dcbcb3c39ae79a0535001e6617adbfb16ea5013a3c39760c9372303b1478ccf6ac0caeed774f4be9804cc9bf0b36375280000000cd0d325e849b64dd989f0eb7a63b30ab8ec51291370a76a7b6122c24ca7da084ed95e758a60c0da</EncryptedAccountNumber>
			<CardType>VISA</CardType><ExpirationDate>112003</ExpirationDate></CreditCardInfo><Phone><PhoneType>PRIMARY</PhoneType>
			<PhonePrefix>281</PhonePrefix><PhoneNumber>8473559</PhoneNumber><CountryCode>US</CountryCode></Phone><AddressInfo>
						 ^^^							^^^								 ^^
			<FriendlyName>XBOX Live</FriendlyName><Street1>4306 cypresswood dr.</Street1><City>spring</City><State>TX</State>
															^^^									^^^				   ^^
			<CountryCode>US</CountryCode><PostalCode>77379</PostalCode></AddressInfo>
						 ^^							  ^^^
		</PaymentInstrumentInfo>|
		<ErrorPackage>
			<ErrorHResult>0x0</ErrorHResult><ErrorMessage></ErrorMessage><ErrorDebugInfo><DebugInfo>0x0</DebugInfo>
						  ^^^							 ^^^
			<DebugInfo><![CDATA[]]></DebugInfo><ComputerName></ComputerName></ErrorDebugInfo>
		</ErrorPackage>|
		h9BbAQAAAAAAAAAA|h9BbAQAAAAABAACA|1||Complete
		*/

		// member-func
		public ParseSPS( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_reSPSAccountInfo	= new Regex( c_szSPSAcctMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_reSPSAddressInfo	= new Regex( c_szSPSAddrMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_reSPSErrorInfo	= new Regex( c_szSPSErrMask,  RegexOptions.Compiled | RegexOptions.IgnoreCase);
		}
		
		public override bool Run( bool fIgnore)
		{
			Console.WriteLine("ParseSPS ...");
			bool	fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);
			
			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;
			Match		 mtch = null;
			long		 lLinesRead  = 0;
			long		 lLinesWrite = 0;
			Regex		 reServID = new Regex( c_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;
			
			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false, System.Text.Encoding.Unicode);
			//sw.AutoFlush = true;
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id
				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( null != (szLineOut = ParseLine( szLineIn, iServID) ) )
					{
						sw.WriteLine( szLineOut);
						lLinesWrite++;
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

		private string ParseLine( string szLine, int iServID)
		{
			/*
			 idtWhen|hResult|tiServNum|biPUID|szGamerTag|tiIsOwner|wszFirstName|wszLastName|szEMailAddr|szPhone|wszAddress|
				 wszCity|wszDistrict|wszState|szCountryCode|wszPostalCode
			*/
			
			string		szRet		= null;
			string[]	rgszFields	= szLine.Split( this.m_rgchSeparator);
			
			int	   iIdx1  = rgszFields[0].IndexOf("/");
			int	   iIdx2  = rgszFields[0].LastIndexOf("/");
			string szYear = rgszFields[0].Substring( 0, iIdx1);
			string szMonth= rgszFields[0].Substring( iIdx1+1, iIdx2-(iIdx1+1));
			string szDay  = rgszFields[0].Substring( iIdx2+1, 2);
			string szTime = rgszFields[0].Substring( iIdx2+3);

			string szAcct = null;
			string szAddr = null;
			string szErr  = null;
			long   lUserID= 0;
			
			try
			{
				// validate timestamp
				DateTime dt = DateTime.Parse( szMonth + "/" + szDay + "/" + szYear + " " + szTime);
				szRet = szYear + "-" + szMonth + "-" + szDay + " " + szTime;
			}
			catch
			{
				// no recovery
				return null;
			}
			
			// append hResult
			if (null == ( szErr = Parse( rgszFields[10], m_reSPSErrorInfo) ) )
			{
				szRet += "\t-1";
			}
			else 
			{
				szErr = szErr.Substring( 1, szErr.IndexOf( "|", 1)-1);
				szRet += "\t" + Convert.ToInt64(szErr, 16).ToString("d");
			}

			// append tiServNum
			szRet += "\t" + iServID.ToString();

			// append UserID Hi/Lo
			lUserID = Convert.ToInt64(rgszFields[4]);
			lUserID <<= 32;
			lUserID |= (Convert.ToInt64(rgszFields[5]) & 0x00000000ffffffff);
			szRet += "\t" + lUserID.ToString();

			// append gamerTag & Owner
			if ( rgszFields[6].IndexOf( ".Owner") >= 0)
			{
				szRet += "\t" + rgszFields[6].Substring( 0, rgszFields[6].IndexOf( ".")).Replace( "_", " ") + "\t1";
			}
			else
			{
				szRet += "\t" + rgszFields[6].Replace( "_", " ") + "\t0";
			}
			
			// validate AccountInfo
			if ( null == ( szAcct = Parse( rgszFields[8], m_reSPSAccountInfo) ) )
			{
				// error parsing AccountInfo
				return null;
			}
			szRet += szAcct.Replace( "|", "\t");
			
			// validate AccountAddress
			if ( null == ( szAddr = Parse( rgszFields[8], m_reSPSAddressInfo) ) )
			{
				// error parsing AccountAddress
				return null;
			}
			else
			{
				string[] rgszAddr = szAddr.Split( this.m_rgchSeparator);
				// phoneprefix|phone|countrycode|street|city|state|country|postal
				//szPhone|wszAddress|wszCity|wszDistrict|wszState|szCountryCode|wszPostalCode
				szRet += "\t+" + rgszAddr[3] + " (" + rgszAddr[1] + ") " + rgszAddr[2];	// phone
				szRet += "\t" + rgszAddr[4] + (0!=rgszAddr[5].Length? " "+rgszAddr[5]:"" );// street
				szRet += "\t" + rgszAddr[6];												// city
				szRet += "\t" + (0 == rgszAddr[7].Length? "NULL" : rgszAddr[7]);			// District
				szRet += "\t" + rgszAddr[8];												// State
				szRet += "\t" + rgszAddr[9];												// Country
				szRet += "\t" + rgszAddr[10];												// PostalCode
			}
/*			
			// validate PaymentAddress
			if ( null == ( szAddr = Parse( rgszFields[9], m_reSPSAddressInfo) ) )
			{
				// error parsing PaymentAddress
				return null;
			}
			szRet += szAddr;
*/
			
			return szRet;
		}

		private string Parse( string szLine, Regex re)
		{
			string szRet = null;
			Match mtch = re.Match( szLine);

			if ( mtch.Success )
			{
				szRet = "";
				for (int i = 1; i < mtch.Groups.Count; i++)
				{
					szRet += "|" + mtch.Groups[i].Value;
				}
			}
			return szRet;
		}


		/*
        #                                   Delegate Hi/Lo
        #                                       v v
        # 2002/10/31 13:54:11.320|CreateAccount|1|1|634138|-777184198|Drunkass|acf4256a-af9a-4c41-92c9-649043577a85
        # YYYY/MM/DD HH:MM:SS.ms_                   UserID Hi/Lo      GamerTag      Tracking GUID

        # Pre-09/26 logs use YY/MM/DD instead

        #
        # Continued from previous:  account info XML
        # |<AccountInfo xmlns="urn:schemas-microsoft-com:billing-data"><CustomerType>PERSONAL</CustomerType><FriendlyName>XBOX Live</FriendlyName><FirstName>francesco</FirstName><LastName>fiorini</LastName><Email>ceco@cox.net</Email><Locale>en-US</Locale><Currency>USD</Currency><PhoneSet><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>619</PhonePrefix><PhoneNumber>4623914</PhoneNumber><CountryCode>US</CountryCode></Phone></PhoneSet><AddressInfoSet><AddressInfo><FriendlyName>XBOX Live</FriendlyName><Street1>9286 lemon ave</Street1><City>la mesa</City><State>CA</State><CountryCode>US</CountryCode><PostalCode>91941</PostalCode></AddressInfo></AddressInfoSet></AccountInfo>
        #                                                                                                                                                    ^^^                            ^^^                      ^^^                                                                                                                           ^^^                           ^^^                               ^^                                                                                                             ^^^                           ^^^                  ^^                     ^^                          ^^

        #
        # Continued from previous:  payment instrument XML
        # |<PaymentInstrumentInfo xmlns="urn:schemas-microsoft-com:billing-data"><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType><FriendlyName>XBOX Live</FriendlyName><CreditCardInfo><AccountHolderName>francesco fiorini</AccountHolderName><EncryptedAccountNumber>3000320030003500320038003000310054008c000000010200000266000000a400008ef575ce21f4e865cad910e54aa7839de3db92bfc4abd5cedbec4b6728d1a0487c9d522c7f9535c1be21df53c307099b3c84eddb9b9396b5a07d2caa4a83ee7bc08ca9c2c7415cc448c67cc27d62bef6aa639b2d8463223c31f25295d095b3aca782a6cebc696dbf1fdee0c075ac3a65f27ca14e2a72eb4dff7008c706eb2a3828000000201a2734e732dc427dba466d0cd55e3ad8ebd4f668aecb590182d7ba1a6291cf6fdc68b79fdf40a2</EncryptedAccountNumber><CardType>VISA</CardType><ExpirationDate>072003</ExpirationDate></CreditCardInfo>
        
        #
        # Continued from previous:  more payment XML
        # <Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>619</PhonePrefix><PhoneNumber>4623914</PhoneNumber><CountryCode>US</CountryCode></Phone><AddressInfo><FriendlyName>XBOX Live</FriendlyName><Street1>9286 lemon ave</Street1><City>la mesa</City><State>CA</State><CountryCode>US</CountryCode><PostalCode>91941</PostalCode></AddressInfo></PaymentInstrumentInfo>
        #                                                   ^^^                           ^^^                               ^^                                                                                  ^^^                           ^^^                  ^^                     ^^                          ^^^                                       

        #
        # Continued from previous:  error XML, etc.
        # |<ErrorPackage><ErrorHResult>0x0</ErrorHResult><ErrorMessage></ErrorMessage><ErrorDebugInfo><DebugInfo>0x0</DebugInfo><DebugInfo><![CDATA[]]></DebugInfo><ComputerName></ComputerName></ErrorDebugInfo></ErrorPackage>|l0BgAQAAAAAAAAAA|l0BgAQAAAAABAACA|28||Complete
        #                              ^^^                            ^^^
		*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\Reader.cs ===
using System;
using System.IO;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// Summary description for Reader.
	/// </summary>
	public class Reader
	{
		private string			m_szFileName;
		private StreamReader	m_sr;

		public Reader( string szFileName)
		{
			m_szFileName = szFileName;
			m_sr = new StreamReader( m_szFileName);
		}

		~Reader()
		{
			if ( null != m_sr )
			{
				m_sr.Close();
			}
		}

		public string ReadLine()
		{
			return m_sr.ReadLine();
		}

		public string ReadLine( long lNum)
		{
			string szLine = null;

			while ( --lNum > 0 && null != ( szLine = m_sr.ReadLine() ) ) ;
			if ( lNum > 0 )
			{
				return null;
			}
			else
			{
				return szLine;
			}
		}

		public void Reopen()
		{
			if ( null != m_sr )
			{
				m_sr = null;
			}
			m_sr = new StreamReader( m_szFileName);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\KilledTransform\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\TestScript.cs ===
using System;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// Summary description for TestScript.
	/// </summary>
	class TestScript
	{
		/// <summary>
		/// The main entry point for the application.
		/// 
		/// 
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			if ( args.Length < 3 )
			{
				Usage();
			}
			else
			{
				DateTime dt1 = DateTime.Now;
				switch ( args[0].ToLower() )
				{
					case "fdbk":
					{
						ParseFeedBack pf = new ParseFeedBack( args[1], args[2]);
						if ( args.Length > 3 && 0 != args[3][0].CompareTo( '-') )
						{
							pf.Run( true);
						}
						else
						{
							pf.Run();
						}
						break;
					}
					case "pres":
					{
						ParsePres pp = new ParsePres( args[1], args[2]);
						if ( args.Length > 3 && 0 != args[3][0].CompareTo( '-') )
						{
							pp.Run(true);
						}
						else
						{
							pp.Run();
						}
						break;
					}
					case "sps":
					{
						ParseSPS ps = new ParseSPS( args[1], args[2]);
						ps.Run();
						break;
					}
					case "xbos":
					{
						ParseContent pc = new ParseContent( args[1], args[2]);
						if ( args.Length > 3 && 0 != args[3][0].CompareTo( '-') )
						{
							pc.Run(true);
						}
						else
						{
							pc.Run();
						}
						break;
					}

					case "cust":
					{
						ParseCust pc = new ParseCust( args[1], args[2]);
						if ( args.Length > 3 && 0 != args[3][0].CompareTo( '-') )
						{
							pc.Run( true);
						}
						else
						{
							pc.Run();
						}
						break;
					}
					case "down":
					{
						ParseDown pw = new ParseDown( args[1], args[2]);
						if ( args.Length > 3 && 0 != args[3][0].CompareTo( '-') )
						{
							pw.Run( true);
						}
						else
						{
							pw.Run();
						}
						break;
					}
					case "stfd":
					{
						ParseSTFD pstfd = new ParseSTFD( args[1], args[2]);
						if ( args.Length > 3 && 0 != args[3][0].CompareTo( '-') )
						{
							pstfd.Run( true);
						}
						else
						{
							pstfd.Run();
						}
						break;
					}
					case "wbca":
					{
						ParseWBCA pwbca = new ParseWBCA( args[1], args[2]);
						pwbca.Run();
						break;
					}

					case "fdbk2":
					{
						FilterRows fr = new FilterRows( args[1], args[2], Filters.ftrFeedback);
						fr.Run();
						break;
					}
					case "mtch2":
					{
						FilterRows fr = new FilterRows( args[1], args[2], Filters.ftrMatch);
						fr.Run();
						break;
					}
					case "pres2":
					{
						FilterRows fr = new FilterRows( args[1], args[2], Filters.ftrPres);
						fr.Run();
						break;
					}
					case "sps2":
					{
						FilterRows fr = new FilterRows( args[1], args[2], Filters.ftrSPS);
						fr.Run();
						break;
					}
					case "xpnf2":
					{
						FilterRows fr = new FilterRows( args[1], args[2], Filters.ftrXPNF);
						fr.Run();
						break;
					}
					case "read":
					{
						Reader r = new Reader( args[1]);
						long  ls = Convert.ToInt64( args[2]);
						if ( ls >= 0 )
						{
							Console.WriteLine( r.ReadLine( ls) );
							if ( args.Length > 3 )
							{
								long le = Convert.ToInt64( args[3]);

								if ( le > ls )
								{
									while ( --le >= ls )
									{
										Console.WriteLine( r.ReadLine() );
									}
								}
							}
						}
						else
						{
							Console.WriteLine( r.ReadLine() );
						}
						break;
					}
					default:
						Usage();
						break;
				}
				TimeSpan ts1 = DateTime.Now - dt1;
				Console.WriteLine( "Parsing took: {0} sec", ts1.TotalSeconds);
			}
		}

		static void Usage()
		{
			Console.WriteLine("Reports CorpScript Testing Tool");
			Console.WriteLine("\nUsage:   TestScript.exe <type> <input_mask> <output_file>");
			Console.WriteLine("\nOptions: read <file_name> <start_line> <number_of_lines>");
			Console.WriteLine("\n         fdbk <input_mask> <output_file> [<use_reg_expr>]");
			Console.WriteLine("\n         pres <input_mask> <output_file> [<use_reg_expr>]");
			Console.WriteLine("\n         sps  <input_mask> <output_file>");
			Console.WriteLine("\n         xbos <input_mask> <output_file> [<use_reg_expr>]");
			Console.WriteLine("\n         cust  <input_mask> <output_file> [<use_reg_expr>]");
			Console.WriteLine("\n         down  <input_mask> <output_file> [<use_reg_expr>]");
			Console.WriteLine("\n         stfd  <input_mask> <output_file> [<use_reg_expr>]");
			Console.WriteLine("\n         wbca  <input_mask> <output_file>");
			Console.WriteLine("\n         fdbk2 <input_mask> <output_file>");
			Console.WriteLine("\n         mtch2 <input_mask> <output_file>");
			Console.WriteLine("\n         pres2 <input_mask> <output_file>");
			Console.WriteLine("\n         sps2  <input_mask> <output_file>");
			Console.WriteLine("\n         xbos2 <input_mask> <output_file>");
			Console.WriteLine("\n         xpnf2 <input_mask> <output_file>");
			Console.WriteLine("\nExample: TestScript.exe pres M:\\Reports\\Data\\pres\\work\\pres* M:\\Reports\\Data\\pres\\RawKilled1.bcp");
		}
	}

	public enum Filters
	{
		ftrFeedback = 0,
		ftrMatch,
		ftrPres,
		ftrSPS,
		ftrXPNF,
	}

	public abstract class ParseLog
	{
		protected string		m_szFileMask;
		protected string		m_szOutFile;
		protected char[]		m_rgchSeparator;

		public ParseLog( string szFileMask, string szOutFile)
		{
			m_szFileMask		= szFileMask;
			m_szOutFile			= szOutFile;
			m_rgchSeparator		= new Char[] {'|'};
		}
		
		public virtual bool Run()
		{
			return Run(false);
		}

		public abstract bool Run( bool fUseRegex);

		public int IP_atoi( string szIP)
		{
			int			ip		= 0;
			string[]	rgszIP	= szIP.Split( new Char[1] {'.'});

			if ( rgszIP.Length == 4 )
			{
				ip = Convert.ToByte( rgszIP[0]);
				for (int i = 1; i < rgszIP.Length; i++)
				{
					ip <<= 8;
					ip |= Convert.ToByte( rgszIP[i]);
				}
			}
			return ip;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseWBCA.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// ParseWBCA - parses web services logs.
	/// </summary>
	public class ParseWBCA : ParseLog
	{
		// member-vars
		private const string	m_szServerMask = "wbca(\\d{3})";
		private const string	m_szTypes = "FRD,LNK,LNKD,GETS,GETL,GetLBList,EnumerateLB,GetLBNearGamerTag,GetLBForGamerTag,GetLBDetails,EnumerateLBRaw";
		private Char[]			m_rgchSplit = null;


		// member-func
		public ParseWBCA( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_rgchSplit = new Char[2] {'.', ':'};
		}
	
	
		public override bool Run( bool fUseRegex)
		{
			if ( fUseRegex)
			{
				Console.WriteLine( "ParseWBCA does not support regular expressions.");
				return false;
			}

			bool fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);

			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;

			Match		 mtch = null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			Regex		 reServID = new Regex( m_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;

			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false);
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id

				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( null != ( szLineOut = ParseLine( szLineIn, iServID) ) )
					{
						sw.Write( szLineOut + "\r\n");
						lLinesWrite++;
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}
		private string ParseLine( string szLine)
		{
			return szLine;
		}


		private string ParseLine( string szLine, int iServID)
		{
			/* in
			2003/09/10 10:01:15.036|TYPE|prod.xplace.rdo.001|B5DFEC62ECCE1A8E|65.59.234.105:9215|00067FFE85FD1FA6|InsaneTHE YETI|0|4|95
			2003/09/10 10:01:15.036|TYPE2|OK|Subject|biRequest|IP:Port|iTitle|...
			out:
			idtWhen,Subject,API,TitleID,RequestID,ClientIP,ClientPort,ServerNum
			*/
			string sz = null;
			string[] rgszFields = szLine.Split( m_rgchSeparator);

			if ( rgszFields.Length < 7 || m_szTypes.IndexOf( rgszFields[1]) < 0 )
			{
				return sz;
			}

			string szYear = rgszFields[0].Substring( 0, 4);
			string szMon  = rgszFields[0].Substring( 5, 2);
			string szDay  = rgszFields[0].Substring( 8, 2);

			sz = szMon + "/" + szDay + "/" + szYear + " " + rgszFields[0].Substring( 10);
			string szOne;
			string szTwo;
			int	iAPI = 0;
			int iType = 0;
			int iNum = 0;

			switch (rgszFields[1])
			{
				case "FRD":
					iAPI = 1;
					iType = 1;
					iNum = 10;
					break;
				case "LNK":
					iAPI = 8;
					iType = 1;
					iNum = 11;
					break;
				case "LNKD":
					iAPI = 9;
					iType = 1;
					iNum = 7;
					break;
				case "GETS":
					iAPI = 10;
					iType = 1;
					iNum = 9;
					break;
				case "GETL":
					iAPI = 11;
					iType = 1;
					iNum = 7;
					break;

				case "GetLBList":
					iAPI = 2;
					iType = 2;
					iNum = 7;
					break;
				case "EnumerateLB":
					iAPI = 3;
					iType = 2;
					iNum = 12;
					break;
				case "GetLBNearGamerTag":
					iAPI = 4;
					iType = 2;
					iNum = 13;
					break;
				case "GetLBForGamerTag":
					iAPI = 5;
					iType = 2;
					iNum = 11;
					break;
				case "GetLBDetails":
					iAPI = 6;
					iType = 2;
					iNum = 11;
					break;
				case "EnumerateLBRaw":
					iAPI = 7;
					iType = 2;
					iNum = 12;
					break;
				default:
					return null;
			}

			if ( rgszFields.Length == iNum && iType == 1 && ParseType1( rgszFields, out szOne, out szTwo) )
			{
				sz += "," + szOne + "," + iAPI.ToString( "d") + "," + szTwo + "," + iServID.ToString( "d");
				return sz;
			}
			else if ( rgszFields.Length == iNum && iType == 2 && rgszFields[2] == "OK" && 
				ParseType2( rgszFields, out szOne, out szTwo) )
			{
				sz += "," + szOne + "," + iAPI.ToString( "d") + "," + szTwo + "," + iServID.ToString( "d");
				return sz;
			}
			return null;
		}


		private bool ParseType1( string [] rgsz, out string szOne, out string szTwo)
		{
			// subject
			szOne = rgsz[2];
			// iTitleID
			szTwo = "-1"; 
			// biRequest
			szTwo += "," + Convert.ToInt64( rgsz[3], 16).ToString( "d");
			// IP
			string [] rgszIP = rgsz[4].Split( ':');
			szTwo += "," + IP_atoi( rgszIP[0]).ToString( "d");
			// Port
			szTwo += "," + rgszIP[1];
			return true;
		}


		private bool ParseType2( string [] rgsz, out string szOne, out string szTwo)
		{
			// subj
			szOne = rgsz[3];
			// iTitleID
			szTwo = Convert.ToInt32( rgsz[6], 16).ToString( "d");
			// biRequest
			szTwo += "," + Convert.ToInt64( rgsz[4], 16).ToString( "d");
			// IP
			string [] rgszIP = rgsz[5].Split( ':');
			szTwo += "," + IP_atoi( rgszIP[0]).ToString( "d");
			// Port
			szTwo += "," + rgszIP[1];
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\Data\TestScripts\ParseDown.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace xonline.tools.xlreports.data.testscripts 
{
	/// <summary>
	/// ParseDown - script that parses IIS download logs.
	/// </summary>
	public class ParseDown : ParseLog
	{
		// member-vars
		private Regex			m_reDL;
		private const string	m_szServerMask = "down...(\\d{3})";
		private Char[]			m_rgchSplit = null;
		private const string	m_szDLMask = 
			"(\\d{4})\\-(\\d{2})\\-(\\d{2}) (\\d{2}:\\d{2}:\\d{2}) (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) " + 
			//		year		month	day			time				user IP
			"([^ ]*) (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) (\\d{1,5}) GET ([^ ]*) n=([\\da-fA-F]{1,16}) " +
		//	username	server IP									port		URL		query
			"(\\d{1,3}) (\\d*) ([^$]*)$";
		//	status		duration	agent
		//
		//                       dest ip            src ip src port                  URI                          Nonce       Status    User Agent
		//                          v                  v      v                       v                             v            v           v
		// 2003-07-22 14:55:01 157.56.12.148 - 192.168.86.61 3074 GET /content/a7049955/a704995500000005.xcp n=1E252F99832AACDD 200 1234 0/0.00.5641
		// YYYY-MM-DD HH:MM:SS               ^                     ^                                                                 ^
		//                               username              HTTP Verb                                                        Time Taken

		
		// member-func
		public ParseDown( string szFileMask, string szOutFile) : base( szFileMask, szOutFile)
		{
			m_reDL = new Regex( m_szDLMask, RegexOptions.Compiled | RegexOptions.IgnoreCase);
			m_rgchSplit = new Char[] {'/'};
		}

	
		public override bool Run( bool fUseRegex)
		{
			Console.WriteLine( "ParseDown is " + (fUseRegex? "" : "not ") + "using regular expressions.");
			bool fSucc = false;

			// expand file mask 
			string	szPath = m_szFileMask.Substring( 0, m_szFileMask.LastIndexOf( "\\") + 1);
			string	szFile = m_szFileMask.Substring( m_szFileMask.LastIndexOf( "\\") + 1);

			StreamReader sr = null;
			string		 szLineIn = null;
			string		 szLineOut= null;

			Match		 mtch = null;
			long		 lLinesRead = 0;
			long		 lLinesWrite= 0;
			Regex		 reServID = new Regex( m_szServerMask, RegexOptions.Compiled | RegexOptions.IgnoreCase );
			int			 iServID = 0;

			// make a reference to a directory
			DirectoryInfo di = new DirectoryInfo( szPath);
			
			// get a reference to each file satisfying mask in that directory
			FileInfo[] rg_fi = di.GetFiles( szFile);

			// get a reference to output stream
			StreamWriter sw = new StreamWriter( m_szOutFile, false);
			
			// read each file
			foreach (FileInfo fi in rg_fi)
			{
				sr = fi.OpenText();
				// parse server id

				mtch = reServID.Match( fi.Name);
				iServID = Convert.ToInt32( mtch.Groups[1].Value);
				while ( null != ( szLineIn = sr.ReadLine() ) )
				{
					if ( fUseRegex)
					{
						if ( null != ( szLineOut = ParseLine( szLineIn) ) )
						{
							// write line
							sw.Write( szLineOut + "\t" + iServID.ToString("d") + "\r\n" );
							lLinesWrite++;
						}
					}
					else
					{
						if ( null != ( szLineOut = ParseLine( szLineIn, iServID) ) )
						{
							sw.Write( szLineOut + "\r\n");
							lLinesWrite++;
						}
					}
					lLinesRead++;
				}
				sr.Close();
				sr = null;
			}
			sw.Flush();
			sw.Close();
			sw = null;
			Console.WriteLine("Read {0} line(s)\tWrote {1} line(s)", lLinesRead, lLinesWrite);
			
			return fSucc;
		}

	
		private string ParseLine( string szLine)
		{
			// use regex
			// 2003-07-22 14:55:01 157.56.12.148 - 192.168.86.61 3074 GET /content/a7049955/a704995500000005.xcp n=1E252F99832AACDD 200 1234 0/0.00.5641
			// year mo da	time	user_IP		user	server	port		URL										query			stat duration	agent
			//	1	2	3	4		5			6		7		8			9										10				11		12		13
			// out:
			// $idtWhen, $dstip, $srcip, $srcport, $titleid, $package, tostring64($nonce), $status, $timetaken, $servnum

			Match	mc = m_reDL.Match( szLine);
			string	sz = null;

			if ( mc.Success )
			{
				// timestamp
				sz = mc.Groups[2].Value + "/" + mc.Groups[3].Value + "/" + mc.Groups[1].Value + " " +
					mc.Groups[4].Value;
				// userIP
				sz += "," + mc.Groups[5].Value;
				// serverIP
				sz += "," + mc.Groups[7].Value;
				// port
				sz += "," + mc.Groups[8].Value;

				// parse URL:
				string[] rgszURL = mc.Groups[9].Value.Split( m_rgchSplit);
				// titleID
				sz += "," + rgszURL[2];
				// package
				sz += "," + rgszURL[3];
				// nonce
				sz += "," + Convert.ToInt64( mc.Groups[10].Value, 16).ToString( "d");
				// status
				sz += "," + mc.Groups[11].Value;
				// duration
				sz += "," + mc.Groups[12].Value;
			}

			return sz;
		}


		private string ParseLine( string szLine, int iServID)
		{
			// 2003-07-22 14:55:01 157.56.12.148 - 192.168.86.61 3074 GET /content/a7049955/a704995500000005.xcp n=1E252F99832AACDD 200 1234 0/0.00.5641
			// year mo da	time	user_IP		user	server	port		URL										query			stat duration	agent
			//	0			1		2			3		4			5	6		7									8				9		10		11
			// out:
			// $idtWhen, $dstip, $srcip, $srcport, $titleid, $package, tostring64($nonce), $status, $timetaken, $servnum
			string sz = null;
			char[] rgchSplit = new Char[1] {' '};
			string[] rgszFields = szLine.Split( rgchSplit);

			if ( rgszFields.Length == 12 && rgszFields[6] == "GET" && 
				 rgszFields[8].Length > 2 && rgszFields[8].Substring( 0, 2) == "n=" )
			{
				string szYear = rgszFields[0].Substring( 0, 4);
				string szMon  = rgszFields[0].Substring( 5, 2);
				string szDay  = rgszFields[0].Substring( 8, 2);

				// date
				sz = szMon + "/" + szDay + "/" + szYear;
				// time
				sz += " " + rgszFields[1];
				// user IP
				sz += "," + IP_atoi( rgszFields[2]).ToString( "d");
				// server IP
				sz += "," + IP_atoi( rgszFields[4]).ToString( "d");
				// port
				sz += "," + rgszFields[5];

				// parse URL:
				string[] rgszURL = rgszFields[7].Split( m_rgchSplit);
				// titleID
				sz += "," + Convert.ToInt64( rgszURL[2], 16).ToString( "d");
				// package
				sz += "," + rgszURL[3];
				
				// nonce
				sz += "," + Convert.ToInt64( rgszFields[8].Substring( 2), 16).ToString( "d");
				// status
				sz += "," + rgszFields[9];
				// duration
				sz += "," + rgszFields[10];
				// server id
				sz += "," + iServID.ToString( "d");
			}

			return sz;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\WebServicesTransform\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\common\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\common\XLTransInterface.cs ===
namespace xonline.tools.xltrans.common
{
    interface IXlTrans
    {
        long TransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath);
        int GetTransferStatus(long transferId, out string message);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\common\Logging.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.IO;

namespace xonline.tools.xltrans.service
{
    enum EventId : int
    {
        /// <summary>
        /// Informational
        /// XLTrans is initializing
        /// </summary>
        XLTRANS_INITIALIZING = 0,

        /// <summary>
        /// Informational
        /// XlTrans daemon has started
        /// </summary>
        XLTRANS_STARTED = 1,

        /// <summary>
        /// Informational
        /// XlTrans daemon has stopped
        /// </summary>
        XLTRANS_STOPPED = 2,

        /// <summary>
        /// Informational
        /// A transfer has been enqueued
        /// </summary>
        XLTRANS_ENQUEUE = 3,

        /// <summary>
        /// Informational
        /// Argument failure enquing
        /// </summary>
        XLTRANS_ENQUEUE_BADARGUMENT = 4,

        /// <summary>
        /// Error
        /// Something failed while enqueing a transfer job
        /// </summary>
        XLTRANS_ENQUEUE_FAILURE = 5,

        /// <summary>
        /// Error
        /// The transfer requested did not exist.
        /// </summary>
        XLTRANS_GETTRANSFERSTATUS_INVALIDTRANSFER = 6,

        /// <summary>
        /// Error
        /// XlTrans gagged while fetching the transfer status.
        /// </summary>
        XLTRANS_GETTRANSFERSTATUS_FAILURE = 7,

        /// <summary>
        /// Error
        /// XlTrans failed to transfer the file, usually a link failure,
        /// or file not found type of error.
        /// </summary>
        XLTRANS_TRANSFER_FAILURE = 8,

        /// <summary>
        /// Error
        /// Specified endpoint was invalid
        /// </summary>
        XLTRANS_TRANSFER_INVALIDENDPOINT = 9,

        /// <summary>
        /// Informational
        /// A transfer started
        /// </summary>
        XLTRANS_TRANSFER_START = 10,

        /// <summary>
        /// Informational
        /// A Transfer completed
        /// </summary>
        XLTRANS_TRANSFER_COMPLETE = 11,

        /// <summary>
        /// Error
        /// Something bad happened, handle it and exit nicely.
        /// </summary>
        XLTRANS_GENERAL_FAILURE = 12,

        /// <summary>
        /// Warning
        /// A non-critical piece of the transfer failed to complete
        /// </summary>
        XLTRANS_TRANSFER_WARNING = 13,

        /// <summary>
        /// Informational/Error
        /// Configuration changed.  This is an error event if the 
        /// configuration failed to reload.
        /// </summary>
        XLTRANS_CONFIG = 14,

        /// <summary>
        /// Informational/Error
        /// Anything to do with loading the daemon from the web service
        /// </summary>
        XLTRANS_WEBSVC_LOADSERVICE = 15,

        /// <summary>
        /// Something within the XLTrans webservice threw an exception
        /// </summary>
        XLTRANS_WEBSVC_FAILURE = 16
    }
    static class Logging
    {
        static private string _eventsource = "XboxLive Transfer Service";
        static private string _eventlogname = "Application";
        static private EventLog _eventlog;

        static Logging()
        {
            if (!EventLog.SourceExists(_eventsource))
            {
                EventLog.CreateEventSource(_eventsource, _eventlogname);
            }
            _eventlog = new EventLog();
            _eventlog.Source = _eventsource;
        }

        public static void WriteLog(EventLogEntryType type, EventId id, string message, params object[] args)
        {
            StackTrace trace = new StackTrace(true);
            StackFrame frame = trace.GetFrame(1);
            MethodBase method = frame.GetMethod();
            String filename = Path.GetFileName(frame.GetFileName());
            String typename = method.DeclaringType.Name;
            String methodname = method.Name;
            Int32 linenumber = frame.GetFileLineNumber();
            String format;

            if (methodname == ".cctor")
                methodname = typename;

            format = String.Format("{0}:line {1}:{2}.{3}()\n", filename,
                linenumber, typename, methodname);

            _eventlog.WriteEntry(String.Format(format + message, args), type, (int)id);
        }

        public static Exception WriteException(EventLogEntryType type, EventId id, Exception e)
        {
            _eventlog.WriteEntry(e.ToString(), type, (int)id);
            return e;
        }

        public static Exception WriteException(EventLogEntryType type, EventId id, Exception e, string message, params object[] args)
        {
            String format;

            format = String.Format(message, args);
            _eventlog.WriteEntry(format + "\n\n" + e.ToString(), type, (int)id);
            return e;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\common\XMLUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml.Serialization;
using System.Xml;
using System.Xml.Schema;

namespace xonline.tools.xltrans.service
{
    class XmlUtil
    {
        #region Core XML Serialization Functions
        /// <summary>
        /// Serialize data into XML
        /// </summary>
        /// <param name="filename">XML file to write data to.</param>
        /// <param name="data">Object to serialize.</param>
        public static void Serialize<T>(TextWriter outstream, T data)
        {
            XmlSerializer serializer;
            XmlWriter writer;
            XmlWriterSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlWriterSettings();
            settings.Indent = true;

            writer = XmlTextWriter.Create(outstream, settings);
            serializer.Serialize(writer, data);
            writer.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, XmlReader xmlSchemaReader, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();
            settings.ValidationFlags = XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.Schemas.Add(null, xmlSchemaReader);

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, String schemaUri, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();
            settings.ValidationFlags = XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.Schemas.Add(null, schemaUri);

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }
        #endregion
        public static void SerializeFile<T>(string filename, T data)
        {
            using (StreamWriter writer = new StreamWriter(filename))
            {
                Serialize(writer, data);
                writer.Close();
            }
        }

        public static void DeserializeFile<T>(string filename, out T data)
        {
            using (StreamReader reader = new StreamReader(filename))
            {
                Deserialize(reader, out data);
                reader.Close();
            }
        }

        public static void SerializeString<T>(out string text, T data)
        {
            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);
            Serialize(writer, data);
            writer.Close();
            text = builder.ToString();
        }

        public static void DeserializeString<T>(string text, out T data)
        {
            StringReader reader = new StringReader(text);
            Deserialize(reader, out data);
            reader.Close();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\WebServicesTransform\WebServicesTransformApp.cs ===
using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;

namespace xonline.tools.xlreports.webservicestransform 
{
    class ParseInfo
    {
        static private int PARSE_LINE_NUM_FIELDS = 10;

        private string m_sTag;
        private string m_sSubTag;
        private int m_iOrdinal;
        private int m_iNumFields;
        private int m_iResultField;
        private int m_iSubjectField;
        private int m_iRequestIdField;
        private int m_iIPAddrField;
        private int m_iTitleIdField;
        private string m_sSuccessString;

        public ParseInfo(
            string sTag,
            string sSubTag,
            int iOrdinal, 
            int iNumFields, 
            int iResultField, 
            int iSubjectField, 
            int iRequestIdField, 
            int iIPAddrField, 
            int iTitleIdField,
            string sSuccessString)
        {
            if( iResultField >= iNumFields ) throw new Exception("Result field specifier for the " + sTag + " tag is too big for the number of fields.");
            if( iSubjectField >= iNumFields ) throw new Exception("Subject field specifier for the " + sTag + " tag is too big for the number of fields.");
            if( iRequestIdField >= iNumFields ) throw new Exception("Request Id field specifier for the " + sTag + " tag is too big for the number of fields.");
            if( iIPAddrField >= iNumFields ) throw new Exception("IP Address field specifier for the " + sTag + " tag is too big for the number of fields.");
            if( iTitleIdField >= iNumFields ) throw new Exception("Title Id field specifier for the " + sTag + " tag is too big for the number of fields.");

            if( sSubTag.Length != 0 &&
                ( iResultField  == 2 ||
                iSubjectField == 2 ||
                iRequestIdField == 2 ||
                iIPAddrField == 2 ||
                iTitleIdField == 2 ))
            {
                throw new Exception("Request, subject, IP or TitleID field overlaps with subtag field for " + sTag);
            }

            m_sTag = sTag;
            m_sSubTag = sSubTag;
            m_iOrdinal = iOrdinal;
            m_iNumFields = iNumFields;
            m_iResultField = iResultField;
            m_iSubjectField = iSubjectField;
            m_iRequestIdField = iRequestIdField;
            m_iIPAddrField = iIPAddrField;
            m_iTitleIdField = iTitleIdField;
            m_sSuccessString = sSuccessString;
        }

        static public ParseInfo Parse(string sLine)
        {
            if(sLine == null)
                throw new ArgumentNullException("sLine");
            if(sLine.Length == 0)
                throw new ArgumentException("String passed must not be empty.", "sLine");

            string [] sFields = sLine.Split(',');
            if(sFields.Length == 1)
                return new ParseInfo(sLine, "", 0, 1, 0, 0, 0, 0, 0, "");
            if(sFields.Length != PARSE_LINE_NUM_FIELDS)
                throw new Exception("Malformed line in ParseInfo.txt: \"" + sLine + "\"");

            string sTag         = sFields[0];
            string sSubTag      = sFields[1];
            int iOrdinal        = Int32.Parse(sFields[2]);
            int iNumFields      = Int32.Parse(sFields[3]);
            int iResultField    = Int32.Parse(sFields[4]);
            int iSubjectField   = Int32.Parse(sFields[5]);
            int iRequestIdField = Int32.Parse(sFields[6]);
            int iIPAddrField    = Int32.Parse(sFields[7]);
            int iTitleIdField   = Int32.Parse(sFields[8]);
            string sSuccess     = sFields[9];

            return new ParseInfo(
                sTag, 
                sSubTag,
                iOrdinal, 
                iNumFields, 
                iResultField, 
                iSubjectField, 
                iRequestIdField, 
                iIPAddrField, 
                iTitleIdField,
                sSuccess);
        }

        public string Tag           { get { return m_sTag;            } }
        public string SubTag        { get { return m_sSubTag;         } }
        public int Ordinal          { get { return m_iOrdinal;        } }
        public int NumFields        { get { return m_iNumFields;      } }
        public int ResultField      { get { return m_iResultField;    } }
        public int SubjectField     { get { return m_iSubjectField;   } }
        public int RequestIdField   { get { return m_iRequestIdField; } }
        public int IPAddrField      { get { return m_iIPAddrField;    } }
        public int TitleIdField     { get { return m_iTitleIdField;   } }
        public string SuccessString { get { return m_sSuccessString;  } }
    }

    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class WebServicesTransformApp
    {
        static Hashtable s_htParseInfo;
        static SortedList s_aUnmatchedLogTypes;
        static ArrayList s_aBadFormatLines;

        static private void ParseIPPort(string IPPortString, out int iClientIP, out short siClientPort)
        {
            string [] addrElements = IPPortString.Split(':');
            if(addrElements.Length != 2)
                throw new ApplicationException("Invalid IP:Port string");

            siClientPort = (short)UInt16.Parse(addrElements[1]);

            string [] ipElements = addrElements[0].Split('.');

            if(ipElements.Length != 4)
                throw new ApplicationException("Invalid IP:Port string");

            iClientIP = (int)((UInt32.Parse(ipElements[0]) * 16777216) + 
                              (UInt32.Parse(ipElements[1]) * 65536) + 
                              (UInt32.Parse(ipElements[2]) * 256) + 
                              (UInt32.Parse(ipElements[3])));
        }

        /// <summary>
        /// LoadParseInfo
        /// 
        /// Loads ParseInfo.txt from the same directory as WebServicesTransform.exe.
        /// </summary>
        private static void LoadParseInfo()
        {
            s_htParseInfo = new Hashtable();

            //  Create path to ParseInfo.txt, which must be in the same directory
            //  as WebServicesTransform.exe

            string sParseInfoFile;
            sParseInfoFile = Assembly.GetExecutingAssembly().Location;
            sParseInfoFile = Path.GetDirectoryName(sParseInfoFile);
            sParseInfoFile = Path.Combine(sParseInfoFile, "ParseInfo.txt");
            if(!File.Exists(sParseInfoFile))
                throw new ApplicationException("Could not find ParseInfo.txt in same directory as WebServicesTransform.exe.");

            using(StreamReader srParseInfo = new StreamReader(sParseInfoFile))
            {
                string sLine;
                for(sLine = srParseInfo.ReadLine(); sLine != null; sLine = srParseInfo.ReadLine())
                {
                    sLine = sLine.Trim();
                    if(sLine.Substring(0,1) == ";") continue;

                    ParseInfo pi = ParseInfo.Parse(sLine);

                    //
                    //  Make sure we're not duplicating an ordinal
                    //

                    foreach(DictionaryEntry e in s_htParseInfo)
                    {
                        ParseInfo pInList = (ParseInfo)e.Value;

                        if(pInList.Ordinal == pi.Ordinal &&
                           pInList.Ordinal != 0)
                            throw new Exception("Duplicate ordinals in ParseInfo.txt!");
                    }

                    s_htParseInfo.Add(pi.SubTag + pi.Tag, pi);
                }
            }
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            if(args.Length != 2)
            {
                Console.WriteLine("WebServicesTransformApp <inputfiles> <outputfile>");
                return;
            }

            if(File.Exists(args[1]))
            {
                File.Delete(args[1]);
            }

            //
            //  Load parse info
            //

            try
            {
                LoadParseInfo();
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                return;
            }

            //
            //  Split out any directory info from <inputfiles>
            //

            string srcFiles = Path.GetFileName(args[0]);
            string dirName = Path.GetDirectoryName(args[0]);

            if(!Path.IsPathRooted(dirName))
                dirName = Path.Combine(System.Environment.CurrentDirectory, dirName);

            Console.WriteLine("Transforming files matching \"" + srcFiles + "\" from \"" + dirName + "\"");

            string [] files = Directory.GetFiles(dirName, srcFiles);
            DateTime dtIDTBase = (new DateTime(2002, 1, 1, 0, 0, 0, 0));

            //
            //  Open BCP file for output
            //

            s_aUnmatchedLogTypes = new SortedList();
            s_aBadFormatLines = new ArrayList();

            using(StreamWriter bcpFile = File.CreateText(args[1]))
            {
                //
                //  Process all input files
                //

                foreach(string fileName in files)
                {
                    using(StreamReader sr = File.OpenText(fileName))
                    {
                        string line;
                        int iServerNum = Int32.Parse(Path.GetFileName(fileName).Substring(4,3));

                        for(line = sr.ReadLine(); line != null; line = sr.ReadLine())
                        {
                            int iIDTWhen;
                            string sSubject = "";
                            int iOperation = 0;
                            int iTitleId = -1;
                            long biRequestId = 0;
                            int iClientIP = 0;
                            short siClientPort = 0;
                            DateTime dt;
                            int iMS;

                            try
                            {
                                string tag;
                                string [] elements = line.Split('|');
                                if(elements.Length < 2) throw new Exception("Each line must have at least two fields");

                                //  If unknown line type, add it to the list that we print out
                                //  at the end.  All log lines types, even those we're ignoring,
                                //  should be represented in parseinfo.txt.

                                if(s_htParseInfo.ContainsKey(elements[1]))
                                    tag = elements[1];
                                else if(s_htParseInfo.ContainsKey(elements[2] + elements[1]))
                                    tag = elements[2] + elements[1];
                                else
                                {
                                    if(!s_aUnmatchedLogTypes.ContainsKey(elements[1]))
                                        s_aUnmatchedLogTypes.Add(elements[1], fileName);
                                    continue;
                                }

                                //  Get parse info for this line, and make sure
                                //  the line has the correct number of fields.
                                ParseInfo pi = (ParseInfo)(s_htParseInfo[tag]);

                                //  Should we ignore this log line type?
                                if(pi.Ordinal == 0)
                                    continue;

                                //  Does the log line have the expected number of fields?
                                if(pi.NumFields != elements.Length) throw new Exception("Incorrect number of fields");

                                //
                                //  Compute time stamp.
                                //

                                string [] dateParts = elements[0].Split('.');
                                if(dateParts.Length != 2) throw new Exception("Invalid date/time stamp");

                                dt = DateTime.ParseExact(dateParts[0], "yyyy/MM/dd HH:mm:ss", null).ToLocalTime();
                                iMS = Int32.Parse(dateParts[1]);

                                TimeSpan t = dt - dtIDTBase;
                                iIDTWhen = -2147483648 + ( (int)t.TotalSeconds * 10 ) + ( ( iMS + 50 ) / 100 );

                                //
                                //  Parse other line elements
                                //

                                //  If this line has a result field, and it specifies a failure
                                //  then just continue.  Nothing wrong with the line, but we
                                //  don't want to report on it either.

                                if(pi.ResultField != -1 && elements[pi.ResultField] != pi.SuccessString)
                                    continue;
                            
                                iOperation = pi.Ordinal;
                                
                                try
                                {
                                    iTitleId = ( pi.TitleIdField == -1 ? -1 : (int)(UInt32.Parse(elements[pi.TitleIdField], NumberStyles.HexNumber)));
                                }
                                catch(Exception)
                                {
                                    // fall back to decimal title id if it isn't in hex.  Some
                                    // stats widget log lines had the title id in decimal.
                                    // Don't need to recheck for -1 here.  If if threw it couldn't have
                                    // been -1.
                                    iTitleId = (int)(UInt32.Parse(elements[pi.TitleIdField]));
                                }

                                sSubject = (pi.SubjectField != -1 ? elements[pi.SubjectField] : "");
                                biRequestId = (pi.RequestIdField != -1 ? (long)(UInt64.Parse(elements[pi.RequestIdField], NumberStyles.HexNumber)) : 0);
        
                                if(pi.IPAddrField != -1)
                                    ParseIPPort(elements[pi.IPAddrField], out iClientIP, out siClientPort);
                                else
                                {
                                    iClientIP = 0;
                                    siClientPort = 0;
                                }

                                bcpFile.WriteLine("{0},{1},{2},{3},{4},{5},{6},{7}",
                                    iIDTWhen,
                                    sSubject,
                                    iOperation,
                                    iTitleId,
                                    biRequestId,
                                    iClientIP,
                                    siClientPort,
                                    iServerNum);
                            }
                            catch(Exception e)
                            {
                                s_aBadFormatLines.Add(fileName + "(\"" + line + "\"):  " + e.Message);
                            }
                        }
                    }
                }

                if(s_aUnmatchedLogTypes.Count != 0)
                {
                    Console.WriteLine("Found the following unknown log line types in these files:");
                    foreach(DictionaryEntry entry in s_aUnmatchedLogTypes)
                    {
                        Console.WriteLine(entry.Key + ":  " + entry.Value);
                    }
                    Console.WriteLine("");
                }

                if(s_aBadFormatLines.Count != 0)
                {
                    Console.WriteLine("Found the following lines whose format did not match parseinfo.txt:");
                    foreach(string s in s_aBadFormatLines)
                    {
                        Console.WriteLine(s);
                    }
                    Console.WriteLine(s_aBadFormatLines.Count + " Total Errors\r\n");
                }
            }
        } // Main()
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xlreports\KilledTransform\KilledTransformApp.cs ===
using System;
using System.Globalization;
using System.IO;

namespace xonline.tools.xlreports.killedtransform 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class KilledTransformApp
	{
        private const int NUM_KIA_FIELDS = 13;

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            if(args.Length != 2)
            {
                Console.WriteLine("KilledTransform <inputfiles> <outputfile>");
                return;
            }

            if(File.Exists(args[1]))
            {
                File.Delete(args[1]);
            }

            StreamWriter bcpFile = File.CreateText(args[1]);

            //
            //  Split out any directory info from <inputfiles>
            //
            string srcFiles = Path.GetFileName(args[0]);
            string dirName = Path.GetDirectoryName(args[0]);

            if(!Path.IsPathRooted(dirName))
                dirName = Path.Combine(System.Environment.CurrentDirectory, dirName);

            Console.WriteLine("Transforming files matching \"" + srcFiles + "\" from \"" + dirName + "\"");

            string [] files = Directory.GetFiles(dirName, srcFiles);
            DateTime dtIDTBase = (new DateTime(2002, 1, 1, 0, 0, 0, 0));

            
            foreach(string fileName in files)
            {
                string line;
                StreamReader sr = File.OpenText(fileName);
                
                int iServerNum = Int32.Parse(Path.GetFileName(fileName).Substring(4,3));

                line = sr.ReadLine();
                while(line != null)
                {
                    string [] elements = line.Split('|');
                    if(elements.Length == NUM_KIA_FIELDS && elements[1] == "KIA")
                    {
                        string [] dateParts = elements[0].Split('.');

                        DateTime dtLogTime = DateTime.ParseExact(dateParts[0], "yyyy/MM/dd HH:mm:ss", null);
                        DateTime dtLocalTime = dtLogTime.ToLocalTime();

                        int iMS = Int32.Parse(dateParts[1]);
                        TimeSpan t = dtLocalTime - dtIDTBase;

                        int iIDTEnd = -2147483648 + ( (int)t.TotalSeconds * 10 ) + ( ( iMS + 50 ) / 100 );
                        int iDuration = Int32.Parse(elements[12], NumberStyles.HexNumber);
                        int iIDTStart = iIDTEnd - (iDuration < 50 ? 1 : (iDuration + 50)/100);

                        long ulUserID = Int64.Parse(elements[6], NumberStyles.HexNumber);
                        int iTitleID = Int32.Parse(elements[7], NumberStyles.HexNumber);
                        long ulSessionID = Int64.Parse(elements[3], NumberStyles.HexNumber);
                        int iXboxIP = Int32.Parse(elements[10], NumberStyles.HexNumber);

                        if(iTitleID != 0) // web users come in with title id == 0, ignore them
                        {
                            bcpFile.WriteLine("{0},{1},{2},{3},0,{4},{5},{6}",
                                iIDTStart,
                                iIDTEnd,
                                iTitleID,
                                ulUserID,
                                ulSessionID,
                                iServerNum,
                                iXboxIP);
                        }
                    }

                    line = sr.ReadLine();
                }

                sr.Close();
            }

            bcpFile.Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_common_3_none_12.4.56.0_none_c68470f7db432002
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.manifest
XP_MANIFEST_PATH=manifests\msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.cat
XP_CATALOG_PATH=manifests\msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.cat
XP_PAYLOAD_PATH=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_3,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_common_3_none_12.4.56.0_none_c68470f7db432002
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.manifest
XP_MANIFEST_PATH=manifests\msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.cat
XP_CATALOG_PATH=manifests\msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2.cat
XP_PAYLOAD_PATH=msil_common_3_no-public-key_12.4.56.0_x-ww_5f01e4a2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_3,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\msi\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\msi\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xltrans_none_12.4.56.0_none_32c180a6675cf1fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xltrans
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.manifest
XP_MANIFEST_PATH=manifests\x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.cat
XP_CATALOG_PATH=manifests\x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.cat
XP_PAYLOAD_PATH=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xltrans,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\msi\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xltrans_none_12.4.56.0_none_32c180a6675cf1fe
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xltrans
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.manifest
XP_MANIFEST_PATH=manifests\x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.cat
XP_CATALOG_PATH=manifests\x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a.cat
XP_PAYLOAD_PATH=x86_xltrans_no-public-key_12.4.56.0_x-ww_d3b6678a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xltrans,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\BaseAsyncResult.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace xonline.tools.xltrans.service
{
    internal class BaseAsyncResult : IAsyncResult
    {
        private EventWaitHandle _completeEvent;
        private Boolean _isComplete;
        private Object _state;
        private AsyncCallback _callback;
        public Exception Exception;
        public Object Return;
        public Object Buffer;
        public int Offset;

        public object AsyncState
        {
            get { return _state; }
        }

        public WaitHandle AsyncWaitHandle
        {
            get { return _completeEvent; }
        }

        public bool CompletedSynchronously
        {
            get { return false; }
        }

        public bool IsCompleted
        {
            get { return _isComplete; }
        }

        public BaseAsyncResult(AsyncCallback callback, Object state)
        {
            _completeEvent = new EventWaitHandle(false, EventResetMode.ManualReset);
            _isComplete = false;
            _callback = callback;
            _state = state;
            Exception = null;
            Return = null;
            Buffer = null;
            Offset = 0;
        }

        public void Complete()
        {
            _isComplete = true;
            _completeEvent.Set();
            if (_callback != null)
            {
                _callback(this);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SFtpStream.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading;

namespace xonline.tools.xltrans.service
{
    public class SFtpStream : Stream, IDisposable
    {
        private long _position;
        private SFtpHandle _handle;
        private SFtpSession _session;
        private bool _canRead, _canWrite, _closed;

        public override bool CanRead
        {
            get { return _canRead; }
        }

        public override bool CanSeek
        {
            get { return true; }
        }

        public override bool CanWrite
        {
            get { return _canWrite; }
        }

        public override void Flush()
        {
        }

        public override long Length
        {
            get { throw new Exception("The method or operation is not implemented."); }
        }

        public override long Position
        {
            get
            {
                return (long)_position;
            }
            set
            {
                Interlocked.Exchange(ref _position, value);
            }
        }

        public SFtpStream(SFtpSession session, String filename, FileMode mode, FileAccess access)
        {
            SFtpOpenFlags openFlags = 0;
            switch (mode)
            {
                case FileMode.Append:
                    openFlags |= SFtpOpenFlags.Append;
                    break;
                case FileMode.Create:
                    openFlags |= SFtpOpenFlags.Create;
                    openFlags |= SFtpOpenFlags.Truncate;
                    break;
                case FileMode.CreateNew:
                    openFlags |= SFtpOpenFlags.Create;
                    openFlags |= SFtpOpenFlags.Exclusive;
                    break;
                case FileMode.Open:
                    break;
                case FileMode.OpenOrCreate:
                    openFlags |= SFtpOpenFlags.Create;
                    break;
                case FileMode.Truncate:
                    openFlags |= SFtpOpenFlags.Create;
                    openFlags |= SFtpOpenFlags.Truncate;
                    break;
            }

            switch (access)
            {
                case FileAccess.Read:
                    openFlags |= SFtpOpenFlags.Read;
                    _canRead = true;
                    _canWrite = false;
                    break;
                case FileAccess.Write:
                    openFlags |= SFtpOpenFlags.Write;
                    _canWrite = true;
                    _canRead = false;
                    break;
                case FileAccess.ReadWrite:
                    openFlags |= SFtpOpenFlags.Read;
                    openFlags |= SFtpOpenFlags.Write;
                    _canRead = true;
                    _canWrite = true;
                    break;
            }

            _handle = session.OpenFile(filename, openFlags);
            _session = session;
            _position = 0;
            _closed = false;

        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, Object asyncState)
        {
            long position = Interlocked.Add(ref _position, count) - count;
            return _session.BeginReadFile(_handle, (ulong)position, buffer, offset, count, asyncCallback, asyncState);
        }

        public override int EndRead(IAsyncResult ar)
        {
            int len = _session.EndReadFile(ar);

            return len;
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            long position = Interlocked.Add(ref _position, count) - count;
            int len = _session.ReadFile(_handle, (ulong)position, buffer, offset, count);

            return len;
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            switch (origin)
            {
                case SeekOrigin.Begin:
                    Interlocked.Exchange(ref _position, offset);
                    break;
                case SeekOrigin.Current:
                    Interlocked.Add(ref _position, offset);
                    break;
                case SeekOrigin.End:
                    throw new Exception("The method or operation is not implemented.");
            }
            return (long)_position;
        }

        public override void SetLength(long value)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, Object asyncState)
        {
            IAsyncResult ar;

            long position = Interlocked.Add(ref _position, count) - count;
            ar = _session.BeginWriteFile(_handle, (ulong)position, buffer, offset, count, asyncCallback, asyncState);

            return ar;
        }

        public override void EndWrite(IAsyncResult ar)
        {
            _session.EndWriteFile(ar);
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            long position = Interlocked.Add(ref _position, count)-count;
            _session.WriteFile(_handle, (ulong)position, buffer, offset, count);
        }

        public override void Close()
        {
            if (_closed)
                return;

            _session.CloseFile(_handle);
            _closed = true;
        }

        void IDisposable.Dispose()
        {
            Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SFtpPacketReader.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading;
using System.Reflection;

namespace xonline.tools.xltrans.service
{
    internal class SFtpPacketReader
    {
        static private Dictionary<SFtpPacketType, Type> _typemap;
        static private Assembly _current;

        static SFtpPacketReader()
        {
            _typemap = new Dictionary<SFtpPacketType, Type>();
            _current = Assembly.GetExecutingAssembly();

            foreach (Type type in _current.GetTypes())
            {
                if (!type.IsSubclassOf(typeof(SFtpPacket)))
                    continue;

                SFtpPacketInfo[] info = (SFtpPacketInfo[])type.GetCustomAttributes(typeof(SFtpPacketInfo), false);
                if (info == null || info.Length == 0)
                    continue;

                _typemap[info[0].Type] = type;
            }
        }

        private Stream _stream;
        private Byte[] _buffer;
        private int _index, _size;
        public SFtpPacketType _packettype;

        public SFtpPacketType PacketType { get { return _packettype; } }

        public SFtpPacketReader(Stream stream)
        {
            _stream = stream;
            _index = 0;
            _size = 0;
            _buffer = new Byte[64];
        }

        public SFtpPacket ReadPacket()
        {
            IAsyncResult ar = BeginReadPacket(null, null);
            return EndReadPacket(ar);
        }

        public IAsyncResult BeginReadPacket(AsyncCallback callback, Object state)
        {
            BaseAsyncResult bar = new BaseAsyncResult(callback, state);

            _index = 0;
            _size = 0;
            _buffer = new Byte[4];
            _stream.BeginRead(_buffer, 0, 4, ReadPacketLengthLoop, bar);

            return bar;
        }

        private void ReadPacketLengthLoop(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar.AsyncState;
            try
            {
                int got = _stream.EndRead(ar);

                _index += got;
                if (got == 0)
                {
                    bar.Exception = new EndOfStreamException();
                    bar.Complete();
                    return;
                }

                if (_index < 4)
                {
                    _stream.BeginRead(_buffer, _index, 4 - _index, ReadPacketLengthLoop, bar);
                    return;
                }

                _size |= ((Int32)_buffer[0]) << 24;
                _size |= ((Int32)_buffer[1]) << 16;
                _size |= ((Int32)_buffer[2]) << 8;
                _size |= ((Int32)_buffer[3]);

                if (_size + 4 > _buffer.Length)
                    Array.Resize(ref _buffer, _size + 4);

                _stream.BeginRead(_buffer, _index, _size + 4 - _index, ReadPacketLoop, bar);
            }
            catch (Exception ex)
            {
                bar.Exception = ex;
                bar.Complete();
                return;
            }
        }
        private void ReadPacketLoop(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar.AsyncState;
            int got = _stream.EndRead(ar);

            _index += got;
            if (got == 0)
            {
                bar.Exception = new EndOfStreamException();
                bar.Complete();
                return;
            }

            if (_index < _size + 4)
            {
                _stream.BeginRead(_buffer, _index, _size + 4 - _index, ReadPacketLoop, bar);
                return;
            }

            _index = 4;
            _packettype = (SFtpPacketType)ReadByte();


            SFtpPacket packet = (SFtpPacket)_current.CreateInstance(_typemap[_packettype].FullName);
            try
            {
                packet.Deserialize(this);
            }
            catch (IndexOutOfRangeException)
            {
            }
            bar.Return = packet;

            bar.Complete();
        }

        public SFtpPacket EndReadPacket(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();
            if (bar.Exception != null)
                throw bar.Exception;

            return (SFtpPacket)bar.Return;
        }

        public Byte ReadByte()
        {
            return _buffer[_index++];
        }
        public UInt32 ReadUInt32()
        {
            UInt32 u = 0;

            u |= ((UInt32)_buffer[_index++]) << 24;
            u |= ((UInt32)_buffer[_index++]) << 16;
            u |= ((UInt32)_buffer[_index++]) << 8;
            u |= ((UInt32)_buffer[_index++]);

            return u;
        }
        public UInt64 ReadUInt64()
        {
            UInt64 u = 0;

            u |= ((UInt32)_buffer[_index++]) << 56;
            u |= ((UInt32)_buffer[_index++]) << 40;
            u |= ((UInt32)_buffer[_index++]) << 40;
            u |= ((UInt32)_buffer[_index++]) << 32;
            u |= ((UInt32)_buffer[_index++]) << 24;
            u |= ((UInt32)_buffer[_index++]) << 16;
            u |= ((UInt32)_buffer[_index++]) << 8;
            u |= ((UInt32)_buffer[_index++]);

            return u;
        }
        public String[] ReadPair()
        {
            String[] pair = new String[2];
            pair[0] = ReadString();
            pair[1] = ReadString();

            return pair;
        }
        public String ReadString()
        {
            Byte[] str;
            UInt32 len;

            len = ReadUInt32();
            str = ReadArray(len);

            return System.Text.Encoding.UTF8.GetString(str);
        }
        public Byte[] ReadBytes()
        {
            UInt32 length = ReadUInt32();
            return ReadArray(length);
        }
        public int ReadBytes(Byte[] buffer, int offset)
        {
            UInt32 length = ReadUInt32();
            ReadArray(buffer, offset, length);
            return (int)length;
        }
        public SFtpFileAttributes ReadAttrib()
        {
            SFtpFileAttributes attribs = new SFtpFileAttributes();

            attribs.AttributeFlags = (SFtpAttributeFlags)ReadUInt32();
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.Size)) != 0)
            {
                attribs.Size = ReadUInt64();
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.UidGid)) != 0)
            {
                attribs.UId = ReadUInt32();
                attribs.GId = ReadUInt32();
            }

            if ((attribs.AttributeFlags & (SFtpAttributeFlags.Permissions)) != 0)
            {
                attribs.Permissions = ReadUInt32();
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.ACModTime)) != 0)
            {
                attribs.AccessTime = ReadUInt32();
                attribs.ModifiedTime = ReadUInt32();
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.Extended)) != 0)
            {
                attribs.extended_count = ReadUInt32();

                attribs.extensions = new string[attribs.extended_count][];
                for (int i = 0; i < attribs.extended_count; i++)
                {
                    attribs.extensions[i] = new string[2];
                    attribs.extensions[i][0] = ReadString();
                    attribs.extensions[i][1] = ReadString();
                }
            }

            return attribs;
        }
        private Byte[] ReadArray(UInt32 len)
        {
            Byte[] array = new Byte[len];

            Array.Copy(_buffer, _index, array, 0, len);
            _index += array.Length;

            return array;
        }
        private void ReadArray(Byte[] array, int offset, UInt32 len)
        {
            Array.Copy(_buffer, _index, array, offset, len);
            _index += array.Length;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SFtpPacketWriter.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace xonline.tools.xltrans.service
{
    internal class SFtpPacketWriter
    {
        Stream _stream;
        Byte[] _buffer;
        int _index;

        public SFtpPacketWriter(Stream stream)
        {
            _buffer = new Byte[32];
            _index = 4;
            _stream = stream;
        }

        public void WritePacket(SFtpPacket packet)
        {
            lock (_stream)
            {
                _index = 4;
                WriteByte((Byte)packet.Type);
                packet.Serialize(this);
                WriteSize();
                _stream.Write(_buffer, 0, _index);
                _stream.Flush();
            }
        }

        public void WriteByte(Byte b)
        {
            _buffer[_index++] = b;
            if (_index == _buffer.Length)
            {
                Array.Resize(ref _buffer, _index + _index);
            }
        }

        public void WriteUInt32(UInt32 u)
        {
            WriteByte((byte)((u >> 24) & 0xff));
            WriteByte((byte)((u >> 16) & 0xff));
            WriteByte((byte)((u >> 8) & 0xff));
            WriteByte((byte)((u) & 0xff));
        }

        public void WriteSize()
        {
            UInt32 u = (UInt32)_index - 4;

            _buffer[0] = (byte)((u >> 24) & 0xff);
            _buffer[1] = (byte)((u >> 16) & 0xff);
            _buffer[2] = (byte)((u >> 8) & 0xff);
            _buffer[3] = (byte)((u) & 0xff);
        }

        public void WriteUInt64(UInt64 u)
        {
            WriteByte((byte)((u >> 56) & 0xff));
            WriteByte((byte)((u >> 40) & 0xff));
            WriteByte((byte)((u >> 40) & 0xff));
            WriteByte((byte)((u >> 32) & 0xff));
            WriteByte((byte)((u >> 24) & 0xff));
            WriteByte((byte)((u >> 16) & 0xff));
            WriteByte((byte)((u >> 8) & 0xff));
            WriteByte((byte)((u) & 0xff));
        }

        public void WritePair(string name, string data)
        {
            WriteString(name);
            WriteString(data);
        }

        public void WriteString(String s)
        {
            if (s != null)
            {
                Byte[] str = System.Text.Encoding.UTF8.GetBytes(s);
                WriteUInt32((UInt32)str.Length);
                WriteArray(str);
            }
            else
            {
                WriteUInt32(0);
            }
        }

        public void WriteBytes(Byte[] array)
        {
            if (array == null)
                WriteBytes(new byte[0], 0, 0);
            else
                WriteBytes(array, 0, array.Length);
        }

        public void WriteBytes(Byte[] array, int size)
        {
            WriteBytes(array, 0, size);
        }

        public void WriteBytes(Byte[] array, int offset, int size)
        {
            if (array == null)
            {
                array = new byte[size];
            }
            WriteUInt32((UInt32)size);
            WriteArray(array, offset, size);
        }

        public void WriteAttrib(SFtpFileAttributes attribs)
        {
            WriteUInt32((UInt32)attribs.AttributeFlags);
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.Size)) != 0)
            {
                WriteUInt64(attribs.Size);
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.UidGid)) != 0)
            {
                WriteUInt32(attribs.UId);
                WriteUInt32(attribs.GId);
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.Permissions)) != 0)
            {
                WriteUInt32(attribs.Permissions);
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.ACModTime)) != 0)
            {
                WriteUInt32(attribs.AccessTime);
                WriteUInt32(attribs.ModifiedTime);
            }
            if ((attribs.AttributeFlags & (SFtpAttributeFlags.Extended)) != 0)
            {
                WriteUInt32(attribs.extended_count);
                for (int i = 0; i < attribs.extended_count; i++)
                {
                    WriteString(attribs.extensions[i][0]);
                    WriteString(attribs.extensions[i][1]);
                }
            }
        }

        private void WriteArray(Byte[] array, int offset, int size)
        {
            while (_buffer.Length < size + _index)
                Array.Resize(ref _buffer, _buffer.Length + _buffer.Length);
            Array.Copy(array, offset, _buffer, _index, size);
            _index += size;
        }

        private void WriteArray(Byte[] array)
        {
            while (_buffer.Length < array.Length + _index)
                Array.Resize(ref _buffer, _buffer.Length + _buffer.Length);
            Array.Copy(array, 0, _buffer, _index, array.Length);
            _index += array.Length;
        }

        public void Dispose()
        {
            try
            {
                lock (_stream)
                {
            WriteSize();
                    _stream.Write(_buffer, 0, _index);
                    _stream.Flush();
                }
            }
            catch (ObjectDisposedException)
            {
                //throw new SFTPException(6, "Connection closed.");
            }
            finally
            {

                _buffer = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SFtpSession.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading;

namespace xonline.tools.xltrans.service
{
    public class SFtpSession
    {
        #region Private Variables
        private Stream _stream;
        private int _connected;
        private SFtpPacketReader _packetReader;
        private SFtpPacketWriter _packetWriter;
        private Dictionary<int, BaseAsyncResult> _returnResult;
        private List<SFtpHandle> _openHandles;
        private int _requestId;
        #endregion
        #region Constructor/Destructor
        public SFtpSession(Stream stream)
        {
            if (!stream.CanRead || !stream.CanWrite)
                throw new ArgumentException("SFtpSession requires a transport stream that can read and write.");
            Interlocked.Exchange(ref _connected, 0);

            SFtpPacketInit initPacket;
            SFtpPacketVersion versionPacket;

            _returnResult = new Dictionary<int, BaseAsyncResult>();
            _openHandles = new List<SFtpHandle>();
            _packetReader = new SFtpPacketReader(stream);
            _stream = stream;
            Interlocked.Exchange(ref _connected, 1);
            _requestId = 0;

            _packetWriter = new SFtpPacketWriter(_stream);
            initPacket = new SFtpPacketInit();
            initPacket.Version = 3;
            _packetWriter.WritePacket(initPacket);

            versionPacket = (SFtpPacketVersion)_packetReader.ReadPacket();

            _packetReader.BeginReadPacket(ReturnPacketProcessor, null);
        }
        ~SFtpSession()
        {
            CloseSession();
        }
        #endregion
        #region Properties
        public Boolean Connected { get { return _connected==1; } }
        #endregion
        #region CreateDirectory
        public void CreateDirectory(String path)
        {
            IAsyncResult ar = BeginCreateDirectory(path, null, null, null);
            EndCreateDirectory(ar);
        }

        public void CreateDirectory(String path, SFtpFileAttributes attributes)
        {
            IAsyncResult ar = BeginCreateDirectory(path, attributes, null, null);
            EndCreateDirectory(ar);
        }

        public IAsyncResult BeginCreateDirectory(String path, SFtpFileAttributes attributes, AsyncCallback callback, Object state)
        {
            if (_connected==0)                
                throw new SFtpSessionDisconnectedException(String.Format("BeginCreateDirectory, SFTP Transport Layer Disconnected, path: [{0}]", path == null ? "null" : path.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketCreateDirectory packet = new SFtpPacketCreateDirectory();

            if (attributes == null)
                attributes = new SFtpFileAttributes();

            packet.RequestId = NextRequestId(bar);
            packet.Path = path;
            packet.Attributes = attributes;
            _packetWriter.WritePacket(packet);

            return bar;
        }

        public void EndCreateDirectory(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (uint)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;

                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region RemoveDirectory
        public void RemoveDirectory(String path)
        {
            IAsyncResult ar = BeginRemoveDirectory(path, null, null);
            EndRemoveDirectory(ar);
        }

        public IAsyncResult BeginRemoveDirectory(String path, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginRemoveDirectory, SFTP Transport Layer Disconnected, path: [{0}]", path == null ? "null" : path.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketRemoveDirectory packet = new SFtpPacketRemoveDirectory();


            packet.RequestId = NextRequestId(bar);
            packet.FileName = path;
            _packetWriter.WritePacket(packet);

            return bar;
        }

        public void EndRemoveDirectory(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (uint)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region RemoveFile
        public void RemoveFile(String path)
        {
            IAsyncResult ar = BeginRemoveFile(path, null, null);
            EndRemoveFile(ar);
        }

        public IAsyncResult BeginRemoveFile(String path, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginRemoveFile, SFTP Transport Layer Disconnected, path: [{0}]", path == null ? "null" : path.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketRemoveFile packet = new SFtpPacketRemoveFile();


            packet.RequestId = NextRequestId(bar);
            packet.FileName = path;
            _packetWriter.WritePacket(packet);

            return bar;
        }

        public void EndRemoveFile(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (uint)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region GetAttributes
        public SFtpFileAttributes GetAttributes(string filename)
        {
            IAsyncResult ar = BeginGetAttributes(filename, null, null);
            return EndGetAttributes(ar);
        }
        public IAsyncResult BeginGetAttributes(string filename, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginGetAttributes, SFTP Transport Layer Disconnected, filename: [{0}]", filename == null ? "null" : filename.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketFileStat packet = new SFtpPacketFileStat();

            packet.RequestId = NextRequestId(bar);
            packet.Path = filename;
            _packetWriter.WritePacket(packet);

            return bar;
        }
        public SFtpFileAttributes EndGetAttributes(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_ATTRS:
                    SFtpPacketAttrs attrib = (SFtpPacketAttrs)bar.Return;
                    return attrib.Attributes;
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region Rename
        public void Rename(string oldpath, string newpath)
        {
            IAsyncResult ar = BeginRename(oldpath, newpath, null, null);
            EndRename(ar);
        }
        public IAsyncResult BeginRename(string oldpath, string newpath, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginRename, SFTP Transport Layer Disconnected, oldpath: [{0}], newpath: [{1}]", oldpath == null ? "null" : oldpath.ToString(),
                                                                                                                                                           newpath == null ? "null" : newpath.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketRename packet = new SFtpPacketRename();

            packet.RequestId = NextRequestId(bar);
            packet.NewPath = newpath;
            packet.OldPath = oldpath;
            _packetWriter.WritePacket(packet);

            return bar;
        }
        public void EndRename(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (uint)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;

                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region OpenFile
        public SFtpHandle OpenFile(string filename, SFtpOpenFlags flags)
        {
            return OpenFile(filename, flags, null);
        }
        public SFtpHandle OpenFile(string filename, SFtpOpenFlags flags, SFtpFileAttributes attributes)
        {
            IAsyncResult ar = BeginOpenFile(filename, flags, attributes, null, null);
            return EndOpenFile(ar);
        }

        public IAsyncResult BeginOpenFile(string filename, SFtpOpenFlags flags, AsyncCallback callback, Object state)
        {
            return BeginOpenFile(filename, flags, null, callback, state);
        }

        public IAsyncResult BeginOpenFile(string filename, SFtpOpenFlags flags, SFtpFileAttributes attributes, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginOpenFile, SFTP Transport Layer Disconnected, filename: [{0}]", filename == null ? "null" : filename.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketOpenFile packet = new SFtpPacketOpenFile();

            packet.RequestId = NextRequestId(bar);
            packet.FileName = filename;
            packet.Flags = flags;
            packet.Attributes = (attributes == null) ? new SFtpFileAttributes() : attributes;
            _packetWriter.WritePacket(packet);

            return bar;
        }

        private SFtpHandle EndOpenFile(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_HANDLE:
                    SFtpPacketHandle handle = (SFtpPacketHandle)packet;
                    return handle.Handle;
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region ReadFile
        public int ReadFile(SFtpHandle handle, UInt64 position, Byte[] buffer, int offset, int len)
        {
            IAsyncResult ar = BeginReadFile(handle, position, buffer, offset, len, null, null);
            return EndReadFile(ar);
        }

        public IAsyncResult BeginReadFile(SFtpHandle handle, ulong position, byte[] buffer, int offset, int len, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginReadFile, SFTP Transport Layer Disconnected"));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketReadFile packet = new SFtpPacketReadFile();

            packet.RequestId = NextRequestId(bar);
            packet.Handle = handle;
            packet.Length = (UInt32)len;
            packet.Position = position;
            bar.Buffer = buffer;
            bar.Offset = offset;

            _packetWriter.WritePacket(packet);

            return bar;
        }

        public int EndReadFile(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;
            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_DATA:
                    SFtpPacketData data = (SFtpPacketData)bar.Return;
                    Array.Copy(data.Data, 0, (Byte[])bar.Buffer, bar.Offset, data.Data.Length);
                    return data.Data.Length;
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (UInt32)SFtpErrorCodes.SSH_FX_EOF)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    return 0;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region WriteFile
        public void WriteFile(SFtpHandle handle, UInt64 position, Byte[] buffer, int offset, int len)
        {
            IAsyncResult ar = BeginWriteFile(handle, position, buffer, offset, len, null, null);
            EndWriteFile(ar);
        }


        public IAsyncResult BeginWriteFile(SFtpHandle handle, UInt64 position, Byte[] buffer, int offset, int len, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginWriteFile, SFTP Transport Layer Disconnected"));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketWriteFile packet = new SFtpPacketWriteFile();

            packet.RequestId = NextRequestId(bar);
            packet.Handle = handle;
            packet.Position = position;
            packet.Data = buffer;
            packet.Offset = offset;
            packet.Length = len;

            _packetWriter.WritePacket(packet);

            return bar;
        }
        public void EndWriteFile(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (UInt16)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region CloseFile
        public void CloseFile(SFtpHandle handle)
        {
            IAsyncResult ar = BeginCloseFile(handle, null, null);
            EndCloseFile(ar);
        }

        public IAsyncResult BeginCloseFile(SFtpHandle handle, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginCloseFile, SFTP Transport Layer Disconnected"));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketClose packet = new SFtpPacketClose();

            packet.RequestId = NextRequestId(bar);
            packet.Handle = handle;
            _packetWriter.WritePacket(packet);

            return bar;
        }
        public void EndCloseFile(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;
            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (UInt16)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region OpenDirectory
        public SFtpHandle OpenDirectory(string filename)
        {
            IAsyncResult ar = BeginOpenDirectory(filename, null, null);
            return EndOpenDirectory(ar);
        }

        public IAsyncResult BeginOpenDirectory(string filename, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginOpenDirectory, SFTP Transport Layer Disconnected, filename: [{0}]", filename == null ? "null" : filename.ToString()));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketOpenDirectory packet = new SFtpPacketOpenDirectory();

            packet.RequestId = NextRequestId(bar);
            packet.FileName = filename;
            _packetWriter.WritePacket(packet);

            return bar;
        }

        private SFtpHandle EndOpenDirectory(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;

            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_HANDLE:
                    SFtpPacketHandle handle = (SFtpPacketHandle)packet;
                    return handle.Handle;
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
#endregion
        #region ReadDirectory
        public SFtpFileInfo[] ReadDirectory(SFtpHandle handle)
        {
            IAsyncResult ar = BeginReadDirectory(handle, null, null);
            return EndReadDirectory(ar);
        }

        public IAsyncResult BeginReadDirectory(SFtpHandle handle, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginReadDirectory, SFTP Transport Layer Disconnected"));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketReadDirectory packet = new SFtpPacketReadDirectory();

            packet.RequestId = NextRequestId(bar);
            packet.Handle = handle;

            _packetWriter.WritePacket(packet);

            return bar;
        }

        public SFtpFileInfo[] EndReadDirectory(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;
            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_NAME:
                    SFtpPacketName data = (SFtpPacketName)bar.Return;
                    return data.Files;
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (UInt32)SFtpErrorCodes.SSH_FX_EOF)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    return null;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region CloseDirectory
        public void CloseDirectory(SFtpHandle handle)
        {
            IAsyncResult ar = BeginCloseDirectory(handle, null, null);
            EndCloseDirectory(ar);
        }
        public IAsyncResult BeginCloseDirectory(SFtpHandle handle, AsyncCallback callback, Object state)
        {
            if (_connected == 0)
                throw new SFtpSessionDisconnectedException(String.Format("BeginCloseDirectory, SFTP Transport Layer Disconnected"));

            BaseAsyncResult bar = new BaseAsyncResult(callback, state);
            SFtpPacketClose packet = new SFtpPacketClose();

            packet.RequestId = NextRequestId(bar);
            packet.Handle = handle;
            _packetWriter.WritePacket(packet);

            return bar;
        }
        public void EndCloseDirectory(IAsyncResult ar)
        {
            BaseAsyncResult bar = (BaseAsyncResult)ar;
            bar.AsyncWaitHandle.WaitOne();

            if (bar.Exception != null)
                throw bar.Exception;
            SFtpPacket packet = (SFtpPacket)bar.Return;
            switch (packet.Type)
            {
                case SFtpPacketType.SSH_FXP_STATUS:
                    SFtpPacketStatus status = (SFtpPacketStatus)packet;
                    if (status.ErrorCode != (UInt16)SFtpErrorCodes.SSH_FX_OK)
                        throw new SFtpSessionStatusException(status.ErrorCode, status.ErrorMessage);
                    break;
                default:
                    throw new SFtpSessionStatusException(SFtpErrorCodes.SSH_FX_BAD_MESSAGE, "Unexpected packet.");
            }
        }
        #endregion
        #region Request/Return Processing
        private UInt32 NextRequestId(BaseAsyncResult bar)
        {
            lock (_returnResult)
            {
                int RequestId = Interlocked.Increment(ref _requestId);
                _returnResult[RequestId] = bar;
                return (UInt32)RequestId;
            }
        }

        private BaseAsyncResult GetRequestResult(UInt32 RequestId)
        {
            lock (_returnResult)
            {
                if (!_returnResult.ContainsKey((int)RequestId))
                    return null;
                BaseAsyncResult bar = _returnResult[(int)RequestId];
                _returnResult.Remove((int)RequestId);
                return bar;
            }
        }

        private void ReturnPacketProcessor(IAsyncResult ar)
        {
            try
            {
                SFtpPacket packet = _packetReader.EndReadPacket(ar);
                _packetReader.BeginReadPacket(ReturnPacketProcessor, null);

                BaseAsyncResult bar = GetRequestResult(packet.RequestId);
                if (bar == null)
                    return;

                bar.Return = packet;
                bar.Complete();
            }
            catch
            {
                CloseSession();
            }
        }
        #endregion
        #region Close Session
        public void CloseSession()
        {
            Interlocked.Exchange(ref _connected, 0);
            _stream.Close();
            lock (_returnResult)
            {
                foreach (int requestId in _returnResult.Keys)
                {
                    _returnResult[requestId].Exception = new EndOfStreamException();
                    ThreadPool.QueueUserWorkItem(
                        delegate(object state)
                        {
                            try
                            {
                                ((BaseAsyncResult)state).Complete();
                            }
                            catch
                            {
                            }
                        },
                        _returnResult[requestId]);
                }
                _returnResult.Clear();
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SFtpPacket.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.xltrans.service
{
    internal enum SFtpPacketType : byte
    {
        SSH_FXP_INIT = 1,
        SSH_FXP_VERSION = 2,
        SSH_FXP_OPEN = 3,
        SSH_FXP_CLOSE = 4,
        SSH_FXP_READ = 5,
        SSH_FXP_WRITE = 6,
        SSH_FXP_LSTAT = 7,
        SSH_FXP_FSTAT = 8,
        SSH_FXP_SETSTAT = 9,
        SSH_FXP_FSETSTAT = 10,
        SSH_FXP_OPENDIR = 11,
        SSH_FXP_READDIR = 12,
        SSH_FXP_REMOVE = 13,
        SSH_FXP_MKDIR = 14,
        SSH_FXP_RMDIR = 15,
        SSH_FXP_REALPATH = 16,
        SSH_FXP_STAT = 17,
        SSH_FXP_RENAME = 18,
        SSH_FXP_READLINK = 19,
        SSH_FXP_SYMLINK = 20,
        SSH_FXP_STATUS = 101,
        SSH_FXP_HANDLE = 102,
        SSH_FXP_DATA = 103,
        SSH_FXP_NAME = 104,
        SSH_FXP_ATTRS = 105,
        SSH_FXP_EXTENDED = 200,
        SSH_FXP_EXTENDED_REPLY = 201
    }

    [Flags]
    public enum SFtpAttributeFlags : uint
    {
        Size = 0x00000001,
        UidGid = 0x00000002,
        Permissions = 0x00000004,
        ACModTime = 0x00000008,
        Extended = 0x80000000
    }

    [Flags]
    public enum SFtpOpenFlags : uint
    {
        Read = 0x00000001,
        Write = 0x00000002,
        Append = 0x00000004,
        Create = 0x00000008,
        Truncate = 0x00000010,
        Exclusive = 0x00000020,
    }

    public enum SFtpErrorCodes : uint
    {
        SSH_FX_OK = 0,
        SSH_FX_EOF = 1,
        SSH_FX_NO_SUCH_FILE = 2,
        SSH_FX_PERMISSION_DENIED = 3,
        SSH_FX_FAILURE = 4,
        SSH_FX_BAD_MESSAGE = 5,
        SSH_FX_NO_CONNECTION = 6,
        SSH_FX_CONNECTION_LOST = 7,
        SSH_FX_OP_UNSUPPORTED = 8,
    }

    public class SFtpFileAttributes
    {
        public SFtpAttributeFlags AttributeFlags;
        public UInt64 Size;
        public UInt32 UId, GId;
        public UInt32 Permissions;
        public UInt32 AccessTime;
        public UInt32 ModifiedTime;
        public UInt32 extended_count;
        public string[][] extensions;

        public SFtpFileAttributes()
        {
            AttributeFlags = 0;
        }
    }

    public class SFtpFileInfo
    {
        public String FileName;
        public String LongName;
        public SFtpFileAttributes Attributes;
    }

    public class SFtpHandle
    {
        public Byte[] handle;
    }

    internal class SFtpPacketInfo : Attribute
    {
        private SFtpPacketType _type;

        public SFtpPacketType Type { get { return _type; } }

        public SFtpPacketInfo(SFtpPacketType type)
        {
            _type = type;
        }
    }

    internal abstract class SFtpPacket
    {
        private SFtpPacketType _type;
        public UInt32 RequestId;

        public SFtpPacketType Type { get { return _type; } }

        public SFtpPacket(SFtpPacketType type)
        {
            _type = type;
        }
        public abstract void Deserialize(SFtpPacketReader reader);
        public abstract void Serialize(SFtpPacketWriter writer);
    }

    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_INIT)]
    internal class SFtpPacketInit : SFtpPacket
    {
        public UInt32 Version;
        public Dictionary<String, String> ExtensionData;

        public SFtpPacketInit() : base( SFtpPacketType.SSH_FXP_INIT)
        {
            ExtensionData = new Dictionary<string, string>();
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Version = reader.ReadUInt32();
            try
            {
                string name, data;

                name = reader.ReadString();
                data = reader.ReadString();

                ExtensionData.Add(name, data);
            }
            catch
            {
            }
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(Version);
            foreach (KeyValuePair<String, String> extension in ExtensionData)
            {
                writer.WriteString(extension.Key);
                writer.WriteString(extension.Value);
            }
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_VERSION)]
    internal class SFtpPacketVersion : SFtpPacket
    {
        public UInt32 Version;
        public Dictionary<String, String> ExtensionData;

        public SFtpPacketVersion()
            : base(SFtpPacketType.SSH_FXP_VERSION)
        {
            ExtensionData = new Dictionary<string, string>();
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Version = reader.ReadUInt32();
            try
            {
                string name, data;

                name = reader.ReadString();
                data = reader.ReadString();

                ExtensionData.Add(name, data);
            }
            catch
            {
            }
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(Version);
            foreach (KeyValuePair<String, String> extension in ExtensionData)
            {
                writer.WriteString(extension.Key);
                writer.WriteString(extension.Value);
            }
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_OPEN)]
    internal class SFtpPacketOpenFile : SFtpPacket
    {
        public String FileName;
        public SFtpOpenFlags Flags;
        public SFtpFileAttributes Attributes;

        public SFtpPacketOpenFile()
            : base(SFtpPacketType.SSH_FXP_OPEN)
        {
            Attributes = new SFtpFileAttributes();
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            FileName = reader.ReadString();
            Flags = (SFtpOpenFlags)reader.ReadUInt32();
            Attributes = (SFtpFileAttributes)reader.ReadAttrib();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(FileName);
            writer.WriteUInt32((UInt32)Flags);
            writer.WriteAttrib(Attributes);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_CLOSE)]
    internal class SFtpPacketClose : SFtpPacket
    {
        public SFtpHandle Handle;

        public SFtpPacketClose()
            : base(SFtpPacketType.SSH_FXP_CLOSE)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle = reader.ReadBytes();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_READ)]
    internal class SFtpPacketReadFile : SFtpPacket
    {
        public SFtpHandle Handle;
        public UInt64 Position;
        public UInt32 Length;

        public SFtpPacketReadFile()
            : base(SFtpPacketType.SSH_FXP_READ)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle = reader.ReadBytes();
            Position = reader.ReadUInt64();
            Length = reader.ReadUInt32();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
            writer.WriteUInt64(Position);
            writer.WriteUInt32(Length);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_WRITE)]
    internal class SFtpPacketWriteFile : SFtpPacket
    {
        public SFtpHandle Handle;
        public UInt64 Position;
        public Byte[] Data;
        public int Length;
        public int Offset;

        public SFtpPacketWriteFile()
            : base(SFtpPacketType.SSH_FXP_WRITE)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle = reader.ReadBytes();
            Position = reader.ReadUInt64();
            Data = reader.ReadBytes();
            Offset = 0;
            Length = Data.Length;
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
            writer.WriteUInt64(Position);
            writer.WriteBytes(Data,Offset,Length);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_RMDIR)]
    internal class SFtpPacketRemoveFile : SFtpPacket
    {
        public String FileName;

        public SFtpPacketRemoveFile()
            : base(SFtpPacketType.SSH_FXP_RMDIR)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            FileName = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(FileName);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_RENAME)]
    internal class SFtpPacketRename : SFtpPacket
    {
        public String OldPath;
        public String NewPath;

        public SFtpPacketRename()
            : base(SFtpPacketType.SSH_FXP_RENAME)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            OldPath = reader.ReadString();
            NewPath = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(OldPath);
            writer.WriteString(NewPath);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_MKDIR)]
    internal class SFtpPacketCreateDirectory : SFtpPacket
    {
        public String Path;
        public SFtpFileAttributes Attributes;

        public SFtpPacketCreateDirectory()
            : base(SFtpPacketType.SSH_FXP_MKDIR)
        {
            Attributes = new SFtpFileAttributes();
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Path = reader.ReadString();
            Attributes = reader.ReadAttrib();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(Path);
            writer.WriteAttrib(Attributes);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_RMDIR)]
    internal class SFtpPacketRemoveDirectory : SFtpPacket
    {
        public String FileName;

        public SFtpPacketRemoveDirectory()
            : base(SFtpPacketType.SSH_FXP_RMDIR)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            FileName = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(FileName);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_OPENDIR)]
    internal class SFtpPacketOpenDirectory : SFtpPacket
    {
        public String FileName;

        public SFtpPacketOpenDirectory()
            : base(SFtpPacketType.SSH_FXP_OPENDIR)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            FileName = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(FileName);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_READDIR)]
    internal class SFtpPacketReadDirectory : SFtpPacket
    {
        public SFtpHandle Handle;

        public SFtpPacketReadDirectory()
            : base(SFtpPacketType.SSH_FXP_READDIR)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle = reader.ReadBytes();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_STAT )]
    internal class SFtpPacketFileStat : SFtpPacket
    {
        public String Path;

        public SFtpPacketFileStat()
            : base(SFtpPacketType.SSH_FXP_STAT)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Path = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(Path);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_LSTAT)]
    internal class SFtpPacketLinkStat : SFtpPacket
    {
        public String Path;

        public SFtpPacketLinkStat()
            : base(SFtpPacketType.SSH_FXP_LSTAT)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Path = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(Path);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_FSTAT)]
    internal class SFtpPacketOpenStat : SFtpPacket
    {
        public SFtpHandle Handle;

        public SFtpPacketOpenStat()
            : base(SFtpPacketType.SSH_FXP_FSTAT)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle = reader.ReadBytes();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_SETSTAT)]
    internal class SFtpPacketSetFileStat : SFtpPacket
    {
        public String Path;
        public SFtpFileAttributes Attributes;

        public SFtpPacketSetFileStat()
            : base(SFtpPacketType.SSH_FXP_SETSTAT)
        {
            Attributes = new SFtpFileAttributes();
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Path = reader.ReadString();
            Attributes = reader.ReadAttrib();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(Path);
            writer.WriteAttrib(Attributes);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_FSETSTAT)]
    internal class SFtpPacketSetOpenStat : SFtpPacket
    {
        public SFtpHandle Handle;
        public SFtpFileAttributes Attributes;

        public SFtpPacketSetOpenStat()
            : base(SFtpPacketType.SSH_FXP_FSETSTAT)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle  = reader.ReadBytes();
            Attributes = reader.ReadAttrib();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
            writer.WriteAttrib(Attributes);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_READLINK)]
    internal class SFtpPacketReadLink : SFtpPacket
    {
        public String Path;

        public SFtpPacketReadLink()
            : base(SFtpPacketType.SSH_FXP_READLINK)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Path = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(Path);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_SYMLINK)]
    internal class SFtpPacketCreateLink : SFtpPacket
    {
        public String LinkPath;
        public String TargetPath;

        public SFtpPacketCreateLink()
            : base(SFtpPacketType.SSH_FXP_SYMLINK)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            LinkPath = reader.ReadString();
            TargetPath = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(LinkPath);
            writer.WriteString(TargetPath);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_REALPATH)]
    internal class SFtpPacketRealPath : SFtpPacket
    {
        public String Path;

        public SFtpPacketRealPath()
            : base(SFtpPacketType.SSH_FXP_REALPATH)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Path = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteString(Path);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_STATUS)]
    internal class SFtpPacketStatus : SFtpPacket
    {
        public UInt32 ErrorCode;
        public String ErrorMessage;
        public String ErrorLanguage;

        public SFtpPacketStatus()
            : base(SFtpPacketType.SSH_FXP_STATUS)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            ErrorCode = reader.ReadUInt32();
            ErrorMessage = reader.ReadString();
            ErrorLanguage = reader.ReadString();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteUInt32(ErrorCode);
            writer.WriteString(ErrorMessage);
            writer.WriteString(ErrorLanguage);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_HANDLE)]
    internal class SFtpPacketHandle : SFtpPacket
    {
        public SFtpHandle Handle;

        public SFtpPacketHandle()
            : base(SFtpPacketType.SSH_FXP_HANDLE)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            Handle = new SFtpHandle();
            RequestId = reader.ReadUInt32();
            Handle.handle = reader.ReadBytes();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Handle.handle);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_DATA)]
    internal class SFtpPacketData : SFtpPacket
    {
        public Byte[] Data;

        public SFtpPacketData()
            : base(SFtpPacketType.SSH_FXP_DATA)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Data = reader.ReadBytes();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteBytes(Data);
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_NAME)]
    internal class SFtpPacketName : SFtpPacket
    {
        public SFtpFileInfo [] Files;

        public SFtpPacketName()
            : base(SFtpPacketType.SSH_FXP_NAME)
        {
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            UInt32 Count;
            RequestId = reader.ReadUInt32();
            Count = reader.ReadUInt32();
            Files = new SFtpFileInfo[Count];
            for (UInt32 u = 0; u < Count; u++)
            {
                Files[u].FileName = reader.ReadString();
                Files[u].LongName = reader.ReadString();
                Files[u].Attributes = reader.ReadAttrib();
            }
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteUInt32((UInt32)Files.Length);
            foreach (SFtpFileInfo file in Files)
            {
                writer.WriteString(file.FileName);
                writer.WriteString(file.LongName);
                writer.WriteAttrib(file.Attributes);
            }
        }
    }
    [SFtpPacketInfo(SFtpPacketType.SSH_FXP_ATTRS)]
    internal class SFtpPacketAttrs : SFtpPacket
    {
        public SFtpFileAttributes Attributes;

        public SFtpPacketAttrs()
            : base(SFtpPacketType.SSH_FXP_ATTRS)
        {
            Attributes = new SFtpFileAttributes();
        }

        public override void Deserialize(SFtpPacketReader reader)
        {
            RequestId = reader.ReadUInt32();
            Attributes = reader.ReadAttrib();
        }

        public override void Serialize(SFtpPacketWriter writer)
        {
            writer.WriteUInt32(RequestId);
            writer.WriteAttrib(Attributes);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sftp4_none_12.4.56.0_none_f2387f1d61fbe924
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sftp4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.manifest
XP_MANIFEST_PATH=manifests\msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.cat
XP_CATALOG_PATH=manifests\msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.cat
XP_PAYLOAD_PATH=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sftp4,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sftp4_none_12.4.56.0_none_f2387f1d61fbe924
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sftp4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.manifest
XP_MANIFEST_PATH=manifests\msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.cat
XP_CATALOG_PATH=manifests\msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88.cat
XP_PAYLOAD_PATH=msil_sftp4_no-public-key_12.4.56.0_x-ww_df9d2f88
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sftp4,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SFtpSessionException.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.xltrans.service
{
    public class SFtpSessionException : Exception
    {
        public SFtpSessionException()
            : base()
        {
        }

        public SFtpSessionException(string message)
            : base(message)
        {
        }
    }
    public class SFtpSessionDisconnectedException : SFtpSessionException
    {
        public SFtpSessionDisconnectedException()
            : base("SFTP transport layer disconnected")
        {
        }

        public SFtpSessionDisconnectedException(string message)
            : base(message)
        {
        }
    }
    public class SFtpSessionStatusException : Exception
    {
        public UInt32 ErrorCode;

        private static String GenerateMessage(UInt32 ErrorCode, String message)
        {
            if (message != null)
            {
                return String.Format("Error {0}: {1}", ErrorCode, message);
            }

            switch (ErrorCode)
            {
                case 0:
                    return String.Format("Error {0}: Success", ErrorCode);
                case 1:
                    return String.Format("Error {0}: End of File", ErrorCode);
                case 2:
                    return String.Format("Error {0}: File not found", ErrorCode);
                case 3:
                    return String.Format("Error {0}: Permission Denied", ErrorCode);
                case 4:
                    return String.Format("Error {0}: Failure", ErrorCode);
                case 5:
                    return String.Format("Error {0}: Bad Message", ErrorCode);
                case 6:
                    return String.Format("Error {0}: No Connection", ErrorCode);
                case 7:
                    return String.Format("Error {0}: Connection Lost", ErrorCode);
                case 8:
                    return String.Format("Error {0}: Unsupported", ErrorCode);
            }

            return String.Format("Error {0}: Unknown", ErrorCode);
        }

        public SFtpSessionStatusException(SFtpErrorCodes errorCode, String message)
            : this((uint)errorCode, message)
        {
        }
        public SFtpSessionStatusException(UInt32 errorCode, String message)
            : base(GenerateMessage(errorCode, message))
        {
            ErrorCode = errorCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\tools\GetFileStats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\test\Basic\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace Basic
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Dictionary<long, TransferStatus> jobState;
                TransferStatus state;
                XlTrans xltrans;
                long transferId, done;
                String server = "PAULRAM004";

                if (args.Length > 1)
                {
                    server = args[0];
                }

                state = null;
                xltrans = new XlTrans();
                xltrans.Url = "http://" + server + "/xltrans/xltrans.asmx";
                jobState = new Dictionary<long, TransferStatus>();

                transferId = xltrans.TransferFile("TestStart", "TestFile_032MB", "SshEnd", "Dump/TestFile_128MB.001");
                jobState[transferId] = xltrans.GetTransferStatusEx(transferId);
                Console.WriteLine("[{0}] {1}: {2}", DateTime.Now, transferId, jobState[transferId].state);
                transferId = xltrans.TransferFile("TestStart", "TestFile_032MB", "TestEnd", "Dump/TestFile_032MB.001");
                jobState[transferId] = xltrans.GetTransferStatusEx(transferId);
                Console.WriteLine("[{0}] {1}: {2}", DateTime.Now, transferId, jobState[transferId].state);
                transferId = xltrans.TransferFile("TestStart", "TestFile_032MB", "RemoteEnd", "Dump/TestFile_032MB.001");
                jobState[transferId] = xltrans.GetTransferStatusEx(transferId);
                Console.WriteLine("[{0}] {1}: {2}", DateTime.Now, transferId, jobState[transferId].state);

                done = 0;
                while (done != 3)
                {
                    done = 0;
                    foreach (long transfer in jobState.Keys)
                    {
                        state = xltrans.GetTransferStatusEx(transfer);
                        if (jobState[transfer].state != state.state)
                        {
                            Console.WriteLine("[{0}] {1}: {2}", DateTime.Now, transfer, state.state);
                            jobState[transfer].state = state.state;

                        }

                        if (jobState[transfer].state == TransferState.Complete || jobState[transfer].state == TransferState.Failed)
                        {
                            done++;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\SFtp\SshStream.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Xml.Serialization;
using System.Xml;
using System.Threading;

namespace xonline.tools.xltrans.service
{
    [XmlRoot(ElementName="Configuration")]
    public class SshConfig
    {
        public String SSHLocation;
        public String SSHKeys;
        public int TimeOut;

        SshConfig()
        {
            SSHLocation = "";
            SSHKeys = "";
        }

        public static SshConfig Load()
        {
            XmlReader reader;
            XmlSerializer serializer;

            if (File.Exists(@"SSH.Config"))
                reader = XmlReader.Create(@"SSH.Config");
            else
                return null;

            serializer = new XmlSerializer(typeof(SshConfig));
            return (SshConfig)serializer.Deserialize(reader);
        }
    }
    public class SshInfo
    {
        static public SshInfo Default;
        /// <summary>
        /// Location of SSH2.EXE
        /// </summary>
        public String Location;

        /// <summary>
        /// Location of the SSH key files
        /// </summary>
        public String KeyLocation;

        /// <summary>
        /// Username to connect with
        /// </summary>
        public String UserName;

        /// <summary>
        /// Server to connect to
        /// </summary>
        public String Server;

        /// <summary>
        /// Service to request
        /// </summary>
        public String Service;

        /// <summary>
        /// Time to wait for authentication
        /// </summary>
        public int TimeOut;

        /// <summary>
        /// Location to put SSH debug logs
        /// </summary>
        public String LogLocation;

        static SshInfo()
        {
            SshConfig config = SshConfig.Load();
            Default = new SshInfo();
            if (config != null)
            {
                Default.Location = config.SSHLocation;
                Default.KeyLocation = config.SSHKeys;
                if (config.TimeOut == 0)
                {
                    Default.TimeOut = -1;
                }
                else
                {
                    Default.TimeOut = config.TimeOut * 1000;
                }
            }
            else
            {
                Default.Location = "";
                Default.KeyLocation = "";
                Default.TimeOut = -1;
            }
            Default.UserName = "";
            Default.Server = "";
            Default.Service = "";
            Default.LogLocation = "";
        }

        public SshInfo()
        {
            if (Default != null)
            {
                Location = Default.Location;
                KeyLocation = Default.KeyLocation;
                TimeOut = Default.TimeOut;
            }
            else
            {
                Location = "";
                KeyLocation = "";
                TimeOut = -1;
            }
            UserName = "";
            Server = "";
            Service = "";
        }

        public SshInfo(SshInfo copy)
        {
            Location = (copy.Location == null || copy.Location == "") ? Default.Location : Location = copy.Location;
            KeyLocation = (copy.KeyLocation == null || copy.KeyLocation == "") ? Default.KeyLocation : KeyLocation = copy.KeyLocation;
            UserName = (copy.UserName == null || copy.UserName == "") ? Default.UserName : UserName = copy.UserName;
            Server = (copy.Server == null || copy.Server == "") ? Default.Server : Server = copy.Server;
            Service = (copy.Service == null || copy.Service == "") ? Default.Service : Service = copy.Service;
            LogLocation = (copy.LogLocation == null || copy.LogLocation == "") ? Default.LogLocation : LogLocation = copy.LogLocation;
            TimeOut = (copy.TimeOut == 0) ? Default.TimeOut : TimeOut = copy.TimeOut;
        }
    }

    public class SshException : Exception
    {
        public SshException() : base() { }
        public SshException(string message) : base(message) { }
        public SshException(string message, Exception innerException) : base(message, innerException) { }
    }

    public class SshDisconnectedException : SshException
    {
        public SshDisconnectedException() : base() { }
        public SshDisconnectedException(string message) : base(message) { }
        public SshDisconnectedException(string message, Exception innerException) : base(message, innerException) { }
    }

    public class SshStream : Stream 
    {
        private Process _process;
        public SshInfo Info;
        private Stream _input, _output;
        private StreamWriter _error;
        private int _state;
        private String _logFileName;

        private const int _stateClosed=0;
        private const int _stateConnecting=1;
        private const int _stateConnected=2;
        private const int _stateClosing=3;        

        public SshStream(String username, String server, String service)
        {
            Info = new SshInfo(SshInfo.Default);
            Info.UserName = username;
            Info.Server = server;
            Info.Service = service;
            _process = null;
            _state = _stateClosed;
            _logFileName = null;
        }

        public SshStream(SshInfo info)
        {
            Info = new SshInfo(info);
            _process = null;
            _error = null;
            _output = null;
            _input = null;
            _state = _stateClosed;
            _logFileName = null;
        }

        public SshStream()
        {
            Info = new SshInfo();
            _process = null;
            _input = null;
            _output = null;
            _error = null;
            _state = _stateClosed;
            _logFileName = null;
        }


        public void Connect()
        {
            IAsyncResult ar; 
            byte[] buffer;

            while (Interlocked.CompareExchange(ref _state, _stateConnecting, _stateClosed) != _stateClosed)
            {
                Thread.VolatileRead(ref _state);
                while (_state == _stateClosing || _state == _stateConnecting)
                {
                    Thread.Sleep(20);
                }

                if (_state == _stateConnected)
                {
                    return;
                }
            }

            buffer = new byte[32];
            _process = new Process();
            _process.StartInfo.FileName = Path.Combine(Info.Location, "SSH2.EXE");
            _process.StartInfo.Arguments = "-x -a -v ";
            _process.StartInfo.Arguments += "-oclearallforwardings=yes ";
            _process.StartInfo.Arguments += "-oforcepttyallocation=no ";
            _process.StartInfo.Arguments += "-onodelay=yes ";
            _process.StartInfo.Arguments += "-oauthenticationnotify=yes ";
            _process.StartInfo.Arguments += "-l \"" + Info.UserName + "\" ";
            _process.StartInfo.Arguments += "-k " + Info.KeyLocation + " ";
            _process.StartInfo.Arguments += "-s " + Info.Service + " ";
            _process.StartInfo.Arguments += "" + Info.Server + "";

            _process.StartInfo.UseShellExecute = false;
            _process.StartInfo.CreateNoWindow = true;
            _process.StartInfo.RedirectStandardInput = true;
            _process.StartInfo.RedirectStandardOutput = true;
            _process.StartInfo.RedirectStandardError = true;

            _process.ErrorDataReceived += new DataReceivedEventHandler(OnReceivedErrorData);
            _process.Exited += new EventHandler(CleanUp);
            _process.EnableRaisingEvents = true;
            _process.Start();

            _process.BeginErrorReadLine();
            _input = _process.StandardInput.BaseStream;
            _output = _process.StandardOutput.BaseStream;

            ar = _output.BeginRead(buffer, 0, 30, null, null);
            if (!ar.AsyncWaitHandle.WaitOne(Info.TimeOut==-1? -1 : Info.TimeOut * 1000, true))
            {
                _process.Kill();
                Interlocked.Exchange(ref _state, _stateConnected);
                Close();
                throw new System.UnauthorizedAccessException();
            }
            int length = _output.EndRead(ar);
            if (length == 0)
            {
                Interlocked.Exchange(ref _state, _stateConnected);
                Close();
                throw new SshException(String.Format("Error starting ssh2.exe:\n  CMD: {0} {1}\n",
                    _process.StartInfo.FileName,
                    _process.StartInfo.Arguments));
            }

            Interlocked.Exchange(ref _state, _stateConnected);
        }

        private void OnReceivedErrorData(object sender, DataReceivedEventArgs e)
        {
            String errorLine = e.Data;

            if (Info.LogLocation == null || Info.LogLocation == "")
            {
                return;
            }

            if (errorLine == null)
            {
                return;
            }

            errorLine = errorLine.Trim();
            if (errorLine == "")
            {
                return;
            }

            lock (this)
            {
                if (_error == null)
                {
                    _logFileName = Path.Combine(Info.LogLocation, "SSH [" + _process.Id + "].log");
                    _error = new StreamWriter(_logFileName, true);
                    _error.AutoFlush = true;
                }
                _error.WriteLine("[{0}] {1}", DateTime.Now, errorLine);
            }
        }

        ~SshStream()
        {
            Close();
        }

        public override bool CanRead
        {
            get { return true; }
        }

        public override bool CanSeek
        {
            get { return false; }
        }

        public override bool CanWrite
        {
            get { return true; }
        }

        public override void Flush()
        {
            _input.Flush();
        }

        public override long Length
        {
            get { return 0; }
        }

        public override long Position
        {
            get
            {
                return 0;
            }
            set
            {
            }
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            return _output.Read(buffer, offset, count);
        }

        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return _output.BeginRead(buffer, offset, count, callback, state);
        }

        public override int EndRead(IAsyncResult asyncResult)
        {
            return _output.EndRead(asyncResult);
        }


        public override void Write(byte[] buffer, int offset, int count)
        {
            _input.Write(buffer, offset, count);
        }

        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return _input.BeginWrite(buffer, offset, count, callback, state);
        }

        public override void EndWrite(IAsyncResult asyncResult)
        {
           _input.EndWrite(asyncResult);
        }


        public override long Seek(long offset, SeekOrigin origin)
        {
            return 0;
        }

        public override void SetLength(long value)
        {
        }

        public override void Close()
        {
            while (Interlocked.CompareExchange(ref _state, _stateClosing, _stateConnected) != _stateConnected)
            {
                Thread.VolatileRead(ref _state);
                while (_state == _stateConnecting)
                {
                    Thread.Sleep(20);
                }

                if (_state == _stateClosed || _state == _stateClosing)
                {
                    return;
                }
            }            
            _input.Close();
            _output.Close();
            _process.WaitForExit();
            if (_error != null)
            {
                _error.WriteLine("[{0}] SSH2.EXE exited with exit code {1}.", DateTime.Now, _process.ExitCode);
                _error.Close();
            }
            _process.Close();
            _input = null;
            _output = null;
            _error = null;
            _process = null;
            _logFileName = "";

            Interlocked.Exchange(ref _state, _stateClosed);
        }

        private void CleanUp(object sender, EventArgs e)
        {
            Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\test\Basic\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Basic")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Basic")]
[assembly: AssemblyCopyright("Copyright   2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a6c2fd6e-e010-46b4-b464-187ef82abad6")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\tools\GetFileStats\XlTransEx.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.xltrans {
    public partial class XlTrans
    {
        public XlTrans(String url)
        {
            this.Url = url;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\tools\GetFileStats\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using xonline.tools.xltrans;
using System.IO;
using System.Reflection;

namespace GetFileStats
{
    class Program
    {
        static void PrintProperties(Object o)
        {
            Type type = o.GetType();
            int length = 0;

            foreach (PropertyInfo property in type.GetProperties())
            {
                if (property.Name.Length > length)
                    length = property.Name.Length;
            }

            foreach (PropertyInfo property in type.GetProperties())
            {
                Console.WriteLine("{0}: {1}", property.Name.PadRight(length),
                    property.GetValue(o, null).ToString());
            }
        }
        static void Main(string[] args)
        {
            if (args.Length != 2 && args.Length != 3)
            {
                Console.WriteLine("Gets information about a file on a remote XlTrans endpoint.");
                Console.WriteLine();
                Console.WriteLine("USAGE:");
                Console.WriteLine("  GetFileStats [<server>] <endpoint> <fileName>");
                Console.WriteLine();
                Console.WriteLine("  server    name or ip of the server hosting XlTrans.");
                Console.WriteLine("  endpoint  endpoint where the file resides.");
                Console.WriteLine("  fileName  name of the file to query.");
                Console.WriteLine();
                return;
            }

            String server, endpoint, fileName;
            if (args.Length == 2)
            {
                server = "xsbrigiis001";
                endpoint = args[0];
                fileName = args[1];
            }
            else
            {
                server = args[0];
                endpoint = args[1];
                fileName = args[2];
            }

			try
			{
				XlTrans xltrans = new XlTrans("http://" + server + "/xltrans/xltrans.asmx");
				FileStats fileStats = xltrans.GetFileStats(endpoint, fileName);
				if (fileStats == null)
				{
					Console.WriteLine("Either the file or endpoint does not exist.");
					return;
				}

				PrintProperties(fileStats);
			}
			catch(Exception ex)
			{
				Console.WriteLine(ex);
			}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\tools\GetFileStats\XlTrans.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.tools.xltrans {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="XlTransSoap", Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class XlTrans : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback TransferFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTransferStatusExOperationCompleted;
        
        private System.Threading.SendOrPostCallback JobTransferFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTransferStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetFileStatsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPhysicalPathOperationCompleted;
        
        /// <remarks/>
        public XlTrans() {
            this.Url = "http://xsbrigiis001/xltrans/xltrans.asmx";
        }
        
        /// <remarks/>
        public event TransferFileCompletedEventHandler TransferFileCompleted;
        
        /// <remarks/>
        public event GetTransferStatusExCompletedEventHandler GetTransferStatusExCompleted;
        
        /// <remarks/>
        public event JobTransferFileCompletedEventHandler JobTransferFileCompleted;
        
        /// <remarks/>
        public event GetTransferStatusCompletedEventHandler GetTransferStatusCompleted;
        
        /// <remarks/>
        public event GetFileStatsCompletedEventHandler GetFileStatsCompleted;
        
        /// <remarks/>
        public event GetPhysicalPathCompletedEventHandler GetPhysicalPathCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/TransferFile", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long TransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath) {
            object[] results = this.Invoke("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath});
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndTransferFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void TransferFileAsync(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath) {
            this.TransferFileAsync(sourceEndpoint, sourceFilePath, destEndpoint, destFilePath, null);
        }
        
        /// <remarks/>
        public void TransferFileAsync(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath, object userState) {
            if ((this.TransferFileOperationCompleted == null)) {
                this.TransferFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferFileOperationCompleted);
            }
            this.InvokeAsync("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath}, this.TransferFileOperationCompleted, userState);
        }
        
        private void OnTransferFileOperationCompleted(object arg) {
            if ((this.TransferFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferFileCompleted(this, new TransferFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetTransferStatusEx", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TransferStatus GetTransferStatusEx(long transferId) {
            object[] results = this.Invoke("GetTransferStatusEx", new object[] {
                        transferId});
            return ((TransferStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTransferStatusEx(long transferId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTransferStatusEx", new object[] {
                        transferId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TransferStatus EndGetTransferStatusEx(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TransferStatus)(results[0]));
        }
        
        /// <remarks/>
        public void GetTransferStatusExAsync(long transferId) {
            this.GetTransferStatusExAsync(transferId, null);
        }
        
        /// <remarks/>
        public void GetTransferStatusExAsync(long transferId, object userState) {
            if ((this.GetTransferStatusExOperationCompleted == null)) {
                this.GetTransferStatusExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransferStatusExOperationCompleted);
            }
            this.InvokeAsync("GetTransferStatusEx", new object[] {
                        transferId}, this.GetTransferStatusExOperationCompleted, userState);
        }
        
        private void OnGetTransferStatusExOperationCompleted(object arg) {
            if ((this.GetTransferStatusExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransferStatusExCompleted(this, new GetTransferStatusExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/JobTransferFile", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long JobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath) {
            object[] results = this.Invoke("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath});
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginJobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndJobTransferFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void JobTransferFileAsync(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath) {
            this.JobTransferFileAsync(srcRootID, srcFilePath, dstRootID, jobId, dstFilePath, null);
        }
        
        /// <remarks/>
        public void JobTransferFileAsync(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath, object userState) {
            if ((this.JobTransferFileOperationCompleted == null)) {
                this.JobTransferFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnJobTransferFileOperationCompleted);
            }
            this.InvokeAsync("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath}, this.JobTransferFileOperationCompleted, userState);
        }
        
        private void OnJobTransferFileOperationCompleted(object arg) {
            if ((this.JobTransferFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.JobTransferFileCompleted(this, new JobTransferFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetTransferStatus", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TransferState GetTransferStatus(long transferId) {
            object[] results = this.Invoke("GetTransferStatus", new object[] {
                        transferId});
            return ((TransferState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTransferStatus(long transferId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTransferStatus", new object[] {
                        transferId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TransferState EndGetTransferStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TransferState)(results[0]));
        }
        
        /// <remarks/>
        public void GetTransferStatusAsync(long transferId) {
            this.GetTransferStatusAsync(transferId, null);
        }
        
        /// <remarks/>
        public void GetTransferStatusAsync(long transferId, object userState) {
            if ((this.GetTransferStatusOperationCompleted == null)) {
                this.GetTransferStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransferStatusOperationCompleted);
            }
            this.InvokeAsync("GetTransferStatus", new object[] {
                        transferId}, this.GetTransferStatusOperationCompleted, userState);
        }
        
        private void OnGetTransferStatusOperationCompleted(object arg) {
            if ((this.GetTransferStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransferStatusCompleted(this, new GetTransferStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetFileStats", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FileStats GetFileStats(string endpointName, string fileName) {
            object[] results = this.Invoke("GetFileStats", new object[] {
                        endpointName,
                        fileName});
            return ((FileStats)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFileStats(string endpointName, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFileStats", new object[] {
                        endpointName,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public FileStats EndGetFileStats(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FileStats)(results[0]));
        }
        
        /// <remarks/>
        public void GetFileStatsAsync(string endpointName, string fileName) {
            this.GetFileStatsAsync(endpointName, fileName, null);
        }
        
        /// <remarks/>
        public void GetFileStatsAsync(string endpointName, string fileName, object userState) {
            if ((this.GetFileStatsOperationCompleted == null)) {
                this.GetFileStatsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFileStatsOperationCompleted);
            }
            this.InvokeAsync("GetFileStats", new object[] {
                        endpointName,
                        fileName}, this.GetFileStatsOperationCompleted, userState);
        }
        
        private void OnGetFileStatsOperationCompleted(object arg) {
            if ((this.GetFileStatsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetFileStatsCompleted(this, new GetFileStatsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetPhysicalPath", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetPhysicalPath(string endpointName, string fileName) {
            object[] results = this.Invoke("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPhysicalPath(string endpointName, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetPhysicalPath(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetPhysicalPathAsync(string endpointName, string fileName) {
            this.GetPhysicalPathAsync(endpointName, fileName, null);
        }
        
        /// <remarks/>
        public void GetPhysicalPathAsync(string endpointName, string fileName, object userState) {
            if ((this.GetPhysicalPathOperationCompleted == null)) {
                this.GetPhysicalPathOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPhysicalPathOperationCompleted);
            }
            this.InvokeAsync("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName}, this.GetPhysicalPathOperationCompleted, userState);
        }
        
        private void OnGetPhysicalPathOperationCompleted(object arg) {
            if ((this.GetPhysicalPathCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPhysicalPathCompleted(this, new GetPhysicalPathCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class TransferStatus {
        
        private TransferState stateField;
        
        private int errorcodeField;
        
        private string messageField;
        
        /// <remarks/>
        public TransferState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public int errorcode {
            get {
                return this.errorcodeField;
            }
            set {
                this.errorcodeField = value;
            }
        }
        
        /// <remarks/>
        public string message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public enum TransferState {
        
        /// <remarks/>
        NotFound,
        
        /// <remarks/>
        Failed,
        
        /// <remarks/>
        Pending,
        
        /// <remarks/>
        Running,
        
        /// <remarks/>
        Complete,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class FileStats {
        
        private string directoryNameField;
        
        private long lengthField;
        
        private string nameField;
        
        private System.DateTime creationTimeField;
        
        private System.DateTime lastAccessTimeField;
        
        private System.DateTime lastWriteTimeField;
        
        /// <remarks/>
        public string DirectoryName {
            get {
                return this.directoryNameField;
            }
            set {
                this.directoryNameField = value;
            }
        }
        
        /// <remarks/>
        public long Length {
            get {
                return this.lengthField;
            }
            set {
                this.lengthField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationTime {
            get {
                return this.creationTimeField;
            }
            set {
                this.creationTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastAccessTime {
            get {
                return this.lastAccessTimeField;
            }
            set {
                this.lastAccessTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastWriteTime {
            get {
                return this.lastWriteTimeField;
            }
            set {
                this.lastWriteTimeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TransferFileCompletedEventHandler(object sender, TransferFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TransferFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransferStatusExCompletedEventHandler(object sender, GetTransferStatusExCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransferStatusExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTransferStatusExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TransferStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TransferStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void JobTransferFileCompletedEventHandler(object sender, JobTransferFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class JobTransferFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal JobTransferFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransferStatusCompletedEventHandler(object sender, GetTransferStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransferStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTransferStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TransferState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TransferState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetFileStatsCompletedEventHandler(object sender, GetFileStatsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetFileStatsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetFileStatsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FileStats Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FileStats)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPhysicalPathCompletedEventHandler(object sender, GetPhysicalPathCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPhysicalPathCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPhysicalPathCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\EndpointParameters.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace xonline.tools.xltrans.service
{
    /// <summary>
    /// Endpoint protocols
    /// </summary>
    public enum Protocol
    {
        SSH,
        UNC,
        LOCAL
    }

    /// <summary>
    /// Parameters which define and endpoint
    /// </summary>
    [XmlRoot(ElementName = "EndPoint")]
    public class EndpointParameters
    {
        /// <summary>
        /// Name of the EndPoint.  This is case-insensitive.
        /// </summary>
        [XmlAttribute]
        public string Name;

        /// <summary>
        /// EndPoint protocol.
        /// </summary>
        [XmlAttribute]
        public Protocol Protocol;

        /// <summary>
        /// (SSH and UNC) Server associated with the EndPoint
        /// </summary>
        [XmlElement]
        public string Server;

        /// <summary>
        /// (SSH Only) Username associated with the EndPoint
        /// </summary>
        [XmlElement]
        public string User;

        /// <summary>
        /// (UNC Only) UNC Fileshare
        /// </summary>
        [XmlElement]
        public string Share;

        /// <summary>
        /// (All)The basepath.
        /// </summary>
        [XmlElement]
        public string Root;

        public bool Matches(EndpointParameters parameters)
        {
            return
                (this.Name == parameters.Name) &&
                (this.Protocol == parameters.Protocol) &&
                (this.Server == parameters.Server) &&
                (this.User == parameters.User) &&
                (this.Share == parameters.Share) &&
                (this.Root == parameters.Root);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\test\Basic\XlTrans.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Basic {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="XlTransSoap", Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class XlTrans : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback TransferFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTransferStatusExOperationCompleted;
        
        private System.Threading.SendOrPostCallback JobTransferFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTransferStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetFileStatsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPhysicalPathOperationCompleted;
        
        /// <remarks/>
        public XlTrans() {
        }
        
        /// <remarks/>
        public event TransferFileCompletedEventHandler TransferFileCompleted;
        
        /// <remarks/>
        public event GetTransferStatusExCompletedEventHandler GetTransferStatusExCompleted;
        
        /// <remarks/>
        public event JobTransferFileCompletedEventHandler JobTransferFileCompleted;
        
        /// <remarks/>
        public event GetTransferStatusCompletedEventHandler GetTransferStatusCompleted;
        
        /// <remarks/>
        public event GetFileStatsCompletedEventHandler GetFileStatsCompleted;
        
        /// <remarks/>
        public event GetPhysicalPathCompletedEventHandler GetPhysicalPathCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/TransferFile", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long TransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath) {
            object[] results = this.Invoke("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath});
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndTransferFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void TransferFileAsync(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath) {
            this.TransferFileAsync(sourceEndpoint, sourceFilePath, destEndpoint, destFilePath, null);
        }
        
        /// <remarks/>
        public void TransferFileAsync(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath, object userState) {
            if ((this.TransferFileOperationCompleted == null)) {
                this.TransferFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferFileOperationCompleted);
            }
            this.InvokeAsync("TransferFile", new object[] {
                        sourceEndpoint,
                        sourceFilePath,
                        destEndpoint,
                        destFilePath}, this.TransferFileOperationCompleted, userState);
        }
        
        private void OnTransferFileOperationCompleted(object arg) {
            if ((this.TransferFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferFileCompleted(this, new TransferFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetTransferStatusEx", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TransferStatus GetTransferStatusEx(long transferId) {
            object[] results = this.Invoke("GetTransferStatusEx", new object[] {
                        transferId});
            return ((TransferStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTransferStatusEx(long transferId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTransferStatusEx", new object[] {
                        transferId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TransferStatus EndGetTransferStatusEx(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TransferStatus)(results[0]));
        }
        
        /// <remarks/>
        public void GetTransferStatusExAsync(long transferId) {
            this.GetTransferStatusExAsync(transferId, null);
        }
        
        /// <remarks/>
        public void GetTransferStatusExAsync(long transferId, object userState) {
            if ((this.GetTransferStatusExOperationCompleted == null)) {
                this.GetTransferStatusExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransferStatusExOperationCompleted);
            }
            this.InvokeAsync("GetTransferStatusEx", new object[] {
                        transferId}, this.GetTransferStatusExOperationCompleted, userState);
        }
        
        private void OnGetTransferStatusExOperationCompleted(object arg) {
            if ((this.GetTransferStatusExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransferStatusExCompleted(this, new GetTransferStatusExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/JobTransferFile", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long JobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath) {
            object[] results = this.Invoke("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath});
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginJobTransferFile(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndJobTransferFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void JobTransferFileAsync(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath) {
            this.JobTransferFileAsync(srcRootID, srcFilePath, dstRootID, jobId, dstFilePath, null);
        }
        
        /// <remarks/>
        public void JobTransferFileAsync(string srcRootID, string srcFilePath, string dstRootID, long jobId, string dstFilePath, object userState) {
            if ((this.JobTransferFileOperationCompleted == null)) {
                this.JobTransferFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnJobTransferFileOperationCompleted);
            }
            this.InvokeAsync("JobTransferFile", new object[] {
                        srcRootID,
                        srcFilePath,
                        dstRootID,
                        jobId,
                        dstFilePath}, this.JobTransferFileOperationCompleted, userState);
        }
        
        private void OnJobTransferFileOperationCompleted(object arg) {
            if ((this.JobTransferFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.JobTransferFileCompleted(this, new JobTransferFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetTransferStatus", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TransferState GetTransferStatus(long transferId) {
            object[] results = this.Invoke("GetTransferStatus", new object[] {
                        transferId});
            return ((TransferState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTransferStatus(long transferId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTransferStatus", new object[] {
                        transferId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TransferState EndGetTransferStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TransferState)(results[0]));
        }
        
        /// <remarks/>
        public void GetTransferStatusAsync(long transferId) {
            this.GetTransferStatusAsync(transferId, null);
        }
        
        /// <remarks/>
        public void GetTransferStatusAsync(long transferId, object userState) {
            if ((this.GetTransferStatusOperationCompleted == null)) {
                this.GetTransferStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTransferStatusOperationCompleted);
            }
            this.InvokeAsync("GetTransferStatus", new object[] {
                        transferId}, this.GetTransferStatusOperationCompleted, userState);
        }
        
        private void OnGetTransferStatusOperationCompleted(object arg) {
            if ((this.GetTransferStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTransferStatusCompleted(this, new GetTransferStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetFileStats", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FileStats GetFileStats(string endpointName, string fileName) {
            object[] results = this.Invoke("GetFileStats", new object[] {
                        endpointName,
                        fileName});
            return ((FileStats)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFileStats(string endpointName, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFileStats", new object[] {
                        endpointName,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public FileStats EndGetFileStats(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FileStats)(results[0]));
        }
        
        /// <remarks/>
        public void GetFileStatsAsync(string endpointName, string fileName) {
            this.GetFileStatsAsync(endpointName, fileName, null);
        }
        
        /// <remarks/>
        public void GetFileStatsAsync(string endpointName, string fileName, object userState) {
            if ((this.GetFileStatsOperationCompleted == null)) {
                this.GetFileStatsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFileStatsOperationCompleted);
            }
            this.InvokeAsync("GetFileStats", new object[] {
                        endpointName,
                        fileName}, this.GetFileStatsOperationCompleted, userState);
        }
        
        private void OnGetFileStatsOperationCompleted(object arg) {
            if ((this.GetFileStatsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetFileStatsCompleted(this, new GetFileStatsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/xltrans/GetPhysicalPath", RequestNamespace="http://websvc.xboxlive.com/xltrans/", ResponseNamespace="http://websvc.xboxlive.com/xltrans/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetPhysicalPath(string endpointName, string fileName) {
            object[] results = this.Invoke("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPhysicalPath(string endpointName, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetPhysicalPath(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetPhysicalPathAsync(string endpointName, string fileName) {
            this.GetPhysicalPathAsync(endpointName, fileName, null);
        }
        
        /// <remarks/>
        public void GetPhysicalPathAsync(string endpointName, string fileName, object userState) {
            if ((this.GetPhysicalPathOperationCompleted == null)) {
                this.GetPhysicalPathOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPhysicalPathOperationCompleted);
            }
            this.InvokeAsync("GetPhysicalPath", new object[] {
                        endpointName,
                        fileName}, this.GetPhysicalPathOperationCompleted, userState);
        }
        
        private void OnGetPhysicalPathOperationCompleted(object arg) {
            if ((this.GetPhysicalPathCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPhysicalPathCompleted(this, new GetPhysicalPathCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class TransferStatus {
        
        private TransferState stateField;
        
        private int errorcodeField;
        
        private string messageField;
        
        /// <remarks/>
        public TransferState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public int errorcode {
            get {
                return this.errorcodeField;
            }
            set {
                this.errorcodeField = value;
            }
        }
        
        /// <remarks/>
        public string message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public enum TransferState {
        
        /// <remarks/>
        NotFound,
        
        /// <remarks/>
        Failed,
        
        /// <remarks/>
        Pending,
        
        /// <remarks/>
        Running,
        
        /// <remarks/>
        Complete,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/xltrans/")]
    public partial class FileStats {
        
        private string directoryNameField;
        
        private long lengthField;
        
        private string nameField;
        
        private System.DateTime creationTimeField;
        
        private System.DateTime lastAccessTimeField;
        
        private System.DateTime lastWriteTimeField;
        
        /// <remarks/>
        public string DirectoryName {
            get {
                return this.directoryNameField;
            }
            set {
                this.directoryNameField = value;
            }
        }
        
        /// <remarks/>
        public long Length {
            get {
                return this.lengthField;
            }
            set {
                this.lengthField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationTime {
            get {
                return this.creationTimeField;
            }
            set {
                this.creationTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastAccessTime {
            get {
                return this.lastAccessTimeField;
            }
            set {
                this.lastAccessTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastWriteTime {
            get {
                return this.lastWriteTimeField;
            }
            set {
                this.lastWriteTimeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TransferFileCompletedEventHandler(object sender, TransferFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TransferFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransferStatusExCompletedEventHandler(object sender, GetTransferStatusExCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransferStatusExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTransferStatusExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TransferStatus Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TransferStatus)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void JobTransferFileCompletedEventHandler(object sender, JobTransferFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class JobTransferFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal JobTransferFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransferStatusCompletedEventHandler(object sender, GetTransferStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransferStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTransferStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TransferState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TransferState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetFileStatsCompletedEventHandler(object sender, GetFileStatsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetFileStatsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetFileStatsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FileStats Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FileStats)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPhysicalPathCompletedEventHandler(object sender, GetPhysicalPathCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPhysicalPathCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPhysicalPathCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\EndpointConfig.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using System.Threading;
using System.Text.RegularExpressions;

namespace xonline.tools.xltrans.service
{
    public class Option
    {
        [XmlAttribute("Name")]
        public string Name;

        [XmlAttribute("Value")]
        public string Value;
    }

    [XmlRoot(ElementName = "EndPointDefinitions")]
    public class EndpointConfig
    {
        [XmlElement(ElementName = "EndPoint")]
        public List<EndpointParameters> Endpoints;

        [XmlElement(ElementName="Option")]
        public List<Option> Options;

        public static EndpointConfig ReadFrom(String endpointConfig)
        {
            EndpointConfig config = null;
            int retries = 5;
            while (retries > 0)
            {
                try
                {
                    XmlUtil.DeserializeFile(endpointConfig, out config);
                    break;
                }
                catch (IOException)
                {
                    retries--;
                    Thread.Sleep(500);
                    continue;
                }
            }
            return config;
        }
    }

    public class EndpointManager
    {
        private static Dictionary<string, Endpoint> _endpoints;
        private static String _configFile;
        private static FileSystemWatcher _configWatcher;

        static EndpointManager()
        {
            _endpoints = new Dictionary<string, Endpoint>();
            String configdir = Path.GetDirectoryName(GetExecutingAssemblyDirectory());
            LoadConfig(Path.Combine(configdir, "EndPoint.Config"));
        }

        static public String GetExecutingAssemblyDirectory()
        {
            Uri codebase = new Uri(Assembly.GetExecutingAssembly().CodeBase);
            return Path.GetDirectoryName(codebase.AbsolutePath);
        }

        static public Endpoint GetEndpoint(String name)
        {
            name = name.ToLower();
            if (_endpoints.ContainsKey(name))
                return _endpoints[name];
            return null;
        }

        static public Endpoint[] EnumEndpoints(String pattern)
        {
            if (pattern == null) pattern = ".*";
            List<Endpoint> endpoints = new List<Endpoint>();
            Regex rePattern = new Regex(pattern, RegexOptions.Compiled | RegexOptions.IgnoreCase);
            foreach (String endpoint in _endpoints.Keys)
            {
                Match m = rePattern.Match(endpoint);
                if (m.Success)
                {
                    endpoints.Add(_endpoints[endpoint]);
                }
            }
            return endpoints.ToArray();
        }

        static public void Initialize()
        {
        }

        static private void OnConfigChanged(object sender, FileSystemEventArgs args)
        {
            Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG, "XlTrans configuration changed.  Reloading.");
            try
            {
                Refresh();
                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG, "XlTrans configuration reloaded.");
            }
            catch (Exception e)
            {
                Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_CONFIG, e, "XlTrans configuration reload failed.");
            }
        }

        static public void LoadConfig(String endpointConfigFile)
        {
            if (!File.Exists(endpointConfigFile))
                throw new FileNotFoundException(endpointConfigFile);
            _configFile = Path.GetFullPath(endpointConfigFile);
            Refresh();
            _configWatcher = new FileSystemWatcher(Path.GetDirectoryName(_configFile));
            _configWatcher.Filter = Path.GetFileName(_configFile);
            _configWatcher.Changed += OnConfigChanged;
            _configWatcher.Created += OnConfigChanged;
            _configWatcher.Deleted += OnConfigChanged;
            _configWatcher.Renamed += OnConfigChanged;
            _configWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.LastAccess;
            _configWatcher.EnableRaisingEvents = true;
        }

        static public void Refresh()
        {
            if (File.Exists(_configFile))
            {
                try
                {
                    EndpointConfig endpointConfig = EndpointConfig.ReadFrom(_configFile);
                    List<EndpointParameters> endpoints = endpointConfig.Endpoints;
                    List<Option> options = endpointConfig.Options;
                    List<string> names = new List<string>();
                    List<string> remaining = new List<string>();

                    foreach (Option option in options)
                    {
                        if (option.Name.ToUpper() == "SSH LOCATION")
                        {
                            String Location = Path.GetFullPath(option.Value);
                            if( SshInfo.Default.Location != Location )
                            {
                                SshInfo.Default.Location = Location;
                                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                    "Setting SSH Location to \"{0}\".", Location);
                            }
                            continue;
                        }

                        if (option.Name.ToUpper() == "SSH LOG LOCATION")
                        {
                            String Location = Path.GetFullPath(option.Value);
                            if (SshInfo.Default.Location != Location)
                            {
                                SshInfo.Default.LogLocation = Location;
                                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                    "Setting SSH Log Location to \"{0}\".", Location);
                            }
                            continue;
                        }

                        if (option.Name.ToUpper() == "SSH TIMEOUT")
                        {
                            int blocksize;

                            if (int.TryParse(option.Value, out blocksize))
                            {
                                SshInfo.Default.TimeOut = blocksize;
                                    
                                    Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                        "Setting SSH Timeout value to \"{0}s\".", Endpoint.BlockSize);
                            }
                            else
                            {
                                Logging.WriteLog(EventLogEntryType.Error, EventId.XLTRANS_CONFIG,
                                    "Could not set Block Size to \"{0}\".  Using current value of {1}.",
                                    option.Value, SshInfo.Default.TimeOut);
                            }

                        }

                        if (option.Name.ToUpper() == "SSH KEYS")
                        {
                            String Location = Path.GetFullPath(option.Value);
                            if (SshInfo.Default.KeyLocation != Location)
                            {
                                SshInfo.Default.KeyLocation = Location;
                                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                    "Setting SSH Key Location to \"{0}\".", Location);
                            }
                            continue;
                        }

                        if (option.Name.ToUpper() == "TRANSFER DIRECTORY")
                        {
                            XlTrans.TransferDirectory = Path.GetFullPath(option.Value);

                            String Location = Path.GetFullPath(option.Value);
                            if (XlTrans.TransferDirectory != Location)
                            {
                                XlTrans.TransferDirectory = Location;
                                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                    "Setting Transfer Directory to \"{0}\".", Location);
                                Directory.CreateDirectory(Location);
                                Directory.CreateDirectory(Path.Combine(Location, "Complete"));
                                Directory.CreateDirectory(Path.Combine(Location, "Failed"));
                            }

                            continue;
                        }

                        if (option.Name.ToUpper() == "CONCURRENT TRANSFERS")
                        {
                            int concurrentTransfers;
                            if (int.TryParse(option.Value, out concurrentTransfers))
                            {
                                if (concurrentTransfers > 0)
                                {
                                    XlTrans.CoreGovernor.Maximum = concurrentTransfers;
                                    Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                        "Setting Max Transfers to \"{0}\".", XlTrans.CoreGovernor.Maximum);
                                }
                                else
                                {
                                    Logging.WriteLog(EventLogEntryType.Error, EventId.XLTRANS_CONFIG,
                                        "Could not set Max Transfers to \"{0}\".  Using current value of {1}.",
                                        option.Value, XlTrans.CoreGovernor.Maximum);
                                }
                            }
                            else
                            {
                                Logging.WriteLog(EventLogEntryType.Error, EventId.XLTRANS_CONFIG,
                                    "Could not set Max Transfers to \"{0}\".  Using current value of {1}.",
                                    option.Value, XlTrans.CoreGovernor.Maximum);
                            }
                        }

                        if (option.Name.ToUpper() == "BLOCK SIZE")
                        {
                            int blocksize;

                            if (int.TryParse(option.Value, out blocksize))
                            {
                                if (blocksize >= 1024 && blocksize < 32768)
                                {
                                    Endpoint.BlockSize = blocksize;
                                    Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                                        "Setting Block Size to \"{0}\".", Endpoint.BlockSize);
                                }
                                else
                                {
                                    Logging.WriteLog(EventLogEntryType.Error, EventId.XLTRANS_CONFIG,
                                        "Could not set Block Size to \"{0}\".  Using current value of {1}.",
                                        option.Value, Endpoint.BlockSize);
                                }
                            }
                            else
                            {
                                Logging.WriteLog(EventLogEntryType.Error, EventId.XLTRANS_CONFIG,
                                    "Could not set Block Size to \"{0}\".  Using current value of {1}.",
                                    option.Value, Endpoint.BlockSize);
                            }
                        }
                    }

                    foreach (string name in _endpoints.Keys)
                        remaining.Add(name);

                    foreach (EndpointParameters parameters in endpoints)
                    {
                        string name = parameters.Name.ToLower();

                        if (_endpoints.ContainsKey(name))
                        {
                            remaining.Remove(name);
                            Endpoint endpoint = _endpoints[name];
                            if (endpoint._parameters.Matches(parameters))
                                continue;
                        }

                        Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_CONFIG,
                            "Updating or creating endpoint \"{0}\".\n"+
                            "   User: {1}\n"+
                            "   Server: {2}\n"+
                            "   Share:  {3}\n"+
                            "   Root: {4}", 
                            parameters.Name,
                            parameters.User==null?"":parameters.User,
                            parameters.Server==null?"":parameters.Server,
                            parameters.Share ==null?"":parameters.Share,
                            parameters.Root ==null?"":parameters.Root
                            );

                        switch (parameters.Protocol)
                        {
                            case Protocol.LOCAL:
                                _endpoints[name] = new LocalEndpoint(parameters);
                                break;
                            case Protocol.SSH:
                                _endpoints[name] = new SFTP2Endpoint(parameters);
                                break;
                            case Protocol.UNC:
                                _endpoints[name] = new NetworkEndpoint(parameters);
                                break;
                        }
                    }

                    foreach (string name in remaining)
                        _endpoints.Remove(name);
                }
                catch(Exception e)
                {
                    Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_CONFIG, e, "Failed to load configuration.  Settings may not have been updated correctly.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\LocalEndpoint.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace xonline.tools.xltrans.service
{
    class LocalEndpoint : Endpoint
    {
        public LocalEndpoint(EndpointParameters parameters)
            : base(parameters)
        {
        }
        public override void CreateDirectory(string path)
        {
            CheckPath(path);
            String fullpath = Path.Combine(_parameters.Root, path);
            Directory.CreateDirectory(fullpath);
        }

        public override void RemoveDirectory(string path)
        {
            CheckPath(path);
            String fullpath = Path.Combine(_parameters.Root, path);
            Directory.Delete(fullpath);
        }

        public override Stream OpenStream(string filename, FileMode mode, FileAccess access)
        {
            CheckPath(filename);
            String fullpath = Path.Combine(_parameters.Root, filename);
            return new FileStream(fullpath, mode, access);
        }

        public override void MoveFile(string oldfile, string newfile)
        {
            CheckPath(oldfile, newfile);

            oldfile = Path.Combine(_parameters.Root, oldfile);
            newfile = Path.Combine(_parameters.Root, newfile);

            File.Move(oldfile, newfile);
        }

        public override void RemoveFile(string filename)
        {
            CheckPath(filename);
            String fullpath = Path.Combine(_parameters.Root, filename);
            File.Delete(fullpath);
        }

        public override string[] ListFiles(string path)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override bool Exists(string filename)
        {
            CheckPath(filename);
            String fullpath = Path.Combine(_parameters.Root, filename);
            return File.Exists(fullpath);
        }

        public override FileStats GetFileInfo(string filename)
        {
            FileInfo fileInfo;
            FileStats fileStats;

            CheckPath(filename);
            fileInfo = new FileInfo(Path.Combine(_parameters.Root, filename));
            fileStats = new FileStats();
            fileStats.CreationTime = fileInfo.CreationTime;
            fileStats.DirectoryName = fileInfo.DirectoryName;
            fileStats.LastAccessTime = fileInfo.LastAccessTime;
            fileStats.LastWriteTime = fileInfo.LastWriteTime;
            fileStats.Length = fileInfo.Length;
            fileStats.Name = fileInfo.Name;

            return fileStats;
        }

        public override string GetPhysicalPath(string filename)
        {
            CheckPath(filename);
            return GetFullPath(filename);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\Governor.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace xonline.tools.xltrans.service
{
    /// <summary>
    /// Dijkstra's Counting Semaphore with an adjustable limit, and no error checking.
    /// </summary>
    public class Governor
    {
        private AutoResetEvent _released;
        private int _maximum, _available;

        /// <summary>
        /// Maximum number of active resources
        /// </summary>
        public int Maximum
        {
            get
            {
                return _maximum;
            }
            set
            {
                lock (this)
                {
                    Interlocked.Add(ref _available, value - _maximum);
                    _maximum = value;
                    _released.Set();
                }
            }
        }

        public Governor()
        {
            _maximum = 0;
            _available = 0;
            _released = new AutoResetEvent(false);
        }

        public Governor(int maximum)
        {
            _maximum = maximum;
            _available = maximum;
            _released = new AutoResetEvent(false);
        }

        /// <summary>
        /// Release a resource for another process to use
        /// </summary>
        public void Leave()
        {
            Interlocked.Increment(ref _available);
            _released.Set();
        }

        /// <summary>
        /// Wait for a resource to become available
        /// </summary>
        /// <returns></returns>
        public bool Enter()
        {
            while (_available <= 0)
            {
                _released.WaitOne(15, false);
            }
            Interlocked.Decrement(ref _available);
            return true;
        }

        /// <summary>
        /// Take ownership of all the resources, and set _maximum to 0.
        /// </summary>
        /// <returns></returns>
        public bool EnterAll()
        {
            lock (this)
            {
                Interlocked.Add(ref _available, -_maximum);
                _maximum = 0;
                while (_available < 0)
                {
                    _released.WaitOne(15, false);
                }
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\endpoint.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;

namespace xonline.tools.xltrans.service
{
    class TransferAsyncResult : IAsyncResult
    {
        private EventWaitHandle _completeEvent;
        private Boolean _isComplete;
        private Object _state;
        private AsyncCallback _callback;
        public Stream Source, Destination;
        public Byte[] Buffer;
        public Exception Exception;

        public object AsyncState
        {
            get { return _state; }
        }

        public WaitHandle AsyncWaitHandle
        {
            get { return _completeEvent; }
        }

        public bool CompletedSynchronously
        {
            get { return false; }
        }

        public bool IsCompleted
        {
            get { return _isComplete; }
        }

        public TransferAsyncResult(Stream source, Stream destination, int buffersize, AsyncCallback callback, Object state)
        {
            _completeEvent = new EventWaitHandle(false, EventResetMode.ManualReset);
            _isComplete = false;
            _callback = callback;
            _state = state;
            Source = source;
            Destination = destination;
            Buffer = new byte[buffersize];
            Exception = null;
        }

        public void Complete()
        {
            try { Source.Close(); }
            catch { }
            try { Destination.Close(); }
            catch { }
            _isComplete = true;
            _completeEvent.Set();
            if (_callback != null)
                _callback(this);
        }
    }

    public class FileStats
    {
        // Gets a string representing the directory's full path.
        public string DirectoryName;

        // Gets the size of the current file.
        public long Length;

        // Gets the name of the file.
        public string Name;

        // Gets or sets the creation time of the current System.IO.FileSystemInfo object.
        public DateTime CreationTime;

        // Gets or sets the time the current file or directory was last accessed.
        public DateTime LastAccessTime;

        // Gets or sets the time when the current file or directory was last written to.
        public DateTime LastWriteTime;
    }

    public abstract class Endpoint
    {
        static public int BlockSize = 4096;

        public EndpointParameters _parameters;

        public Endpoint(EndpointParameters parameters)
        {
            _parameters = parameters;
        }
        protected void CheckPath(String path)
        {
            if (Path.GetPathRoot(path) != "")
                throw new ArgumentException("Path can not be rooted.");

            String[] elements = path.Split(new char[] { '\\', '/' });
            int depth = 0;
            for (int i = 0; i < elements.Length; i++)
            {
                if (elements[i] == "..") depth--;
                else depth++;
            }

            if (depth < 0)
                throw new ArgumentException("Path can not access directories above the root.");
        }
        protected void CheckPath(params String[] paths)
        {
            foreach (String path in paths)
                CheckPath(path);
        }

        protected string GetFullPath(String path)
        {
            return Path.Combine(_parameters.Root, path);
        }

        public abstract void CreateDirectory(String path);
        public abstract void RemoveDirectory(String path);
        public abstract Stream OpenStream(String filename, FileMode mode, FileAccess access);
        public abstract void MoveFile(String oldfile, String newfile);
        public abstract void RemoveFile(String filename);
        public abstract String[] ListFiles(String path);
        public abstract Boolean Exists(String filename);
        public abstract FileStats GetFileInfo(String filename);
        public abstract String GetPhysicalPath(String filename);

        public static IAsyncResult BeginTransfer(Endpoint srcEndpoint, String srcPath, Endpoint dstEndpoint, String dstPath, AsyncCallback callback, Object state)
        {
            TransferAsyncResult tar = new TransferAsyncResult(
                srcEndpoint.OpenStream(srcPath, FileMode.Open, FileAccess.Read),
                dstEndpoint.OpenStream(dstPath, FileMode.Create, FileAccess.Write),
                Endpoint.BlockSize,
                callback,
                state);

            tar.Source.BeginRead(tar.Buffer, 0, tar.Buffer.Length, OnReadComplete, tar);
            return tar;
        }

        private static void OnReadComplete(IAsyncResult ar)
        {
			TransferAsyncResult transferstate = (TransferAsyncResult)ar.AsyncState;
			try 
			{
				int len = transferstate.Source.EndRead(ar);
				if (len == 0)
				{
					transferstate.Complete();
				}
				else
				{
					transferstate.Destination.BeginWrite(transferstate.Buffer, 0, len, OnWriteComplete, transferstate);
				}
			}
            catch (Exception e)
            {
				transferstate.Exception = e;
				transferstate.Complete();
            }
        }

        private static void OnWriteComplete(IAsyncResult ar)
        {
            TransferAsyncResult transferstate = (TransferAsyncResult)ar.AsyncState;
            try
            {
                transferstate.Destination.EndWrite(ar);
                transferstate.Source.BeginRead(transferstate.Buffer, 0, transferstate.Buffer.Length, OnReadComplete, transferstate);
            }
            catch (Exception e)
            {
                transferstate.Exception = e;
                transferstate.Complete();
            }
        }
        public static void EndTransfer(IAsyncResult ar)
        {
            TransferAsyncResult tar = (TransferAsyncResult)ar;
            tar.AsyncWaitHandle.WaitOne();
            tar.Source.Close();
            tar.Destination.Close();
            if (tar.Exception != null) throw tar.Exception;
        }

        public static void Transfer(Endpoint srcEndpoint, String srcPath, Endpoint dstEndpoint, String dstPath)
        {
            IAsyncResult ar = BeginTransfer(srcEndpoint, srcPath, dstEndpoint, dstPath, null, null);
            EndTransfer(ar);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\HealthRequest.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.Diagnostics;
using System.Web.UI;

namespace xonline.tools.xltrans.service
{
    class HealthRequest : IHttpHandler
    {
        #region IHttpHandler Members

        public bool IsReusable
        {
            get { return true; }
        }

        public void ProcessRequest(HttpContext context)
        {
            StringBuilder output = new StringBuilder();

            // if (context.Request["debug"] == "break" && !Debugger.IsAttached)
                // Debugger.Launch();
            
            context.Response.Write("<H1>XlTrans</H1><HR><BR>");
            try
            {
                XlTrans.Initialize();

                output.AppendLine(@"<TABLE>");
                foreach (Endpoint endpoint in EndpointManager.EnumEndpoints(null))
                {
                    EndpointParameters parameters = endpoint._parameters;
                    output.AppendFormat(@"<TR valign=""middle""><TD bgcolor=""DarkBlue"" align=""center""><H3>&nbsp;<FONT color=""White"">{0}</FONT>&nbsp;</H3></TD><TD><STRONG>{1}</STRONG></TD></TR>",
                        parameters.Protocol, parameters.Name);
                    output.AppendLine();
                    // output.AppendFormat(@"<TR><TD>&nbsp;</TD><TD>{0}</TD><TD>{1}</TD></TR>",
                        // "Protocol", parameters.Protocol);
                    // output.AppendLine();
                    // output.AppendFormat(@"<TR><TD>&nbsp;</TD><TD>{0}</TD><TD>{1}</TD></TR>",
                        // "Server", parameters.Server);
                    // output.AppendLine(); 
                    // output.AppendFormat(@"<TR><TD>&nbsp;</TD><TD>{0}</TD><TD>{1}</TD></TR>",
                        // "Share", parameters.Share);
                    // output.AppendLine();
                    // output.AppendFormat(@"<TR><TD>&nbsp;</TD><TD>{0}</TD><TD>{1}</TD></TR>",
                        // "User", parameters.User);
                    // output.AppendLine();
                    // output.AppendFormat(@"<TR><TD>&nbsp;</TD><TD>{0}</TD><TD>{1}</TD></TR>",
                        // "Root", parameters.Root);
                    // output.AppendLine();
                    output.AppendLine(@"<TR><TD>&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>");
                    output.AppendLine();
                }
                output.AppendLine(@"</TABLE>");
            }
            catch (Exception ex)
            {
                output.AppendLine();

                output.AppendLine(@"<TABLE width=""100%"">");
                output.AppendLine(@"<TR><TD bgcolor=""DarkRed"">Failure</TD></TR>");
                output.AppendLine("<TR><TD><PRE>" + ex.ToString() + "</PRE></TD></TR>");
                output.AppendLine(@"</TABLE>");
            }
            context.Response.Write(output.ToString());
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\Transfer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.IO;
using System.Threading;
using System.Xml;

namespace xonline.tools.xltrans.service
{
    public enum TransferState
    {
        NotFound = -2,
        Failed = -1,
        Pending = 0,
        Running = 1,
        Complete = 2,
    }

    /// <summary>
    /// Transfer job definition
    /// </summary>
    public class Transfer
    {
        /// <summary>
        /// Transfer Id
        /// </summary>
        public long TransferId;

        /// <summary>
        /// The source EndPoint
        /// </summary>          
        public string SourceEndPoint;

        /// <summary>
        /// The source EndPoint
        /// </summary>        
        public string SourcePath;

        /// <summary>
        /// The destination EndPoint
        /// </summary>
        public string DestinationEndPoint;

        /// <summary>
        /// The destination path
        /// </summary>
        public string DestinationPath;

        /// <summary>
        /// State of the transfer
        /// </summary>
        public TransferState State;

        /// <summary>
        /// The reason the transfer failed.
        /// </summary>
        public String FailureReason;

        [XmlIgnore]
        public string TransferIdString
        {
            get
            {
                long BeginningOfTime = 632716704000000000;
                long Adjustment = TransferId  % 10000;
                long AdjustedTime = TransferId / 1000 + BeginningOfTime;
                DateTime Time = new DateTime(AdjustedTime);

                return String.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}{6:D3}{7:D4}",
                    Time.Year, Time.Month, Time.Day, Time.Hour, Time.Minute, Time.Second,
                    Time.Millisecond, Adjustment);
            }
        }

        private static Random RandomGenerator = new Random((int)DateTime.Now.Ticks);
        public static long NewId()
        {
            long BeginningOfTime = 632716704000000000;
            long CurrentTime = DateTime.Now.ToUniversalTime().Ticks;
            long AdjustedTime = (CurrentTime - BeginningOfTime) * 1000;
            return AdjustedTime + RandomGenerator.Next(1000);
        }

        /// <summary>
        /// Default constructor
        /// </summary>
        public Transfer()
        {
            this.TransferId = NewId();
            this.SourceEndPoint = null;
            this.SourcePath = null;
            this.DestinationEndPoint = null;
            this.DestinationPath = null;
            this.State = TransferState.Pending;
            this.FailureReason = "";
        }


        public static void Serialize(String Directory, Transfer transfer)
        {
            String FileName = transfer.TransferId.ToString() + ".xml";
            String FilePath = Path.Combine(Directory, FileName);
            Boolean Complete = false;

            while (!Complete)
            {
                try
                {
                    XmlUtil.SerializeFile(FilePath, transfer);
                    Complete = true;
                }
                catch
                {
                    Thread.Sleep(250);
                }
            }
        }
        public static Transfer Deserialize(String Directory, long transferId)
        {
            return Deserialize(Path.Combine(Directory, transferId.ToString() + ".xml"));
        }
        public static Transfer Deserialize(String FileName)
        {
            Boolean Complete = false;
            Transfer transfer = null;

            if (!File.Exists(FileName))
                return null;

            while (!Complete)
            {
                try
                {
                    XmlUtil.DeserializeFile(FileName, out transfer);
                    Complete = true;
                }
                catch
                {
                    Thread.Sleep(250);
                }
            }

            return transfer;
        }

        

        public static Transfer Remove(String Directory, long transferId)
        {
            String FileName = transferId.ToString() + ".xml";
            String FilePath = Path.Combine(Directory, FileName);
            Boolean Complete = false;
            Transfer transfer = null;

            if (!File.Exists(FilePath))
                return null;

            while (!Complete)
            {
                try
                {
                    File.Delete(FilePath);
                    Complete = true;
                }
                catch
                {
                    Thread.Sleep(250);
                }
            }

            return transfer;
        }

        public static Transfer Move(String OldDirectory, String NewDirectory, long transferId)
        {
            String FileName = transferId.ToString() + ".xml";
            String OldFilePath = Path.Combine(OldDirectory, FileName);
            String NewFilePath = Path.Combine(NewDirectory, FileName);
            Boolean Complete = false;
            Transfer transfer = null;

            if (!File.Exists(OldFilePath))
                return null;

            while (!Complete)
            {
                try
                {
                    File.Move(OldFilePath, NewFilePath);
                    Complete = true;
                }
                catch
                {
                    Thread.Sleep(250);
                }
            }

            return transfer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\XlTransApplication.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.Diagnostics;

namespace xonline.tools.xltrans.service
{
    public class XlTransApplication : HttpApplication
    {
        public virtual void Application_Error(object sender, EventArgs e)
        {
            //get reference to the source of the exception chain
            Exception ex = Server.GetLastError().GetBaseException();

            Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_WEBSVC_FAILURE, ex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xltrans_none_12.4.56.0_none_32c2e4ec675b3c67
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xltrans
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.manifest
XP_MANIFEST_PATH=manifests\msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.cat
XP_CATALOG_PATH=manifests\msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.cat
XP_PAYLOAD_PATH=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xltrans,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\TransferQueue.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.IO;

namespace xonline.tools.xltrans.service
{
    static class TransferQueue
    {
        static private Queue<Transfer> _queue;
        static private Dictionary<long, Transfer> _transfers;

        static TransferQueue()
        {
            _queue = new Queue<Transfer>();
            _transfers = new Dictionary<long, Transfer>();
        }

        static public void LoadQueue()
        {
            lock (_queue)
            {
                foreach (String file in Directory.GetFiles(XlTrans.TransferDirectory, "*.xml"))
                {
                    Transfer transfer = Transfer.Deserialize(file);
                    if (transfer.State == TransferState.Pending)
                    {
                        Enqueue(transfer);
                    }
                    else
                    {
                        lock (_transfers)
                        {
                            _transfers[transfer.TransferId] = transfer;
                        }
                    }
                }
            }
        }            

        static public void Enqueue(Transfer transfer)
        {
            Transfer.Serialize(XlTrans.TransferDirectory, transfer);
            lock (_queue)
            {
                _queue.Enqueue(transfer);
                lock (_transfers)
                {
                    _transfers[transfer.TransferId] = transfer;
                }
                Monitor.PulseAll(_queue);
            }
        }
        static public Transfer Dequeue()
        {
            lock (_queue)
            {
                while (!Monitor.Wait(_queue, 100) && _queue.Count == 0);
                    
                return _queue.Dequeue();
            }
        }

        static public Transfer GetTransfer(long transferId)
        {
            if (_transfers.ContainsKey(transferId))
                return _transfers[transferId];

            Transfer transfer = Transfer.Deserialize(XlTrans.TransferDirectory, transferId);
            if (transfer == null)
                return null;
            lock (_transfers)
            {
                _transfers[transfer.TransferId] = transfer;
            }
            return transfer;
        }

        static public void Complete(long transferId)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\SFtpEndpoint.cs ===
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;

namespace xonline.tools.xltrans.service
{
    class SFTP2Endpoint : Endpoint
    {
        private SFtpSession _session;
        private SshStream _sshstream;

        public SFTP2Endpoint(EndpointParameters parameters)
            : base(parameters)
        {
            _parameters = parameters;
            _sshstream = new SshStream(_parameters.User, _parameters.Server, "sftp");
            _sshstream.Connect();
            _session = new SFtpSession(_sshstream);
            try
            {
                _session.CreateDirectory(_parameters.Root);
            }
            catch (Exception ex)
            {
                Logging.WriteException(EventLogEntryType.Warning, EventId.XLTRANS_TRANSFER_WARNING, ex,
                    "Failed to create the root directory.  This may be a non-fatal error if the directory " +
                    "already exists.");

            }
        }

        public override void CreateDirectory(string path)
        {
            path = path.Replace('\\', '/');
            CheckPath(path);
            Reconnect();

            _session.CreateDirectory(GetFullPath(path));
        }

        public override void RemoveDirectory(string path)
        {
            path = path.Replace('\\', '/');
            CheckPath(path);
            Reconnect();

            _session.RemoveDirectory(GetFullPath(path));
        }

        public override Stream OpenStream(string filename, FileMode mode, FileAccess access)
        {
            filename = filename.Replace('\\', '/');
            CheckPath(filename);
            Reconnect();

            String fullpath = GetFullPath(filename);

            return new SFtpStream(_session, fullpath, mode, access);
        }

        public override void MoveFile(string oldfile, string newfile)
        {
            oldfile = oldfile.Replace('\\', '/');
            newfile = newfile.Replace('\\', '/');
            CheckPath(oldfile, newfile);
            Reconnect();

            _session.Rename(GetFullPath(oldfile), GetFullPath(newfile));
        }

        public override void RemoveFile(string filename)
        {
            filename = filename.Replace('\\', '/');
            CheckPath(filename);
            Reconnect();

            _session.RemoveFile(GetFullPath(filename));
        }

        public override string[] ListFiles(string path)
        {
            path = path.Replace('\\', '/');
            CheckPath(path);

            List<string> filelist = new List<string>();
            SFtpHandle handle = _session.OpenDirectory(GetFullPath(path));
            SFtpFileInfo [] files;

            while ((files = _session.ReadDirectory(handle)) != null)
            {
                foreach (SFtpFileInfo file in files)
                {
                    filelist.Add(Path.Combine(GetFullPath(path), file.FileName));
                }
            }
            _session.CloseDirectory(handle);
            return filelist.ToArray();            
        }

        private void Reconnect()
        {
            lock (this)
            {
                if (!_session.Connected)
                {
                    _sshstream = new SshStream(_parameters.User, _parameters.Server, "sftp");
                    _sshstream.Connect();
                    _session = new SFtpSession(_sshstream);
                }
            }
        }

        public override bool Exists(string filename)
        {
            filename = filename.Replace('\\', '/');
            CheckPath(filename);
            Reconnect();

            String fullpath = GetFullPath(filename);

            try
            {
                _session.GetAttributes(fullpath);
            }
            catch (SFtpSessionStatusException)
            {
                return false;
            }
            return true;
        }

        private static DateTime _baseUnixTime = new DateTime(1970, 1, 1, 0, 0, 0);
        public override FileStats GetFileInfo(string filename)
        {
            FileStats fileStats;
            SFtpFileAttributes fileAttribs;

            filename = filename.Replace('\\', '/');
            CheckPath(filename);
            Reconnect();

            String fullpath = GetFullPath(filename);

            try
            {
                fileAttribs = _session.GetAttributes(fullpath);

                fileStats = new FileStats();
                fileStats.CreationTime = _baseUnixTime.ToLocalTime();
                fileStats.DirectoryName = filename;
                fileStats.LastAccessTime = _baseUnixTime.AddSeconds(fileAttribs.AccessTime).ToLocalTime();
                fileStats.LastWriteTime = _baseUnixTime.AddSeconds(fileAttribs.ModifiedTime).ToLocalTime();
                fileStats.Length = (long)fileAttribs.Size;
                fileStats.Name = filename;

                return fileStats;
            }
            catch (SFtpSessionStatusException)
            {
                return null;
            }
        }

        /// <summary>
        /// Return the SFTP uri as specified by:
        ///     http://tools.ietf.org/id/draft-ietf-secsh-scp-sftp-ssh-uri-04.txt
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public override string GetPhysicalPath(string filename)
        {
            return String.Format("sftp://{0}@{1}/{2}", _parameters.User, _parameters.Server, GetFullPath(filename));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\NetworkEndpoint.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace xonline.tools.xltrans.service
{
    class NetworkEndpoint : Endpoint
    {
        private String _basepath;

        public NetworkEndpoint(EndpointParameters parameters)
            : base(parameters)
        {
            _basepath = @"\\" + _parameters.Server + @"\" + _parameters.Share + @"\" + _parameters.Root + @"\";
        }
        new protected string GetFullPath(String path)
        {
            return Path.Combine(_basepath, path);
        }
        public override void CreateDirectory(string path)
        {
            CheckPath(path);
            String fullpath = Path.Combine(_basepath, path);
            Directory.CreateDirectory(fullpath);
        }

        public override void RemoveDirectory(string path)
        {
            CheckPath(path);
            String fullpath = Path.Combine(_basepath, path);
            Directory.Delete(fullpath);
        }

        public override Stream OpenStream(string filename, FileMode mode, FileAccess access)
        {
            CheckPath(filename);
            return new FileStream(Path.Combine(_basepath,filename), mode, access);
        }

        public override void MoveFile(string oldfile, string newfile)
        {
            CheckPath(oldfile, newfile);

            oldfile = Path.Combine(_basepath, oldfile);
            newfile = Path.Combine(_basepath, newfile);

            File.Move(oldfile, newfile);
        }

        public override void RemoveFile(string filename)
        {
            CheckPath(filename);
            String fullpath = Path.Combine(_basepath, filename);
            File.Delete(fullpath);
        }

        public override string[] ListFiles(string path)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        public override bool Exists(string filename)
        {
            CheckPath(filename);
            return File.Exists(Path.Combine(_basepath, filename));
        }

        public override FileStats GetFileInfo(string filename)
        {
            FileInfo fileInfo;
            FileStats fileStats;

            CheckPath(filename);
            fileInfo = new FileInfo(GetFullPath(filename));
            fileStats = new FileStats();
            fileStats.CreationTime = fileInfo.CreationTime;
            fileStats.DirectoryName = fileInfo.DirectoryName;
            fileStats.LastAccessTime = fileInfo.LastAccessTime;
            fileStats.LastWriteTime = fileInfo.LastWriteTime;
            fileStats.Length = fileInfo.Length;
            fileStats.Name = fileInfo.Name;
            
            return fileStats;
        }

        public override string GetPhysicalPath(string filename)
        {
            CheckPath(filename);
            return GetFullPath(filename);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmlappend\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xltrans_none_12.4.56.0_none_32c2e4ec675b3c67
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xltrans
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.manifest
XP_MANIFEST_PATH=manifests\msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.cat
XP_CATALOG_PATH=manifests\msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417.cat
XP_PAYLOAD_PATH=msil_xltrans_no-public-key_12.4.56.0_x-ww_61a1f417
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xltrans,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmlappend\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmlappend\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmlappend\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmlappend_none_12.4.56.0_none_5399cf6403b4732e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmlappend
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.manifest
XP_MANIFEST_PATH=manifests\msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.cat
XP_CATALOG_PATH=manifests\msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.cat
XP_PAYLOAD_PATH=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmlappend,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xltrans\xltrans\xltrans.cs ===
using System;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Web.Configuration;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using xonline.tools.xltrans.service;
using System.Threading;
using System.Text.RegularExpressions;

namespace xonline.tools.xltrans.service
{
    public class TransferStatus
    {
        public TransferState state;
        public int errorcode;
        public String message;
    }

    [WebService(Namespace = "http://websvc.xboxlive.com/xltrans/")]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    public class XlTrans : System.Web.Services.WebService
    {
        private static Regex WinPathSoap = new Regex("\\\\+", RegexOptions.Compiled);
        private static Regex UnixPathSoap = new Regex("/+", RegexOptions.Compiled);
        private static Thread _transferThread = null;
        public static Governor CoreGovernor;
        public static string TransferDirectory;


        static XlTrans()
        {
            try
            {
                TransferDirectory = Environment.CurrentDirectory;
                CoreGovernor = new Governor(1);
                EndpointManager.Initialize();
                StartTransferThread();
            }
            catch (Exception e)
            {
                throw Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_WEBSVC_FAILURE, e);
            }
        }

        public static void Initialize()
        {
        }


        /// <summary>
        /// Transfer a file from a source end point to a destination end point
        /// </summary>
        /// <param name=sourceEndpoint>Source to transfer from</param>
        /// <param name=sourceFilePath>Path to the source file from the source</param>
        /// <param name=destEndpoint>Destination environment to transfer to</param>
        /// <param name=destFilePath> The filename relative and rooted to the specified destination path </param>
        /// <returns> A transfer Id, which can be later used to check the status of the transfer </returns>
        [WebMethod(Description = "Transfer a file from a source end point to a destination end point")]
        public long TransferFile(string sourceEndpoint, string sourceFilePath, string destEndpoint, string destFilePath)
        {
            if (!((sourceFilePath[0] != '\\' && sourceFilePath[0] != '/') || (destFilePath[0] != '\\' && destFilePath[0] != '/')))
            {
                throw Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_ENQUEUE_BADARGUMENT,
                    new ArgumentException("Invalid source or destination path.  Paths must not start with a root character, \\ or /"),
                                    "Failed to Enqueue transfer from \"{0}:\\{1}\" to \"{2}:\\{3}\"",
                                    sourceEndpoint, sourceFilePath,
                                    destEndpoint, destFilePath);
            }

            if (
                sourceFilePath.Replace("\\", "/").StartsWith("../") ||
                sourceFilePath.Replace("\\", "/").Contains("/../") ||
                sourceFilePath.Replace("\\", "/").EndsWith("/..") ||
                destFilePath.Replace("\\", "/").StartsWith("../") ||
                destFilePath.Replace("\\", "/").Contains("/../") ||
                destFilePath.Replace("\\", "/").EndsWith("/.."))
            {
                throw Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_ENQUEUE_BADARGUMENT,
                    new ArgumentException("Invalid source or destination path.  Paths must not contain \"..\""),
                                    "Failed to Enqueue transfer from \"{0}:\\{1}\" to \"{2}:\\{3}\"",
                                    sourceEndpoint, sourceFilePath,
                                    destEndpoint, destFilePath);
            }

            try
            {
                sourceFilePath = WinPathSoap.Replace(sourceFilePath, "\\");
                sourceFilePath = UnixPathSoap.Replace(sourceFilePath, "\\");
                destFilePath = WinPathSoap.Replace(destFilePath, "\\");
                destFilePath = UnixPathSoap.Replace(destFilePath, "\\");

                Transfer transfer = new Transfer();
                transfer.SourceEndPoint = sourceEndpoint;
                transfer.SourcePath = sourceFilePath;
                transfer.DestinationEndPoint = destEndpoint;
                transfer.DestinationPath = destFilePath;

                TransferQueue.Enqueue(transfer);

                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_ENQUEUE,
                    "Enqueued transfer from \"{0}:\\{1}\" to \"{2}:\\{3}\" with transferId {4}.",
                    transfer.SourceEndPoint, transfer.SourcePath,
                    transfer.DestinationEndPoint, transfer.DestinationPath,
                    transfer.TransferId);

                return transfer.TransferId;
            }
            catch (Exception e)
            {
                throw Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_ENQUEUE_FAILURE, e);
            }
        }

        /// <summary>
        /// Gets the status of a transfer
        /// </summary>
        /// <param name="transferId">Transfer Identifier returned by TransferFile</param>
        /// <param name="message">Message in the case of failure.</param>
        /// <returns>State of the transfer.</returns>
        [WebMethod(Description = "Gets the status of a transfer")]
        public TransferStatus GetTransferStatusEx(long transferId)
        {
            TransferStatus status = new TransferStatus();
            Transfer transfer = null;

            try
            {
                transfer = TransferQueue.GetTransfer(transferId);
                if (transfer == null)
                {
                    status.message = "Transfer not found.";
                    status.state = TransferState.NotFound;
                }
                else
                {
                    status.state = transfer.State;
                    if (transfer.State == TransferState.Failed)
                    {
                        status.message = transfer.FailureReason;
                    }
                    else
                    {
                        status.message = transfer.State.ToString();
                    }
                }
                return status;
            }
            catch (Exception e)
            {
                throw Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_GETTRANSFERSTATUS_FAILURE, e);
            }
        }

        /// <summary>
        /// Transfer a file from a source end point to a destination end point, with a toolsmgmt jobId
        /// </summary>
        /// <param name=srcRootId>Source to transfer from</param>
        /// <param name=srcFilePath>Path to the source file from the source</param>
        /// <param name=dstRootId>Destination environment to transfer to</param>
        /// <param name=jobId>ToolsMgmt JobId</param>
        /// <param name=dstFilePath> The filename relative and rooted to the specified destination path </param>
        /// <returns> A transfer Id, which can be later used to check the status of the transfer </returns>    [WebMethod]
        [WebMethod(Description = "Transfer a file from a source end point to a destination end point, with a toolsmgmt jobId")]
        public long JobTransferFile(String srcRootID, String srcFilePath, String dstRootID, long jobId, String dstFilePath)
        {
            return TransferFile(srcRootID, srcFilePath, dstRootID, jobId.ToString() + "\\" + dstFilePath);
        }

        /// <summary>
        /// Gets the status of a transfer
        /// </summary>
        /// <param anme=transferId>Transfer Identifier returned by TransferFile</param>
        /// <returns> Percent of the file transferred (could be, 0, 1, and 100, where 0 indicates waiting to transfer)</returns>
        [WebMethod(Description = "Gets the status of a transfer")]
        public TransferState GetTransferStatus(long transferId)
        {
            return GetTransferStatusEx(transferId).state;
        }

        /// <summary>
        /// Get general file information.
        /// </summary>
        /// <remarks>
        /// Currently only UNC paths are returned, though others are 
        /// implemented.
        /// </remarks>
        /// <param name="endpointName">Endpoint with the file</param>
        /// <param name="fileName">File to retrieve information about</param>
        /// <returns></returns>
        [WebMethod(Description = "Get general file information.")]
        public FileStats GetFileStats(String endpointName, String fileName)
        {
            Endpoint endpoint = EndpointManager.GetEndpoint(endpointName);

            if (endpoint == null)
                return null;

            if (endpoint._parameters.Protocol != Protocol.UNC)
                return null;

            return endpoint.GetFileInfo(fileName);
        }

        /// <summary>
        /// Gets the physical path in a format determined by the protocol
        /// for the given filename.
        /// </summary>
        /// <remarks>
        /// Currently only UNC paths are returned, though others are 
        /// implemented.
        /// </remarks>
        /// <param name="endpointName">Endpoint with the file</param>
        /// <param name="fileName">File to retrieve the physical path for</param>
        /// <returns></returns>
        [WebMethod(Description = "Gets the physical path in a format determined by the protocol for the given filename.")]
        public String GetPhysicalPath(String endpointName, String fileName)
        {
            Endpoint endpoint = EndpointManager.GetEndpoint(endpointName);

            if (endpoint == null)
                return null;

            if (endpoint._parameters.Protocol != Protocol.UNC)
                return null;

            return endpoint.GetPhysicalPath(fileName);
        }

        private static void StartTransferThread()
        {
            if (_transferThread == null || !_transferThread.IsAlive)
            {
                _transferThread = new Thread(TransferThread);
                _transferThread.Start();
            }
        }

        private static void TransferThread()
        {
            Boolean running = true;
            Thread thread = null;
            Object transfer = null;

            //Debug.Assert(false);

            try
            {
                EndpointManager.Initialize();
                TransferQueue.LoadQueue();

                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_STARTED, "XlTrans started.");
                while (running)
                {
                    CoreGovernor.Enter();
                    transfer = TransferQueue.Dequeue();
                    thread = new Thread(ExecuteTransfer);
                    thread.Start(transfer);
                }
                CoreGovernor.EnterAll();
                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_STOPPED, "XlTrans stopped.");
            }
            catch (Exception e)
            {
                throw Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_GENERAL_FAILURE, e,
                    "XlTrans crashed with a fatal exception.");
            }
        }

        static void ExecuteTransfer(object arg)
        {
            Endpoint destination, source;
            Transfer transfer = null;
            String fullpath;
            String[] directories;

            try
            {
                transfer = (Transfer)arg;

                source = EndpointManager.GetEndpoint(transfer.SourceEndPoint);
                if (source == null)
                    throw new ArgumentException("Unknown Source Endpoint " + transfer.SourceEndPoint);
                destination = EndpointManager.GetEndpoint(transfer.DestinationEndPoint);
                if (destination == null)
                    throw new ArgumentException("Unknown Destination Endpoint " + transfer.DestinationEndPoint);

                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_TRANSFER_START, "Transfer {0} has started.\n\n{1}:{2} => {3}:{4}",
                    transfer.TransferId,
                    transfer.SourceEndPoint, transfer.SourcePath,
                    transfer.DestinationEndPoint, transfer.DestinationPath);

                fullpath = null;
                directories = transfer.DestinationPath.Split(new char[] { '\\' });
                for (int i = 0; i < directories.Length - 1; i++)
                {
                    fullpath = fullpath == null ? directories[i] : fullpath + "\\" + directories[i];
                    try
                    {
                        destination.CreateDirectory(fullpath);
                    }
                    catch (Exception e)
                    {
                        Logging.WriteException(EventLogEntryType.Warning, EventId.XLTRANS_TRANSFER_WARNING,
                        e,
                        "TransferId {0} from \"{1}:\\{2}\" to \"{3}:\\{4}\" failed to create directory \"{3}:{5}\" with exception:",
                        transfer.TransferId,
                        transfer.SourceEndPoint, transfer.SourcePath,
                        transfer.DestinationEndPoint, transfer.DestinationPath,
                        fullpath);
                    }
                }

                transfer.State = TransferState.Running;
                Endpoint.Transfer(
                    source,
                    transfer.SourcePath,
                    destination,
                    transfer.DestinationPath);
                transfer.State = TransferState.Complete;
                Logging.WriteLog(EventLogEntryType.Information, EventId.XLTRANS_TRANSFER_COMPLETE, "Transfer {0} completed.\n\n{1}:{2} => {3}:{4}",
                    transfer.TransferId,
                    transfer.SourceEndPoint, transfer.SourcePath,
                    transfer.DestinationEndPoint, transfer.DestinationPath);
                //Transfer.Remove(XlTrans.TransferDirectory, transfer.TransferId);
            }
            catch (Exception e)
            {
                if (transfer == null)
                {
                    Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_TRANSFER_FAILURE,
                        new ArgumentException("Invalid argument passed to transfer thread"),
                        "TransferId {0} from \"{1}:\\{2}\" to \"{3}:\\{4}\" failed with exception:",
                        transfer.TransferId,
                        transfer.SourceEndPoint, transfer.SourcePath,
                        transfer.DestinationEndPoint, transfer.DestinationPath);
                }
                else
                {
                    transfer.State = TransferState.Failed;
                    transfer.FailureReason = e.Message;
                    Logging.WriteException(EventLogEntryType.Error, EventId.XLTRANS_TRANSFER_FAILURE, e,
                        "TransferId {0} from \"{1}:\\{2}\" to \"{3}:\\{4}\" failed with exception:",
                        transfer.TransferId,
                        transfer.SourceEndPoint, transfer.SourcePath,
                        transfer.DestinationEndPoint, transfer.DestinationPath);
                }
                transfer.State = TransferState.Failed;
            }
            finally
            {
                Transfer.Serialize(XlTrans.TransferDirectory, transfer);
                TransferQueue.Complete(transfer.TransferId);
                CoreGovernor.Leave();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmlappend\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmlappend_none_12.4.56.0_none_5399cf6403b4732e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmlappend
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.manifest
XP_MANIFEST_PATH=manifests\msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.cat
XP_CATALOG_PATH=manifests\msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114.cat
XP_PAYLOAD_PATH=msil_xmlappend_no-public-key_12.4.56.0_x-ww_99939114
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmlappend,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmlappend\xmlappend.cs ===
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml;

namespace xonline.tools.xmlappend
{     
    class XmlAppend
    {
        static void Usage()
        {
            Console.WriteLine("------------------------------------------------------------------");
            Console.WriteLine("xmlappend -list XMLLIST -out OUTFILE [-xpathoverride XPATHOVERRIDE]");     
            Console.WriteLine("XMLLIST   :   A TXT file containing all XML files to include");
            Console.WriteLine("OUTFILE   :   The output master XML file");
            Console.WriteLine("XPATHOVERRIDE   :   Optional, the xpath to select the nodes to append (default=/d:database/d:table)");
            Console.WriteLine("e.g.     xmlappend -list npdb.list -out npdb.xml -xpathoverride /d:database/d:table");
            Console.WriteLine("------------------------------------------------------------------");
            
        }

        /*
            This tool will read a comma separated text file for all the xml files to include.
            It will then generate a master xml file which will include all of the above files. 

            Note: When XINCLUDE is fully supported, we should use it. http://www.w3.org/TR/xinclude/
        */
        static int Main(string[] args)
        {
            List<string> list = new List<string>();
            string szOutputFile = null;
            string szNamespaceShortForm = "d";
            string szXPath = string.Format("/{0}:database/{0}:table", szNamespaceShortForm);

            Hashtable m_htXmlList = new Hashtable();

            try
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i] == "-list")
                    {
                        list.Add(args[i + 1]);
                        i = i + 1;
                    }

                    if (args[i] == "-out")
                    {
                        szOutputFile = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-xpathoverride")
                    {
                        szXPath = args[i + 1];
                        i = i + 1;
                    }
                }

                if (0 == list.Count || null == szOutputFile)
                {
                    throw new Exception("Some arguments are invalid");
                }

                foreach (string szListFilePath in list)
                {
                    using (StreamReader objReader = new StreamReader(szListFilePath))
                    {
                        string szLine = null;

                        while ((szLine = objReader.ReadLine()) != null)
                        {
							if( szLine.Trim() == String.Empty )
							{
								continue;
							}
                            string[] arrXMLFiles = szLine.Split(new Char[] { ' ', ',', ';' });
                            foreach (string szFile in arrXMLFiles)
                            {
                                if (m_htXmlList[szFile] == null)
                                {
                                    m_htXmlList.Add(System.Environment.ExpandEnvironmentVariables(szFile.Trim().ToLower()), 1);
                                }
                            }
                        }
                    }
                }

                XmlDocument masterDoc = null;
                XmlNamespaceManager namespaceMgr = null;

                foreach (string szFile in m_htXmlList.Keys)
                {
                    Console.WriteLine("{0}", szFile);
                    if (null == masterDoc)
                    {
                        masterDoc = new XmlDocument();
                        masterDoc.Load(szFile);

                        namespaceMgr = new XmlNamespaceManager(masterDoc.NameTable);
                        namespaceMgr.AddNamespace(szNamespaceShortForm, "http://www.xboxlive.com/dml"); 
                    }
                    else
                    {
                        XmlDocument xmlTempDoc = new XmlDocument();
                        xmlTempDoc.Load(szFile);

                        XmlNodeList xmlNodes = xmlTempDoc.SelectNodes(szXPath, namespaceMgr);
                        foreach (XmlNode xmlNode in xmlNodes)
                        {
                            masterDoc.DocumentElement.AppendChild(masterDoc.ImportNode(xmlNode, true));
                        }
                    }
                }

                XmlTextWriter writer = new XmlTextWriter(szOutputFile, Encoding.UTF8);
                writer.Formatting = Formatting.Indented;

                masterDoc.WriteTo(writer);
                writer.Close();

                return 0;
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                return 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\Difference.cs ===
//-----------------------------------------------------------------------
// <copyright file="Difference.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   enum to specify xml difference
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    /// <summary>
    /// Enum to specify the xml difference
    /// </summary>
    public enum Difference
    {
        /// <summary>
        /// No difference
        /// </summary>
        None,

        /// <summary>
        /// Node added
        /// </summary>
        Add,

        /// <summary>
        /// Element removed
        /// </summary>
        Remove,

        /// <summary>
        /// Element moved
        /// </summary>
        Move,

        /// <summary>
        /// Node changed
        /// </summary>2
        Change,

        /// <summary>
        /// Node changed namespace
        /// </summary>
        ChangeNamespace,

        /// <summary>
        /// Node changed prefix
        /// </summary>
        ChangePrefix
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\NodeAttribute.cs ===
//-----------------------------------------------------------------------
// <copyright file="NodeAttribute.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe the attributes of an element
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    using System;

    /// <summary>
    /// Class to describe an xml attribute
    /// </summary>
    public sealed class NodeAttribute : Node, ICloneable
    {
        /// <summary>
        /// Initializes a new instance of the NodeAttribute class
        /// </summary>
        internal NodeAttribute()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NodeAttribute class
        /// </summary>
        /// <param name="localName">The local name of the attribute</param>
        /// <param name="prefix">The namespace prefix of the attribute</param>
        /// <param name="namespaceURI">The namespace uri of the attribute</param>
        /// <param name="value">The value of the attribute</param>
        internal NodeAttribute(string localName, string prefix, string namespaceURI, string value)
            : base(localName, prefix, namespaceURI)
        {
            this.Value = value;
        }

        /// <summary>
        /// Initializes a new instance of the NodeAttribute class
        /// </summary>
        /// <param name="nodeAttribute">The node attribute instance to copy to the new instance</param>
        private NodeAttribute(NodeAttribute nodeAttribute)
            : base(nodeAttribute)
        {
        }

        /// <summary>
        /// Creates a new object that is a copy of the current instance
        /// </summary>
        /// <returns>A new object that is a copy of the current instance</returns>
        object System.ICloneable.Clone()
        {
            // create a new attribute
            return new NodeAttribute(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\IgnoreXPathCollection.cs ===
//-----------------------------------------------------------------------
// <copyright file="IgnoreXPathCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   collection of xpaths that should be ignored during comparison
// </summary>
//-----------------------------------------------------------------------
namespace Microsoft.XmlDiffPatch
{
    using System.Collections.Specialized;
    using System.Text;

    /// <summary>
    /// Class to represent a collection of xpaths that should be ignore during comparison
    /// </summary>
    public sealed class IgnoreXPathCollection
    {
        /// <summary>
        /// The underlying collection of the IgnoreXPathCollection class
        /// </summary>
        private StringDictionary stringDictionary = new StringDictionary();

        /// <summary>
        /// Initializes a new instance of the IgnoreXPathCollection class that is empty
        /// </summary>
        public IgnoreXPathCollection()
        {
        }

        /// <summary>
        /// Adds the specified xpath to the collection
        /// </summary>
        /// <param name="xpath">The xpath to add to the collection</param>
        public void Add(string xpath)
        {
            string xpathTrimEnd = xpath.TrimEnd(new char[] { '/' });
            this.stringDictionary[xpathTrimEnd] = xpathTrimEnd;
        }

        /// <summary>
        /// Removes all xpaths from the collection
        /// </summary>
        public void Clear()
        {
            this.stringDictionary.Clear();
        }

        /// <summary>
        /// Determines whether an xpath is in the collection
        /// </summary>
        /// <param name="xpath">The xpath to locate in the collection</param>
        /// <returns>true if object is found in the collection; otherwise, false</returns>
        public bool Contains(string xpath)
        {
            // split the xpath into its fragments
            string[] xpathFragments = xpath.Split(new char[] { '/' });

            // build the xpath to traverse from root to leaf
            StringBuilder stringBuilder = new StringBuilder();

            foreach (string xpathFragment in xpathFragments)
            {
                stringBuilder.Append(xpathFragment);

                if (true == this.stringDictionary.ContainsKey(stringBuilder.ToString()))
                {
                    return true;
                }

                stringBuilder.Append("/");
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\NodeElement.cs ===
//-----------------------------------------------------------------------
// <copyright file="NodeElement.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe an xml element
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;

    /// <summary>
    /// Class to describe an xml element
    /// </summary>
    public sealed class NodeElement : Node, ICloneable
    {
        /// <summary>
        /// attributes is the collection of attributes for this element
        /// </summary>
        private List<NodeAttribute> attributes = new List<NodeAttribute>();

        /// <summary>
        /// Initializes a new instance of the NodeElement class
        /// </summary>
        internal NodeElement()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NodeElement class
        /// </summary>
        /// <param name="localName">The local name of the element</param>
        /// <param name="prefix">The namespace prefix of the element</param>
        /// <param name="namespaceURI">The namespace uri of the element</param>
        internal NodeElement(string localName, string prefix, string namespaceURI)
            : base(localName, prefix, namespaceURI)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NodeElement class
        /// </summary>
        /// <param name="localName">The local name of the element</param>
        /// <param name="prefix">The namespace prefix of the element</param>
        /// <param name="namespaceURI">The namespace uri of the element</param>
        /// <param name="value">The value of the element</param>
        internal NodeElement(string localName, string prefix, string namespaceURI, string value)
            : this(localName, prefix, namespaceURI)
        {
            this.Value = value;
        }

        /// <summary>
        /// Initializes a new instance of the NodeElement class
        /// </summary>
        /// <param name="nodeElement">The node element instance to copy to the new instance</param>
        private NodeElement(NodeElement nodeElement)
            : base(nodeElement)
        {
        }

        /// <summary>
        /// Gets the collection of attributes for this element
        /// </summary>
        public ReadOnlyCollection<NodeAttribute> Attributes
        {
            get { return new ReadOnlyCollection<NodeAttribute>(this.attributes); }
        }

        /// <summary>
        /// Creates a new object that is a copy of the current instance
        /// </summary>
        /// <returns>A new object that is a copy of the current instance</returns>
        object System.ICloneable.Clone()
        {
            // create a new element
            return new NodeElement(this);
        }

        /// <summary>
        /// Add the new attribute to the collection of attributes for this element
        /// </summary>
        /// <param name="nodeAttribute">The new attribute to add to this element</param>
        internal void AddAttribute(NodeAttribute nodeAttribute)
        {
            this.attributes.Add(nodeAttribute);
        }

        /// <summary>
        /// Gets the attribute specified by the name
        /// </summary>
        /// <param name="value">The name of the attribute to get</param>
        /// <returns>The attribute specified by the name</returns>
        internal NodeAttribute GetAttribute(string value)
        {
            foreach (NodeAttribute nodeAttribute in this.attributes)
            {
                if (nodeAttribute.Name == value)
                {
                    return nodeAttribute;
                }
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\SelectNodes.cs ===
//-----------------------------------------------------------------------
// <copyright file="SelectNodes.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   provides methods to select nodes specified by an xpath expression
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Class to select nodes specified by an xpath expression
    /// </summary>
    public static class SelectNodes
    {
        /// <summary>
        /// Select the nodes specified by the xpath expression
        /// </summary>
        /// <param name="nodeRoot">The root of all xml nodes</param>
        /// <param name="node">The current xml node</param>
        /// <param name="xpathLocation">The xpath location expression specifying the children to select</param>
        /// <returns>The list of nodes specified by the xpath expression</returns>
        internal static List<Node> Select(Node nodeRoot, Node node, string xpathLocation)
        {
            switch (xpathLocation[0])
            {
                case '/':
                    return SelectNodes.SelectAbsoluteNodes(nodeRoot, xpathLocation);

                case '@':
                    if ('*' == xpathLocation[1])
                    {
                        return SelectNodes.SelectAttributesAll(node as NodeElement);
                    }
                    else
                    {
                        return SelectNodes.SelectAttributes(node as NodeElement, xpathLocation);
                    }

                case '*':
                    return SelectNodes.SelectChildNodesAll(node);

                default:
                    return SelectNodes.SelectChildNodes(node, xpathLocation);
            }
        }

        /// <summary>
        /// Select the nodes specified by the xpath expression from the root
        /// </summary>
        /// <param name="node">The root node from which to select the children</param>
        /// <param name="xpathLocation">The xpath location expression specifying the children to select</param>
        /// <returns>The list of nodes specified by the xpath expression</returns>
        private static List<Node> SelectAbsoluteNodes(Node node, string xpathLocation)
        {
            // split the xpath into each node index
            string[] xpathLocations = xpathLocation.Split(new char[] { '/' }, StringSplitOptions.RemoveEmptyEntries);

            // enumerate each xpath node index
            for (int index = 0; index < (xpathLocations.Length - 1); index++)
            {
                // get the node index
                int nodeIndex = int.Parse(xpathLocations[index]);

                // get the node
                node = node.GetChildNode(nodeIndex - 1);
            }

            return SelectNodes.SelectChildNodes(node, xpathLocations[xpathLocations.Length - 1]);
        }

        /// <summary>
        /// Select the attributes specified by xpath expression
        /// </summary>
        /// <param name="nodeElement">The element from which to select the attributes</param>
        /// <param name="xpathLocation">The xpath location expression specifying the attributes to select</param>
        /// <returns>The list of attributes specified by the xpath expression</returns>
        private static List<Node> SelectAttributes(NodeElement nodeElement, string xpathLocation)
        {
            List<Node> childNodes = new List<Node>();

            // split the xpath into each attribute
            string[] xpathLocations = xpathLocation.Split(new char[] { '@', '|' }, StringSplitOptions.RemoveEmptyEntries);

            // enumerate each xpath attribute
            for (int index = 0; index < xpathLocations.Length; index++)
            {
                // get the node
                NodeAttribute nodeAttribute = nodeElement.GetAttribute(xpathLocations[index]);
                if (null != nodeAttribute)
                {
                    childNodes.Add(nodeAttribute);
                }
            }

            return childNodes;
        }

        /// <summary>
        /// Select all of the attributes for the element
        /// </summary>
        /// <param name="nodeElement">The element from which to select all of the attributes</param>
        /// <returns>The list of attributes for the element</returns>
        private static List<Node> SelectAttributesAll(NodeElement nodeElement)
        {
            return new List<Node>(nodeElement.Attributes as IEnumerable<Node>);
        }

        /// <summary>
        /// Select the children specified by the xpath expression for the node
        /// </summary>
        /// <param name="node">The node from which to select the children</param>
        /// <param name="xpathLocation">The xpath location expression specifying the children to select</param>
        /// <returns>The list of children for the node</returns>
        private static List<Node> SelectChildNodes(Node node, string xpathLocation)
        {
            List<Node> childNodes = new List<Node>();

            // split the xpath into each node index
            string[] xpathLocations = xpathLocation.Split(new char[] { '|' }, StringSplitOptions.RemoveEmptyEntries);

            // enumerate each xpath node index
            for (int index = 0; index < xpathLocations.Length; index++)
            {
                // split the xpath node index into start and stop
                string[] nodeIndexes = xpathLocations[index].Split(new char[] { '-' }, StringSplitOptions.RemoveEmptyEntries);

                // get the start node index
                int nodeIndexStart = int.Parse(nodeIndexes[0]);
                int nodeIndexStop = nodeIndexStart;

                if (2 == nodeIndexes.Length)
                {
                    nodeIndexStop = int.Parse(nodeIndexes[1]);
                }

                // enumerate the node indexes and get the nodes
                while (nodeIndexStart <= nodeIndexStop)
                {
                    childNodes.Add(node.GetChildNode(nodeIndexStart - 1));
                    nodeIndexStart++;
                }
            }

            return childNodes;
        }

        /// <summary>
        /// Select all of the children for the node
        /// </summary>
        /// <param name="node">The node from which to select all of the children</param>
        /// <returns>The list of children for the element</returns>
        private static List<Node> SelectChildNodesAll(Node node)
        {
            return new List<Node>(node.ChildNodes);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\Node.cs ===
//-----------------------------------------------------------------------
// <copyright file="Node.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe an xml node
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;

    /// <summary>
    /// Class to describe an xml node
    /// </summary>
    public class Node
    {
        /// <summary>
        /// arrayChildNodes is the array of child nodes of this node
        /// </summary>
        private Node[] arrayChildNodes;

        /// <summary>
        ///  difference is the difference to this node
        /// </summary>
        private Difference difference;

        /// <summary>
        /// listChildNodes is the list of child nodes of this node
        /// </summary>
        private List<Node> listChildNodes = new List<Node>();

        /// <summary>
        /// localName is the local name of the attribute
        /// </summary>
        private string localName;

        /// <summary>
        /// name is the qualified name of the attribute
        /// </summary>
        private string name;

        /// <summary>
        /// namespaceURI is the namespace uri of the attribute
        /// </summary>
        private string namespaceURI;

        /// <summary>
        /// node is the difference between source and destination
        /// </summary>
        private Node nodeChanged;

        /// <summary>
        /// prefix is the namespace prefix of the attribute
        /// </summary>
        private string prefix;

        /// <summary>
        /// value is the value of the attribute
        /// </summary>
        private string value;

        /// <summary>
        /// xpath is the xpath expression to select the node
        /// </summary>
        private string xpath;

        /// <summary>
        /// xpathLocation is the xpath expression to select the node by location
        /// </summary>
        private string xpathLocation;

        /// <summary>
        /// Initializes a new instance of the Node class
        /// </summary>
        internal Node()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Node class
        /// </summary>
        /// <param name="localName">The local name of the node</param>
        /// <param name="prefix">The namespace prefix of the node</param>
        /// <param name="namespaceURI">The namespace uri of the node</param>
        internal Node(string localName, string prefix, string namespaceURI)
        {
            this.localName = localName;
            this.prefix = prefix;
            this.namespaceURI = namespaceURI;

            if (true == String.IsNullOrEmpty(prefix))
            {
                this.name = localName;
            }
            else
            {
                this.name = prefix + ":" + localName;
            }
        }

        /// <summary>
        /// Initializes a new instance of the Node class
        /// </summary>
        /// <param name="node">The node instance to copy to the new instance</param>
        internal Node(Node node)
            : this(node.localName, node.prefix, node.namespaceURI)
        {
            this.value = node.value;
            this.xpath = node.xpath;
            this.xpathLocation = node.xpathLocation;
        }

        /// <summary>
        /// Gets the local name of the node
        /// </summary>
        public string LocalName
        {
            get { return this.localName; }
        }

        /// <summary>
        /// Gets the name of the attribute
        /// </summary>
        public string Name
        {
            get { return this.name; }
        }

        /// <summary>
        /// Gets the namespace uri of the node
        /// </summary>
        public string NamespaceURI
        {
            get { return this.namespaceURI; }
        }

        /// <summary>
        /// Gets the namespace prefix of the node
        /// </summary>
        public string Prefix
        {
            get { return this.prefix; }
        }

        /// <summary>
        /// Gets the value of the node
        /// </summary>
        public string Value
        {
            get { return this.value; }
            internal set { this.value = value; }
        }

        /// <summary>
        /// Gets the xpath of the node
        /// </summary>
        public string XPath
        {
            get { return this.xpath; }
            internal set { this.xpath = value; }
        }

        /// <summary>
        /// Gets the xpath location of the node
        /// </summary>
        public string XPathLocation
        {
            get { return this.xpathLocation; }
            internal set { this.xpathLocation = value; }
        }

        /// <summary>
        /// Gets the collection of child nodes of this node
        /// </summary>
        internal ReadOnlyCollection<Node> ChildNodes
        {
            get { return new ReadOnlyCollection<Node>(this.listChildNodes); }
        }

        /// <summary>
        /// Gets or sets the difference between source and destination
        /// </summary>
        internal Difference Difference
        {
            get { return this.difference; }
            set { this.difference = value; }
        }

        /// <summary>
        /// Gets or sets the difference between source and destination
        /// </summary>
        internal Node NodeChanged
        {
            get { return this.nodeChanged; }
            set { this.nodeChanged = value; }
        }

        /// <summary>
        /// Add the new child to the collection of children for this element
        /// </summary>
        /// <param name="node">The new child to add to this element</param>
        internal void AppendChild(Node node)
        {
            this.listChildNodes.Add(node);
        }

        /// <summary>
        /// Gets the child at the specified index
        /// </summary>
        /// <param name="index">The index of the child to get</param>
        /// <returns>The child at the specified index</returns>
        internal Node GetChildNode(int index)
        {
            this.BuildChildNodeArray();

            if (0 == this.listChildNodes.Count)
            {
                return this;
            }

            return this.arrayChildNodes[index];
        }

        /// <summary>
        /// Insert the new child to the collection of children after the specified reference node
        /// </summary>
        /// <param name="node">The new child to add to this element</param>
        /// <param name="refNode">The reference node after which the new child is added</param>
        internal void InsertAfter(Node node, Node refNode)
        {
            this.BuildChildNodeArray();

            int index = this.listChildNodes.IndexOf(refNode);
            this.listChildNodes.Insert(index + 1, node);
        }

        /// <summary>
        /// Builds the array of child nodes using the source nodes only
        /// </summary>
        private void BuildChildNodeArray()
        {
            if (null == this.arrayChildNodes)
            {
                this.arrayChildNodes = new Node[this.listChildNodes.Count];

                int arrayIndex = 0;
                foreach (Node node in this.listChildNodes)
                {
                    this.arrayChildNodes[arrayIndex++] = node;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlMerge\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\XmlDiffDetail.cs ===
//-----------------------------------------------------------------------
// <copyright file="XmlDiffDetail.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to describe the differences of an xml node
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    /// <summary>
    /// Class to describe the differences of an xml node
    /// </summary>
    public sealed class XmlDiffDetail
    {
        /// <summary>
        /// difference specifies the xml difference
        /// </summary>
        private Difference difference;

        /// <summary>
        /// nodeDestination is the xml node of the destination
        /// </summary>
        private Node nodeDestination;

        /// <summary>
        /// nodeSource is the xml node of the source
        /// </summary>
        private Node nodeSource;

        /// <summary>
        /// Initializes a new instance of the XmlDiffDetail class
        /// </summary>
        /// <param name="difference">The xml difference (add, remove, change, etc.)</param>
        public XmlDiffDetail(Difference difference)
        {
            this.difference = difference;
        }

        /// <summary>
        /// Gets the xml node of the destination
        /// </summary>
        public Node Destination
        {
            get { return this.nodeDestination; }
            internal set { this.nodeDestination = value; }
        }

        /// <summary>
        /// Gets the difference between the source and destination xml nodes
        /// </summary>
        public Difference Difference
        {
            get { return this.difference; }
        }

        /// <summary>
        /// Gets the xml node of the source
        /// </summary>
        public Node Source
        {
            get { return this.nodeSource; }
            internal set { this.nodeSource = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\StringWriterUTF8.cs ===
//-----------------------------------------------------------------------
// <copyright file="StringWriterUTF8.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   implements a TextWriter for writing information to a UTF8 encoded string
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    using System.IO;
    using System.Text;

    /// <summary>
    /// Implements a TextWriter for writing information to a UTF8 encoded string
    /// </summary>
    internal sealed class StringWriterUTF8 : StringWriter
    {
        /// <summary>
        /// Initializes a new instance of the StringWriterUTF8 class that writes to the specified StringBuilder
        /// </summary>
        /// <param name="stringBuilder">The StringBuilder to write to</param>
        public StringWriterUTF8(StringBuilder stringBuilder)
            : base(stringBuilder)
        {
        }

        /// <summary>
        /// Gets the Encoding in which the output is written (UTF8)
        /// </summary>
        public override Encoding Encoding
        {
            get { return Encoding.UTF8; }
        }

        /// <summary>
        /// Releases all the unmanaged resources used by the StringWriterUTF8 and optionally releases the managed resources
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources</param>
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlMerge\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\StackHelper.cs ===
//-----------------------------------------------------------------------
// <copyright file="StackHelper.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   resolve stack to a friendly string
// </summary>
//-----------------------------------------------------------------------

namespace Microsoft.XmlDiffPatch
{
    using System.Collections.Generic;
    using System.Text;

    /// <summary>
    /// Implements a Stack for returning string representations of the stack
    /// </summary>
    internal sealed class StackHelper : Stack<string>
    {
        /// <summary>
        /// Returns a string representation of the stack
        /// </summary>
        /// <returns>The string representation of the stack</returns>
        public override string ToString()
        {
            string[] stackElements = this.ToArray();
            StringBuilder stringBuilder = new StringBuilder();

            for (int index = stackElements.Length - 1; (index >= 0) && (index >= stackElements.Length - 1); index--)
            {
                stringBuilder.Append(stackElements[index]);
            }

            for (int index = stackElements.Length - 2; index >= 0; index--)
            {
                stringBuilder.Append("/");
                stringBuilder.Append(stackElements[index]);
            }

            return stringBuilder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\XmlDiffReport.cs ===
//-----------------------------------------------------------------------
// <copyright file="XmlDiffReport.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   common library for detailing xml document differences
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace Microsoft.XmlDiffPatch
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;

    /// <summary>
    /// Class to find and describe the differences of an xml document
    /// </summary>
    public sealed class XmlDiffReport
    {
        /// <summary>
        /// collectionDifferences is the collection of differences specified by opid
        /// </summary>
        private Dictionary<string, Difference> collectionDifferences = new Dictionary<string, Difference>();

        /// <summary>
        /// collectionIgnoreXPaths is the collection of xpaths that should be ignored
        /// </summary>
        private IgnoreXPathCollection collectionIgnoreXPaths = new IgnoreXPathCollection();

        /// <summary>
        /// collectionXmlDiffDetails is the collection of xml diff details
        /// </summary>
        private XmlDiffDetailCollection collectionXmlDiffDetails = new XmlDiffDetailCollection();

        /// <summary>
        /// nodeDocument is the document at the root of all xml nodes
        /// </summary>
        private Node nodeDocument;

        /// <summary>
        /// xmlDiff is the XmlDiff class from the XmlDiffPatch assembly used to compare two xml documents
        /// </summary>
        private XmlDiff xmlDiff = new XmlDiff();

        /// <summary>
        /// xmlNamespaceManagerDiffGram is the XmlNamespaceManager object providing scope management for the diffgram document
        /// </summary>
        private XmlNamespaceManager xmlNamespaceManagerDiffGram;

        /// <summary>
        /// xpathNavigator is the diff gram xml document
        /// </summary>
        private XPathNavigator xpathNavigatorDiffGram;

        /// <summary>
        /// Initializes a new instance of the XmlDiffReport class
        /// </summary>
        public XmlDiffReport()
        {
            this.xmlDiff.IgnoreComments = true;
            this.xmlDiff.IgnoreDtd = true;
            this.xmlDiff.IgnorePI = true;
            this.xmlDiff.IgnoreWhitespace = true;
            this.xmlDiff.IgnoreXmlDecl = true;
        }

        /// <summary>
        /// Gets or sets the algorithm for comparing the xml documents
        /// </summary>
        public XmlDiffAlgorithm Algorithm
        {
            get { return this.xmlDiff.Algorithm; }
            set { this.xmlDiff.Algorithm = value; }
        }

        /// <summary>
        /// Gets the collection of xml diff details
        /// </summary>
        public XmlDiffDetailCollection Details
        {
            get { return this.collectionXmlDiffDetails; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to ignore the child order (default = false)
        /// </summary>
        public bool IgnoreChildOrder
        {
            get { return this.xmlDiff.IgnoreChildOrder; }
            set { this.xmlDiff.IgnoreChildOrder = value; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to ignore namespaces (default = false)
        /// </summary>
        public bool IgnoreNamespaces
        {
            get { return this.xmlDiff.IgnoreNamespaces; }
            set { this.xmlDiff.IgnoreNamespaces = value; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to ignore prefixes (default = false)
        /// </summary>
        public bool IgnorePrefixes
        {
            get { return this.xmlDiff.IgnorePrefixes; }
            set { this.xmlDiff.IgnorePrefixes = value; }
        }

        /// <summary>
        /// Compare the source file and the destination file
        /// </summary>
        /// <param name="fileSource">The source file name</param>
        /// <param name="fileDestination">The destination file name</param>
        public void Compare(string fileSource, string fileDestination)
        {
            // load the source file
            XmlDocument xmlDocumentSource = new XmlDocument();
            xmlDocumentSource.Load(fileSource);

            // load the destination file
            XmlDocument xmlDocumentDestination = new XmlDocument();
            xmlDocumentDestination.Load(fileDestination);

            // compare
            this.Compare(xmlDocumentSource, xmlDocumentDestination);
        }

        /// <summary>
        /// Compare the source xml node and the destination xml node
        /// </summary>
        /// <param name="xmlNodeSource">The source xml node</param>
        /// <param name="xmlNodeDestination">The destination xml node</param>
        public void Compare(XmlNode xmlNodeSource, XmlNode xmlNodeDestination)
        {
            this.collectionDifferences.Clear();
            this.collectionXmlDiffDetails.Clear();
            this.nodeDocument = null;
            this.xmlNamespaceManagerDiffGram = null;

            // compare
            this.CompareNodes(xmlNodeSource, xmlNodeDestination);

            // process the descriptor elements in the diffgram
            this.ProcessDescriptors();

            // load the xml nodes
            this.LoadXmlNodes(xmlNodeSource);

            // apply the diffgram
            this.ApplyDiffGram(this.xpathNavigatorDiffGram.SelectSingleNode("*"), this.nodeDocument);

            // build the xml diff details
            StackHelper stackHelperXPath = new StackHelper();
            stackHelperXPath.Push("./");

            StackHelper stackHelperXPathLocation = new StackHelper();
            stackHelperXPathLocation.Push("./");

            int location = 0;
            this.BuildXmlDiffDetails(stackHelperXPath, stackHelperXPathLocation, this.nodeDocument.ChildNodes, ref location);
        }

        /// <summary>
        /// Adds the specified xpath to the collection of xpaths that should be ignored when comparing
        /// </summary>
        /// <param name="xpath">The specified xpath</param>
        public void IgnoreXPath(string xpath)
        {
            this.collectionIgnoreXPaths.Add(xpath);
        }

        /// <summary>
        /// Apply the xml diffgram to the current xml node
        /// </summary>
        /// <param name="xpathNavigator">The xml node from the diffgram</param>
        /// <param name="nodeSource">The xml node from the source</param>
        private void ApplyDiffGram(XPathNavigator xpathNavigator, Node nodeSource)
        {
            Node refNode = null;

            XPathNodeIterator xpathNodeIterator = xpathNavigator.SelectChildren(XPathNodeType.Element);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the xpath for the node match
                string xpath = xpathNodeIterator.Current.GetAttribute("match", String.Empty);

                // get the list of nodes for the match
                List<Node> listNodes = null;
                if (String.Empty != xpath)
                {
                    listNodes = SelectNodes.Select(this.nodeDocument, nodeSource, xpath);
                }

                switch (xpathNodeIterator.Current.LocalName)
                {
                    case "add":
                        if (null != listNodes)
                        {
                            this.OnAddMatch(xpathNodeIterator.Current, nodeSource, listNodes, ref refNode);
                        }
                        else
                        {
                            string typeAttribute = xpathNodeIterator.Current.GetAttribute("type", String.Empty);
                            if (String.Empty != typeAttribute)
                            {
                                this.OnAddNode(xpathNodeIterator.Current, typeAttribute, nodeSource, ref refNode);
                            }
                            else
                            {
                                this.OnAddFragment(xpathNodeIterator.Current, nodeSource, ref refNode);
                            }
                        }

                        break;

                    case "change":
                        this.OnChange(xpathNodeIterator.Current, listNodes[0], ref refNode);

                        break;

                    case "node":
                        this.ApplyDiffGram(xpathNodeIterator.Current, listNodes[0]);
                        refNode = listNodes[0];

                        break;

                    case "remove":
                        this.OnRemove(xpathNodeIterator.Current, nodeSource, listNodes);

                        break;
                }
            }
        }

        /// <summary>
        /// Builds the xml diff detail for the specified node
        /// </summary>
        /// <param name="stackHelperXPath">The stack helper instance to resolve the xpath of the node</param>
        /// <param name="stackHelperXPathLocation">The stack helper instance to resolve the xpath location of the node</param>
        /// <param name="node">The specified node to check for differences</param>
        /// <param name="location">The location of the node amongst its siblings</param>
        private void BuildXmlDiffDetail(StackHelper stackHelperXPath, StackHelper stackHelperXPathLocation, Node node, ref int location)
        {
            // locationIncrement is the value to increment the location by (0 for attributes, since they do not have a location; 1 for elements, since they do)
            int locationIncrement = 1;

            if (true == (node is NodeAttribute))
            {
                locationIncrement = 0;
            }

            if ((Difference.None == node.Difference) || (null != node.NodeChanged))
            {
                // this node exists in the destination, so increment the location (number of nodes)
                location += locationIncrement;
            }

            if ((Difference.None != node.Difference) && ((Difference.Move != node.Difference) || (null != node.NodeChanged)))
            {
                // this node was added, changed, moved to the destination or removed from the source
                // build the xml diff detail
                XmlDiffDetail xmlDiffDetail = new XmlDiffDetail(node.Difference);

                xmlDiffDetail.Source = node;
                xmlDiffDetail.Destination = node.NodeChanged;

                // xpath is the xpath of this node used to check if the difference should be ignored
                string xpath = node.XPath;

                // set the destination xpath
                if (null != node.NodeChanged)
                {
                    if (true == (node is NodeAttribute))
                    {
                        xmlDiffDetail.Destination.XPath = stackHelperXPath.ToString() + "[@" + xmlDiffDetail.Destination.LocalName + "]";
                        xmlDiffDetail.Destination.XPathLocation = stackHelperXPathLocation.ToString() + "[@" + xmlDiffDetail.Destination.LocalName + "]";
                    }
                    else
                    {
                        xmlDiffDetail.Destination.XPath = stackHelperXPath.ToString() + "/" + xmlDiffDetail.Destination.LocalName;
                        xmlDiffDetail.Destination.XPathLocation = stackHelperXPathLocation.ToString() + "/" + location.ToString();
                    }
                }

                if (null == xpath)
                {
                    // source xpath is not set so set the xpath to the destination xpath
                    xpath = xmlDiffDetail.Destination.XPath;
                }
                else if ((null != xmlDiffDetail.Destination) && (xpath != xmlDiffDetail.Destination.XPath))
                {
                    // source xpath != destination xpath so the node cannot be ignored
                    xpath = null;
                }

                // check if the node is ignored by xpath
                if ((null == xpath) || (false == this.collectionIgnoreXPaths.Contains(xpath)))
                {
                    // add the xml diff detail to the collection
                    this.collectionXmlDiffDetails.Add(xmlDiffDetail);
                }
            }
        }

        /// <summary>
        /// Builds the xml diff detail collection by iterating all nodes for differences
        /// </summary>
        /// <param name="stackHelperXPath">The stack helper instance to resolve the xpath of the node</param>
        /// <param name="stackHelperXPathLocation">The stack helper instance to resolve the xpath location of the node</param>
        /// <param name="collectionNodes">The collection of nodes to iterate</param>
        /// <param name="location">The location of the node amongst its siblings</param>
        private void BuildXmlDiffDetails(StackHelper stackHelperXPath, StackHelper stackHelperXPathLocation, ReadOnlyCollection<Node> collectionNodes, ref int location)
        {
            // iterate the nodes
            foreach (Node node in collectionNodes)
            {
                // build the xml diff detail for this node
                this.BuildXmlDiffDetail(stackHelperXPath, stackHelperXPathLocation, node, ref location);

                stackHelperXPath.Push(node.LocalName);
                stackHelperXPathLocation.Push(location.ToString());

                // iterate the attributes
                if (true == (node is NodeElement))
                {
                    foreach (NodeAttribute nodeAttribute in (node as NodeElement).Attributes)
                    {
                        this.BuildXmlDiffDetail(stackHelperXPath, stackHelperXPathLocation, nodeAttribute, ref location);
                    }
                }

                // iterate the child nodes
                int locationChild = 0;
                this.BuildXmlDiffDetails(stackHelperXPath, stackHelperXPathLocation, node.ChildNodes, ref locationChild);

                stackHelperXPath.Pop();
                stackHelperXPathLocation.Pop();
            }
        }

        /// <summary>
        /// Compares two xml documents and writes the diffgram to this.xpathNavigatorDiffGram
        /// </summary>
        /// <param name="xmlNodeSource">The source xml node</param>
        /// <param name="xmlNodeDestination">The destination xml node</param>
        private void CompareNodes(XmlNode xmlNodeSource, XmlNode xmlNodeDestination)
        {
            // compare
            StringBuilder stringBuilder = new StringBuilder();
            using (StringWriterUTF8 stringWriterUTF8 = new StringWriterUTF8(stringBuilder))
            {
                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                xmlWriterSettings.Indent = true;

                using (XmlWriter xmlWriter = XmlWriter.Create(stringWriterUTF8))
                {
                    this.xmlDiff.Compare(xmlNodeSource, xmlNodeDestination, xmlWriter);
                }
            }

            // load the diff gram
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(stringBuilder.ToString());
            this.xpathNavigatorDiffGram = xmlDocument.CreateNavigator();

            // create the xml namespace manager
            this.xmlNamespaceManagerDiffGram = new XmlNamespaceManager(this.xpathNavigatorDiffGram.NameTable);
            this.xmlNamespaceManagerDiffGram.AddNamespace("xd", "http://schemas.microsoft.com/xmltools/2002/xmldiff");
        }

        /// <summary>
        /// Load the xml nodes
        /// </summary>
        /// <param name="xmlNode">The root xml node</param>
        private void LoadXmlNodes(XmlNode xmlNode)
        {
            StackHelper stackHelperXPath = new StackHelper();
            stackHelperXPath.Push("./");

            StackHelper stackHelperXPathLocation = new StackHelper();
            stackHelperXPathLocation.Push("./");

            // create the document xml node
            this.nodeDocument = new Node();

            using (StringReader stringReader = new StringReader(xmlNode.OuterXml))
            {
                using (XmlTextReader xmlTextReader = new XmlTextReader(stringReader))
                {
                    // load the xml nodes
                    this.LoadXmlNodes(stackHelperXPath, stackHelperXPathLocation, this.nodeDocument, xmlTextReader);
                }
            }
        }

        /// <summary>
        /// Load the child xml nodes into the parent xml node
        /// </summary>
        /// <param name="stackHelperXPath">The stack helper instance to resolve the xpath of the node</param>
        /// <param name="stackHelperXPathLocation">The stack helper instance to resolve the xpath location of the node</param>
        /// <param name="nodeParent">The parent node of this node</param>
        /// <param name="xmlTextReader">The xml text reader object to read the xml nodes</param>
        private void LoadXmlNodes(StackHelper stackHelperXPath, StackHelper stackHelperXPathLocation, Node nodeParent, XmlTextReader xmlTextReader)
        {
            // load the attributes
            while (true == xmlTextReader.MoveToNextAttribute())
            {
                NodeAttribute nodeAttribute = new NodeAttribute(xmlTextReader.LocalName, xmlTextReader.Prefix, xmlTextReader.NamespaceURI, xmlTextReader.Value);
                nodeAttribute.XPath = stackHelperXPath.ToString() + "[@" + nodeAttribute.LocalName + "]";
                nodeAttribute.XPathLocation = stackHelperXPathLocation.ToString() + "[@" + nodeAttribute.LocalName + "]";

                (nodeParent as NodeElement).AddAttribute(nodeAttribute);
            }

            if (true == xmlTextReader.IsEmptyElement)
            {
                return;
            }

            // iterate each node
            int location = 0;
            while (true == xmlTextReader.Read())
            {
                stackHelperXPath.Push(xmlTextReader.LocalName);
                stackHelperXPathLocation.Push((++location).ToString());

                switch (xmlTextReader.NodeType)
                {
                    case XmlNodeType.CDATA:
                    case XmlNodeType.Text:
                        // set the element value
                        (nodeParent as NodeElement).Value = xmlTextReader.Value;

                        break;

                    case XmlNodeType.Element:
                        // create the element node
                        NodeElement nodeElement = new NodeElement(xmlTextReader.LocalName, xmlTextReader.Prefix, xmlTextReader.NamespaceURI);
                        nodeElement.XPath = stackHelperXPath.ToString();
                        nodeElement.XPathLocation = stackHelperXPathLocation.ToString();

                        // load the child nodes
                        this.LoadXmlNodes(stackHelperXPath, stackHelperXPathLocation, nodeElement, xmlTextReader);

                        // add the new element node to the parent
                        nodeParent.AppendChild(nodeElement);
                        
                        break;

                    case XmlNodeType.EndElement:
                        stackHelperXPath.Pop();
                        stackHelperXPathLocation.Pop();

                        return;

                    default:
                        // add placeholder child so indexes are correct
                        nodeParent.AppendChild(new Node());
                        break;
                }

                stackHelperXPath.Pop();
                stackHelperXPathLocation.Pop();
            }
        }
        
        /// <summary>
        /// Create a difference specifying the xml nodes were added
        /// </summary>
        /// <param name="xpathNavigator">The xml node from the diffgram</param>
        /// <param name="node">The xml node to which the xml nodes are added</param>
        /// <param name="refNode">The reference node after which these xml nodes are added</param>
        private void OnAddFragment(XPathNavigator xpathNavigator, Node node, ref Node refNode)
        {
            XPathNodeIterator xpathNodeIterator = xpathNavigator.SelectChildren(XPathNodeType.All);
            while (true == xpathNodeIterator.MoveNext())
            {
                switch ((xpathNodeIterator.Current as IHasXmlNode).GetNode().NodeType)
                {
                    case XmlNodeType.CDATA:
                    case XmlNodeType.Text:
                        // get the element
                        NodeElement nodeElement = node as NodeElement;

                        if (Difference.None == nodeElement.Difference)
                        {
                            // set the difference
                            nodeElement.Difference = Difference.Change;

                            // clone the node as the difference
                            nodeElement.NodeChanged = (nodeElement as ICloneable).Clone() as NodeElement;
                        }

                        // set the difference value
                        nodeElement.NodeChanged.Value = xpathNodeIterator.Current.Value;

                        break;

                    case XmlNodeType.Element:
                        // create the new element
                        NodeElement nodeElementAdded = new NodeElement();
                        nodeElementAdded.Difference = Difference.Add;
                        nodeElementAdded.NodeChanged = new NodeElement(xpathNodeIterator.Current.LocalName, xpathNodeIterator.Current.Prefix, xpathNodeIterator.Current.NamespaceURI);

                        // get the attributes
                        if (true == xpathNodeIterator.Current.MoveToFirstAttribute())
                        {
                            do
                            {
                                NodeAttribute nodeAttributeAdded = new NodeAttribute();
                                nodeAttributeAdded.Difference = Difference.Add;
                                nodeAttributeAdded.NodeChanged = new NodeAttribute(xpathNodeIterator.Current.LocalName, xpathNodeIterator.Current.Prefix, xpathNodeIterator.Current.NamespaceURI, xpathNodeIterator.Current.Value);

                                nodeElementAdded.AddAttribute(nodeAttributeAdded);
                            } while (true == xpathNodeIterator.Current.MoveToNextAttribute());

                            xpathNodeIterator.Current.MoveToParent();
                        }

                        // add the new element node to the parent
                        node.InsertAfter(nodeElementAdded, refNode);
                        refNode = nodeElementAdded;

                        // add the element children
                        Node refNodeChild = null;
                        this.OnAddFragment(xpathNodeIterator.Current, nodeElementAdded, ref refNodeChild);

                        break;
                }
            }
        }

        /// <summary>
        /// Create a difference specifying the xml nodes were added from a matched set of xml nodes in the document
        /// </summary>
        /// <param name="xpathNavigator">The xml node from the diffgram</param>
        /// <param name="node">The xml node to which the xml nodes are added</param>
        /// <param name="listNodes">The list of added xml nodes</param>
        /// <param name="refNode">The reference node after which these xml nodes are added</param>
        private void OnAddMatch(XPathNavigator xpathNavigator, Node node, List<Node> listNodes, ref Node refNode)
        {
            // check if it is the entire subtree or just a subset
            string subtree = xpathNavigator.GetAttribute("subtree", String.Empty);
            if ("no" == subtree)
            {
                this.ApplyDiffGram(xpathNavigator, listNodes[0]);
                return;
            }

            // iterate the added nodes
            foreach (Node nodeMove in listNodes)
            {
                NodeElement nodeElementMove = ((nodeMove as NodeElement) as ICloneable).Clone() as NodeElement;
                nodeElementMove.Difference = Difference.Move;
                nodeElementMove.NodeChanged = ((nodeMove as NodeElement) as ICloneable).Clone() as NodeElement;

                // add the new element node to the parent
                node.InsertAfter(nodeElementMove, refNode);
                refNode = nodeElementMove;
            }
        }

        /// <summary>
        /// Create a difference specifying the xml node was added
        /// </summary>
        /// <param name="xpathNavigator">The xml node from the diffgram</param>
        /// <param name="typeAttribute">Specifies the type of xml node added</param>
        /// <param name="node">The xml node to which the xml node is added</param>
        /// <param name="refNode">The reference node after which this xml node is added</param>
        private void OnAddNode(XPathNavigator xpathNavigator, string typeAttribute, Node node, ref Node refNode)
        {
            // get the new node type
            XmlNodeType xmlNodeType = (XmlNodeType)int.Parse(typeAttribute);

            // get the new node
            string localName = xpathNavigator.GetAttribute("name", String.Empty);
            string prefix = xpathNavigator.GetAttribute("prefix", String.Empty);
            string namespaceURI = xpathNavigator.GetAttribute("ns", String.Empty);

            switch (xmlNodeType)
            {
                case XmlNodeType.Attribute:
                    // create the new attribute
                    NodeAttribute nodeAttributeAdded = new NodeAttribute();
                    nodeAttributeAdded.Difference = Difference.Add;
                    nodeAttributeAdded.NodeChanged = new NodeAttribute(localName, prefix, namespaceURI, xpathNavigator.Value);

                    (node as NodeElement).AddAttribute(nodeAttributeAdded);

                    break;

                case XmlNodeType.CDATA:
                case XmlNodeType.Text:
                    // get the element
                    NodeElement nodeElement = node as NodeElement;

                    // set the difference
                    nodeElement.Difference = Difference.Change;

                    // clone the node as the difference
                    nodeElement.NodeChanged = (nodeElement as ICloneable).Clone() as NodeElement;

                    // set the difference value
                    nodeElement.NodeChanged.Value = xpathNavigator.Value;

                    break;

                case XmlNodeType.Element:
                    // create the new element
                    NodeElement nodeElementAdded = new NodeElement();
                    nodeElementAdded.Difference = Difference.Add;
                    nodeElementAdded.NodeChanged = new NodeElement(localName, prefix, namespaceURI); ;

                    // add the new element node to the parent
                    node.InsertAfter(nodeElementAdded, refNode);
                    refNode = nodeElementAdded;

                    // apply the diffgram
                    this.ApplyDiffGram(xpathNavigator, nodeElementAdded);

                    break;
            }
        }

        /// <summary>
        /// Create a difference specifying the xml node has changed
        /// </summary>
        /// <param name="xpathNavigator">The xml node from the diffgram</param>
        /// <param name="node">The xml node that is changed</param>
        /// <param name="refNode">The reference node after which this xml node is changed</param>
        private void OnChange(XPathNavigator xpathNavigator, Node node, ref Node refNode)
        {
            if (false == (node is NodeAttribute))
            {
                refNode = node;
            }

            // get the difference
            Difference difference = Difference.Change;
            string opid = xpathNavigator.GetAttribute("opid", String.Empty);
            if (String.Empty != opid)
            {
                // get the difference from the opid
                difference = this.collectionDifferences[opid];
            }

            // iterate the attributes to get the destination detail
            string localName = null;
            string prefix = null;
            string namespaceURI = null;

            if (true == xpathNavigator.MoveToFirstAttribute())
            {
                do
                {
                    switch (xpathNavigator.Name)
                    {
                        case "name":
                            localName = xpathNavigator.Value;
                            break;

                        case "ns":
                            namespaceURI = xpathNavigator.Value;
                            break;

                        case "prefix":
                            prefix = xpathNavigator.Value;
                            break;
                    }
                } while (true == xpathNavigator.MoveToNextAttribute());
            }

            // return to the element
            xpathNavigator.MoveToParent();

            if ((true == (node is NodeAttribute)) || (true == (node is NodeElement)))
            {
                // get the values for the new node
                if (null == localName)
                {
                    localName = node.LocalName;
                }

                if (null == prefix)
                {
                    prefix = node.Prefix;
                }

                if (null == namespaceURI)
                {
                    namespaceURI = node.NamespaceURI;
                }

                string value = node.Value;
                if ((0 == node.ChildNodes.Count) && (true == xpathNavigator.HasChildren))
                {
                    value = xpathNavigator.Value;
                }

                if (true == (node is NodeAttribute))
                {
                    NodeAttribute nodeAttribute = node as NodeAttribute;
                    nodeAttribute.Difference = difference;
                    nodeAttribute.NodeChanged = new NodeAttribute(localName, prefix, namespaceURI, value);
                }
                else
                {
                    NodeElement nodeElement = (node as NodeElement);
                    nodeElement.Difference = difference;
                    nodeElement.NodeChanged = new NodeElement(localName, prefix, namespaceURI, value);
                }
            }
        }

        /// <summary>
        /// Create a difference specifying the xml node was removed
        /// </summary>
        /// <param name="xpathNavigator">The xml node from the diffgram</param>
        /// <param name="node">The xml node from which the xml nodes are removed</param>
        /// <param name="listNodes">The list of removed xml nodes</param>
        private void OnRemove(XPathNavigator xpathNavigator, Node node, List<Node> listNodes)
        {
            // check if it is the entire subtree or just a subset
            string subtree = xpathNavigator.GetAttribute("subtree", String.Empty);
            if ("no" == subtree)
            {
                this.ApplyDiffGram(xpathNavigator, listNodes[0]);
                return;
            }

            // get the difference
            Difference difference = Difference.Remove;
            string opid = xpathNavigator.GetAttribute("opid", String.Empty);
            if (String.Empty != opid)
            {
                // get the difference from the opid
                difference = this.collectionDifferences[opid];
            }

            // iterate the removed nodes
            foreach (Node nodeRemoved in listNodes)
            {
                nodeRemoved.Difference = difference;
            }
        }

        /// <summary>
        /// Process the descriptor elements in the diffgram
        /// </summary>
        private void ProcessDescriptors()
        {
            // iterate each descriptor element
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorDiffGram.Select(".//xd:xmldiff/xd:descriptor", this.xmlNamespaceManagerDiffGram);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the opid attribute
                string opid = xpathNodeIterator.Current.GetAttribute("opid", String.Empty);

                // get the type attribute
                switch (xpathNodeIterator.Current.GetAttribute("type", String.Empty))
                {
                    case "move":
                        this.collectionDifferences[opid] = Difference.Move;
                        break;

                    case "namespace change":
                        this.collectionDifferences[opid] = Difference.ChangeNamespace;
                        break;

                    case "prefix change":
                        this.collectionDifferences[opid] = Difference.ChangePrefix;
                        break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\XmlDiffDetailCollection.cs ===
//-----------------------------------------------------------------------
// <copyright file="XmlDiffDetailCollection.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   collection of xml diff details
// </summary>
//-----------------------------------------------------------------------
namespace Microsoft.XmlDiffPatch
{
    using System.Collections.Generic;

    /// <summary>
    /// Class to represent a collection of xml diff details
    /// </summary>
    public sealed class XmlDiffDetailCollection : IEnumerable<XmlDiffDetail>
    {
        /// <summary>
        /// The underlying collection of the XmlDiffDetailCollection class
        /// </summary>
        private List<XmlDiffDetail> listXmlDiffDetails = new List<XmlDiffDetail>();

        /// <summary>
        /// Initializes a new instance of the XmlDiffDetailCollection class that is empty
        /// </summary>
        public XmlDiffDetailCollection()
        {
        }

        /// <summary>
        /// Gets the number of xml diff details in the collection
        /// </summary>
        public int Count
        {
            get
            {
                return this.listXmlDiffDetails.Count;
            }
        }

        /// <summary>
        /// Adds the specified xml diff detail to the collection
        /// </summary>
        /// <param name="xmlDiffDetail">The xml diff detail to add to the collection</param>
        public void Add(XmlDiffDetail xmlDiffDetail)
        {
            this.listXmlDiffDetails.Add(xmlDiffDetail);
        }

        /// <summary>
        /// Removes all xml diff details from the collection
        /// </summary>
        public void Clear()
        {
            this.listXmlDiffDetails.Clear();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        IEnumerator<XmlDiffDetail> IEnumerable<XmlDiffDetail>.GetEnumerator()
        {
            return this.listXmlDiffDetails.GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator that iterates through the collection
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.listXmlDiffDetails.GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlMerge\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmlmerge_none_12.4.56.0_none_fd6d584cba528cf0
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmlmerge
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.manifest
XP_MANIFEST_PATH=manifests\msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.cat
XP_CATALOG_PATH=manifests\msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.cat
XP_PAYLOAD_PATH=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmlmerge,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlMerge\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlPrep\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlMerge\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmlmerge_none_12.4.56.0_none_fd6d584cba528cf0
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmlmerge
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.manifest
XP_MANIFEST_PATH=manifests\msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.cat
XP_CATALOG_PATH=manifests\msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4.cat
XP_PAYLOAD_PATH=msil_xmlmerge_no-public-key_12.4.56.0_x-ww_8009dac4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmlmerge,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlPrep\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlDiffReport\Properties\AssemblyInfo.cs ===
//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("XmlDiffReport")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("XmlDiffReport")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d3f61f26-0cb6-497c-b827-69a8c65ad080")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlPrep\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlPrep\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmlprep_none_12.4.56.0_none_0cd3596c97bff645
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmlprep
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.manifest
XP_MANIFEST_PATH=manifests\msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.cat
XP_CATALOG_PATH=manifests\msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.cat
XP_PAYLOAD_PATH=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmlprep,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmltosg\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlMerge\XmlMerge.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace XmlMerge
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 4)
            {
                Help();
                return;
            }

            XmlTextWriter writer = new XmlTextWriter(args[0], null);

            // Write out the information needed to make valid XML and apply the stylesheet
            writer.WriteStartDocument();
            String xslTranform = "type=\"text/xsl\" href=\"" + args[1] + "\"";
            writer.WriteProcessingInstruction("xml-stylesheet", xslTranform);

            // Everything will be put under the root element specified as arg[1] 
            writer.WriteStartElement(args[2]);

            XmlTextReader reader = null;
            for (int i = 3; i < args.Length; i++)
            {
                reader = new XmlTextReader(args[i]);
                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {
                        writer.WriteNode(reader, true);
                        break;
                    }
                }
                reader.Close();
            }

            writer.WriteEndDocument();
            writer.Close();
        }

        static void Help()
        {
            Console.WriteLine("\n\tXmlMerge Usage");

            Console.WriteLine("\n\t[Description]");
            Console.WriteLine("\t\tXmlMerge is a simple tool used to merge multiple XML files under a single root node.");
            Console.WriteLine("\t\tNote: There are no param names, so you must specify them in the correct order.");

            Console.WriteLine("\n\t[Parameters]");
            Console.WriteLine("\t\t *Output File*\tThe name of the xml file to output the merged files to.");
            Console.WriteLine("\t\t *Xsl Transform*\tThe name of the xsl transform file to apply at the top of the file.");
            Console.WriteLine("\t\t *Root Node*\tThe name of the root node that everything will be listed under.");
            Console.WriteLine("\t\t *XML files*\tSpace delimited list of xml files to merge into one.");

            Console.WriteLine("\n\t[Examples]");
            Console.WriteLine("\t\t Merge file a.xml and b.xml under the root node called 'ROOT' into output.xml and tack on the xsl transform trans.xsl.");
            Console.WriteLine("\t\t\t XmlMerge output.xml trans.xsl ROOT a.xml b.xml");



        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmltosg\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmltransform\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlPrep\xmlprep.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;

namespace XmlPreprocessor
{
    class Program
    {
        static void ProcessXmlElement(XmlDocument xmlDocument, XmlElement xmlElement)
        {
            XmlNode xmlNode = xmlElement.FirstChild;
            while (xmlNode != null)
            {
                if (xmlNode.NodeType == XmlNodeType.Element)
                {
                    ProcessXmlElement(xmlDocument, xmlNode as XmlElement);
                }
                else if (xmlNode.NodeType == XmlNodeType.ProcessingInstruction)
                {
                    XmlNode xmlPrevNode = xmlNode.PreviousSibling;
                    ProcessXmlProcessingInstruction(xmlDocument, xmlNode as XmlProcessingInstruction);
                    xmlNode = xmlPrevNode.NextSibling;
                }
                xmlNode = xmlNode.NextSibling;
            }
        }

        static void ProcessXmlProcessingInstruction(XmlDocument xmlDocument, XmlProcessingInstruction xmlProcessingInstruction)
        {
            if (xmlProcessingInstruction.Name == "XmlInclude")
            {
                ProcessXmlInclude(xmlDocument, xmlProcessingInstruction);
            }
        }

        private static void ProcessXmlInclude(XmlDocument xmlDocument, XmlProcessingInstruction xmlProcessingInstruction)
        {
            XmlDocument xmlInclude = new XmlDocument();
            xmlInclude.Load(xmlProcessingInstruction.Value.Trim());

            if (xmlInclude.DocumentElement.Name != "XmlInclude")
            {
                return;
            }

            String previousDirectory = Directory.GetCurrentDirectory();
            Directory.SetCurrentDirectory(Path.GetDirectoryName(Path.GetFullPath(xmlProcessingInstruction.Value.Trim())));
            ProcessXmlElement(xmlInclude, xmlInclude.DocumentElement);
            Directory.SetCurrentDirectory(previousDirectory);            

            foreach (XmlNode xmlNode in xmlInclude.DocumentElement)
            {
                XmlNode xmlNodeCopy = xmlDocument.ImportNode(xmlNode, true);
                xmlProcessingInstruction.ParentNode.InsertBefore(xmlNodeCopy, xmlProcessingInstruction);
            }
            xmlProcessingInstruction.ParentNode.RemoveChild(xmlProcessingInstruction);
            xmlInclude.RemoveAll();
        }

        static int Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("XmlPrep [xmlfile] > [output]");

                return -1;
            }
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.Load(args[0]);

            String previousDirectory = Directory.GetCurrentDirectory();
            Directory.SetCurrentDirectory(Path.GetDirectoryName(Path.GetFullPath(args[0])));
            ProcessXmlElement(xmlDocument, xmlDocument.DocumentElement);
            Directory.SetCurrentDirectory(previousDirectory);

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Indent = true;

            XmlWriter writer = XmlWriter.Create(Console.Out, settings);
            xmlDocument.WriteContentTo(writer);
            writer.Flush();

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XmlPrep\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xmlprep_none_12.4.56.0_none_0cd3596c97bff645
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmlprep
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.manifest
XP_MANIFEST_PATH=manifests\msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.cat
XP_CATALOG_PATH=manifests\msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927.cat
XP_PAYLOAD_PATH=msil_xmlprep_no-public-key_12.4.56.0_x-ww_057e3927
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmlprep,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmltosg\xmltosg.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using xonline.common.service;

namespace xonline.tools.xmltosg
{
    public class XmlToSg
    {
        public static void Main(string[] args)
        {
            string xml;
            int node = -1;
            
            if (args.Length == 0 ||
                (args.Length > 0 && args[0] == "/?"))
            {
                Console.WriteLine("");
                Console.WriteLine("Usage: xmltosg <file.xml> [<server index>]");
                Console.WriteLine("");
                Console.WriteLine("    <file.xml>: the xml file that contains the SG configration");
                Console.WriteLine("");
                Console.WriteLine("    <server index>: when the config is for more than one sg, this ");
                Console.WriteLine("        is the index of the server to use (corrisponds to the ");
                Console.WriteLine("        'node' attribute in the <networkInterface /> elements.");
                Console.WriteLine("");
                Console.WriteLine("This tool generates sgconfig.ini files based on a xml ");
                Console.WriteLine("description. The results are written to sdout.  ");
                return;
            }

            if (args.Length == 2)
            {
                node = Convert.ToInt32(args[1]);
            }    
            
            StreamReader reader = File.OpenText(args[0]);
            xml = reader.ReadToEnd();
            reader.Close();
            
            ParseXml(xml, args[0], node);
        }
    
        public static void ParseXml(string xml, string filename, int node)
        {
            XPathDocument doc = new XPathDocument(new StringReader(xml));                                  
            XPathNavigator root = doc.CreateNavigator();
    
            XPathNodeIterator sgs = root.Select("//securityGateway");
            if (sgs.Count == 0)
            {
                throw new Exception("No securityGateway nodes!!");
            }
            
            while(sgs.MoveNext())
            {
                
                WriteHeader(sgs.Current, filename);
                WriteConfigParams(sgs.Current);
                WriteNetworInterfaces(sgs.Current, node);
                WriteServices(sgs.Current);
                WriteServers(sgs.Current);
            }
        }
                            
        public static void WriteHeader(XPathNavigator node, string filename)
        {
            string name = node.GetAttribute("name", "");
            
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("; SG Configuration v2 for " + name);
            Console.WriteLine(";");
            Console.WriteLine("; Generated " + DateTime.Now + " from " + Path.GetFileName(filename));
            Console.WriteLine(";");
            Console.WriteLine("; This file is intended for an SG built after Fall 2007.");
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("");
        }
        
        public const int    DEFAULT_CLIENT_LIMIT         = 30000;
        public const int    DEFAULT_CLIENT_HISTORY_LIMIT = 40000;
        public const int    DEFAULT_PACKET_POOL_MAX      = 50000;
        public const string DEFAULT_LOGGING_PATH         = "e:\\logroot\\sg";
        
        public static void WriteConfigParams(XPathNavigator node)
        {
            int clientLimit = SafeConvert.ToInt32(node.GetAttribute("clientLimit", ""), -1);
            if (clientLimit == 0)
            {
                clientLimit = DEFAULT_CLIENT_LIMIT;
            }

            int clientHistoryLimit = SafeConvert.ToInt32(node.GetAttribute("clientHistoryLimit", ""), -1);
            if (clientHistoryLimit == 0)
            {
                clientHistoryLimit = DEFAULT_CLIENT_HISTORY_LIMIT;
            }

            int packetPoolMax = SafeConvert.ToInt32(node.GetAttribute("packetPoolMax", ""), -1);
            if (packetPoolMax == 0)
            {
                packetPoolMax = DEFAULT_PACKET_POOL_MAX;
            }

            string loggingPath = node.GetAttribute("loggingPath", "");
            if (loggingPath == null || loggingPath == "")
            {
                loggingPath = DEFAULT_LOGGING_PATH;
            }
                    
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("; General Configuration Parameters");
            Console.WriteLine(";");
            Console.WriteLine("; This section defines miscellaneous parameters for the gateway as a whole.");
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("EnableConnectionServices        0");
            Console.WriteLine("ClientLimit                     " + clientLimit);
            Console.WriteLine("ClientHistoryLimit              " + clientHistoryLimit);
            Console.WriteLine("PacketPoolMax                   " + packetPoolMax);
            Console.WriteLine("");
            Console.WriteLine("AdvertiseOnLive                 0");
            Console.WriteLine("GetSiteInfoFromLive             0");
            Console.WriteLine("LoggingEnabled                  1");
            Console.WriteLine("LoggingPath                     " + loggingPath);
            Console.WriteLine("LoggingRotationTimeInMinutes    60");
            Console.WriteLine("LoggingRotationSizeInBytes      1000000000");
            Console.WriteLine("");
            
        }
        


        public static void WriteNetworInterfaces(XPathNavigator sgnode, int serverIndex)
        {
            bool hasDatacenter = false;
            bool hasInternet = false;
            
            XPathNodeIterator nics = sgnode.Select("networkInterface" + (serverIndex == -1 ? "" : "[@node='" + serverIndex + "']"));
            
            if (nics.Count == 0)
            {
                throw new Exception("No networkInterface nodes found!");
            }
            
            
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("; Network Interfaces");
            Console.WriteLine(";");
            Console.WriteLine("; This section specifies the set of network interfaces the gateway is connected to.");
            Console.WriteLine("; There must be at least one Internet and one Datacenter Network Interface defined.");
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            
            while (nics.MoveNext())
            {
                string type = nics.Current.GetAttribute("type", "");
                int id = SafeConvert.ToInt32(nics.Current.GetAttribute("id", ""), -1);
                string ipFront = nics.Current.GetAttribute("ipFront", "");
                string ipStart = nics.Current.GetAttribute("ipStart", "");
                string ipEnd = nics.Current.GetAttribute("ipEnd", "");                
                string ipAdmin = nics.Current.GetAttribute("ipAdmin", "");
                string subnet = nics.Current.GetAttribute("subnetMask", "");
                string gateway = nics.Current.GetAttribute("gateway", "");
                string lan = nics.Current.GetAttribute("lan", "");
                string mac = nics.Current.GetAttribute("mac", "");

                // mac should be something like "000F1F0408D7", but we'll be nice
                mac = mac.Replace("-", "");
                mac = mac.Replace(":", "");
                mac = mac.Replace(" ", "");
                
                if (type.ToLower() == "datacenter")
                {
                    Check(id != -1, "No Id specified for internet networkInterface!");
                    Check(ipStart != "", "Missing ipStart setting for networkInterface!");
                    Check(ipEnd != "", "Missing ipEnd setting for networkInterface!");
                    Check(ipAdmin != "", "Missing ipAdmin setting for networkInterface!");
                    
                    hasDatacenter = true;
                }
                else if (type.ToLower() == "internet")
                {
                    Check(ipFront != "", "Missing ipFront setting for networkInterface!");
                    
                    hasInternet = true;
                }
                else 
                {
                    Check(false, "Invalid networkInterface type " + type);
                }
                    
                Check(subnet != "", "Missing subnet setting for networkInterface!");
                Check(gateway != "", "Missing gateway setting for networkInterface!");
                Check(mac != "", "Missing mac setting for networkInterface!");

                if (lan != "")
                {
                    Console.Error.WriteLine("Warning: \"lan\" setting for networkInterface is deprecated.");
                }
                
                    
                Console.WriteLine("NetworkInterface ");
                Console.WriteLine("{ ");
                Console.WriteLine("    Type                " + type);
                
                if (type.ToLower() == "datacenter")
                {
                    Console.WriteLine("    Id                  " + id);
                    Console.WriteLine("    Ip                  " + ipStart);
                    Console.WriteLine("    IpEnd               " + ipEnd);
                    Console.WriteLine("    IpAdmin             " + ipAdmin);
                }                    
                else
                {
                    Console.WriteLine("    Ip                  " + ipFront);
                }
                
                    
                Console.WriteLine("    IpMask              " + subnet);
                Console.WriteLine("    IpGateway           " + gateway);
                Console.WriteLine("    Nic                 " + mac);
                Console.WriteLine("}");
                Console.WriteLine("");
            }
            Console.WriteLine("");
            
            Check(hasInternet && hasDatacenter, "Missing at least one each of Internet and/or Datacenter type networkInterfaces!");
                                                                      
        }


        public static void WriteServices(XPathNavigator sgnode)
        {
            XPathNodeIterator services = sgnode.Select("service");
            
            Check(services.Count != 0, "No service nodes found!");
            Check(services.Count <= 32, "Too many services found!");
            
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("; Services");
            Console.WriteLine(";");
            Console.WriteLine("; This section specifies the Id and Name of each service that any of the servers");
            Console.WriteLine("; behind the gateway provide.  There is a maximum of 32 services that can be specified.");
            Console.WriteLine("; Note that only those services which are referenced by the Servers section need be");
            Console.WriteLine("; listed here.");
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            
            
            while(services.MoveNext())
            {
                string name = services.Current.GetAttribute("name", "").ToUpper();
                int id = SafeConvert.ToInt32(services.Current.GetAttribute("id", ""), -1);
                
                Check(name != "", "No name attribute found in service node!");
                Check(id != -1, "Failed to find or parse service id in service node");
                
                Console.WriteLine("Service");
                Console.WriteLine("{");
                Console.WriteLine("    Id                  0x" + id.ToString("x"));
                Console.WriteLine("    Name                " + name.ToUpper());
                Console.WriteLine("}");
                Console.WriteLine("");
                
            }                
            
            Console.WriteLine("");
        }
        


        public static void WriteServers(XPathNavigator sgnode)
        {
            XPathNodeIterator services = sgnode.Select("service");
            
            Check(services.Count != 0, "No service nodes found!");
            Check(services.Count <= 32, "Too many services found!");
            
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
            Console.WriteLine("; Servers");
            Console.WriteLine(";");
            Console.WriteLine("; Each server in the datacenter is assigned an Id that the client uses as the destination");
            Console.WriteLine("; port to address UDP or TCP packets.  This port is used to route the packet to the");
            Console.WriteLine("; given server on the datacenter.  Note that each server must have a unique Ip/Port pair.");
            Console.WriteLine("; That is, it is illegal for two server records to point to the same Ip/Port.  It is");
            Console.WriteLine("; acceptable, however, to have two server records point to the same Ip on different Ports.");
            Console.WriteLine("; ----------------------------------------------------------------------------------------");
                    

                
            while(services.MoveNext())
            {
                string name = services.Current.GetAttribute("name", "").ToUpper();
                
                Check(name != "", "No name attribute found in service node!");
                
                Hashtable hosts = new Hashtable();
                XPathNodeIterator hostNodes = services.Current.Select("host");
                while (hostNodes.MoveNext())
                {
                    hosts.Add(hostNodes.Current.GetAttribute("name", ""), hostNodes.Current.GetAttribute("ip", ""));
                }
                
                XPathNodeIterator mappingNodes = services.Current.Select("mapping");
                
                XPathNodeIterator portNodes = null;
                XPathNodeIterator serverNodes = null;
                XPathNodeIterator clientPortNodes = null;
                XPathNodeIterator protocolNodes = null;
                
                string port = "";
                string clientPort = "";
                string ip = "";
                string protocol = "";
                int startPort = 0;
                int endPort = 0;
                
                
                while(mappingNodes.MoveNext())
                {
                    string type = mappingNodes.Current.GetAttribute("type", "");
                    protocol = "";
                    
                    switch (type)
                    {
                    case "single-1-to-1":
                        portNodes = mappingNodes.Current.Select("port");
                        serverNodes = mappingNodes.Current.Select("server");
                        protocolNodes = mappingNodes.Current.Select("protocol");
                        
                        Check(portNodes.Count == 1, "Not enough, or too many, port nodes specified for service: " + name + " type " + type);
                        Check(serverNodes.Count == 1, "Not enough, or too many, server nodes specified for service: " + name + " type " + type);
                        Check(protocolNodes.Count <= 1, "Too many protocol nodes specified for service: " + name + " type " + type);
                        
                        portNodes.MoveNext();
                        serverNodes.MoveNext();
                        protocolNodes.MoveNext();
                        
                        port = portNodes.Current.Value;
                        ip = serverNodes.Current.Value;
                        ip = (hosts.ContainsKey(ip) ? (string)hosts[ip] : ip);
                        if (protocolNodes.Count > 0)
                        {
                            protocol = " Protocol " + protocolNodes.Current.Value;
                        }
                        
                        Console.WriteLine("Server { Id " + port + " Service " + name + protocol + " Address { InterfaceId 1 Ip " + ip + " Port " + port + " } }");
                        break;
                        
                    case "range-1-to-1":
                        portNodes = mappingNodes.Current.Select("portRange");
                        serverNodes = mappingNodes.Current.Select("server");
                        protocolNodes = mappingNodes.Current.Select("protocol");
                        
                        Check(portNodes.Count == 1, "Not enough, or too many, portRange nodes specified for service: " + name + " type " + type);
                        Check(serverNodes.Count == 1, "Not enough, or too many, server nodes specified for service: " + name + " type " + type);
                        Check(protocolNodes.Count <= 1, "Too many protocol nodes specified for service: " + name + " type " + type);
                        
                        portNodes.MoveNext();
                        serverNodes.MoveNext();
                        protocolNodes.MoveNext();
                        
                        startPort = SafeConvert.ToInt32(portNodes.Current.GetAttribute("start", ""));
                        endPort = SafeConvert.ToInt32(portNodes.Current.GetAttribute("end", ""));
                        ip = serverNodes.Current.Value;
                        ip = (hosts.ContainsKey(ip) ? (string)hosts[ip] : ip);
                        if (protocolNodes.Count > 0)
                        {
                            protocol = " Protocol " + protocolNodes.Current.Value;
                        }
                        
                        for (int i = startPort; i <= endPort; i++)
                        {
                            Console.WriteLine("Server { Id " + i + " Service " + name + protocol + " Address { InterfaceId 1 Ip " + ip + " Port " + i + " } }");
                        }
                                                       
                        break;
                        
                    case "single":
                        portNodes = mappingNodes.Current.Select("port");
                        serverNodes = mappingNodes.Current.Select("server");
                        clientPortNodes = mappingNodes.Current.Select("clientRequestedPort");
                        protocolNodes = mappingNodes.Current.Select("protocol");
                        
                        Check(portNodes.Count == 1, "Not enough, or too many, port nodes specified for service: " + name + " type " + type);
                        Check(serverNodes.Count == 1, "Not enough, or too many, server nodes specified for service: " + name + " type " + type);
                        Check(clientPortNodes.Count == 1, "Not enough, or too many, clientRequestedPort odes specified for service: " + name + " type " + type);
                        Check(protocolNodes.Count <= 1, "Too many protocol nodes specified for service: " + name + " type " + type);
                        
                        portNodes.MoveNext();
                        serverNodes.MoveNext();
                        clientPortNodes.MoveNext();
                        protocolNodes.MoveNext();
                        
                        port = portNodes.Current.Value;
                        clientPort = clientPortNodes.Current.Value;
                        ip = serverNodes.Current.Value;
                        ip = (hosts.ContainsKey(ip) ? (string)hosts[ip] : ip);
                        if (protocolNodes.Count > 0)
                        {
                            protocol = " Protocol " + protocolNodes.Current.Value;
                        }
                        
                        Console.WriteLine("Server { Id " + clientPort + " Service " + name + protocol + " Address { InterfaceId 1 Ip " + ip + " Port " + port + " } }");
                                                       
                        break;
                        
                    default:
                        Check(false, "Unrecgonized mapping type : " + type);                    
                        break;
                                            
                        
                    }
                    
                    Console.WriteLine("");                                                   
                
                }                
                
                Console.WriteLine("");
            }
        }
        
        
        public static void Check(bool f, string msg)
        {
            if (!f) throw new Exception(msg);
        }    
            
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\client_results.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for client_log_commands.
	/// </summary>
	public class client_results : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
	
		string clientip;
		int rows;

		StringBuilder sb; 
		private void Page_Load(object sender, System.EventArgs e)
		{	
			sb = new StringBuilder();

			try
			{
				clientip = Page.Request.QueryString["clientip"].ToString();
				rows = Convert.ToInt32(Page.Request.QueryString["rows"].ToString());
			}
			catch 
			{
				Response.Write("Page error : 'clientip' and 'rows' querystring values are either invalid, out of range, or do not exist.");
				Response.End();
			}
			Client cl = XonWatchSvc.GetClientByIP(clientip,this.Context);

			sb.Append("Name : " + cl.Name + "<br>");
			sb.Append("IP : " +  cl.IPAddress + "<br>");
			sb.Append("Uptime : " + cl.UpTime +  "<br>");
			sb.Append("Last Update : " +  cl.LastUpdate + "<br>");
			
			// Put user code to initialize the page here
			XonWatchDB db = (XonWatchDB)Application["DB"];
			DataTable t = db.ResultsForClientGet(clientip, rows);

			sb.Append(@"<table><tr><td>TIME</td><td>SCRIPT</td><td>HRESULT</td><td>MESSAGE</td></tr>");
			
			foreach (DataRow r in t.Rows)
			{
				sb.Append(@"<tr><td>");
				sb.Append(r["dt_logged"].ToString());
				sb.Append(@"</td><td>");
				sb.Append(r["i_script"].ToString());
				sb.Append(@"</td><td>");
				sb.Append(r["i_hresult"].ToString());
				sb.Append(@"</td><td>");
				sb.Append(r["vc_message"].ToString());
				sb.Append(@"</td></tr>");
			}

			sb.Append("</table>");

			content.Text = sb.ToString();
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\client.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for client.
	/// </summary>
	public class client : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
	
		private string clientip;
		//private int rows;

		protected System.Web.UI.WebControls.ListBox lbClients;
		protected System.Web.UI.WebControls.ListBox lbEnv;
		private StringBuilder sb; 

		public string SelectedClient;
		public string SelectedEnv;

		private void Page_Load(object sender, System.EventArgs e)
		{	

			SelectedClient = lbClients.SelectedValue;
			SelectedEnv = lbEnv.SelectedValue;

			Client cl = XonWatchSvc.GetClientByIP(SelectedClient,this.Context);
			Environment en = XonWatchSvc.GetEnvironmentByName(SelectedEnv,this.Context);

			if (!IsPostBack || (cl.EnvironmentID != en.ID))
			{

				try
				{
					clientip = Page.Request.QueryString["clientip"].ToString();
				}
				catch 
				{
					Response.Write("Page error : 'clientip' value is either invalid, out of range, or do not exist.");
					Response.End();
				}

				SortedList environments = XonWatchSvc.GetEnvironments(this.Context);
				foreach (Xonwatch.Environment env in environments.Values)
				{
					lbEnv.Items.Add(env.Name.ToString());
				}

				SortedList clients = XonWatchSvc.GetClients(this.Context);
				foreach (Client client in clients.Values)
				{			
					lbClients.Items.Add(client.IPAddress.ToString());
				}
				
				sb = new StringBuilder();

				//rows = 100;
				sb.Append(@"<IFRAME width=""1024"" height=""600"" src=""client_results.aspx?rows=100&clientip=" + clientip + @"""/>");
		
				content.Text = sb.ToString();

			}

			if (clientip != null)
			{
				lbClients.SelectedValue = clientip;
		
				Environment envi = XonWatchSvc.GetEnvironmentByClientIP(clientip, this.Context);
				lbEnv.SelectedValue = envi.Name;
			}

			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.lbEnv.SelectedIndexChanged += new System.EventHandler(this.lbEnv_SelectedIndexChanged);
			this.lbClients.SelectedIndexChanged += new System.EventHandler(this.lbClients_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void lbClients_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Response.Redirect("client.aspx?clientip=" + SelectedClient + "&envid=" + SelectedEnv);
		}

		private void lbEnv_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Response.Redirect("client.aspx?clientip=" + SelectedClient + "&envid=" + SelectedEnv);	
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\config.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for config.
	/// </summary>
	public class config : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.TextBox txtip;
		protected System.Web.UI.WebControls.Label lblip;
		protected System.Web.UI.WebControls.Label lblport;
		protected System.Web.UI.WebControls.TextBox txtport;
		protected System.Web.UI.WebControls.Literal message;
		protected System.Web.UI.WebControls.Button btnsubmit;

		private void Page_Load(object sender, System.EventArgs e)
		{
			if (Application["XonWatchRemoting"] == null)
			{
				message.Text = "<div bgcolor=\"yellow\">There is no XonWatch Service found at the current address and port.</div>";
			}

			// Put user code to initialize the page here
			if (Application["ipaddress"] != null)
			{
				txtip.Text = Application["ipaddress"].ToString();
			}
			else
			{
				txtip.Text = String.Empty;
			}

			if (Application["port"] != null)
			{
				txtport.Text = Application["port"].ToString();
			}
			else
			{
				txtport.Text = String.Empty;
			}

			Application["ipaddress"] = txtip.Text;
			Application["port"] = txtport.Text;

		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.btnsubmit.Click += new System.EventHandler(this.btnsubmit_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void btnsubmit_Click(object sender, System.EventArgs e)
		{

			if (Request.Form["txtip"].ToString() == String.Empty)
			{
				Response.Redirect("config.aspx");
			}

			if (Request.Form["txtport"].ToString() == String.Empty)
			{
				Response.Redirect("config.aspx");
			}

			Application["ipaddress"] = Request.Form["txtip"].ToString();
			Application["port"] = Request.Form["txtport"].ToString();

			string ipaddress = Application["ipaddress"].ToString();
			int port = Convert.ToInt32(Application["port"].ToString());

			if (Application["XonWatchRemoting"] == null)
			{
				XonWatchSvc xonwatch = new XonWatchSvc(ipaddress, port);
			}

			Response.Redirect("default.aspx");

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\debug.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace XonWatch
{
	/// <summary>
	/// Summary description for debug.
	/// </summary>
	public class debug : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xmltransform\xmltransform.cs ===
using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Xsl;

namespace XmlTransform
{
    class Program
    {
        private static XmlSchemaException validationException = null;

        private static void Validate(string xmlPath, string xsdPath)
        {
            XmlSchemaSet schemaSet = new XmlSchemaSet();
            schemaSet.Add(null, xsdPath);

            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ValidationType = ValidationType.Schema;
            settings.Schemas = schemaSet;
            settings.ValidationEventHandler += new ValidationEventHandler(ValidationCallback);
     
            XmlReader xmlReader = XmlReader.Create(xmlPath, settings);

            while (xmlReader.Read()) {
                if (validationException != null) throw validationException;
            }
        }

        private static void ValidationCallback(object sender, ValidationEventArgs args)
        {
            if (validationException == null) {
                validationException = args.Exception;
            }
        }
        
        private static bool GetOption(string[] args, ref int i, string option, ref string param)
        {
            if (args[i] != option) return false;
            if (i + 1 >= args.Length) throw new Exception("Missing parameter for option " + option);
            param = args[++i];
            return true;
        }

        static int Main(string[] args)
        {

            string xsdPath = null;
            string xslPath = null;
            string xmlPath = null;
            string outPath = null;

            // page the command line arguments and create  argument
            // list that we will pass through to the transformation

            int i = 0;
            string param = null;
            XsltArgumentList argumentList = null;

            while (i < args.Length)
            {
                if (args[i].StartsWith("/")) args[i] = "-" + args[i].Substring(1);

                if ((args[i].ToLower() == "-h") || (args[i].ToLower() == "-help") || (args[i].ToLower() == "-?"))
                {
                    Usage();
                    return -1;
                }

                try
                {
                    // order doesn't matter.

                    if (GetOption(args, ref i, "-out", ref outPath)) continue;
                    if (GetOption(args, ref i, "-xsd", ref xsdPath)) continue;
                    if (GetOption(args, ref i, "-xsl", ref xslPath)) continue;
                    if (GetOption(args, ref i, "-xml", ref xmlPath)) continue;

                    // parameters come in the form  name=value,  if
                    // we find one, then parse around the '='  char

                    if (GetOption(args, ref i, "-param", ref param))
                    {
                        if (argumentList == null) argumentList = new XsltArgumentList();
                        string[] s = param.Split('=');

                        if (s.Length != 2)
                        {
                            Console.Error.WriteLine("Error parsing name value pair, '{0}'", param);
                            Usage();
                            return -1;
                        }

                        argumentList.AddParam(s[0], "", s[1]);
                        continue;
                    }
                }
                catch (Exception)
                {
                    Console.Error.WriteLine("Error parsing command line");
                    Usage();
                    return -1;
                }

                i++;
            }

            // they have to have both an XML path and XSL path. All
            // the other parameters are optional

            if (xmlPath == null)
            {
                Console.Error.WriteLine("No xml file was specified");
                Usage();
                return -1;
            }

            if (xslPath == null)
            {
                Console.Error.WriteLine("No xsl file was specified");
                Usage();
                return -1;
            }

            // if they provided a schema, then validate the XML file
            // against the schema.  bail out if it does not validate

            if (xsdPath != null)
            {
                try
                {
                    Validate(xmlPath, xsdPath);
                }
                catch (Exception e)
                {
                    Console.Error.WriteLine("Error validating xml file against schema");
                    Console.Error.Write(e.Message);

                    if (e is XmlSchemaException)
                    {
                        XmlSchemaException xse = (XmlSchemaException) e;
                        Console.Error.Write(" Line {0}, Position {1}.", xse.LineNumber, xse.LinePosition);
                    }

                    Console.Error.WriteLine();
                    return -1;
                }
            }

            // load up the XSL file so we can do the transformation

            XslCompiledTransform xslt;

            try
            {
                xslt = new XslCompiledTransform();
                xslt.Load(xslPath);
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error reading XSL file, '{0}'", xslPath);
                Console.Error.WriteLine(e.Message);
                return -1;
            }
        
            // use a string builder for the output so we don't write
            // a partial file when we incur  some  sort  of  failure

            StringBuilder stringBuilder = new StringBuilder();
            TextWriter textWriter = new StringWriter(stringBuilder);

            // transform the input file and write to the output path

            try
            {
                xslt.Transform(xmlPath, argumentList, textWriter);
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error transforming input file, '{0}'", xmlPath);
                Console.Error.WriteLine(e.Message);
                return -1;
            }
            finally {
                textWriter.Dispose();
                textWriter = null;
            }

           // if we get here then we have a successfully transformed
           // file in our stringbuilder.  Attempt to  write  it  out.

            try
            {
                // if they don't supply an outpath,  then use stdout

                if (outPath == null)
                    textWriter = Console.Out;
                else
                {
                    textWriter = new StreamWriter(outPath);
                }

                textWriter.Write(stringBuilder.ToString());
            }
            catch (Exception e)
            {
                Console.Error.WriteLine("Error opening output file, '{0}'", outPath);
                Console.Error.WriteLine(e.Message);
                return -1;
            }
            finally
            {
                if ((outPath != null) && (textWriter != null))
                {
                    textWriter.Dispose();
                    textWriter = null;
                }
            }

            return 0;
        }

        static void Usage()
        {
            Console.Error.WriteLine();
            Console.Error.WriteLine("Usage: xmltransform");
            Console.Error.WriteLine("\t-xsd <xsdfile>\r\n\t\tinput xsd file to validate xml file [optional]");
            Console.Error.WriteLine("\t-xml <xmlfile>\r\n\t\tinput xml file to be transformed");
            Console.Error.WriteLine("\t-xsl <xslfile>\r\n\t\tinput xsl file used to transform the xml file");
            Console.Error.WriteLine("\t-out <outfile>\r\n\t\toutput file [optional, default = Console.Out]");
            Console.Error.WriteLine();
            Console.Error.WriteLine("\t-param name=value [optional, multiple allowed]");
            Console.Error.WriteLine("\t\tusers can supply zero or more name value pairs");
            Console.Error.WriteLine("\t\tto be passed the xslt processor as  parameters");
            Console.Error.WriteLine();
            Console.Error.WriteLine("Examples:");
            Console.Error.WriteLine("\txmltransform -xml my.xml -xsl my.xsl -out foo.out");
            Console.Error.WriteLine("\txmltransform -xml my.xml -xsl my.xsl -param env=xblob");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\default_view.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for environment_view.
	/// </summary>
	public class default_view : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
		private StringBuilder sb;

		private void Page_Load(object sender, System.EventArgs e)
		{
			sb = new StringBuilder();
			Information info = XonWatchSvc.GetInformation(this.Context);
			SortedList testtypes = XonWatchSvc.GetTestTypes(this.Context);

			sb.Append("<table>");

			sb.Append("<tr colspan=\"3\"><td>");
			sb.Append("<div class=\"title1\">Status</div>");
			sb.Append("</td></tr>");

			sb.Append("<tr colspan=\"3\"><td>");
			sb.Append("<div class=\"title2\">Uptime: </div>");
			sb.Append("<div class=\"title2\">" + DateTime.Now.ToUniversalTime() + info.UpTime.ToString() + "</div>");
			sb.Append("</td></tr>");

			int totaltests = 0;
			int totalfails = 0;

			foreach (TestType t in testtypes.Values)
			{
				sb.Append("<tr><td>");
				sb.Append("<input type=\"button\" value=\"" + t.id + "\" name=\"" + t.name + "\"></input>");
				sb.Append("</td><td>");
				sb.Append("Total tests: ");
				sb.Append(t.tests);
				sb.Append("</td><td>");
				sb.Append("Total failures: ");
				sb.Append(t.fails);
				sb.Append("</td></tr>");

				totaltests += t.tests;
				totalfails += t.fails;
			}			

			//error analysis
			sb.Append("<tr><td>");
			sb.Append("<input onclick=\"window.open('errors.aspx')\" type=\"button\" value=\"errors\" name=\"errors\"></input>");
			sb.Append("</td><td>");
			sb.Append("Total tests: ");
			sb.Append(totaltests);
			sb.Append("</td><td>");
			sb.Append("Total failures: ");
			sb.Append(totalfails);
			sb.Append("</td></tr>");

			//management
			sb.Append("<tr colspan=\"3\"><td>");
			sb.Append("<input onclick=\"window.open('management.aspx')\" type=\"button\" value=\"management\" name=\"management\"></input>");
			sb.Append("</td></tr>");

			sb.Append("</table>");

			this.content.Text = sb.ToString();		
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class Default : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Button btnRefresh;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			if (Application["XonWatchRemoting"] == null)
			{
				Response.Redirect("config.aspx");
			}

			XonWatchSvc s = (XonWatchSvc)Application["XonWatchRemoting"];

			// try to load app from existing address 
			if ((string)Application["ServiceIP"]==String.Empty || Application["ServiceIP"]==null)
			{
				Response.Redirect("config.aspx");
			}

			if (Application["ServicePort"]==null)
			{
				Response.Redirect("config.aspx");
			}
		}
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.btnRefresh.Click += new System.EventHandler(this.btnRefresh_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void btnRefresh_Click(object sender, System.EventArgs e)
		{
			XonWatchSvc s = (XonWatchSvc)Application["XonWatchRemoting"];
			s.RemoteData.bRefreshData = true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\environment.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using Xonwatch;

namespace Xonwatch
{
    /// <summary>
    /// Summary description for environment.
    /// </summary>
    public class environment : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.DropDownList lbEnv;
        protected System.Web.UI.HtmlControls.HtmlGenericControl cfg_new;  
        protected System.Web.UI.HtmlControls.HtmlGenericControl cfg_exist;  
        protected System.Web.UI.HtmlControls.HtmlGenericControl cfg_clients;  

        //protected System.Web.UI.WebControls.Literal content;
    
        public string qs; //querystring that we'll pass along to the page
        public string SelectedEnv;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            SelectedEnv = lbEnv.SelectedValue;
    
            String envid = "";
             
            if (Request.QueryString["env"] != null)
            {
                envid = Request.QueryString["env"].ToString();
            }
            
            SortedList environments = XonWatchSvc.GetEnvironments(this.Context);
            foreach (Xonwatch.Environment en in environments.Values)
            {
                if (envid.Length == 0)
                    envid = en.ID.ToString();
    
                lbEnv.Items.Add(en.Name.ToString());
            }
    
            Environment env = XonWatchSvc.GetEnvironmentByID(envid, this.Context);
            lbEnv.SelectedValue = env.Name;

            XonWatchSvc.SetCurrentEnvironment(this.Context, env.Location);
    

            cfg_new.Attributes["src"]      = @"environment_cfg_new.aspx?env=" + envid;
            cfg_exist.Attributes["src"]    = @"environment_cfg_existing.aspx?env=" + envid;
            cfg_clients.Attributes["src"]  = @"environment_clients.aspx?env=" + envid;


        }
    
    
        
        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
        
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.lbEnv.SelectedIndexChanged += new System.EventHandler(this.lbEnv_SelectedIndexChanged);
            this.Load += new System.EventHandler(this.Page_Load);
    
        }
        #endregion
    
    
        private void lbEnv_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            Environment env = XonWatchSvc.GetEnvironmentByName(SelectedEnv, this.Context);
    
            Response.Redirect("environment.aspx?env=" + env.ID.ToString());
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\default_status.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for environment_status.
	/// </summary>
	public class default_status : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
		private StringBuilder sb;

		private void Page_Load(object sender, System.EventArgs e)
		{
			sb = new StringBuilder();

			sb.Append(@"<table width=""1024"">");
			
			SortedList environments = XonWatchSvc.GetEnvironments(this.Context);
			SortedList clients = XonWatchSvc.GetClients(this.Context);

			foreach (Environment env in environments.Values)
			{


				bool envFailure = false;

				foreach (Client client in clients.Values)
				{
					
					if (client.EnvironmentID == env.ID)
					{
						if (client.Failing || !client.SendSocket || !client.RecvSocket)
						{
							envFailure = true;
							break;
						}
					}
				}

				if (envFailure == false)
				{
					sb.Append("<tr>");
				}
				else
				{
					sb.Append("<tr bgcolor=\"red\">");
				}

				sb.Append(@"<td width=""224""><span onclick=""window.open('environment.aspx?config=false&env=" + env.ID.ToString() + @"')"">" + env.Name + "</span></td>");
				
				sb.Append("<td width=\"700\">");
				sb.Append("<table><tr>");

				foreach (Client client in clients.Values)
				{
					
					if (client.EnvironmentID == env.ID)
					{
						sb.Append(@"<td width=""125""><span class=""smalltext"" onclick=""parent.window.open('client.aspx?clientip=" + client.IPAddress + @"')"">");
	
						if (client.Failing || !client.SendSocket || !client.RecvSocket)
						{
							string reason = "";
							if (client.Failing)
								reason = reason + "Client is failing.";
							if (!client.SendSocket)
								reason = reason + "No send socket for client.";
							if (!client.RecvSocket)
								reason = reason + "No recv socket for client";

							sb.Append(@"<img alt=""" + reason + @""" src=""images/client_fail.gif"">");
						}
						else
						{
							string reason ="online";
							sb.Append(@"<img alt=""" + reason + @""" src=""images/client_ok.gif"">");						
						}
						sb.Append(client.IPAddress + "<br>(" + client.Name + ")");

						sb.Append("</span></td>");
					}
				}
				sb.Append("</tr></table>");
				sb.Append("</td>");

				sb.Append(@"<td width=""100"">");
				sb.Append("<input type=\"button\" value=\"Edit\" name=\"" + env.ID +  "\"></input>");
				sb.Append("</td>");
				sb.Append("</tr>");
			}			

/* TODO : ADD / REMOVE ENVIRONMENTS
			sb.Append("<tr><td></td><td>");
			sb.Append("<input type=\"button\" value=\"add\" name=\"add\"></input>");
			sb.Append("<input type=\"button\" value=\"remove\" name=\"remove\"></input>");
			sb.Append("</td><td></td></tr>");
*/
			sb.Append("</table>");


			this.content.Text = sb.ToString();		
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\environment_cfg_existing.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using Xonwatch;
    
    
    namespace Xonwatch
    {
    /// <summary>
    /// Summary description for environment_cfg_existing.
    /// </summary>
    public class environment_cfg_existing : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Table  Table1;
    
        private void Page_Load(object sender, System.EventArgs e)
        {
            StringBuilder sb = new StringBuilder();
    
            string envID = Page.Request.QueryString["env"].ToString();
    
            Xonwatch.Environment en = XonWatchSvc.GetEnvironmentByID(envID, this.Context);
    
            
            SortedList sl = en.scripts;
            IDictionaryEnumerator ideScripts = en.Scripts;
            while (ideScripts.MoveNext())
            {
                Xonwatch.Script s = (Xonwatch.Script)ideScripts.Value;
    
                Xonwatch.RunScriptStatus rs = (Xonwatch.RunScriptStatus) Page.LoadControl("script_status.ascx");
    
                rs.ScriptID = s.ID.ToString();
                rs.EnvID    = envID.ToString();
                rs.ctxt     = this.Context;
    
    
                TableRow  tRow  = new TableRow();
                TableCell tCell = new TableCell();
                
                Table1.Rows.Add(tRow);
                tRow.Cells.Add(tCell);
    
                tCell.BorderWidth = 1;
                tCell.Controls.Add(rs);
    
            }
        }
    
    
    
    
        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
        
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);
    
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\errors.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for errata.
	/// </summary>
	public class errors : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\environment_clients.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using Xonwatch;
    
    
    namespace Xonwatch
    {
    /// <summary>
    /// Summary description for environment_clients.
    /// </summary>
    public class environment_clients : System.Web.UI.Page
    {
        protected System.Web.UI.WebControls.Table  clientlist;

    
        private void Page_Load(object sender, System.EventArgs e)
        {
            string envID = Page.Request.QueryString["env"].ToString();
            


            // Now load up the client list on the left frame 
            SortedList allClients = XonWatchSvc.GetClients(this.Context);

            clientlist.CellSpacing = 5;

            foreach (Client c in allClients.Values)
            {
                if (clientlist.Rows.Count == 0)
                {
                    TableRow  tr = new TableRow();
                    TableCell tc = new TableCell();
                    Literal   lt = new Literal();

                    clientlist.Rows.Add(tr);
                    tr.Cells.Add(tc);
                    tc.Controls.Add(lt);
                    tc.HorizontalAlign = HorizontalAlign.Center;
                    tc.VerticalAlign   = VerticalAlign.Middle;

                    lt.Text = "Clients";
                }


                if (c.EnvironmentID.ToString() == envID)
                {
                    TableRow  tr = new TableRow();
                    TableCell tc = new TableCell();
                    Literal   lt = new Literal();
    
                    clientlist.Rows.Add(tr);
                    tr.Cells.Add(tc);
                    tc.Controls.Add(lt);
                    tc.HorizontalAlign = HorizontalAlign.Center;
                    tc.VerticalAlign   = VerticalAlign.Middle;

                    lt.Text = c.DisplayHTML;
                }
            }

        }
    
    
        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
        
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);
    
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\environment_results.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for environment_log.
	/// </summary>
	public class environment_log : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			string envid = Request.QueryString["env"].ToString();
			string scriptid = "all";

			try
			{
				scriptid = Request.QueryString["script"].ToString();
			}
			catch
			{
			}

			XonWatchDB db = (XonWatchDB)Application["DB"];
			DataTable t = db.ResultsForEnvironmentGet(Convert.ToInt32(envid),1000);

			StringBuilder sb = new StringBuilder();
			sb.Append(@"<table width=""800""><tr><td>TIME</td><td>SCRIPT</td><td>HRESULT</td><td>MESSAGE</td></tr>");
			
			foreach (DataRow r in t.Rows)
			{
				sb.Append(@"<tr><td>");
				sb.Append(r["dt_logged"].ToString());
				sb.Append(@"</td><td>");
				sb.Append(r["i_script"].ToString());
				sb.Append(@"</td><td>");
				sb.Append(r["i_hresult"].ToString());
				sb.Append(@"</td><td>");
				sb.Append(r["vc_message"].ToString());
				sb.Append(@"</td></tr>");
			}

			sb.Append("</table>");

			content.Text = sb.ToString();
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void tblog_TextChanged(object sender, System.EventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\environment_cfg_new.aspx.cs ===
using System;
using System.IO;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;


namespace Xonwatch
{
	/// <summary>
	/// Summary description for environment_cfg_new.
	/// </summary>
	public class environment_cfg_new : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
		protected System.Web.UI.WebControls.ListBox lbScripts;
		protected System.Web.UI.WebControls.Button btnStart;
        protected System.Web.UI.WebControls.Button ReloadScripts;
		protected System.Web.UI.WebControls.Label dbgtxt;
		protected System.Web.UI.WebControls.Label reason;
        protected System.Web.UI.WebControls.Label scriptExecReason;
        private static string ScriptExecError;
		
    protected System.Web.UI.WebControls.Table tbl;

		private void Page_Load(object sender, System.EventArgs e)
		{

//            dbgtxt.Text = dbgtxt.Text + "<br>-------------" + ((IsPostBack) ? "true" : "false") + "----------------<br>" + DateTime.Now.ToString() + ">> Page_Load:Start<br>";

            if (!IsPostBack)
			{
				string envID = Page.Request.QueryString["env"].ToString();
			
				SortedList scripts = XonWatchSvc.GetScripts(this.Context);

                string currentEnv = XonWatchSvc.GetCurrentEnvironment(this.Context);

				lbScripts.Items.Clear();
				foreach (Xonwatch.Script s in scripts.Values)
				{
                    if (currentEnv != "" && (s.RequiredEnvironment == currentEnv || s.RequiredEnvironment == "all"))
                    {
                        lbScripts.Items.Add(s.Name);
                        lbScripts.SelectedValue = s.Name;
                    }
				}
			}

            ConfigureClientSelector();
            ControlStartButton();

//            dbgtxt.Text = dbgtxt.Text + "<br>" + DateTime.Now.ToString() + ">> Page_Load:Exit<br>-----------------------------<br> ";
		}



		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.btnStart.Click                 += new System.EventHandler(this.btnStart_Click);
			this.Load                           += new System.EventHandler(this.Page_Load);
            this.ReloadScripts.Click             += new System.EventHandler(this.ScriptReload_Click);
		}
		#endregion

        private void ScriptReload_Click(object sender, System.EventArgs e)
        {
            XonWatchSvc.SetReloadScripts(this.Context, true);
            
            string envID = Page.Request.QueryString["env"].ToString();
            
            Environment env = XonWatchSvc.GetEnvironmentByID(envID, this.Context);

            while (XonWatchSvc.GetReloadScripts(this.Context))
            {
                System.Threading.Thread.Sleep(1); //Wait for scripts to be updated before loading the scripts
            }

            ClientScript.RegisterStartupScript(typeof(Page), "RefreshParent", "<scrip tlanguage='javascript'>RefreshParent()</script>");

            Response.Redirect(this.Request.RawUrl);
        }

        private void btnStart_Click(object sender, System.EventArgs e)
        {
//            dbgtxt.Text = dbgtxt.Text + "<br>-----------------------------<br>" + DateTime.Now.ToString() + ">> btnStart_Click:Start<br>";
            XonWatchSvc.SetReloadScripts(this.Context, true);
            Hashtable runclients = new Hashtable();
            SortedList allClients = XonWatchSvc.GetClients(this.Context);
            System.Collections.Generic.List<string> ClientToDisengage = new System.Collections.Generic.List<string>();

            // Loop through the table of client selection controls and find out what values have
            // been selected for each of the script's client roles and build a SortedList of the 
            // corresponding Client objects for assignment to the script
            // 
            bool fSkip = true;
            foreach (TableRow tr in tbl.Rows)
            {
                if (fSkip)
                {
                    fSkip = false;
                    continue;
                }

                // Cell[0] = Script role
                // Cell[1] = Platform
                // Cell[2] = Selector DropDownList control where Item=client name and Value=client IP
                //
                
                Literal      lRole = (Literal) tr.Cells[0].Controls[0];
                Literal      lPlat = (Literal) tr.Cells[0].Controls[0];
                DropDownList ddl   = (DropDownList) tr.Cells[2].Controls[0];

                foreach(Client c in allClients.Values)
                {
                    if (c.Name == ddl.SelectedItem.Text)
                    {
                        ClientToDisengage.Add(c.Name);

                        dbgtxt.Text = dbgtxt.Text + "Matched client>" + ddl.SelectedItem.Text + " to role " + lRole.Text + "<br>";
                        
                        if (!c.EngageClient(lRole.Text))
                        {
                            dbgtxt.Text = dbgtxt.Text + "Client failed to engage!>" + ddl.SelectedItem.Text + " to role " + lRole.Text + "<br>";
                            // $REVIEW (michion): What to do?
                        }

                        runclients[lRole.Text] = c;
                        break;
                    }
                }
            }


            string envID = Page.Request.QueryString["env"].ToString();

            Environment en = XonWatchSvc.GetEnvironmentByID(envID,this.Context);

            while (XonWatchSvc.GetReloadScripts(this.Context))
            {
                System.Threading.Thread.Sleep(1); //Wait for scripts to be updated before loading the scripts
            }
    
            SortedList scripts = XonWatchSvc.GetScripts(this.Context);

            XonWatchDB db = (XonWatchDB)Application["DB"];
            string Net;
            string xmacsAddr;
            string sgfdAddr;
            db.NetworkGet(Convert.ToInt32(en.NetworkID), out Net, out xmacsAddr, out sgfdAddr);
            ScriptExecError = "";
            foreach (Xonwatch.Script s in scripts.Values)
            {
                if (s.Name == lbScripts.SelectedValue)
                {
                    if (!en.ExecuteScript(s, runclients, Net))
                    {
                        foreach (Client c in allClients.Values)
                        {
                            foreach (string client in ClientToDisengage)
                            {
                                if( client == c.Name )
                                    c.DisengageClient();
                            }
                        }

                        ScriptExecError = s.Name + " script cannot be executed in the " + en.Name + " environment";
                    }
                    Response.Redirect(this.Request.RawUrl);
                }
            }

//            dbgtxt.Text = dbgtxt.Text + "<br>" + DateTime.Now.ToString() + ">> btnStart_Click:Exit<br>-----------------------------<br> ";
        }





		private void ddlClient_SelectedIndexChanged(object sender, System.EventArgs e)
		{
//            dbgtxt.Text = dbgtxt.Text + "<br>-----------------------------<br>" + DateTime.Now.ToString() + ">> ddlClient_SelectedIndexChanged:Start<br>";

            DropDownList ddl =  (DropDownList) sender;

            ControlStartButton();

//            dbgtxt.Text = dbgtxt.Text + "<br>" + DateTime.Now.ToString() + ">> ddlClient_SelectedIndexChanged:Exit<br>-----------------------------<br> ";
		}




		private void ControlStartButton()
		{
            bool    enable = true;
            string  txt = "";

            Hashtable h = new Hashtable();
    
            bool fSkip = true;

            foreach (TableRow tr in tbl.Rows)
            {
                if (fSkip)
                {
                    fSkip = false;
                    continue;
                }

                Literal l1 = (Literal) tr.Cells[0].Controls[0];
                Literal l2 =  (Literal) tr.Cells[1].Controls[0];
                DropDownList ddl = (DropDownList) tr.Cells[2].Controls[0];

                if (ddl.Items.Count > 0)
                {
                    if (h.Contains(ddl.SelectedItem.Text))
                    {
                        txt += "Client " + ddl.SelectedItem.Text + " is assigned to multiple roles<br>";
                        enable = false;
                    }
                    else
                    {
                        h.Add(ddl.SelectedItem.Text, ddl.SelectedValue);
                    }
    
                    
                    Client c = XonWatchSvc.GetClientByIP(ddl.SelectedValue, this.Context);
    
                    if (c.Engaged)
                    {
// $REVIEW (michion): can we get tne name of the script the client is running?
//                        txt += "Client " + ddl.SelectedItem.Text + " is already engaged as " + c.InScriptID + " in script<br>";
                        txt += "Client " + ddl.SelectedItem.Text + " is already engaged in a script<br>";
                        enable = false;
                    }
    
                    if (!c.RecvSocket || !c.SendSocket)
                    {
                        txt += "Client " + ddl.SelectedItem.Text + " is OFFLINE<br>";
                        enable = false;
                    }
                }
                else
                {
                    txt += "Environment has no defined clients of type " + l2.Text+ "<br>";
                    enable = false;
                }

            }

            reason.Text      = txt;
            scriptExecReason.Text = ScriptExecError;
            btnStart.Enabled = enable;

		}


		private void ConfigureClientSelector()
		{
            int sIter = 0;

            string envID = Page.Request.QueryString["env"].ToString();
         
            SortedList scripts = XonWatchSvc.GetScripts(this.Context);

			foreach (Xonwatch.Script s in scripts.Values)
			{
                int cIter = 0;

                sIter++;

				if (s.Name == lbScripts.SelectedValue)
				{
                    SortedList allClients = XonWatchSvc.GetClients(this.Context);
    
                    TableRow tr = new TableRow();
                    tbl.Rows.Add(tr);

                    TableCell tc = new TableCell();
                    tc.BorderWidth = 1;
                    tc.HorizontalAlign = HorizontalAlign.Center;
                    tr.Cells.Add(tc);

                    Literal lt = new Literal();
                    tc.Controls.Add(lt);

                    lt.Text = "Script Role";
                    
                    //------------------
                    tc = new TableCell();
                    tc.BorderWidth = 1;
                    tc.HorizontalAlign = HorizontalAlign.Center;
                    tr.Cells.Add(tc);

                    lt = new Literal();
                    tc.Controls.Add(lt);

                    lt.Text = "Platform";
                    
                    //------------------
                    tc = new TableCell();
                    tc.BorderWidth = 1;
                    tc.HorizontalAlign = HorizontalAlign.Center;
                    tr.Cells.Add(tc);

                    lt = new Literal();
                    tc.Controls.Add(lt);

                    lt.Text = "Clients";
                    
                    foreach (DictionaryEntry de in s.ClientsNeeded)
                    {
                        cIter++;

                        tr = new TableRow();
                        tbl.Rows.Add(tr);


                        //------------------
                        tc = new TableCell();
                        tc.BorderWidth = 1;
                        tc.HorizontalAlign = HorizontalAlign.Center;
                        tr.Cells.Add(tc);

                        lt = new Literal();
                        tc.Controls.Add(lt);
                        
                        lt.Text = de.Key.ToString();


                        //------------------
                        tc = new TableCell();
                        tc.BorderWidth = 1;
                        tc.HorizontalAlign = HorizontalAlign.Center;
                        tr.Cells.Add(tc);

                        lt = new Literal();
                        tc.Controls.Add(lt);
                        
                        lt.Text = de.Value.ToString();
                        

                        //------------------
                        tc = new TableCell();
                        tc.BorderWidth = 1;
                        tr.Cells.Add(tc);

                        DropDownList ddl = new DropDownList();
                        ddl.ID = de.Key.ToString();
                        ddl.SelectedIndexChanged += new System.EventHandler(ddlClient_SelectedIndexChanged);
                        ddl.AutoPostBack = true;
                        ddl.Width = 150;
                        tc.Controls.Add(ddl);
                        

                        // This is tricky, but we need to Clear() the DropDownList _after_ 
                        // we add it to the table cell.  When the DDL is added, the viewstate 
                        // will be restored to include the elements that were in the DDL in 
                        // that cell previously.

                        ddl.Items.Clear();

                        int ctr = 0;
                        int tot = allClients.Count;

                        foreach (Client client in allClients.Values)
                        {
                            ctr++;

                            if (client.EnvironmentID.ToString() == envID && client.Platform == (string)de.Value)
                            {
                                ListItem li = new ListItem();
        
                                li.Text  = client.Name;
                                li.Value = client.IPAddress;
                                
                                if (!ddl.Items.Contains(li))
                                {
                                    ddl.Items.Add(li);
                                }
                                else
                                {
                                }

                            }

                        } // foreach
                    } // foreach
                } // if 
            } // foreach
		}
 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\script_edit.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for script_edit.
	/// </summary>
	public class script_edit : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Literal content;
		protected System.Web.UI.WebControls.ListBox lbScripts;

		string SelectedScript;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			SelectedScript = lbScripts.SelectedValue;

			StringBuilder sb = new StringBuilder();
			int scriptid = 0;

			if (!IsPostBack)
			{
				try
				{
					scriptid = Convert.ToInt32(Page.Request.QueryString["scriptid"].ToString());
				}
				catch
				{
				}
			
				SortedList scripts = XonWatchSvc.GetScripts(this.Context);

				foreach (Xonwatch.Script s in scripts.Values)
				{
					lbScripts.Items.Add(s.Name);
					lbScripts.SelectedValue = s.Name;
				}

				sb.Append(@"<iframe id=""script"" src=""script_fulltext.aspx?scriptid=""" + scriptid + @""" ");
			}

			content.Text = sb.ToString();
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.lbScripts.SelectedIndexChanged += new System.EventHandler(this.lbScripts_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void lbScripts_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			Response.Redirect("script.aspx?scriptid=" + SelectedScript);
		}

		private void btnSubmit_Click(object sender, System.EventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\errors_details.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for errata_details.
	/// </summary>
	public class errors_details : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;
using System.Configuration;

namespace Xonwatch 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

			// extract settings from web.config....
			string ipAddress = ConfigurationManager.AppSettings["ServiceIP"].ToString();
			int port         = Convert.ToInt32(ConfigurationManager.AppSettings["ServicePort"].ToString());
			string dbserver  = ConfigurationManager.AppSettings["DBServer"].ToString();
			string dbname    = ConfigurationManager.AppSettings["DBName"].ToString(); 

			string connectionstr =  "data source=" + dbserver + 
				";initial catalog=" + dbname + 
				";integrated security=SSPI;" + 
				"Packet Size=16384"; 
					
			// ... and repackage them into the Application collection    $REVIEW (michion): ummm, why? 
			Application["XonWatchRemoting"] = new XonWatchSvc(ipAddress, port);
			Application["ServiceIP"]        = ipAddress;
			Application["ServicePort"]      = port.ToString();   // $REVIEW (michion): this "new XonWatchSvc(ipAddress, port);" doesn't look right to me.  Since no one references it, I'm going to fix it
			Application["DBServer"]         = dbserver;
			Application["DBName"]           = dbname;

			XonWatchDB db = new XonWatchDB(connectionstr, null);
			Application["DB"] = db;

			//load the collections in the remoting object
			XonWatchSvc svc = (XonWatchSvc)(Application["XonWatchRemoting"]);
		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{
		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{
		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{
		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\script_fulltext.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for script_fulltext.
	/// </summary>
	public class script_fulltext : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.TextBox txtScript;
		protected System.Web.UI.WebControls.Button btnUpdate;
		public StringBuilder sb;
		public int scriptid;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			scriptid = 1;
			string scriptname = string.Empty;;
			string scripttext = string.Empty;

			if (!IsPostBack)
			{
				
				try
				{
					scriptid = Convert.ToInt32(Page.Request.QueryString["scriptid"].ToString());
				}
				catch
				{
		
				}

				XonWatchDB db = (XonWatchDB)Application["DB"];
				db.ScriptGet(scriptid, out scriptname, out scripttext);

				txtScript.Text = scripttext;
			}
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.txtScript.TextChanged += new System.EventHandler(this.txtScript_TextChanged);
			this.btnUpdate.Click += new System.EventHandler(this.btnUpdate_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void txtScript_TextChanged(object sender, System.EventArgs e)
		{

		}

		private void btnUpdate_Click(object sender, System.EventArgs e)
		{
			string script = Request.Form["txtScript"].ToString();
			XonWatchDB db = (XonWatchDB)Application["DB"];
			db.ScriptSet(scriptid, script);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\management.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace XonWatch
{
	/// <summary>
	/// Summary description for management.
	/// </summary>
	public class management : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Button btnEditScript;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.btnEditScript.Click += new System.EventHandler(this.btnEditScript_Click);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void btnEditScript_Click(object sender, System.EventArgs e)
		{
			Response.Redirect("script_edit.aspx");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\script_status.ascx.cs ===
using System;
using System.Text;
using System.Data;
using System.Configuration;
using System.Collections;
 


namespace Xonwatch
{
    	/// <summary>
    public partial class RunScriptStatus : System.Web.UI.UserControl
    {
    

		protected System.Web.UI.WebControls.Label         script_id;
        protected System.Web.UI.WebControls.Label         script_name;
		protected System.Web.UI.WebControls.Label         script_uptime;
		protected System.Web.UI.WebControls.Label         script_ecount;
		protected System.Web.UI.WebControls.Label         script_elast;
		protected System.Web.UI.WebControls.Label         script_passes;
		protected System.Web.UI.WebControls.Label         script_clients;

//        protected System.Web.UI.WebControls.LinkButton      script_clients;
        protected System.Web.UI.WebControls.Button          script_reset;
        protected System.Web.UI.WebControls.Button          script_pause;
        protected System.Web.UI.WebControls.Button          script_resume;
        protected System.Web.UI.WebControls.Button          script_abort;
        
        public System.Web.HttpContext                       ctxt;

        private string              title;
        public string Title
        {
            get {return title;}
            set {title = value;}
        }
    
    
        private string                 scriptID;
        public string ScriptID
        {
            get {return scriptID;}
            set {scriptID = value;}
        }
    
        private string                 envID;
        public string EnvID
        {
            get {return envID;}
            set {envID = value;}
        }
    
    
        private string              name;
        public string Name
        {
            get {return name;}
            set {name = value;}
        }
    
    
    
        private string              clients;
        public string Clients
        {
            get {return clients;}
            set {clients = value;}
        }
    
    
    
        private Xonwatch.Script              s;
        public Xonwatch.Script S
        {
            get {return s;}
            set {s = value;}
        }
    
    
    
    
        protected void Page_Load(object sender, System.EventArgs e)
        {
    		Xonwatch.Script s =  XonWatchSvc.GetEnvironmentScriptByID(EnvID, ScriptID, ctxt);
            
            if (s != null)
            {
                script_id.Text          =  s.ID.ToString();
                script_name.Text        =  s.Name.ToString();

                script_uptime.Text      =  s.RunUptime;
                script_ecount.Text      =  s.RunErrors.ToString() + " / " + s.StatCmdsIssued.ToString();
                script_elast.Text       =  s.RunErrorTime;
                script_elast.ToolTip    =  "Failed command: " + s.RunErrorCmd;

                script_passes.Text      =  s.RunPass.ToString();
                script_passes.ToolTip   =  s.RunErrors.ToString() + " errors out of " + s.RunPass.ToString() + " passes";


                StringBuilder sb = new StringBuilder();

                foreach (DictionaryEntry de in s.Clients)
                {
                    Client c = (Client)de.Value;

                    if (sb.Length > 0)
                        sb.Append("  ");

                    sb.Append(c.DisplayHTML);
                }

                script_clients.Text     =  sb.ToString();

                if (s.IsPaused)
                {
                    script_pause.Enabled  = false;
                    script_reset.Enabled  = false;
                    script_resume.Enabled = true;
                }
                else
                {
                    script_pause.Enabled  = true;
                    script_reset.Enabled  = true;
                    script_resume.Enabled = false;
                }

            }
    
        }
    
        protected void script_reset_Click(object sender, System.EventArgs e)
        {
    		Xonwatch.Script s =  XonWatchSvc.GetEnvironmentScriptByID(EnvID, ScriptID, ctxt);

            if (s != null)
            {
                s.SignalReset();
            }
        }
    
        protected void script_pause_Click(object sender, System.EventArgs e)
        {
    		Xonwatch.Script s =  XonWatchSvc.GetEnvironmentScriptByID(EnvID, ScriptID, ctxt);

            if (s != null)
            {
                s.SignalPause();
            }
        }
    
        protected void script_resume_Click(object sender, System.EventArgs e)
        {
    		Xonwatch.Script s =  XonWatchSvc.GetEnvironmentScriptByID(EnvID, ScriptID, ctxt);

            if (s != null)
            {
                s.SignalResume();
            }
        }
    
        protected void script_abort_Click(object sender, System.EventArgs e)
        {
    		Xonwatch.Script s =  XonWatchSvc.GetEnvironmentScriptByID(EnvID, ScriptID, ctxt);

            if (s != null)
            {
                s.SignalAbort();
            }
        }
    
    

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\XonWatchSvc.cs ===
using System;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Channels.Tcp;
using System.Runtime;
using System.Web;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for XonWatchSvc.
	/// </summary>
	public class XonWatchSvc
	{
		public XonWatchRemoting RemoteData;

		public XonWatchSvc(string ipAddress, int port)
		{
			try
			{
				BinaryClientFormatterSinkProvider clntFormatter = new BinaryClientFormatterSinkProvider();

				HttpClientChannel h = new HttpClientChannel("XonWatchChannel", clntFormatter);
				ChannelServices.RegisterChannel(h, false);
				RemoteData = (XonWatchRemoting)Activator.GetObject(typeof(XonWatchRemoting), "http://" + ipAddress + ":" + port.ToString() + "/XonWatchRemoting");
			}
			catch 
			{
				//log error
			}
		}

        public static SortedList GetEnvironments(HttpContext context)
		{
			return (SortedList)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.Environments);
		}

		public static SortedList GetClients(HttpContext context)
		{
			return (SortedList)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.Clients);
		}

		public static SortedList GetScripts(HttpContext context)
		{
			return (SortedList)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.Scripts);
		}

		public static SortedList GetNetworks(HttpContext context)
		{
			return (SortedList)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.Networks);
		}

		public static SortedList GetTestTypes(HttpContext context)
		{
			return (SortedList)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.TestTypes);
		}

		public static Information GetInformation(HttpContext context)
		{
			return (Information)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.Info);
		}

        public static void SetReloadScripts(HttpContext context, bool reload)
        {
            ((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.ReloadScripts = reload;
        }

        public static void SetCurrentEnvironment(HttpContext context, string currentEnv)
        {
            ((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.CurrentEnvironment = currentEnv;
        }

        public static string GetCurrentEnvironment(HttpContext context)
        {
            return (string)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.CurrentEnvironment);
        }

        public static bool GetReloadScripts(HttpContext context)
        {
            return (bool)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.ReloadScripts);
        }

		//utility functions for UI
		public static Client GetClientByIP(string ip, HttpContext context)
		{
			SortedList Clients = GetClients(context);
			foreach (Client c in Clients.Values)
			{
				if (c.IPAddress == ip)
				{
					return c;
				}
			}
			return null;
		}

		public static Environment GetEnvironmentByClientIP(string ip, HttpContext context)
		{
			SortedList Clients = GetClients(context);
			foreach (Client c in Clients.Values)
			{
				if (c.IPAddress == ip)
				{
					SortedList Environments = GetEnvironments(context);
					foreach (Environment env in Environments.Values)
					{
						if (c.EnvironmentID == env.ID)
						{
							return env;
						}
					}
				}
			}
			return null;
		}


		public static Environment GetEnvironmentByName(string name, HttpContext context)
		{
			SortedList Environments = GetEnvironments(context);
			foreach (Environment env in Environments.Values)
			{
				if (env.Name == name)
				{
					return env;
				}
			}
			return null;
		}

		public static Environment GetEnvironmentByID(string id, HttpContext context)
		{
			SortedList Environments = GetEnvironments(context);
			foreach (Environment env in Environments.Values)
			{
				if (env.ID == Convert.ToInt32(id))
				{
					return env;
				}
			}
			return null;
		}

		public static Script GetEnvironmentScriptByID(string envid, string scriptid, HttpContext context)
		{
			Environment thisenv = XonWatchSvc.GetEnvironmentByID(envid, context);
			IDictionaryEnumerator inm = thisenv.Scripts; 

			while (inm.MoveNext())
			{
				Script script = (Script)inm.Value;
				if (script.ID == Convert.ToInt32(scriptid))
				{
					return script;
				}
			}
			return null;
		}


        public static ICollection GetAllRunningScripts(HttpContext context) 
        {
            SortedList l = (SortedList)(((XonWatchSvc)context.Application["XonWatchRemoting"]).RemoteData.Scripts);

			return l;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Client.cs ===
using System;
using System.Text;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for XBox Client.
	/// </summary>
	//[Serializable]
	public class Client : MarshalByRefObject
	{
		int id;
		string inscriptid;  // NOT the ID of the script, but the ID of the _client_ in the context of the script)
		string inscriptrole;  // NOT the ID of the script, but the ID of the _client_ in the context of the script)
		string platform;
		string ipaddress;
		string name;
		int environmentid;
//		bool engaged;
		bool failing;
		DateTime inited;
		bool recvsocket;
		bool sendsocket;
        string m_Status;
		//private XonWatchLog log;

		//log info
		DateTime lastupdate;

		private Client(){} 

		public Client(int _id, string _platform, string _idaddress, string _name, int _environmentid)
		{
			id              = _id;
            inscriptid      = null;         // indicates an un-engaged client
			platform        = _platform;
			ipaddress       = _idaddress;
			name            = _name;
			environmentid   = _environmentid;
			//engaged         = _engaged;
			inited          = DateTime.Now;
		}

		public int ID
		{
			get
			{
				return id;
			}
		}

		public string Platform
		{
			get
			{
				return platform;
			}
		}

		public string IPAddress
		{
			get
			{
				return ipaddress;
			}
		}

		public string Name
		{
			get
			{
				return name;
			}
		}

		public string InScriptID
		{
			get
			{
				return inscriptid;
			}
			set
			{
				inscriptid = value;
			}
		}

		public string InScriptRole
		{
			get
			{
				return inscriptrole;
			}
			set
			{
				inscriptrole = value;
			}
		}

		public int EnvironmentID
		{
			get
			{
				return environmentid;
			}
			set
			{
				environmentid = value;
			}
		}

		public bool RecvSocket
		{
			get
			{
				return recvsocket;
			}
			set
			{
				recvsocket = value;
			}
		}

		
		public bool SendSocket
		{
			get
			{
				return sendsocket;
			}
			set
			{
				sendsocket = value;
			}
		}


		public bool Engaged
		{
			get
			{
                return (InScriptID == null) ? false : true;
			}
		}

		public bool Failing
		{
			get
			{
				return failing;
			}
			set
			{
				failing = value;
			}
		}

        public string Status
        {
            get { return m_Status; }
            set { m_Status = value; }
        }

		public DateTime StartTime
		{
			get 
			{
				return this.inited;
			}
		}

		public TimeSpan UpTime
		{
			get 
			{
				return DateTime.Now - this.inited;
			}
		}

		public DateTime LastUpdate
		{
			get 
			{
				return lastupdate;
			}
			set
			{
				lastupdate = value;
			}
		}


		public bool EngageClient(string id)
		{
            if (InScriptID == null)
            {
                InScriptID = id;
                return true;
            }
            else
            {
                return false;
            }
        }


		public bool DisengageClient()
		{
            if (InScriptID == null)
            {
                return false;
            }
            else
            {
                InScriptID = null;
                return true;
            }
        }

        public void UpdateStatus()
        {
            if (Engaged)
            {
                if (RecvSocket && SendSocket)
                {
                    Status = "engaged";
                }
                else
                {
                    Status = "failing";
                }
            }
            else
            {
                if (RecvSocket && SendSocket)
                {
                    Status = "online";
                }
                else
                {
                    Status = "offline";
                }
            }
        }
        
		public string DisplayHTML
		{
			get 
			{
                String strStyle;
                String strStatus;

                StringBuilder sb = new StringBuilder();


                if (Engaged)
                {
                    if (RecvSocket && SendSocket)
                    {
                        strStatus = "engaged";
                        strStyle  = "clientrun";
                        Status = "engaged";
                    }
                    else
                    {
                        strStatus = "failing";
                        strStyle  = "clientfail";
                        Status = "failing";
                    }
                }
                else
                {
                    if (RecvSocket && SendSocket)
                    {
                        strStatus = "online";
                        strStyle  = "clientup";
                        Status = "online";
                    }
                    else
                    {
                        strStatus = "offline";
                        strStyle  = "clientdown";
                        Status = "offline";
                    }
                }


                sb.Append("<span class='");
                sb.Append(strStyle);
                sb.Append("' title='IP: ");
                sb.Append(IPAddress.ToString());
                sb.Append("\nStatus: ");
                sb.Append(strStatus);
                sb.Append("\nPlatform: ");
                sb.Append(Platform);

                // $REVIEW (michion):  This bites, but sockets and clients aren't cleanly linked, so getting
                //                     the DateTime of last incoming traffic isn't simple
                //sb.Append("\nLast Contact: ");                
                //sb.Append(LastUpdate.ToString());
                sb.Append("'>");

                sb.Append(Name);

                sb.Append("</span>");

				return sb.ToString();
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\browser\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:29:00 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Command.cs ===
using System;
using System.Collections;

namespace Xonwatch
{
	/// <summary>
	/// Summary description for XonwatchCommand.
	/// </summary>
	//[Serializable]
	public class XonWatchCommand : MarshalByRefObject
	{
		string name;
        Queue parameters;
		string target;
		int ivalue;
		int timeout;
		int retryCount;
		int retryAttempt;
		int retryDelay;

		bool fWaitTimer;
		bool fResult;
		DateTime tLastExecuted;

		//private XonWatchLog log;

		public XonWatchCommand()
		{
			name         = string.Empty;
            target       = string.Empty;
			parameters   = new Queue();
			ivalue       = 0;
            timeout      = 0;    // zero indicates a default timeout should be enforced
            retryAttempt = 0;    // indicates the current retry attempt being made (for a 'live' command object)
            retryCount   = 0;    // zero indicates that no retries are allowed in the event of an error
            retryDelay   = 0;    // number of seconds to pause between command error and a retry
            fWaitTimer   = false;
		}

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}


		public Queue Parameters
		{
			get
			{
				return parameters;
			}
		}

		public void AddParameter(ScriptCommandParameter param)
		{
			parameters.Enqueue(param);
		}
 

		public DateTime LastExecuted
		{
			get
			{
				return tLastExecuted;
			}
			set
			{
				tLastExecuted = value;
			}
		}

		public bool WaitTimer
		{
			get
			{
				return fWaitTimer;
			}
			set
			{
				fWaitTimer = value;
			}
		}

		public string Target
		{
			get
			{
				return target;
			}
			set
			{
				target = value;
			}
		}

		public int IValue
		{
			get
			{
				return ivalue;
			}
			set
			{
				ivalue = value;
			}
		}

		public int Timeout
		{
			get
			{
				return timeout;
			}
			set
			{
				timeout = value;
			}
		}

		public int RetryCount
		{
			get
			{
				return retryCount;
			}
			set
			{
				retryCount = value;
			}
		}

		public int RetryAttempt
		{
			get
			{
				return retryAttempt;
			}
			set
			{
				retryAttempt = value;
			}
		}

		public int RetryDelay
		{
			get
			{
				return retryDelay;
			}
			set
			{
				retryDelay = value;
			}
		}


        
        /* FCommandSuccess
         * ------------------------------------
         * This method is used to intrpret the result string that is returned
         * from the client and determine whether the command was successfully
         * executed or not.  Currently the client commands only return
         * the string 'success' and 'failed', so this is a simple check, but
         * by isolating this logic in a method, we can support future
         * possibilities where other return strings might be decipherable.
         *
         * Parameters:  
         *
         *
        */
        public bool FCommandSuccess(string result)
        {
            fResult =  (result.ToUpper() == "FAILURE") ? false : true;
    
            return FCommandSuccess();
        }
    
        public bool FCommandSuccess()
        {
            return fResult;
        }
    
    
        public bool FSaveResponseData()
        {
            // Our current convention is to only save the response data
            // (for use in subsequent command substitution) if the command
            // was successful
    
            return FCommandSuccess();
        }
 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Information.cs ===
using System;

namespace Xonwatch
{
    /// <summary>
    /// class holds test statistics
    /// </summary>
    //[Serializable]
    public class Information : MarshalByRefObject
    {

        private DateTime svcstart;
        private TimeSpan uptime;

        //private XonWatchLog log;

        public Information()
        {
            svcstart = DateTime.Now;
            uptime = DateTime.Now - DateTime.Now;
        }

        public DateTime ServiceStart
        {
            get
            {
                return svcstart;
            }
        }

        public TimeSpan UpTime
        {
            get
            {
                return uptime;
            }
            set
            {
                uptime = value;
            }
        }

        //methods for retrieving formatted log results
        public string GetLogInfo(int clientid)
        {
            return string.Empty;
        }

    }

    [Serializable]
    ///
    ///test types are usually just named by service
    ///e.g., presence, matchmaking, stats, storage
    ///
    public class TestType
    {
        public int id;
        public string name;
        public int tests;
        public int fails;

        public TestType()
        {
            id    = 0;
            name  = string.Empty;
            tests = 0;
            fails = 0;
        }

        public TestType(int _id, string _name)
        {
            id    = _id;
            name  = _name;
            tests = 0;
            fails = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Environment.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Threading;

namespace Xonwatch
{
    /// <summary>
    /// Summary description for Environment.
    /// </summary>
    //[Serializable]
    public class Environment : MarshalByRefObject
    {
        private int id;
        private string networkid;
        private string location;
        private string name;
        private string serviceip;
        private bool alert;

        public SortedList scripts;
        private Queue outgoingmessages;
        private Queue incomingmessages;
        private XonWatchLog log;

        private Environment(){}

        public Environment(int _id, string _name, string _networkid, string _location, string _useraccounts, string _serviceip)
        {
            scripts = new SortedList();
            outgoingmessages = new Queue();
            incomingmessages = new Queue();

            id              = _id;
            name            = _name;
            networkid       = _networkid;
            location        = _location;
            string [] users = _useraccounts.Split(',');


            serviceip = _serviceip;
            alert = false;

            log  = XonWatchRemoting.Log;
        }

        public int ID
        {
            get
            {
                return id;
            }
        }

        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }

        public string NetworkID
        {
            get
            {
                return networkid;
            }
        }

        public string Location
        {
            get
            {
                return location;
            }
        }

        public string ServiceIP
        {
            get
            {
                return serviceip;
            }
        }


        public bool Alert
        {
            get
            {
                return alert;
            }
            set
            {
                alert = value;
            }
        }

        public IDictionaryEnumerator Scripts
        {
            get
            {
                return scripts.GetEnumerator();
            }
        }



        public void ClearScripts()
        {
            scripts.Clear();
        }

        public void AddScript(int scriptID, Script script)
        {
            scripts.Add(scriptID, script);
        }

        public void RemoveScript(int scriptID)
        {
            scripts.Remove(scriptID);
        }


        //used by the message distributor
        public XonWatchMessage GetNextOutgoingMessage()
        {
            if (outgoingmessages.Count != 0)
            {
                return (XonWatchMessage)outgoingmessages.Dequeue();
            }
            else
            {
                return null;
            }
        }

        //used internally? if so, access queue directly
        public void SetNextOutgoingMessage(XonWatchMessage thisMessage)
        {
            outgoingmessages.Enqueue(thisMessage);
        }

        //used internally? if so, access queue directly
        public XonWatchMessage GetNextIncomingMessage()
        {
            if (outgoingmessages.Count != 0)
            {
                return (XonWatchMessage)incomingmessages.Dequeue();
            }
            else
            {
                return null;
            }

        }

        //used by message distributor
        public void SetNextIncomingMessage(XonWatchMessage thisMessage)
        {
            incomingmessages.Enqueue(thisMessage);
        }

        public void ProcessData()
        {
            ThreadPool.QueueUserWorkItem(new WaitCallback(ProcessDataLoop));
        }

        public void ProcessDataLoop(Object stateInfo)
        {
            //Main Execution Loop for an environment
            while (true)
            {
                Thread.Sleep(250);
                XonWatchMessage msg;

                try
                {
                    if (incomingmessages.Count != 0)
                    {
                        msg = (XonWatchMessage)incomingmessages.Dequeue();
                        ProcessMessage(msg);
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("ProcessMessage exception: " + e.Message.ToString());
                    //continue looping
                }
            }
        }




        public Script GetScriptByLastMessageID(int id)
        {
            StringBuilder sb = new StringBuilder();

            sb.Append("Searching " + id.ToString());

            foreach (Script script in this.scripts.Values)
            {
                sb.Append("|");
                sb.Append("Script " + script.ID);
                sb.Append(":");
                sb.Append("Msg " + script.LastMessageID);

                if (script.LastMessageID == id)
                {
                    return script;
                }
            }

            Eventing.WriteAppLogEvent(EventLogEntryType.Error, (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_MESSAGE_CORRELATION_NOT_FOUND), 0, "Search to correlate message failed:\n" + sb.ToString());

            return null;
        }



        public void ProcessMessage(XonWatchMessage msg)
        {
            //-----------------------------------------------------------------
            // We have a response from the client, so tag the script as being
            // ready for more processing.
            //-----------------------------------------------------------------
            // $REVIEW (michion): We should be insulated from racing issues
            // since incoming messages are queued, but raising the flag
            // immediately will allow the script to send the next command
            // to the client potentially before we finish recording the
            // results to the DB/file logs.
            //
            Script s = this.GetScriptByLastMessageID(msg.ID);

            if (s != null)
            {
                //-----------------------------------------------------------------
                // Parse and repackage the client response data and then log to
                // the DB/File
                //
                string details    = "";
                string strResult  = "";
                string strContext = "";
                string strHresult = "";
                string strElapsed = "";

                int hresult    = 0;
                int elapsed    = 0;

                foreach(DictionaryEntry e in msg.Params)
                {
                    switch(e.Key.ToString().ToUpper())
                    {
                        case "CONTEXT":
                            strContext = e.Value.ToString();
                            break;

                        case "RESULT":
                            strResult = e.Value.ToString();
                            break;

                        case "HRESULT":
                            strHresult = e.Value.ToString();
                            hresult = Convert.ToInt32(e.Value);
                            break;

                        case "ELAPSED":
                            strElapsed = e.Value.ToString();
                            elapsed = Convert.ToInt32(e.Value);
                            break;

                        default:
                            if (details.Length > 0)
                                details += "|";

                            details += e.Key.ToString() + "=" + e.Value.ToString();

                            break;
                    }

                }

                s.ProcessResponse(msg.Command, strContext, strResult, strHresult, strElapsed, details);

                log.WriteToResultsLog(msg.EnvID, s.TemplateID, msg.DestIP, msg.Command, strResult, hresult, elapsed, strContext, details );

            }
            else
            {
                Eventing.WriteAppLogEvent(EventLogEntryType.Warning, (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_MESSAGE_CORRELATION_NOT_FOUND_IN_RUNNING_SCRIPT), 0, "Ignoring message " + msg.ID + ":  Message could not be correlated to any scripts running in environment " + msg.EnvID + ".\n\n" + msg.FullText);
            }

        }

        public bool ExecuteScript(Script script, Hashtable clients, string Net)
        {
            bool retVal = true;
            if (Net + "_" + script.RequiredEnvironment == this.Name || script.RequiredEnvironment == "all")
            {
                Script newscript = script.MakeExecutableCopy();

                newscript.Clients = clients;
                newscript.ParseScriptXml(newscript.FullText);

                this.AddScript(newscript.ID, newscript);

                if (newscript.IsReady)
                {
                    newscript.Parent = this;
                    ThreadPool.QueueUserWorkItem(new WaitCallback(newscript.RunScript), (object)newscript);
                }
            }
            else
            {
                Eventing.WriteAppLogEvent(
                    EventLogEntryType.Error,
                    (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_ADD_FAILED),
                    0,
                    "Failed to add " + script.Name + " to " + this.Name + " environment.\n"
                    + (Net + "_" + script.RequiredEnvironment) + "Required.");

                retVal = false;
            }

            return retVal;
        }

        /* SendCommand
         * ------------------------------------
         * This is the enviroment level send method.  It's responsibility
         * is to queue the message object on the environment's outbound
         * message queue
         *
         *
         * Parameters:
         *
         *
        */
        public int SendCommand(string toIP, string command, ArrayList parameters)
        {
            XonWatchMessage x = new XonWatchMessage(ServiceIP, toIP, this.id, command, parameters);

            this.SetNextOutgoingMessage(x);

            return x.ID;        // each message will be marked with a counter based ID to allow it to be
                                // uniquely identified (and reassociated with an Enviroment upon reply
        }


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Log.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

namespace Xonwatch
{

    public class XonWatchLog
    {
        public const int CONSOLE = 1;
        public const int BASICLOG = 2;
        public const int RESULTLOG = 2;
        public const int MOM = 3;
        public const int FILE = 4;

        private int m_iLevel = BASICLOG;


        public int Level
        {
            get
            {
                return m_iLevel;
            }
            set
            {
                m_iLevel = value;
            }
        }

        public XonWatchDB DB;
        public LogFileMgr FF;

        public XonWatchLog()
        {
        }

        public XonWatchLog(XonWatchDB db)
        {
            DB = db;
            FF = new LogFileMgr(".\\logs");
        }

        public void WriteLine(int level, string sz)
        {
            switch (level)
            {
                case 1:
                    WriteToConsole(sz);
                    break;
                case 2:
                    WriteToBasicLog(sz);
                    break;
                case 3:
                    WriteToResultsLog(sz);
                    break;
                case 4:
                    WriteToMOM(sz);
                    break;
                case 5:
                    WriteToFile(sz);
                    break;
            }
        }

        public void WriteToConsole(string sz)
        {
            Console.WriteLine(sz);
        }

        public void WriteToBasicLog(string message)
        {
            DB.LogSet(message);
        }

        public void WriteToResultsLog(string message)
        {
            DB.ResultSet(-1, -1, "N/A", "N/A", "N/A", -1, 0, "N/A", message);
        }

        public void WriteToResultsLog(int envid, int scriptid, string clientip, string command, string result, int hresult, int elapsed, string context, string message)
        {
            DB.ResultSet(envid, scriptid, clientip, command, result, hresult, elapsed, context, message);
            FF.LogResults(envid, scriptid, clientip, command, result, hresult, elapsed, context, message);
        }


        public void WriteToMOM(string sz)
        {
            //TODO
        }

        public void WriteToFile(string sz)
        {
            //TODO
        }

        public static string CollectionToString(ICollection collection)
        {
            if (collection == null)
            {
                return "null";
            }
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            IEnumerator enumerator = collection.GetEnumerator();
            bool bNext = enumerator.MoveNext();
            while (bNext)
            {
                sb.Append(enumerator.Current == null ? "null" : enumerator.Current.ToString());
                bNext = enumerator.MoveNext();
                if (bNext)
                {
                    sb.Append(",");
                }
            }
            sb.Append("}");
            return sb.ToString();
        }

        public string SqlCommandToString(SqlCommand sqlCommand)
        {
            if (sqlCommand == null)
            {
                throw new ArgumentNullException("sqlCommand");
            }

            if (sqlCommand.CommandText == null || sqlCommand.CommandText.Length == 0)
            {
                return "SqlCommand.CommandText is empty";
            }

            switch (sqlCommand.CommandType)
            {
                case CommandType.Text:
                    return sqlCommand.CommandText;

                case CommandType.StoredProcedure:
                    StringBuilder sb = new StringBuilder();
                    sb.Append(sqlCommand.CommandText);
                    foreach (SqlParameter sParam in sqlCommand.Parameters)
                    {
                        sb.Append(" ");
                        sb.Append(sParam.ParameterName);
                        sb.Append("=");
                        if (sParam.Value == null)
                        {
                            sb.Append("null");
                        }
                        else
                        {
                            sb.Append(sParam.Value.ToString());
                        }
                    }
                    sb.Append(" CommandTimeout="+sqlCommand.CommandTimeout);
                    return sb.ToString();

                default:
                    return "Unknown SqlCommand.CommandType. SqlCommand.CommandText is: " + sqlCommand.CommandText;
            }
        }
    }



    public class LogFileMgr
    {
        const string delim = "|";

        string          basePath;
        int             currentHour;
        StreamWriter    log;
        Mutex           mutex;


        public LogFileMgr(string path)
        {
            log          = null;
            basePath     = path;
            currentHour  = -1;
            mutex        = new Mutex(false);
        }



        public StreamWriter Log
        {
            get
            {
                DateTime now = DateTime.Now;
                string filespec;

                if (now.Hour != currentHour)
                {
                    filespec  = now.Year.ToString("D4");
                    filespec += now.Month.ToString("D2");
                    filespec += now.Day.ToString("D2");
                    filespec += now.Hour.ToString("D2");
                    filespec += ".log";

                    currentHour = now.Hour;

                    if (log != null)
                    {
                        log.Flush();
                        log.Close();
                    }

                    if (!Directory.Exists(basePath))
                        Directory.CreateDirectory(basePath);

                    log =  File.AppendText(basePath + "\\" + filespec);
                }

                return log;
            }
        }



        public void LogResults(int envid, int scriptid, string clientip, string command, string result, int hresult, int elapsed, string context, string message)
        {
            string line;

            try
            {
                mutex.WaitOne(10000, false);

                line =  DateTime.Now.ToString() + delim
                     + envid.ToString() + delim
                     + scriptid.ToString() + delim
                     + clientip + delim
                     + command + delim
                     + result + delim
                     + hresult.ToString() + delim
                     + elapsed.ToString() + delim
                     + context + delim
                     + message + delim;

                Log.WriteLine(line);
                Log.Flush();
            }
            catch (Exception e)
            {
                Console.WriteLine("Text logging is borked: " + e);
            }
            finally
            {
                mutex.ReleaseMutex();
            }
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Message.cs ===
using System;
using System.Collections;

namespace Xonwatch
{

	/// <summary>
	///  Same format for ingoing and outgoing messages.
	/// Standard Message format is [messagelength]|[messageid]|[sourceip]|[destip]|[envid]|[command]|[param1]|[param2]|...
	/// </summary>
	//[Serializable]
	public class XonWatchMessage : MarshalByRefObject
	{
		static int MessageIDCount = 1;

		ArrayList parameters;
		int id;
		int envid;
		string command;
		string destip;
		string sourceip;
		string fulltext;
		byte [] msginbytes;
		//private XonWatchLog log;

		/// <summary>
		/// Build the fullText value fo the MessageObject
		/// which is what will be sent
		/// </summary>
		/// <param name="SourceIP"></param>
		/// <param name="DestIP"></param>
		/// <param name="EnvID"></param>
		/// <param name="Command"></param>
		/// <param name="Params"></param>
		public XonWatchMessage(string sourceIP, string destIP, int envID, 
			string Command, ArrayList _parameters)
		{
			//create message object from variables on the client
			id = MessageIDCount++;
			sourceip = sourceIP;
			destip = destIP;
			envid = envID;
			command = Command;
			parameters = _parameters;

			fulltext = id+ "|" + sourceIP + "|" + destIP + "|" + envID + "|" + command;

			IEnumerator e = parameters.GetEnumerator();
			while (e.MoveNext())
			{
                DictionaryEntry o = (DictionaryEntry) e.Current;
				fulltext = fulltext + "|" + o.Key.ToString() + "=" + o.Value.ToString();
			}

			byte [] fullbytes = System.Text.Encoding.ASCII.GetBytes(fulltext.ToCharArray());
			string length = fullbytes.Length.ToString();
			fulltext = length + "|" + fulltext;
			msginbytes = System.Text.Encoding.ASCII.GetBytes(fulltext.ToCharArray());
		}

		public XonWatchMessage(string fullText)
		{
			string [] elements = fullText.Split('|');
			id = Convert.ToInt32(elements[0]);
			sourceip = elements[1];
			destip = elements[2];
			envid = Convert.ToInt32(elements[3]);
			command = elements[4];

			parameters = new ArrayList();

			for (int x = 5; x < elements.Length; x++)
			{

				string y = elements[x];
				string [] z = y.Split('=');
				try
				{
                    DictionaryEntry  entry = new DictionaryEntry();
    
                    entry.Key   = z[0];
                    entry.Value = z[1];
    
                    parameters.Add(entry);
				}
				catch (Exception err)
				{
					string zzz = err.Message;
				}

			}

			fulltext = fullText;

			byte [] fullbytes = System.Text.Encoding.ASCII.GetBytes(fulltext.ToCharArray());
			string length = fullbytes.Length.ToString();
			fulltext = length + "|" + fulltext;
			msginbytes = System.Text.Encoding.ASCII.GetBytes(fulltext.ToCharArray());
		}

		public int ID
		{
			get
			{
				if (id > 500000)
				{
					id = 0; //reset to prevent overflow
				}
				return id;
			}
		}

		public int EnvID
		{
			get
			{
				return envid;
			}
		}

		public string Command
		{
			get
			{
				return command;
			}

		}

		public string DestIP
		{
			get
			{
				return destip;
			}

		}

		public string SourceIP
		{
			get
			{
				return sourceip;
			}

		}

		public ArrayList Params
		{
			get
			{
				return parameters;
			}
		}

		public string FullText
		{
			get
			{
				return fulltext;
			}

		}
	}

	public abstract class MessageQueues
	{
		//there are 2 queues of messages
		//one for outgoing messages 
		//and those received from XBoxes
		//socket connections and the environment objects are constantly adding and removing
		//messages from these queues

		//recvmessages are those being processed by the service
		//these will be processed as is possible
		private static Queue recvmessages = new Queue();

		public static void AddRecvMessage(XonWatchMessage recvMessage)
		{
			recvmessages.Enqueue(recvMessage);
		}

		public static XonWatchMessage GetRecvMessage()
		{
			if (recvmessages.Count != 0)
			{
			   return (XonWatchMessage)recvmessages.Dequeue();
			}
			else
			{
				return null;
			}
		}

		//sendmessages are those being sent to xboxes
		//these will be handled by sockets
		private static Queue sendmessages = new Queue();

		public static void AddSendMessage(XonWatchMessage sendMessage)
		{
			sendmessages.Enqueue(sendMessage);
		}

		public static XonWatchMessage GetSendMessage()
		{
			if (sendmessages.Count != 0)
			{
				return (XonWatchMessage)sendmessages.Dequeue();
			}
			else
			{
				return null;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Eventing.cs ===
//-----------------------------------------------------------------------
// <copyright file="Eventing.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Threading;

namespace Xonwatch
{
    /// <summary>
    /// Wrapper class for event logging in the XonWatch service
    /// </summary>
    public class Eventing
    {
        /// <summary>
        /// Controls whether we write to the actual event log or to standard output
        /// </summary>
        public static bool LogToConsole = false;

        /// <summary>
        /// Source of XonWatch service events
        /// </summary>
        public const string Source = "XeOnWatch";

        public static bool WriteAppLogEvent(EventLogEntryType et, int id, short cat, string text)
        {
            if (LogToConsole)
            {
                Console.WriteLine("Event {0}: {1}: {2}", id, et, text);
            }
            else
            {
                EventLog log = new EventLog("Application");

                if (!EventLog.SourceExists(Source))
                {
                    EventLog.CreateEventSource(Source, "Application");

                    // This creation loop is a little hacky but really should only
                    // execute once on a box, so... hopefully not a big deal
                    //
                    while (!EventLog.SourceExists(Source))
                        Thread.Sleep(500);
                }


                if (text.Length >= 32766)
                    text = text.Substring(0, 32766);

                log.Source = Source;
                log.WriteEntry(text, et, id, cat);
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Network.cs ===
using System;

namespace Xonwatch
{

	/// <summary>
	/// Summary description for Network.
	/// </summary>
	//[Serializable]
	public class Network : MarshalByRefObject
	{
		int id;
		string name;
		string xmacsaddress;
		string sgfdaddress;
		//private XonWatchLog log;

		private Network(){} 

		public Network(int _id, string _name, string _xmacsaddress, string _sgfdaddress)
		{
			id = _id;
			name = _name;
			xmacsaddress = _xmacsaddress;
			sgfdaddress = _sgfdaddress;
		}

		public int ID
		{
			get
			{
				return id;
			}
		}

		public string Name
		{
			get
			{
				return name;
			}
		}

		public string XMacs
		{
			get
			{
				return xmacsaddress;
			}
		}
	
		public string SGFD
		{
			get
			{
				return sgfdaddress;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\XboxSocket.cs ===
using System;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace Xonwatch
{
    /// <summary>
    /// Class encapsulates all functionality needed to send and recv data
    /// to and from Clientes
    /// There are threes types of socket: listener, receive, and send
    /// One listener socket is created for the life of the application
    /// Thr listener will spawn receive sockets which are added to the AvailableSockets
    /// Hashtable--where specific sockets are retrievable based on a SocketKey (IP address +
    /// "send" or "recv") Send sockets are created directly by the user of this class with a buffer of
    /// information that needs to be sent to a given Client at IP Address 'x.x.x.x'.
    /// </summary>
    public abstract class ClientSockets
    {
        /// <summary>
        /// All of send and recv sockets available to do work.
        /// </summary>
        static public Hashtable recvsockets = new Hashtable();
        static public Hashtable sendsockets = new Hashtable();
        static private ClientListenerSocket listener;

        /// <summary>
        ///outgoing messages are arranged in a hashtable of queues
        ///with a queue for each client
        /// </summary>
        static private Hashtable outgoingmessages = new Hashtable();

        /// <summary>
        /// ReaderWriter lock that guards access to the outgoingMessages
        /// </summary>
        static private ReaderWriterLock outgoingMsgLock = new ReaderWriterLock();

        /// <summary>
        /// Queue of all messages from Clients that will need to be routed
        /// to the appropriate environment.
        /// </summary>
        static public Queue incomingmessages = new Queue();


        static public ClientListenerSocket Listener
        {
            get
            {
                return listener;
            }
            set
            {
                listener = value;
            }
        }

        static public IDictionaryEnumerator RecvSockets
        {
            //will need to fix for synchronization issues
            get
            {
                return (IDictionaryEnumerator)recvsockets.GetEnumerator();
            }
        }

        static public IDictionaryEnumerator SendSockets
        {
            //will need to fix for synchronization issues
            get
            {
                return (IDictionaryEnumerator)sendsockets.GetEnumerator();
            }
        }

        static public bool CreateSendSocket(string _clientip,
            int _sendport)
        {
            try
            {
                ClientSendSocket sender = new ClientSendSocket(_clientip,_sendport);
            }
            catch
            {
                return false;
            }

            return true;
        }

        static public void RemoveSendSocket(string _clientip)
        {
            try
            {
                ClientSendSocket s = (ClientSendSocket)sendsockets[_clientip];

                if (s != null)
                {
                    sendsockets.Remove(_clientip);
                    s.Close();
                }
            }
            catch
            {
            }
        }

        static public ClientSendSocket GetSendSocket(string ip)
        {
            try
            {
                return (ClientSendSocket)sendsockets[ip];
            }
            catch
            {
                return null;
            }
        }

        static public bool SendNextMessage(string _clientip)
        {
            ClientSendSocket s = (ClientSendSocket)sendsockets[_clientip];
            bool b  = s.SendNextMessage();
            return b;
        }

        static public ClientRecvSocket GetRecvSocket(string ip)
        {
            try
            {
                return (ClientRecvSocket)recvsockets[ip];
            }
            catch
            {
                return null;
            }
        }

        static public void RemoveRecvSocket(string _clientip)
        {
            try
            {
                ClientRecvSocket s = (ClientRecvSocket)recvsockets[_clientip];

                if (s != null)
                {
                    recvsockets.Remove(_clientip);
                    s.Close();
                }
            }
            catch
            {
            }
        }

        /// <summary>
        /// This creates the send and recv sockets for a given Client.
        /// These sockets are then accessible via their IP address from the
        /// RecvSockets and SendSockets enumerators
        /// </summary>
        /// <param name="ControllerIP"></param>
        /// <param name="ClientIP"></param>
        /// <param name="SendPort"></param>
        /// <param name="RecvPort"></param>
        /// <returns></returns>
        static public bool StartListener(string _serviceip,
            int recvport)
        {
            try
            {
                if (ClientSockets.listener == null)
                {
                    listener = new ClientListenerSocket(_serviceip, recvport);
                }
            }
            catch
            {
                return false;
            }

            return true;
        }

        static public bool DeleteSockets(string _clientip)
        {
            ClientSockets.RemoveSendSocket(_clientip);
            ClientSockets.RemoveRecvSocket(_clientip);

            return true;
        }

        static public void AddOutgoingMessageQueue(string ip)
        {
            outgoingMsgLock.AcquireWriterLock(-1);

            try
            {
                outgoingmessages.Add(ip, new Queue());
            }
            finally
            {
                outgoingMsgLock.ReleaseWriterLock();
            }
        }

        static public void ClearOutgoingMessageQueues()
        {
            outgoingMsgLock.AcquireWriterLock(-1);

            try
            {
                outgoingmessages.Clear();
            }
            finally
            {
                outgoingMsgLock.ReleaseWriterLock();
            }
        }

        static public void SetNextOutgoingMessage(XonWatchMessage thisMessage)
        {
            outgoingMsgLock.AcquireReaderLock(-1);

            try
            {
                if (outgoingmessages.Contains(thisMessage.DestIP))
                {
                    Queue clientmessages = (Queue)outgoingmessages[thisMessage.DestIP];
                    clientmessages.Enqueue(thisMessage);
                }
            }
            finally
            {
                outgoingMsgLock.ReleaseReaderLock();
            }
        }


        static public XonWatchMessage GetNextIncomingMessage()
        {
            if (incomingmessages.Count != 0)
            {
                return (XonWatchMessage)incomingmessages.Dequeue();
            }
            else
            {
                return null;
            }
        }


        /// <summary>
        /// SocketPacket is used to send current socket information between different functions
        /// including delegates. Buffer is set to one byte for recv mode but can be much larger for
        /// send mode.
        /// </summary>
        public class SocketPacket
        {
            public byte [] lilbuffer;
            public byte [] bigbuffer;
            public Socket socket;

            private SocketPacket(){}

            public SocketPacket(Socket xsocket)
            {
                lilbuffer = new byte[1];
                bigbuffer = new byte[4096];         // keep in sync with <client>\private\tools\live\xeonwatch\client\src\communication.h
                socket = xsocket;
            }
        }

        /// <summary>
        /// Sends data to a Client. Full buffer is given to this socket which then sends in async mode to
        /// the target Client.
        /// </summary>
        public class ClientSendSocket : Socket
        {
            AsyncCallback CallBack0;
            AsyncCallback CallBack;
            bool readyfornewsend;
            string clientip;

            public ClientSendSocket(string _clientip, int _sendport):
                base(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
            {

                clientip = _clientip;
                IPAddress addr = IPAddress.Parse(clientip);
                //short s = IPAddress.HostToNetworkOrder((short)_sendport);
                IPEndPoint ep = new IPEndPoint(addr, _sendport);
                ClientSockets.RemoveSendSocket(clientip);
                ClientSockets.sendsockets.Add(clientip, this);
                readyfornewsend = false;
                WaitForData(ep);
            }

            public bool ReadyForNewSend
            {
                get
                {
                    return readyfornewsend;
                }
                set
                {
                    readyfornewsend = value;
                }
            }

            public void WaitForData(IPEndPoint ep)
            {
                if (CallBack0 == null)
                {
                    CallBack0 = new AsyncCallback(OnConnect);
                }

                if (!this.Connected)
                {

#if DEBUG
                    Console.WriteLine("Connecting now...");
#endif

                    this.BeginConnect(ep,CallBack0,null);
                }
            }


            public void OnConnect(IAsyncResult ia)
            {
                try
                {
                    this.EndConnect(ia);
#if DEBUG
                    Console.WriteLine("Attempting send socket wakeup.");
#endif

                    //wake up
                    SendData(Encoding.ASCII.GetBytes("0"));
                    readyfornewsend = true;
#if DEBUG
                    Console.WriteLine("Send passed. Socket added for Client:" + clientip +".");
#endif
                }
                catch
                {
                    ClientSockets.RemoveSendSocket(clientip);
                }
            }

            public bool SendNextMessage()
            {
                if (!readyfornewsend)
                    return false;

                Queue queue = null;

                outgoingMsgLock.AcquireReaderLock(-1);

                try
                {
                    if (outgoingmessages.Contains(clientip))
                    {
                        queue = (Queue)outgoingmessages[clientip];
                    }
                }
                finally
                {
                    outgoingMsgLock.ReleaseReaderLock();
                }

                if (queue != null && queue.Count != 0)
                {
                    XonWatchMessage msg = (XonWatchMessage)queue.Peek();

                    try
                    {
                        SendData(Encoding.ASCII.GetBytes(msg.FullText));
                        //message should not be removed from queue until send data passes
                        queue.Dequeue();
#if DEBUG
    ConsoleControl.ColorWriteLine(ConsoleControl.COLOR_SEND, "Send[" + DateTime.Now.ToString() + "]:[" + msg.FullText + "]");
#endif
                        return true;
                    }
                    catch
                    {
                        ClientSockets.RemoveSendSocket(clientip);
                        readyfornewsend = false;
#if DEBUG
                        Console.WriteLine("Data send failed.");
#endif
                        return false;
                    }
                }

                return false;
            }

            /// <summary>
            /// performs the actually asynchronous send of data
            /// </summary>
            /// <param name="buffer"></param>
            public void SendData(byte [] buffer)
            {
                if (!readyfornewsend)
                    return;

                if  (CallBack == null)
                {
                    CallBack = new AsyncCallback(DataSent);
                }

                SocketPacket sp = new SocketPacket(this);
                sp.bigbuffer = buffer;
                sp.socket = this;
                try
                {
                    this.BeginSend(sp.bigbuffer, 0,
                        sp.bigbuffer.Length,
                        SocketFlags.None,
                        CallBack,
                        sp);
                }
                catch (Exception e)
                {
                    string em = e.Message;
                    ClientSockets.RemoveSendSocket(clientip);
                    readyfornewsend = false;

                    throw new Exception();
                }
            }

            public void DataSent(IAsyncResult ia)
            {
                try
                {
                    this.EndSend(ia);
                    readyfornewsend = true;
                }
                catch
                {
                    ClientSockets.RemoveSendSocket(clientip);
                    readyfornewsend = false;
                }
            }
        }

        /// <summary>
        /// The Listener waits for connections and then spawns a new Recv socket
        /// It then goes back to listening.
        /// </summary>
        public class ClientListenerSocket : Socket
        {
            private string serviceip;
            public int port;

            public ClientListenerSocket(string _serviceip, int recvport):
                base(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
            {
                serviceip = _serviceip;
                port = recvport;
                IPAddress addr = IPAddress.Parse(serviceip);
                IPEndPoint ep = new IPEndPoint(addr, port);
                this.Bind(ep);
                this.Listen(Convert.ToInt32(Enum.Format(typeof(SocketOptionName), SocketOptionName.MaxConnections, "d")));
                this.BeginAccept(new AsyncCallback(OnClientConnect), null);
            }

            /// <summary>
            /// Callback function for the Listener
            /// Creates the new recv socket and returns Listener to listen mode.
            /// </summary>
            /// <param name="asyn"></param>
            public void OnClientConnect(IAsyncResult asyn)
            {
                try
                {
#if DEBUG
                    Console.WriteLine("Remote Client attempting connection.");
#endif

                    Socket s = (Socket)this.EndAccept(asyn);
                    ClientRecvSocket recvSocket = new ClientRecvSocket(s);
                    IPEndPoint x = (IPEndPoint)recvSocket.sock.RemoteEndPoint;
                    string clientip = x.Address.ToString();
                    recvSocket.serviceip = this.serviceip;
                    recvSocket.clientip  = clientip;
                    recvSocket.heartbeat = DateTime.Now;

                    ClientSockets.RemoveRecvSocket(clientip); //remove old connection
                    ClientSockets.recvsockets.Add(clientip, recvSocket);

#if DEBUG
                    Console.WriteLine("Recv socket created for remote Client:" + clientip + ".");
#endif
                    this.BeginAccept(new AsyncCallback(OnClientConnect),null); //go back to listening
                }
                catch (Exception e)
                {
                    string x = e.Message;
                }
            }
        }

        /// <summary>
        /// This form of socket receives data a byte at a time
        /// from a given Client. Buffer data is added to string message
        /// which is, when finished, then placed on a received message queue.
        /// The socket then goes back to waiting for new data.
        /// </summary>
        public class ClientRecvSocket : Socket
        {
            /// <summary>
            /// Gets or sets a value indicating whether to show heartbeat messages received from the console
            /// </summary>
            public static bool ShowHeartbeatMessages { get; set; }

            public AsyncCallback CallBack;
            public string clientip;
            public string serviceip;
            private StringBuilder message;
            public int bytesread;
            public int msglength;
            public int msgheaderlength;
            public string szlength; //string representation of the message length
            public Socket sock;
            public SocketPacket sp;
            public DateTime heartbeat;

            public string BufferVal { get; private set; }

            public string MsgLength
            {
                get
                {
                    return msglength.ToString();
                }

            }

            //the socket itself is actually a member of this class now
            public ClientRecvSocket(Socket s): base(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
            {
                #if DEBUG
                    Console.WriteLine("Recv socket being created.");
                #endif

                sock = s;
                msglength = 0;
                msgheaderlength = 0;
                bytesread = 0;
                szlength = "";
                serviceip = "";
                clientip = "";
                sp = new SocketPacket(this);
                WaitForData();
                message = new StringBuilder();
            }

            /// <summary>
            /// recv socket is waiting for more data at this point
            /// </summary>
            public void WaitForData()
            {
                try
                {
                    if  (CallBack == null)
                    {
                        CallBack = new AsyncCallback(OnDataReceived);
                    }

                    this.sock.BeginReceive(sp.lilbuffer, 0,
                        sp.lilbuffer.Length,
                        SocketFlags.None,
                        CallBack,
                        sp);
                }
                catch (Exception e)
                {
                    string msg = e.Message;
                }
            }

            /// <summary>
            /// callback function when data is received. it is added to the message string.
            /// the socket then waits for more data.
            /// </summary>
            /// <param name="asyn"></param>
            public void OnDataReceived(IAsyncResult asyn)
            {
                heartbeat = DateTime.Now;

                string bufferval;

                try
                {
                    heartbeat = DateTime.Now;
                    int read = this.sock.EndReceive(asyn);


                    //---------------------------------------------------------
                    // msglength is an important 'state' variable which indicates
                    // the operating mode of this callback.  If msglength is zero
                    // it indicates that we are collecting the incoming message
                    // one character at a time in order to locate the first '|'
                    // delimiter and thereby isolate the message length field which
                    // is at the beginning of incoming text.
                    //
                    // the szlength string is used to accumulate the characters
                    // until this delimiter is located at which point msglength is
                    // set to the decimal equivalent of the message lenghth and a
                    // 'large' buffer read is performed to retrieve the remainder
                    // of the incoming text
                    //
                    if (msglength == 0)
                    {
                        //start listening again with the small buffer
                        bufferval = Encoding.ASCII.GetString(sp.lilbuffer, 0, read);
                    }
                    else
                    {
                        bufferval = Encoding.ASCII.GetString(sp.bigbuffer, 0, read);
                    }


                    if (msglength == 0)
                    {
                        // If we get a zero for the first character, we treat
                        // the incoming message as a heartbeat (we don't allow
                        // the length prefix to be zero padded)
                        //
                        if (bufferval == "0" && szlength == "")
                        {
                            if (ShowHeartbeatMessages)
                            {
#if DEBUG
                                ConsoleControl.ColorWriteLine(ConsoleControl.COLOR_HEART, "Heart: [" + this.sock.RemoteEndPoint + "]");
#endif
                            }

                            // this.sock.BeginReceive(sp.lilbuffer, 0, sp.lilbuffer.Length, SocketFlags.None, new AsyncCallback(OnDataReceived),sp);
                            // return;
                        }
                        else
                        {
                            if (bufferval == "|")
                            {
                                msglength = Convert.ToInt32(szlength);
                            }
                            else
                            {
                                szlength += bufferval;
                            }
                        }
                      }
                    else
                    {
#if DEBUG

    if (bufferval.IndexOf("result=success") > 0)
        ConsoleControl.ColorWriteLine(ConsoleControl.COLOR_RECV, "Recv[" + DateTime.Now.ToString() + "]:[" + szlength + "|" + bufferval + "]");
    else
        ConsoleControl.ColorWriteLine(ConsoleControl.COLOR_ERROR, "Recv[" + DateTime.Now.ToString() + "]:[" + szlength + "|" + bufferval + "]");
#endif
                        message.Append(bufferval);

                        if (message.Length >= msglength)
                        {
                            XonWatchMessage msg = new XonWatchMessage(message.ToString());
                            if (msg != null)
                            {
                                incomingmessages.Enqueue(msg);
                            }

                            // Reset our 'state' variables to collect the next incoming message
                            msglength = 0;
                            szlength = "";
                            bufferval = "";
                            message.Length = 0;
                        }
                    }


                    if (msglength == 0)
                    {
                        this.sock.BeginReceive(sp.lilbuffer, 0, sp.lilbuffer.Length, SocketFlags.None, new AsyncCallback(OnDataReceived),sp);
                    }
                    else
                    {
                        this.sock.BeginReceive(sp.bigbuffer, 0, sp.bigbuffer.Length, SocketFlags.None, new AsyncCallback(OnDataReceived),sp);    // $REVIEW (michion): use SocketFlags.None?
                    }

                }
                catch (ObjectDisposedException )
                {
                    //System.Diagnostics.Debugger.Log(0,"1","\nOnDataReceived: Socket has been closed\n");
                }
                catch(SocketException)
                {
                    //MessageBox.Show (se.Message );
                }
                catch
                {
                }
            }
        }

    }




    public class ConsoleControl
    {
        /*  Foreground  colors:
                Blue      = 0x00000001,
                Green     = 0x00000002,
                Red       = 0x00000004,
                Intensity = 0x00000008

            Background
                Blue      = 0x00000010,
                Green     = 0x00000020,
                Red       = 0x00000040,
                Intensity = 0x00000080
        */

        public const int COLOR_HEART = 1;
        public const int COLOR_SEND  = 2;
        public const int COLOR_RECV  = 10;
        public const int COLOR_ERROR = 12;


        private const int STD_INPUT_HANDLE  = -10;
        private const int STD_OUTPUT_HANDLE = -11;
        private const int STD_ERROR_HANDLE  = -12;

        private static Stack history = new Stack();


        [StructLayout(LayoutKind.Sequential)]
        struct COORD
        {
            public short x;
            public short y;
        }


        [StructLayout(LayoutKind.Sequential)]
        struct SMALL_RECT
        {
            public short Left;
            public short Top;
            public short Right;
            public short Bottom;
        }


        [StructLayout(LayoutKind.Sequential)]
        struct CONSOLE_SCREEN_BUFFER_INFO
        {
            public COORD dwSize;
            public COORD dwCursorPosition;
            public int wAttributes;
            public SMALL_RECT srWindow;
            public COORD dwMaximumWindowSize;
        }




        [DllImport("kernel32.dll")]
        private static extern IntPtr GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll")]
        private static extern bool GetConsoleScreenBufferInfo(IntPtr hConsoleHandle, ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        [DllImport("kernel32.dll")]
        private static extern bool SetConsoleTextAttribute(IntPtr hConsoleOutput, int Attributes );



        public static void ColorWriteLine(int a, string s)
        {
            IntPtr hOut = GetStdHandle(STD_OUTPUT_HANDLE);

            CONSOLE_SCREEN_BUFFER_INFO ci = new CONSOLE_SCREEN_BUFFER_INFO();

            GetConsoleScreenBufferInfo(hOut, ref ci);

            int a_old = ci.wAttributes;

            SetConsoleTextAttribute(hOut, a);

            Console.WriteLine(s);

            SetConsoleTextAttribute(hOut, a_old);
        }

    }




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\XonWatchRemoting.cs ===
using System;
using System.Collections;
using System.Security.Permissions;

namespace Xonwatch
{
    /// <summary>
    ///
    /// This class is designed to be instantiated only once by means of the
    /// RemotedInstance static below.  The SortedList containers that are
    /// created for that single instance are loaded by the App.LoadData()
    /// method and the single instance is made remotable by the
    /// App.SetUpRemoting() (actually NOT in that order).
    ///
    /// The intent here is for all the data for the xonwatch2 system to be
    /// controlled by the one instance of this class (and the data it holds)
    ///
    /// </summary>
    public class XonWatchRemoting : System.MarshalByRefObject
    {
        public SortedList Clients;
        public SortedList Environments;
        public SortedList Networks;
        public SortedList Scripts;
        public SortedList TestTypes;
        public string currentEnvironment;
        public Information Info;
        public bool bRefreshData;
        public bool bReloadScripts;
        static public XonWatchLog Log;
        static public Hashtable MOMErrors = new Hashtable();
        //        static public Hashtable TestTypes = new Hashtable();

        public static XonWatchRemoting RemotedInstance = new XonWatchRemoting();

        private XonWatchRemoting()
        {
            Clients = new SortedList();
            Environments = new SortedList();
            Networks = new SortedList();
            Scripts = new SortedList();
            TestTypes = new SortedList();
            Info = new Information();   // $REVIEW (michion): App class instantiates its own Information object and 'overrides' this one.  Why?

            currentEnvironment = "";

            bRefreshData = false;
            bReloadScripts = false;
            Log = null;
        }

        public enum XeOnWatchEvents
        {
            SCRIPT_TIMEOUT = 10010,
            SCRIPT_CRITICAL_ERROR = 10020,
            SCRIPT_UNKNOWN_STATE = 10030,
            SCRIPT_CLIENT_NOT_FOUND = 10040,
            SCRIPT_NOT_RUNNING = 10050,
            SCRIPT_STARTING = 10060,
            SCRIPT_MESSAGE_CORRELATION_NOT_FOUND = 10070,
            SCRIPT_MESSAGE_CORRELATION_NOT_FOUND_IN_RUNNING_SCRIPT = 10080,
            SCRIPT_ADD_FAILED = 10090,
            CLIENT_RECV_SOCKET_STARVING = 20010,
            CLIENT_STATUS_FAILING = 20020,
            CLIENT_STATUS_OFFLINE = 20030,
            SERVICE_ABNORMAL_TERMINATION = 30010,
            EMAIL_SEND_FAILED = 40010,
            EMAIL_SEND_FAILED_FINAL = 40020,
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override Object InitializeLifetimeService()
        {
            return null;
        }

        public string CurrentEnvironment
        {
            get
            {
                return currentEnvironment;
            }

            set
            {
                currentEnvironment = value;
            }
        }

        public bool ReloadScripts
        {
            get
            {
                return bReloadScripts;
            }

            set
            {
                bReloadScripts = value;
            }
        }

        public Client GetClientByID(string ip)
        {
            try
            {
                return (Client)Clients[ip];
            }
            catch
            {
                return null;
            }

        }

        static public bool IsMOMError(int hr)
        {
            try
            {
                int x = Convert.ToInt32(MOMErrors[hr]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\RuntimeResponseData.cs ===
using System;
using System.Collections;

namespace Xonwatch
{
    /// <summary>
    /// Object used to manage runtime data returned by test clients.  The response data
    /// is organized into two major types: global and context.  The global data is overwritten
    /// in a cumulative fashion with each response message that is received.  Context data is
    /// is overwritten but in a replacement fashion
    /// </summary>
    public class RuntimeResponseData : MarshalByRefObject
    {
        private Hashtable globals;
        private Hashtable contexts;

        public RuntimeResponseData()
        {
            globals = new Hashtable();
            contexts = new Hashtable();
        }

        public void RecordResponse(String command, String context, String result, String hresult, String elapsed, String details)
        {
            Hashtable replacement = new Hashtable();

            replacement["COMMAND"] = command;
            replacement["CONTEXT"] = context;
            replacement["ELAPSED"] = elapsed;
            replacement["RESULT"] = result;
            replacement["HRESULT"] = hresult;

            string[] elements = details.Split('|');

            for (int x = 0; x < elements.Length; x++)
            {
                string y = elements[x];
                string[] z = y.Split('=');

                if (z.Length == 2)
                    replacement[z[0]] = z[1];
            }

            // First, overwrite any globals with matching key values
            foreach (DictionaryEntry e in replacement)
            {
                globals[e.Key.ToString().ToUpper()] = e.Value.ToString();
            }

            if (command != null && command.Length > 0)
            {
                string x = command;

                contexts[x] = new Hashtable(replacement);

                if (context != null)
                    x = x + "." + context;
                else
                    x = x + ".";

                contexts[x] = new Hashtable(replacement);
            }
        }

        public void SetGlobal(String key, String value)
        {
            globals[key] = value;
        }

        public string GetValue(String subkey)
        {
            String cmd = null;
            String ctx = null;
            String key = null;

            if (subkey == null)
                return null;

            String[] z = subkey.Split('.');

            if (z.Length == 3)
            {
                cmd = z[0];
                ctx = z[1];
                key = z[2];
            }

            if (z.Length == 2)
            {
                cmd = z[0];
                ctx = null;
                key = z[1];
            }

            if (z.Length == 1)
            {
                cmd = null;
                ctx = null;
                key = z[0];
            }

            if (cmd == null)
            {
                if (globals.ContainsKey(key))
                    return globals[key].ToString();
            }
            else
            {
                String k;

                k = cmd;

                if (ctx != null)
                    k += "." + ctx;

                Hashtable x = (Hashtable)contexts[k];

                if (x != null)
                {
                    if (x.ContainsKey(key))
                        return x[key].ToString();
                }
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\ScriptCommandParameter.cs ===
using System;
using System.Xml;

namespace Xonwatch
{
    /// <summary>
    /// Command parameter object, allows for value substitution during script runtime.
    /// </summary>
    //[Serializable]
    public class ScriptCommandParameter : MarshalByRefObject
    {
        static Random rndgen = new Random();

        private string name;
        private string value;
        private string subKey;
        private ulong rndmin;
        private ulong rndmax;

        public ScriptCommandParameter(XmlNode node)
        {
            name = node.Attributes["name"].Value.ToString();
            value = node.InnerText;
            rndmin = 0;
            rndmax = 0;

            // The param node can specify a number of interesting attributes:

            // subkey: This is used to specify a substitution key value which
            //         the script resolves at runtime to determine what value
            //         the parameter will take
            //
            // rndmin: This attribute specifies that a parameter should be
            //         resolved as a random numeric value and that the minimum
            //         value should match this specification
            //
            // rndmax: This attribute specifies that a parameter should be
            //         resolved as a random numeric value and that the maximum
            //         value should match this specification
            //
            if (node.Attributes["subkey"] != null)
                subKey = node.Attributes["subkey"].Value.ToString();
            else
                subKey = null;


            if (node.Attributes["rndmin"] != null)
                rndmin = Convert.ToUInt64(node.Attributes["rndmin"].Value.ToString());

            if (node.Attributes["rndmax"] != null)
                rndmax = Convert.ToUInt64(node.Attributes["rndmax"].Value.ToString());
        }

        public string Name
        {
            get
            {
                return name;
            }
        }

        public string Value(RuntimeResponseData rtd)
        {
            // rules of precedence:  If a subkey is specified, then use it, otherwise,
            // if a random value is generatable then use it, otherwise, use the default
            //
            if (rtd != null && subKey != null)
            {
                string s = rtd.GetValue(subKey);
                return (s == null) ? value : s;
            }

            if (rndmin != rndmax)
            {
                ulong range = (rndmax > rndmin) ? (rndmax - rndmin) : rndmin - rndmax;
                range++;
                ulong rndval = ((ulong)(rndgen.NextDouble() * range)) + rndmin;

                return rndval.ToString();
            }

            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:28:59 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\XonWatchDB.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Threading;

namespace Xonwatch
{
    /// <summary>
    /// adapted from /depot/xonline/private/tools/framework/cwebdb.cs
    /// </summary>
    public class XonWatchDB
    {
        /// <summary>
        /// Boolean that controls whether SQL log messages go to the database or the console
        /// </summary>
        public static bool LogToConsole = false;

        private string connectionstring;
        private SqlConnection sqlconnection = null;
        private Mutex         sqlMutex      = null;
        private static Mutex scriptGetMutex = null;
        private static Mutex scriptListGetMutex = null;
        private static Mutex environmentGetMutex = null;
        private object sqlConnectionLock = null;
        private XonWatchLog log;

        public XonWatchDB(string _connectionstring, XonWatchLog dblog)
        {
            log = dblog;

            connectionstring = _connectionstring;

            if (!string.IsNullOrEmpty(connectionstring))
            {
                // Create a sql connection. Note, I've decided not to track
                // the opened state of this connection. I'll rely on the
                // sql classes to throw the appropriate exceptions if someone
                // calls Close on this class and then attempts to use some
                // other methods.
                try
                {
                    sqlconnection = new SqlConnection(connectionstring);
                    sqlconnection.StateChange += new StateChangeEventHandler(sqlconnection_StateChange);
                    sqlconnection.Open();
                    sqlMutex = new Mutex(false);
                    scriptGetMutex = new Mutex();
                    scriptListGetMutex = new Mutex();
                    environmentGetMutex = new Mutex();
                    sqlConnectionLock = new object();
                }
                catch (SqlException sqlException)
                {
                    string sErr = "XonWatch.XonWatchDB.ctor: "
                        + "Opening a connection to "
                        + connectionstring
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;

                    throw new XonWatchDBException(sErr, sqlException);
                }
                catch (ArgumentException ArgumentException)
                {
                    // this gets thrown if the connection string is improperly formatted
                    string sErr = "XonWatch.XonWatchDB.ctor: "
                        + "Opening a connection to "
                        + connectionstring
                        + " caused an ArgumentException. Exception details: "
                        + ArgumentException.Message;

                    throw new XonWatchDBException(sErr, ArgumentException);
                }
            }
        }

        void sqlconnection_StateChange(object sender, StateChangeEventArgs e)
        {
            //if (sqlconnection.State != ConnectionState.Open)
                //sqlconnection.Open();
        }

        public void Close()
        {
            if (sqlconnection != null && sqlconnection.State != ConnectionState.Closed)
            {
                sqlconnection.Close();
            }

            if (sqlMutex != null)
            {
                sqlMutex.Close();
            }
        }

        /// <summary>
        /// create an asynchronous send
        /// </summary>
        /// <param name="sqlCommand"></param>
        /// <param name="sContext"></param>

        // I had this little code block repeated all over the place in this
        // file, so I finally decided to put it in this little helper function
        // It's not always useful, because sometimes I want to check the return
        // code for specific values, but I found that most of the time
        // I just threw the same message if it was non-zero
        private void ExecuteNonQuery(
            SqlCommand sqlCommand,
            string sContext)
        {
            try
            {
                sqlMutex.WaitOne(10000, false);

                if (sqlCommand.Connection.State != ConnectionState.Open)
                    sqlCommand.Connection.Open();
                sqlCommand.ExecuteNonQuery();
                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = sContext
                        + ": The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = sContext
                    + ": The stored procedure "
                    + sqlCommand.CommandText
                    + " caused a SqlException. Details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                sqlMutex.ReleaseMutex();
            }
        }

        public SqlConnection GetSqlConnection()
        {
            lock(sqlConnectionLock)
            {
                return sqlconnection;
            }
        }

        public ArrayList EnvironmentListGet()
        {
            SqlCommand sqlCommand = GetSqlConnection().CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_environment_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int envid = (int)sqlDataReader["i_id"];
                    arrayList.Add(envid);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.EnvironmentListGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.EnvironmentListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return arrayList;
        }

        public bool EnvironmentGet(
            int id,
            out string networkid,
            out string location,
            out string useraccounts)
        {
            if (id == 0)
            {
                throw new ArgumentNullException("id");
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            if (sqlCommand.Connection.State != ConnectionState.Open)
                sqlCommand.Connection.Open();
            sqlCommand.CommandText = "p_XonWatchDB_environment_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            bool bFound = false;
            networkid = string.Empty;
            location = string.Empty;
            useraccounts = string.Empty;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "XonWatch.XonWatchDB.EnvironmentGet: "
                            + " more than one row was returned by "
                            + sqlCommand.CommandText;

                        throw new XonWatchDBException(sErr);
                    }

                    networkid = (string)sqlDataReader["vc_networkid"];
                    location = (string)sqlDataReader["vc_location"];
                    useraccounts = (string)sqlDataReader["txt_useraccounts"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.EnvironmentGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CWebDB.EnvironmentGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return bFound;
        }

        public void EnvironmentDelete(int id)
        {
            if (id == 0)
            {
                throw new ArgumentNullException("id");
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_environment_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
        }

        public ArrayList NetworkListGet()
        {
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_network_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int netid = (int)sqlDataReader["i_id"];
                    arrayList.Add(netid);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.NetworkListGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.NetworkListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return arrayList;
        }

        public bool NetworkGet(
            int id,
            out string name,
            out string xmacsAddr,
            out string sgfdAddr)
        {

            if (id == 0)
            {
                throw new ArgumentNullException("id");
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_network_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            bool bFound = false;
            name = string.Empty;
            xmacsAddr = string.Empty;
            sgfdAddr = string.Empty;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "XonWatch.XonWatchDB.NetworkGet: "
                            + " more than one row was returned by "
                            + sqlCommand.CommandText;

                        throw new XonWatchDBException(sErr);
                    }

                    name       = (string)sqlDataReader["vc_name"];
                    xmacsAddr  = (string)sqlDataReader["txt_xmacsaddr"];
                    sgfdAddr   = (string)sqlDataReader["txt_sgfdaddr"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.NetworkGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.NetworkGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return bFound;
        }

        public void RefreshSqlConnection()
        {
            if (sqlconnection.State == ConnectionState.Closed)
            {
                sqlconnection.Open();
            }
        }

        public ArrayList ClientListGet()
        {
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_client_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int netid = (int)sqlDataReader["i_id"];
                    arrayList.Add(netid);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.ClientListGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.ClientListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return arrayList;
        }

        public bool ClientGet(
            int id,
            out string platform,
            out string name,
            out string ip,
            out int environment)
        {

            if (id == 0)
            {
                throw new ArgumentNullException("id");
            }


            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_client_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            bool bFound = false;
            platform    = string.Empty;
            name        = string.Empty;
            ip          = string.Empty;
            environment = 0;

            SqlDataReader sqlDataReader = null;

            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "XonWatch.XonWatchDB.ClientGet: "
                            + " more than one row was returned by "
                            + sqlCommand.CommandText;

                        throw new XonWatchDBException(sErr);
                    }

                    platform    = (string) sqlDataReader["vc_platform"];
                    name        = (string) sqlDataReader["vc_name"];
                    ip          = (string) sqlDataReader["vc_ip"];
                    environment = (int)    sqlDataReader["i_environment"];

                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.ClientGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.ClientGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return bFound;
        }

        public void ClientEnvironmentIdSet(
            int clientid,
            int envid)
        {

            if (clientid == 0)
            {
                throw new ArgumentNullException("clientid");
            }

            if (envid == 0)
            {
                throw new ArgumentNullException("envid");
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_client_set_environment_id";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_clientid", SqlDbType.Int).Value = clientid;
            sqlCommand.Parameters.Add("@i_envid", SqlDbType.NVarChar).Value = envid;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            /*
                        if (!bReportOnly)
                        {
            */
            ExecuteNonQuery(sqlCommand, "XonWatch.XonWatchDB.ClientEnvironmentIdSet");
            /*
                    }
            */


        }


        public ArrayList ScriptListGet()
        {
            scriptListGetMutex.WaitOne();
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            if (sqlCommand.Connection.State != ConnectionState.Open)
                sqlCommand.Connection.Open();
            sqlCommand.CommandText = "p_XonWatchDB_script_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int netid = (int)sqlDataReader["i_id"];
                    arrayList.Add(netid);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.ScriptListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlCommand.Connection.Close();
                    sqlDataReader.Close();
                }
            }

            scriptListGetMutex.ReleaseMutex();
            return arrayList;
        }


        public bool ScriptGet(
            int id,
            out string name,
            out string txt)
        {
            scriptGetMutex.WaitOne();

            if (id == -1)
            {
                throw new ArgumentNullException("id");
            }


            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_script_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            bool bFound = false;
            name = string.Empty;
            txt = string.Empty;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                if( sqlCommand.Connection.State != ConnectionState.Open )
                    sqlCommand.Connection.Open();
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlCommand.Connection.State == ConnectionState.Open && !sqlDataReader.IsClosed && sqlDataReader.Read())
                {
                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "XonWatch.XonWatchDB.ScriptGet: "
                            + " more than one row was returned by "
                            + sqlCommand.CommandText;

                        throw new XonWatchDBException(sErr);
                    }

                    name = (string)sqlDataReader["vc_name"];
                    txt = (string)sqlDataReader["txt_script"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = 0;
                if( sqlCommand.Parameters["RETURN_VALUE"].Value != null )
                    iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;

                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.ScriptGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.ScriptGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            scriptGetMutex.ReleaseMutex();
            return bFound;
        }


        public void ScriptSet(int scriptid, string script)
        {
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_xonwatchdb_script_set";
            sqlCommand.CommandType = CommandType.StoredProcedure;

            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = scriptid;
            sqlCommand.Parameters.Add("@txt_script", SqlDbType.Text).Value = script;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            try
            {
                ExecuteNonQuery(sqlCommand, "XonWatch.XonWatchDB.ScriptSet");
            }
            catch (Exception e)
            {

                Console.WriteLine(e.Message);
                Console.WriteLine("Loading failure. Press any key to continue...");
                Console.ReadLine();
            }
        }

        public ArrayList TestTypeListGet()
        {
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_testtype_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            ArrayList arrayList = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int testid = (int)sqlDataReader["i_id"];
                    arrayList.Add(testid);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.TestTypesListGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.TestTypesListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return arrayList;
        }




        public bool TestTypeGet(
            int id,
            out string name)
        {
            if (id == -1)
            {
                throw new ArgumentNullException("id");
            }


            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_testtype_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;


            bool bFound = false;
            name = string.Empty;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "XonWatch.XonWatchDB.TestTypesGet: "
                            + " more than one row was returned by "
                            + sqlCommand.CommandText;

                        throw new XonWatchDBException(sErr);
                    }

                    name = (string)sqlDataReader["vc_name"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.TestTypesGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.TestTypesGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return bFound;
        }








        public void ResultSet(

            int envid,
            int scriptid,
            string clientip,
            string command,
            string result,
            int hresult,
            int elapsed,
            string context,
            string message)
        {
            if (string.IsNullOrEmpty(clientip))
            {
                throw new ArgumentNullException("clientip");
            }

            if (envid == 0)
            {
                throw new ArgumentNullException("envid");
            }

            if (string.IsNullOrEmpty(command))
            {
                throw new ArgumentNullException("command");
            }

            if (string.IsNullOrEmpty(result))
            {
                throw new ArgumentNullException("result");
            }

            if (LogToConsole)
            {
                Console.WriteLine("SQL: " + string.Join(", ", envid, scriptid, clientip, command, result, hresult, elapsed, context, message));
                return;
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_result_set";
            sqlCommand.CommandType = CommandType.StoredProcedure;

            sqlCommand.Parameters.Add("@i_environment", SqlDbType.Int).Value     = envid;
            sqlCommand.Parameters.Add("@i_script",      SqlDbType.Int).Value     = scriptid;
            sqlCommand.Parameters.Add("@vc_clientip",   SqlDbType.VarChar).Value = clientip;
            sqlCommand.Parameters.Add("@vc_command",    SqlDbType.VarChar).Value = command;
            sqlCommand.Parameters.Add("@vc_result",     SqlDbType.VarChar).Value = result;
            sqlCommand.Parameters.Add("@i_hresult",     SqlDbType.Int).Value     = hresult;
            sqlCommand.Parameters.Add("@i_elapsed",     SqlDbType.Int).Value     = elapsed;
            sqlCommand.Parameters.Add("@vc_context",    SqlDbType.VarChar).Value = context;
            sqlCommand.Parameters.Add("@vc_message",    SqlDbType.VarChar).Value = message;
            sqlCommand.Parameters.Add("RETURN_VALUE",   SqlDbType.Int).Direction  = ParameterDirection.ReturnValue;

            try
            {
                ExecuteNonQuery(sqlCommand, "XonWatch.XonWatchDB.ClientEnvironmentIdSet");
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception ResultSet(): ExecuteNonQuery: " + e );
            }
        }


        public void LogSet(string message)
        {
            if (LogToConsole)
            {
                Console.WriteLine("SQL: " + message);
                return;
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_log_set";
            sqlCommand.CommandType = CommandType.StoredProcedure;

            sqlCommand.Parameters.Add("@vc_details", SqlDbType.VarChar,255).Value = message;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            try
            {
                ExecuteNonQuery(sqlCommand, "XonWatch.XonWatchDB.LogSet");
            }
            catch (Exception e)
            {

                Console.WriteLine(e.Message);
                Console.WriteLine("Loading failure. Press any key to continue...");
                Console.ReadLine();
            }
        }

        public Hashtable MOMErrorsGet()
        {

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_hresult_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            Hashtable ht = new Hashtable();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int hr = (int)sqlDataReader["i_id"];
                    string name = sqlDataReader["vc_name"].ToString();
                    ht.Add(hr, name);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.HResultListGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.HResultListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }


            return ht;
        }

        //the following functions return data that will be used in the browser portion of the application
        public DataTable ResultsForClientGet(string clientip, int rows)
        {

            if (rows <= 0 || rows > 1000)
            {
                rows = 100;
            }

            DataTable dt = null;
            SqlCommand sqlCommand = null;
            SqlDataAdapter adapter = null;

            try
            {
                sqlCommand = sqlconnection.CreateCommand();
                sqlCommand.CommandText = "p_XonWatchDB_results_for_client_get";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@vc_clientip", SqlDbType.VarChar, 15).Value = clientip;
                sqlCommand.Parameters.Add("@i_rows", SqlDbType.Int).Value = rows;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                adapter = new SqlDataAdapter(sqlCommand);
                dt = new DataTable();

                adapter.Fill(dt);

            }
            catch (SqlException /*sqlException*/)
            {

            }
            finally
            {
                sqlconnection.Close();
            }

            return dt;

        }

        public DataTable ResultsForEnvironmentGet(int envid, int rows)
        {

            if (rows <= 0 || rows > 1000)
            {
                rows = 100;
            }

            DataTable dt = null;
            SqlCommand sqlCommand = null;
            SqlDataAdapter adapter = null;

            try
            {
                sqlCommand = sqlconnection.CreateCommand();
                sqlCommand.CommandText = "p_XonWatchDB_results_for_environment_get";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_environment", SqlDbType.Int).Value = envid;
                sqlCommand.Parameters.Add("@i_rows", SqlDbType.Int).Value = rows;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                adapter = new SqlDataAdapter(sqlCommand);
                dt=new DataTable();

                adapter.Fill(dt);

            }
            catch (SqlException /*sqlException*/)
            {
            }
            finally
            {
                sqlconnection.Close();
            }

            return dt;

        }

        public DataTable ResultsForTestTypeGet(int testtypeid, int rows)
        {

            if (rows <= 0 || rows > 1000)
            {
                rows = 100;
            }

            DataTable dt = null;
            SqlCommand sqlCommand = null;
            SqlDataAdapter adapter = null;

            try
            {
                sqlCommand = sqlconnection.CreateCommand();
                sqlCommand.CommandText = "p_XonWatchDB_results_for_testtype_get";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_testtypeid", SqlDbType.Int).Value = testtypeid;
                sqlCommand.Parameters.Add("@i_rows", SqlDbType.Int).Value = rows;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                adapter = new SqlDataAdapter(sqlCommand);
                dt = new DataTable();

                adapter.Fill(dt);

            }
            catch (SqlException /*sqlException*/)
            {
            }
            finally
            {
                sqlconnection.Close();
                adapter.Dispose();
            }

            return dt;

        }


        public DataTable ResultsForScriptGet(int scriptid, int rows)
        {

            if (rows <= 0 || rows > 1000)
            {
                rows = 100;
            }

            DataTable dt = null;
            SqlCommand sqlCommand = null;
            SqlDataAdapter adapter = null;

            try
            {
                sqlCommand = sqlconnection.CreateCommand();
                sqlCommand.CommandText = "p_XonWatchDB_results_for_script_get";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_testtypeid", SqlDbType.Int).Value = scriptid;
                sqlCommand.Parameters.Add("@i_rows", SqlDbType.Int).Value = rows;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                adapter = new SqlDataAdapter(sqlCommand);
                dt=new DataTable();

                adapter.Fill(dt);

            }
            catch (SqlException /*sqlException*/)
            {

            }
            finally
            {
                sqlconnection.Close();
            }

            return dt;

        }


        public class XonWatchDBException: ApplicationException
        {
            public XonWatchDBException() : base() {}
            public XonWatchDBException(string s) : base(s) {}
            protected XonWatchDBException(
                System.Runtime.Serialization.SerializationInfo si,
                System.Runtime.Serialization.StreamingContext sc
                ) : base(si, sc) {}
            public XonWatchDBException(string s, Exception e) : base(s, e) {}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\remoting\Script.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Net.Mail;
using System.Text;
using System.Threading;
using System.Xml;

namespace Xonwatch
{
    /// <summary>
    /// Summary description for Script.
    /// </summary>
    //[Serializable]
    public class Script : MarshalByRefObject
    {
        static public int scriptidgen = 1000;

        private Queue runQueue;
        private DateTime runStart;
        private XonWatchCommand runCommand;

        private DateTime runErrorTime;

        private AutoResetEvent[] events;

        private const int EvtMessage = 0;
        private const int EvtPause = 1;
        private const int EvtResume = 2;
        private const int EvtReset = 3;
        private const int EvtAbort = 4;
        private const int EvtTypeMax = 5;

        enum ScriptState
        {
            InitQueue,
            NextCommand,
            SendCommand,
            AwaitResponse,
            AwaitRetryDelay,
            AwaitResume,
            AwaitRestart,
            Abort,
            Restart,
            ErrorTimeout,
            ErrorState,
        };

        ScriptState state;

        private Script()
        {
        }

        public Script(int _id, string _name, string _scriptxml)
        {
            this.ID = _id;
            this.Name = _name;
            this.FullText = _scriptxml;


            this.Clients = new Hashtable();
            this.IsReady = false;
            this.IsParsed = false;
            this.Commands = new Queue();

            this.LastMessageID = 0;

            this.Running = false;

            // $REVIEW (michion): This needs to be in the script or environment table, but for now, were using
            //                    5 minutes based on the longest request turnaround that I've observed in testnet
            //                    under stress which was 3 minutes

            this.DefaultCommandTimeout = 300000; // in milliseconds
            this.DefaultRetryTimeout = 15000;  // in milliseconds

            this.TemplateID = 0;
        }

        /* MakeExecutableCopy()
         * ------------------------------------
         * Utilized by the Environment object to create a runnable copy of the
         * script.  An executable copy differs slightly from the 'normal' script
         * object in that its templateid value is non-zero.  This value specifies
         * the id of the script that the executable copy was copied from.  The id
         * field of the executable copy is a controller assigned serial number that
         * allows the controller to distinguish between multiple copies of the same
         * script that may be executing in multiple environments/clients.
         *
         * Parameters:
        */
        public Script MakeExecutableCopy()
        {
            Script newscript = new Script(scriptidgen++, Name, FullText);

            newscript.TemplateID = this.ID;  // save the original script's ID since our id field is an internal identifier now

            newscript.RTD = new RuntimeResponseData();

            return newscript;
        }

        public void RecordResponse(String command, String context, String result, String hresult, String elapsed, String details)
        {
            if (this.RTD != null)
            {
                this.RTD.RecordResponse(command, context, result, hresult, elapsed, details);
            }
        }

        public void SignalPause()
        {
            events[EvtPause].Set();
        }

        public void SignalResume()
        {
            events[EvtResume].Set();
        }

        public void SignalReset()
        {
            events[EvtReset].Set();
        }

        public void SignalAbort()
        {
            events[EvtAbort].Set();
        }

        /// <summary>
        /// Gets a value indicating whether the script is ready to run
        /// </summary>
        public bool IsReady { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the XML was successfully parsed
        /// </summary>
        public bool IsParsed { get; private set; }

        public Hashtable Clients { get; set; }

        public bool IsPaused
        {
            get { return (state == ScriptState.AwaitResume) ? true : false; }
        }

        public int ID { get; private set; }

        public string Name { get; private set; }

        public Environment Parent { get; set; }

        public string RequiredNetwork { get; private set; }

        public string RequiredEnvironment { get; private set; }

        public string NotificationSender { get; private set; }

        public string NotificationRecipient { get; private set; }

        public bool AutoStart { get; private set; }

        public bool NotificationsEnabled { get; private set; }

        public int CountClientsNeeded
        {
            get { return this.ClientsNeeded.Count; }
        }

        public Hashtable ClientsNeeded { get; private set; }

        public Queue Commands { get; private set; }

        public string FullText { get; private set; }

        public int LastMessageID { get; private set; }

        public bool OnlyRunOnce { get; private set; }

        public bool Running { get; private set; }

        public int StatCmdsIssued { get; private set; }

        public int RunPass { get; private set; }

        public int RunErrors { get; private set; }

        public string RunErrorTime
        {
            get
            {
                DateTime zero = new DateTime();

                if (runErrorTime == zero)
                    return "";
                else
                    return runErrorTime.ToString();
            }
        }

        public string RunErrorCmd { get; private set; }

        public string RunErrorText { get; private set; }

        public String RunUptime
        {
            get
            {
                DateTime now = DateTime.Now;
                TimeSpan elapsed = now.Subtract(runStart);

                return String.Format("{0:D2} {1:D2}:{2:D2}:{3:D2}", elapsed.Days, elapsed.Hours, elapsed.Minutes, elapsed.Seconds);
            }
        }

        public String RunClients
        {
            get
            {
                StringBuilder sb = new StringBuilder();

                foreach (DictionaryEntry e in this.Clients)
                {
                    if (sb.Length > 0)
                        sb.Append(", ");

                    sb.Append(((Client)e.Value).Name);
                }

                return sb.ToString();
            }
        }

        public int TemplateID { get; set; }

        public int DefaultCommandTimeout { get; private set; }

        public int DefaultRetryTimeout { get; private set; }

        public RuntimeResponseData RTD { get; set; }

        //builds list of commands
        public bool ParseScriptXml(string _scriptxml)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(_scriptxml);

            // Check if the script should only run once
            XmlNode runOnceNode = xmlDoc.SelectSingleNode("/xonscript/@onlyRunOnce");

            if (runOnceNode != null)
            {
                bool onlyRunOnce = false;

                if (bool.TryParse(runOnceNode.Value, out onlyRunOnce))
                {
                    this.OnlyRunOnce = onlyRunOnce;
                }
            }

            // Set sender and recipient for script failure notifications
            XmlNode notificationNode = xmlDoc.SelectSingleNode("/xonscript/notifications");

            if (notificationNode != null)
            {
                this.NotificationsEnabled = true;
                this.NotificationSender = notificationNode.Attributes["sender"].Value;
                this.NotificationRecipient = notificationNode.Attributes["recipient"].Value;
            }
            else
            {
                this.NotificationSender = "reidmi@microsoft.com";
                this.NotificationRecipient = "reidmi@microsoft.com";
            }

            // Set the environment restriction
            XmlNode environmentNode = xmlDoc.SelectSingleNode("/xonscript/environment");

            // The environment node and its id attribute are required...
            if (environmentNode == null || environmentNode.Attributes["id"] == null)
                throw new ArgumentException("environment node and id attribute is required", "environment");

            this.RequiredEnvironment = environmentNode.Attributes["id"].Value;

            // Set the environment restriction
            XmlNode networkNode = xmlDoc.SelectSingleNode("/xonscript/network");

            // The network node and its id attribute are required...
            if (networkNode == null || networkNode.Attributes["id"] == null)
                throw new ArgumentException("network node and id attribute is required", "network");

            this.RequiredNetwork = networkNode.Attributes["id"].Value;

            // Set the autostart attribute
            XmlNode autostartNode = xmlDoc.SelectSingleNode("/xonscript/autostart");
            if (autostartNode != null && autostartNode.InnerText == "true")
            {
                AutoStart = true;
            }

            // Isolate the client description nodes first.  These are used to determine what
            // types of clients and how many of each type are needed for the script to run
            //
            XmlNodeList clientNodes = xmlDoc.SelectNodes("/xonscript/client");

            if (clientNodes.Count == 0)
            {
                throw new ArgumentException("Script does not specify client requirements: " + clientNodes.Count.ToString(), "xonscript");
            }

            this.ClientsNeeded = new Hashtable();

            foreach (XmlNode node in clientNodes)
            {
                // All these attributes are required...
                if (node.Attributes["id"] == null || node.Attributes["platform"] == null || node.Attributes["role"] == null)
                    throw new ArgumentException("Client node does not contain all three required attributes: id, platform and role", "client");

                string ci = node.Attributes["id"].Value;
                string cp = node.Attributes["platform"].Value;


                // Some yahoo put a duplicate client id value in
                if (this.ClientsNeeded.Contains(ci))
                    throw new ArgumentException("Duplicate id values detected in <client> list", "client");

                this.ClientsNeeded.Add(ci, cp);
            }

            //need to process each node on its own
            XmlNodeList nodes = xmlDoc.SelectSingleNode("/xonscript").ChildNodes;

            foreach (XmlNode node in nodes)
            {
                if (node.GetType() == typeof(System.Xml.XmlComment))
                {
                    continue; // skip any comment nodes
                }

                //standalone command
                if (node.Name == "command")
                {
                    // $REVIEW (michion): Need to validate each command's client specification
                    // against the script level clients specification to prevent out of bounds
                    // array references (when the SendCommand tries to lookup a client IP
                    //
                    XonWatchCommand cmd = GetCommandFromNode(node);
                    this.Commands.Enqueue(cmd);
                }
                else if (node.Name == "block")
                {
                    // Within a block, we support a number of options:
                    // "repeat" controls the number of times the sequence of commands
                    //          in the block will be repeated (default = 1)
                    // "interval" controls during which passes this block will be
                    //          executed (EG a value of 3 would specify that the block
                    //          will execute once every 3 times the script is executed
                    //  "timer" specifies that the block's execution will be governed by
                    //          time and only executed once every n seconds
                    //  "wait"  (in conjunction with "timer") specifies (if true) that the
                    //          script should wait until the timer interval is reached before
                    //          executing a block.  If "wait" is false (or not specified)
                    //          then the script will skip the block if the timer interval
                    //          is not reached
                    //
                    XonWatchCommand closer = null;

                    int repeat = 1;
                    if (node.Attributes["repeat"] != null)
                    {
                        repeat = Convert.ToInt32(node.Attributes["repeat"].Value.ToString());
                    }

                    if (node.Attributes["interval"] != null)
                    {
                        int interval = Convert.ToInt32(node.Attributes["interval"].Value.ToString());

                        if (interval > 0)
                        {
                            XonWatchCommand cmd = new XonWatchCommand();
                            cmd.Name = "interval_start";
                            cmd.IValue = interval;
                            this.Commands.Enqueue(cmd);

                            closer = new XonWatchCommand();
                            closer.Name = "interval_end";
                        }
                    }

                    if (node.Attributes["timer"] != null)
                    {
                        int timer = Convert.ToInt32(node.Attributes["timer"].Value.ToString());

                        if (timer > 0)
                        {
                            XonWatchCommand cmd = new XonWatchCommand();
                            cmd.Name = "timer_start";
                            cmd.IValue = timer;

                            if (node.Attributes["wait"] != null)
                                cmd.WaitTimer = (node.Attributes["wait"].Value.ToString().ToLower() == "true") ? true : false;
                            else
                                cmd.WaitTimer = false;

                            this.Commands.Enqueue(cmd);

                            closer = new XonWatchCommand();
                            closer.Name = "timer_end";
                        }
                    }

                    for (int x = 0; x < repeat; x++)
                    {
                        foreach (XmlNode cmdNode in node.ChildNodes)
                        {
                            if (cmdNode.GetType() == typeof(System.Xml.XmlComment))
                                continue; // skip any comment nodes

                            XonWatchCommand cmd = GetCommandFromNode(cmdNode);
                            this.Commands.Enqueue(cmd);
                        }
                    }

                    if (closer != null)
                    {
                        this.Commands.Enqueue(closer);
                    }

                }
            }

            //TODO : not sure if we should set this here.  Is this diff from parsed?
            this.IsReady = true;
            this.IsParsed = true;

            return true;
        }



        XonWatchCommand GetCommandFromNode(XmlNode thisNode)
        {
            XonWatchCommand cmd = new XonWatchCommand();
            cmd.Name = thisNode.Attributes["name"].Value.ToString();
            cmd.Target = thisNode.Attributes["client"].Value.ToString();

            if (!this.ClientsNeeded.Contains(cmd.Target))
                throw new ArgumentException("Command node '" + cmd.Name + "' specifies an unknown client id: '" + cmd.Target + "'", "client");


            if (thisNode.Attributes["retryCount"] != null)
            {
                cmd.RetryCount = Convert.ToInt32(thisNode.Attributes["retryCount"].Value.ToString());
            }

            if (thisNode.Attributes["retryDelay"] != null)
            {
                cmd.RetryDelay = Convert.ToInt32(thisNode.Attributes["retryDelay"].Value.ToString());
            }

            if (thisNode.Attributes["timeout"] != null)
            {
                cmd.Timeout = Convert.ToInt32(thisNode.Attributes["timeout"].Value.ToString());
            }

            XmlNodeList parameters = thisNode.SelectNodes("param");

            foreach (XmlNode paramnode in parameters)
            {
                if (paramnode.GetType() == typeof(System.Xml.XmlComment))
                    continue; // skip any comment nodes

                ScriptCommandParameter p = new ScriptCommandParameter(paramnode);
                cmd.AddParameter(p);
            }

            return cmd;
        }

        /// <summary>
        /// This method is called asynchronously by the Environment object's ProcessDataLoop thread which is responsible for dequeing messages
        /// coming into the controller and marked as belonging to a particular environment.  The Environment determines which script the message
        /// is intended for and calls the appropriate ProcessResponse method.
        ///
        /// The important thing that this method does is to signal (Set) the AutoResetEvent which the Script's thread is waiting on which is
        /// what allows that thread to react to the client's response (by seeing whether the command succeeded, and deciding determining if
        /// the command should be retried or whether the next command should be dequeued and run, etc.)
        /// </summary>
        /// <param name="command"></param>
        /// <param name="context"></param>
        /// <param name="result"></param>
        /// <param name="hresult"></param>
        /// <param name="elapsed"></param>
        /// <param name="details"></param>
        public void ProcessResponse(String command, String context, String result, String hresult, String elapsed, String details)
        {
            if (Running)
            {
                if (runCommand.FCommandSuccess(result))
                {
                    //-----------------------------------------------------------------
                    // Take all the result info and have it stored in the real time data
                    // object that is associated with this script.  This will ensure
                    // that substitution data will be properly associated
                    //
                    RTD.RecordResponse(command, context, result, hresult, elapsed, details);
                }
                else
                {
                    this.RunErrors++;
                    runErrorTime = DateTime.Now;
                    this.RunErrorCmd = command;
                    this.RunErrorText = details;
                }



                // N.B.  The last thing we do here is to signal the Script's
                // RunScript thread that we received a response.  This must be
                // done after we update the rtd, otherwise we run the risk of
                // losing a race condition where the RunScript might dequeue
                // a new command and use old data in its parameter substitution
                //
                events[EvtMessage].Set();
            }
        }

        /// <summary>
        /// Executes a script object
        /// </summary>
        /// <param name="script">Script object to execute</param>
        public void RunScript(object script)
        {
            bool loop = true;
            Script s = (Script)script;

            Eventing.WriteAppLogEvent(
                EventLogEntryType.Information,
                (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_STARTING),
                0,
                "Script " + s.Name + " with ID " + s.ID + " is starting in " + s.Parent.Name + ".");

            runQueue = new Queue();
            events = new AutoResetEvent[EvtTypeMax];

            events[EvtMessage] = new AutoResetEvent(false);      // Thread client responded event
            events[EvtPause] = new AutoResetEvent(false);      // Thread pause event
            events[EvtResume] = new AutoResetEvent(false);      // Thread resume event
            events[EvtReset] = new AutoResetEvent(false);      // Thread reset event
            events[EvtAbort] = new AutoResetEvent(false);      // Thread abort signal

            state = ScriptState.Restart;

            this.Running = true;

            while (loop)
            {
                switch (state)
                {
                    case ScriptState.Restart:

                        DateTime zero = new DateTime();

                        runQueue.Clear();
                        this.RunPass = 0;
                        runStart = DateTime.Now;

                        this.RunErrors = 0;
                        runErrorTime = zero;
                        this.RunErrorCmd = "";
                        this.RunErrorText = "";

                        this.StatCmdsIssued = 0;

                        state = ScriptState.InitQueue;
                        break;


                    case ScriptState.InitQueue:
                        runQueue = (Queue)Commands.Clone();
                        this.RunPass++;
                        state = ScriptState.NextCommand;
                        break;


                    case ScriptState.NextCommand:
                        state = SetNextCommand();
                        break;


                    case ScriptState.SendCommand:
                        SendCommand();
                        state = ScriptState.AwaitResponse;
                        break;


                    case ScriptState.AwaitResponse:
                    case ScriptState.AwaitRetryDelay:
                    case ScriptState.AwaitResume:
                    case ScriptState.AwaitRestart:
                        state = AwaitResponse(state);
                        break;


                    // TODO: What cleanup do we need to take care of?  Logging?
                    case ScriptState.ErrorTimeout:
                        Eventing.WriteAppLogEvent(
                            EventLogEntryType.Error,
                            (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_TIMEOUT),
                            0,
                            "Script " + s.ID + " in " + (s.Parent).Name + " environment timed out waiting for a client response and will be aborted");

                        if (NotificationsEnabled)
                        {
                            SendEmailNotification(
                                "XeOnWatch script timeout", "Script " + s.ID + " timed out waiting for a client response and will be aborted",
                                NotificationRecipient,
                                NotificationSender);
                        }

                        loop = false;
                        break;

                    case ScriptState.Abort:
                        loop = false;
                        break;

                    // $REVIEW (michion): How to deal with this?
                    case ScriptState.ErrorState:
                        Eventing.WriteAppLogEvent(
                            EventLogEntryType.Error,
                            (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_CRITICAL_ERROR),
                            0,
                            "Script " + s.ID + " in " + (s.Parent).Name + " environment encountered a critical error and has been aborted");

                        if (NotificationsEnabled)
                        {
                            SendEmailNotification(
                                "XeOnWatch script timeout", "Script " + s.ID + " encountered a critical error and has been aborted",
                                NotificationRecipient,
                                NotificationSender);
                        }

                        loop = false;
                        break;


                    // $REVIEW (michion): How to deal with this?
                    default:
                        Eventing.WriteAppLogEvent(
                            EventLogEntryType.Error,
                            (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_UNKNOWN_STATE),
                            0,
                            "Script " + s.ID + " in " + (s.Parent).Name + " environment entered an unknown state " + state.ToString() + " and has been aborted");

                        if (NotificationsEnabled)
                            SendEmailNotification("XeOnWatch script timeout", "Script " + s.ID + " entered an unknown state " + state.ToString() + " and has been aborted", NotificationRecipient, NotificationSender);

                        loop = false;
                        break;

                }
                //                Console.WriteLine("----[" + DateTime.Now.ToString() + "]:New state is [" + ((int)state).ToString() + "]");
            }

            this.Running = false;

            // Now that the script is offline, release the  Client(s) from their engagements
            foreach (DictionaryEntry e in this.Clients)
            {
                ((Client)e.Value).DisengageClient();
            }

            Parent.RemoveScript(ID);

        }

        /// <summary>
        /// This method is responsible for setting the runCommand member of the Script.  This is the high level method that encapsulates
        /// the logic that determines what the script should do next and includes the logic to determine whether a command needs to be
        /// retried (if it failed and is marked as retry eligible) or the next command in the queue should be dequeued and set for
        /// execution
        /// </summary>
        /// <returns>True if a run command has been set, false if the queue has been emptied</returns>
        private ScriptState SetNextCommand()
        {
            // if we have executed a previous command, we need to check
            // whether it succeeded, failed or timed out and to determine
            // if it is necessary to retry the command
            //
            if ((runCommand != null) && (runCommand.FCommandSuccess() == false))
            {
                if (runCommand.RetryAttempt < runCommand.RetryCount)
                {
                    runCommand.RetryAttempt = runCommand.RetryAttempt + 1;
                    return ScriptState.AwaitRetryDelay;
                }
            }

            if (runQueue.Count > 0)
            {
                runCommand = DequeueNextCommand();

                if (runCommand == null)
                {
                    return this.OnlyRunOnce ? ScriptState.Abort : ScriptState.InitQueue;
                }
                else
                {
                    return ScriptState.SendCommand;
                }
            }
            else
            {
                runCommand = null;
                return this.OnlyRunOnce ? ScriptState.Abort : ScriptState.InitQueue;
            }
        }

        /* DequeueNextCommand
         * ------------------------------------
         * This method is responsible for determining the next _executable_
         * command in the script will be.  This method is responsible for
         * handling the rather limited flow control that is currently
         * supported, namely the block timer and interval mechanisms.
         *
         *
         *
         * Parameters:
         *
         * Returns:  true - runCommand is set
         *          false - command queue has been emptied
        */
        private XonWatchCommand DequeueNextCommand()
        {
            XonWatchCommand cmd = null;

            bool skipping = false;
            bool found = false;

            while (found == false)
            {
                // If we've exhausted the queue without finding an eligible node to run
                // we need to
                if (runQueue.Count == 0)
                {
                    return null;
                }
                else
                {
                    cmd = (XonWatchCommand)runQueue.Dequeue();
                }

                switch (cmd.Name)
                {
                    case "interval_start":
                        if (this.RunPass % cmd.IValue == 0)
                        {
                            skipping = false;
                        }
                        else
                        {
                            skipping = true;
                        }


                        break;

                    case "interval_end":
                        skipping = false;
                        break;


                    case "timer_start":
                        DateTime now = DateTime.Now;
                        double elapsed = now.Subtract(cmd.LastExecuted).TotalSeconds;

                        if (elapsed >= cmd.IValue)
                        {
                            cmd.LastExecuted = now;
                            skipping = false;
                        }
                        else
                        {
                            skipping = true;
                        }
                        break;



                    case "timer_end":
                        skipping = false;
                        break;


                    default:
                        if (!skipping)
                            found = true;

                        break;
                }
            }

            //-----------------------------------------------------------------
            // Because the the run queue (runQueue) is a shallow copy of the
            // master one (commands), any modifications that have been made to
            // the XonWatchCommand objects (namely bumps to the retryCount
            // counter, will persist from pass to pass.  Consequently, before
            // we allow this command to be used, we need to reset any modifiable
            // fields that might have been affected in a previous pass (EG the
            // retryAttempt counter)
            //
            cmd.RetryAttempt = 0;

            return cmd;
        }

        /* AwaitResponse
         * ------------------------------------
         * This method is designed to deal with waiting for asynchronous
         * triggers.  This can get complex because the signal we might
         * be wating for (EG a response from a command we issued) may
         * not arrive and in place we might get some input like a script
         * pause/reset/abort signal.
         *
         * Parameters:
         *
         * Returns:
         *
        */
        private ScriptState AwaitResponse(ScriptState initialState)
        {
            ScriptState newState = initialState;
            int msTimeout = 30000;

            //-----------------------------------------------------------------------
            // Based on the state we are in, determine what the appropriate wait
            // timeout is.  The only state where this is superfluous is in the
            // AwaitResume state where we will essentially wait forever and the
            // value selection in this is purely arbitrary
            //
            switch (initialState)
            {
                case ScriptState.AwaitResponse:
                    msTimeout = (runCommand.Timeout > 0) ? runCommand.Timeout : DefaultCommandTimeout;
                    break;

                case ScriptState.AwaitRetryDelay:
                    msTimeout = (runCommand.RetryDelay > 0) ? runCommand.RetryDelay : DefaultRetryTimeout;
                    break;

                case ScriptState.AwaitResume:
                case ScriptState.AwaitRestart:
                    break;

                default:
                    // $REVIEW (michion): Throw an exception?  We shouldn't be able to get here...
                    break;
            }

            //-----------------------------------------------------------------------
            // Ok, time to hurry up and wait!
            //
            int waitResult = WaitHandle.WaitAny(events, msTimeout, false);

            switch (waitResult)
            {
                //-----------------------------------------------------------------------
                // Abort signal is pretty simple since it overrides any other actions
                //
                case EvtAbort:
                    newState = ScriptState.Abort;
                    break;

                //-----------------------------------------------------------------------
                // Reset signal is also pretty simple
                //
                case EvtReset:
                    newState = ScriptState.Restart;
                    break;

                //-----------------------------------------------------------------------
                // Message receipt signal
                //
                case EvtMessage:

                    if (initialState == ScriptState.AwaitResponse)
                    {
                        newState = ScriptState.NextCommand;
                    }
                    else
                    {
                        // We were waiting for a retry delay to expire or for a resume
                        // signal, so whatever message we received wasn't expected
                    }
                    break;

                //-----------------------------------------------------------------------
                // Abort signal is pretty simple since it overrides any other actions
                //
                case EvtPause:
                    switch (initialState)
                    {
                        //---------------------------------------------------------------
                        // If we were already paused, then something weird is up because
                        // the UI should ideally be preventing a resend of a pause.  From
                        // a practical standpoint though, it doesn't really make much
                        // difference if we ignore the event
                        //
                        // $REVIEW (michion): right?
                        //
                        case ScriptState.AwaitResume:
                        case ScriptState.AwaitRestart:
                            break;

                        //---------------------------------------------------------------
                        //
                        //
                        //
                        case ScriptState.AwaitResponse:
                        case ScriptState.AwaitRetryDelay:
                            newState = ScriptState.AwaitResume;
                            break;


                        //---------------------------------------------------------------
                        // If we are awaiting a resume signal (IE the script has been
                        // paused) then we expect the timeout to trigger until we
                        // (hopefully) eventually receive the resume signal
                        //
                        default:
                            break;
                    }
                    break;

                case EvtResume:
                    switch (initialState)
                    {
                        //---------------------------------------------------------------
                        // Just what we've been waiting for, the resume signal!
                        //
                        case ScriptState.AwaitResume:
                            newState = ScriptState.NextCommand;
                            break;

                        //---------------------------------------------------------------
                        // We shouldn't be getting resume event (the control should be
                        // disabled) if the script is in a failed state
                        //
                        case ScriptState.AwaitRestart:
                            break;


                        //---------------------------------------------------------------
                        // $REVIEW (michion): Can we do anything useful here?
                        //
                        case ScriptState.AwaitResponse:
                        case ScriptState.AwaitRetryDelay:
                        default:
                            break;
                    }
                    break;

                //-----------------------------------------------------------------------
                // Wait timeout:  This is where things get interesting
                //
                case WaitHandle.WaitTimeout:
                    switch (initialState)
                    {
                        //---------------------------------------------------------------
                        // If we were waiting for a client to respond and we've timed
                        // out, then we have to consider the client as dead and have the
                        // script deal with it however it chooses
                        //
                        case ScriptState.AwaitResponse:
                            newState = ScriptState.ErrorTimeout;
                            break;

                        //---------------------------------------------------------------
                        // If we were waiting for a retry delay to expire, then we're
                        // happy as can be, since we're done waiting and can proceed with
                        // the next logical step of the script (which would be a retry of
                        // whatever command caused us to entered the retry delay in the
                        // first place)
                        //
                        case ScriptState.AwaitRetryDelay:
                            newState = ScriptState.SendCommand;
                            break;

                        //---------------------------------------------------------------
                        // If we are awaiting a resume signal (IE the script has been
                        // paused) then we expect the timeout to trigger until we
                        // (hopefully) eventually receive the resume signal
                        //
                        case ScriptState.AwaitResume:
                        case ScriptState.AwaitRestart:
                            break;
                    }
                    break;

                default:
                    break;
            }

            return newState;
        }

        /* SendEmailNotification
         * ------------------------------------
         *
         * This method sends an email notification
         *
         * Parameters:
         *
         * subject = subject
         * message = body of message
         * emailAddress = recipient email address
         *
         * Returns:  void
        */
        public static void SendEmailNotification(string subject, string message, string toEmailAddress, string fromEmailAddress)
        {
            MailMessage mailMessage = new MailMessage(fromEmailAddress, toEmailAddress);
            mailMessage.Body = message;
            mailMessage.IsBodyHtml = false;
            mailMessage.Subject = subject;

            SmtpClient smtpClient = new SmtpClient("smtphost");
            smtpClient.UseDefaultCredentials = true;

            try
            {
                smtpClient.Send(mailMessage);
            }
            catch (SmtpException smtpException)
            {
                Eventing.WriteAppLogEvent(EventLogEntryType.Error, (int)(XonWatchRemoting.XeOnWatchEvents.EMAIL_SEND_FAILED), 0, string.Format("Failed to send email. Trying again.\n{0}", smtpException.ToString()));
                try
                {
                    // retry
                    smtpClient.Send(mailMessage);
                }
                catch (SmtpException smtpException2)
                {
                    // give up
                    Eventing.WriteAppLogEvent(EventLogEntryType.Error, (int)(XonWatchRemoting.XeOnWatchEvents.EMAIL_SEND_FAILED_FINAL), 0, string.Format("Failed to send email. Giving up.\n{0}", smtpException2.ToString()));
                }
            }
        }

        /* SendCommand
         * ------------------------------------
         * Script object's 'wrapper' send method which calls, in turn, the
         * parent Enviroment objects SendCommand method
         *
         * The Script level method is responsible for maintaining data
         * that logically is associated with the script, such as when
         * the command was issued, which client it was issued to, etc
         *
         * In actuality, this method only queue's a message for transmission.
         * The actual transmission is asynchronous from this thread.
         *
         *
         * Parameters:
         *
         * Returns:  true - Response was received
         *          false - Timed out waiting for response
        */
        public bool SendCommand()
        {
            ArrayList parameters = new ArrayList();

            // We use the script's RTD (runtime data) object to perform any
            // dynamic parameter substitution.
            //
            foreach (ScriptCommandParameter p in runCommand.Parameters)
            {
                DictionaryEntry entry = new DictionaryEntry();

                entry.Key = p.Name;
                entry.Value = p.Value(RTD);

                parameters.Add(entry);
            }

            // The command's Target string represents a key value that indexes
            // into the clients Hashtable.  From the corresponding Client object,
            // we can extract the IP address that we need to deliver the command
            // to
            //
            if (this.Clients.Contains(runCommand.Target))
            {
                Client target = (Client)this.Clients[runCommand.Target];

                LastMessageID = Parent.SendCommand(target.IPAddress, runCommand.Name, parameters);
                this.StatCmdsIssued++;
                return true;
            }
            else
            {
                Eventing.WriteAppLogEvent(
                    EventLogEntryType.Error,
                    (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_CLIENT_NOT_FOUND),
                    0,
                    "Script=" + this.ID + ", command=" + runCommand.Name + ":  Invalid Target: Could not find a client whose assigned role is " + runCommand.Target);
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\Ini.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace Xonwatch
{

    public class Ini
    {
        private SortedList m_slSections = null;
        private bool m_bChanged = false;

        public bool Changed
        {
            get { return m_bChanged; }
        }

        public void SetSetting(string sSection, string sSetting, string sValue)
        {
            if (sSetting == null)
            {
                throw new ArgumentNullException("sSetting");
            }
            if (sValue == null)
            {
                throw new ArgumentNullException("sValue");
            }

            if(m_slSections == null)
            {
                // no settings yet, create the section list, unless we're trying to remove the setting
                m_slSections = new SortedList();
            }

            // get the sorted list for this section
            SortedList slSettings = (SortedList)m_slSections[sSection.ToUpper()];
            if(slSettings == null)
            {
                // whoops, section doesn't exist yet, so create it
                slSettings = new SortedList();
                m_slSections[sSection.ToUpper()] = slSettings;
            }

            slSettings[sSetting.ToUpper()] = sValue;
            m_bChanged = true;
        }

        public string GetSetting(string sSection, string sSetting)
        {
            if (sSection == null)
            {
                throw new ArgumentNullException("sSection");
            }
            if (sSetting == null)
            {
                throw new ArgumentNullException("sSetting");
            }

            if (m_slSections == null)
            {
                // no sections, no setting, return null to indicate setting doesn't exist
                return null;
            }

            SortedList slSettings = (SortedList)m_slSections[sSection.ToUpper()];
            if (slSettings == null)
            {
                // section doesn't exist, return null to indicate setting doesn't exist
                return null;
            }

            string sValue = (string)slSettings[sSetting.ToUpper()];

            // if setting isn't in list, then sValue is null
            return sValue;
        }

        public SortedList GetSection(string sSection)
        {
            if (sSection == null)
            {
                throw new ArgumentNullException("sSection");
            }

            if (m_slSections == null)
            {
                // no sections, no setting, return null to indicate section doesn't exist
                return null;
            }

            // once we give them the section, they can modify it, so we have
            // to assume they will...
            m_bChanged = true;
            return (SortedList)m_slSections[sSection.ToUpper()];
        }

        public SortedList GetSections()
        {
            // once we give them the sections, they can modify it, so we have
            // to assume they will...
            m_bChanged = true;
            return m_slSections;
        }

        public void Save(string sIniPathAndFileName)
        {
            if (sIniPathAndFileName == null)
            {
                throw new ArgumentNullException("sIniPathAndFileName");
            }

            StreamWriter streamWriter = File.CreateText(sIniPathAndFileName);

            try
            {
                foreach(DictionaryEntry deSection in m_slSections)
                {
                    streamWriter.WriteLine("[" + deSection.Key.ToString().ToUpper() + "]");

                    SortedList slSettings = (SortedList)deSection.Value;

                    foreach(DictionaryEntry deSetting in slSettings)
                    {
                        streamWriter.WriteLine(deSetting.Key.ToString().ToUpper() + "=" + deSetting.Value.ToString());
                    }

                    streamWriter.WriteLine("");
                    m_bChanged = false;
                }
            }
            finally
            {
                streamWriter.Close();
            }
        }

        public Ini()
        {
            m_slSections = null;
        }

        public Ini(string sIniPathAndFileName)
        {
            if (sIniPathAndFileName == null)
            {
                throw new ArgumentNullException("sIniPathAndFileName");
            }

            if (!File.Exists(sIniPathAndFileName))
            {
                throw new ArgumentException("Xbox.Tools.Framework.Ini.ctor: "
                    + "Ini file "
                    + sIniPathAndFileName
                    + " does not exist.",
                    "sIniPathAndFileName");
            }

            m_bChanged = false;
            StreamReader streamReader = File.OpenText(sIniPathAndFileName);
            try
            {
                string sCurSection = "global";
                string sSetting;
                string sValue;

                int iLine;
                string sLine;
                int n;
                for (sLine = streamReader.ReadLine(), iLine=0; sLine != null; sLine = streamReader.ReadLine(), ++iLine)
                {
                    sLine = sLine.Trim();

                    // emtpy line
                    if (sLine == "") 
                        continue;

                    // comment
                    if (sLine.StartsWith(";")) 
                        continue;

                    // new section
                    if (sLine.StartsWith("["))
                    {
                        n = sLine.IndexOf(']');
                        if (n <= 1)
                        {
                            throw new ApplicationException("Format error in ini file: ']' expected on line " + iLine);
                        }

                        sCurSection = sLine.Substring(1, n-1).ToUpper();
                        continue;
                    }

                    // name/value pair
                    n = sLine.IndexOf("=");
                    if (n <= 0)
                    {
                            throw new ApplicationException("Format error in ini file: '=' expected on line " + iLine);
                    }

                    sSetting = sLine.Substring(0, n).Trim().ToUpper();

                    if (n < sLine.Length-1)
                    {
                        sValue = sLine.Substring(n+1).Trim();
                    }
                    else
                    {
                        // no val specified (a=)
                        sValue = "";
                    }

                    if (m_slSections == null)
                    {
                        m_slSections = new SortedList();
                    }
                    if (m_slSections[sCurSection] == null)
                    {
                        m_slSections[sCurSection] = new SortedList();
                    }

                    ((SortedList)(m_slSections[sCurSection]))[sSetting] = sValue;
                }
            }
            finally
            {
                streamReader.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\objd\i386\_generated.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly: System.CLSCompliant(false)]
[assembly: System.Reflection.AssemblyProduct("\r\n      DEPOT\r\n    ")]
[assembly: System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly: System.Reflection.AssemblyFileVersion("12.4.56.0")]

// Generated by the MSBuild WriteCodeFragment class on 10/27/2012 5:29:00 PM.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
// <copyright file="ProjectInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System.ComponentModel;
using System.Diagnostics;
using System.Configuration.Install;
using System.ServiceProcess;

namespace Xonwatch
{
    [RunInstaller(true)]
    public partial class ProjectInstaller : Installer
    {
        /// <summary>
        /// Installer for event log information
        /// </summary>
        private EventLogInstaller eventLogInstaller;

        /// <summary>
        /// Installer for the underlying service process
        /// </summary>
        private ServiceProcessInstaller processInstaller;

        /// <summary>
        /// Installer for the service itself
        /// </summary>
        private ServiceInstaller serviceInstaller;

        public ProjectInstaller()
        {
            // Create the event log installer
            this.eventLogInstaller = new EventLogInstaller()
            {
                Source = Eventing.Source,
            };

            // Create the process installer
            this.processInstaller = new ServiceProcessInstaller()
            {
                Password = null, // No default password
                Username = null, // No default username
            };

            // Create the service installer
            this.serviceInstaller = new ServiceInstaller()
            {
                Description = "XonWatch controller service that sends commands to clients and reports results.",
                DisplayName = "XonWatch Service",
                ServiceName = XonWatchService.Name,
                StartType = ServiceStartMode.Manual,
            };

            // Publish the two installers
            this.Installers.AddRange(new Installer[] { this.eventLogInstaller, this.processInstaller, this.serviceInstaller });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xprofpop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XStorageSmoke.rc
// Copyright (c) Microsoft Corporation.  All rights reserved

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\Program.cs ===
//-----------------------------------------------------------------------
// <copyright file="Program.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.ServiceProcess;

namespace Xonwatch
{
    /// <summary>
    /// Entry point for the XonWatchService
    /// </summary>
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            // This UserInteractive check will return true if the service is ever configured to interact
            // with the desktop, but we're using it now for a few reasons:
            //      1. ServiceInstaller does not currently support the interaction option
            //      2. This preserves the legacy behavior of not requiring a command line parameter
            //      3. If/when desktop interaction is supported via ServiceInstaller, someone would
            //         have to deliberately configure it
            if (System.Environment.UserInteractive)
            {
                bool isInteractiveMode = false;

                if (args.Length > 0)
                {
                    if (args.Length == 2 && args[0].ToUpperInvariant().Equals("/I"))
                    {
                        IPAddress titleIp = null;

                        if (!IPAddress.TryParse(args[1], out titleIp))
                        {
                            Console.WriteLine("Invalid title IP address: " + args[1]);
                            return;
                        }

                        isInteractiveMode = true;
                    }
                    else
                    {
                        Console.WriteLine("Usage: {0} /i titleIp", Path.GetFileName(Assembly.GetExecutingAssembly().Location));
                        return;
                    }
                }

                Console.WriteLine();

                // --------------------12345678901234567890123456789012345678901234567890123456789012345678901234567890
                if (isInteractiveMode)
                {
                    Console.WriteLine("Running in interactive console mode.  For passive console mode, run this program");
                    Console.WriteLine("without any arguments.");
                }
                else
                {
                    Console.WriteLine("Running in passive console mode.  For interactive console mode, run this program");
                    Console.WriteLine("with the /i parameter followed by the title IP of your devkit.");
                }

                Console.WriteLine();

                // Redirect all event and database logging to the console
                Eventing.LogToConsole = true;
                XonWatchDB.LogToConsole = true;

                // Run as a console application
                try
                {
                    if (isInteractiveMode)
                    {
                        // Disable display of heartbeat messages
                        ClientSockets.ClientRecvSocket.ShowHeartbeatMessages = false;

                        XonWatchInteractiveConsole interactiveConsole = new XonWatchInteractiveConsole(args[1]);
                        interactiveConsole.Run();
                    }
                    else
                    {
                        XonWatchService service = new XonWatchService();
                        service.Initialize();
                        service.ServiceThreadProc();
                    }
                }
                catch (Exception ex)
                {
                    ConsoleColor currentColor = Console.ForegroundColor;
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine();
                    Console.WriteLine(ex.Message);
                    Console.WriteLine();
                    Console.WriteLine(ex.StackTrace);
                    Console.WriteLine();
                    Console.ForegroundColor = currentColor;
                }
            }
            else
            {
                // Run as a service
                ServiceBase.Run(new XonWatchService());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XqsToCs\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xprofpop\precomp.h ===
//  Precompiled headers.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

#ifndef __PRECOMP_H
#define __PRECOMP_H

#include <windows.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlconv.h>

#include "wsockntp.h"
#include "xonlinep.h"
#include "wststore.h"

#include "WSOLEDBResult.h"

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\XonWatchInteractiveConsole.cs ===
//-----------------------------------------------------------------------
// <copyright file="XonWatchInteractiveConsole.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Xml;

namespace Xonwatch
{
    public class XonWatchInteractiveConsole
    {
        /// <summary>
        /// Kernel API that allows us to trap ctrl+break events
        /// </summary>
        /// <param name="handler">Callback to be invoked when an event occurs</param>
        /// <param name="add">True if the handler is being added, false if it should be removed</param>
        /// <returns></returns>
        [DllImport("kernel32")]
        private static extern bool SetConsoleCtrlHandler(HandlerRoutine handlerRoutine, bool add);

        /// <summary>
        /// Control types that can be trigged by a console control event
        /// </summary>
        private enum CtrlType
        {
            CTRL_C_EVENT = 0,
            CTRL_BREAK_EVENT = 1,
            CTRL_CLOSE_EVENT = 2,
            CTRL_LOGOFF_EVENT = 5,
            CTRL_SHUTDOWN_EVENT = 6,
        };

        /// <summary>
        /// Callback that handles console control events
        /// </summary>
        /// <param name="ctrlType">Console control event</param>
        /// <returns>True if the event was handled, false if it wasn't</returns>
        private delegate bool HandlerRoutine(CtrlType ctrlType);

        /// <summary>
        /// XonWatch client
        /// </summary>
        private Client client = null;

        /// <summary>
        /// XonWatch environment
        /// </summary>
        private Environment xonWatchEnv = null;

        /// <summary>
        /// Callback handler for console control events
        /// </summary>
        private HandlerRoutine handlerRoutine = null;

        /// <summary>
        /// Most recent exception to be thrown by a command
        /// </summary>
        private Exception lastCommandException = null;

        /// <summary>
        /// Currently running script
        /// </summary>
        private Script runningScript = null;

        /// <summary>
        /// Boolean controlling whether we should quit the program
        /// </summary>
        private bool shouldQuit = false;

        /// <summary>
        /// Title IP address of the devkit
        /// </summary>
        private string titleIp = null;

        /// <summary>
        /// Instantiates the interactive console mode for the XonWatch service
        /// </summary>
        /// <param name="titleIp">Title IP address of the devkit</param>
        public XonWatchInteractiveConsole(string titleIp)
        {
            this.titleIp = titleIp;

            // Register our handler for Ctrl+Break events
            this.handlerRoutine = new HandlerRoutine(HandleConsoleControl);
            SetConsoleCtrlHandler(this.handlerRoutine, true);

            // Perform one-time setup of the XonWatch app object
            App app = App.GetInstance();
            app.Initialize(false);

            // Add a minimal environment and the target devkit
            this.xonWatchEnv = new Environment(1, "xwic-net", "1", "xwic-env", string.Empty, App.GetLocalIP());
            app.AddEnvironment(this.xonWatchEnv.ID, this.xonWatchEnv);

            this.client = new Client(1, "Xenon", this.titleIp, this.titleIp, 1);
            app.AddClient(this.client.ID, this.client);
            ClientSockets.AddOutgoingMessageQueue(this.titleIp);

            this.xonWatchEnv.ProcessData();
            app.StartMessageDistributor();
        }

        /// <summary>
        /// Runs the service in interactive console mode.  This mode displays a command prompt
        /// and accepts commands from the user.
        /// </summary>
        public void Run()
        {
            App app = App.GetInstance();

            // Wait for the client connection to be established
            do
            {
                app.ProcessSockets();
                app.ProcessNotifications();
            } while (this.client.Status == "offline" || !ClientSockets.GetSendSocket(this.client.IPAddress).ReadyForNewSend);

            Console.WriteLine();
            Console.WriteLine("For a list of commands, type \"help\".");

            while (!shouldQuit)
            {
                // Display the command prompt
                Console.WriteLine();
                Console.Write("> ");

                // Read user input
                string input = Console.ReadLine();

                // If the input was empty, ignore it
                if (input == null)
                {
                    continue;
                }

                input = input.Trim();

                if (input.Length == 0)
                {
                    continue;
                }

                // Split the input into a command and its arguments
                string command = null;
                string[] args = null;
                int firstSpaceIndex = input.IndexOf(' ');

                if (firstSpaceIndex > -1)
                {
                    command = input.Substring(0, firstSpaceIndex);
                    args = input.Substring(firstSpaceIndex + 1).Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                }
                else
                {
                    command = input;
                    args = new string[0];
                }

                // Process the command
                try
                {
                    this.ProcessCommand(command, args);
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine();

                    if (command.ToUpperInvariant() == "EXINFO")
                    {
                        // Delicious irony... just dump all info anyway
                        Console.WriteLine(ex.StackTrace);
                    }
                    else
                    {
                        Console.WriteLine("To see more information, type \"exinfo\".");
                    }

                    lastCommandException = ex;
                }
            }

            // Prevent the GC from collecting the unmanaged console control handler
            GC.KeepAlive(this.handlerRoutine);
        }

        /// <summary>
        /// Processes an interactive console command
        /// </summary>
        /// <param name="command">Command to process</param>
        /// <param name="args">Arguments passed to the command</param>
        private void ProcessCommand(string command, string[] args)
        {
            Console.WriteLine();

            switch (command.ToUpperInvariant())
            {
                case "EXINFO":
                    if (this.lastCommandException != null)
                    {
                        Console.WriteLine(this.lastCommandException.Message);
                        Console.WriteLine();
                        Console.WriteLine(this.lastCommandException.StackTrace);
                    }
                    else
                    {
                        Console.WriteLine("No command exceptions have been thrown.");
                    }

                    break;
                case "?":
                case "HELP":
                    // ----------------123457890123457890123457890123457890123457890123457890123457890123457890
                    Console.WriteLine("List of available commands:");
                    Console.WriteLine();
                    Console.WriteLine("    exstack");
                    Console.WriteLine("        Shows the stack trace of the last command exception.");
                    Console.WriteLine();
                    Console.WriteLine("    help");
                    Console.WriteLine("        Displays this help screen.");
                    Console.WriteLine();
                    Console.WriteLine("    runcmd command [paramName paramValue [paramName paramValue ...]]");
                    Console.WriteLine("        Sends a single command (with optional params) to the client.");
                    Console.WriteLine();
                    Console.WriteLine("        command - Name of the command to send");
                    Console.WriteLine("        paramName - Name of the parameter");
                    Console.WriteLine("        paramValue - Parameter value");
                    Console.WriteLine();
                    Console.WriteLine("    runscript scriptFile");
                    Console.WriteLine("        Executes a XeOnWatch XML test script contained in a file.");
                    Console.WriteLine();
                    Console.WriteLine("        scriptFile - Path to local script in an XML or SQL file");
                    Console.WriteLine();
                    Console.WriteLine("    quit");
                    Console.WriteLine("        Quits the program.");
                    break;
                case "Q":
                case "QUIT":
                    this.shouldQuit = true;
                    break;
                case "RUNCMD":
                    if (args.Length == 0)
                    {
                        Console.WriteLine("Incorrect number of arguments.");
                        break;
                    }

                    string[] cmdArgs = null;

                    if (args.Length > 0)
                    {
                        // Parameters must be specified as name value pairs
                        if (args.Length % 2 != 1)
                        {
                            Console.WriteLine("Parameters must be specified as name value pairs.");
                            break;
                        }

                        cmdArgs = new string[args.Length - 1];
                        Array.Copy(args, 1, cmdArgs, 0, cmdArgs.Length);
                    }

                    string scriptXml = CreateSingleCommandXml(args[0], cmdArgs);
                    RunScript("SingleCommand", scriptXml);

                    break;
                case "RUNSCRIPT":
                    if (args.Length != 1)
                    {
                        Console.WriteLine("Incorrect number of arguments.");
                        break;
                    }

                    RunScriptFromFile(args[0]);

                    break;
                default:
                    Console.WriteLine("Unrecognized command: " + command);
                    break;
            }
        }

        /// <summary>
        /// Runs a XeOnWatch XML script against the target devkit
        /// </summary>
        /// <param name="scriptFile">Path to XML script to execute</param>
        private void RunScriptFromFile(string scriptFile)
        {
            // Load the XML file into memory
            string scriptXml = null;

            using (StreamReader scriptStream = File.OpenText(scriptFile))
            {
                scriptXml = scriptStream.ReadToEnd();
            }

            if (Path.GetExtension(scriptFile).ToUpperInvariant().Equals(".SQL"))
            {
                // If this is a SQL file, it should contain an INSERT statement with XML contents.  Here
                // we try to extract just the XML or throw an error if we fail.
                int startIndex = scriptXml.IndexOf("<xonscript", StringComparison.InvariantCultureIgnoreCase);
                int endIndex = scriptXml.IndexOf("</xonscript>", StringComparison.InvariantCultureIgnoreCase);

                if (startIndex < 0 || endIndex < 0 || endIndex < startIndex)
                {
                    throw new ArgumentException(scriptFile + " must contain a single <xonscript>", "scriptFile");
                }

                scriptXml = scriptXml.Substring(startIndex, endIndex - startIndex + "</xonscript>".Length);
            }

            // Get the script name from the XML
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(scriptXml);

            XmlNode scriptNameNode = xmlDoc.SelectSingleNode("/xonscript/@name");

            if (scriptNameNode == null || scriptNameNode.Value.Trim().Length == 0)
            {
                throw new ArgumentException("xonscript element does not have a valid name attribute", scriptFile);
            }

            string scriptName = scriptNameNode.Value.Trim();

            RunScript(scriptName, scriptXml);
        }

        /// <summary>
        /// Runs a XeOnWatch XML script against the target devkit
        /// </summary>
        /// <param name="name">Name of the script</param>
        /// <param name="xml">XML script to execute</param>
        private void RunScript(string name, string xml)
        {
            // Get the App instance.  This object handles the primary communication logic.
            App app = App.GetInstance();
            app.RemoveAllScripts();

            // Create the script object
            Script script = new Script(1, name, xml);
            script.ParseScriptXml(xml);

            // Register the client, environment, and script with the app
            app.AddScript(script.ID, script);

            // Put the client into a Hashtable because that's what the execution method requires
            Hashtable clients = new Hashtable(1);
            clients.Add(this.client.ID.ToString(), this.client);

            // Execute the script
            this.xonWatchEnv.ExecuteScript(script, clients, string.Empty);

            // Wait for the script to start
            Thread.Sleep(100);

            // Our script object isn't the one that gets executed; the service executes a copy.  In
            // interactive console mode, we only run a single script at a time, so get the first
            // script and monitor it.
            IDictionaryEnumerator scriptEnum = this.xonWatchEnv.Scripts;
            if (scriptEnum.MoveNext())
            {
                this.runningScript = scriptEnum.Value as Script;

                if (this.runningScript != null)
                {
                    // Pump the script execution pipeline
                    while (this.runningScript.Running)
                    {
                        app.ProcessSockets();
                        app.ProcessNotifications();
                        Thread.Sleep(0);
                    }
                }
            }
        }

        /// <summary>
        /// Callback invoked when a console control event is fired
        /// </summary>
        /// <param name="ctrlType">Type of console control event</param>
        /// <returns>True if the event was handled, false if it wasn't</returns>
        private bool HandleConsoleControl(CtrlType ctrlType)
        {
            // If a script is currently running, abort it and drop the user back to the
            // interactive console command prompt.
            if (this.runningScript != null && this.runningScript.Running)
            {
                this.runningScript.SignalAbort();
                Console.WriteLine("Aborting script...");
                return true;
            }

            // Script isn't running, let the powers that be handle it
            return false;
        }

        /// <summary>
        /// Creates an XML script that executes a single command
        /// </summary>
        /// <param name="name">Name of the command</param>
        /// <param name="args">Parameters to the command.  Must have an even number of elements representing name value pairs.</param>
        /// <returns>XML contents of the script</returns>
        private string CreateSingleCommandXml(string name, string[] args)
        {
            if (args != null && args.Length % 2 != 0)
            {
                throw new ArgumentException("Single command parameters must be name value pairs", "args");
            }

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.AppendChild(xmlDoc.CreateNode(XmlNodeType.XmlDeclaration, "", ""));

            // Root node
            XmlElement xmlRootElement = xmlDoc.CreateElement("xonscript");
            xmlRootElement.SetAttribute("id", "1");
            xmlRootElement.SetAttribute("name", "SingleCommand");
            xmlRootElement.SetAttribute("onlyRunOnce", "true");

            // Environment
            XmlElement xmlEnvironmentElement = xmlDoc.CreateElement("environment");
            xmlEnvironmentElement.SetAttribute("id", "all");
            xmlRootElement.AppendChild(xmlEnvironmentElement);

            // Network
            XmlElement xmlNetworkElement = xmlDoc.CreateElement("network");
            xmlNetworkElement.SetAttribute("id", "unused");
            xmlRootElement.AppendChild(xmlNetworkElement);

            // Client
            XmlElement xmlClientElement = xmlDoc.CreateElement("client");
            xmlClientElement.SetAttribute("id", "1");
            xmlClientElement.SetAttribute("platform", "Xenon");
            xmlClientElement.SetAttribute("role", "unused");
            xmlRootElement.AppendChild(xmlClientElement);

            // Command
            XmlElement xmlCommandElement = xmlDoc.CreateElement("command");
            xmlCommandElement.SetAttribute("client", "1");
            xmlCommandElement.SetAttribute("name", name);

            // Parameters
            if (args != null && args.Length > 0)
            {
                for (int i = 0; i < args.Length; i += 2)
                {
                    XmlElement xmlParamElement = xmlDoc.CreateElement("param");
                    xmlParamElement.SetAttribute("name", args[i]);
                    xmlParamElement.AppendChild(xmlDoc.CreateTextNode(args[i + 1]));
                    xmlCommandElement.AppendChild(xmlParamElement);
                }
            }

            xmlRootElement.AppendChild(xmlCommandElement);

            xmlDoc.AppendChild(xmlRootElement);

            return xmlDoc.InnerXml;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XqsToSql\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xprofpop\xprofpop.cpp ===
#include "precomp.h"
#include "wststore_i.c"

CAtlMap<CStringW, ULONGLONG> g_UserMap;

void Usage(void)
{
    printf("xprofpop <filename>\r\n");
}

void ErrPrint(
    LPCSTR  szMsg,                
    HRESULT hr
    )
{
    printf("%s failed with error = 0x%08X.\r\n", szMsg, hr);
}

#define TOHEX(c) ((c >= L'0' && c <= L'9') ? (c - L'0') : ((c >= L'a' && c <= L'f') ? (c - L'a' + 10) : 0xFFFF))

HRESULT ParsePUID(
    LPCWSTR     szPUID,
    ULONGLONG&  qwPUID
    )
{
    HRESULT     hr;
    LPCWSTR     szCur = szPUID;

    qwPUID = 0;

    if(wcschr(szPUID, L'\0') - szPUID > 16)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    while(*szCur)
    {
        USHORT c = TOHEX(*szCur);
        if(c == 0xFFFF)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        qwPUID = (qwPUID << 4) + c;
        ++szCur;
    }
    
    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT InsertUserIntoProfile(
    IWSTCommand*    piCommand,
    CStringW&       cszUserName,
    ULONGLONG       qwUserPUID
    )
{
    HRESULT                     hr;
    CComPtr<IMultipleResults>   piResults;
    CComPtr<IWSTHash>           piHash;
    LONG                        lBucket;
    LARGE_INTEGER               liHash;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        WORD wBucket;
        ULONGLONG qwUserPUID;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I2,  sizeof(sParams.wBucket), offsetof(sParams_t, wBucket), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserPUID), offsetof(sParams_t, qwUserPUID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szAcctName), offsetof(sParams_t, szAcctName), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        sizeof(rgwstcpParams)/sizeof(WSTCOMMANDPARAM),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_insert_user (?, ?, ?) }";

    USES_CONVERSION;

    // Check parameters
    if ((qwUserPUID == 0) ||
        (cszUserName.GetLength() == 0))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get the bucket number
    hr = piCommand->QueryInterface(&piHash);
    if(FAILED(hr))
        goto Cleanup;

    liHash.QuadPart = qwUserPUID;
    hr = piHash->HashLARGEINTEGER(liHash, &lBucket);
    if (FAILED(hr))
        goto Cleanup;

    // Set the parameters
    sParams.iRet = -1;
    sParams.wBucket = (WORD)lBucket;
    sParams.qwUserPUID = qwUserPUID;
    strncpy(sParams.szAcctName, W2A(cszUserName), MAX_ACCTNAME_BYTES);
    sParams.szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lBucket,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piResults,
        NULL,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
        goto Cleanup;

    
Cleanup:

    return hr;
}


HRESULT AddFriend(
    IWSTCommand*    piCommand,
    IWSTDTC*        piDTC,
    ULONGLONG       qwUserID,
    CStringW        cszUserName,
    ULONGLONG       qwFriendID,
    CStringW        cszFriendName
    )
{
    HRESULT                     hr;
    CComPtr<IWSTHash>           piHash;
    CComPtr<IMultipleResults>   piResults;
    DWORD                       cRows = 0;
    LONG                        lAddHash;
    LONG                        lAddedHash;
    LARGE_INTEGER               liPUID;

    USES_CONVERSION;

    // Parameter structures
    struct sAddParams_t {
        INT iRet;
        ULONGLONG qwUserID;
        ULONGLONG qwFriendID;
        CHAR szFriendAcctName[MAX_ACCTNAME_BYTES];
    } sAddParams;

    static WSTCOMMANDPARAM rgwstcpAddParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sAddParams.iRet), offsetof(sAddParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAddParams.qwUserID), offsetof(sAddParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAddParams.qwFriendID), offsetof(sAddParams_t, qwFriendID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sAddParams.szFriendAcctName), offsetof(sAddParams_t, szFriendAcctName), NULL}
    };

    WSTCOMMANDINFO wstciAddParams = {
        sizeof(sAddParams),
        &sAddParams,
        sizeof(rgwstcpAddParams)/sizeof(WSTCOMMANDPARAM),
        rgwstcpAddParams
    };

    static WCHAR wszAddCmd[] = L"{ ? = call p_pres_add_friend_V2 (?, ?, ?) }";

    struct sAddedParams_t {
        INT iRet;
        ULONGLONG qwUserID;
        ULONGLONG qwFriendID;
        CHAR szFriendAcctName[MAX_ACCTNAME_BYTES];
    } sAddedParams;

    static WSTCOMMANDPARAM rgwstcpAddedParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sAddedParams.iRet), offsetof(sAddedParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAddedParams.qwUserID), offsetof(sAddedParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAddedParams.qwFriendID), offsetof(sAddedParams_t, qwFriendID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sAddedParams.szFriendAcctName), offsetof(sAddedParams_t, szFriendAcctName), NULL}
    };

    WSTCOMMANDINFO wstciAddedParams = {
        sizeof(sAddedParams),
        &sAddedParams,
        sizeof(rgwstcpAddedParams)/sizeof(WSTCOMMANDPARAM),
        rgwstcpAddedParams
    };

    static WCHAR wszAddedCmd[] = L"{ ? = call p_pres_added_friend_V2 (?, ?, ?) }";

    //
    //  Get hash interface and compute partition numbers
    //

    hr = piCommand->QueryInterface(&piHash);
    if(FAILED(hr))
        goto Cleanup;

    liPUID.QuadPart = qwUserID;
    piHash->HashLARGEINTEGER(liPUID, &lAddHash);

    liPUID.QuadPart = qwFriendID;
    piHash->HashLARGEINTEGER(liPUID, &lAddedHash);

    // Set the parameters
    sAddParams.iRet = -1;
    sAddParams.qwUserID = qwUserID;
    sAddParams.qwFriendID = qwFriendID;
    strncpy(sAddParams.szFriendAcctName, W2A(cszFriendName), MAX_ACCTNAME_BYTES);
    sAddParams.szFriendAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lAddHash,
        wszAddCmd,
        &wstciAddParams,
        (IUnknown **)&piResults,
        piDTC,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for a return
    if((sAddParams.iRet != -1) && (FAILED((HRESULT)sAddParams.iRet)))
    {
        hr = (DWORD) sAddParams.iRet;
        goto Cleanup;
    }

    piResults = NULL;

    // Parameter structures
    // Set the parameters
    sAddedParams.iRet = -1;
    sAddedParams.qwUserID = qwFriendID;
    sAddedParams.qwFriendID = qwUserID;
    strncpy(sAddedParams.szFriendAcctName, W2A(cszUserName), MAX_ACCTNAME_BYTES);
    sAddedParams.szFriendAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lAddedHash,
        wszAddedCmd,
        &wstciAddedParams,
        (IUnknown **)&piResults,
        piDTC,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for a return
    if((sAddedParams.iRet != -1) && (FAILED((HRESULT)sAddedParams.iRet)))
    {
        hr = (DWORD) sAddedParams.iRet;
        goto Cleanup;
    }

Cleanup:

    return hr;
}


HRESULT AcceptFriend(
    IWSTCommand*    piCommand,
    IWSTDTC*        piDTC,
    ULONGLONG       qwPUID1,
    ULONGLONG       qwPUID2
    )
{
    HRESULT                     hr;
    CComPtr<IWSTHash>           piHash;
    CComPtr<IMultipleResults>   piResults;
    DWORD                       cRows = 0;
    LARGE_INTEGER               liPUID;
    LONG                        lHash1;
    LONG                        lHash2;

    // Parameter structures
    struct sAcceptParams_t {
        INT iRet;
        ULONGLONG qwUserID;
        ULONGLONG qwFriendID;
    } sAcceptParams;

    static WSTCOMMANDPARAM rgwstcpAcceptParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sAcceptParams.iRet), offsetof(sAcceptParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAcceptParams.qwUserID), offsetof(sAcceptParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAcceptParams.qwFriendID), offsetof(sAcceptParams_t, qwFriendID), NULL}
    };

    WSTCOMMANDINFO wstciAcceptParams = {
        sizeof(sAcceptParams),
        &sAcceptParams,
        sizeof(rgwstcpAcceptParams)/sizeof(WSTCOMMANDPARAM),
        rgwstcpAcceptParams
    };

    static WCHAR wszAcceptCmd[] = L"{ ? = call p_pres_accept_friend_V2 (?, ?) }";

    struct sAcceptedParams_t {
        INT iRet;
        ULONGLONG qwUserID;
        ULONGLONG qwFriendID;
    } sAcceptedParams;

    static WSTCOMMANDPARAM rgwstcpAcceptedParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sAcceptedParams.iRet), offsetof(sAcceptedParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAcceptedParams.qwUserID), offsetof(sAcceptedParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAcceptedParams.qwFriendID), offsetof(sAcceptedParams_t, qwFriendID), NULL}
    };

    WSTCOMMANDINFO wstciAcceptedParams = {
        sizeof(sAcceptedParams),
        &sAcceptedParams,
        sizeof(rgwstcpAcceptedParams)/sizeof(WSTCOMMANDPARAM),
        rgwstcpAcceptedParams
    };

    static WCHAR wszAcceptedCmd[] = L"{ ? = call p_pres_accepted_friend_V2 (?, ?) }";
    
    //
    //  Get hash interface and compute hashes
    //

    hr = piCommand->QueryInterface(&piHash);
    if(FAILED(hr))
        goto Cleanup;

    liPUID.QuadPart = qwPUID1;
    piHash->HashLARGEINTEGER(liPUID, &lHash1);

    liPUID.QuadPart = qwPUID2;
    piHash->HashLARGEINTEGER(liPUID, &lHash2);

    // Set the parameters
    sAcceptParams.iRet = -1;
    sAcceptParams.qwUserID = qwPUID1;
    sAcceptParams.qwFriendID = qwPUID2;

    // Execute the proc
    hr = piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lHash1,
        wszAcceptCmd,
        &wstciAcceptParams,
        (IUnknown **)&piResults,
        piDTC,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for a return
    if((sAcceptParams.iRet != -1) && (FAILED((HRESULT)sAcceptParams.iRet)))
    {
        hr = (DWORD) sAcceptParams.iRet;
        goto Cleanup;
    }

    piResults = NULL;

    // Parameter structures
    // Set the parameters
    sAcceptedParams.iRet = -1;
    sAcceptedParams.qwUserID = qwPUID2;
    sAcceptedParams.qwFriendID = qwPUID1;

    // Execute the proc
    hr = piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lHash2,
        wszAcceptedCmd,
        &wstciAcceptedParams,
        (IUnknown **)&piResults,
        piDTC,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for a return
    if((sAcceptedParams.iRet != -1) && (FAILED((HRESULT)sAcceptedParams.iRet)))
    {
        hr = (DWORD) sAcceptedParams.iRet;
        goto Cleanup;
    }

Cleanup:

    return hr;
}


HRESULT InsertFriendIntoProfile(
    IWSTCommand*    piCommand,
    ULONGLONG       qwPUID1,
    CStringW        cszUserName1,
    ULONGLONG       qwPUID2,
    CStringW        cszUserName2
    )
{
    HRESULT             hr;
    CComPtr<IWSTDTC>    piDTC;

    hr = piCommand->GetDTC(&piDTC);
    if(FAILED(hr))
        goto Cleanup;

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if(FAILED(hr))
        goto Cleanup;

    hr = AddFriend(piCommand, piDTC, qwPUID1, cszUserName1, qwPUID2, cszUserName2);
    if(FAILED(hr))
        goto Cleanup;

    hr = AcceptFriend(piCommand, piDTC, qwPUID2, qwPUID1);
    if(FAILED(hr))
        goto Cleanup;

    piDTC->CommitTransaction();
    piDTC = NULL;
    
Cleanup:

    if(piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    return hr;
}

HRESULT InsertBlockIntoProfile(
    IWSTCommand*    piCommand,
    ULONGLONG       qwPUID1,
    ULONGLONG       qwPUID2
    )
{
    HRESULT                     hr;
    CComPtr<IWSTDTC>            piDTC;
    CComPtr<IWSTHash>           piHash;
    CComPtr<IMultipleResults>   piResults;
    LARGE_INTEGER               liPUID;
    LONG                        lHash;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        ULONGLONG qwUserID;
        ULONGLONG qwBlockID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBlockID), offsetof(sParams_t, qwBlockID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        sizeof(rgwstcpParams)/sizeof(WSTCOMMANDPARAM),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_add_lockout (?, ?) }";

    // compute hash bucket
    hr = piCommand->QueryInterface(&piHash);
    if(FAILED(hr))
        goto Cleanup;

    liPUID.QuadPart = qwPUID1;
    hr = piHash->HashLARGEINTEGER(liPUID, &lHash);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Start a transaction
    //

    hr = piCommand->GetDTC(&piDTC);
    if(FAILED(hr))
        goto Cleanup;

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if(FAILED(hr))
        goto Cleanup;

    // Set the parameters
    sParams.iRet = -1;
    sParams.qwUserID = qwPUID1;
    sParams.qwBlockID = qwPUID2;

    // Execute the proc
    hr = piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lHash,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piResults,
        NULL,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Check for a return
    if((sParams.iRet != -1) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto Cleanup;
    }

    piDTC->CommitTransaction();
    piDTC = NULL;
    
Cleanup:

    if(piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    return hr;
}

HRESULT PopulateUsers(
    IWSTCommand*        piCommand,
    IXMLDOMDocument*    piConfigDoc
    )
{
    HRESULT                     hr;
    const CComBSTR              cbstrUserNodes(L"xppopulate/users/user");
    const CComBSTR              cbstrName(L"name");
    const CComBSTR              cbstrPUID(L"puid");
    CComPtr<IXMLDOMNodeList>    piUserList;
    LONG                        lNumUsers;
    LONG                        lCurUser;

    hr = piConfigDoc->selectNodes(cbstrUserNodes, &piUserList);
    if(FAILED(hr))
        goto Cleanup;

    hr = piUserList->get_length(&lNumUsers);
    if(FAILED(hr))
        goto Cleanup;

    for(lCurUser = 0; lCurUser < lNumUsers; ++lCurUser)
    {
        CComPtr<IXMLDOMNode>    piUserNode;
        CComPtr<IXMLDOMElement> piUser;
        CComBSTR                cbstrUserName;
        CComBSTR                cbstrUserPUID;
        CComVariant             cvAttr;
        ULONGLONG               qwUserPUID;
        CStringW                cszUserName;

        hr = piUserList->get_item(lCurUser, &piUserNode);
        if(FAILED(hr))
            goto Cleanup;

        hr = piUserNode->QueryInterface(&piUser);
        if(FAILED(hr))
            goto Cleanup;

        hr = piUser->getAttribute(cbstrName, &cvAttr);
        if(FAILED(hr))
            goto Cleanup;

        cszUserName = cvAttr.bstrVal;

        hr = piUser->getAttribute(cbstrPUID, &cvAttr);
        if(FAILED(hr))
            goto Cleanup;

        hr = ParsePUID(cvAttr.bstrVal, qwUserPUID);
        if(FAILED(hr))
            goto Cleanup;

        g_UserMap.SetAt(cszUserName, qwUserPUID);

        hr = InsertUserIntoProfile(piCommand, cszUserName, qwUserPUID);
        if(FAILED(hr))
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


HRESULT PopulateFriends(
    IWSTCommand*        piCommand,
    IXMLDOMDocument*    piConfigDoc
    )
{
    HRESULT                     hr;
    const CComBSTR              cbstrFriendNodes(L"xppopulate/friends/friend");
    const CComBSTR              cbstrUser1(L"user1");
    const CComBSTR              cbstrUser2(L"user2");
    CComPtr<IXMLDOMNodeList>    piFriendList;
    LONG                        lNumFriends;
    LONG                        lCurFriend;

    hr = piConfigDoc->selectNodes(cbstrFriendNodes, &piFriendList);
    if(FAILED(hr))
        goto Cleanup;

    hr = piFriendList->get_length(&lNumFriends);
    if(FAILED(hr))
        goto Cleanup;

    for(lCurFriend = 0; lCurFriend < lNumFriends; ++lCurFriend)
    {
        CComPtr<IXMLDOMNode>    piFriendNode;
        CComPtr<IXMLDOMElement> piFriend;
        CComVariant             cvAttr;
        CStringW                cszUserName1;
        CStringW                cszUserName2;
        ULONGLONG               qwPUID1;
        ULONGLONG               qwPUID2;

        hr = piFriendList->get_item(lCurFriend, &piFriendNode);
        if(FAILED(hr))
            goto Cleanup;

        hr = piFriendNode->QueryInterface(&piFriend);
        if(FAILED(hr))
            goto Cleanup;

        hr = piFriend->getAttribute(cbstrUser1, &cvAttr);
        if(FAILED(hr))
            goto Cleanup;

        cszUserName1 = cvAttr.bstrVal;
        qwPUID1 = g_UserMap[cszUserName1];

        hr = piFriend->getAttribute(cbstrUser2, &cvAttr);
        if(FAILED(hr))
            goto Cleanup;

        cszUserName2 = cvAttr.bstrVal;
        qwPUID2 = g_UserMap[cszUserName2];

        hr = InsertFriendIntoProfile(piCommand, qwPUID1, cszUserName1, qwPUID2, cszUserName2);
        if(FAILED(hr))
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


HRESULT PopulateBlocks(
    IWSTCommand*        piCommand,
    IXMLDOMDocument*    piConfigDoc
    )
{
    HRESULT                     hr;
    const CComBSTR              cbstrBlockNodes(L"xppopulate/blocks/block");
    const CComBSTR              cbstrUser1(L"user1");
    const CComBSTR              cbstrUser2(L"user2");
    CComPtr<IXMLDOMNodeList>    piBlockList;
    LONG                        lNumBlocks;
    LONG                        lCurBlock;

    hr = piConfigDoc->selectNodes(cbstrBlockNodes, &piBlockList);
    if(FAILED(hr))
        goto Cleanup;

    hr = piBlockList->get_length(&lNumBlocks);
    if(FAILED(hr))
        goto Cleanup;

    for(lCurBlock = 0; lCurBlock < lNumBlocks; ++lCurBlock)
    {
        CComPtr<IXMLDOMNode>    piBlockNode;
        CComPtr<IXMLDOMElement> piBlock;
        CComVariant             cvAttr;
        CStringW                cszUserName1;
        CStringW                cszUserName2;
        ULONGLONG               qwPUID1;
        ULONGLONG               qwPUID2;

        hr = piBlockList->get_item(lCurBlock, &piBlockNode);
        if(FAILED(hr))
            goto Cleanup;

        hr = piBlockNode->QueryInterface(&piBlock);
        if(FAILED(hr))
            goto Cleanup;

        hr = piBlock->getAttribute(cbstrUser1, &cvAttr);
        if(FAILED(hr))
            goto Cleanup;

        cszUserName1 = cvAttr.bstrVal;
        qwPUID1 = g_UserMap[cszUserName1];

        hr = piBlock->getAttribute(cbstrUser2, &cvAttr);
        if(FAILED(hr))
            goto Cleanup;

        cszUserName2 = cvAttr.bstrVal;
        qwPUID2 = g_UserMap[cszUserName2];

        hr = InsertBlockIntoProfile(piCommand, qwPUID1, qwPUID2);
        if(FAILED(hr))
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


void __cdecl main(int argc, char** argv)
{
    HRESULT                     hr;
    CComPtr<IWSTStore>          piWebstore;
    CComPtr<IWSTCommand>        piCommand;
    CComPtr<IXMLDOMDocument>    piConfigDoc;
    VARIANT_BOOL                bSuccessful;

    if(argc != 2)
    {
        Usage();
        goto Cleanup;
    }

    //
    //  Initialize COM
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr))
    {
        ErrPrint("Initializing COM", hr);
        goto Cleanup;
    }

    //
    //  Load XML and webstore objects
    //

    hr = piWebstore.CoCreateInstance(CLSID_WSTStore);
    if(FAILED(hr))
    {
        ErrPrint("Creating webstore instance", hr);
        goto Cleanup;
    }

    hr = piConfigDoc.CoCreateInstance(L"Msxml2.DOMDocument");
    if(FAILED(hr))
    {
        ErrPrint("Creating MSXML document instance", hr);
        goto Cleanup;
    }

    //
    //  Initialize webstore
    //

    hr = piWebstore->Initialize(L"uodb");
    if(FAILED(hr))
    {
        ErrPrint("Initializing the uodb webstore application", hr);
        goto Cleanup;
    }

    hr = piWebstore->QueryInterface(&piCommand);
    if(FAILED(hr))
    {
        ErrPrint("Getting webstore command interface", hr);
        goto Cleanup;
    }

    //
    //  Load config file
    //

    hr = piConfigDoc->load(CComVariant(argv[1]), &bSuccessful);
    if(FAILED(hr))
    {
        ErrPrint("Loading configuration document", hr);
        goto Cleanup;
    }

    if(!bSuccessful)
    {
        CComPtr<IXMLDOMParseError>  piError;
        LONG                        lLine;
        CComBSTR                    cbstrReason;

        piConfigDoc->get_parseError(&piError);

        piError->get_line(&lLine);
        piError->get_reason(&cbstrReason);

        printf("Error parsing config file.\r\n\tReason = \"%ls\"\r\n\tLine = %d\r\n",
               (BSTR)cbstrReason,
               lLine);
        goto Cleanup;
    }

    printf("Configuration document loaded successfully.\r\n");

    //
    //  Get the list of users
    //

    hr = PopulateUsers(piCommand, piConfigDoc);
    if(FAILED(hr))
    {
        ErrPrint("PopulateUsers", hr);
        goto Cleanup;
    }

    printf("All users successfully populated.\r\n");

    hr = PopulateFriends(piCommand, piConfigDoc);
    if(FAILED(hr))
    {
        ErrPrint("PopulateFriends", hr);
        goto Cleanup;
    }

    printf("All friend relationships successfully populated.\r\n");

    hr = PopulateBlocks(piCommand, piConfigDoc);
    if(FAILED(hr))
    {
        ErrPrint("PopulateBlocks", hr);
        goto Cleanup;
    }

    printf("All block relationships successfully populated.\r\n");

    hr = piWebstore->DeInitialize();

Cleanup:

    g_UserMap.RemoveAll();

    CoUninitialize();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\XonWatchService.cs ===
//-----------------------------------------------------------------------
// <copyright file="XonWatchService.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.ServiceProcess;
using System.Threading;

namespace Xonwatch
{
    /// <summary>
    /// XonWatch service object that handles initialization and event processing
    /// </summary>
    public class XonWatchService : ServiceBase
    {
        /// <summary>
        /// Name used to identify the Windows Service
        /// </summary>
        public const string Name = "XonWatchService";

        /// <summary>
        /// Application instance
        /// </summary>
        private App appData = null;

        /// <summary>
        /// Main worker thread
        /// </summary>
        private Thread workerThread = null;

        /// <summary>
        /// Creates an instance of XonWatchService
        /// </summary>
        public XonWatchService()
        {
            this.ServiceName = Name;
        }

        /// <summary>
        /// Starts the XonWatchService when running as a Windows Service
        /// </summary>
        /// <param name="args">Arguments to the service binary</param>
        protected override void OnStart(string[] args)
        {
            base.OnStart(args);

            try
            {
                // Initialize config and various threads
                this.Initialize();

                // Start the worker thread
                this.workerThread = new Thread(new ThreadStart(ServiceThreadProc));
                this.workerThread.Start();
            }
            catch (Exception ex)
            {
                string message = "XeOnWatch controller service encountered a problem during initialization:" +
                    System.Environment.NewLine +
                    ex.Message +
                    System.Environment.NewLine +
                    ex.StackTrace;

                // Log an event on failure
                Eventing.WriteAppLogEvent(
                    EventLogEntryType.Error,
                    (int)(XonWatchRemoting.XeOnWatchEvents.SERVICE_ABNORMAL_TERMINATION),
                    0,
                    message);

                // Rethrow so the service actually stops
                throw;
            }
        }

        /// <summary>
        /// Stops the XonWatchService when running as a Windows service
        /// </summary>
        protected override void OnStop()
        {
            this.Cleanup();
            base.OnStop();
        }

        /// <summary>
        /// Cleans up any resources used by the service
        /// </summary>
        public void Cleanup()
        {
            // Terminate the worker thread
            if (this.workerThread != null)
            {
                this.workerThread.Abort();
                this.workerThread.Join();
                this.workerThread = null;
            }
        }

        /// <summary>
        /// Initializes the XonWatchService by reading configuration, connecting to the database,
        /// and starting various threads
        /// </summary>
        public void Initialize()
        {
            this.appData = App.GetInstance();
            this.appData.Initialize(true);
        }

        /// <summary>
        /// Main worker method that processes events and pumps the service
        /// </summary>
        public void ServiceThreadProc()
        {
            try
            {
                Console.WriteLine("Entering main loop.");
                bool firstLaunch = true;

                //this is where the service will loop, primarily.
                while (true)
                {
                    Thread.Sleep(250);

                    //keep main thread alive
                    if (this.appData.RemoteData.bRefreshData == true)
                    {
                        this.appData.LoadData();
                        this.appData.RemoteData.bRefreshData = false;
                    }

                    if (this.appData.RemoteData.bReloadScripts == true)
                    {
                        this.appData.ReloadScripts(); //Reload the scripts if any have changed
                        this.appData.ReloadEnvironments();
                        this.appData.RemoteData.bReloadScripts = false;
                    }

                    //keep making sure that sockets are working
                    //determines whether client is online or not

                    this.appData.ProcessSockets();

                    this.appData.ProcessNotifications();

                    //AppData.CheckForNewScripts();
                    //AppData.CheckForChangedScripts();

                    if (firstLaunch)
                    {
                        this.appData.LaunchAutoStartScripts();
                        firstLaunch = false;
                    }
                }
            }
            catch (ThreadAbortException)
            {
                // Thread aborts are an expected occurrence when someone stops the service
                Console.WriteLine("Exiting main loop.");
            }
            catch (Exception e)
            {
                string message = "XeOnWatch controller service terminated unexpectedly." +
                    System.Environment.NewLine +
                    e.Message +
                    System.Environment.NewLine +
                    e.StackTrace;

                Console.WriteLine(message);
                Eventing.WriteAppLogEvent(
                    EventLogEntryType.Error,
                    (int)(XonWatchRemoting.XeOnWatchEvents.SERVICE_ABNORMAL_TERMINATION),
                    0,
                    message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xsigner\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xsigner\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xStatsConversion\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XonWatch2\service\App.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Threading;

namespace Xonwatch
{
    /// <summary>
    /// Summary description for Global.
    /// </summary>
    public class App
    {
        //declarations
        private static App instance;

        //config settings
        HttpServerChannel channel;
        private string serviceip;
        private XonWatchLog log;

        public XonWatchRemoting RemoteData;

        private SortedList clients;
        private SortedList environments;
        private SortedList networks;
        private SortedList scripts;
        private SortedList testtypes;
        private string currentEnvironment;
        private Hashtable ScriptRunningEvents;
        private Hashtable ClientFailingEvents;
        private Hashtable ClientOfflineEvents;
        private Hashtable PanoramaEvents;
        private Hashtable SQLEvents;
        private Information info;
        private bool bReloadScripts;

        /// <summary>
        /// singleton design
        /// </summary>
        private App()
        {
            info = new Information();
            ScriptRunningEvents = new Hashtable();
            ClientFailingEvents = new Hashtable();
            ClientOfflineEvents = new Hashtable();
            PanoramaEvents = new Hashtable();
            SQLEvents = new Hashtable();
            log = new XonWatchLog(null);
        }

        ~App()
        {
            //cleanup remoting
            RemotingServices.Disconnect(RemoteData);
            ChannelServices.UnregisterChannel(channel);
        }

        public static App GetInstance()
        {
            if(instance == null)
            {
                instance = new App();
            }
            return instance;
        }


        public XonWatchLog DBLog
        {
            get
            {
                return log;
            }
            set
            {
                log = value;
            }
        }

        public XonWatchLog MOMLog
        {
            get
            {
                return log;
            }
            set
            {
                log = value;
            }
        }

        public XonWatchDB XonWatchDBObj { get; private set; }

        public string Database { get; private set; }

        public string DBServer { get; private set; }

        public int SendPort { get; private set; }

        public int RecvPort { get; private set; }

        public int RemotePort { get; private set; }

        //Client access
        public IDictionaryEnumerator Clients
        {
            get
            {
                return (IDictionaryEnumerator)clients.GetEnumerator();
            }
        }

        //clients
        public void AddClient(int id, Client x)
        {
            clients.Add(id, x);
        }

        public void RemoveClient(int id)
        {
            clients.Remove(id);
        }

        public void RemoveAllClients()
        {
            clients.Clear();
        }

        //networks
        public void AddNetwork(int id, Network x)
        {
            networks.Add(id, x);
        }

        public void RemoveNetwork(int id)
        {
            networks.Remove(id);
        }

        //testtypes
        public void AddTestType(int id, TestType x)
        {
            testtypes.Add(id, x);
        }

        //testtypes
        public void AddMOMError(int id, string description)
        {
            XonWatchRemoting.MOMErrors.Add(id, description);
        }

        //environment access
        public IDictionaryEnumerator Environments
        {
            get
            {
                return (IDictionaryEnumerator)environments.GetEnumerator();
            }
        }

        public void AddEnvironment(int id, Environment x)
        {
            environments.Add(id, x);
        }

        public void RemoveEnvironment(int id)
        {
            environments.Remove(id);
        }

        //script access
        public IDictionaryEnumerator Scripts
        {
            get
            {
                return (IDictionaryEnumerator)scripts.GetEnumerator();
            }
        }

        public void AddScript(int id, Script x)
        {
            scripts.Add(id, x);
        }

        public void RemoveScript(int id)
        {
            scripts.Remove(id);
        }

        public void RemoveAllScripts()
        {
            scripts.Clear();
        }

        public bool reloadScripts
        {
            set { bReloadScripts = value; }
            get { return bReloadScripts; }
        }

        // $REVIEW (michion): Is this going to work if we have multiple NICs?
        public static string GetLocalIP()
        {
            string strHostName = Dns.GetHostName();
            IPHostEntry iphostentry = Dns.GetHostEntry(strHostName);
            // Grab the first IP address
            foreach( IPAddress ip in iphostentry.AddressList )
            {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    return ip.ToString();
                }
            }
            return null;
        }

        /// <summary>
        /// Initializes the XonWatchService by reading configuration, connecting to the database,
        /// and starting various threads
        /// </summary>
        public void Initialize(bool initDatabase)
        {
            //get ini settings
            Console.WriteLine("Reading ini settings.");

            string basePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            Ini iniFile = new Ini(Path.Combine(basePath, @"config\xonwatch.ini"));

            this.DBServer = iniFile.GetSetting("SQLServer", "server");
            this.Database = iniFile.GetSetting("SQLServer", "dbname");
            this.SendPort = Convert.ToInt32(iniFile.GetSetting("Socket", "sendport"));
            this.RecvPort = Convert.ToInt32(iniFile.GetSetting("Socket", "recvport"));
            this.RemotePort = Convert.ToInt32(iniFile.GetSetting("Socket", "remoteport"));

            //create remoting object and local reference
            Console.WriteLine("Initializing Remoting object.");
            this.SetUpRemoting();

            if (initDatabase)
            {
                string connectionstr = "data source=" + this.DBServer +
                    ";initial catalog=" + this.Database +
                    ";integrated security=SSPI;" +
                    "Packet Size=16384"; // bigger than usual for faster bulk inserts

                Console.WriteLine("Establishing database connection.");

                this.XonWatchDBObj = new XonWatchDB(connectionstr, this.DBLog);
                this.DBLog.DB = this.XonWatchDBObj;
            }
            else
            {
                this.XonWatchDBObj = new XonWatchDB(null, this.DBLog);
                this.DBLog.DB = this.XonWatchDBObj;
            }

            // $REVIEW (michion): HACK HACK HACK
            XonWatchRemoting.Log = this.DBLog;
            // $REVIEW (michion): HACK HACK HACK

            if (initDatabase)
            {
                Console.WriteLine("Load config data from database.");

                //load all configuration info from the database
                this.LoadData();

                //now that the sockets are made, launch the Environment threads to get and send messages
                IDictionaryEnumerator Environments = this.Environments;
                while (Environments.MoveNext())
                {
                    Environment env = (Environment)Environments.Value;
                    string message = "Starting Environment " + env.ID + " now.";
                    this.DBLog.WriteToBasicLog(message);

                    // Preserve legacy behavior; this line was always logged to the console
                    if (!XonWatchDB.LogToConsole)
                    {
                        Console.WriteLine(message);
                    }

                    env.ProcessData(); //the main loop thread for that environment
                }

                this.StartMessageDistributor();
            }
        }

        /* SetUpRemoting()
         * ------------------------------------
         * This method is used to establish this process as a .NET remoting
         * server of the one and ONLY XonWatchRemoting object.  I'll repeat
         * for clarity that we are NOT using SingleCall or Singleton
         * server activtion here!  The XonWatchRemoting object is designed
         * to be instantiated only once and this code makes that one instance
         * accessible to remote systems by virtue of RemotingServices.Marshall
         *
         * $REVIEW (michion): According to some discussions I saw, we should
         * override InitializeLifetimeServices() to prevent the object from
         * being automatically destroyed after 5 minutes, but I haven't seen
         * this happen...
         *
        */
        public void SetUpRemoting()
        {
             // get local ip
            serviceip = GetLocalIP();


            // In order for the remoting objects to be passable as parameters, the TypeFilterLevel
            // has to be opened up to Full (instead of Default).  This allows calls like
            // Environment.ExecuteScript() to be passed references to remoted Script objects
            //
            // $REVIEW (michion): I'm weirded out by this... if this is allowed, doesn't it allow
            // for a remote object from a different context (EG a different SERVER) to be passed
            // in?  Maybe there's something to do with contexts that I'm not understanding...
            // or is the fact that the object is static going to convince the framework to leave
            // it alone?
            //
            BinaryServerFormatterSinkProvider  srvFormatter = new BinaryServerFormatterSinkProvider();
            srvFormatter.TypeFilterLevel = System.Runtime.Serialization.Formatters.TypeFilterLevel.Full;


            // Register the channel with our formatter and type filter adjustment
            channel = new HttpServerChannel("XonWatchChannel", this.RemotePort, srvFormatter);
            ChannelServices.RegisterChannel(channel, false);


            // The XonWatchRemoting class has a static member with holds a
            // reference to the one instance of the class that everyone must
            // use.  This instance is created during startup which is where
            // SortedList collections for all the management objects are
            // instantiated.  What we do here is set up our own references
            // to these SortedList collections.
            //
            // N.B.  This is really screwy, becuase what happens here
            // in actual practice is that this method is called first, which
            // allows the App class to get references to the SortedList
            // collections, BUT these collections are EMTPY!  The service
            // code will subsequently call App.LoadData() (below) which will
            // populate these collections.  What's confusing about this
            // arrangement (IMO) is that the creation of the containers and
            // the loading of their collections are spread out amongst two
            // disparate classes.
            //
            RemoteData = XonWatchRemoting.RemotedInstance;

            clients         = RemoteData.Clients;
            environments    = RemoteData.Environments;
            networks        = RemoteData.Networks;
            scripts         = RemoteData.Scripts;
            testtypes       = RemoteData.TestTypes;
            bReloadScripts  = RemoteData.bReloadScripts;
            currentEnvironment = RemoteData.CurrentEnvironment;

            RemoteData.Info = info;   // $REVIEW (michion): uh... wtf?  The static XonWatchRemoting
                                      // object already instantiated an Information object, so why
                                      // are we instantiating another one and 'redirecting' the
                                      // static object's reference to ours?

            // This is where the .NET remoting magic happens.  According to
            // my searches, calling this method on an object allows this
            // specific instance to be accessible via remote.  Goofy, but
            // the returned ObjRef is just discarded...
            //
            ObjRef remote = RemotingServices.Marshal(RemoteData, "XonWatchRemoting", typeof(XonWatchRemoting));
        }

        public bool LoadData()
        {
            this.LoadNetworks();
            this.LoadEnvironments();
            this.LoadClients();
            this.LoadScripts();
            this.LoadTestTypes();
            this.LoadMOMErrors();

            return true;
        }

        public bool LoadEnvironments()
        {
            environments.Clear();
            ArrayList environmentids = this.XonWatchDBObj.EnvironmentListGet();
            foreach (int id in environmentids)
            {
                string networkid    = string.Empty;
                string name         = string.Empty;
                string location     = string.Empty;
                string useraccounts = string.Empty;
                this.XonWatchDBObj.EnvironmentGet(id, out networkid, out location, out useraccounts);
                Environment env = new Environment(id, name, networkid, location, useraccounts, serviceip);

                string netname=String.Empty;
                foreach (Network net in this.networks.Values)
                {
                    if (Convert.ToInt32(env.NetworkID)==net.ID)
                    {
                        netname=net.Name;
                    }
                }
                env.Name = netname + "_" + location;
                this.AddEnvironment(id, env);
                this.DBLog.WriteToBasicLog("Loading Environment: " + env.Name);
            }

            return true;
        }

        public bool LoadNetworks()
        {
            networks.Clear();
            ArrayList networkids = this.XonWatchDBObj.NetworkListGet();
            foreach (int id in networkids)
            {
                string name      = string.Empty;
                string xmacsAddr = string.Empty;
                string sgfdAddr  = string.Empty;
                this.XonWatchDBObj.NetworkGet(id, out name, out xmacsAddr, out sgfdAddr);
                Network net = new Network(id, name, xmacsAddr, sgfdAddr);
                this.AddNetwork(id, net);
                this.DBLog.WriteToBasicLog("Loading Network: " + name);
            }

            return true;
        }

        public bool LoadClients()
        {
            clients.Clear();
            ClientSockets.ClearOutgoingMessageQueues();

            //load Client clients
            ArrayList clientids = this.XonWatchDBObj.ClientListGet();
            foreach (int id in clientids)
            {
                string name     = string.Empty;
                string ip       = string.Empty;
                string platform = string.Empty;
                int environment = 0;
                this.XonWatchDBObj.ClientGet(id, out platform, out name, out ip, out environment);
                Client client = new Client(id, platform, ip, name, environment);
                this.AddClient(id, client);

                ClientSockets.AddOutgoingMessageQueue(ip);
                this.DBLog.WriteToBasicLog("Loading Client: " + name);
            }

            return true;
        }

        public void LaunchAutoStartScripts()
        {
            Hashtable runclients;

            foreach (Xonwatch.Script s in scripts.Values)
            {
                runclients = new Hashtable();
                if( s.AutoStart && s.RequiredEnvironment != "all" )
                {
                    foreach (Environment env in environments.Values)
                    {
                        if (env.Location == s.RequiredEnvironment)
                        {
                            foreach (string key in (s.ClientsNeeded).Keys)
                            {
                                foreach (Client c in clients.Values)
                                {
                                    c.UpdateStatus();
                                    if (c.Platform == (string)((s.ClientsNeeded)[key]) &&
                                        ((Environment)(environments[c.EnvironmentID])).Location == env.Location && !c.Engaged)
                                    {
                                        c.EngageClient(key);
                                        runclients[key] = c;
                                        break;
                                    }
                                }
                            }

                            if (runclients.Count < (s.ClientsNeeded).Count || !env.ExecuteScript(s, runclients, s.RequiredNetwork))
                            {
                                foreach (Client c in runclients.Values)
                                {
                                    c.DisengageClient();
                                }

                                Console.WriteLine(s.Name + " script cannot be executed in the " + env + " environment");
                            }
                        }
                    }
                }
            }
        }

        private void ProcessScriptNotifications()
        {
            bool isRunning;
            foreach (Environment env in environments.Values)
            {
                foreach(Script sc in scripts.Values)
                {
                    isRunning = false;
                    if (env.Location == sc.RequiredEnvironment || sc.RequiredEnvironment == "all")
                    {
                        foreach (Script s in (env.scripts).Values)
                        {
                            if (s.TemplateID == sc.ID && s.Running)
                            {
                                isRunning = true;
                                break;
                            }
                        }
                        if (!isRunning && ScriptRunningEvents[sc.ID] == null)
                        {
                            ScriptRunningEvents.Add(sc.ID, env.Location);

                            // wshee: Why do we log this?
                            // Eventing.WriteAppLogEvent(EventLogEntryType.Error, (int)(XonWatchRemoting.XeOnWatchEvents.SCRIPT_NOT_RUNNING), 0, sc.Name + " not running in " + env.Name + " environment.");
                        }
                        else if (isRunning && ScriptRunningEvents[sc.ID] != null && (string)ScriptRunningEvents[sc.ID] == env.Location)
                        {
                            ScriptRunningEvents.Remove(sc.ID);
                        }
                    }
                }
            }
        }

        private void ProcessClientNotifications()
        {
            foreach (Client c in clients.Values)
            {
                c.UpdateStatus();
                if (ClientFailingEvents[c.IPAddress] == null && c.Status == "failing" )
                {
                    ClientFailingEvents.Add(c.IPAddress, true);
                    Eventing.WriteAppLogEvent(EventLogEntryType.Error, (int)(XonWatchRemoting.XeOnWatchEvents.CLIENT_STATUS_FAILING), 0, "Client " + c.Name + " at IP " + c.IPAddress + " in Environment " + c.EnvironmentID + " is " + c.Status + ".");
                }
                else if (ClientFailingEvents[c.IPAddress] != null && (c.Status == "engaged" || c.Status == "online"))
                {
                    ClientFailingEvents.Remove(c.IPAddress);
                }

                if (ClientOfflineEvents[c.IPAddress] == null && c.Status == "offline")
                {
                    ClientOfflineEvents.Add(c.IPAddress, true);
                    Eventing.WriteAppLogEvent(EventLogEntryType.Error, (int)(XonWatchRemoting.XeOnWatchEvents.CLIENT_STATUS_OFFLINE), 0, "Client " + c.Name + " at IP " + c.IPAddress + " in Environment " + c.EnvironmentID + " is " + c.Status + ".");
                }
                else if (ClientOfflineEvents[c.IPAddress] != null && (c.Status == "engaged" || c.Status == "online"))
                {
                    ClientOfflineEvents.Remove(c.IPAddress);
                }
            }
        }

        public void ProcessNotifications()
        {
            //Check to see if all scripts are running
            ProcessScriptNotifications();

            //Environments and tests failing

            //What clients are offline or failing
            ProcessClientNotifications();

            //SQl events
        }

        public void CheckForNewScripts()
        {
            ArrayList _scripts;
            try
            {
                _scripts = this.XonWatchDBObj.ScriptListGet();
            }
            catch
            {
                return; //Can't read from XonWatchDB. Try again next time.
            }
            if (_scripts.Count != scripts.Count)
                RemoteData.bReloadScripts = true;

        }

        public void CheckForChangedScripts()
        {
            string name = string.Empty;
            string text = string.Empty;
            ArrayList _scripts;

            try
            {
                _scripts = this.XonWatchDBObj.ScriptListGet();

                if (_scripts.Count != scripts.Count)
                    RemoteData.bReloadScripts = true;

                foreach (int id in _scripts)
                {
                    this.XonWatchDBObj.ScriptGet(id, out name, out text);
                    Xonwatch.Script scr = new Script(id, name, text);
                    if (scripts[id] != null && ((Script)scripts[id]).FullText != scr.FullText)
                    {
                        RemoteData.bReloadScripts = true;
                        break;
                    }
                }
            }
            catch( Exception e )
            {
                Console.WriteLine(e.Message);
                return; //can't read from the database. try again next time.
            }


        }

        private bool HasEnvironmentChanged( int id )
        {
            bool changed = false;
            string networkid = string.Empty;
            string location = string.Empty;
            string useraccounts = string.Empty;
            if (environments[id] == null)
                changed = true;
            else
            {
                this.XonWatchDBObj.EnvironmentGet(id, out networkid, out location, out useraccounts);
                if (((Environment)environments[id]).NetworkID != networkid || ((Environment)environments[id]).Location != location)
                    changed = true;
            }
            return changed;
        }

        public void ReloadEnvironments()
        {
            ArrayList environmentids = this.XonWatchDBObj.EnvironmentListGet();
            //Look for environments that have changed or have been added and add or update accordingly
            foreach (int id in environmentids)
            {
                string name = string.Empty;
                string useraccounts = string.Empty;
                string location = string.Empty;
                string networkid = string.Empty;

                if (HasEnvironmentChanged(id))
                {
                    this.XonWatchDBObj.EnvironmentGet(id, out networkid, out location, out useraccounts);
                    Environment env = new Environment(id, name, networkid, location, useraccounts, serviceip);

                    string netname = String.Empty;
                    foreach (Network net in this.networks.Values)
                    {
                        if (Convert.ToInt32(env.NetworkID) == net.ID)
                        {
                            netname = net.Name;
                        }
                    }
                    env.Name = netname + "_" + location;
                    if (environments[id] != null)
                        this.RemoveEnvironment(id);
                    this.AddEnvironment(id, env);
                    this.DBLog.WriteToBasicLog("Loading Environment: " + env.Name);
                }
            }

            //Look for environments that have been deleted and remove them
            if (environments.Count > environmentids.Count)
            {
                bool found;
                SortedList CurrentEnvironments = new SortedList(environments);
                foreach (Environment env in CurrentEnvironments.Values)
                {
                    found = false;
                    foreach (int id in environmentids)
                    {
                        if (env.ID == id)
                        {
                            found = true;
                            break;
                        }
                    }
                    if( !found )
                        RemoveEnvironment(env.ID);
                }
            }
        }

        public void ReloadScripts()
        {
            ArrayList _scripts;

            try
            {
                _scripts = this.XonWatchDBObj.ScriptListGet();
            }
            catch
            {
                return; //Can't read from XonWatch database. Try again next time.
            }

            foreach (int id in _scripts)
            {
                string name = string.Empty;
                string text = string.Empty;
                this.XonWatchDBObj.ScriptGet(id, out name, out text);
                Xonwatch.Script scr = new Script(id, name, text);

                try
                {
                    if (scr.ParseScriptXml(text) && scripts[id] == null)
                    {
                        this.AddScript(id, scr);
                        this.DBLog.WriteToBasicLog("loading newly added script: " + name);
                    }
                    else if (scr.ParseScriptXml(text) && ((Script)scripts[id]).FullText != text)
                    {
                        this.RemoveScript(id);
                        this.AddScript(id, scr);
                        this.DBLog.WriteToBasicLog("Reloading Script: " + name);
                    }
                    else if (!scr.ParseScriptXml(text))
                    {
                        this.RemoveScript(id);
                        this.DBLog.WriteToBasicLog("Unloading Script: " + name + " because it failed to parse.");
                    }
                }
                catch (ArgumentException e)
                {
                    this.DBLog.WriteToBasicLog("Failed parsing Script: " + name + "\n" + e.ToString());
                    Console.WriteLine("Failed parsing Script: " + name + "\n" + e.ToString());
                    if( scripts[id] != null )
                        this.RemoveScript(id);
                }
            }
        }

        public bool LoadScripts()
        {
            scripts.Clear();
            //load scripts
            ArrayList _scripts = this.XonWatchDBObj.ScriptListGet();
            foreach (int id in _scripts)
            {
                string name = string.Empty;
                string text = string.Empty;
                this.XonWatchDBObj.ScriptGet(id, out name, out text);
                Xonwatch.Script scr = new Script(id, name, text);

                try
                {
                    scr.ParseScriptXml(text);
                    this.AddScript(id, scr);
                    this.DBLog.WriteToBasicLog("Loading Script: " + name);
                }
                catch (ArgumentException e)
                {
                    this.DBLog.WriteToBasicLog("Failed parsing Script: " + name + "\n" + e.ToString());
                    Console.WriteLine("Failed parsing Script: " + name + "\n" + e.ToString());
                }
            }

            return true;
        }

        public bool LoadTestTypes()
        {
            testtypes.Clear();
            //load testtypes
            ArrayList _testtypes = this.XonWatchDBObj.TestTypeListGet();
            foreach (int id in _testtypes)
            {
                string name = string.Empty;
                this.XonWatchDBObj.TestTypeGet(id, out name);
                Xonwatch.TestType ttype = new TestType(id, name);
                this.AddTestType(id, ttype);
                this.DBLog.WriteToBasicLog("Loading TestType: " + name);
            }

            return true;
        }


        public bool LoadMOMErrors()
        {
            XonWatchRemoting.MOMErrors.Clear();
            //load scripts
            Hashtable _MOMErrors = this.XonWatchDBObj.MOMErrorsGet();
            IDictionaryEnumerator de = _MOMErrors.GetEnumerator();
            while (de.MoveNext())
            {
                this.AddMOMError(Convert.ToInt32(de.Key), de.Value.ToString());
            }

            this.DBLog.WriteToBasicLog("Loading MOM Errors.");

            return true;
        }

        //create sockets for all clients
        //clients are loosely associated with environments, so that we
        //do not have to bind them here
        public bool ProcessSockets()
        {
            try
            {
                foreach (Client c in clients.Values)
                {
                    if (ClientSockets.GetSendSocket(c.IPAddress) == null)
                    {
                        Console.WriteLine("Attempting connection to " + c.IPAddress + " .");
                        ClientSockets.CreateSendSocket(c.IPAddress, this.SendPort);
                    }
                    else
                    {
                        c.SendSocket = true;

                        //round-robin send of messages from main loop
                        //should be no blocking
                        if (ClientSockets.GetSendSocket(c.IPAddress).ReadyForNewSend)
                        {
                            ClientSockets.SendNextMessage(c.IPAddress);
                        }
                    }

                    //check client heartbeat
                    if (ClientSockets.GetRecvSocket(c.IPAddress) != null)
                    {
                        ClientSockets.ClientRecvSocket s = (ClientSockets.ClientRecvSocket)ClientSockets.GetRecvSocket(c.IPAddress);
                        TimeSpan span = DateTime.Now.Subtract(s.heartbeat);
                        if (Math.Abs(span.TotalSeconds) > 90)   // 90 = 30 seconds x 3 retries: If the client hasn't pinged us (or we've missed them) after 3 intervals, call it quits
                        {
                            Console.WriteLine("Recv socket for " + c.IPAddress + " is stale and being removed.");
                            ClientSockets.DeleteSockets(c.IPAddress);

//                            ClientSockets.RemoveRecvSocket(c.IPAddress);
                            c.SendSocket = false;
                            c.RecvSocket = false;

                            Eventing.WriteAppLogEvent(EventLogEntryType.Warning, (int)(XonWatchRemoting.XeOnWatchEvents.CLIENT_RECV_SOCKET_STARVING), 0, "Recv socket for " + c.IPAddress + " has not received any data in over 90 seconds and has been removed");
                        }
                        else
                        {
                            c.RecvSocket = true;
                        }
                    }
                    else
                    {
                        c.RecvSocket = false;
                    }

                    //Listener should always be available
                    if (ClientSockets.Listener == null)
                    {
                        this.DBLog.WriteToBasicLog("Creating listener socket on " + this.serviceip);
                        ClientSockets.StartListener(this.serviceip,this.RecvPort);
                    }
                }
            }
            catch (Exception e)
            {
                this.DBLog.WriteToBasicLog(e.Message);
            }

            return true;
        }



        public void StartMessageDistributor()
        {
            ThreadPool.QueueUserWorkItem(new WaitCallback(DistributeMessages));
        }

        //This pops incoming messages off the incoming messages queue where all the sockets post messages
        //It grabs all received messages and adds them to the correct environments
        //while getting new messages from each of the environments
        //basically, this is the Xonwatch service mailman
        private void DistributeMessages(object AppData)
        {
            while(true)
            {
                Thread.Sleep(250);

                //for load balancing, we'll process as many incoming messages
                //as outgoing messages
                foreach (Environment env in environments.Values)
                {
                    //process incoming
                    XonWatchMessage incoming = ClientSockets.GetNextIncomingMessage();
                    Environment env2 = null;
                    if (incoming != null)
                    {
                        env2 = (Environment)environments[incoming.EnvID];

                        // env2 can be null if you stop the service, remove an environment, and restart it
                        // before the client responds to a command from the first iteration.  This can easily
                        // happen if you switch to interactive mode while a test is running.
                        if (env2 != null)
                        {
                            env2.SetNextIncomingMessage(incoming);
                        }
                    }

                    //process outgoing
                    XonWatchMessage msg = env.GetNextOutgoingMessage();
                    if (msg != null)
                    {
                        ClientSockets.SetNextOutgoingMessage(msg);
                    }
                }
            }
        }

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XqsToCs\xqstocs.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.XPath;
using System.Threading;
using System.Collections;
using xonline.common.service;
using xonline.tools.framework;
using System.Text.RegularExpressions;

namespace xonline.tools.xqstocs 
{
    public class XqsToCs
    {
        
        // hack: CXqsParse.parseDataset has a bug in it, where an xqs
        // with multiple title nods will duplicate the datasets query list.
        // It doesn't cause harm with the sql generation, so I'm leaving it for
        // now.   This is a quick hack to get around it. 
        // 
        static ArrayList _classNames = new ArrayList();
        
        
        public static void Main(string[] args)
        {
            string filename;
            StreamWriter writer;
            StringBuilder cs = new StringBuilder();
                        
            if (args.Length == 0)
            {
                Help();
                return;
            }    
            
            try
            {
                
                StreamReader reader = File.OpenText(args[0]);
                //StreamReader reader = File.OpenText("elimination.xqs");
                string xml = reader.ReadToEnd();
                reader.Close();
                
                Console.WriteLine("Parsing " + args[0] + "...");
                
                
                XPathDocument doc = new XPathDocument(new StringReader(xml));                                  
                XPathNavigator root = doc.CreateNavigator();
                
                XPathNodeIterator tIterator = root.Select("/querysim/title");
                if (tIterator.Count == 0)
                {
                    throw new Exception("No title nodes!!");
                }
                
                tIterator.MoveNext();
                string name = tIterator.Current.GetAttribute("name", "");
                name = nameToVarName(name);
                
                XPathNodeIterator dsIterator = root.Select("/querysim/title/dataset");
                if (dsIterator.Count == 0)
                {
                    throw new Exception("No dataset nodes!!");
                }
                
                
                writeHeader(cs, args[0], name);
                
                while (dsIterator.MoveNext())
                {
                    int id = SafeConvert.ToInt32(dsIterator.Current.GetAttribute("id", ""));

                    CXqsParse.Dataset ds = CXqsParse.parseDataset(dsIterator.Current, id);
                    writeDataset(cs, ds);
                }
                
                writeFooter(cs);
                
                
                filename = Path.GetFileNameWithoutExtension(args[0]) + ".cs";
                using(writer = File.CreateText(filename))
                {
                    Console.WriteLine("Writing dataset classes to " + filename + "...");
                    writer.Write(cs.ToString());
                }
                
                Console.WriteLine("done!");
            }
            catch(Exception e)
            {
                Console.WriteLine(e.ToString());
            }
                
                
        }
        
        public static void writeHeader(StringBuilder cs, string filename, string name)
        {
            cs.Append("// Autogenerated from " + filename + " on " + DateTime.Now);
            cs.Append("// DO NOT MAKE CHANGES TO THIS FILE!  They will not be reflected the next time \r\n");
            cs.Append("// this file is generated.\r\n");
            cs.Append("\r\n");
            cs.Append("using System;\r\n");
            cs.Append("using xonline.common.protocol;\r\n");
            cs.Append("using xonline.server.query.test.dvt;\r\n");
            cs.Append("using xonline.common.service;\r\n");
            cs.Append("using xonline.common;\r\n");
            cs.Append("\r\n");
            cs.Append("namespace xonline.server.query.plugins");
            if (name != "") cs.Append("." + name);
            cs.Append("\r\n");
            
            cs.Append("{\r\n");
        }
        
        static void writeFooter(StringBuilder cs)
        {
            cs.Append("}\r\n");
        }

            
        public static void writeDataset(StringBuilder cs, CXqsParse.Dataset ds)
        {
            
            writeAdd(cs, ds);
            
            for (int i = 0; i < ds.queries.Count; i++)
            {
                CXqsParse.Query q = (CXqsParse.Query)ds.queries[i];
        
                if (_classNames.Contains(nameToVarName(q.name)))
                {
                    // do nothing
                    return;
                }
                _classNames.Add(nameToVarName(q.name));
                    
                switch (q.op)
                {
                case "search":
                    writeSearch(cs, ds, q);
                    break;
                
                case "findids":
                    writeFindIds(cs, ds, q);
                    break;   
                
                case "update":
                    writeUpdate(cs, ds, q);
                    break;
                    
                case "remove":
                    writeRemove(cs, ds, q);
                    break;
                    
                case "updateid":
                    writeUpdateId(cs, ds, q);
                    break;
                    
                case "custom":
                    writeCustom(cs, ds, q);
                    break;
                
                case "removeid":
                    // nothing to do
                    break;
                    
                default:
                    throw new Exception("Unknown query type: " + q.op);
                }                                 
            }    
            
        }
        
        public static void writeAdd(StringBuilder cs, CXqsParse.Dataset ds)
        {
            string className = "Add" + nameToVarName(ds.name);
            
            if (_classNames.Contains(className))
            {
                // do nothing
                return;
            }
            
            _classNames.Add(className);
                

            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromColumns(cs, ds, ds.columns, className);
            writePropsFromColums(cs, ds, ds.columns);
            
            cs.Append("#if XQRY\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        \r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
        }
            
        public static void writeRemove(StringBuilder cs, CXqsParse.Dataset ds, CXqsParse.Query q)
        {
            string className = nameToVarName(q.name);
            
            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromParams(cs, ds, q.parameters, null, className);
            writePropsFromParams(cs, ds, q.parameters);
            
            cs.Append("#if XQRY\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", Attribs);        \r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
        }
   
        public static void writeUpdate(StringBuilder cs, CXqsParse.Dataset ds, CXqsParse.Query q)
        {
            string className = nameToVarName(q.name);

            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromParams(cs, ds, q.parameters, null, className);
            writePropsFromParams(cs, ds, q.parameters);
            
            cs.Append("#if XQRY\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
        }

        public static void writeUpdateId(StringBuilder cs, CXqsParse.Dataset ds, CXqsParse.Query q)
        {
            string className = nameToVarName(q.name);
            
            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromParams(cs, ds, q.parameters, null, className);
            writePropsFromParams(cs, ds, q.parameters);
            
            cs.Append("#if XQRY\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", entityId, Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", entityId, Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
        }

        public static void writeSearch(StringBuilder cs, CXqsParse.Dataset ds, CXqsParse.Query q)
        {
            string className = nameToVarName(q.name);
            

            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromParams(cs, ds, q.parameters, q.returns, className);
            writePropsFromParams(cs, ds, q.parameters);

            cs.Append("#if XQRY\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, uint datasetId, out " + className + "Results[] results)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            uint totalResults;\r\n");
            cs.Append("            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);\r\n");
            cs.Append("        }\r\n");
            cs.Append("\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out " + className + "Results[] results)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            results = null;\r\n");
            cs.Append("            QueryAttribute[,] attribResults;\r\n");
            cs.Append("            uint hr = Dataset.Search(source, titleId, datasetId, 0x" + q.id.ToString("x") + ", page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);\r\n");
            cs.Append("\r\n");
            cs.Append("            if (HResult.Succeeded(hr) && attribResults != null)\r\n");
            cs.Append("            {\r\n");
            cs.Append("                results = new " + className + "Results[attribResults.GetLength(0)];\r\n");
            cs.Append("                for (int i = 0; i < results.Length; i++)\r\n");
            cs.Append("                {\r\n");
            cs.Append("                    results[i] = new " + className + "Results(attribResults, i);\r\n");
            cs.Append("                }\r\n");
            cs.Append("            }\r\n");
            cs.Append("\r\n");
            cs.Append("            return hr;    \r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public uint Execute(uint titleId, uint datasetId, out " + className + "Results[] results)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            uint totalResults;\r\n");
            cs.Append("            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);\r\n");
            cs.Append("        }\r\n");
            cs.Append("\r\n");
            cs.Append("        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out " + className + "Results[] results)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            results = null;\r\n");
            cs.Append("            QueryAttribute[] attribResults;\r\n");
            cs.Append("            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x" + q.id.ToString("x") + ", page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);\r\n");
            cs.Append("            if (HResult.Succeeded(hr) && attribResults != null)\r\n");
            cs.Append("            {\r\n");
            cs.Append("                results = new " + className + "Results[attribResults.Length / Specs.Length];\r\n");
            cs.Append("                for (int i = 0; i < results.Length; i++)\r\n");
            cs.Append("                {\r\n");
            cs.Append("                    results[i] = new " + className + "Results(attribResults, i * Specs.Length);\r\n");
            cs.Append("                }\r\n");
            cs.Append("            }\r\n");
            cs.Append("            \r\n");
            cs.Append("            return hr;    \r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
            
            className += "Results";
            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromReturns(cs, ds, q.returns, className);
            writePropsFromReturns(cs, ds, q.returns);
            
            cs.Append("    }\r\n");
            cs.Append("\r\n");
            
        }

        public static void writeFindIds(StringBuilder cs, CXqsParse.Dataset ds, CXqsParse.Query q)
        {
            string className = nameToVarName(q.name);

            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromParams(cs, ds, null, q.returns, className, true);


            cs.Append("#if XQRY\r\n");
            cs.Append("        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out " + className + "Results[] results)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            results = null;\r\n");
            cs.Append("            QueryAttribute[,] attribResults;\r\n");
            cs.Append("            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x" + q.id.ToString("x") + ", entityIds, Specs, out attribResults);\r\n");
            cs.Append("\r\n");
            cs.Append("            if (HResult.Succeeded(hr))\r\n");
            cs.Append("            {\r\n");
            cs.Append("                results = new " + className + "Results[attribResults.GetLength(0)];\r\n");
            cs.Append("                for (int i = 0; i < results.Length; i++)\r\n");
            cs.Append("                {\r\n");
            cs.Append("                    results[i] = new " + className + "Results(attribResults, i);\r\n");
            cs.Append("                }\r\n");
            cs.Append("            }\r\n");
            cs.Append("\r\n");
            cs.Append("            return hr;    \r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out " + className + "Results[] results)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            uint totalResults;\r\n");
            cs.Append("            results = null;\r\n");
            cs.Append("            QueryAttribute[] attribResults;\r\n");
            cs.Append("            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x" + q.id.ToString("x") + ", Specs, entityIds, out totalResults, out attribResults);\r\n");
            cs.Append("            if (HResult.Succeeded(hr))\r\n");
            cs.Append("            {\r\n");
            cs.Append("                results = new " + className + "Results[attribResults.Length / Specs.Length];\r\n");
            cs.Append("                for (int i = 0; i < results.Length; i++)\r\n");
            cs.Append("                {\r\n");
            cs.Append("                    results[i] = new " + className + "Results(attribResults, i * Specs.Length);\r\n");
            cs.Append("                }\r\n");
            cs.Append("            }\r\n");
            cs.Append("            \r\n");
            cs.Append("            return hr;    \r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
            
            className += "Results";
            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromReturns(cs, ds, q.returns, className);
            writePropsFromReturns(cs, ds, q.returns);
            
            cs.Append("    }\r\n");
            cs.Append("\r\n");
            
        }

        public static void writeCustom(StringBuilder cs, CXqsParse.Dataset ds, CXqsParse.Query q)
        {
            string className = nameToVarName(q.name);
            
            cs.Append("    public class " + className + "\r\n");
            cs.Append("    {\r\n");
            
            writeCtorFromParams(cs, ds, q.parameters, null, className);
            writePropsFromParams(cs, ds, q.parameters);
            
            cs.Append("#if XQRY\r\n");
            cs.Append("        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return Dataset.ExecCustom(source, titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", entityId, Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#else\r\n");
            cs.Append("        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x" + q.id.ToString("x") + ", entityId, Attribs);\r\n");
            cs.Append("        }\r\n");
            cs.Append("#endif\r\n");
            cs.Append("    }\r\n");
            cs.Append("\r\n");
        }




        
        public static void writeCtorFromColumns(StringBuilder cs, CXqsParse.Dataset ds, ArrayList columns, string className)
        {
            cs.Append("        public QueryAttribute[] Attribs;\r\n");
            cs.Append("        public " + className + "()\r\n");
            cs.Append("        {\r\n");
            
            // NOTE: subtract 3 for the bi_entity_id, bi_owner_id, and dt_change_datetime columns
            cs.Append("            Attribs = new QueryAttribute[" + (columns.Count-3) + "];\r\n");
            for (int i = 3; i < columns.Count; i++)
            {
                CXqsParse.Column col = (CXqsParse.Column)columns[i];
                
                string line = "            Attribs[" + (i-3) + "] = new QueryAttribute(0x" + col.id.ToString("x8");
                if (col.defaultVal != "" && col.defaultVal != null)
                {
                    line += ", ";
                    if (col.type == "blob")
                        line += "new byte[] { " + col.defaultVal + "} ";
                    else
                        line += col.defaultVal.Replace('\'', '"');
                }
                line += ");";
                
                
                line = line.PadRight(60);
                cs.Append(line);
                cs.Append("// " + col.name + "\r\n");
                
            }
            cs.Append("        }\r\n");
            cs.Append("\r\n");
        }
        
        public static void writeCtorFromParams(StringBuilder cs, CXqsParse.Dataset ds, ArrayList parameters, ArrayList results, string className)
        {
            writeCtorFromParams(cs, ds, parameters, results, className, false);
        }    
        public static void writeCtorFromParams(StringBuilder cs, CXqsParse.Dataset ds, ArrayList parameters, ArrayList results, string className, bool isStatic)
        {
            string s = (isStatic ? "static " : "");
            
            if (parameters != null)
            {
                cs.Append("        public " + s + "QueryAttribute[] Attribs;\r\n");
            }    
            
            if (results != null)
            {
                cs.Append("        public " + s + "QueryAttributeSpec[] Specs;\r\n");
            }
            
            cs.Append("\r\n");
            cs.Append("        " + (isStatic ? s : " public ") + className + "()\r\n");
            cs.Append("        {\r\n");
            
            if (parameters != null)
            {
                cs.Append("            Attribs = new QueryAttribute[" + parameters.Count + "];\r\n");
                for (int i = 0; i < parameters.Count; i++)
                {
                    CXqsParse.Param p = (CXqsParse.Param)parameters[i];
                    CXqsParse.Column c = null;
                    if (ds.colmap.ContainsKey(p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK))
                    {
                        c = CXqsParse.GetColumn(ds, p.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK);
                    }    
                    
                    string line = "            Attribs[" + i + "] = new QueryAttribute(0x" + p.id.ToString("x8");
                    if (c != null && c.defaultVal != "" && c.defaultVal != null)
                    {
                        line += ", ";
                        if (c.type == "blob")
                            line += "new byte[] { " + c.defaultVal + "} ";
                        else
                            line += c.defaultVal.Replace('\'', '"');
                    }
                    line += ");";
                    
                    line = line.PadRight(66);
                    cs.Append(line);
                    cs.Append("// " + p.name + "\r\n");
                    
                }
            }
                        
            if (results != null)
            {
                cs.Append("\r\n");
                cs.Append("            Specs = new QueryAttributeSpec[" + (results.Count+1) + "];\r\n");
                cs.Append("            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID\r\n");
                
                for (int i = 0; i < results.Count; i++)
                {
                    CXqsParse.Return r = (CXqsParse.Return)results[i];
                    CXqsParse.Column c = CXqsParse.GetColumn(ds, r.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK);
                    
                    string line = "            Specs[" + (i+1) + "] = new QueryAttributeSpec(0x" + r.id.ToString("x8") + ", " + c.maxlen + ");";
                    line = line.PadRight(66);
                    cs.Append(line);
                    cs.Append("// " + c.name + "\r\n");
                }
            }
            
            
            cs.Append("        }\r\n");
            cs.Append("\r\n");
        }
        
        
        public static void writeCtorFromReturns(StringBuilder cs, CXqsParse.Dataset ds, ArrayList returns, string className)
        {
            
            cs.Append("        QueryAttribute[] _attribs;\r\n");
            cs.Append("        int _startIndex;\r\n");
            cs.Append("        \r\n");
            cs.Append("        public " + className + "(QueryAttribute[] attribResults, int startIndex)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            _attribs = attribResults;\r\n");
            cs.Append("            _startIndex = startIndex;\r\n");
            cs.Append("        }\r\n");
            
            cs.Append("        public " + className + "(QueryAttribute[,] attribResults, int index)\r\n");
            cs.Append("        {\r\n");
            cs.Append("            _attribs = new QueryAttribute[attribResults.GetLength(1)];\r\n");
            cs.Append("            for (int i = 0; i < _attribs.Length; i++)\r\n");
            cs.Append("            {\r\n");
            cs.Append("                _attribs[i] = attribResults[index, i];\r\n");
            cs.Append("            }    \r\n");
            cs.Append("            _startIndex = 0;\r\n");
            cs.Append("        }\r\n");
        }
        
        public static void writePropsFromReturns(StringBuilder cs, CXqsParse.Dataset ds, ArrayList returns)
        {
            
            cs.Append("        public ulong EntityId\r\n");
            cs.Append("        {\r\n");
            cs.Append("            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }\r\n");
            cs.Append("            set { _attribs[0 + _startIndex].Value = value; }\r\n");
            cs.Append("        }\r\n");
            cs.Append("\r\n");
            
            for (int i = 0; i < returns.Count; i++)
            {
                CXqsParse.Return r = (CXqsParse.Return)returns[i];
                CXqsParse.Column c = CXqsParse.GetColumn(ds, r.id &~ XOn.X_ATTRIBUTE_DATAFLAG_MASK);
                
                string name = (r.name == "" ? c.name : r.name);
                name = nameToVarName(name);

                string type = c.type;
                if (type == "int")
                {
                    type = "long";
                }
                else if (type == "blob")
                {
                    type = "byte[]";
                }
                    
                cs.Append("        public " + type + " " + name + "\r\n");
                cs.Append("        {\r\n");
                cs.Append("            get { return (" + type + ")_attribs[" + (i+1) + " + _startIndex].Value; }\r\n");
                cs.Append("            set { _attribs[" + (i+1) + " + _startIndex].Value = value; }\r\n");
                cs.Append("        }\r\n");
                cs.Append("\r\n");
            }    
        }

        
        public static void writePropsFromColums(StringBuilder cs, CXqsParse.Dataset ds, ArrayList columns)
        {
            for (int i = 3; i < columns.Count; i++)
            {
                CXqsParse.Column col = (CXqsParse.Column)columns[i];
                
                string name = nameToVarName(col.name);

                string type = col.type;
                if (col.type == "int")
                {
                    type = "long";
                }
                else if (col.type == "blob")
                {
                    type = "byte[]";
                }
                    
                cs.Append("        public " + type + " " + name + "\r\n");
                cs.Append("        {\r\n");
                cs.Append("            get { return (" + type + ")Attribs[" + (i-3) + "].Value; }\r\n");
                cs.Append("            set { Attribs[" + (i-3) + "].Value = value; }\r\n");
                cs.Append("        }\r\n");
                cs.Append("\r\n");
            }    
        }
            
        public static void writePropsFromParams(StringBuilder cs, CXqsParse.Dataset ds, ArrayList parameters)
        {
            for (int i = 0; i < parameters.Count; i++)
            {
                CXqsParse.Param p = (CXqsParse.Param)parameters[i];
                
                string name = nameToVarName(p.name);

                string type = p.type;
                if (p.type == "int")
                {
                    type = "long";
                }
                else if (p.type == "blob")
                {
                    type = "byte[]";
                }
                    
                cs.Append("        public " + type + " " + name + "\r\n");
                cs.Append("        {\r\n");
                cs.Append("            get { return (" + type + ")Attribs[" + i + "].Value; }\r\n");
                cs.Append("            set { Attribs[" + i + "].Value = value; }\r\n");
                cs.Append("        }\r\n");
                cs.Append("\r\n");
            }    
        }







            
        static string nameToVarName(string name)
        {
            StringBuilder bldr = new StringBuilder();
        
            
            name = Regex.Replace(name, "^XONLINE_QUERY_ATTR_", "");
            name = Regex.Replace(name, "^XONLINE_COMP_ATTR_", "");
            name = Regex.Replace(name, "^XONLINE_COMP_ML_", "");
            name = Regex.Replace(name, "^att_", "");
            name = Regex.Replace(name, "^p_", "");
            
            string[] words = name.Split( new char[] { ' ', '_' } );
            
            for (int i = 0; i < words.Length; i++)
            {
                string word = words[i];
                word = word.ToLower();
                word = Char.ToUpper(word[0]) + word.Substring(1);
                bldr.Append(word);
            }
            
            return bldr.ToString();
        }
                
          
          
        public static void Help()
        {
            Console.WriteLine("xqsToSql.exe <file.xqs>");
            Console.WriteLine("");
            Console.WriteLine("     Produces c# classes from an XQS file.");
        }
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xsigner\XSignerMain.cs ===
using System;
using System.Text;
using System.IO;
using System.Security.Cryptography;

using xonline.common.tools.console;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;

namespace XSignerMain
{
    static class XSignerAppEntry
    {
        private static void Main(string[] args)
        {
            NamedArgParser argParser = new NamedArgParser(new string[] { "Help", "FileToSign", "Outfile", "DebugOnStart"});
            bool parsed = argParser.Parse(args);

            if (argParser["DebugOnStart"] != null)
            {
                System.Diagnostics.Debugger.Break();
            }

            string fileToSign = argParser["FileToSign"];
            string outFile = argParser["Outfile"];

            if (!parsed || String.IsNullOrEmpty(fileToSign) || String.IsNullOrEmpty(outFile) || argParser["help"] != null)
            {
                Console.WriteLine(HelpString);
                return;
            }

            try
            {
                Console.WriteLine("Writing header for file {0} to file {1}...", fileToSign, outFile);
                Utils.WriteFileBytes(XSigProxy.GetSignedHeader(Utils.GetFileBytes(fileToSign)), outFile);
                Console.WriteLine("Success");
            }
            catch (Exception e)
            {
                Console.WriteLine("XSigner failed with exception {0}.", e);
            }

        }

        private static string HelpString
        {
            get
            {
                if (String.IsNullOrEmpty(_helpString))
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendLine("Signs a file with the GetSignedHeader service api.");
                    sb.AppendLine("XSigner /FileToSign:<file_to_sign> /Outfile:<header_file>");
                    sb.AppendLine("XSigner /Help");
                    sb.AppendLine("If you pass in the /DebugOnStart parameter, this will fire a debugger break on start.");

                    _helpString = sb.ToString();
                }
                return _helpString;
            }
        }

        private static string _helpString;
    }

    static class Utils
    {
        public static byte[] GetFileBytes(string fileName)
        {
            FileInfo fileInfo = new FileInfo(fileName);
            using (BinaryReader reader = new BinaryReader(new FileStream(fileName, FileMode.Open)))
            {
                return reader.ReadBytes((int)fileInfo.Length);
            }
        }

        public static void WriteFileBytes(byte[] bytes, string fileName)
        {
            using (FileStream fs = new FileStream(fileName, FileMode.Create))
            {
                using (BinaryWriter writer = new BinaryWriter(fs))
                {
                    writer.Write(bytes);
                }
            }
        }
    }

    static class XSigProxy
    {
        public static byte[] GetSignedHeader(byte[] fileBytesToSign)
        {
            uint hr = HResult.S_OK;

            // Build the request to send to xsig.
            GetSignedHeaderRequest request = new GetSignedHeaderRequest();
            request.fileSize = (uint)fileBytesToSign.Length;
            request.fileType = GetSignedHeaderRequest.ONLY_LEGAL_FILE_TYPE;
            request.fileHash = (new SHA1Managed()).ComputeHash(fileBytesToSign);

            // Call accross to xsig.
            GetSignedHeaderResponse response = new GetSignedHeaderResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xsig_int, request.Xrl, null, request, ref xrlo);

            // Do some error checking on the response.
            if (HResult.Failed(hr))
            {
                throw new Exception(String.Format("Proxy call to xsig failed with hresult {0:X8}. Check event viewer for error.", hr));
            }

            if (response.headerSize != response.header.Length)
            {
                throw new Exception(String.Format(
                    "Actual size of the header returned ({0}) is different than the headerSize returned ({1}). That's fishy.",
                    response.header.Length, response.headerSize));
            }

            return response.header;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\XqsToSql\xqstosql.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;

using System.Threading;
using xonline.common.service;
using xonline.tools.framework;

namespace xonline.tools.xqstosql 
{
    public class XqsToSql
    {
        public static void Main(string[] args)
        {
            string[] qdbSql;
            string[] npdbSql;
            int i;
            string filename;
            bool dropTables = false;
            StreamWriter writer;
                        
            if (args.Length == 0)
            {
                Help();
                return;
            }    
            
            try
            {
                if (args.Length == 2 && args[1].ToLower().IndexOf("drop") != -1)
                {
                    dropTables = true;
                }
                    
                    
                StreamReader reader = File.OpenText(args[0]);
                //StreamReader reader = File.OpenText("elimination.xqs");
                string xml = reader.ReadToEnd();
                reader.Close();
                
                Console.WriteLine("Parsing " + args[0] + "...");
                
                CXqsParse.XqsParse(xml, 0, dropTables, 1, out qdbSql, out npdbSql);
                
                filename = Path.GetFileNameWithoutExtension(args[0]) + ".querydb.sql";
                using(writer = File.CreateText(filename))
                {
                    Console.WriteLine("Writing query db commands to " + filename + "...");
                    
                    for (i = 0; i < qdbSql.Length; i++)
                    {
                        writer.Write(qdbSql[i]);
                        writer.Write("\r\ngo\r\n");
                    }
                }
                
                    
                filename = Path.GetFileNameWithoutExtension(args[0]) + ".npdb.sql";
                using(writer = File.CreateText(filename))
                {
                    Console.WriteLine("Writing npdb db commands to " + filename + "...");
                    
                    for (i = 0; i < npdbSql.Length; i++)
                    {
                        writer.Write(npdbSql[i]);
                        writer.Write("\r\ngo\r\n");
                        
                    }
                }
                
                
                Console.WriteLine("done!");
            }
            catch(Exception e)
            {
                Console.WriteLine(e.ToString());
            }
                
        }
        
        public static void Help()
        {
            Console.WriteLine("xqsToSql.exe <file.xqs>");
            Console.WriteLine("");
            Console.WriteLine("     Produces SQL files from an XQS file.");
        }
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\xStatsConversion\xstatsconversion.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.IO;
using System.Data.SqlTypes;
using System.Collections;
using System.Text;

using xonline.common.config;
using xonline.common.tools.console;
using xonline.common.service;

namespace nick2utf8
{
    class App
    {
        static void Main(string[] args)
        {
            if (args.Length != 3)
            {
                Console.WriteLine("xstatsconversion <conversion file> <v1 stats server> <v1 stats db>");
                Console.WriteLine("  Conversion file is a comma delimited text file of:");
                Console.WriteLine("  <tileid>,<inh server>,<sql server>");
                Console.WriteLine("  i.e. 4D53004B,SeaXePoolInh001,SeaxeTitlSqlv01");

                return;
            }


            SqlConnection cxn = null;
            Hashtable map = new Hashtable();
            ArrayList notfound = new ArrayList();


            try
            {
                Console.WriteLine("-- Loading " + args[0] + "...");

                using (StreamReader txtreader = File.OpenText(args[0]))
                {
                    string line = txtreader.ReadLine();
                    while (line != null)
                    {
                        string[] parts = line.Split(new char[] {','});
                        if (parts.Length != 3)
                        {
                            Console.WriteLine("Invalid line found in " + args[0] + "! '" + line + "'");
                            return;
                        }

                        uint titleid = Convert.ToUInt32(parts[0], 16);
                        map.Add(titleid, parts[1]);

                        line = txtreader.ReadLine();
                    }
                }



                cxn = new SqlConnection("Data Source="+ args[1] + ";Initial Catalog=" + args[2] + ";Integrated Security=SSPI;Timeout=2400");

                Console.WriteLine("-- Connecting to " + args[1] + ".." + args[2] + "...");

                cxn.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = cxn;


                cmd.CommandText = @"
                    select i_title_id,
                    'exec dbo.p_stats_lb_add ''!!SERVERNAME!!'', '
                    + cast( i_title_id as varchar(50) ) + ', '
                    + cast( i_leader_board_type as varchar(50) ) + ', '
                    + cast( ti_reset_type as varchar(5) ) + ', '
                    + cast(
                        (case i_max_rating_count
                            when 0 then 0
                            else 1
                        end) as varchar(5) ) + ', '
                    + cast( ti_IsTeam as varchar(5) ) + ', '
                    + cast( ti_ReqArbitration as varchar(5) ) + ', '
                    + cast( i_decay_days as varchar(5) ) + ', '
                    + '''' + substring( vc_params, charindex( 'ELO_E=', vc_params) + 6, charindex( ';', vc_params, 0) - ( charindex( 'ELO_E=', vc_params) + 6)) + '''' + ', '
                    + substring( vc_params, charindex( 'ELO_K=', vc_params) + 6, charindex( ';', vc_params, charindex( 'ELO_K=', vc_params) ) - ( charindex( 'ELO_K=', vc_params) + 6)) + ', '
                    + substring( vc_params, charindex( 'ELO_NEW=', vc_params) + 8, charindex( ';', vc_params, charindex( 'ELO_NEW=', vc_params) ) - ( charindex( 'ELO_NEW=', vc_params) + 8)) + ', '
                    + '''' + substring( vc_params, charindex( 'ELO_C=', vc_params) + 6, 1000) + '''' + ', '
                    + cast( i_att_count as varchar(50) )+ ', '
                    + cast( i_max_att_size as varchar(50) )
                    from t_leader_board
                    where vc_params <> ''

                    union

                    select i_title_id,
                    'exec dbo.p_stats_lb_add ''!!SERVERNAME!!'', '
                    + cast( i_title_id as varchar(50) ) + ', '
                    + cast( i_leader_board_type as varchar(50) ) + ', '
                    + cast( ti_reset_type as varchar(5) ) + ', '
                    + cast(
                        (case i_max_rating_count
                            when 0 then 0
                            else 1
                        end) as varchar(5) ) + ', '
                    + cast( ti_IsTeam as varchar(5) ) + ', '
                    + cast( ti_ReqArbitration as varchar(5) ) + ', '
                    + cast( i_decay_days as varchar(5) ) + ', '
                    -- E default
                    + '''E'','
                    -- K default
                    + '120,' +
                    -- New default
                    + '500,' +
                    -- C default
                    + '''0:40,1000:20,1500:10'',' +
                    + cast( i_att_count as varchar(50) )+ ', '
                    + cast( i_max_att_size as varchar(50) )
                    from t_leader_board
                    where vc_params = ''";

                SqlDataReader reader = cmd.ExecuteReader();

                while (reader.Read())
                {
                    uint titleid = (uint)reader.GetInt32(0);
                    string line = reader.GetString(1);

                    if (!map.Contains(titleid))
                    {
                        if (!notfound.Contains(titleid))
                            notfound.Add(titleid);

                        continue;
                    }

                    line = line.Replace("!!SERVERNAME!!", (string)map[titleid]);

                    Console.WriteLine(line);
                }

                reader.Close();

                Console.WriteLine("");
                Console.WriteLine("-- title limits");
                Console.WriteLine("");

                cmd.CommandText = "select i_titleId, i_maxWrites, i_MaxReads from t_titleconfig";
                reader = cmd.ExecuteReader();

                while (reader.Read())
                {
                    Console.WriteLine("exec dbo.p_stats_title_set_limits " + reader.GetInt32(0) + ", " + reader.GetInt32(1) + ", " + reader.GetInt32(2));
                }


                reader.Close();

                Console.WriteLine("");
                Console.WriteLine("-- competitions");
                Console.WriteLine("");



                cmd.CommandText = "select i_titleId, i_templateid, ti_reset_type, " +
                    "i_max_rating_count, ti_isTeam, ti_reqarbitration, i_decay_days, i_att_count, i_max_att_size, vc_params " +
                    "from t_CompetitionTemplate";

                reader = cmd.ExecuteReader();
                while (reader.Read())
                {
                    if (reader.GetString(9) != "")
                    {
                        throw new Exception("Unhanlded case where comp template has elo settings!!");
                    }

                    Console.WriteLine("exec dbo.p_stats_competition_template_add " + reader.GetInt32(0) + ", " + reader.GetInt32(1) + "," + reader.GetByte(2) + "," +
                        (reader.GetInt32(3) == 0 ? "0" : "1") + "," + reader.GetByte(4) + "," + reader.GetByte(5) + "," + reader.GetInt32(6) + ", '10','100','500','0:40'," +
                        reader.GetInt32(7) + "," + reader.GetInt32(8));

                }


                reader.Close();


                cmd.CommandText = "select i_titleId, ti_partition, i_lbIdSeed from t_CompetitionPartition";

                reader = cmd.ExecuteReader();

                while (reader.Read())
                {

                    uint titleid = (uint)reader.GetInt32(0);

                    if (!map.Contains(titleid))
                    {
                        if (!notfound.Contains(titleid))
                            notfound.Add(titleid);

                        continue;
                    }

                    Console.WriteLine("exec dbo.p_stats_competition_partition_add '" + (string)map[titleid] + "', " + reader.GetInt32(0) + ", " + reader.GetByte(1));
                }

                reader.Close();

                if (notfound.Count > 0)
                {
                    Console.WriteLine("-----------------");
                    Console.WriteLine("-- " + args[0] + " did not contain mappings for the following titles!");
                    foreach (uint titleid in notfound)
                    {
                        Console.WriteLine("-- " + titleid.ToString("x"));
                    }
                }

            }
            catch(Exception e)
            {
                Console.WriteLine(e.ToString());
                return;
            }
            finally
            {
                if (cxn != null) cxn.Close();
            }

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Default.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm1 {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Default.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm1 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GeneralReadOnly);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Automation\AutomationClient.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Xml.Linq;

namespace YellowDoor.Automation
{
    public class AutomationClient
    {
        public AutomationClient(string server, string environment)
        {
            _client = new AutomationContract();
            _client.Url = server;
            _client.Credentials = CredentialCache.DefaultCredentials;
            _environment = environment;
        }

        // Group Management
        public Guid CreateGroup(string name, string creator)
        {
            return _client.CreateGroup(_environment, name, creator);
        }

        public Group GetGroupInfo(Guid id)
        {
            return _client.GetGroupInfo(_environment, id);
        }

        public GroupSummary[] GetAllGroupSummaries()
        {
            return _client.GetAllGroupSummaries(_environment);
        }

        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId)
        {
            return _client.AddConsoleIdsToGroup(_environment, consoleIds, groupId);
        }

        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId)
        {
            return _client.RemoveConsoleIdsFromGroup(_environment, consoleIds, groupId);
        }

        public string[] GetConsoleIdsForGroup(Guid groupId)
        {
            return _client.GetConsoleIdsForGroup(_environment, groupId);
        }

        // Propping
        public bool IsFlashPropped(uint version)
        {
            return _client.IsFlashPropped(_environment, version);
        }

        public string PropTitleUpdate(uint titleId, string cabFilePath)
        {
            return _client.PropTitleUpdate(_environment, titleId, cabFilePath);
        }

        public string PropFlash(string cabFilePath)
        {
            return _client.PropFlash(_environment, cabFilePath);
        }

        public string PropRelease(string releaseName, string releaseFilePath, bool isXITRelease)
        {
            return _client.PropRelease(_environment, releaseName, releaseFilePath, isXITRelease);
        }

        public void AssignFlashReleaseToGroup(string releaseName, Guid groupId)
        {
            _client.AssignFlashReleaseToGroup(_environment, releaseName, groupId);
        }

        // LiveHive
        public LiveHiveSettingsEntry[] GetSettings(Guid groupId, ushort BuildId)
        {
            return _client.GetSettings(_environment, groupId, BuildId);
        }

        public LiveHiveSettingsEntry[] GetDefaultSettings()
        {
            return _client.GetDefaultSettings(_environment);
        }

        public void SetSetting(Guid groupId, ushort BuildId, string name, string value)
        {
            _client.SetSetting(_environment, groupId, BuildId, name, value);
        }

        // TitleVersions
        public TitleVersionInstance[] GetTitleVersions(uint TitleId)
        {
            return _client.GetTitleVersions(_environment, TitleId);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            _client.AddBaseVersion(_environment, titleId, version, platformType, betaGroup);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            _client.RemoveBaseVersion(_environment, titleId, version, platformType, betaGroup);
        }

        // SettingsManagement
        public XElement IngestEtxManifest(string etxLocationSpecifier)
        {
            return XElement.Parse(_client.IngestEtxManifest(_environment, etxLocationSpecifier));
        }

        private AutomationContract _client;
        private string _environment;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Automation\AutomationContract.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace YellowDoor.Automation {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AutomationContractSoap", Namespace="http://www.xbox.com/yellowdoor")]
    public partial class AutomationContract : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback CreateGroupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetGroupInfoOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAllGroupSummariesOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddConsoleIdsToGroupOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveConsoleIdsFromGroupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetConsoleIdsForGroupOperationCompleted;
        
        private System.Threading.SendOrPostCallback IsFlashProppedOperationCompleted;
        
        private System.Threading.SendOrPostCallback PropTitleUpdateOperationCompleted;
        
        private System.Threading.SendOrPostCallback PropFlashOperationCompleted;
        
        private System.Threading.SendOrPostCallback PropReleaseOperationCompleted;
        
        private System.Threading.SendOrPostCallback AssignFlashReleaseToGroupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSettingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDefaultSettingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetSettingOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTitleVersionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddBaseVersionOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveBaseVersionOperationCompleted;
        
        private System.Threading.SendOrPostCallback IngestEtxManifestOperationCompleted;
        
        /// <remarks/>
        public AutomationContract() {
            this.Url = "http://jojohn-yd-1/YellowDoor/Automation.asmx";
        }
        
        /// <remarks/>
        public event CreateGroupCompletedEventHandler CreateGroupCompleted;
        
        /// <remarks/>
        public event GetGroupInfoCompletedEventHandler GetGroupInfoCompleted;
        
        /// <remarks/>
        public event GetAllGroupSummariesCompletedEventHandler GetAllGroupSummariesCompleted;
        
        /// <remarks/>
        public event AddConsoleIdsToGroupCompletedEventHandler AddConsoleIdsToGroupCompleted;
        
        /// <remarks/>
        public event RemoveConsoleIdsFromGroupCompletedEventHandler RemoveConsoleIdsFromGroupCompleted;
        
        /// <remarks/>
        public event GetConsoleIdsForGroupCompletedEventHandler GetConsoleIdsForGroupCompleted;
        
        /// <remarks/>
        public event IsFlashProppedCompletedEventHandler IsFlashProppedCompleted;
        
        /// <remarks/>
        public event PropTitleUpdateCompletedEventHandler PropTitleUpdateCompleted;
        
        /// <remarks/>
        public event PropFlashCompletedEventHandler PropFlashCompleted;
        
        /// <remarks/>
        public event PropReleaseCompletedEventHandler PropReleaseCompleted;
        
        /// <remarks/>
        public event AssignFlashReleaseToGroupCompletedEventHandler AssignFlashReleaseToGroupCompleted;
        
        /// <remarks/>
        public event GetSettingsCompletedEventHandler GetSettingsCompleted;
        
        /// <remarks/>
        public event GetDefaultSettingsCompletedEventHandler GetDefaultSettingsCompleted;
        
        /// <remarks/>
        public event SetSettingCompletedEventHandler SetSettingCompleted;
        
        /// <remarks/>
        public event GetTitleVersionsCompletedEventHandler GetTitleVersionsCompleted;
        
        /// <remarks/>
        public event AddBaseVersionCompletedEventHandler AddBaseVersionCompleted;
        
        /// <remarks/>
        public event RemoveBaseVersionCompletedEventHandler RemoveBaseVersionCompleted;
        
        /// <remarks/>
        public event IngestEtxManifestCompletedEventHandler IngestEtxManifestCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/CreateGroup", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Guid CreateGroup(string environment, string name, string creator) {
            object[] results = this.Invoke("CreateGroup", new object[] {
                        environment,
                        name,
                        creator});
            return ((System.Guid)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateGroup(string environment, string name, string creator, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateGroup", new object[] {
                        environment,
                        name,
                        creator}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Guid EndCreateGroup(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Guid)(results[0]));
        }
        
        /// <remarks/>
        public void CreateGroupAsync(string environment, string name, string creator) {
            this.CreateGroupAsync(environment, name, creator, null);
        }
        
        /// <remarks/>
        public void CreateGroupAsync(string environment, string name, string creator, object userState) {
            if ((this.CreateGroupOperationCompleted == null)) {
                this.CreateGroupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateGroupOperationCompleted);
            }
            this.InvokeAsync("CreateGroup", new object[] {
                        environment,
                        name,
                        creator}, this.CreateGroupOperationCompleted, userState);
        }
        
        private void OnCreateGroupOperationCompleted(object arg) {
            if ((this.CreateGroupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateGroupCompleted(this, new CreateGroupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/GetGroupInfo", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Group GetGroupInfo(string environment, System.Guid id) {
            object[] results = this.Invoke("GetGroupInfo", new object[] {
                        environment,
                        id});
            return ((Group)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGroupInfo(string environment, System.Guid id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGroupInfo", new object[] {
                        environment,
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public Group EndGetGroupInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Group)(results[0]));
        }
        
        /// <remarks/>
        public void GetGroupInfoAsync(string environment, System.Guid id) {
            this.GetGroupInfoAsync(environment, id, null);
        }
        
        /// <remarks/>
        public void GetGroupInfoAsync(string environment, System.Guid id, object userState) {
            if ((this.GetGroupInfoOperationCompleted == null)) {
                this.GetGroupInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetGroupInfoOperationCompleted);
            }
            this.InvokeAsync("GetGroupInfo", new object[] {
                        environment,
                        id}, this.GetGroupInfoOperationCompleted, userState);
        }
        
        private void OnGetGroupInfoOperationCompleted(object arg) {
            if ((this.GetGroupInfoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetGroupInfoCompleted(this, new GetGroupInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/GetAllGroupSummaries", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GroupSummary[] GetAllGroupSummaries(string environment) {
            object[] results = this.Invoke("GetAllGroupSummaries", new object[] {
                        environment});
            return ((GroupSummary[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAllGroupSummaries(string environment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAllGroupSummaries", new object[] {
                        environment}, callback, asyncState);
        }
        
        /// <remarks/>
        public GroupSummary[] EndGetAllGroupSummaries(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GroupSummary[])(results[0]));
        }
        
        /// <remarks/>
        public void GetAllGroupSummariesAsync(string environment) {
            this.GetAllGroupSummariesAsync(environment, null);
        }
        
        /// <remarks/>
        public void GetAllGroupSummariesAsync(string environment, object userState) {
            if ((this.GetAllGroupSummariesOperationCompleted == null)) {
                this.GetAllGroupSummariesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAllGroupSummariesOperationCompleted);
            }
            this.InvokeAsync("GetAllGroupSummaries", new object[] {
                        environment}, this.GetAllGroupSummariesOperationCompleted, userState);
        }
        
        private void OnGetAllGroupSummariesOperationCompleted(object arg) {
            if ((this.GetAllGroupSummariesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAllGroupSummariesCompleted(this, new GetAllGroupSummariesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/AddConsoleIdsToGroup", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string environment, string[] consoleIds, System.Guid groupId) {
            object[] results = this.Invoke("AddConsoleIdsToGroup", new object[] {
                        environment,
                        consoleIds,
                        groupId});
            return ((GroupMembershipChangeResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddConsoleIdsToGroup(string environment, string[] consoleIds, System.Guid groupId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddConsoleIdsToGroup", new object[] {
                        environment,
                        consoleIds,
                        groupId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GroupMembershipChangeResult[] EndAddConsoleIdsToGroup(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GroupMembershipChangeResult[])(results[0]));
        }
        
        /// <remarks/>
        public void AddConsoleIdsToGroupAsync(string environment, string[] consoleIds, System.Guid groupId) {
            this.AddConsoleIdsToGroupAsync(environment, consoleIds, groupId, null);
        }
        
        /// <remarks/>
        public void AddConsoleIdsToGroupAsync(string environment, string[] consoleIds, System.Guid groupId, object userState) {
            if ((this.AddConsoleIdsToGroupOperationCompleted == null)) {
                this.AddConsoleIdsToGroupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddConsoleIdsToGroupOperationCompleted);
            }
            this.InvokeAsync("AddConsoleIdsToGroup", new object[] {
                        environment,
                        consoleIds,
                        groupId}, this.AddConsoleIdsToGroupOperationCompleted, userState);
        }
        
        private void OnAddConsoleIdsToGroupOperationCompleted(object arg) {
            if ((this.AddConsoleIdsToGroupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddConsoleIdsToGroupCompleted(this, new AddConsoleIdsToGroupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/RemoveConsoleIdsFromGroup", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string environment, string[] consoleIds, System.Guid groupId) {
            object[] results = this.Invoke("RemoveConsoleIdsFromGroup", new object[] {
                        environment,
                        consoleIds,
                        groupId});
            return ((GroupMembershipChangeResult[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveConsoleIdsFromGroup(string environment, string[] consoleIds, System.Guid groupId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveConsoleIdsFromGroup", new object[] {
                        environment,
                        consoleIds,
                        groupId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GroupMembershipChangeResult[] EndRemoveConsoleIdsFromGroup(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GroupMembershipChangeResult[])(results[0]));
        }
        
        /// <remarks/>
        public void RemoveConsoleIdsFromGroupAsync(string environment, string[] consoleIds, System.Guid groupId) {
            this.RemoveConsoleIdsFromGroupAsync(environment, consoleIds, groupId, null);
        }
        
        /// <remarks/>
        public void RemoveConsoleIdsFromGroupAsync(string environment, string[] consoleIds, System.Guid groupId, object userState) {
            if ((this.RemoveConsoleIdsFromGroupOperationCompleted == null)) {
                this.RemoveConsoleIdsFromGroupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveConsoleIdsFromGroupOperationCompleted);
            }
            this.InvokeAsync("RemoveConsoleIdsFromGroup", new object[] {
                        environment,
                        consoleIds,
                        groupId}, this.RemoveConsoleIdsFromGroupOperationCompleted, userState);
        }
        
        private void OnRemoveConsoleIdsFromGroupOperationCompleted(object arg) {
            if ((this.RemoveConsoleIdsFromGroupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveConsoleIdsFromGroupCompleted(this, new RemoveConsoleIdsFromGroupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/GetConsoleIdsForGroup", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] GetConsoleIdsForGroup(string environment, System.Guid groupId) {
            object[] results = this.Invoke("GetConsoleIdsForGroup", new object[] {
                        environment,
                        groupId});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetConsoleIdsForGroup(string environment, System.Guid groupId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetConsoleIdsForGroup", new object[] {
                        environment,
                        groupId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndGetConsoleIdsForGroup(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public void GetConsoleIdsForGroupAsync(string environment, System.Guid groupId) {
            this.GetConsoleIdsForGroupAsync(environment, groupId, null);
        }
        
        /// <remarks/>
        public void GetConsoleIdsForGroupAsync(string environment, System.Guid groupId, object userState) {
            if ((this.GetConsoleIdsForGroupOperationCompleted == null)) {
                this.GetConsoleIdsForGroupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetConsoleIdsForGroupOperationCompleted);
            }
            this.InvokeAsync("GetConsoleIdsForGroup", new object[] {
                        environment,
                        groupId}, this.GetConsoleIdsForGroupOperationCompleted, userState);
        }
        
        private void OnGetConsoleIdsForGroupOperationCompleted(object arg) {
            if ((this.GetConsoleIdsForGroupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetConsoleIdsForGroupCompleted(this, new GetConsoleIdsForGroupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/IsFlashPropped", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool IsFlashPropped(string environment, uint version) {
            object[] results = this.Invoke("IsFlashPropped", new object[] {
                        environment,
                        version});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIsFlashPropped(string environment, uint version, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsFlashPropped", new object[] {
                        environment,
                        version}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndIsFlashPropped(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void IsFlashProppedAsync(string environment, uint version) {
            this.IsFlashProppedAsync(environment, version, null);
        }
        
        /// <remarks/>
        public void IsFlashProppedAsync(string environment, uint version, object userState) {
            if ((this.IsFlashProppedOperationCompleted == null)) {
                this.IsFlashProppedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsFlashProppedOperationCompleted);
            }
            this.InvokeAsync("IsFlashPropped", new object[] {
                        environment,
                        version}, this.IsFlashProppedOperationCompleted, userState);
        }
        
        private void OnIsFlashProppedOperationCompleted(object arg) {
            if ((this.IsFlashProppedCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IsFlashProppedCompleted(this, new IsFlashProppedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/PropTitleUpdate", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string PropTitleUpdate(string environment, uint titleId, string cabFilePath) {
            object[] results = this.Invoke("PropTitleUpdate", new object[] {
                        environment,
                        titleId,
                        cabFilePath});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPropTitleUpdate(string environment, uint titleId, string cabFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PropTitleUpdate", new object[] {
                        environment,
                        titleId,
                        cabFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndPropTitleUpdate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void PropTitleUpdateAsync(string environment, uint titleId, string cabFilePath) {
            this.PropTitleUpdateAsync(environment, titleId, cabFilePath, null);
        }
        
        /// <remarks/>
        public void PropTitleUpdateAsync(string environment, uint titleId, string cabFilePath, object userState) {
            if ((this.PropTitleUpdateOperationCompleted == null)) {
                this.PropTitleUpdateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPropTitleUpdateOperationCompleted);
            }
            this.InvokeAsync("PropTitleUpdate", new object[] {
                        environment,
                        titleId,
                        cabFilePath}, this.PropTitleUpdateOperationCompleted, userState);
        }
        
        private void OnPropTitleUpdateOperationCompleted(object arg) {
            if ((this.PropTitleUpdateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PropTitleUpdateCompleted(this, new PropTitleUpdateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/PropFlash", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string PropFlash(string environment, string cabFilePath) {
            object[] results = this.Invoke("PropFlash", new object[] {
                        environment,
                        cabFilePath});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPropFlash(string environment, string cabFilePath, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PropFlash", new object[] {
                        environment,
                        cabFilePath}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndPropFlash(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void PropFlashAsync(string environment, string cabFilePath) {
            this.PropFlashAsync(environment, cabFilePath, null);
        }
        
        /// <remarks/>
        public void PropFlashAsync(string environment, string cabFilePath, object userState) {
            if ((this.PropFlashOperationCompleted == null)) {
                this.PropFlashOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPropFlashOperationCompleted);
            }
            this.InvokeAsync("PropFlash", new object[] {
                        environment,
                        cabFilePath}, this.PropFlashOperationCompleted, userState);
        }
        
        private void OnPropFlashOperationCompleted(object arg) {
            if ((this.PropFlashCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PropFlashCompleted(this, new PropFlashCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/PropRelease", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string PropRelease(string environment, string releaseName, string releaseFilePath, bool isXITRelease) {
            object[] results = this.Invoke("PropRelease", new object[] {
                        environment,
                        releaseName,
                        releaseFilePath,
                        isXITRelease});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPropRelease(string environment, string releaseName, string releaseFilePath, bool isXITRelease, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PropRelease", new object[] {
                        environment,
                        releaseName,
                        releaseFilePath,
                        isXITRelease}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndPropRelease(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void PropReleaseAsync(string environment, string releaseName, string releaseFilePath, bool isXITRelease) {
            this.PropReleaseAsync(environment, releaseName, releaseFilePath, isXITRelease, null);
        }
        
        /// <remarks/>
        public void PropReleaseAsync(string environment, string releaseName, string releaseFilePath, bool isXITRelease, object userState) {
            if ((this.PropReleaseOperationCompleted == null)) {
                this.PropReleaseOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPropReleaseOperationCompleted);
            }
            this.InvokeAsync("PropRelease", new object[] {
                        environment,
                        releaseName,
                        releaseFilePath,
                        isXITRelease}, this.PropReleaseOperationCompleted, userState);
        }
        
        private void OnPropReleaseOperationCompleted(object arg) {
            if ((this.PropReleaseCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PropReleaseCompleted(this, new PropReleaseCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/AssignFlashReleaseToGroup", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AssignFlashReleaseToGroup(string environment, string releaseName, System.Guid groupId) {
            this.Invoke("AssignFlashReleaseToGroup", new object[] {
                        environment,
                        releaseName,
                        groupId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAssignFlashReleaseToGroup(string environment, string releaseName, System.Guid groupId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AssignFlashReleaseToGroup", new object[] {
                        environment,
                        releaseName,
                        groupId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAssignFlashReleaseToGroup(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void AssignFlashReleaseToGroupAsync(string environment, string releaseName, System.Guid groupId) {
            this.AssignFlashReleaseToGroupAsync(environment, releaseName, groupId, null);
        }
        
        /// <remarks/>
        public void AssignFlashReleaseToGroupAsync(string environment, string releaseName, System.Guid groupId, object userState) {
            if ((this.AssignFlashReleaseToGroupOperationCompleted == null)) {
                this.AssignFlashReleaseToGroupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAssignFlashReleaseToGroupOperationCompleted);
            }
            this.InvokeAsync("AssignFlashReleaseToGroup", new object[] {
                        environment,
                        releaseName,
                        groupId}, this.AssignFlashReleaseToGroupOperationCompleted, userState);
        }
        
        private void OnAssignFlashReleaseToGroupOperationCompleted(object arg) {
            if ((this.AssignFlashReleaseToGroupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AssignFlashReleaseToGroupCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/GetSettings", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public LiveHiveSettingsEntry[] GetSettings(string environment, System.Guid groupId, ushort BuildId) {
            object[] results = this.Invoke("GetSettings", new object[] {
                        environment,
                        groupId,
                        BuildId});
            return ((LiveHiveSettingsEntry[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSettings(string environment, System.Guid groupId, ushort BuildId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSettings", new object[] {
                        environment,
                        groupId,
                        BuildId}, callback, asyncState);
        }
        
        /// <remarks/>
        public LiveHiveSettingsEntry[] EndGetSettings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LiveHiveSettingsEntry[])(results[0]));
        }
        
        /// <remarks/>
        public void GetSettingsAsync(string environment, System.Guid groupId, ushort BuildId) {
            this.GetSettingsAsync(environment, groupId, BuildId, null);
        }
        
        /// <remarks/>
        public void GetSettingsAsync(string environment, System.Guid groupId, ushort BuildId, object userState) {
            if ((this.GetSettingsOperationCompleted == null)) {
                this.GetSettingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSettingsOperationCompleted);
            }
            this.InvokeAsync("GetSettings", new object[] {
                        environment,
                        groupId,
                        BuildId}, this.GetSettingsOperationCompleted, userState);
        }
        
        private void OnGetSettingsOperationCompleted(object arg) {
            if ((this.GetSettingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSettingsCompleted(this, new GetSettingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/GetDefaultSettings", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public LiveHiveSettingsEntry[] GetDefaultSettings(string environment) {
            object[] results = this.Invoke("GetDefaultSettings", new object[] {
                        environment});
            return ((LiveHiveSettingsEntry[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDefaultSettings(string environment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDefaultSettings", new object[] {
                        environment}, callback, asyncState);
        }
        
        /// <remarks/>
        public LiveHiveSettingsEntry[] EndGetDefaultSettings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LiveHiveSettingsEntry[])(results[0]));
        }
        
        /// <remarks/>
        public void GetDefaultSettingsAsync(string environment) {
            this.GetDefaultSettingsAsync(environment, null);
        }
        
        /// <remarks/>
        public void GetDefaultSettingsAsync(string environment, object userState) {
            if ((this.GetDefaultSettingsOperationCompleted == null)) {
                this.GetDefaultSettingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDefaultSettingsOperationCompleted);
            }
            this.InvokeAsync("GetDefaultSettings", new object[] {
                        environment}, this.GetDefaultSettingsOperationCompleted, userState);
        }
        
        private void OnGetDefaultSettingsOperationCompleted(object arg) {
            if ((this.GetDefaultSettingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDefaultSettingsCompleted(this, new GetDefaultSettingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/SetSetting", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetSetting(string environment, System.Guid groupId, ushort BuildId, string name, string value) {
            this.Invoke("SetSetting", new object[] {
                        environment,
                        groupId,
                        BuildId,
                        name,
                        value});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetSetting(string environment, System.Guid groupId, ushort BuildId, string name, string value, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetSetting", new object[] {
                        environment,
                        groupId,
                        BuildId,
                        name,
                        value}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetSetting(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetSettingAsync(string environment, System.Guid groupId, ushort BuildId, string name, string value) {
            this.SetSettingAsync(environment, groupId, BuildId, name, value, null);
        }
        
        /// <remarks/>
        public void SetSettingAsync(string environment, System.Guid groupId, ushort BuildId, string name, string value, object userState) {
            if ((this.SetSettingOperationCompleted == null)) {
                this.SetSettingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetSettingOperationCompleted);
            }
            this.InvokeAsync("SetSetting", new object[] {
                        environment,
                        groupId,
                        BuildId,
                        name,
                        value}, this.SetSettingOperationCompleted, userState);
        }
        
        private void OnSetSettingOperationCompleted(object arg) {
            if ((this.SetSettingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetSettingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/GetTitleVersions", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public TitleVersionInstance[] GetTitleVersions(string environment, uint TitleId) {
            object[] results = this.Invoke("GetTitleVersions", new object[] {
                        environment,
                        TitleId});
            return ((TitleVersionInstance[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleVersions(string environment, uint TitleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleVersions", new object[] {
                        environment,
                        TitleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public TitleVersionInstance[] EndGetTitleVersions(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TitleVersionInstance[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTitleVersionsAsync(string environment, uint TitleId) {
            this.GetTitleVersionsAsync(environment, TitleId, null);
        }
        
        /// <remarks/>
        public void GetTitleVersionsAsync(string environment, uint TitleId, object userState) {
            if ((this.GetTitleVersionsOperationCompleted == null)) {
                this.GetTitleVersionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTitleVersionsOperationCompleted);
            }
            this.InvokeAsync("GetTitleVersions", new object[] {
                        environment,
                        TitleId}, this.GetTitleVersionsOperationCompleted, userState);
        }
        
        private void OnGetTitleVersionsOperationCompleted(object arg) {
            if ((this.GetTitleVersionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTitleVersionsCompleted(this, new GetTitleVersionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/AddBaseVersion", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddBaseVersion(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup) {
            this.Invoke("AddBaseVersion", new object[] {
                        environment,
                        titleId,
                        version,
                        platformType,
                        betaGroup});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddBaseVersion(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddBaseVersion", new object[] {
                        environment,
                        titleId,
                        version,
                        platformType,
                        betaGroup}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddBaseVersion(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void AddBaseVersionAsync(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup) {
            this.AddBaseVersionAsync(environment, titleId, version, platformType, betaGroup, null);
        }
        
        /// <remarks/>
        public void AddBaseVersionAsync(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup, object userState) {
            if ((this.AddBaseVersionOperationCompleted == null)) {
                this.AddBaseVersionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddBaseVersionOperationCompleted);
            }
            this.InvokeAsync("AddBaseVersion", new object[] {
                        environment,
                        titleId,
                        version,
                        platformType,
                        betaGroup}, this.AddBaseVersionOperationCompleted, userState);
        }
        
        private void OnAddBaseVersionOperationCompleted(object arg) {
            if ((this.AddBaseVersionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddBaseVersionCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/RemoveBaseVersion", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveBaseVersion(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup) {
            this.Invoke("RemoveBaseVersion", new object[] {
                        environment,
                        titleId,
                        version,
                        platformType,
                        betaGroup});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveBaseVersion(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveBaseVersion", new object[] {
                        environment,
                        titleId,
                        version,
                        platformType,
                        betaGroup}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveBaseVersion(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RemoveBaseVersionAsync(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup) {
            this.RemoveBaseVersionAsync(environment, titleId, version, platformType, betaGroup, null);
        }
        
        /// <remarks/>
        public void RemoveBaseVersionAsync(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup, object userState) {
            if ((this.RemoveBaseVersionOperationCompleted == null)) {
                this.RemoveBaseVersionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveBaseVersionOperationCompleted);
            }
            this.InvokeAsync("RemoveBaseVersion", new object[] {
                        environment,
                        titleId,
                        version,
                        platformType,
                        betaGroup}, this.RemoveBaseVersionOperationCompleted, userState);
        }
        
        private void OnRemoveBaseVersionOperationCompleted(object arg) {
            if ((this.RemoveBaseVersionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveBaseVersionCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/yellowdoor/IngestEtxManifest", RequestNamespace="http://www.xbox.com/yellowdoor", ResponseNamespace="http://www.xbox.com/yellowdoor", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string IngestEtxManifest(string environment, string etxLocationSpecifier) {
            object[] results = this.Invoke("IngestEtxManifest", new object[] {
                        environment,
                        etxLocationSpecifier});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIngestEtxManifest(string environment, string etxLocationSpecifier, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IngestEtxManifest", new object[] {
                        environment,
                        etxLocationSpecifier}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndIngestEtxManifest(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void IngestEtxManifestAsync(string environment, string etxLocationSpecifier) {
            this.IngestEtxManifestAsync(environment, etxLocationSpecifier, null);
        }
        
        /// <remarks/>
        public void IngestEtxManifestAsync(string environment, string etxLocationSpecifier, object userState) {
            if ((this.IngestEtxManifestOperationCompleted == null)) {
                this.IngestEtxManifestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIngestEtxManifestOperationCompleted);
            }
            this.InvokeAsync("IngestEtxManifest", new object[] {
                        environment,
                        etxLocationSpecifier}, this.IngestEtxManifestOperationCompleted, userState);
        }
        
        private void OnIngestEtxManifestOperationCompleted(object arg) {
            if ((this.IngestEtxManifestCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IngestEtxManifestCompleted(this, new IngestEtxManifestCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public partial class Group {
        
        private GroupSummary summaryField;
        
        private ReleaseInfo[] relInfosField;
        
        /// <remarks/>
        public GroupSummary Summary {
            get {
                return this.summaryField;
            }
            set {
                this.summaryField = value;
            }
        }
        
        /// <remarks/>
        public ReleaseInfo[] RelInfos {
            get {
                return this.relInfosField;
            }
            set {
                this.relInfosField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public partial class GroupSummary {
        
        private System.Guid idField;
        
        private string nameField;
        
        private string creatorField;
        
        private System.DateTime createdField;
        
        private uint fullFlashVersionField;
        
        private System.Guid releaseIdField;
        
        private string releaseNameField;
        
        private string foundConsoleIdField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string Creator {
            get {
                return this.creatorField;
            }
            set {
                this.creatorField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Created {
            get {
                return this.createdField;
            }
            set {
                this.createdField = value;
            }
        }
        
        /// <remarks/>
        public uint FullFlashVersion {
            get {
                return this.fullFlashVersionField;
            }
            set {
                this.fullFlashVersionField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ReleaseId {
            get {
                return this.releaseIdField;
            }
            set {
                this.releaseIdField = value;
            }
        }
        
        /// <remarks/>
        public string ReleaseName {
            get {
                return this.releaseNameField;
            }
            set {
                this.releaseNameField = value;
            }
        }
        
        /// <remarks/>
        public string FoundConsoleId {
            get {
                return this.foundConsoleIdField;
            }
            set {
                this.foundConsoleIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public partial class TitleVersionInstance {
        
        private System.Guid betaGroupIdField;
        
        private int baseVersionField;
        
        private uint titleIdField;
        
        private int updateVersionField;
        
        private PlatformType platformTypeField;
        
        private string groupNameField;
        
        /// <remarks/>
        public System.Guid BetaGroupId {
            get {
                return this.betaGroupIdField;
            }
            set {
                this.betaGroupIdField = value;
            }
        }
        
        /// <remarks/>
        public int BaseVersion {
            get {
                return this.baseVersionField;
            }
            set {
                this.baseVersionField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
        
        /// <remarks/>
        public int UpdateVersion {
            get {
                return this.updateVersionField;
            }
            set {
                this.updateVersionField = value;
            }
        }
        
        /// <remarks/>
        public PlatformType PlatformType {
            get {
                return this.platformTypeField;
            }
            set {
                this.platformTypeField = value;
            }
        }
        
        /// <remarks/>
        public string GroupName {
            get {
                return this.groupNameField;
            }
            set {
                this.groupNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public enum PlatformType {
        
        /// <remarks/>
        Xbox1,
        
        /// <remarks/>
        XboxCom,
        
        /// <remarks/>
        Xenon,
        
        /// <remarks/>
        Marketplace,
        
        /// <remarks/>
        PC,
        
        /// <remarks/>
        Mobile,
        
        /// <remarks/>
        WebGames,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public partial class LiveHiveSettingsEntry {
        
        private string settingNameField;
        
        private string valueField;
        
        private string diffValueField;
        
        private ushort buildIdField;
        
        /// <remarks/>
        public string SettingName {
            get {
                return this.settingNameField;
            }
            set {
                this.settingNameField = value;
            }
        }
        
        /// <remarks/>
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
        
        /// <remarks/>
        public string DiffValue {
            get {
                return this.diffValueField;
            }
            set {
                this.diffValueField = value;
            }
        }
        
        /// <remarks/>
        public ushort BuildId {
            get {
                return this.buildIdField;
            }
            set {
                this.buildIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public partial class GroupMembershipChangeResult {
        
        private string consoleIDField;
        
        private GroupMembershipChangeOutcome outcomeField;
        
        private System.Guid[] conflictingGroupsField;
        
        /// <remarks/>
        public string ConsoleID {
            get {
                return this.consoleIDField;
            }
            set {
                this.consoleIDField = value;
            }
        }
        
        /// <remarks/>
        public GroupMembershipChangeOutcome Outcome {
            get {
                return this.outcomeField;
            }
            set {
                this.outcomeField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid[] ConflictingGroups {
            get {
                return this.conflictingGroupsField;
            }
            set {
                this.conflictingGroupsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public enum GroupMembershipChangeOutcome {
        
        /// <remarks/>
        Success,
        
        /// <remarks/>
        MemberInOtherGroup,
        
        /// <remarks/>
        MachineAccountNotExist,
        
        /// <remarks/>
        MachineNotInGroup,
        
        /// <remarks/>
        MemberAlreadyInGroup,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xbox.com/yellowdoor")]
    public partial class ReleaseInfo {
        
        private string sMRevisionField;
        
        private string sOMRevisionField;
        
        private short flashVersionField;
        
        private short flashQfeField;
        
        /// <remarks/>
        public string SMRevision {
            get {
                return this.sMRevisionField;
            }
            set {
                this.sMRevisionField = value;
            }
        }
        
        /// <remarks/>
        public string SOMRevision {
            get {
                return this.sOMRevisionField;
            }
            set {
                this.sOMRevisionField = value;
            }
        }
        
        /// <remarks/>
        public short FlashVersion {
            get {
                return this.flashVersionField;
            }
            set {
                this.flashVersionField = value;
            }
        }
        
        /// <remarks/>
        public short FlashQfe {
            get {
                return this.flashQfeField;
            }
            set {
                this.flashQfeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateGroupCompletedEventHandler(object sender, CreateGroupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateGroupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateGroupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Guid Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetGroupInfoCompletedEventHandler(object sender, GetGroupInfoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetGroupInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetGroupInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Group Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Group)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAllGroupSummariesCompletedEventHandler(object sender, GetAllGroupSummariesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAllGroupSummariesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAllGroupSummariesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GroupSummary[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GroupSummary[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddConsoleIdsToGroupCompletedEventHandler(object sender, AddConsoleIdsToGroupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddConsoleIdsToGroupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddConsoleIdsToGroupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GroupMembershipChangeResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GroupMembershipChangeResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveConsoleIdsFromGroupCompletedEventHandler(object sender, RemoveConsoleIdsFromGroupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RemoveConsoleIdsFromGroupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RemoveConsoleIdsFromGroupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GroupMembershipChangeResult[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GroupMembershipChangeResult[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetConsoleIdsForGroupCompletedEventHandler(object sender, GetConsoleIdsForGroupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetConsoleIdsForGroupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetConsoleIdsForGroupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void IsFlashProppedCompletedEventHandler(object sender, IsFlashProppedCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class IsFlashProppedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal IsFlashProppedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PropTitleUpdateCompletedEventHandler(object sender, PropTitleUpdateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PropTitleUpdateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PropTitleUpdateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PropFlashCompletedEventHandler(object sender, PropFlashCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PropFlashCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PropFlashCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PropReleaseCompletedEventHandler(object sender, PropReleaseCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PropReleaseCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PropReleaseCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AssignFlashReleaseToGroupCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSettingsCompletedEventHandler(object sender, GetSettingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSettingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSettingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LiveHiveSettingsEntry[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LiveHiveSettingsEntry[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDefaultSettingsCompletedEventHandler(object sender, GetDefaultSettingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDefaultSettingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetDefaultSettingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LiveHiveSettingsEntry[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LiveHiveSettingsEntry[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetSettingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTitleVersionsCompletedEventHandler(object sender, GetTitleVersionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTitleVersionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTitleVersionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TitleVersionInstance[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TitleVersionInstance[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddBaseVersionCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveBaseVersionCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void IngestEtxManifestCompletedEventHandler(object sender, IngestEtxManifestCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class IngestEtxManifestCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal IngestEtxManifestCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Environment.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Mail;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using System.Threading;
using System.Web;
using System.Web.Configuration;
using System.Xml.Linq;
using System.Text;

using YellowDoor.ToolsMgmtProxy;

namespace YellowDoor
{
    [Serializable]
    class Environment : IEnvironment
    {
        public string Name { get; private set; }

        public string WebSgMixUrl { get; private set; }

        public string WebSgToolsMgmtUrl { get; private set; }

        public string WebSgCertificateName { get; private set; }

        public X509Certificate2 WebSgCertificate
        {
            get
            {
                if (IsXblob)
                {
                    return null;
                }
                else
                {
                    X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                    store.Open(OpenFlags.ReadOnly);
                    try
                    {
                        foreach (X509Certificate2 cert in store.Certificates)
                        {
                            if (cert.FriendlyName == WebSgCertificateName)
                            {
                                return cert;
                            }
                        }
                    }
                    finally
                    {
                        store.Close();
                    }
                    return new X509Certificate2();
                }
            }
        }

        public string SystemUpdateUploadPath { get; private set; } // Upload path for Flash CAB files

        public string SystemReleaseUploadPath { get; private set; } // Upload path for PAM packages

        public string SystemReleaseDownloadUrl { get; private set; }

        public string XblToolsPath { get; private set; }

        public bool IsXblob { get; private set; }

        public uint MinUpgradeFlashVersion { get; private set; }

        public uint FlashTitleId
        {
            get { return 0xFFFE07D1; } // Could be a setting in web.config
        }

        public int CopyFileDelay { get; private set; }

        public int MixVersionBetaManagement { get; private set; }

        public int MixVersionSettingsManagement { get; private set; }

        public int MixVersionTitleManagement { get; private set; }

        public bool IsGlobalEnabled { get; private set; }

        private IBetaManagementClient BetaManagementClient
        {
            get { return BetaManagementClientFactory.CreateClient(this); }
        }

        private ISettingsManagementClient SettingsManagementClient
        {
            get
            {
                return SettingsManagementClientFactory.CreateClient(this);
            }
        }

        private ITitleManagementClient TitleManagementClient
        {
            get
            {
                return TitleManagementClientFactory.CreateClient(this);
            }
        }

        [NonSerialized]
        private ToolsMgmt ToolsMgmtService;

        [NonSerialized]
        private JobInfo JobInfo;

        public Environment(string name)
        {
            Name = name;
            ToolsMgmtService = null;
            JobInfo = null;

            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "p_environments_get_config";
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Name);
                    SqlDataReader reader = sqlCmd.ExecuteReader();
                    if (reader.Read())
                    {
                        WebSgMixUrl = reader["vc_websg_mix_url"] as string;
                        WebSgToolsMgmtUrl = reader["vc_websg_toolsmgmt_url"] as string;
                        WebSgCertificateName = reader["vc_websg_certificate"] as string;
                        SystemUpdateUploadPath = reader["vc_system_update_upload_path"] as string;
                        SystemReleaseUploadPath = reader["vc_system_release_upload_path"] as string;
                        IsXblob = (bool)reader["b_is_xblob"];
                        MinUpgradeFlashVersion = (uint)(int)reader["i_min_upgrade_flash_version"];
                        XblToolsPath = reader["vc_xbltools_path"] as string;
                        SystemReleaseDownloadUrl = reader["vc_system_release_download_url"] as string;
                        CopyFileDelay = (int)reader["i_copyfile_delay"];
                        MixVersionBetaManagement = (int)reader["i_mixversion_betamanagement"];
                        MixVersionSettingsManagement = (int)reader["i_mixversion_settingsmanagement"];
                        MixVersionTitleManagement = (int)reader["i_mixversion_titlemanagement"];
                        IsGlobalEnabled = (bool)reader["b_enable_global"];
                        Logger.Log(string.Format("Environment loaded", name));
                    }
                }
            }
        }

        public bool IsFlashPropped(uint version)
        {
            return BetaManagementClient.IsFlashPropped(FlashTitleId, version);
        }

        public Group GetGroupInfo(Guid id)
        {
            return BetaManagementClient.GetGroupInfo(id);
        }

        public Group.GroupSummary[] GetAllGroupSummaries()
        {
            return BetaManagementClient.GetAllGroupSummaries();
        }

        public void AssignFlashReleaseToGroup(Release release, Guid groupId)
        {
            foreach (ReleaseApp app in release.SystemOnlineManifestApps)
            {
                if (app.AppVersion.HasValue && app.TitleId.HasValue && app.TitleId.Value > 0)
                {
                    AddBaseVersion(app.TitleId.Value, (int)app.AppVersion, PlatformType.Xenon, groupId);
                }
            }

            foreach (ReleaseApp app in release.SystemManifestApps)
            {
                if (app.AppVersion.HasValue && app.TitleId.HasValue && app.TitleId.Value > 0)
                {
                    AddBaseVersion(app.TitleId.Value, (int)app.AppVersion, PlatformType.Xenon, groupId);
                }
            }

            BetaManagementClient.AssignFlashReleaseToGroup(release, groupId, FlashTitleId, MinUpgradeFlashVersion);
        }

        public static void SendMail(string to, string subject, string body, params Attachment[] attachments)
        {
            MailMessage email;
            SmtpClient client;
            WindowsIdentity identity;
            

            Logger.Log(string.Format("Sending mail to: {0} with subject: {1}", to, subject));

            try
            {
                identity = WindowsIdentity.GetCurrent(false);

                if (null != identity || string.IsNullOrEmpty(identity.Name))
                {
                    string[] user;
                    string from;

                    user = identity.Name.Split('/', '\\');

                    from = string.Format("{0}@microsoft.com", user[user.Length-1]);

                    email = new MailMessage(from, to, subject, body);
                    email.IsBodyHtml = true;

                    foreach (Attachment attachement in attachments)
                    {
                        email.Attachments.Add(attachement);
                    }

                    client = new SmtpClient();

                    client.Send(email);
                }
                else
                {
                    Logger.Log("Failed to send mail: not running under a valid user account.");
                }
            }
            catch (Exception e)
            {
                Logger.Log(string.Format("Failed to send mail: {0}", e));
            }
        }

        public static string GetAppSetting(string setting, string defaultVal)
        {
            string result = WebConfigurationManager.AppSettings[setting];
            return (result == null) ? defaultVal : result;
        }

        public static long GetAppSetting(string setting, long defaultVal)
        {
            string result = WebConfigurationManager.AppSettings[setting];
            return (result == null) ? defaultVal : Int64.Parse(result);
        }

        public void PropSelective(string cabFilePath, uint titleId)
        {
            // Set up for WCTools
            //
            Logger.Log(string.Format("PropSelective() {0}", cabFilePath));
            ToolsMgmtService = new ToolsMgmt();
            ToolsMgmtService.Url = WebSgToolsMgmtUrl;
            ToolsMgmtService.Timeout = 20 * 60 * 1000; // 20 minutes

            if (!IsXblob)
            {
                ToolsMgmtService.ClientCertificates.Add(WebSgCertificate);
                ServicePointManager.ServerCertificateValidationCallback =
                    new System.Net.Security.RemoteCertificateValidationCallback((sender, certificate, chain, sslPolicyErrors) =>
                    {
                        return true;
                    });
            }

            string cabFileName = Path.GetFileName(cabFilePath);

            // Create the new job.  We need to do this to retrieve the maximum
            // amount of space on the server, to make sure we have enough disk
            // space.
            JobInfo jobInfo;
            ToolsMgmtService.CreateJob("YellowDoor PropSelective Job", out jobInfo);
            JobInfo = jobInfo;

            // A cab file is a cab file for this.  We should maybe change the name to
            // UploadCabToEnvironment or something.
            UploadSystemUpdateFile(cabFilePath);

            // Create the new action and make the command line.
            //
            ActionInfo propAction = new ActionInfo();
            propAction.jobId = JobInfo.jobId;
            propAction.toolFileName = Path.Combine(XblToolsPath, "LiveContent.exe");
            propAction.files = new string[1] { cabFileName };

            // Add the commandline parameters.
            propAction.parameters = new Parameter[7];

            propAction.parameters[0] = new Parameter();
            propAction.parameters[0].name = "/action:build";

            propAction.parameters[1] = new Parameter();
            propAction.parameters[1].name = "/update:selective";

            propAction.parameters[2] = new Parameter();
            propAction.parameters[2].name = "/platform:xenon";

            propAction.parameters[3] = new Parameter();
            propAction.parameters[3].name = String.Format("/titleid:{0:X}", titleId);

            propAction.parameters[4] = new Parameter();
            propAction.parameters[4].name = String.Format("/package:{0}", cabFileName);

            propAction.parameters[5] = new Parameter();
            propAction.parameters[5].name = "/overwrite";

            propAction.parameters[5] = new Parameter();
            propAction.parameters[5].name = String.Format("/timeout:{0}", Environment.GetAppSetting("LiveContent.Timeout", 1));

            ToolsMgmtService.AddAction(propAction);
            ToolsMgmtService.ExecuteJob(JobInfo.jobId);

            Logger.Log(string.Format("PropSelective() {0} finished", cabFilePath));
        }

        public void ValidateToolsMgmt(string testFile)
        {
            ToolsMgmtService = new ToolsMgmt();
            ToolsMgmtService.Url = WebSgToolsMgmtUrl;
            ToolsMgmtService.Timeout = 20 * 60 * 1000; // 20 minutes

            if (!IsXblob)
            {
                ToolsMgmtService.ClientCertificates.Add(WebSgCertificate);
                ServicePointManager.ServerCertificateValidationCallback =
                    new System.Net.Security.RemoteCertificateValidationCallback((sender, certificate, chain, sslPolicyErrors) =>
                    {
                        return true;
                    });
            }

            // Create the new job.  We need to do this to retrieve the maximum
            // amount of space on the server, to make sure we have enough disk
            // space.
            JobInfo jobInfo;
            ToolsMgmtService.CreateJob("ValidateTools Job", out jobInfo);
            JobInfo = jobInfo;

            UploadTestSystemUpdateFile(testFile);

            // Create the new action and make the command line.
            //
            ActionInfo action = new ActionInfo();
            action.jobId = JobInfo.jobId;
            action.toolFileName = Path.Combine(XblToolsPath, "LiveContent.exe");
            action.files = new string[1] { testFile };

            // Add the commandline parameters.
            action.parameters = new Parameter[1];

            action.parameters[0] = new Parameter();
            action.parameters[0].name = "/?";

            ToolsMgmtService.AddAction(action);
            ToolsMgmtService.ExecuteJob(JobInfo.jobId);
        }

        private void UploadTestSystemUpdateFile(string fileName)
        {
            string uploadPath = Path.Combine(SystemUpdateUploadPath, "ToolsTransfer");
            if (!Directory.Exists(uploadPath))
            {
                Directory.CreateDirectory(uploadPath);
            }
            uploadPath = Path.Combine(uploadPath, JobInfo.jobId.ToString());
            if (!Directory.Exists(uploadPath))
            {
                Directory.CreateDirectory(uploadPath);
            }
            uploadPath = Path.Combine(uploadPath, Path.GetFileName(fileName));

            File.CreateText(uploadPath);

            if (!IsXblob)
            {
                // We use signiant for file-copying.
                // Singiant deletes the source folder once it's replicated to the environment.
                double waitMs = Double.Parse(WebConfigurationManager.AppSettings["Environment.MaxSigniantWaitTimeMs"]);
                TimeSpan waitSpan = TimeSpan.FromMilliseconds(waitMs);
                DateTime waitStart = DateTime.UtcNow;
                do
                {
                    if ((DateTime.UtcNow - waitStart) > waitSpan)
                    {
                        throw new TimeoutException("Timed out while waiting on signiant to copy source file: " + uploadPath);
                    }
                }
                while (File.Exists(uploadPath));
            }

            // Some environments require some delay to let the files
            // synchronize between folders
            //
            if (CopyFileDelay > 0)
            {
                Thread.Sleep(TimeSpan.FromSeconds(CopyFileDelay));
            }
        }

        private void UploadSystemUpdateFile(string path)
        {
            // Verify space requirements
            //
            
            FileInfo fi = new FileInfo(path);
            ulong bytesSpaceNeeded = (ulong)fi.Length;

            if (bytesSpaceNeeded > JobInfo.spaceAvailable)
            {
                string exceptionString = String.Format(
                        "WCTools reported it didn't have enough space.  Has {0} bytes, needs {1}",
                        JobInfo.spaceAvailable,
                        bytesSpaceNeeded);

                throw new Exception(exceptionString);
            }

            // Upload the files.
            //
            if (!Directory.Exists(SystemUpdateUploadPath))
            {
                throw new DirectoryNotFoundException("The system upload path can't be found: {0}");
            }

            string uploadPath = Path.Combine(SystemUpdateUploadPath, "ToolsTransfer");
            if (!Directory.Exists(uploadPath))
            {
                Directory.CreateDirectory(uploadPath);
            }
            uploadPath = Path.Combine(uploadPath, JobInfo.jobId.ToString());
            if (!Directory.Exists(uploadPath))
            {
                Directory.CreateDirectory(uploadPath);
            }
            uploadPath = Path.Combine(uploadPath, Path.GetFileName(path));

            File.Copy(path, uploadPath);

            if (!IsXblob)
            {
                // We use signiant for file-copying.
                // Singiant deletes the source folder once it's replicated to the environment.
                double waitMs = Double.Parse(WebConfigurationManager.AppSettings["Environment.MaxSigniantWaitTimeMs"]);
                TimeSpan waitSpan = TimeSpan.FromMilliseconds(waitMs);
                DateTime waitStart = DateTime.UtcNow;
                do
                {
                    if ((DateTime.UtcNow - waitStart) > waitSpan)
                    {
                        throw new TimeoutException("Timed out while waiting on signiant to copy source file: " + uploadPath);
                    }
                }
                while (File.Exists(uploadPath));
            }

            // Some environments require some delay to let the files
            // synchronize between folders
            //
            if (CopyFileDelay > 0)
            {
                Thread.Sleep(TimeSpan.FromSeconds(CopyFileDelay));
            }
        }

        public PropStatus GetPropStatus()
        {
            return new PropStatus(ToolsMgmtService.GetActionResult(JobInfo.jobId, 0));
        }

        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId)
        {
            Logger.Log(string.Format("AddConsoleIdsToGroup() {0}, {1}", consoleIds.Length, groupId));
            return BetaManagementClient.AddConsoleIdsToGroup(consoleIds, groupId);
        }

        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId)
        {
            Logger.Log(string.Format("RemoveConsoleIdsFromGroup() {0}, {1}", consoleIds.Length, groupId));
            return BetaManagementClient.RemoveConsoleIdsFromGroup(consoleIds, groupId);
        }

        public string[] GetConsoleIdsForGroup(Guid groupId)
        {
            Logger.Log(string.Format("GetConsoleIdsForGroup() {0}", groupId));
            return BetaManagementClient.GetConsoleIdsForGroup(groupId);
        }

        public Guid CreateGroup(string name, string creator)
        {
            Logger.Log(string.Format("CreateGroup() {0},{1}", name, creator));
            return BetaManagementClient.CreateGroup(name, creator);
        }

        public InvalidConsoleResult[] ValidateBetaGroupConsoles(Guid groupId)
        {
            Logger.Log(string.Format("ValidateBetaGroupConsoles() {0}", groupId));
            return BetaManagementClient.ValidateBetaGroupConsoles(groupId);
        }

        public LiveHiveSettingsEntry[] GetSettings(Guid groupId, ushort buildId)
        {
            Logger.Log(string.Format("GetSettings() {0},{1}", groupId, buildId));
            return SettingsManagementClient.GetSettings(groupId, buildId);
        }

        public void SetSetting(Guid groupId, ushort buildId, string name, string value)
        {
            Logger.Log(string.Format("SetSetting() {0},{1},{2},{3}", groupId, buildId, name, value));
           SettingsManagementClient.SetSetting(groupId, buildId, name, value);
        }

        public LiveHiveSettingsEntry[] GetDefaultSettings()
        {
            List<LiveHiveSettingsEntry> returnList = new List<LiveHiveSettingsEntry>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "p_LiveHiveSettings_get_for_environment";
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Name);
                    SqlDataReader reader = sqlCmd.ExecuteReader();

                    while (reader.Read())
                    {
                        returnList.Add(LiveHiveSettingsEntry.FromDbReader(reader));
                    }

                    return returnList.ToArray();
                }
            }
        }

        public TitleVersionInstance[] GetTitleVersions(uint titleId)
        {
            Logger.Log(string.Format("GetTitleVersions {0}", titleId.ToString("X")));
            return TitleManagementClient.GetTitleVersions(titleId, this);
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            Logger.Log(string.Format("AddBaseVersion {0},{1},{2},{3}", titleId.ToString("X"), version, platformType, betaGroup));
            TitleManagementClient.AddBaseVersion(titleId, version, platformType, betaGroup);
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            Logger.Log(string.Format("RemoveBaseVersion {0},{1},{2},{3}", titleId.ToString("X"), version, platformType, betaGroup));
            TitleManagementClient.RemoveBaseVersion(titleId, version, platformType, betaGroup);
        }

        public XElement IngestEtxManifest(string etxLocationSpecifier)
        {
            XElement result;

            Logger.Log("IngestEtxManifest");
            
            result = SettingsManagementClient.IngestEtxManifest(etxLocationSpecifier);
            result.Add(new XAttribute("environment", Name));

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Automation.asmx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.Configuration;
using System.Web.Services;

namespace YellowDoor
{
    [WebService(Namespace = "http://www.xbox.com/yellowdoor")]
    public class AutomationContract : WebService
    {
        public AutomationContract()
        {
            IngestionUtil.Initialize();
        }

        // Group Management
        [WebMethod]
        public Guid CreateGroup(string environment, string name, string creator)
        {
            return EnvironmentFactory.GetEnvironment(environment).CreateGroup(name, creator);
        }

        [WebMethod]
        public Group GetGroupInfo(string environment, Guid id)
        {
            return EnvironmentFactory.GetEnvironment(environment).GetGroupInfo(id);
        }

        [WebMethod]
        public Group.GroupSummary[] GetAllGroupSummaries(string environment)
        {
            return EnvironmentFactory.GetEnvironment(environment).GetAllGroupSummaries();
        }

        [WebMethod]
        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string environment, string[] consoleIds, Guid groupId)
        {
            return EnvironmentFactory.GetEnvironment(environment).AddConsoleIdsToGroup(consoleIds, groupId);
        }

        [WebMethod]
        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string environment, string[] consoleIds, Guid groupId)
        {
            return EnvironmentFactory.GetEnvironment(environment).RemoveConsoleIdsFromGroup(consoleIds, groupId);
        }

        [WebMethod]
        public string[] GetConsoleIdsForGroup(string environment, Guid groupId)
        {
            return EnvironmentFactory.GetEnvironment(environment).GetConsoleIdsForGroup(groupId);
        }

        // Propping
        [WebMethod]
        public bool IsFlashPropped(string environment, uint version)
        {
            return EnvironmentFactory.GetEnvironment(environment).IsFlashPropped(version);
        }

        [WebMethod]
        public string PropTitleUpdate(string environment, uint titleId, string cabFilePath)
        {
            IEnvironment env = EnvironmentFactory.GetEnvironment(environment);
            PropSelectiveTask task = new PropSelectiveTask(cabFilePath, titleId, env);
            IAsyncResult result = task.Run();
            result.AsyncWaitHandle.WaitOne();

            if(task.Exception != null)
            {
                throw task.Exception;
            }

            return task.TaskProgress;
        }

        [WebMethod]
        public string PropFlash(string environment, string cabFilePath)
        {
            IEnvironment env = EnvironmentFactory.GetEnvironment(environment);
            PropFlashTask task = new PropFlashTask(cabFilePath, env);
            IAsyncResult result = task.Run();
            result.AsyncWaitHandle.WaitOne();

            if(task.Exception != null)
            {
                throw task.Exception;
            }

            return task.TaskProgress;
        }

        [WebMethod]
        public string PropRelease(string environment, string releaseName, string releaseFilePath, bool isXITRelease)
        {
            IEnvironment env = EnvironmentFactory.GetEnvironment(environment);
            PropReleaseTask task = new PropReleaseTask(releaseName, releaseFilePath, isXITRelease, env);
            IAsyncResult result = task.Run();
            result.AsyncWaitHandle.WaitOne();

            if(task.Exception != null)
            {
                throw task.Exception;
            }

            return task.TaskProgress;
        }

        [WebMethod]
        public void AssignFlashReleaseToGroup(string environment, string releaseName, Guid groupId)
        {
            IEnvironment env = EnvironmentFactory.GetEnvironment(environment);
            Release toAssign = Release.LoadFromDb(releaseName, env);
            env.AssignFlashReleaseToGroup(toAssign, groupId);
        }

        // LiveHive
        [WebMethod]
        public LiveHiveSettingsEntry[] GetSettings(string environment, Guid groupId, ushort BuildId)
        {
            return EnvironmentFactory.GetEnvironment(environment).GetSettings(groupId, BuildId);
        }

        [WebMethod]
        public LiveHiveSettingsEntry[] GetDefaultSettings(string environment)
        {
            return EnvironmentFactory.GetEnvironment(environment).GetDefaultSettings();
        }

        [WebMethod]
        public void SetSetting(string environment, Guid groupId, ushort BuildId, string name, string value)
        {
            EnvironmentFactory.GetEnvironment(environment).SetSetting(groupId, BuildId, name, value);
        }

        // TitleVersions
        [WebMethod]
        public TitleVersionInstance[] GetTitleVersions(string environment, uint TitleId)
        {
            return EnvironmentFactory.GetEnvironment(environment).GetTitleVersions(TitleId);
        }

        [WebMethod]
        public void AddBaseVersion(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            EnvironmentFactory.GetEnvironment(environment).AddBaseVersion(titleId, version, platformType, betaGroup);
        }

        [WebMethod]
        public void RemoveBaseVersion(string environment, uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            EnvironmentFactory.GetEnvironment(environment).RemoveBaseVersion(titleId, version, platformType, betaGroup);
        }

        // Settings Management
        [WebMethod]
        public string IngestEtxManifest(string environment, string etxLocationSpecifier)
        {
            return EnvironmentFactory.GetEnvironment(environment).IngestEtxManifest(etxLocationSpecifier).ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Error.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm11 {
        
        /// <summary>
        /// pGeneralError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl pGeneralError;
        
        /// <summary>
        /// pUnhandledException control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl pUnhandledException;
        
        /// <summary>
        /// pAccessViolation control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl pAccessViolation;
        
        /// <summary>
        /// lblException control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblException;
        
        /// <summary>
        /// divException control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl divException;
        
        /// <summary>
        /// preException control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preException;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Error.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm11 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Exception ex = Session["LastServerError"] as Exception;
            if (ex == null)
            {
                pGeneralError.Visible = true;
            }
            else if (ex is UnauthorizedRoleException || 
                (ex.InnerException != null && ex.InnerException is UnauthorizedRoleException))
            {
                pAccessViolation.Visible = true;
                divException.Visible = false;
                lblException.Visible = false;
            }
            else
            {
                preException.InnerText = ex.ToString();
                divException.Visible = true;
                // Get the inner-most exception to determine the root cause
                Exception inner = ex;
                while (inner.InnerException != null)
                {
                    inner = inner.InnerException;
                }
                lblException.Text = inner.Message;
                lblException.Visible = true;
                if (inner.GetType() == typeof(UnauthorizedRoleException))
                {
                    pAccessViolation.Visible = true;
                }
                else
                {
                    pUnhandledException.Visible = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\FileDiffListEntry.cs ===
using System;
using System.Data.SqlClient;

namespace YellowDoor
{
    public class FileDiffListEntry
    {
        private FileDiffListEntry()
        { 
        }

        public static FileDiffListEntry FromDataReader(SqlDataReader reader)
        {
            FileDiffListEntry entry = new FileDiffListEntry();
            entry.Name = string.IsNullOrEmpty((reader["vc_name1"] as string)) ? reader["vc_name2"] as string : reader["vc_name1"] as string;
            entry.OldVersion = reader["vc_version1"] as string;
            entry.NewVersion = reader["vc_version2"] as string;

            return entry;
        }

        public static FileDiffListEntry FromReleaseApp(ReleaseApp app)
        {
            FileDiffListEntry entry = new FileDiffListEntry();
            entry.Name = app.Name;
            entry.OldVersion = String.Empty;
            entry.NewVersion = app.Version;
            return entry;
        }

        public string Name { get; private set; }
        public string OldVersion { get; private set; }
        public string NewVersion { get; private set; }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Group.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;

namespace YellowDoor
{
    public class Group
    {
        public static Guid GlobalGroupId
        {
            get
            {
                return Guid.Empty;
            }
        }

        public GroupSummary Summary { get; set; }

        public List<ReleaseInfo> RelInfos { get; set; }

        public Dictionary<uint, TitleInfo> Titles { get; set; }

        public class GroupSummary
        {
            public Guid Id { get; set; }

            public string Name { get; set; }

            public string Creator { get; set; }

            public DateTime Created { get; set; }

            public uint FullFlashVersion { get; set; }

            public ushort FlashVersion
            {
                get { return (ushort)(0xFFFF & (FullFlashVersion >> 8)); }
            }

            public Guid ReleaseId { get; set; }

            public string ReleaseName { get; set; }
        }

        public class ReleaseInfo
        {
            public string SMRevision { get; set; }

            public string SOMRevision { get; set; }

            public short FlashVersion { get; set; }

            public short FlashQfe { get; set; }

            public uint FullFlashVersion
            {
                get { return Group.BuildFlashVersion(FlashVersion, FlashQfe); }
            }
        }

        public class TitleInfo
        {
            public uint TitleId { get; set; }

            public byte ConsoleType { get; set; }

            public List<UpgradeInfo> UpgradePaths { get; set; }
        }

        public class UpgradeInfo
        {
            public uint BaseVersion { get; set; }

            public uint UpgradeVersion { get; set; }

            public DateTime StartTime { get; set; }

            public DateTime EndTime { get; set; }
        }

        public static uint BuildFlashVersion(short version, short qfe)
        {
            return ((((uint)version) << 8) + ((uint)qfe));
        }

        public ReleaseInfo GetReleaseInfo(uint flashVersion)
        {
            foreach(ReleaseInfo info in RelInfos)
            {
                if (info.FlashVersion == flashVersion)
                {
                    return info;
                }
            }

            return null;
        }

        public ReleaseInfo GetCurrentReleaseInfo()
        {
            return GetReleaseInfo(Summary.FlashVersion);
        }
    }

    public class GroupDetails
    {
        protected Group Source { get; set; }

        public Guid Id
        {
            get { return Source.Summary.Id; }
        }

        public string Name
        {
            get { return Source.Summary.Name; }
        }

        public string Creator
        {
            get { return Source.Summary.Creator; }
        }

        public DateTime Created
        {
            get { return Source.Summary.Created; }
        }

        public uint FlashVersion
        {
            get { return Source.Summary.FlashVersion; }
        }

        public string SMRevision
        {
            get
            {
                if (Source.GetReleaseInfo(FlashVersion) != null)
                    return Source.GetReleaseInfo(FlashVersion).SMRevision;
                else
                    return null;
            }
        }

        public string SOMRevision
        {
            get
            {
                if (Source.GetReleaseInfo(FlashVersion) != null)
                    return Source.GetReleaseInfo(FlashVersion).SOMRevision;
                else
                    return null;
            }
        }

        public GroupDetails(Group g)
        {
            Source = g;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\health.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class Health : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.SuperUser);
        }

        protected void btnValidate_Click(object sender, EventArgs e)
        {
            Logger.Log("Running health checks");
            IEnvironment env = Session["environment"] as IEnvironment;
            ValidateEnvironmentTask task = new ValidateEnvironmentTask(env);

            Session["validateEnvironmentResult"] = task.Run();
            lblError.Visible = false;
            UpdateTimer.Enabled = true;

            preProgress.InnerText = "Starting background task...";

        }

        protected void UpdateTimer_Tick(object sender, EventArgs e)
        {
            IAsyncResult result = Session["validateEnvironmentResult"] as IAsyncResult;
            if (result != null)
            {
                ValidateEnvironmentTask task = result.AsyncState as ValidateEnvironmentTask;
                preProgress.InnerText = task.TaskProgress;
                if (result.IsCompleted)
                {
                    Session.Remove("validateEnvironmentResult");
                    UpdateTimer.Enabled = false;
                    if (task.HasException)
                    {
                        lblError.Text = String.Format("Exception hit during validation. {0} See below for details.", task.Exception.Message);
                        lblError.Visible = true;
                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Global.asax.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;

namespace YellowDoor
{
    public class Global : System.Web.HttpApplication
    {

        protected void Application_Start(object sender, EventArgs e)
        {

        }

        protected void Session_Start(object sender, EventArgs e)
        {

        }

        protected void Application_BeginRequest(object sender, EventArgs e)
        {

        }

        protected void Application_AuthenticateRequest(object sender, EventArgs e)
        {

        }

        protected void Application_Error(object sender, EventArgs e)
        {
            HttpContext c = HttpContext.Current;
            Exception ex = c.Server.GetLastError();
            if (ex != null)
            {
                c.Server.ClearError();
                c.Session["LastServerError"] = ex;
                Logger.Log(ex.ToString());
            }
            c.Response.Redirect("~/Error.aspx", true);
        }

        protected void Session_End(object sender, EventArgs e)
        {

        }

        protected void Application_End(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Group.aspx.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm6 : YellowDoorPage
    {
        protected LiveHiveSettings lhsettings;
        protected Button btnAssignLHSettings;

        protected Guid GroupId
        {
            get 
            {
                return GetParam("GroupId", true, Guid.Empty);
            }
        }

        protected void Page_Load(object sender, EventArgs e)
        {

            Roles.Current.EnforceRole(Roles.GeneralReadOnly);

            if (!Roles.Current.HasRole(Roles.GroupsReadWrite))
            {
                uplAddConsoles.Enabled = false;
                uplRemoveConsoles.Enabled = false;
                btnAddConsoles.Enabled = false;
                btnRemoveConsoles.Enabled = false;
                btnRemoveAll.Enabled = false;
                btnValidateGroup.Enabled = false;
                cbEnableRemoveAll.Enabled = false;
            }

            if (!Roles.Current.HasRole(Roles.FlashReadWrite))
            {
                lstReleaseHistory.Enabled = false;
                btnAssignRelease.Enabled = false;
            }

            if (!Roles.Current.HasRole(Roles.SettingsReadWrite))
            {
                btnAssignLHSettings.Enabled = false;
            }

            if (GroupId == Group.GlobalGroupId)
            {
                pnlGlobalManagement.Visible = false;

                if (!Roles.Current.HasRole(Roles.GroupGlobalReadWrite))
                {
                    pnlLiveHiveSettings.Visible = false;
                }
            }


            divError.Visible = false;
            divSuccess.Visible = false;

            if (Environment != null)
            { 
                Group.ReleaseInfo info = Environment.GetGroupInfo(GroupId).GetCurrentReleaseInfo();
                if (info != null && !string.IsNullOrEmpty(info.SMRevision) && !string.IsNullOrEmpty(info.SOMRevision))
                {
                    btnAssignLHSettings.Visible = lhsettings.Visible = true;
                }
                else
                {
                    btnAssignLHSettings.Visible = lhsettings.Visible = false;
                }
            }
        }

        protected string[] ReadConsoleIdsFromUpload(FileUpload upld)
        {
            List<string> consoleIds = new List<string>();
            if (upld.HasFile)
            {
                StreamReader sr = new StreamReader(new MemoryStream(upld.FileBytes));
                while (!sr.EndOfStream)
                {
                    string line = sr.ReadLine();
                    if (!String.IsNullOrEmpty(line))
                    {
                        consoleIds.Add(line);
                    }
                }
            }
            return consoleIds.ToArray();
        }

        protected void CommandBtn_Click(object sender, CommandEventArgs e)
        {
            List<string> groupIds = new List<string>();
            groupIds.Add(Request.QueryString["groupId"]);
            Release release = Release.LoadFromDb(new Guid((string)e.CommandArgument), Session["environment"] as IEnvironment);
            Session["assignReleaseRelease"] = release;
            Session["assignReleaseGroups"] = groupIds;
            Session["originUrl"] = Request.RawUrl;
            Response.Redirect(@"~/ReleaseDiff.aspx");
        }

        protected void btnAddConsoles_Click(object sender, EventArgs e)
        {
            try
            {
                string[] consoleIds = ReadConsoleIdsFromUpload(uplAddConsoles);
                GroupMembershipChangeResult[] status = Environment.AddConsoleIdsToGroup(consoleIds, GroupId);
                int successCount = 0;
                StringBuilder sb = new StringBuilder();
                foreach (GroupMembershipChangeResult s in status)
                {
                    switch (s.Outcome)
                    {
                        case GroupMembershipChangeResult.GroupMembershipChangeOutcome.Success:
                            ++successCount;
                            break;

                        case GroupMembershipChangeResult.GroupMembershipChangeOutcome.MemberInOtherGroup:
                            sb.AppendFormat("  Machine {0} is member of another group\n", s.ConsoleID);
                            break;

                        case GroupMembershipChangeResult.GroupMembershipChangeOutcome.MachineAccountNotExist:
                            sb.AppendFormat("  Machine {0} does not exist\n", s.ConsoleID);
                            break;

                        default:
                            sb.AppendFormat("  Unrecognized error adding console {0} to group\n", s.ConsoleID);
                            break;
                    }
                }
                if (successCount > 0)
                {
                    preSuccess.InnerText = String.Format("Successfully added {0} machines to the group.", successCount);
                    divSuccess.Visible = true;
                }
                if (sb.Length > 0)
                {
                    preError.InnerText = "Errors found when adding machines to the group:\n" + sb.ToString();
                    divError.Visible = true;
                }
            }
            catch (Exception ex)
            {
                preError.InnerText = "Failed to add the selected consoles to the group.\n" + ex.ToString();
                divError.Visible = true;
            }
        }

        protected void btnRemoveConsoles_Click(object sender, EventArgs e)
        {
            try
            {
                string[] consoleIds = ReadConsoleIdsFromUpload(uplRemoveConsoles);
                GroupMembershipChangeResult[] status = Environment.RemoveConsoleIdsFromGroup(consoleIds, GroupId);
                int successCount = 0;
                StringBuilder sb = new StringBuilder();
                foreach (GroupMembershipChangeResult s in status)
                {
                    switch (s.Outcome)
                    {
                        case GroupMembershipChangeResult.GroupMembershipChangeOutcome.Success:
                            ++successCount;
                            break;

                        case GroupMembershipChangeResult.GroupMembershipChangeOutcome.MachineNotInGroup:
                            sb.AppendFormat("  Machine {0} is not a member of the specified group\n", s.ConsoleID);
                            break;

                        default:
                            sb.AppendFormat("  Unrecognized error removing console {0} from group\n", s.ConsoleID);
                            break;
                    }
                }
                preSuccess.InnerText = String.Format("Successfully removed {0} consoles from the group.", consoleIds.Length);
                divSuccess.Visible = true;
            }
            catch (Exception ex)
            {
                preError.InnerText = "Failed to remove the selected consoles from the group.\n" + ex.ToString();
                divError.Visible = true;
            }
        }

        protected void btnRemoveAll_Click(object sender, EventArgs e)
        {
            try
            {
                Guid guid = GroupId;
                string[] consoleIds = Environment.GetConsoleIdsForGroup(guid);
                Environment.RemoveConsoleIdsFromGroup(consoleIds, guid);
                preSuccess.InnerText = String.Format("Successfully removed {0} consoles from the group.", consoleIds.Length);
                divSuccess.Visible = true;
            }
            catch (Exception ex)
            {
                preError.InnerText = "Failed to remove all consoles from the group.\n" + ex.ToString();
                divError.Visible = true;
            }
        }

        protected void lnkGetConsoles_Click(object sender, EventArgs e)
        {
            try
            {
                string[] consoleIds = Environment.GetConsoleIdsForGroup(GroupId);
                StringBuilder sb = new StringBuilder();
                foreach (string console in consoleIds)
                {
                    sb.AppendLine(console);
                }
                Response.Clear();
                Response.ContentType = "text/plain";
                Response.AddHeader("Content-disposition", "attachment;filename=consoles.txt");
                Response.Write(sb.ToString());
                Response.End();
            }
            catch (Exception ex)
            {
                preError.InnerText = "Failed to remove all consoles from the group.\n" + ex.ToString();
                divError.Visible = true;
            }
        }

        protected void btnFilterClear_Click(object sender, EventArgs e)
        {
            txtFilterReleases.Text = "";
        }

        protected void btnAssignRelease_Click(object sender, EventArgs e)
        {
            if (chkListReleases.SelectedIndex >= 0)
            {
                List<string> groupIds = new List<string>();
                groupIds.Add(GetParam("GroupId", true, string.Empty));
                Release release = Release.LoadFromDb(new Guid(chkListReleases.SelectedValue), Session["environment"] as IEnvironment);
                Session["assignReleaseRelease"] = release;
                Session["assignReleaseGroups"] = groupIds;
                Session["originUrl"] = Request.RawUrl;
                Response.Redirect(@"~\ReleaseDiff.aspx");
            }
        }

        protected void btnAssignLHSettings_Click(object sender, EventArgs e)
        {
            lhsettings.WriteSubmittedSettings(Environment.GetGroupInfo(GroupId).Summary.FlashVersion);
        }

        protected void cbEnableRemoveAll_CheckedChanged(object sender, EventArgs e)
        {
            if (cbEnableRemoveAll.Checked)
                btnRemoveAll.Enabled = true;
            else
                btnRemoveAll.Enabled = false;
        }

        protected void btnValidateGroup_Click(object sender, EventArgs e)
        {
            try
            {
                InvalidConsoleResult[] results = Environment.ValidateBetaGroupConsoles(GroupId);
                StringBuilder sb = new StringBuilder();
                foreach (InvalidConsoleResult result in results)
                {
                    sb.AppendFormat("  Machine {0} is on flash version {1:X} and does not have an upgrade path to this group's current flash version.\n", result.ConsoleID, result.FlashVersion);
                }

                if (sb.Length == 0)
                {
                    preSuccess.InnerText = "Successfully validated all consoles in the group.";
                    divSuccess.Visible = true;
                }
                else
                {
                    preError.InnerText = sb.ToString();
                    divError.Visible = true;
                }
            }
            catch (Exception ex)
            {
                preError.InnerText = "Failed to validate the consoles in the group.\n" + ex.ToString();
                divError.Visible = true;
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Groups.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm5 {
        
        /// <summary>
        /// txtFilterGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtFilterGroups;
        
        /// <summary>
        /// btnFilterGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnFilterGroups;
        
        /// <summary>
        /// btnFilterClear control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnFilterClear;
        
        /// <summary>
        /// GridView1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.GridView GridView1;
        
        /// <summary>
        /// dbGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ObjectDataSource dbGroups;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Groups.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm5 : YellowDoorPage
    {
        protected void Page_Init(object sender, EventArgs e)
        {
            dbGroups.SelectParameters["showGlobal"].DefaultValue = Environment.IsGlobalEnabled.ToString();
        }

        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GeneralReadOnly);
        }

        protected void btnFilterClear_Click(object sender, EventArgs e)
        {
            txtFilterGroups.Text = "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Group.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm6 {
        
        /// <summary>
        /// ScriptManager1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager ScriptManager1;
        
        /// <summary>
        /// DetailsView1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DetailsView DetailsView1;
        
        /// <summary>
        /// dbGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ObjectDataSource dbGroup;
        
        /// <summary>
        /// pnlGlobalManagement control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel pnlGlobalManagement;
        
        /// <summary>
        /// lnkGetConsoles control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton lnkGetConsoles;
        
        /// <summary>
        /// uplAddConsoles control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.FileUpload uplAddConsoles;
        
        /// <summary>
        /// btnAddConsoles control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAddConsoles;
        
        /// <summary>
        /// uplRemoveConsoles control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.FileUpload uplRemoveConsoles;
        
        /// <summary>
        /// btnRemoveConsoles control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnRemoveConsoles;
        
        /// <summary>
        /// cbEnableRemoveAll control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox cbEnableRemoveAll;
        
        /// <summary>
        /// btnRemoveAll control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnRemoveAll;
        
        /// <summary>
        /// btnValidateGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnValidateGroup;
        
        /// <summary>
        /// divSuccess control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl divSuccess;
        
        /// <summary>
        /// preSuccess control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preSuccess;
        
        /// <summary>
        /// divError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl divError;
        
        /// <summary>
        /// preError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preError;
        
        /// <summary>
        /// lstReleaseHistory control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListView lstReleaseHistory;
        
        /// <summary>
        /// dbReleaseHistory control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.SqlDataSource dbReleaseHistory;
        
        /// <summary>
        /// UpdatePanel1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel1;
        
        /// <summary>
        /// chkShowLower control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox chkShowLower;
        
        /// <summary>
        /// txtFilterReleases control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtFilterReleases;
        
        /// <summary>
        /// btnFilterReleases control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnFilterReleases;
        
        /// <summary>
        /// btnFilterClear control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnFilterClear;
        
        /// <summary>
        /// chkListReleases control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButtonList chkListReleases;
        
        /// <summary>
        /// btnAssignRelease control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAssignRelease;
        
        /// <summary>
        /// dbReleases control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ObjectDataSource dbReleases;
        
        /// <summary>
        /// pnlLiveHiveSettings control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel pnlLiveHiveSettings;
        
        /// <summary>
        /// liveHiveDiv control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl liveHiveDiv;
        
        /// <summary>
        /// btnRefresh control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnRefresh;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\health.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class Health {
        
        /// <summary>
        /// UpdateScriptManager control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager UpdateScriptManager;
        
        /// <summary>
        /// btnValidate control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnValidate;
        
        /// <summary>
        /// UpdatePanel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel;
        
        /// <summary>
        /// UpdateTimer control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.Timer UpdateTimer;
        
        /// <summary>
        /// lblError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblError;
        
        /// <summary>
        /// preProgress control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preProgress;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\IngestEtxManifest.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm12 {
        
        /// <summary>
        /// txtCabPath control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtFilePath;
        
        /// <summary>
        /// btnUpload control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnUpload;
        
        /// <summary>
        /// UpdateScriptManager control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager UpdateScriptManager;
        
        /// <summary>
        /// UpdatePanel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel;
        
        /// <summary>
        /// UpdateTimer control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.Timer UpdateTimer;
        
        /// <summary>
        /// lblError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblError;
        
        /// <summary>
        /// preProgress control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preProgress;

        /// <summary>
        /// divResult control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl divResult;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\IngestEtxManifest.aspx.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Mail;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Xsl;

namespace YellowDoor
{
    public partial class WebForm12 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.FlashReadWrite);
        }

        protected void UpdateTimer_Tick(object sender, EventArgs e)
        {

        }

        protected void btnUpload_Click(object sender, EventArgs e)
        {
            lblError.Visible = false;

            try
            {
                XElement result;
                Environment env;

                env = Session["environment"] as Environment;

                result = env.IngestEtxManifest(txtFilePath.Text);

                divResult.InnerHtml = IngestionUtil.ArchiveResult(result, env.Name);
            }
            catch(Exception ex)
            {
                lblError.Text = "Exception hit while ingesting manifest. See below for details.\n";
                lblError.Text += ex.ToString();
                lblError.Visible = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\LiveHiveSettings.ascx.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Web;
using System.Web.Configuration;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

namespace YellowDoor
{
    /// <summary>
    /// Class for LiveHiveSettings.ascx
    /// </summary>
    public partial class LiveHiveSettings : System.Web.UI.UserControl
    {
        private int MAX_DIFF_VAL_LENGTH = 20;
        private IEnvironment _env = null;
        private Dictionary<string, string> _submittedSettings;
        private string _footerText = string.Empty;
        protected System.Web.UI.WebControls.Repeater settings;
        protected System.Web.UI.WebControls.Literal noEntriesLiteral;
        public bool DiffOnlyDisplay { get; set; }
        public bool ThreeColumnDisplay { get; set; }
        public bool ShowUpdateWarning { get; set; }
        public string TableId { get; set; }
        

        public void WriteSubmittedSettings(ushort buildId)
        {
            Guid GroupId = GetGroupId();

            if (Environment != null && _submittedSettings != null && Environment.GetGroupInfo(GroupId).GetCurrentReleaseInfo() != null)
            {
                Dictionary<string, string>.KeyCollection.Enumerator keyEnum = _submittedSettings.Keys.GetEnumerator();

                while (keyEnum.MoveNext())
                {
                    string name = keyEnum.Current;
                    Environment.SetSetting(GroupId, buildId, name, _submittedSettings[name]);
                }
            }

            DisplayList();
        }

        protected void Page_Init(object sender, EventArgs e)
        {
            if (Page.IsPostBack)
            {
                LiveHiveSettingsEntry[] defaultSettings = Environment.GetDefaultSettings();
                _submittedSettings = new Dictionary<string, string>();

                foreach (LiveHiveSettingsEntry entry in defaultSettings)
                {
                    if (string.Compare(Request[LiveHiveSettingsEntry.GetCBControlName(entry.SettingName)], "on", true) == 0)
                    {
                        _submittedSettings.Add(entry.SettingName, Request[LiveHiveSettingsEntry.GetTBControlName(entry.SettingName)]);
                    }
                }
            }   
        }

        protected void settings_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {

            Literal lit = e.Item.FindControl("litSettingDisplay") as Literal;
            LiveHiveSettingsEntry entry = e.Item.DataItem as LiveHiveSettingsEntry;

            if (lit != null && entry != null)
            {
                if (DiffOnlyDisplay)
                {
                    lit.Text = (entry.Value.Length > MAX_DIFF_VAL_LENGTH) ?
                        string.Format("{0}...", entry.Value.Substring(0, MAX_DIFF_VAL_LENGTH)) :
                        entry.Value;
                }
                else
                {
                    lit.Text = string.Format("<input type='text' disabled='disabled' id='{0}' name='{0}' size='30' value='{1}' />",
                        entry.TextBoxControlId,
                        entry.Value);
                }
            }
        }

        /// <summary>
        /// Onload event.
        /// </summary>
        /// <param name="sender">ignored</param>
        /// <param name="e">ignored.</param>
        protected void Page_Load(object sender, EventArgs e)
        {
            if (this.settings != null)
            {
                this.settings.DataSource = null;
            }

            DisplayList();
        }

        private void DisplayList()
        {
            Group.ReleaseInfo currentRelease = Environment.GetGroupInfo(GetGroupId()).GetCurrentReleaseInfo();
            SortedDictionary<string, LiveHiveSettingsEntry> currentServiceEntries = null;
            SortedDictionary<string, LiveHiveSettingsEntry> newBuildSettings = null;
            List<LiveHiveSettingsEntry> displayEntries = new List<LiveHiveSettingsEntry>();
            LiveHiveSettingsEntry[] defaultSettings = Environment.GetDefaultSettings();

            if (currentRelease == null)
            {
                currentServiceEntries = new SortedDictionary<string, LiveHiveSettingsEntry>();
            }
            else
            { 
                currentServiceEntries = GetEntriesFromService((ushort)currentRelease.FlashVersion, GetGroupId());
            }

            if (ThreeColumnDisplay)
            {
                newBuildSettings = GetEntriesFromService((ushort)NewRelease.BaseFlash, GetGroupId());

                SortedDictionary<string, LiveHiveSettingsEntry>.Enumerator newBuildSettingsEnum = newBuildSettings.GetEnumerator();

                while (newBuildSettingsEnum.MoveNext())
                {
                    LiveHiveSettingsEntry entry = newBuildSettingsEnum.Current.Value;

                    // Special case these two fields to make them disappear from the UX.
                    if (currentRelease != null && (string.Compare(entry.SettingName, "SMRevision", true) == 0))
                    {
                        entry.DiffValue = entry.Value = currentRelease.SMRevision;
                    }
                    if (currentRelease != null && (string.Compare(entry.SettingName, "SOMRevision", true) == 0))
                    {
                        entry.DiffValue = entry.Value = currentRelease.SOMRevision;
                    }

                    if (currentServiceEntries.ContainsKey(entry.SettingName) &&
                        string.Compare(entry.Value,
                        currentServiceEntries[entry.SettingName].Value,
                        true) != 0)
                    {
                        string settingVal = currentServiceEntries[entry.SettingName].Value;
                        entry.DiffValue = (settingVal.Length > MAX_DIFF_VAL_LENGTH) ? 
                            string.Format("{0}...", settingVal.Substring(0, MAX_DIFF_VAL_LENGTH)) : 
                            settingVal;

                        displayEntries.Add(entry);
                    }
                }
            }
            else
            {
                foreach (LiveHiveSettingsEntry entry in defaultSettings)
                {
                    // set the current version value.
                    entry.Value = (currentServiceEntries.ContainsKey(entry.SettingName) &&
                                   !string.IsNullOrEmpty(currentServiceEntries[entry.SettingName].Value)) ?
                                        currentServiceEntries[entry.SettingName].Value :
                                        entry.Value;

                    // set the diff value to empty.
                    entry.DiffValue = string.Empty;

                    if (!DiffOnlyDisplay ||
                        (DiffOnlyDisplay && string.Compare(entry.DiffValue, entry.Value, true) == 0))
                    {
                        displayEntries.Add(entry);
                    }
                }
            }

            if (displayEntries.Count > 0)
            {
                this.settings.DataSource = displayEntries;
                this.settings.DataBind();
            }
            else
            {
                string formatText = "<table id=\"settingsHeader\" cellpadding=\"2\" cellspacing=\"2\" class=\"listTable\" ><tr><td colspan=\"3\" style=\"vertical-align:center;width:587px;min-width:590px;\"><center>{0}</center></td></tr></table>";
                noEntriesLiteral.Text = string.Format(formatText, "No differences between the two releases");
            }

        }

        private SortedDictionary<string, LiveHiveSettingsEntry> GetEntriesFromService(ushort BuildId, Guid GroupId)
        {
            SortedDictionary<string, LiveHiveSettingsEntry> returnList = new SortedDictionary<string, LiveHiveSettingsEntry>();

             if (Environment != null)
            {
                try
                {
                    LiveHiveSettingsEntry[] serviceList = Environment.GetSettings(GroupId, BuildId);

                    foreach (LiveHiveSettingsEntry e in serviceList)
                    {
                        if (returnList.ContainsKey(e.SettingName))
                        {
                            // If it's a buid specific setting, get the latest build for our uses.
                            if (e.BuildId >= returnList[e.SettingName].BuildId)
                            {
                                returnList[e.SettingName] = e;
                            }
                        }
                        else
                        {
                            returnList.Add(e.SettingName, e);
                        }
                    }
                }
                catch
                { }
            }

            return returnList;
        }

        private Guid GetGroupId()
        {
            if (Request.CurrentExecutionFilePath.ToLower().Contains("group.aspx"))
            {
                return new Guid(Request["groupId"]);
            }
            else if (Request.CurrentExecutionFilePath.ToLower().Contains("releasediff.aspx"))
            {
                List<string> groupIds = Session["assignReleaseGroups"] as List<string>;
                return new Guid(groupIds[0]);
            }
            else
            {
                throw new Exception("Unsupported Page");
            }
        }

        private string GetEnvString()
        {
            return Environment.Name;
        }

        private IEnvironment Environment
        {
            get
            {
                if (_env == null)
                {
                    _env = Session["environment"] as IEnvironment;
                }

                if (_env == null)
                {
                    HttpCookie cookie = Request.Cookies["environment"];
                    if (cookie != null)
                    {
                        try
                        {
                            _env = EnvironmentFactory.GetEnvironment(cookie.Value);
                            Session["environment"] = _env;
                        }
                        catch (Exception)
                        {
                        }
                    }
                }

                if (_env == null)
                {
                    _env = EnvironmentFactory.GetDefaultEnvironment();
                    Session["environment"] = _env;
                    // No need to save a cookie if we're using default environment
                }

                return _env;
            }
        }

        public string HeaderText
        {
            get
            {
                string formatText = "<table id=\"settingsHeader\" cellpadding=\"2\" cellspacing=\"2\" class=\"listTable\" ><tr><td colspan=\"3\" style=\"color:#284775;background-color:#5D7B9D;color:#FFFFFF;vertical-align:center;width:587px;min-width:590px;\"><center><a style='font-size:small;color:#FFFFFF;A:visited:#FFFFFF;A:link:#FFFFFF;' href=\"javascript:showHideRegionLHS('{0}');\">(Show/Hide)</a>&nbsp;&nbsp;<b>{1}</b></center></td></tr></table>";

                if (ThreeColumnDisplay)
                {
                    // Title string for a diff display
                    return string.Format(formatText, TableId, "Live Hive Differences");
                }
                else if (Request.Path.Contains("ReleaseDiff.aspx"))
                {
                    // Title string for a configuration display
                    return string.Format(formatText, TableId, "Configure Live Hive Settings");
                }
                else
                {
                    return string.Format(formatText, TableId, "Live Hive Settings");
                }
            }
        }

        public string UpdateWarning
        {
            get
            {
                if (ShowUpdateWarning)
                {
                    return "<tr><td colspan=\"3\">Updates to Live Hive settings take several minutes and may not be reflected in the UI immediately.</td></tr>";
                }

                return string.Empty;
            }
        }

        public Release NewRelease
        {
            get
            {
                return Session["assignReleaseRelease"] as Release;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\IngestionUtil.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Net.Mail;
using System.Text;
using System.Web;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Xsl;

namespace YellowDoor
{
    public static class IngestionUtil
    {
        private const string APP_SETTING_EMAIL_ALIAS = "Ingestion.EmailAlias";
        private const string APP_SETTING_EMAIL_ALIAS_DEFAULT = null;

        private const string APP_SETTING_ARCHIVE_DIRECTORY = "Ingestion.ArchiveDirectory";
        private const string APP_SETTING_ARCHIVE_DIRECTORY_DEFAULT = null;

        private static XslCompiledTransform resultTransform = null;
        private static string ingestionStyleSheetPath = null;

        /// <summary>
        /// Gets the path to the Ingestion StyleSheet
        /// </summary>
        public static string IngestionStyleSheetPath
        {
            get
            {
                if (null == ingestionStyleSheetPath)
                {
                    ingestionStyleSheetPath = HttpContext.Current.Server.MapPath("IngestEtxManifest.xsl");
                }

                return ingestionStyleSheetPath;
            }
        }

        /// <summary>
        /// Stylesheet used to ResultTransform ingestion results.
        /// </summary>
        public static XslCompiledTransform ResultTransform
        {
            get
            {
                if (null == resultTransform)
                {
                    XslCompiledTransform transform;

                    transform = new XslCompiledTransform();
                    transform.Load(IngestionStyleSheetPath);

                    resultTransform = transform;
                }

                return resultTransform;
            }
        }

        /// <summary>
        /// Caches values that depend on the HttpContext for initialization while it is present.
        /// </summary>
        public static void Initialize()
        {
            if (null == HttpContext.Current)
            {
                throw new InvalidOperationException("Must be called from within a valid HttpContext");
            }

            var transform = ResultTransform;
        }

        /// <summary>
        /// Sends email notification for etx manifest ingestion.
        /// </summary>
        /// <param name="result">Result xml to send in mail.</param>
        /// <param name="environment">Environment associated with the ingestion.</param>
        /// <returns>Returns the transformed html.</returns>
        public static string ArchiveResult(XElement result, string environment)
        {
            string transformedText;

            using (MemoryStream stream = new MemoryStream())
            {
                using (XmlWriter writer = XmlWriter.Create(stream, ResultTransform.OutputSettings))
                {
                    string target;
                    string ingestionName;

                    ResultTransform.Transform(result.CreateReader(), writer);

                    transformedText = Encoding.UTF8.GetString(stream.ToArray());

                    ingestionName = DateTime.UtcNow.ToString("'ingestion_'yyyyMMddHHmmss'.xml'");

                    // Attempt to email the results
                    if (!string.IsNullOrEmpty(target = Environment.GetAppSetting(APP_SETTING_EMAIL_ALIAS, APP_SETTING_EMAIL_ALIAS_DEFAULT)))
                    {
                        Attachment attachment;

                        stream.Position = 0;

                        attachment = new Attachment(stream, ingestionName, "text/xml");

                        Environment.SendMail(
                            target,
                            string.Format("Etx Manifest Ingestion: {0}", environment),
                            transformedText,
                            attachment);
                    }

                    // Attempt to archive the results
                    if (!string.IsNullOrEmpty(target = Environment.GetAppSetting(APP_SETTING_ARCHIVE_DIRECTORY, APP_SETTING_ARCHIVE_DIRECTORY_DEFAULT)))
                    {
                        XDocument document;
                        string xslTarget;
                        string xmlTarget;

                        xslTarget = "Ingestion.xsl";
                        xmlTarget = Path.Combine(target, ingestionName);

                        document = new XDocument();

                        // Attempt to copy the style sheet to the archive location
                        try
                        {
                            string path;

                            path = Path.Combine(target, xslTarget);

                            if (!File.Exists(path))
                            {
                                File.Copy(IngestionStyleSheetPath, path, true);
                            }

                            // Success, associated the xml document with the style sheet
                            document.Add(new XProcessingInstruction("xml-stylesheet", string.Format("type='text/xsl' href='{0}'", xslTarget)));
                        }
                        catch (Exception e)
                        {
                            Logger.Log("Failed to copy the ingestion xsl: " + e.ToString());
                        }

                        // Attach results to the document
                        document.Add(result);

                        // Attempt to write the ingestion results to the archive location
                        try
                        {
                            Logger.Log("Archiving ingestion results: " + xmlTarget);

                            File.WriteAllText(xmlTarget, document.ToString());
                        }
                        catch (Exception e)
                        {
                            Logger.Log("Failed to archive results: " + e.ToString());
                        }
                    }
                }
            }

            return transformedText;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\IEnvironment.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Web;
using System.Web.Configuration;
using System.Xml.Linq;

using YellowDoor.ToolsMgmtProxy;

namespace YellowDoor
{
    public interface IEnvironment
    {
        string Name { get; }

        string SystemUpdateUploadPath { get; } // Upload path for Flash CAB files

        string SystemReleaseUploadPath { get; } // Upload path for PAM packages

        string SystemReleaseDownloadUrl { get; } // Upload path for PAM packages

        string WebSgMixUrl { get; }

        X509Certificate2 WebSgCertificate { get; }

        string XblToolsPath { get; }

        bool IsXblob { get; }

        int CopyFileDelay { get; }

        Group GetGroupInfo(Guid id);

        Group.GroupSummary[] GetAllGroupSummaries();

        bool IsFlashPropped(uint version);

        void AssignFlashReleaseToGroup(Release release, Guid groupId);

        void PropSelective(string cabFilePath, uint titleId);

        void ValidateToolsMgmt(string testFile);

        PropStatus GetPropStatus();

        GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId);

        GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId);

        string[] GetConsoleIdsForGroup(Guid groupId);

        Guid CreateGroup(string name, string creator);

        InvalidConsoleResult[] ValidateBetaGroupConsoles(Guid groupId);

        int MixVersionBetaManagement { get; }

        int MixVersionSettingsManagement { get; }

        int MixVersionTitleManagement { get; }

        LiveHiveSettingsEntry[] GetSettings(Guid groupId, ushort BuildId);

        LiveHiveSettingsEntry[] GetDefaultSettings();

        void SetSetting(Guid groupId, ushort BuildId, string name, string value);

        TitleVersionInstance[] GetTitleVersions(uint TitleId);

        void AddBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup);

        void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup);

        bool IsGlobalEnabled { get; }

        XElement IngestEtxManifest(string etxSpec);
    }

    public static class EnvironmentFactory
    {
        public static IEnvironment GetEnvironment(string name)
        {
            string typeName = WebConfigurationManager.AppSettings["EnvironmentFactory.TypeName"];
            if (typeName == null)
            {
                throw new ConfigurationErrorsException("AppSetting value not found for EnvironmentFactoryClass");
            }
            Type type = Type.GetType(typeName, true);
            var ctor = type.GetConstructor(new Type[] { Type.GetType("System.String") });
            if (ctor == null)
            {
                throw new ConfigurationErrorsException(String.Format("{0} does not implement a constructor accepting a string", type.Name));
            }
            IEnvironment env = ctor.Invoke(new object[] { name }) as IEnvironment;
            if (env == null)
            {
                throw new ConfigurationErrorsException(String.Format("Could not cast type {0} into YellowDoor.IEnvironment", type.Name));
            }
            return env;
        }

        public static IEnvironment GetDefaultEnvironment()
        {
            string name = WebConfigurationManager.AppSettings["EnvironmentFactory.DefaultEnvironmentName"];
            if (String.IsNullOrEmpty(name))
            {
                throw new ConfigurationErrorsException("AppSetting value not found for DefaultEnvironmentName");
            }
            return GetEnvironment(name);
        }
    }

    public class PropStatus
    {
        public PropStatus()
        {
            Finished = false;
            ReturnCode = -1;
            Output = String.Empty;
        }

        public PropStatus(ActionResult ar)
        {
            Finished = (ar.state == JobState.Complete || ar.state == JobState.Failed || ar.state == JobState.Canceled);
            JobFailure = (ar.state == JobState.Failed);
            ReturnCode = ar.returnCode;
            Output = ar.consoleOutput;

            State = Enum.GetName(typeof(JobState), ar.state);
        }

        public bool Finished { get; private set; }
        public bool JobFailure { get; private set; }
        public int ReturnCode { get; private set; }
        public string Output { get; private set; }
        public string State { get; private set; }
    }

    public class GroupMembershipChangeResult
    {
        public enum GroupMembershipChangeOutcome : byte
        {
            Success = 0,
            MemberInOtherGroup = 1,
            MachineAccountNotExist = 2,
            MachineNotInGroup = 3,
        }

        public string ConsoleID {get; set;}
        public GroupMembershipChangeOutcome Outcome {get; set;}
        public IEnumerable<Guid> ConflictingGroups {get; set;}
    }

    public class InvalidConsoleResult
    {
        public string ConsoleID { get; set; }
        public uint FlashVersion { get; set; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\LiveHiveSetting.cs ===
using System;
using System.Data.SqlClient;
using LiveHiveSettingV1 = xonline.mix.settingsmanagement.contracts.V1.LiveHiveSetting;
using LiveHiveSettingV2 = xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting;

namespace YellowDoor
{
    public class LiveHiveSettingsEntry
    {
        public static string GetCBControlName(string name)
        {
            return string.Format("LHS_CB_{0}", name);
        }

        public static string GetTBControlName(string name)
        {
            return string.Format("LHS_TB_{0}", name);
        }

        public static LiveHiveSettingsEntry FromServiceEntry(LiveHiveSettingV1 serviceEntry)
        {
            LiveHiveSettingsEntry entry = new LiveHiveSettingsEntry(serviceEntry.Name);
            entry.Value = serviceEntry.Value;
            entry.BuildId = (serviceEntry.Config.Build.HasValue) ? serviceEntry.Config.Build.Value : (ushort)0;
            return entry;
        }

        public static LiveHiveSettingsEntry FromServiceEntry(LiveHiveSettingV2 serviceEntry)
        {
            LiveHiveSettingsEntry entry = new LiveHiveSettingsEntry(serviceEntry.Name);
            entry.Value = serviceEntry.Value;
            entry.BuildId = (serviceEntry.Config.Build.HasValue) ? serviceEntry.Config.Build.Value : (ushort)0;
            return entry;
        }

        public static LiveHiveSettingsEntry FromDbReader(SqlDataReader reader)
        {
            LiveHiveSettingsEntry entry = new LiveHiveSettingsEntry(reader["vc_setting"] as string);
            entry.Value = reader["vc_value"] as string;
            entry.BuildId = 0;
            return entry;
        }

        public string SettingName { get; set; }
        public string Value { get; set; }
        public string DiffValue { get; set; }
        public ushort BuildId { get; set; }

        public LiveHiveSettingsEntry(string name)
        {
            this.SettingName = name;
        }

        public string CheckBoxControlId
        {
            get
            {
                return GetCBControlName(SettingName);
            }
        }

        public string TextBoxControlId
        {
            get
            {
                return GetTBControlName(SettingName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\JobStatus.aspx.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.Configuration;

namespace YellowDoor
{
    public partial class JobStatus : YellowDoorPage
    {
        protected Panel pnlReleases;
        protected Panel pnlFlashes;
        protected Panel pnlNoData;
        protected Repeater rptrReleases;
        protected Repeater rptrFlashes;

        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.FlashReadWrite);

            IngestionUtil.Initialize();

            Response.AddHeader("Refresh", "30");
            pnlFlashes.Visible = false;
            pnlReleases.Visible = false;
            pnlNoData.Visible = false;

            List<IAsyncResult> flashList = Session["flashList"] as List<IAsyncResult>;
            List<IAsyncResult> releaseList = Session["releaseList"] as List<IAsyncResult>;

            if (((flashList == null) || (flashList != null && flashList.Count == 0)) &&
                ((releaseList == null) || (releaseList != null && releaseList.Count == 0)))
            {
                pnlNoData.Visible = true;
            }
            else
            {
                if (flashList != null && flashList.Count > 0)
                {
                    IAsyncResult[] displayFlashList = new IAsyncResult[flashList.Count];
                    Array.Copy(flashList.ToArray(), displayFlashList, flashList.Count);
                    Array.Reverse(displayFlashList);

                    pnlFlashes.Visible = true;
                    rptrFlashes.DataSource = displayFlashList;
                    rptrFlashes.DataBind();
                }

                if (releaseList != null && releaseList.Count > 0)
                {
                    IAsyncResult[] displayReleaseList = new IAsyncResult[releaseList.Count];
                    Array.Copy(releaseList.ToArray(), displayReleaseList, releaseList.Count);
                    Array.Reverse(displayReleaseList);

                    pnlReleases.Visible = true;
                    rptrReleases.DataSource = displayReleaseList;
                    rptrReleases.DataBind();
                }
            }
        }

        protected void releaseRepeater_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {
            IAsyncResult result = e.Item.DataItem as IAsyncResult;

            if (result != null)
            {
                PropReleaseTask task = result.AsyncState as PropReleaseTask;
                Label lblName = e.Item.FindControl("lblName") as Label;
                Label lblStatus = e.Item.FindControl("lblStatus") as Label;

                if (task != null && lblName != null && lblStatus != null)
                {
                    lblName.Text = task.Release.Name;

                    lblStatus.Text = string.Format("<span style='background-color:{0};'>Complete: {1} </span><br />", 
                        (result.IsCompleted) ? "lightgreen" : "yellow",
                        result.IsCompleted);
                    lblStatus.Text += task.TaskProgress.Replace("\r", "<br />") + "<br />";

                    if (result.IsCompleted)
                    {
                        if (task.HasException)
                        {
                            lblStatus.Text += "<span style='background-color:red;'><strong>Exception hit during propping. See below for details.</strong></span><br />";
                            lblStatus.Text += task.Exception.Message;
                        }
                        else
                        {
                            if (!task.IsBaseFlashPropped)
                            {
                                lblStatus.Text += String.Format("Warning: Base flash ({0}) is not propped! Click 'New Flash' on the left to prop it now.", task.Release.BaseFlash);
                            }
                        }
                    }
                }
            }
        }

        protected void flashRepeater_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {
            IAsyncResult result = e.Item.DataItem as IAsyncResult;

            if (result != null)
            {
                PropFlashTask task = result.AsyncState as PropFlashTask;
                Label lblName = e.Item.FindControl("lblName") as Label;
                Label lblStatus = e.Item.FindControl("lblStatus") as Label;

                if (task != null && lblName != null && lblStatus != null)
                {
                    lblName.Text = Path.GetFileName(task.CabFilePath);

                    lblStatus.Text = string.Format("<span style='background-color:{0};'>Complete: {1} </span><br />", 
                        (result.IsCompleted) ? "lightgreen" : "yellow", 
                        result.IsCompleted);
                    lblStatus.Text += task.TaskProgress.Replace("\r", "<br />") + "<br />";

                    if (result.IsCompleted)
                    {
                        if (task.HasException)
                        {
                            lblStatus.Text += "<span style='background-color:red;'><strong>Exception hit during propping. See below for details.</strong></span><br />";
                            lblStatus.Text += task.Exception.Message;
                        }

                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Logger.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using Microsoft.Win32;

namespace YellowDoor
{
    public class Logger
    {
        private static string _defaultLogLocation = "C:\\inetpub\\logs\\";

        public static void Log(string info)
        {
            string id = (HttpContext.Current == null) ? string.Empty : HttpContext.Current.Request.LogonUserIdentity.Name;
            string process = (HttpContext.Current == null) ? string.Empty : HttpContext.Current.Request.Url.PathAndQuery;
            string environment = (HttpContext.Current == null || HttpContext.Current.Session["environment"] == null) ?
                string.Empty :
                ((Environment)HttpContext.Current.Session["environment"]).Name;
            string instance = (HttpContext.Current == null) ? string.Empty : HttpContext.Current.Request.ServerVariables["INSTANCE_ID"].ToString();

            Log(instance, process, environment, id, info);
        }

        public static void Log(string instance, string process, string environment, string id, string info)
        {
            try
            {
                Logger.GetInstance().WriteLine(instance, process, environment, id, info);
            }
            catch 
            {
                
            }
        }

        private static Logger _instance;
        private static object _lockObject =  new object();

        private static Logger GetInstance()
        {
            if (_instance == null)
            {
                lock (_lockObject)
                {
                    if (_instance == null)
                    {
                        _instance = new Logger();
                    }
                }
            }

            return _instance;
        }

        private Logger()
        {
            
        }

        ~Logger()
        {
        }

        private void WriteLine(string instance, string process, string environment, string id, string info)
        {

            string folderPath = GetLogFolderPath();
            string filePath = GetLogFilePath();

            if (string.IsNullOrEmpty(filePath) || string.IsNullOrEmpty(folderPath))
            {
                throw new Exception("File or folder path bad");
            }

            string finalDirectory = string.Format("{0}\\{1}\\", folderPath, instance );
            string finalPath = string.Format("{0}\\{1}", finalDirectory, filePath);

            if (!Directory.Exists(finalDirectory))
            {
                Directory.CreateDirectory(finalDirectory);
            }

            if (!File.Exists(finalPath))
            {
                lock (_lockObject)
                {
                    if (!File.Exists(finalPath))
                    {
                        using (FileStream createdFile = File.Open(finalPath, FileMode.CreateNew, FileAccess.Write, FileShare.Write))
                        {
                            createdFile.Flush();
                            createdFile.Close();
                        }
                    }
                }
            }

            lock (_lockObject)
            {
                using (StreamWriter _logWriter = new StreamWriter(File.Open(finalPath, FileMode.Open, FileAccess.Write, FileShare.Write)))
                {
                    _logWriter.BaseStream.Seek(0, SeekOrigin.End);
                    _logWriter.WriteLine(string.Format("{0}|{1}|{2}|{3}",
                        DateTime.UtcNow.ToShortTimeString(),
                        id,
                        process,
                        info));

                    _logWriter.Flush();
                    _logWriter.BaseStream.Flush();
                }
            }
        }

        private string GetLogFolderPath()
        {
            string folder = string.Empty;

            try
            {
                RegistryKey hklm = Registry.LocalMachine;
                RegistryKey logKey = hklm.OpenSubKey("Software\\Microsoft\\YellowDoor");
                folder = logKey.GetValue("filelocation") as string;
                
            }
            catch
            {
                folder = Logger._defaultLogLocation;
            }

            folder += "YellowDoor\\";

            if (!Directory.Exists(folder))
            {
                Directory.CreateDirectory(folder);
            }

            return folder;
        }

        private string GetLogFilePath()
        {
            string filename = DateTime.UtcNow.ToString("u"); // 2002-01-03 00:00:00Z
            filename = filename.Split(' ')[0]; // 2002-01-03
            filename = filename.Replace('-', '_');
            filename += ".log";

            return filename;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ManageXblobs.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {

    public partial class WebForm9 {
        /// <summary>
        /// txtXblobName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtXblobName;

        /// <summary>
        /// btnAdd control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAdd;

        /// <summary>
        /// preText control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preText;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\MixSettingsManagement.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Text;
using System.Web;
using System.Web.Configuration;
using System.Xml.Linq;

using xonline.mix.settingsmanagement.contracts;
using xonline.mix.common;

using LiveHiveSettingV1 = xonline.mix.settingsmanagement.contracts.V1.LiveHiveSetting;
using LiveHiveConfigV1 = xonline.mix.settingsmanagement.contracts.V1.LiveHiveConfig;
using LiveHiveSettingV2 = xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting;
using LiveHiveConfigV2 = xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig;

namespace YellowDoor
{
    public static class SettingsManagementClientFactory
    {
        public static ISettingsManagementClient CreateClient(IEnvironment env)
        {
            string url = env.WebSgMixUrl + WebConfigurationManager.AppSettings["Environment.MixSettingsManagementUrl"];
            switch (env.MixVersionSettingsManagement)
            {
                case 1:
                    return new SettingsManagementClientV1(env.WebSgCertificate, url);
                case 2:
                    return new SettingsManagementClientV2(env.WebSgCertificate, url);
                default:
                    throw new NotSupportedException("Unsupported MixVersionSettingsManagement");
            }
        }
    }

    public interface ISettingsManagementClient
    {
        LiveHiveSettingsEntry[] GetSettings(Guid GroupId, ushort BuildId);

        void SetSetting(Guid GroupId, ushort BuildId, string Name, string Value);

        XElement IngestEtxManifest(string etxLocationSpecifier);
    }

    public class SettingsManagementClientV1 : ISettingsManagementClient
    {
        private MixSettingsManagementClient Client
        {
            get
            {
                MixSettingsManagementClient client = new MixSettingsManagementClient(MixUtil.GetBinding(Certificate != null), new EndpointAddress(RemoteAddress));
                if (Certificate != null)
                {
                    client.ChannelFactory.Credentials.ClientCertificate.Certificate = Certificate;
                }
                return client;
            }
        }

        private X509Certificate2 Certificate { get; set; }

        private string RemoteAddress { get; set; }

        public SettingsManagementClientV1(X509Certificate2 clientCert, string remoteAddress)
        {
            Certificate = clientCert;
            RemoteAddress = remoteAddress;
        }

        public LiveHiveSettingsEntry[] GetSettings(Guid GroupId, ushort BuildId)
        {
            LiveHiveConfigV1 config = GetConfig(GroupId, BuildId);

            LiveHiveSettingV1[] serviceResults = null;
            Logger.Log(string.Format("Calling GetSettings {0}", MixUtil.GetValueForLog(config)));

            MixUtil.InvokeAction<MixSettingsManagementClient, MixSettingsManagement>(Client, 
                Certificate, 
                1,
                (x) => { serviceResults = x.GetSettings(config); });

            LiveHiveSettingsEntry[] results = new LiveHiveSettingsEntry[serviceResults.Length];

            for (int idx = 0; idx < serviceResults.Length; idx++)
            {
                results[idx] = LiveHiveSettingsEntry.FromServiceEntry(serviceResults[idx]);
            }

            return results;
        }

        public void SetSetting(Guid GroupId, ushort BuildId, string Name, string Value)
        {
            LiveHiveConfigV1 config = GetConfig(GroupId, BuildId);
            LiveHiveSettingV1 setting = GetSetting(config, Name, Value);

            Logger.Log(string.Format("Calling SetSetting {0}, {1}, {2}", MixUtil.GetValueForLog(config), Name, Value));
            MixUtil.InvokeAction<MixSettingsManagementClient, MixSettingsManagement>(Client,
                Certificate, 1, (x) => { x.SetSetting(config, setting); });
        }

        private LiveHiveConfigV1 GetConfig(Guid GroupId, ushort BuildId)
        {
            LiveHiveConfigV1 config = new xonline.mix.settingsmanagement.contracts.V1.LiveHiveConfig();
            config.BetaGroupId = GroupId;
            config.PlatformType = xonline.mix.settingsmanagement.contracts.V1.PlatformType.Xenon;
            config.Build = BuildId; 
            config.Qfe = 0; // hardcoded value required, specified by ChrisBan
            return config;
        }

        private LiveHiveSettingV1 GetSetting(LiveHiveConfigV1 Config, string Name, string Value)
        {
            LiveHiveSettingV1 setting = new xonline.mix.settingsmanagement.contracts.V1.LiveHiveSetting();
            setting.Config = Config;
            setting.Name = Name;
            setting.Value = Value;
            return setting;
        }

        public XElement IngestEtxManifest(string etxLocationSpecifier)
        {
            throw new NotSupportedException("The interface MixSettingsManagementClientV1 does not support IngestEtxManifest.  V2 is required.");
        }
    }

    public partial class SettingsManagementClientV2 : ISettingsManagementClient
    {
        private MixSettingsManagementV2Client Client
        {
            get
            {
                MixSettingsManagementV2Client client = new MixSettingsManagementV2Client(MixUtil.GetBinding(Certificate != null), new EndpointAddress(RemoteAddress));
                if (Certificate != null)
                {
                    client.ChannelFactory.Credentials.ClientCertificate.Certificate = Certificate;
                }
                return client;
            }
        }

        private X509Certificate2 Certificate { get; set; }

        private string RemoteAddress { get; set; }

        public SettingsManagementClientV2(X509Certificate2 clientCert, string remoteAddress)
        {
            Certificate = clientCert;
            RemoteAddress = remoteAddress;
        }

        public LiveHiveSettingsEntry[] GetSettings(Guid GroupId, ushort BuildId)
        {
            LiveHiveConfigV2 config = GetConfig(GroupId, BuildId);

            LiveHiveSettingV2[] serviceResults = null;
            Logger.Log(string.Format("Calling GetSettings {0}", MixUtil.GetValueForLog(config)));

            MixUtil.InvokeAction<MixSettingsManagementV2Client, MixSettingsManagementV2>(Client, 
                Certificate, 
                1,
                (x) => { serviceResults = x.GetSettings(config); });

            LiveHiveSettingsEntry[] results = new LiveHiveSettingsEntry[serviceResults.Length];

            for (int idx = 0; idx < serviceResults.Length; idx++)
            {
                results[idx] = LiveHiveSettingsEntry.FromServiceEntry(serviceResults[idx]);
            }

            return results;
        }

        public void SetSetting(Guid GroupId, ushort BuildId, string Name, string Value)
        {
            LiveHiveConfigV2 config = GetConfig(GroupId, BuildId);
            LiveHiveSettingV2 setting = GetSetting(config, Name, Value);

            Logger.Log(string.Format("Calling SetSetting {0}, {1}, {2}", MixUtil.GetValueForLog(config), Name, Value));
            MixUtil.InvokeAction<MixSettingsManagementV2Client, MixSettingsManagementV2>(Client,
                Certificate, 1, (x) => { x.SetSetting(config, setting); });
        }

        private LiveHiveConfigV2 GetConfig(Guid GroupId, ushort BuildId)
        {
            LiveHiveConfigV2 config = new xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig();
            config.BetaGroupId = GroupId;
            config.PlatformType = xonline.mix.settingsmanagement.contracts.V2.PlatformType.Xenon;
            config.Build = BuildId; 
            config.Qfe = 0; // hardcoded value required, specified by ChrisBan
            return config;
        }

        private LiveHiveSettingV2 GetSetting(LiveHiveConfigV2 Config, string Name, string Value)
        {
            LiveHiveSettingV2 setting = new xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting();
            setting.Config = Config;
            setting.Name = Name;
            setting.Value = Value;
            return setting;
        }

        public XElement IngestEtxManifest(string etxLocationSpecifier)
        {
            XElement ingestion;

            int build;

            ingestion = new XElement(ELEMENT_ROOT_INGESTION);

            try
            {
                if (int.TryParse(etxLocationSpecifier, out build))
                {
                    ingestion.Add(IngestEtxManifestFromBuildVersion(build));
                }
                else if (Directory.Exists(etxLocationSpecifier))
                {
                    ingestion.Add(IngestEtxManifestFromDirectory(etxLocationSpecifier));
                }
                else
                {
                    if (etxLocationSpecifier.EndsWith(".release", StringComparison.OrdinalIgnoreCase))
                    {
                        ingestion.Add(IngestEtxManifestFromReleasePackage(etxLocationSpecifier));
                    }
                    else
                    {
                        ingestion.Add(IngestEtxManifestFromFile(etxLocationSpecifier));
                    }
                }
            }
            catch (Exception e)
            {
                AddIngestionError(ingestion, e, "Operation terminating! Unexpected error encountered.");
            }
            
            return ingestion;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\MixTitleManagement.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Text;
using System.Web;
using System.Web.Configuration;

using xonline.mix.titlemanagement.contracts;
using xonline.mix.common;

using MixTitleVersions = xonline.mix.titlemanagement.contracts.V1.TitleVersions;
using MixPlatformType = xonline.mix.titlemanagement.contracts.V1.PlatformType;

namespace YellowDoor
{
    public static class TitleManagementClientFactory
    {
        public static ITitleManagementClient CreateClient(IEnvironment env)
        {
            string url = env.WebSgMixUrl + WebConfigurationManager.AppSettings["Environment.MixTitleManagementUrl"];
            switch (env.MixVersionTitleManagement)
            {
                case 1:
                    return new MixTitleManagementClientV1(env.WebSgCertificate, url);

                default:
                    throw new NotSupportedException("Unsupported MixVersionTitleManagement");
            }
        }
    }

    public interface ITitleManagementClient
    {
        TitleVersionInstance[] GetTitleVersions(uint titleId, IEnvironment env);

        void AddBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup);

        void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup);
    }

    public class MixTitleManagementClientV1 : ITitleManagementClient
    {
        private MixTitleManagementClient Client
        {
            get
            {
                MixTitleManagementClient client = new MixTitleManagementClient(MixUtil.GetBinding(Certificate != null), new EndpointAddress(RemoteAddress));
                if (Certificate != null)
                {
                    client.ChannelFactory.Credentials.ClientCertificate.Certificate = Certificate;
                }
                return client;
            }
        }

        private X509Certificate2 Certificate { get; set; }

        private string RemoteAddress { get; set; }

        public MixTitleManagementClientV1(X509Certificate2 clientCert, string remoteAddress)
        {
            Certificate = clientCert;
            RemoteAddress = remoteAddress;
        }

        public TitleVersionInstance[] GetTitleVersions(uint titleId, IEnvironment env)
        {
            MixTitleVersions serviceResults = null;

            Logger.Log(string.Format("Calling GetTitleVersions {0}", titleId));

            MixUtil.InvokeAction<MixTitleManagementClient, MixTitleManagement>(Client,
                Certificate,
                1,
                (x) => { serviceResults = x.GetTitleVersions(titleId); });

            TitleVersionInstance[] results = new TitleVersionInstance[serviceResults.Versions.Length];

            for (int idx = 0; idx < serviceResults.Versions.Length; idx++)
            {
                results[idx] = TitleVersionInstance.FromServiceInstance(serviceResults.Versions[idx], env);
            }

            return results;
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
             MixPlatformType pt = (xonline.mix.titlemanagement.contracts.V1.PlatformType)platformType;

             Logger.Log(string.Format("Calling AddBaseVersion {0}, {1}, {2}, {3}", titleId, version, platformType.ToString(), betaGroup));
             MixUtil.InvokeAction<MixTitleManagementClient, MixTitleManagement>(Client,
                 Certificate,
                 1,
                 (x) => { x.AddBaseVersion(titleId, version, pt, betaGroup); } );
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            MixPlatformType pt = (xonline.mix.titlemanagement.contracts.V1.PlatformType)platformType;

            Logger.Log(string.Format("Calling RemoveBaseVersion {0}, {1}, {2}, {3}", titleId, version, platformType.ToString(), betaGroup));
            MixUtil.InvokeAction<MixTitleManagementClient, MixTitleManagement>(Client,
                Certificate,
                1,
                (x) => { x.RemoveBaseVersion(titleId, version, pt, betaGroup); });
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\MixGroupManagement.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Text;
using System.Web;
using System.Web.Configuration;

using xonline.mix.betamanagement.contract;
using xonline.mix.common;

using GroupSummaryV1 = xonline.mix.betamanagement.contracts.V1.GroupSummary;
using GroupSummaryV2 = xonline.mix.betamanagement.contracts.V2.GroupSummary;
using InvalidConsole = xonline.mix.betamanagement.contracts.V2.InvalidConsole;

namespace YellowDoor
{
    public static class BetaManagementClientFactory
    {
        public static IBetaManagementClient CreateClient(IEnvironment env)
        {
            string url = env.WebSgMixUrl + WebConfigurationManager.AppSettings["Environment.MixBetaManagementUrl"];
            switch (env.MixVersionBetaManagement)
            {
                case 1:
                    return new BetaManagementClientV1(env.WebSgCertificate, url);

                case 2:
                    return new BetaManagementClientV2(env.WebSgCertificate, url);

                default:
                    throw new NotSupportedException("Unsupported MixVersionBetaManagement");
            }
        }
    }

    public interface IBetaManagementClient
    {
        Group GetGroupInfo(Guid id);

        Group.GroupSummary[] GetAllGroupSummaries();

        bool IsFlashPropped(uint flashTitleId, uint version);

        void AssignFlashReleaseToGroup(Release release, Guid groupId, uint flashTitleId, uint minUpgradeVersion);

        GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId);

        GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId);

        string[] GetConsoleIdsForGroup(Guid groupId);

        Guid CreateGroup(string name, string creator);

        InvalidConsoleResult[] ValidateBetaGroupConsoles(Guid groupId);

    }

    public class BetaManagementClientV1 : IBetaManagementClient
    {
        private MixBetaManagementClient Client 
        {
            get
            {
                MixBetaManagementClient client = new MixBetaManagementClient(MixUtil.GetBinding(Certificate != null), new EndpointAddress(RemoteAddress));
                if (Certificate != null)
                {
                    client.ChannelFactory.Credentials.ClientCertificate.Certificate = Certificate;
                }
                return client;
            }
        }

        private X509Certificate2 Certificate { get; set; }

        private string RemoteAddress { get; set; }

        public BetaManagementClientV1(X509Certificate2 clientCert, string remoteAddress)
        {
            Certificate = clientCert;
            RemoteAddress = remoteAddress;
        }

        public Group GetGroupInfo(Guid id)
        {
            xonline.mix.betamanagement.contracts.V1.Group mixGroup = null;
            Logger.Log(string.Format("Calling GetGroupDetails {0}", id));
            MixUtil.InvokeAction<MixBetaManagementClient, MixBetaManagement>(Client, Certificate, 1, (x) => { mixGroup = x.GetGroupDetails(id); });
            Group group = new Group();
            group.Summary = new Group.GroupSummary();
            group.Summary.Id = mixGroup.Summary.GroupGuid;
            group.Summary.Name = mixGroup.Summary.Name;
            group.Summary.Creator = mixGroup.Summary.Creator;
            group.Summary.Created = mixGroup.Summary.Created;
            group.Summary.FullFlashVersion = mixGroup.Summary.FlashVersion;
            group.Titles = new Dictionary<uint, Group.TitleInfo>();
            foreach (var x in mixGroup.Titles)
            {
                if (!group.Titles.ContainsKey(x.TitleId))
                {
                    group.Titles[x.TitleId] = new Group.TitleInfo();
                    group.Titles[x.TitleId].TitleId = x.TitleId;
                    group.Titles[x.TitleId].ConsoleType = (byte)x.ConsoleType;
                    group.Titles[x.TitleId].UpgradePaths = new List<Group.UpgradeInfo>();
                }

                Group.UpgradeInfo upgInfo = new Group.UpgradeInfo();
                upgInfo.BaseVersion = x.BaseVersion;
                upgInfo.UpgradeVersion = x.UpgradeVersion;
                upgInfo.StartTime = DateTime.MinValue;
                upgInfo.EndTime = DateTime.MaxValue;
                group.Titles[x.TitleId].UpgradePaths.Add(upgInfo);
            }
            group.RelInfos = new List<Group.ReleaseInfo>();
            foreach (var x in mixGroup.RelInfos)
            {
                Group.ReleaseInfo relInfo = new Group.ReleaseInfo();
                relInfo.FlashQfe = x.FlashQfe;
                relInfo.FlashVersion = x.FlashVersion;
                relInfo.SMRevision = x.SMRevision;
                relInfo.SOMRevision = x.SOMRevision;
                group.RelInfos.Add(relInfo);
            }
            return group;
        }

        public Group.GroupSummary[] GetAllGroupSummaries()
        {
            IEnumerable<GroupSummaryV1> mixGroups = null;
            Logger.Log("Getting Groups");
            MixUtil.InvokeAction<MixBetaManagementClient, MixBetaManagement>(Client, Certificate, 1, (x) => { mixGroups = x.GetGroups(); });

            List<Group.GroupSummary> groupSummaries = new List<Group.GroupSummary>();
            if (mixGroups != null)
            {
                foreach (GroupSummaryV1 result in mixGroups)
                {
                    groupSummaries.Add(MixUtil.GroupSummaryV1ToGroupSummary(result));
                }
            }

            return groupSummaries.ToArray();
        }

        public bool IsFlashPropped(uint flashTitleId, uint version)
        {
            bool isPropped = false;
            Logger.Log(string.Format("Calling IsFlashPropped {0}, {1}", flashTitleId, version));
            MixUtil.InvokeAction<MixBetaManagementClient, MixBetaManagement>(Client, Certificate, 1, (x) => { isPropped = x.IsTitleVersionPropped(flashTitleId, version); });
            return isPropped;
        }

        public void AssignFlashReleaseToGroup(Release release, Guid groupId, uint flashTitleId, uint minUpgradeVersion)
        {
            bool isPropped = true;
            Logger.Log(string.Format("Calling IsTitleVersionPropped {0}, {1}", flashTitleId, release.FullBaseFlash));
            MixUtil.InvokeAction<MixBetaManagementClient, MixBetaManagement>(Client, Certificate, 1,
                 (x) =>
                 {
                     isPropped = x.IsTitleVersionPropped(
                         flashTitleId,
                         release.FullBaseFlash);
                 });

            Logger.Log(string.Format("Calling AssignReleaseToGroup {0}, {1}, {2}, {3}, {4}, {5}, {6}", minUpgradeVersion,
                        release.FullBaseFlash,
                        release.SystemOnlineManifestRevision,
                        release.SystemManifestRevision,
                        groupId,
                        flashTitleId,
                        isPropped));

            MixUtil.InvokeAction<MixBetaManagementClient, MixBetaManagement>(Client, Certificate, 1,
                (x) =>
                {
                    x.AssignReleaseToGroup(
                        minUpgradeVersion,
                        release.FullBaseFlash,
                        release.SystemOnlineManifestRevision,
                        release.SystemManifestRevision,
                        groupId,
                        flashTitleId,
                        isPropped);
                }

                );
        }

        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId)
        {
            throw new NotSupportedException("The interface MixBetaManagementClientV1 does not support AddConsoleIdsToGroup");
        }

        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId)
        {
            throw new NotSupportedException("The interface MixBetaManagementClientV1 does not support RemoveConsoleIdsFromGroup");
        }

        public string[] GetConsoleIdsForGroup(Guid groupId)
        {
            throw new NotSupportedException("The interface MixBetaManagementClientV1 does not support GetConsoleIdsForGroup");
        }

        public Guid CreateGroup(string name, string creator)
        {
            throw new NotSupportedException("The interface MixBetaManagementClientV1 does not support CreateGroup");
        }

        public InvalidConsoleResult[] ValidateBetaGroupConsoles(Guid groupId)
        {
            throw new NotSupportedException("The interface MixBetaManagementClientV1 does not support ValidateBetaGroupConsoles");
        }
    }

    public class BetaManagementClientV2 : IBetaManagementClient
    {
        private MixBetaManagementV2Client Client 
        {
            get
            {
                MixBetaManagementV2Client client = new MixBetaManagementV2Client(MixUtil.GetBinding(Certificate != null), new EndpointAddress(RemoteAddress));
                if (Certificate != null)
                {
                    client.ChannelFactory.Credentials.ClientCertificate.Certificate = Certificate;
                }
                return client;
            }
        }

        private X509Certificate2 Certificate { get; set; }

        private string RemoteAddress { get; set; }

        public BetaManagementClientV2(X509Certificate2 clientCert, string remoteAddress)
        {
            Certificate = clientCert;
            RemoteAddress = remoteAddress;
        }

        public Group GetGroupInfo(Guid id)
        {
            xonline.mix.betamanagement.contracts.V2.Group mixGroup = null;
            Logger.Log(string.Format("Calling GetGroupDetails {0}", id));
            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1, (x) => { mixGroup = x.GetGroupDetails(id); });
            Group group = new Group();
            group.Summary = new Group.GroupSummary();
            group.Summary.Id = mixGroup.Summary.GroupGuid;
            group.Summary.Name = mixGroup.Summary.Name;
            group.Summary.Creator = mixGroup.Summary.Creator;
            group.Summary.Created = mixGroup.Summary.Created;
            group.Summary.FullFlashVersion = mixGroup.FlashVersion;
            group.Titles = new Dictionary<uint, Group.TitleInfo>();
            foreach (var x in mixGroup.Titles)
            {
                if (!group.Titles.ContainsKey(x.TitleId))
                {
                    group.Titles[x.TitleId] = new Group.TitleInfo();
                    group.Titles[x.TitleId].TitleId = x.TitleId;
                    group.Titles[x.TitleId].ConsoleType = (byte)x.ConsoleType;
                    group.Titles[x.TitleId].UpgradePaths = new List<Group.UpgradeInfo>();
                }

                Group.UpgradeInfo upgInfo = new Group.UpgradeInfo();
                upgInfo.BaseVersion = x.BaseVersion;
                upgInfo.UpgradeVersion = x.UpgradeVersion;
                upgInfo.StartTime = DateTime.MinValue;
                upgInfo.EndTime = DateTime.MaxValue;
                group.Titles[x.TitleId].UpgradePaths.Add(upgInfo);
            }
            group.RelInfos = new List<Group.ReleaseInfo>();
            foreach (var x in mixGroup.RelInfos)
            {
                Group.ReleaseInfo relInfo = new Group.ReleaseInfo();
                relInfo.FlashQfe = x.FlashQfe;
                relInfo.FlashVersion = x.FlashVersion;
                relInfo.SMRevision = x.SMRevision;
                relInfo.SOMRevision = x.SOMRevision;
                group.RelInfos.Add(relInfo);
            }
            return group;
        }

        public Group.GroupSummary[] GetAllGroupSummaries()
        {
            IEnumerable<GroupSummaryV2> mixGroups = null;
            Logger.Log("Calling GetGroups");
            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1, (x) => { mixGroups = x.GetGroups(); });

            List<Group.GroupSummary> groupSummaries = new List<Group.GroupSummary>();
            if (mixGroups != null)
            {
                foreach (GroupSummaryV2 result in mixGroups)
                {
                    groupSummaries.Add(MixUtil.GroupSummaryV2ToGroupSummary(result));
                }
            }

            return groupSummaries.ToArray();
        }

        public bool IsFlashPropped(uint flashTitleId, uint version)
        {
            bool isPropped = false;
            Logger.Log(string.Format("Calling IsTitleVersionPropped {0}, {1}", flashTitleId, version));
            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1, (x) => { isPropped = x.IsTitleVersionPropped(flashTitleId, version); });
            return isPropped;
        }

        public void AssignFlashReleaseToGroup(Release release, Guid groupId, uint flashTitleId, uint minUpgradeVersion)
        {
            bool isPropped = true;
            Logger.Log(string.Format("Calling IsTitleVersionPropped {0}, {1}", flashTitleId, release.FullBaseFlash));
            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                 (x) =>
                 {
                     isPropped = x.IsTitleVersionPropped(
                         flashTitleId,
                         release.FullBaseFlash);
                 });

            Logger.Log(string.Format("Calling AssignReleaseToGroup {0}, {1}, {2}, {3}, {4}, {5}, {6}", minUpgradeVersion,
                        release.FullBaseFlash,
                        release.SystemOnlineManifestRevision,
                        release.SystemManifestRevision,
                        groupId,
                        flashTitleId,
                        isPropped));

            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                (x) =>
                {
                    x.AssignReleaseToGroup(
                        minUpgradeVersion,
                        release.FullBaseFlash,
                        release.SystemOnlineManifestRevision,
                        release.SystemManifestRevision,
                        groupId,
                        flashTitleId,
                        isPropped);
                }

                );
        }

        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId)
        {
            List<GroupMembershipChangeResult> status = new List<GroupMembershipChangeResult>();

            Logger.Log(string.Format("Calling AddConsoleIDsToGroup {0} {1}", MixUtil.GetValueForLog(consoleIds), groupId));

            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                (x) =>
                {
                    var ret = x.AddConsoleIDsToGroup(consoleIds, groupId);
                    foreach (var r in ret)
                    {
                        GroupMembershipChangeResult s = new GroupMembershipChangeResult();
                        s.ConsoleID = r.ConsoleID;
                        s.Outcome = (GroupMembershipChangeResult.GroupMembershipChangeOutcome)(byte)r.Outcome;
                        status.Add(s);
                    }
                }
            );
            return status.ToArray();
        }

        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId)
        {
            List<GroupMembershipChangeResult> status = new List<GroupMembershipChangeResult>();

            Logger.Log(string.Format("Calling RemoveConsoleIDsFromGroup {0}, {1}", MixUtil.GetValueForLog(consoleIds), groupId));

            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                (x) =>
                {
                    var ret = x.RemoveConsoleIDsFromGroup(consoleIds, groupId);
                    foreach (var r in ret)
                    {
                        GroupMembershipChangeResult s = new GroupMembershipChangeResult();
                        s.ConsoleID = r.ConsoleID;
                        s.Outcome = (GroupMembershipChangeResult.GroupMembershipChangeOutcome)(byte)r.Outcome;
                        status.Add(s);
                    }
                }
            );

            return status.ToArray();
        }

        public string[] GetConsoleIdsForGroup(Guid groupId)
        {
            string[] consoleIds = null;
            Logger.Log(String.Format("Calling GetConsoleIDsInGroup {0}", groupId));
            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                (x) => { consoleIds = x.GetConsoleIDsInGroup(groupId); }
            );
            return consoleIds;
        }

        public Guid CreateGroup(string name, string creator)
        {
            Guid newGuid = new Guid();
            Logger.Log(String.Format("Calling CreateGroup {0}, {1}", name, creator));
            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                (x) => { newGuid = x.CreateGroup(name, creator); }
            );
            return newGuid;
        }

        public InvalidConsoleResult[] ValidateBetaGroupConsoles(Guid groupId)
        {
            List<InvalidConsoleResult> results = new List<InvalidConsoleResult>();

            Logger.Log(string.Format("Calling ValidateBetaGroupConsoles {0}", groupId));

            MixUtil.InvokeAction<MixBetaManagementV2Client, MixBetaManagementV2>(Client, Certificate, 1,
                (x) =>
                {
                    var ret = x.ValidateBetaGroupConsoles(groupId);
                    foreach (var r in ret)
                    {
                        InvalidConsoleResult result = new InvalidConsoleResult();
                        result.ConsoleID = r.ConsoleId;
                        result.FlashVersion = r.FlashVersion;
                        results.Add(result);
                    }
                }
            );

            return results.ToArray();            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ManageXblobs.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Configuration;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm9 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.SuperUser);      

            // Let's see if ADT is calling us, by using a query string.
            string xblob = HttpContext.Current.Request.QueryString.Get("Add");

            if(xblob != null)
            {
                // If there's an exception, pass it up so that there's a 500.
                AddXblobToDatabase(xblob);
            }
        }

        protected void btnAdd_Click(object sender, EventArgs e)
        {
            StringBuilder output = new StringBuilder();

            // Set up controls.
            preText.Visible = true;
            btnAdd.Enabled = false;
            txtXblobName.Enabled = false;

            try
            {
                output.AppendFormat("Verifying connectivity to {0}...", txtXblobName.Text);

                // Make sure file path is writeable
                //
                // TODO: Uncomment when working!
                //string testPath = Path.Combine(uploadPath, "test.txt");
                //using (FileStream fs = File.Create(testPath)) { }

                output.Append("success!");

                AddXblobToDatabase(txtXblobName.Text);
            }
            catch (Exception ex)
            {
                output.Append("An exception occurred while trying to add this Xblob.  See exception for details\n");
                output.Append(ex.Message);
                output.Append(ex.StackTrace);
            }

            preText.InnerText = output.ToString();
        }

        private void AddXblobToDatabase(string xblobName)
        {
            string mixUrl = String.Format(@"http://{0}:12000/mixbetamanagement/mixbetamanagementv2.svc", xblobName);
            string toolsMgmtUrl = String.Format(@"http://{0}:12000/wctoolsmgmt/toolsmgmt.asmx", xblobName);
            string sysUpdateUploadPath = String.Format(@"\\{0}\YellowDoor", xblobName);
            string releaseUploadPath = String.Format(@"\\{0}\Content\fffe07d1\", xblobName);

            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "p_environments_add";
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.Parameters.AddWithValue("@vc_environment", xblobName);
                    sqlCmd.Parameters.AddWithValue("@vc_websg_mix_url", mixUrl);
                    sqlCmd.Parameters.AddWithValue("@vc_websg_certificate", String.Empty);
                    sqlCmd.Parameters.AddWithValue("@vc_system_update_upload_path", sysUpdateUploadPath);
                    sqlCmd.Parameters.AddWithValue("@vc_system_release_upload_path", releaseUploadPath);
                    sqlCmd.Parameters.AddWithValue("@b_is_xblob", true);
                    sqlCmd.Parameters.AddWithValue("@i_min_upgrade_flash_version", 0x20076000);
                    sqlCmd.Parameters.AddWithValue("@vc_xbltools_path", @"C:\Esp\Webroot\Xbltools");
                    sqlCmd.Parameters.AddWithValue("@vc_websg_toolsmgmt_url", toolsMgmtUrl);
                    sqlCmd.ExecuteNonQuery();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\MixUtil.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Text;
using System.Web;
using System.Web.Configuration;

using xonline.mix.common;

using LiveHiveConfigV1 = xonline.mix.settingsmanagement.contracts.V1.LiveHiveConfig;
using GroupSummaryV1 = xonline.mix.betamanagement.contracts.V1.GroupSummary;
using GroupSummaryV2 = xonline.mix.betamanagement.contracts.V2.GroupSummary;
using LiveHiveConfigV2 = xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig;

namespace YellowDoor
{
    public class MixUtil
    {
        private static BasicHttpBinding _wsb = DefaultWSHttpBinding("BasicHttpBinding_Mix");

        protected static BasicHttpBinding Binding
        {
            get { return _wsb; }
        }

        protected static string SubjectName
        {
            get { return "Subject-Name"; }
        }

        protected static string ClientIPPort
        {
            get { return "Client-IP-Port"; }
        }

        protected static string RequestId
        {
            get { return "RequestId"; }
        }

        private static RNGCryptoServiceProvider _cryptoProvider = new RNGCryptoServiceProvider();

        protected static RNGCryptoServiceProvider CryptoProvider
        {
            get { return _cryptoProvider; }
        }

        /// <summary>
        /// Generates Random Request ID
        /// </summary>
        /// <returns></returns>
        protected static string GetRandomRequestId()
        {
            byte[] randomBytes = new byte[8];
            CryptoProvider.GetBytes(randomBytes);
            StringBuilder sb = new StringBuilder(randomBytes.Length * 2);
            foreach (byte b in randomBytes)
            {
                sb.AppendFormat("{0:x2}", b);
            }
            return sb.ToString();
        }

        protected static BasicHttpBinding DefaultWSHttpBinding(string wsbName)
        {
            BasicHttpBinding wsb = new BasicHttpBinding();
            wsb.Name = wsbName;
            wsb.CloseTimeout = TimeSpan.Parse(Environment.GetAppSetting("Binding.CloseTimeout", "00:01:00"));
            wsb.OpenTimeout = TimeSpan.Parse(Environment.GetAppSetting("Binding.OpenTimeout", "00:01:00"));
            wsb.ReceiveTimeout = TimeSpan.Parse(Environment.GetAppSetting("Binding.ReceiveTimeout", "00:01:00"));
            wsb.SendTimeout = TimeSpan.Parse(Environment.GetAppSetting("Binding.SendTimeout", "00:01:00"));
            wsb.BypassProxyOnLocal = false;
            wsb.HostNameComparisonMode =
                System.ServiceModel.HostNameComparisonMode.StrongWildcard;
            wsb.MaxBufferPoolSize = Environment.GetAppSetting("Binding.MaxBufferPoolSize", (long)524288);
            wsb.MaxReceivedMessageSize = Environment.GetAppSetting("Binding.MaxReceivedMessageSize", (long)786432);
            wsb.ReaderQuotas.MaxStringContentLength = (int)wsb.MaxReceivedMessageSize;
            wsb.MessageEncoding =
                System.ServiceModel.WSMessageEncoding.Text;
            wsb.TextEncoding = System.Text.Encoding.UTF8;
            wsb.UseDefaultWebProxy = true;
            wsb.AllowCookies = false;
            wsb.Security.Transport.ProxyCredentialType = HttpProxyCredentialType.None;
            return wsb;
        }

        internal static Group.GroupSummary GroupSummaryV1ToGroupSummary(GroupSummaryV1 sum)
        {
            Group.GroupSummary result = new Group.GroupSummary();
            result.Created = sum.Created;
            result.Creator = sum.Creator;
            result.FullFlashVersion = sum.FlashVersion;
            result.Id = sum.GroupGuid;
            result.Name = sum.Name;
            return result;
        }

        internal static Group.GroupSummary GroupSummaryV2ToGroupSummary(GroupSummaryV2 sum)
        {
            Group.GroupSummary result = new Group.GroupSummary();
            result.Created = sum.Created;
            result.Creator = sum.Creator;
            result.Id = sum.GroupGuid;
            result.Name = sum.Name;
            return result;
        }

        public static Binding GetBinding(bool usingCert)
        {
            BasicHttpBinding binding = Binding;
            if (usingCert)
            {
                // Have to set-up the right security access and certificate to talk to WebSG
                binding.Security.Transport.ClientCredentialType = HttpClientCredentialType.Certificate;
                binding.Security.Mode = BasicHttpSecurityMode.Transport;

                // client.ChannelFactory.Credentials.ClientCertificate.Certificate = env.WebSgCertificate;
                ServicePointManager.ServerCertificateValidationCallback =
                    new System.Net.Security.RemoteCertificateValidationCallback((sender, certificate, chain, sslPolicyErrors) =>
                        {
                            return true;
                        });
            }
            else
            {
                binding.Security.Mode = BasicHttpSecurityMode.None;
            }
            return binding;
        }

        public static TResult InvokeFunction<TClient, TChannel, TResult>(TClient client, X509Certificate2 clientCert, int retryCount, Func<TClient, TResult> func)
            where TChannel : class
            where TClient : ClientBase<TChannel>
        {
            TResult result;

            result = default(TResult);

            InvokeAction<TClient, TChannel>(client, clientCert, retryCount, c => result = func(c));

            return result;
        }

        public static void InvokeAction<TClient, TChannel>(TClient client, X509Certificate2 clientCert, int retryCount, Action<TClient> action) 
            where TChannel : class
            where TClient : ClientBase<TChannel>
        {
            for(;;--retryCount)
            {
                using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                {
                    HttpRequestMessageProperty msgProperty = new HttpRequestMessageProperty();

                    OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = msgProperty;

                    if (clientCert == null)
                    {
                        // If all 3 WebSG http headers don't exist, add the default ones
                        List<string> allKeys = new List<string>(msgProperty.Headers.AllKeys);
                        if (!(allKeys.Contains(SubjectName) || allKeys.Contains(ClientIPPort) || allKeys.Contains(RequestId)))
                        {
                            msgProperty.Headers.Add(SubjectName, "DebugPartner");
                            msgProperty.Headers.Add(ClientIPPort, "1.1.1.1:1000");
                            msgProperty.Headers.Add(RequestId, GetRandomRequestId());
                        }
                    }

                    try
                    {
                        action(client);
                        client.Close();
                        return;
                    }
                    catch (FaultException<MixClientFault> fe)
                    {
                        if (fe.Detail.IsRetryable && retryCount > 0)
                        {
                            continue;
                        }
                        throw fe;
                    }
                }
            }
        }

        public static string GetValueForLog(string[] vals)
        {
            StringBuilder bldr = new StringBuilder();

            foreach (string val in vals)
            {
                bldr.AppendFormat(" {0} |", val);
            }

            return bldr.ToString();
        }

        public static string GetValueForLog(LiveHiveConfigV1 config)
        {
            StringBuilder bldr = new StringBuilder();

            bldr.AppendFormat(" {0} |", config.BetaGroupId);
            bldr.AppendFormat(" {0} |", (config.Build.HasValue? config.Build.Value.ToString() : "null"));
            bldr.AppendFormat(" {0} |", config.PlatformType.ToString());
            bldr.AppendFormat(" {0} |", (config.Qfe.HasValue? config.Qfe.Value.ToString() : "null") );

            return bldr.ToString();

        }

        public static string GetValueForLog(LiveHiveConfigV2 config)
        {
            StringBuilder bldr = new StringBuilder();

            bldr.AppendFormat(" {0} |", config.BetaGroupId);
            bldr.AppendFormat(" {0} |", (config.Build.HasValue? config.Build.Value.ToString() : "null"));
            bldr.AppendFormat(" {0} |", config.PlatformType.ToString());
            bldr.AppendFormat(" {0} |", (config.Qfe.HasValue? config.Qfe.Value.ToString() : "null") );

            return bldr.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\NewFlash.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm8 {
        
        /// <summary>
        /// txtCabPath control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtCabPath;
        
        /// <summary>
        /// btnUpload control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnUpload;
        
        /// <summary>
        /// UpdateScriptManager control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager UpdateScriptManager;
        
        /// <summary>
        /// UpdatePanel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel;
        
        /// <summary>
        /// UpdateTimer control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.Timer UpdateTimer;
        
        /// <summary>
        /// lblError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblError;
        
        /// <summary>
        /// preProgress control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preProgress;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\NewGroup.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm10 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GroupsCreate);
            divError.Visible = false;
        }

        protected void btnCreate_Click(object sender, EventArgs e)
        {
            IEnvironment env = Session["environment"] as IEnvironment;
            try
            {
                Guid newGuid = env.CreateGroup(txtName.Text, Request.LogonUserIdentity.Name);
                Response.Redirect(String.Format(@"~\Group.aspx?groupId={0}", newGuid), true);
            }
            catch (Exception ex)
            {
                divError.Visible = true;
                preError.InnerText = "Failed to create new group.\n" + ex.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\MixSettingsManagement.EtxIngestion.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Net;
using System.Net.Mail;
using System.Net.Mime;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.Configuration;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Xsl;

using xonline.mix.settingsmanagement.contracts;
using xonline.mix.common;

using Packaging;

using LiveHiveSettingV1 = xonline.mix.settingsmanagement.contracts.V1.LiveHiveSetting;
using LiveHiveConfigV1 = xonline.mix.settingsmanagement.contracts.V1.LiveHiveConfig;
using LiveHiveSettingV2 = xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting;
using LiveHiveConfigV2 = xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig;

namespace YellowDoor
{
    public partial class SettingsManagementClientV2
    {
        #region Constants

        private const string ELEMENT_ROOT_INGESTION = "ingestion";
        private const string ELEMENT_BUILD_INGEST = "build";
        private const string ELEMENT_RELEASE_INGEST = "release";
        private const string ELEMENT_DIRECTORY_INGEST = "directory";
        private const string ELEMENT_FILE_INGEST_LIST = "files";
        private const string ELEMENT_FILE_INGEST = "file";
        private const string ELEMENT_ERROR_LIST = "errors";
        private const string ELEMENT_ERROR_ITEM = "item";
        private const string ELEMENT_ERROR_DESCRIPTION = "description";
        private const string ELEMENT_EXCEPTION = "exception";
        private const string ELEMENT_EXCEPTION_STACK = "stack";
        private const string ELEMENT_EXCEPTION_MESSAGE = "message";
        private const string ATTRIB_EXCEPTION_SITE = "site";
        private const string ATTRIB_ENTITY_EXISTS = "exists";

        private const string APP_SETTING_BUILD_LOCATION = "Ingestion.BuildLocation";
        private const string APP_SETTING_RELEASE_ETX_MANIFEST_PATTERN = "Ingestion.ReleaseManifestPattern";
        private const string APP_SETTING_BUILD_LOCATION_DEFAULT = @"\\xbox\usr\magnumci\etxmanifests\{0}";
        private const string APP_SETTING_RELEASE_ETX_MANIFEST_PATTERN_DEFAULT = @"^.*etxmanifests\\.*\.xml";

        #endregion

        #region Error Reporting

        private XElement GetOrCreateErrorsNode(XElement target)
        {
            XElement errors;

            errors = target.Element(ELEMENT_ERROR_LIST);

            if (null == errors)
            {
                errors = new XElement(ELEMENT_ERROR_LIST);

                target.Add(errors);
            }

            return errors;
        }

        private XElement AddIngestionError(XElement target, string message)
        {
            XElement errors;
            XElement item;

            errors = GetOrCreateErrorsNode(target);

            errors.Add(
                item = new XElement(ELEMENT_ERROR_ITEM,
                    new XElement(ELEMENT_ERROR_DESCRIPTION, message)));

            return item;
        }

        private XElement AddIngestionError(XElement target, string message, params object[] args)
        {
            return AddIngestionError(target, string.Format(message, args));
        }

        private void AddException(XElement target, Exception e)
        {
            XElement exception;

            target.Add(
                exception = new XElement(ELEMENT_EXCEPTION,
                    new XAttribute(ATTRIB_EXCEPTION_SITE, e.TargetSite.ToString()),
                    new XElement(ELEMENT_EXCEPTION_MESSAGE, e.Message),
                    new XElement(ELEMENT_EXCEPTION_STACK, e.StackTrace)));

            if (null != e.InnerException)
            {
                AddException(exception, e.InnerException);
            }
        }

        private XElement AddIngestionError(XElement target, Exception e, string message, params object[] args)
        {
            XElement item;

            item = AddIngestionError(target, message, args);
            AddException(item, e);

            return item;
        }

        #endregion

        /// <summary>
        /// Ingests all etx manifests associated with the specified release package.
        /// </summary>
        /// <param name="releaseFile">Target release package.</param>
        /// <returns>Returns an XElement containing details about the release package ingestion.</returns>
        private XElement IngestEtxManifestFromReleasePackage(string releaseFile)
        {
            Regex expression;
            Package release;
            XElement result;
            XElement files;
            PackageFileInfo[] etxFiles;

            Logger.Log(string.Format("Ingesting etx manifest package from {0}", releaseFile));

            result = new XElement(ELEMENT_RELEASE_INGEST, new XAttribute("path", releaseFile));

            expression = new Regex(
                Environment.GetAppSetting(APP_SETTING_RELEASE_ETX_MANIFEST_PATTERN, APP_SETTING_RELEASE_ETX_MANIFEST_PATTERN_DEFAULT), 
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            try
            {
                release = Package.Open(releaseFile, true);

                etxFiles = release.GetFileList().Where(p => expression.IsMatch(p.Name)).ToArray();
            }
            catch (Exception e)
            {
                AddIngestionError(result, e, "Operation terminating! Error encountered while trying to open the release package.");

                return result;
            }

            result.Add(files = new XElement(ELEMENT_FILE_INGEST_LIST));

            if (etxFiles.Length > 0)
            {
                foreach (PackageFileInfo etxFile in etxFiles)
                {
                    XElement file;

                    files.Add(file = new XElement(ELEMENT_FILE_INGEST, new XAttribute("path", etxFile.Name)));

                    try
                    {
                        using (MemoryStream ms = new MemoryStream((int)etxFile.OriginalSize))
                        {
                            release.UnpackFile(etxFile.Name, ms);

                            ms.Position = 0;

                            using (StreamReader reader = new StreamReader(ms))
                            {
                                IngestEtxManifestFromText(file, reader.ReadToEnd());
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        AddIngestionError(result, e, "Operation failed! Unexpected error encountered while unpacking the file.");
                    }
                }
            }
            else
            {
                AddIngestionError(result, "Operation failed! The specified release package contains no etx files matching the following expression: {0}.", expression);
            }

            return result;
        }

        /// <summary>
        /// Ingests all etx manifests associated with the specified flash build version.
        /// </summary>
        /// <param name="build">Target flash build version.</param>
        /// <returns>Returns an XElement containing details about the build ingestion.</returns>
        private XElement IngestEtxManifestFromBuildVersion(int build)
        {
            string flashBuildDirectory;
            XElement result;

            Logger.Log(string.Format("Ingestion etx manifest build from {0}", build));

            flashBuildDirectory = Environment.GetAppSetting(
                APP_SETTING_BUILD_LOCATION, 
                APP_SETTING_BUILD_LOCATION_DEFAULT);

            result = new XElement(ELEMENT_BUILD_INGEST, new XAttribute("flashVersion", build));

            try
            {
                result.Add(IngestEtxManifestFromDirectory(string.Format(flashBuildDirectory, build)));
            }
            catch (Exception e)
            {
                AddIngestionError(result, e, "Operation terminating! Unexpected error encountered.");
            }

            return result;
        }

        /// <summary>
        /// Ingests all etx manifests in the specified flashBuildDirectory.
        /// </summary>
        /// <param name="directoryPath">Target flashBuildDirectory to ingest files from.</param>
        /// <returns>Returns an XElement containing details about the flashBuildDirectory ingestion.</returns>
        private XElement IngestEtxManifestFromDirectory(string directoryPath)
        {
            XElement result;

            Logger.Log(string.Format("Ingestion etx manifest directory from {0}", directoryPath));

            result = new XElement(ELEMENT_DIRECTORY_INGEST, new XAttribute("path", directoryPath));

            try
            {
                bool exists;

                exists = Directory.Exists(directoryPath);

                result.Add(new XAttribute(ATTRIB_ENTITY_EXISTS, exists));

                if (!exists)
                {
                    AddIngestionError(result, "Operation aborted! The specified directory does not exist: {0}.", directoryPath);

                    return result;
                }
                else
                {
                    XElement files;
                    int count;

                    result.Add(files = new XElement(ELEMENT_FILE_INGEST_LIST));
                    count = 0;

                    foreach (string filePath in Directory.GetFiles(directoryPath, "*.xml", SearchOption.AllDirectories))
                    {
                        files.Add(IngestEtxManifestFromFile(filePath));
                        count++;
                    }

                    if (0 == count)
                    {
                        AddIngestionError(result, "Operation failed! The specified etx directory contains no etx .xml files: {0}.", directoryPath);
                    }
                }
            }
            catch (Exception e)
            {
                AddIngestionError(result, e, "Operation terminating! Unexpected error encountered.");
            }

            return result;
        }
       
        /// <summary>
        /// Ingests an etx manifest from the specified file.
        /// </summary>
        /// <param name="filePath">Target file to ingest etx manifest from.</param>
        /// <returns>Returns an XElement containing details about the file ingestion.</returns>
        private XElement IngestEtxManifestFromFile(string filePath)
        {
            XElement result;

            Logger.Log(string.Format("Ingestion etx manifest file from {0}.", filePath));

            result = new XElement(ELEMENT_FILE_INGEST, new XAttribute("path", filePath));

            try
            {
                bool exists;

                exists = File.Exists(filePath);
                
                result.Add(new XAttribute(ATTRIB_ENTITY_EXISTS, exists));

                if (!exists)
                {
                    AddIngestionError(result, "Operation aborted! The specified etx file does not exist: {0}.", filePath);

                    return result;
                }
                else
                {
                    string manifestXml;

                    manifestXml = File.ReadAllText(filePath);

                    IngestEtxManifestFromText(result, manifestXml);
                }
            }
            catch (Exception e)
            {
                AddIngestionError(result, e, "Operation terminating! Unexpected error encountered.");
            }

            return result;
        }

        /// <summary>
        /// Ingests an etx manifest from the specified manifest xml text.
        /// </summary>
        /// <param name="target">Target XElement to receive the results of the ingestion.</param>
        /// <param name="manifest">Input manifest xml text.</param>
        /// <returns>Returns the specified XElement parameter.</returns>
        private XElement IngestEtxManifestFromText(XElement target, string manifest)
        {
            string result;

            Logger.Log(string.Format("Calling IngestEtxManifest. XML follows:\n{0}.", manifest));

            result = MixUtil.InvokeFunction<MixSettingsManagementV2Client, MixSettingsManagementV2, string>(
                Client,
                Certificate,
                1,
                settingsClientV2 => settingsClientV2.IngestEtxManifest(manifest));

            try
            {
                target.Add(XElement.Parse(result));
            }
            catch (Exception e)
            {
                AddIngestionError(target, e, "Operation failed! Xml parse of the result text fail. Result:\n{0}", result);
            }

            return target;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\NewFlash.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm8 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.FlashReadWrite);
        }

        protected void UpdateTimer_Tick(object sender, EventArgs e)
        {
            List<IAsyncResult> resultList = Session["flashList"] as List<IAsyncResult>;
            if (resultList != null && resultList.Count > 0)
            {
                IAsyncResult result = resultList[resultList.Count - 1]; 
                PropFlashTask task = result.AsyncState as PropFlashTask;
                preProgress.InnerText = task.TaskProgress;
                if (result.IsCompleted)
                {
                    // Upload operation completed
                    UpdateTimer.Enabled = false;
                    btnUpload.Enabled = true;
                    txtCabPath.Enabled = true;
                    if (task.HasException)
                    {
                        lblError.Text = "Exception hit during propping. See below for details.";
                        lblError.Visible = true;
                    }
                }
            }
        }

        protected void btnUpload_Click(object sender, EventArgs e)
        {
            List<IAsyncResult> taskList = Session["flashList"] as List<IAsyncResult>;

            if (taskList == null)
            {
                taskList = new List<IAsyncResult>();
            }

            Environment env = Session["environment"] as Environment;
            PropFlashTask task = new PropFlashTask(txtCabPath.Text, env);
            taskList.Add(task.Run());
            Session["flashList"] = taskList;
            lblError.Visible = false;
            btnUpload.Enabled = false;
            txtCabPath.Enabled = false;
            UpdateTimer.Enabled = true;
            preProgress.InnerText = "Starting background task...";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\NewGroup.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm10 {
        
        /// <summary>
        /// txtName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtName;
        
        /// <summary>
        /// btnCreate control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnCreate;
        
        /// <summary>
        /// divError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl divError;
        
        /// <summary>
        /// preError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preError;

        protected global::System.Web.UI.WebControls.Panel pnlNewGroup;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\NewRelease.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm7 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.FlashReadWrite);

            IngestionUtil.Initialize();
        }

        protected void UpdateTimer_Tick(object sender, EventArgs e)
        {
            List<IAsyncResult> resultList = Session["releaseList"] as List<IAsyncResult>;
            if (resultList != null && resultList.Count > 0)
            {
                IAsyncResult result = resultList[resultList.Count -1];
                PropReleaseTask task = result.AsyncState as PropReleaseTask;
                preProgress.InnerText = task.TaskProgress;
                if (result.IsCompleted)
                {
                    // Upload operation completed
                    Session.Remove("releaseUploadResult");
                    UpdateTimer.Enabled = false;
                    if (task.HasException)
                    {
                        lblError.Text = "Exception hit during propping. See below for details.";
                        lblError.Visible = true;
                    }
                    else
                    {
                        if (!task.IsBaseFlashPropped)
                        {
                            lblError.Text = String.Format("Warning: Base flash ({0}) is not propped! Click 'New Flash' on the left to prop it now.", task.Release.BaseFlash);
                            lblError.Visible = true;
                        }
                    }
                }
            }
        }

        protected void btnUpload_Click(object sender, EventArgs e)
        {
            List<IAsyncResult> uploadingReleaseList = Session["releaseList"] as List<IAsyncResult>;

            if (uploadingReleaseList == null)
            {
                uploadingReleaseList = new List<IAsyncResult>();
            }

            IEnvironment env = Session["environment"] as IEnvironment;
            PropReleaseTask task = new PropReleaseTask(txtName.Text, txtReleasePath.Text, chkXITRelease.Checked, env);
            IAsyncResult result = task.Run();
            uploadingReleaseList.Add(result);
            Session["releaseList"] = uploadingReleaseList;
            lblError.Visible = false;
            btnUpload.Enabled = false;
            txtReleasePath.Enabled = false;
            txtName.Enabled = false;
            UpdateTimer.Enabled = true;
            preProgress.InnerText = "Starting background task...";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\PropFlashTask.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Configuration;

using YellowDoor.ToolsMgmtProxy;

namespace YellowDoor
{
    public class PropFlashTask : PropSelectiveTask
    {
        public PropFlashTask(string cabFilePath, IEnvironment environment)
            : base(cabFilePath, 0xFFFE07D1, environment)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\PropSelectiveTask.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Configuration;

using YellowDoor.ToolsMgmtProxy;

namespace YellowDoor
{
    public class PropSelectiveTask : WebTask
    {
        public string CabFilePath { get; protected set; }

        public uint TitleId { get; protected set; }

        public int Version { get; protected set; }

        protected IEnvironment TargetEnvironment { get; set; }

        public PropSelectiveTask(string cabFilePath, uint titleId, IEnvironment environment)
        {
            CabFilePath = cabFilePath;
            TitleId = titleId;
            TargetEnvironment = environment;
        }

        protected override void OnTaskRun()
        {
            TaskProgressBuffer.AppendLine("Starting PropSelectiveTask task...");

            TaskProgressBuffer.AppendFormat(".cab file: {0}\n", CabFilePath);
            TaskProgressBuffer.AppendFormat("Title ID: {0:X}\n", TitleId);
            TaskProgressBuffer.AppendFormat("Version: {0}", Version);

            TaskProgressBuffer.AppendLine("Copying file to share...\n");
            TaskProgressBuffer.AppendLine("Waiting on Signiant process...\n");

            PropStatus status;
            TargetEnvironment.PropSelective(CabFilePath, TitleId);

            TaskProgressBuffer.AppendLine("Files uploaded.");
            TaskProgressBuffer.AppendLine("Waiting for WCTools to finish executing job.");

            int refreshWait = Int32.Parse(WebConfigurationManager.AppSettings["PropFlashTask.WCToolsRefreshWaitMs"]);

            do
            {
                Thread.Sleep(refreshWait);
                status = TargetEnvironment.GetPropStatus();
                if (!status.Finished)
                {
                    TaskProgressBuffer.AppendLine(string.Format("Tools management service replied status {0} at {1} ", 
                        status.State,
                        DateTime.Now.ToLongTimeString()));
                }
            } while( !status.Finished );

            TaskProgressBuffer.AppendLine();

            if (status.JobFailure)
            {
                throw new Exception("Yellow Door had a problem executing the job. Please investigate whether files are uploading correctly.");
            }
            else
            {
                TaskProgressBuffer.AppendLine((status.ReturnCode == 0) ? " SUCCESS!" : "FAILURE!");
                TaskProgressBuffer.AppendFormat("LiveContent returned error code {0}. Output:\n{1}", status.ReturnCode, status.Output);

                if (status.ReturnCode != 0)
                {
                    // Need to throw an error so that WebTask flags the error on the webpage.
                    throw new Exception("Live content failed to prop. See above for details");
                }
            }
        }

        protected void DetermineVersion()
        {
            Version = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\NewRelease.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm7 {
        
        /// <summary>
        /// txtName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtName;
        
        /// <summary>
        /// txtReleasePath control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtReleasePath;
        
        /// <summary>
        /// chkXITRelease control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox chkXITRelease;
        
        /// <summary>
        /// btnUpload control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnUpload;
        
        /// <summary>
        /// UpdateScriptManager control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager UpdateScriptManager;
        
        /// <summary>
        /// UpdatePanel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel;
        
        /// <summary>
        /// UpdateTimer control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.Timer UpdateTimer;
        
        /// <summary>
        /// lblError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblError;
        
        /// <summary>
        /// preProgress control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preProgress;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\PropReleaseTask.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Configuration;
using Packaging;
using UpdateManager;

namespace YellowDoor
{
    public class PropReleaseTask : WebTask
    {
        public Release Release { get; set; }

        public bool IsBaseFlashPropped { get; set; }

        protected IEnvironment TargetEnvironment { get; set; }

        public PropReleaseTask(string releaseName, string releaseFilePath, bool isXITRelease, IEnvironment environment)
        {
            Release = new Release();
            Release.Id = Guid.NewGuid();
            Release.Name = releaseName;
            Release.ReleaseFilePath = releaseFilePath;
            Release.IsXIT = isXITRelease;
            Release.Environment = environment.Name;
            IsBaseFlashPropped = false;
            TargetEnvironment = environment;
        }

        protected class StringBuilderReporter : Reporter
        {
            protected enum LogLevel
            {
                Warning = 0,
                Normal = 1,
                Verbose = 2
            }

            protected LogLevel Level { get; set; }

            protected StringBuilder Buffer { get; set; }

            public StringBuilderReporter(StringBuilder sb)
            {
                Buffer = sb;
                Level = (LogLevel)Int32.Parse(WebConfigurationManager.AppSettings["StringBuilderReporter.Level"]);
            }

            public override void LogVerbose(string fmt, params object[] args)
            {
                if (Level >= LogLevel.Verbose)
                {
                    Buffer.AppendFormat("  " + fmt + "\n", args);
                }
            }

            public override void Log(string fmt, params object[] args)
            {
                if (Level >= LogLevel.Normal)
                {
                    Buffer.AppendFormat("  " + fmt + "\n", args);
                }
            }

            public override void LogWarning(string fmt, params object[] args)
            {
                if (Level >= LogLevel.Warning)
                {
                    Buffer.AppendFormat("Warning: " + fmt + "\n", args);
                }
            }
        }

        // --------------------------------------------------------------------------------------
        // XboxClientVersionBSTRToDword - converts a string like "2.0.7363.0" or 
        // "15.15.65535.255" to its corresponding uint representation.
        // --------------------------------------------------------------------------------------
        private uint XboxClientVersionStringtoUInt(string versionString)
        {
            int[] MASK = new int[] { 0xF, 0xF, 0xFFFF, 0xFF };
            int[] BITS_TO_SHIFT = new int[] { 28, 24, 8, 0 };

            string[] versionParts = versionString.Split('.');
            if (versionParts.Length != 4)
            {
                throw new ArgumentException("versionString must be four parts delimited by '.'.", "versionString");
            }

            int idx = 0;
            uint version = 0;
            for (; idx < versionParts.Length; ++idx)
            {
                uint val = uint.Parse(versionParts[idx]);
                version |= (uint)((val & MASK[idx]) << BITS_TO_SHIFT[idx]);
            }

            return version;
        }

        protected override void OnTaskRun()
        {
            if (Release.LoadFromDb(Release.Name, TargetEnvironment) != null)
            {
                throw new NotSupportedException(String.Format("Error: A release with the name of \"{0}\" already exists!", Release.Name));
            }

            TaskProgressBuffer.AppendLine("Propping the etx manifest...");
            
            try
            {
                IngestionUtil.ArchiveResult(
                    TargetEnvironment.IngestEtxManifest(Release.ReleaseFilePath),
                    TargetEnvironment.Name);
            }
            catch (Exception e)
            {
                TaskProgressBuffer.AppendLine(string.Format("Encountered error while propping etx manifest, continuing...\n{0}", e));
            }

            TaskProgressBuffer.AppendLine("Opening release package...");

            StringBuilderReporter reporter = new StringBuilderReporter(TaskProgressBuffer);
            using (ReleasePackage rPackage = ReleasePackage.Open(reporter, Release.ReleaseFilePath, true))
            {
                Release.IsGreenSigned = rPackage.IsGreenSigned;
                ReleaseSignType signType = Release.IsGreenSigned?ReleaseSignType.Green:ReleaseSignType.Red;
                Release.SystemManifestRevision = rPackage.OfflineRevision.ToString("X016");
                Release.SystemOnlineManifestRevision = rPackage.OnlineRevision.ToString("X016");
                Release.BaseFlash = (ushort)Convert.ToUInt32(rPackage.FlashVersion);
                List<ReleaseApp> offlineApps = new List<ReleaseApp>();
                List<ReleaseApp> onlineApps = new List<ReleaseApp>();
                foreach (UpdateEntry rApp in rPackage.Entries)
                {
                    ReleaseApp app = new ReleaseApp();
                    app.Name = rApp.Name;
                    app.PropPath = rPackage.GetUpdateEntryTargetPath(rApp, signType);
                    app.Version = String.Format(
                        "{0}.{1}.{2}.{3}",
                        rApp.Version.MajorVersion,
                        rApp.Version.MinorVersion,
                        rApp.Version.BuildNumber,
                        rApp.Version.QfeNumber);
                    app.TitleId = rApp.TitleId.HasValue ? rApp.TitleId.Value : 0;
                    app.AppVersion = XboxClientVersionStringtoUInt(app.Version);

                    switch (rApp.UpdateType)
                    {
                        case UpdateManifestType.Online:
                            onlineApps.Add(app);
                            break;
                        case UpdateManifestType.Offline:
                            offlineApps.Add(app);
                            break;
                    }
                }
                ReleaseApp offlineManifest = new ReleaseApp();
                offlineManifest.Name = ReleasePackage.NameSystemManifest;
                offlineManifest.PropPath = rPackage.OfflineManifestTargetPath;
                offlineManifest.Version = rPackage.OfflineRevision.ToString("X016");
                offlineApps.Add(offlineManifest);

                ReleaseApp onlineManifest = new ReleaseApp();
                onlineManifest.Name = ReleasePackage.NameSystemOnlineManifest;
                onlineManifest.PropPath = rPackage.OnlineManifestTargetPath;
                onlineManifest.Version = rPackage.OfflineRevision.ToString("X016");
                onlineApps.Add(onlineManifest);

                Release.SystemManifestApps = offlineApps.ToArray();
                Release.SystemOnlineManifestApps = onlineApps.ToArray();

                // Log what we've extracted from the .release path
                TaskProgressBuffer.AppendLine(string.Format("Details for system release: {0}\n", Release.ReleaseFilePath));
                TaskProgressBuffer.AppendLine(string.Format("  Friendly name: {0}\n", Release.Name));
                TaskProgressBuffer.AppendLine(string.Format("  SMRevision: {0}\n", Release.SystemManifestRevision));
                TaskProgressBuffer.AppendLine(string.Format("  SOMRevision: {0}\n", Release.SystemOnlineManifestRevision));
                TaskProgressBuffer.AppendLine(string.Format("  Flash: {0}\n", Release.BaseFlash));
                if (Release.IsXIT)
                {
                    TaskProgressBuffer.AppendLine("  Release is XIT privileged.");
                }
                if (Release.IsGreenSigned)
                {
                    TaskProgressBuffer.AppendLine("  Release is green signed.");
                }

                TaskProgressBuffer.AppendLine("Starting propping process...");
                TaskProgressBuffer.AppendLine(string.Format("  Target destination: {0}\n", TargetEnvironment.SystemReleaseUploadPath));

                
                IReleaseInstallerWorker worker;
                if (String.IsNullOrEmpty(TargetEnvironment.SystemReleaseDownloadUrl))
                {
                    worker = new FileShareInstaller();
                }
                else
                {
                    worker = new FileShareInstaller();
                    //worker = new ContentUrlInstaller(TargetEnvironment.SystemReleaseUploadPath, TargetEnvironment.SystemReleaseDownloadUrl, reporter);
                }
                ReleaseInstaller.Install(reporter, worker, rPackage, signType, TargetEnvironment.SystemReleaseUploadPath, false);
                // TODO: When TargetEnvironment.IsXblob == false, we need to implement logic to verify signiant is done copying
            }

            // Check if the base flash is already propped
            IsBaseFlashPropped = TargetEnvironment.IsFlashPropped(Release.FullBaseFlash);

            // When done, insert to YellowDoor's database
            Release.IsFlashPropped = IsBaseFlashPropped;
            Release.SaveToDb();
        }

        class FileShareInstaller : IReleaseInstallerWorker
        {
            public Stream CreateFile(string filename)
            {
                if (!Directory.Exists(Path.GetDirectoryName(filename)))
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(filename));
                }

                return File.Create(filename);
            }

            public Stream TryOpenFile(string filename)
            {
                if (File.Exists(filename))
                {
                    return File.Open(filename, FileMode.Open);
                }
                else
                {
                    return null;
                }
            }
        }

        class ContentUrlInstaller : IReleaseInstallerWorker
        {
            public Reporter Reporter { get; private set; }

            public string UploadPath { get; private set; }

            public string DownloadUrl { get; private set; }

            public ContentUrlInstaller(string uploadPath, string downloadUrl, Reporter reporter)
            {
                UploadPath = uploadPath;
                DownloadUrl = downloadUrl;
                Reporter = reporter;
            }

            public Stream CreateFile(string filename)
            {
                if (!Directory.Exists(Path.GetDirectoryName(filename)))
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(filename));
                }

                return File.Create(filename);
            }

            public Stream TryOpenFile(string filename)
            {
                string url = filename.Replace(UploadPath, DownloadUrl).Replace('\\', '/');
                try
                {
                    HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
                    HttpWebResponse response = request.GetResponse() as HttpWebResponse;
                    Stream stream = response.GetResponseStream();
                    stream.ReadTimeout = 10 * 60 * 1000; // 10 minutes
                    return stream;
                }
                catch (Exception e)
                {
                    Reporter.LogWarning("Exception {0} caught when opening Url: {1}\n\tMessage: {2}", e.GetType(), url, e.Message);
                    return null;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Release.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.Configuration;

namespace YellowDoor
{
    public partial class WebForm3 : YellowDoorPage
    {
        protected Release Release { get; set; }

        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GeneralReadOnly);

            if (!Roles.Current.HasRole(Roles.FlashReadWrite))
            {
                DetailsView1.Fields[9].Visible = false; // The comand row.
                pnlAssignToGroup.Visible = false; // the assign to group panel
            }

            IEnvironment env = Session["environment"] as IEnvironment;
            Release = Release.LoadFromDb(new Guid(Request.QueryString["releaseId"]), env);
            if (!Release.IsFlashPropped && env.IsFlashPropped(Release.FullBaseFlash))
            {
                Release.IsFlashPropped = true;
                Release.SaveToDb();
            }
            ReleaseAppsGridView.Columns[0].Visible = false;

            dbGroups.SelectParameters["showGlobal"].DefaultValue =
                (Environment.IsGlobalEnabled && 
                Roles.Current.HasRole(Roles.GroupGlobalReadWrite)).ToString();
        }

        protected void btnAssignToGroups_Click(object sender, EventArgs e)
        {
            List<string> groupIds = new List<string>();
            foreach (ListItem item in chkListGroups.Items)
            {
                if (item.Selected)
                {
                    groupIds.Add(item.Value);
                }
            }
            if (groupIds.Count > 0)
            {
                Release release = Release.LoadFromDb(new Guid(Request.QueryString["releaseId"]), Session["environment"] as IEnvironment);
                Session["assignReleaseRelease"] = release;
                Session["assignReleaseGroups"] = groupIds;
                Session["originUrl"] = Request.RawUrl;
                Response.Redirect(@"~\ReleaseDiff.aspx");
            }
        }

        protected void btnValidate_Click(object sender, EventArgs e)
        {
            ReleaseAppsGridView.Columns[0].Visible = true;
            dbReleaseApps.SelectParameters["validateApps"].DefaultValue = "true";
        }

        protected void btnFilterClear_Click(object sender, EventArgs e)
        {
            txtFilterGroups.Text = "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Release.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm3 {
        
        /// <summary>
        /// ScriptManager1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager ScriptManager1;
        
        /// <summary>
        /// DetailsView1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DetailsView DetailsView1;
        
        /// <summary>
        /// dbRelease control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.SqlDataSource dbRelease;
        
        /// <summary>
        /// UpdatePanel2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel2;
        
        /// <summary>
        /// btnValidate control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton btnValidate;
        
        /// <summary>
        /// ReleaseAppsGridView control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.GridView ReleaseAppsGridView;
        
        /// <summary>
        /// dbReleaseApps control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ObjectDataSource dbReleaseApps;
        
        /// <summary>
        /// pnlAssignToGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel pnlAssignToGroup;
        
        /// <summary>
        /// UpdatePanel1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel1;
        
        /// <summary>
        /// chkShowAssigned control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox chkShowAssigned;
        
        /// <summary>
        /// txtFilterGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtFilterGroups;
        
        /// <summary>
        /// btnFilterGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnFilterGroups;
        
        /// <summary>
        /// btnFilterClear control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnFilterClear;
        
        /// <summary>
        /// chkListGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBoxList chkListGroups;
        
        /// <summary>
        /// btnAssignToGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAssignToGroups;
        
        /// <summary>
        /// dbGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ObjectDataSource dbGroups;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ObjectDataSources.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Web;
using System.Web.Configuration;

namespace YellowDoor
{
    public static class ObjectDataSources
    {

        private class GroupSummaryComparer : IComparer<Group.GroupSummary>
        {
            #region IComparer<GroupSummary> Members

            public int Compare(Group.GroupSummary x, Group.GroupSummary y)
            {
                // Check for the global group id first to make it always show up at the top, then compare by name
                if (x.Id == y.Id)
                    return 0;
                else if (x.Id == Guid.Empty)
                    return -1;
                else if (y.Id == Guid.Empty)
                    return 1;
                else
                    return x.Name.CompareTo(y.Name);
            }

            #endregion
        }

        public static GroupDetails GetGroupDetails(object environment, string groupId)
        {
            IEnvironment env = environment as IEnvironment;
            return new GroupDetails(env.GetGroupInfo(new Guid(groupId)));
        }

        public static Group.GroupSummary[] GetGroupSummariesForTitleDetails(object environment, string filter, bool showGlobal)
        {
            List<Group.GroupSummary> results = new List<Group.GroupSummary>();
            IEnvironment env = environment as IEnvironment;
            Group.GroupSummary[] summaries = env.GetAllGroupSummaries();
            bool add;

            if (showGlobal)
            {
                // Add the global group first
                Group.GroupSummary global = env.GetGroupInfo(Group.GlobalGroupId).Summary;
                results.Add(env.GetGroupInfo(Group.GlobalGroupId).Summary);
            }

            foreach (Group.GroupSummary summary in summaries)
            {
                add = true;

                if (!string.IsNullOrEmpty(filter) && !summary.Name.ToLower().Contains(filter.ToLower()))
                {
                    add = false;
                }

                if (add)
                {
                    results.Add(summary);
                }
            }

            Group.GroupSummary[] finalSet = results.ToArray();

            Array.Sort<Group.GroupSummary>(finalSet, new GroupSummaryComparer());

            return finalSet;
        }

        public static Group.GroupSummary[] GetAllGroupSummaries(
            object environment, 
            string filterName, 
            bool showAssigned, 
            string releaseId, 
            bool printFlashVersion, 
            bool getReleaseInfo,
            bool showGlobal,
            bool makeHyperlink)
        {
            IEnvironment env = environment as IEnvironment;
            List<Group.GroupSummary> summaryList = new List<Group.GroupSummary>();

            if (showGlobal)
            {
                // Add the global group first
                Group.GroupSummary global = env.GetGroupInfo(Group.GlobalGroupId).Summary;
                summaryList.Add(env.GetGroupInfo(Group.GlobalGroupId).Summary);
            }

            summaryList.AddRange(env.GetAllGroupSummaries());

            Group.GroupSummary[] summaries = summaryList.ToArray();

            if (!String.IsNullOrEmpty(filterName))
            {
                List<Group.GroupSummary> filtered = new List<Group.GroupSummary>();
                foreach (Group.GroupSummary s in summaries)
                {
                    if (s.Name.ToLower().Contains(filterName.ToLower()))
                    {

                        filtered.Add(s);
                    }
                }
                summaries = filtered.ToArray();
            }

            if (showAssigned)
            {
                Release release = Release.LoadFromDb(new Guid(releaseId), env);
                List<Group.GroupSummary> filtered = new List<Group.GroupSummary>();
                foreach (Group.GroupSummary s in summaries)
                {
                    if (s.FlashVersion == release.BaseFlash)
                    {
                        Group.ReleaseInfo r = env.GetGroupInfo(s.Id).GetCurrentReleaseInfo();
                        if (r != null && 
                            r.SMRevision == release.SystemManifestRevision &&
                            r.SOMRevision == release.SystemOnlineManifestRevision)
                        {
                            filtered.Add(s);
                        }
                    }
                }
                summaries = filtered.ToArray();
            }

            if (getReleaseInfo)
            {
                for (int i = 0; i < summaries.Length; ++i)
                {
                    Group.ReleaseInfo r = env.GetGroupInfo(summaries[i].Id).GetCurrentReleaseInfo();
                    if (r != null)
                    {
                        string[] names = Release.LoadNamesFromDb(r.SMRevision, r.SOMRevision, r.FlashVersion, env);
                        if (names != null && names.Length > 0)
                        {
                            Release rel = Release.LoadFromDb(names[0], env);
                            if (rel != null)
                            {
                                summaries[i].ReleaseId = rel.Id;
                                summaries[i].ReleaseName = rel.Name;
                            }
                        }
                    }
                }
            }

            if (printFlashVersion)
            {
                foreach (Group.GroupSummary s in summaries)
                {
                    s.Name = (s.FullFlashVersion == 0 ? String.Format("{0} (No flash assigned) ", s.Name) :
                        String.Format("{0} ({1})", s.Name, s.FlashVersion));
                }
            }

            if (makeHyperlink)
            {
                foreach (Group.GroupSummary s in summaries)
                {
                    s.Name = String.Format("<a href='Group.aspx?groupId={0}'>{1}</a>", s.Id, s.Name);
                }
            }

            Array.Sort<Group.GroupSummary>(summaries, new GroupSummaryComparer());

            return summaries;
        }

        public static ReleaseApp[] GetReleaseApps(object environment, string releaseId, bool validateApps)
        {
            List<ReleaseApp> apps = new List<ReleaseApp>();

            IEnvironment env = environment as IEnvironment;
            string contentUrl = env.SystemReleaseDownloadUrl;
            Release r = Release.LoadFromDb(new Guid(releaseId), env);
            apps.AddRange(r.SystemManifestApps);
            apps.AddRange(r.SystemOnlineManifestApps);

            for (int i = 0; i < apps.Count; ++i)
            {
                ReleaseApp app = apps[i];
                app.Validated = false;
                if (!String.IsNullOrEmpty(contentUrl))
                {
                    app.ContentUrl = String.Format(@"{0}/{1}", contentUrl, app.PropPath).Replace('\\', '/').Trim();
                    if (validateApps)
                    {
                        try
                        {
                            HttpWebRequest request = WebRequest.Create(app.ContentUrl) as HttpWebRequest;
                            HttpWebResponse response = request.GetResponse() as HttpWebResponse;
                            using (Stream s = response.GetResponseStream())
                            {
                            }
                            app.Validated = true;
                        }
                        catch (Exception)
                        {
                        }
                    }
                }
                else
                {
                    app.ContentUrl = null;
                }
            }

            return apps.ToArray();
        }

        public static Release[] GetAllReleasesForGroup(object environment, string groupId, string filterName, bool showLower, bool makeHyperlink)
        {
            List<Release> releases = new List<Release>();
            IEnvironment env = environment as IEnvironment;
            Group group = env.GetGroupInfo(new Guid(groupId));
            Group.ReleaseInfo relInfo = group.GetCurrentReleaseInfo();
            bool doFilter = false;
            if (!String.IsNullOrEmpty(filterName))
            {
                doFilter = true;
                filterName = filterName.ToLower();
            }
            foreach (Release release in Release.LoadAllFromDb(env))
            {
                if (relInfo != null)
                {
                    if (relInfo.FlashVersion == release.BaseFlash &&
                        relInfo.SMRevision == release.SystemManifestRevision &&
                        relInfo.SOMRevision == release.SystemOnlineManifestRevision)
                    {
                        continue;
                    }

                    if (relInfo.FlashVersion > release.BaseFlash && !showLower)
                    {
                        continue;
                    }
                }

                if (doFilter && release.Name.ToLower().IndexOf(filterName) < 0)
                {
                    continue;
                }

                releases.Add(release);
            }

            if (makeHyperlink)
            {
                foreach (Release r in releases)
                {
                    r.Name = String.Format("<a href='Release.aspx?releaseId={0}'>{1}</a>", r.Id, r.Name);
                }
            }

            return releases.ToArray();
        }

        public static FileDiffListEntry[] GetReleaseFileDiff(string sm_version, string som_version, Guid releaseToDiff)
        {
            List<FileDiffListEntry> returnList = new List<FileDiffListEntry>();

            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                FileDiffListEntry entry = null;

                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "dbo.p_Compare_Release_Files";
                    sqlCmd.Parameters.AddWithValue("@vc_sm_version", sm_version);
                    sqlCmd.Parameters.AddWithValue("@vc_som_version", som_version);
                    sqlCmd.Parameters.AddWithValue("@uid_release2", releaseToDiff);
                    SqlDataReader reader = sqlCmd.ExecuteReader();

                    while (reader.Read())
                    {
                        entry = FileDiffListEntry.FromDataReader(reader);

                        if (string.Compare(entry.NewVersion, entry.OldVersion, true) != 0)
                        {
                            returnList.Add(FileDiffListEntry.FromDataReader(reader));
                        }
                    }
                }
            }
            return returnList.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Release.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Web;
using System.Web.Configuration;

namespace YellowDoor
{
    public class ReleaseApp
    {
        public string Type { get; set; }

        public string Version { get; set; }

        public string Name { get; set; }

        public string PropPath { get; set; }

        public string ContentUrl { get; set; }

        public bool Validated { get; set; } // Non-persisted to DB

        public uint? TitleId { get; set; }

        public uint? AppVersion { get; set; }
    }

    public class Release
    {
        public Guid Id { get; set; }

        public string ReleaseFilePath { get; set; }

        public string Name { get; set; }

        public bool IsXIT { get; set; }

        public bool IsGreenSigned { get; set; }

        public bool IsArchived { get; set; }

        public bool IsFlashPropped { get; set; }

        public string SystemManifestRevision { get; set; }

        public string SystemOnlineManifestRevision { get; set; }

        public ushort BaseFlash { get; set; }

        public uint FullBaseFlash { get { return (((uint)0x20 << 24) | ((uint)BaseFlash << 8)); } }

        public ReleaseApp[] SystemManifestApps { get; set; }

        public ReleaseApp[] SystemOnlineManifestApps { get; set; }

        public string Environment { get; set; }

        public Release()
        {
            Id = new Guid("00000000-0000-0000-0000-000000000000");
            ReleaseFilePath = null;
            Name = null;
            IsXIT = false;
            IsGreenSigned = false;
            IsArchived = false;
            IsFlashPropped = false;
            BaseFlash = 0;
            SystemManifestRevision = "0";
            SystemOnlineManifestRevision = "0";
            SystemManifestApps = new ReleaseApp[0];
            SystemOnlineManifestApps = new ReleaseApp[0];
        }

        public void SaveToDb()
        {
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "dbo.p_releases_insert_or_update";
                    sqlCmd.Parameters.AddWithValue("@uid_release_id", Id);
                    sqlCmd.Parameters.AddWithValue("@vc_name", Name);
                    sqlCmd.Parameters.AddWithValue("@vc_sm_revision", SystemManifestRevision);
                    sqlCmd.Parameters.AddWithValue("@vc_som_revision", SystemOnlineManifestRevision);
                    sqlCmd.Parameters.AddWithValue("@i_base_flash", (int)BaseFlash);
                    sqlCmd.Parameters.AddWithValue("@b_xit_privileged", IsXIT);
                    sqlCmd.Parameters.AddWithValue("@b_is_green_signed", IsGreenSigned);
                    sqlCmd.Parameters.AddWithValue("@b_archived", IsArchived);
                    sqlCmd.Parameters.AddWithValue("@vc_filepath", ReleaseFilePath);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Environment);
                    sqlCmd.Parameters.AddWithValue("@b_is_flash_propped", IsFlashPropped);
                    sqlCmd.Parameters.Add("@RETVAL", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                    sqlCmd.ExecuteNonQuery();
                    if ((int)sqlCmd.Parameters["@RETVAL"].Value == 0) // Is not a new release
                    {
                        return;
                    }
                }
                foreach (ReleaseApp app in SystemManifestApps)
                {
                    using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                    {
                        sqlCmd.CommandType = CommandType.StoredProcedure;
                        sqlCmd.CommandText = "dbo.p_release_apps_insert";
                        sqlCmd.Parameters.AddWithValue("@uid_release_id", Id);
                        sqlCmd.Parameters.AddWithValue("@vc_type", "offline");
                        sqlCmd.Parameters.AddWithValue("@vc_name", app.Name);
                        sqlCmd.Parameters.AddWithValue("@vc_version", app.Version);
                        sqlCmd.Parameters.AddWithValue("@vc_prop_path", app.PropPath);
                        sqlCmd.Parameters.AddWithValue("@i_title_id", app.TitleId.HasValue ? (int)app.TitleId.Value : 0);
                        sqlCmd.Parameters.AddWithValue("@i_app_version", app.AppVersion.HasValue ? (int)app.AppVersion.Value : 0);
                        sqlCmd.ExecuteNonQuery();
                    }
                }
                foreach (ReleaseApp app in SystemOnlineManifestApps)
                {
                    using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                    {
                        sqlCmd.CommandType = CommandType.StoredProcedure;
                        sqlCmd.CommandText = "dbo.p_release_apps_insert";
                        sqlCmd.Parameters.AddWithValue("@uid_release_id", Id);
                        sqlCmd.Parameters.AddWithValue("@vc_type", "online");
                        sqlCmd.Parameters.AddWithValue("@vc_name", app.Name);
                        sqlCmd.Parameters.AddWithValue("@vc_version", app.Version);
                        sqlCmd.Parameters.AddWithValue("@vc_prop_path", app.PropPath);
                        sqlCmd.Parameters.AddWithValue("@i_title_id", app.TitleId.HasValue ? (int)app.TitleId.Value : 0);
                        sqlCmd.Parameters.AddWithValue("@i_app_version", app.AppVersion.HasValue ? (int)app.AppVersion.Value : 0);
                        sqlCmd.ExecuteNonQuery();
                    }
                }
            }
        }

        protected static Release LoadFromReader(SqlDataReader reader)
        {
            if (reader.Read())
            {
                Release release = new Release();
                release.Id = (Guid)reader["uid_release_id"];
                release.ReleaseFilePath = reader["vc_filepath"] as string;
                release.Name = reader["vc_name"] as string;
                release.Environment = reader["vc_environment"] as string;
                release.IsXIT = (bool)reader["b_xit_privileged"];
                release.IsGreenSigned = (bool)reader["b_is_green_signed"];
                release.IsArchived = (bool)reader["b_archived"];
                release.IsFlashPropped = (bool)reader["b_is_flash_propped"];
                release.BaseFlash = (ushort)(int)reader["i_base_flash"];
                release.SystemManifestRevision = reader["vc_sm_revision"] as string;
                release.SystemOnlineManifestRevision = reader["vc_som_revision"] as string;
                release.SystemManifestApps = new ReleaseApp[0];
                release.SystemOnlineManifestApps = new ReleaseApp[0];
                if (reader.NextResult())
                {
                    List<ReleaseApp> apps = new List<ReleaseApp>();
                    while (reader.Read())
                    {
                        ReleaseApp app = new ReleaseApp();
                        app.Type = reader["vc_type"] as string;
                        app.Name = reader["vc_name"] as string;
                        app.Version = reader["vc_version"] as string;
                        app.PropPath = reader["vc_prop_path"] as string;

                        if (reader["i_app_version"] != DBNull.Value && (int)reader["i_app_version"] != 0)
                        {
                            app.AppVersion = (uint)(int)reader["i_app_version"];
                        }

                        if (reader["i_title_id"] != DBNull.Value && (int)reader["i_title_id"] != 0)
                        {
                            app.TitleId = (uint)(int)reader["i_title_id"];
                        }

                        apps.Add(app);
                    }
                    release.SystemManifestApps = apps.ToArray();
                }
                if (reader.NextResult())
                {
                    List<ReleaseApp> apps = new List<ReleaseApp>();
                    while (reader.Read())
                    {
                        ReleaseApp app = new ReleaseApp();
                        app.Type = reader["vc_type"] as string;
                        app.Name = reader["vc_name"] as string;
                        app.Version = reader["vc_version"] as string;
                        app.PropPath = reader["vc_prop_path"] as string;

                        if (reader["i_app_version"] != DBNull.Value && (int)reader["i_app_version"] != 0)
                        {
                            app.AppVersion = (uint)(int)reader["i_app_version"];
                        }

                        if (reader["i_title_id"] != DBNull.Value)
                        {
                            app.TitleId = (uint)(int)reader["i_title_id"];
                        }

                        apps.Add(app);
                    }
                    release.SystemOnlineManifestApps = apps.ToArray();
                }
                return release;
            }
            else
            {
                return null;
            }
        }

        public static Release LoadFromDb(string name, IEnvironment environment)
        {
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "dbo.p_releases_get_details";
                    sqlCmd.Parameters.AddWithValue("@vc_name", name);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", environment.Name);
                    return LoadFromReader(sqlCmd.ExecuteReader());
                }
            }
        }

        public static Release LoadFromDb(Guid id, IEnvironment environment)
        {
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "dbo.p_releases_get_details";
                    sqlCmd.Parameters.AddWithValue("@uid_release_id", id);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", environment.Name);
                    return LoadFromReader(sqlCmd.ExecuteReader());
                }
            }
        }

        public static Release[] LoadAllFromDb(IEnvironment environment)
        {
            List<Release> releases = new List<Release>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "dbo.p_releases_get_all";
                    sqlCmd.Parameters.AddWithValue("@b_archived", false);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", environment.Name);
                    SqlDataReader reader = sqlCmd.ExecuteReader();
                    while (reader.Read())
                    {
                        Release release = new Release();
                        release.Id = (Guid)reader["uid_release_id"];
                        release.ReleaseFilePath = reader["vc_filepath"] as string;
                        release.Name = reader["vc_name"] as string;
                        release.Environment = reader["vc_environment"] as string;
                        release.IsXIT = (bool)reader["b_xit_privileged"];
                        release.IsGreenSigned = (bool)reader["b_is_green_signed"];
                        release.IsArchived = (bool)reader["b_archived"];
                        release.IsFlashPropped = (bool)reader["b_is_flash_propped"];
                        release.BaseFlash = (ushort)(int)reader["i_base_flash"];
                        release.SystemManifestRevision = reader["vc_sm_revision"] as string;
                        release.SystemOnlineManifestRevision = reader["vc_som_revision"] as string;
                        release.SystemManifestApps = new ReleaseApp[0];
                        release.SystemOnlineManifestApps = new ReleaseApp[0];
                        releases.Add(release);
                    }
                }
            }
            return releases.ToArray();
        }

        public static string[] LoadNamesFromDb(string smRevision, string somRevision, int baseFlash, IEnvironment environment)
        {
            List<string> results = new List<string>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "dbo.p_releases_get_names_by_metadata";
                    sqlCmd.Parameters.AddWithValue("@vc_sm_revision", smRevision);
                    sqlCmd.Parameters.AddWithValue("@vc_som_revision", somRevision);
                    sqlCmd.Parameters.AddWithValue("@i_base_flash", (int)baseFlash);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", environment.Name);
                    SqlDataReader reader = sqlCmd.ExecuteReader();
                    while (reader.Read())
                    {
                        results.Add(reader["vc_name"] as string);
                    }
                }
            }
            return results.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ReleaseDiff.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm4 {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl lblTitle;
        
        /// <summary>
        /// tblDiff control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Table tblDiff;
        
        /// <summary>
        /// hdrGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableHeaderCell hdrGroup;
        
        /// <summary>
        /// hdrRelease control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableHeaderCell hdrRelease;
        
        /// <summary>
        /// celGroupSMRevision control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableCell celGroupSMRevision;
        
        /// <summary>
        /// celReleaseSMRevision control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableCell celReleaseSMRevision;
        
        /// <summary>
        /// celGroupSOMRevision control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableCell celGroupSOMRevision;
        
        /// <summary>
        /// celReleaseSOMRevision control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableCell celReleaseSOMRevision;
        
        /// <summary>
        /// celGroupBaseFlash control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableCell celGroupBaseFlash;
        
        /// <summary>
        /// celReleaseBaseFlash control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TableCell celReleaseBaseFlash;
        
        /// <summary>
        /// diffRepeater control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Repeater diffRepeater;
        
        /// <summary>
        /// lhsettings control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::YellowDoor.LiveHiveSettings lhsettings;
        
        /// <summary>
        /// lhsettingsTwo control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::YellowDoor.LiveHiveSettings lhsettingsTwo;
        
        /// <summary>
        /// ScriptManager1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.ScriptManager ScriptManager1;
        
        /// <summary>
        /// UpdatePanel1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.UpdatePanel UpdatePanel1;
        
        /// <summary>
        /// btnAssign control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAssign;
        
        /// <summary>
        /// btnCancel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnCancel;
        
        /// <summary>
        /// btnSkip control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnSkip;
        
        /// <summary>
        /// lblError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblError;
        
        /// <summary>
        /// preError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl preError;

        protected global::System.Web.UI.WebControls.Literal litStatus;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ReleaseDiff.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm4 : YellowDoorPage
    {

        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GeneralReadOnly);

            if (!Roles.Current.HasRole(Roles.SettingsReadWrite))
            {
                this.lhsettingsTwo.Visible = false;
            }

            lblError.Visible = false;
            preError.Visible = false;
            btnAssign.Enabled = true;

            if (!Page.IsPostBack)
            {
                this.btnAssign.OnClientClick = "this.disabled = true; this.value = 'Submitting...';";

                List<string> groupIds = Session["assignReleaseGroups"] as List<string>;
                if (groupIds.Count == 0)
                {
                    Response.Redirect(Session["originUrl"] as string);
                }

                btnSkip.Visible = (groupIds.Count > 1);

                Group group = Environment.GetGroupInfo(new Guid(groupIds[0]));
                Group.ReleaseInfo relInfo = group.GetCurrentReleaseInfo();

                lblTitle.InnerText = String.Format("Assigning release {0} to group {1}", Release.Name, group.Summary.Name); ;

                hdrGroup.Text = String.Format(hdrGroup.Text, group.Summary.Name);
                hdrRelease.Text = String.Format(hdrRelease.Text, group.Summary.Name);

                celGroupSMRevision.Text = (relInfo != null) ? relInfo.SMRevision : "--";
                celReleaseSMRevision.Text = Release.SystemManifestRevision;

                celGroupSOMRevision.Text = (relInfo != null) ? relInfo.SOMRevision : "--";
                celReleaseSOMRevision.Text = Release.SystemOnlineManifestRevision;

                celGroupBaseFlash.Text = (relInfo != null) ? relInfo.FlashVersion.ToString() : "--";

                celReleaseBaseFlash.Text = Release.BaseFlash.ToString();

                string smVersionForDiff, somVersionForDiff;
                smVersionForDiff = (relInfo == null) ? string.Empty : relInfo.SMRevision;
                somVersionForDiff = (relInfo == null) ? string.Empty : relInfo.SOMRevision;
                FileDiffListEntry[] entries = ObjectDataSources.GetReleaseFileDiff(smVersionForDiff,
                                                     somVersionForDiff,
                                                     Release.Id);

                if (entries.Length > 0)
                {
                    diffRepeater.DataSource = entries;
                    diffRepeater.DataBind();
                }
                else
                {
                    //litStatus = new Literal();
                    litStatus.Text = "<tr><td colspan=\"3\">All files are identical in the two releases</td></tr>";
                }
            }
        }

        protected void btnAssign_Click(object sender, EventArgs e)
        {
            List<string> groupIds = Session["assignReleaseGroups"] as List<string>;
            Guid groupId = new Guid(groupIds[0]);

            bool error = false;

            try
            {
                Environment.AssignFlashReleaseToGroup(Release, groupId);
                // TODO: Need a YD-global constant for Flash titleId instead of hard-coding FFFE07D1
                ReleaseHistory.CreateEntry(Release.Id,
                    groupId,
                    (uint)0xFFFE07D1,
                    Environment.Name,
                    User.Identity.Name); 
            }
            catch (Exception ex)
            {
                error = true;
                lblError.Text = "The operation to assign a release to the beta-group failed. See below for details.";
                lblError.Visible = true;
                preError.InnerText = ex.ToString();
                preError.Visible = true;
                btnAssign.Enabled = false;
            }

            try
            {
                lhsettings.WriteSubmittedSettings(Release.BaseFlash);
                groupIds.RemoveAt(0);
            }
            catch (Exception ex)
            {
                error = true;
                lblError.Text = "The operation to assign live hive settings failed. See below for details.";
                lblError.Visible = true;
                preError.InnerText = ex.ToString();
                preError.Visible = true;
                btnAssign.Enabled = false;
            }

            if (!error)
            {
                if (groupIds.Count == 0)
                {
                    Session.Remove("assignReleaseGroups");
                    Response.Redirect(Session["originUrl"] as string);
                }
                else
                {
                    Session["assignReleaseGroups"] = groupIds;
                    Response.Redirect(Request.RawUrl);
                }
            }
        }

        protected void btnSkip_Click(object sender, EventArgs e)
        {
            List<string> groupIds = Session["assignReleaseGroups"] as List<string>;
            groupIds.RemoveAt(0);
            Session["assignReleaseGroups"] = groupIds;
            Response.Redirect(Request.RawUrl);
        }

        protected void btnCancel_Click(object sender, EventArgs e)
        {
            Response.Redirect(Session["originUrl"] as string);
        }

        public Release Release
        {
            get
            {
                return Session["assignReleaseRelease"] as Release;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\TestEnvironment.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Web;
using System.Web.Configuration;
using System.Xml.Linq;

namespace YellowDoor
{
    [Serializable]
    class TestEnvironment : IEnvironment
    {
        public string Name { get; private set; }

        public string WebSgMixUrl { get { return ""; } }

        public X509Certificate2 WebSgCertificate { get { return new X509Certificate2(); } }

        public string SystemUpdateUploadPath { get; private set; } // Upload path for Flash CAB files

        public string SystemReleaseUploadPath { get; private set; } // Upload path for PAM packages

        public string SystemReleaseDownloadUrl { get; private set; }

        public string XblToolsPath { get; private set; }

        public bool IsXblob { get; private set; }

        public int CopyFileDelay { get; private set; }

        public int MixVersionBetaManagement { get { return -1; } }

        public int MixVersionSettingsManagement { get { return -1; } }

        public int MixVersionTitleManagement { get { return -1; } }

        public TestEnvironment(string name)
        {
            Name = name;

            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "p_environments_get_config";
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Name);
                    SqlDataReader reader = sqlCmd.ExecuteReader();
                    if (reader.Read())
                    {
                        SystemUpdateUploadPath = reader["vc_system_update_upload_path"] as string;
                        SystemReleaseUploadPath = reader["vc_system_release_upload_path"] as string;
                        IsXblob = (!reader.IsDBNull(reader.GetOrdinal("b_is_xblob")) && (bool)reader["b_is_xblob"]);
                        XblToolsPath = reader["vc_xbltools_path"] as string;
                        CopyFileDelay = (int)reader["i_copyfile_delay"];
                    }
                }
            }
        }

        public bool IsFlashPropped(uint version)
        {
            // TODO: This is a mock implementation of what the IsFlashPropped MIX API should return

            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "SELECT COUNT(i_version) FROM t_flash_propped WHERE i_version = @i_version AND vc_environment = @vc_environment";
                    sqlCmd.Parameters.AddWithValue("@i_version", (int)version);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Name);
                    int count = (int)sqlCmd.ExecuteScalar();
                    return (count > 0);
                }
            }
        }

        public Group GetGroupInfo(Guid id)
        {
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "p_groups_get_info";
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    // sqlCmd.Parameters.AddWithValue("@vc_environment", Name); Group guids are unique across environments
                    sqlCmd.Parameters.AddWithValue("@uid_group_id", id);
                    SqlDataReader reader = sqlCmd.ExecuteReader();
                    if (reader.Read())
                    {
                        Group group = new Group();
                        group.Summary = new Group.GroupSummary();
                        group.Summary.Id = (Guid)reader["uid_group_id"];
                        group.Summary.Name = reader["vc_name"] as string;
                        group.Summary.Creator = reader["vc_creator"] as string;
                        group.Summary.Created = (DateTime)reader["dt_created"];
                        group.Summary.FullFlashVersion = ((uint)(int)reader["i_flash_version"]) << 8;
                        group.RelInfos = new List<Group.ReleaseInfo>();
                        group.Titles = new Dictionary<uint,Group.TitleInfo>();

                        if (reader.NextResult() && reader.Read())
                        {
                            do
                            {
                                Group.ReleaseInfo relInfo = new Group.ReleaseInfo();
                                relInfo.SMRevision = reader["vc_sm_revision"] as string;
                                relInfo.SOMRevision = reader["vc_som_revision"] as string;
                                relInfo.FlashQfe = (short)reader["si_flash_qfe"];
                                relInfo.FlashVersion = (short)reader["si_flash_version"];
                                group.RelInfos.Add(relInfo);
                            } while (reader.Read());
                        }

                        if (reader.NextResult() && reader.Read())
                        {
                            do
                            {
                                uint titleId = (uint)(int)reader["i_title_id"];
                                if (!group.Titles.ContainsKey(titleId))
                                {
                                    Group.TitleInfo titleInfo = new Group.TitleInfo();
                                    titleInfo.TitleId = titleId;
                                    titleInfo.ConsoleType = (byte)reader["ti_console_type"];
                                    titleInfo.UpgradePaths = new List<Group.UpgradeInfo>();
                                    group.Titles[titleId] = titleInfo;
                                }
                                Group.UpgradeInfo upgInfo = new Group.UpgradeInfo();
                                upgInfo.BaseVersion = (uint)(int)reader["i_base_ver"];
                                upgInfo.UpgradeVersion = (uint)(int)reader["i_upgrade_ver"];
                                upgInfo.StartTime = (DateTime)reader["dt_start"];
                                upgInfo.EndTime = (DateTime)reader["dt_end"];
                                group.Titles[titleId].UpgradePaths.Add(upgInfo);
                            } while (reader.Read());
                        }

                        return group;
                    }
                    else
                    {
                        return null;
                    }
                }
            }
        }

        public Group.GroupSummary[] GetAllGroupSummaries()
        {
            // TODO: This is a mock implementation of what the GetGroups MIX API should return

            List<Group.GroupSummary> results = new List<Group.GroupSummary>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "SELECT * FROM t_groups WHERE vc_environment = @vc_environment";
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Name);
                    SqlDataReader reader = sqlCmd.ExecuteReader();
                    while (reader.Read())
                    {
                        Group.GroupSummary s = new Group.GroupSummary();
                        s.Id = (Guid)reader["uid_group_id"];
                        s.Name = reader["vc_name"] as string;
                        s.Creator = reader["vc_creator"] as string;
                        s.Created = (DateTime)reader["dt_created"];
                        s.FullFlashVersion = ((uint)(int)reader["i_flash_version"]) << 8;
                        results.Add(s);
                    }
                }
            }
            return results.ToArray();
        }

        public void AssignFlashReleaseToGroup(Release release, Guid groupId)
        {
            Group g = GetGroupInfo(groupId);
            // TODO: Actually assign the release to the group in YellowTest database
        }

        public void PropSelective(string cabFilePath, uint titleId)
        {

        }

        public void ValidateToolsMgmt(string testFile)
        {

        }

        public PropStatus GetPropStatus()
        {
            return new PropStatus();
        }

        public bool IsGlobalEnabled
        {
            get
            {
                return true;
            }
        }

        public GroupMembershipChangeResult[] AddConsoleIdsToGroup(string[] consoleIds, Guid groupId)
        {
            List<GroupMembershipChangeResult> status = new List<GroupMembershipChangeResult>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                foreach (string consoleId in consoleIds)
                {
                    // TODO: Check that the console is not on another group
                    using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                    {
                        sqlCmd.CommandText = "INSERT INTO t_group_consoles (uid_group_id, vc_console_id) VALUES (@uid_group_id, @vc_console_id)";
                        sqlCmd.Parameters.AddWithValue("@uid_group_id", groupId);
                        sqlCmd.Parameters.AddWithValue("@vc_console_id", consoleId);
                        sqlCmd.ExecuteNonQuery();
                    }
                    GroupMembershipChangeResult s = new GroupMembershipChangeResult();
                    s.ConsoleID = consoleId;
                    s.Outcome = GroupMembershipChangeResult.GroupMembershipChangeOutcome.Success;
                    status.Add(s);
                }
            }
            return status.ToArray();
        }

        public GroupMembershipChangeResult[] RemoveConsoleIdsFromGroup(string[] consoleIds, Guid groupId)
        {
            List<GroupMembershipChangeResult> status = new List<GroupMembershipChangeResult>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                foreach (string consoleId in consoleIds)
                {
                    using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                    {
                        sqlCmd.CommandText = "DELETE t_group_consoles WHERE uid_group_id = @uid_group_id AND vc_console_id = @vc_console_id";
                        sqlCmd.Parameters.AddWithValue("@uid_group_id", groupId);
                        sqlCmd.Parameters.AddWithValue("@vc_console_id", consoleId);
                        sqlCmd.ExecuteNonQuery();
                    }

                    GroupMembershipChangeResult s = new GroupMembershipChangeResult();
                    s.ConsoleID = consoleId;
                    s.Outcome = GroupMembershipChangeResult.GroupMembershipChangeOutcome.Success;
                    status.Add(s);
                }
            }
            return status.ToArray();
        }

        public string[] GetConsoleIdsForGroup(Guid groupId)
        {
            List<string> consoleIds = new List<string>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                foreach (string consoleId in consoleIds)
                {
                    using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                    {
                        sqlCmd.CommandText = "SELECT vc_console_id FROM t_group_consoles WHERE uid_group_id = @uid_group_id";
                        sqlCmd.Parameters.AddWithValue("@uid_group_id", groupId);
                        SqlDataReader reader = sqlCmd.ExecuteReader();
                        while (reader.Read())
                        {
                            consoleIds.Add(reader["vc_console_id"] as string);
                        }
                    }
                }
            }
            return consoleIds.ToArray();
        }

        public Guid CreateGroup(string name, string creator)
        {
            Guid newGuid = Guid.NewGuid();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowTest"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                {
                    sqlCmd.CommandText = "INSERT INTO t_groups (uid_group_id, vc_name, vc_creator, dt_created, vc_environment, i_flash_version) VALUES (@uid_group_id, @vc_name, @vc_creator, @dt_created, @vc_environment, @i_flash_version)";
                    sqlCmd.Parameters.AddWithValue("@uid_group_id", newGuid);
                    sqlCmd.Parameters.AddWithValue("@vc_name", name);
                    sqlCmd.Parameters.AddWithValue("@vc_creator", creator);
                    sqlCmd.Parameters.AddWithValue("@dt_created", DateTime.UtcNow);
                    sqlCmd.Parameters.AddWithValue("@vc_environment", Name);
                    sqlCmd.Parameters.AddWithValue("@i_flash_version", (int)0);
                    sqlCmd.ExecuteNonQuery();
                }
            }
            return newGuid;
        }

        public InvalidConsoleResult[] ValidateBetaGroupConsoles(Guid groupId)
        {
            List<InvalidConsoleResult> results = new List<InvalidConsoleResult>();
            
            InvalidConsoleResult result = new InvalidConsoleResult();
            result.FlashVersion = 0x20000000;
            result.ConsoleID = "xe.021509791782";
            results.Add(result);

            return results.ToArray();
        }

        public LiveHiveSettingsEntry[] GetSettings(Guid groupId, ushort BuildId)
        { 
            throw new NotImplementedException();
        }

        public void SetSetting(Guid groupId, ushort BuildId, string name, string value)
        {
            throw new NotImplementedException();
        }

        public LiveHiveSettingsEntry[] GetDefaultSettings()
        {
            throw new NotImplementedException();
        }

        public TitleVersionInstance[] GetTitleVersions(uint titleId)
        {
            throw new NotImplementedException();
        }

        public void AddBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            throw new NotImplementedException();
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, System.Guid betaGroup)
        {
            throw new NotImplementedException();
        }

        public Group.GroupSummary[] GetGroupsForConsoleIDs(string[] consoleIDs)
        {
            throw new NotImplementedException();
        }

        public void RemoveGroup(System.Guid groupId)
        {
            throw new NotImplementedException();
        }

        public GroupMembershipChangeResult[] MigrateConsoleIDsToGroup(string[] consoleIDs, System.Guid fromGroup, System.Guid toGroup)
        {
            throw new NotImplementedException();
        }

        public void RenameGroup(Guid GroupId, string newName)
        {
            throw new NotImplementedException();

        }

        public XElement IngestEtxManifest(string etxLocationSpec)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Releases.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class WebForm2 : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GeneralReadOnly);

            if (!Roles.Current.HasRole(Roles.FlashReadWrite))
            {
                this.GridView1.Columns[8].Visible = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Releases.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class WebForm2 {
        
        /// <summary>
        /// chkShowArchived control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox chkShowArchived;
        
        /// <summary>
        /// GridView1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.GridView GridView1;
        
        /// <summary>
        /// dbReleases control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.SqlDataSource dbReleases;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ReleaseHistory.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Web;
using System.Web.Configuration;

namespace YellowDoor
{
    public class ReleaseHistory
    {
        public class Entry
        {
            public Guid GroupId { get; set; }

            public Guid ReleaseId { get; set; }

            public string ReleaseName { get; set; }

            public string Environment { get; set; }

            public string User { get; set; }

            public DateTime Assigned { get; set; }

            public uint TitleId { get; set; }

            public static Entry FromReader(SqlDataReader reader)
            {
                Entry e = new Entry();
                e.GroupId = (Guid)reader["uid_group_id"];
                e.ReleaseId = (Guid)reader["uid_release_id"];
                e.ReleaseName = (string)reader["vc_release_name"];
                e.Environment = (string)reader["vc_environment"];
                e.User = (string)reader["vc_environment"];
                e.Assigned = (DateTime)reader["dt_assigned"];
                e.TitleId = (uint)(int)reader["i_title_id"];
                return e;
            }

            public void SaveToDb(SqlConnection sqlCon)
            {
                using (SqlCommand cmd = sqlCon.CreateCommand())
                {
                    cmd.CommandText = "p_release_history_insert";
                    cmd.CommandType = System.Data.CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@uid_group_id", GroupId);
                    cmd.Parameters.AddWithValue("@uid_release_id", ReleaseId);
                    cmd.Parameters.AddWithValue("@vc_environment", Environment);
                    cmd.Parameters.AddWithValue("@vc_user", User);
                    cmd.Parameters.AddWithValue("@dt_assigned", Assigned);
                    cmd.Parameters.AddWithValue("@i_title_id", (int)TitleId);
                    cmd.ExecuteNonQuery();
                }
            }
        }

        public static Entry[] GetAllForGroup(string environment, Guid groupId)
        {
            List<Entry> entries = new List<Entry>();
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                using (SqlCommand cmd = sqlCon.CreateCommand())
                {
                    cmd.CommandText = "p_release_history_get_all_for_group";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@vc_environment", environment);
                    cmd.Parameters.AddWithValue("@uid_group_id", groupId);
                    SqlDataReader reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        entries.Add(Entry.FromReader(reader));
                    }
                }
            }
            return entries.ToArray();
        }

        public static Entry GetActiveForGroup(string environment, Guid groupId)
        {
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                using (SqlCommand cmd = sqlCon.CreateCommand())
                {
                    cmd.CommandText = "p_release_history_get_active_for_group";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@vc_environment", environment);
                    cmd.Parameters.AddWithValue("@uid_group_id", groupId);
                    SqlDataReader reader = cmd.ExecuteReader();
                    if (reader.Read())
                    {
                        return Entry.FromReader(reader);
                    }
                }
            }
            return null;
        }

        public static void CreateEntry(Guid releaseId, Guid groupId, uint titleId, string environment, string user)
        {
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                Entry e = new Entry();
                e.GroupId = groupId;
                e.ReleaseId = releaseId;
                e.Environment = environment;
                e.User = user;
                e.Assigned = DateTime.UtcNow;
                e.TitleId = titleId;
                e.SaveToDb(sqlCon);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\Roles.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Security.Principal;
using System.Web;
using System.Web.Configuration;

namespace YellowDoor
{
    public class UnauthorizedRoleException : Exception
    {
        public UnauthorizedRoleException(string reason)
            : base(reason)
        {
        }
    }

    public class Roles
    {
        public const string GeneralReadOnly = "general_ro";
        public const string FlashReadWrite = "flash_rw";
        public const string GroupsReadWrite = "groups_rw";
        public const string GroupsCreate = "groups_new";
        public const string SettingsReadWrite = "settings_rw";
        public const string TitlesReadWrite = "titles_rw";
        public const string GroupGlobalReadWrite = "global_rw";
        public const string SuperUser = "su";

        protected List<string> Memberships { get; set; }

        public static Roles Current
        {
            get
            {
                if (HttpContext.Current != null)
                {
                    Roles roles = HttpContext.Current.Session["UserRoles"] as Roles;
                    if (roles == null)
                    {
                        roles = Roles.Load();
                        HttpContext.Current.Session["UserRoles"] = roles;
                    }

                    return roles;
                }
                else
                {
                    return null;
                }
            }
        }

        public static Roles Load()
        {
            Roles roles = new Roles();

            // The environment should've been saved into the session already
            IEnvironment env = HttpContext.Current.Session["environment"] as IEnvironment;

            // Grab all of the possible user identities
            List<string> identities = new List<string>();
            identities.Add(HttpContext.Current.Request.LogonUserIdentity.Name);
            foreach (var group in HttpContext.Current.Request.LogonUserIdentity.Groups)
            {
                NTAccount account = group.Translate(typeof(NTAccount)) as NTAccount;
                identities.Add(account.Value);
            }

            identities.Add(HttpContext.Current.Request.LogonUserIdentity.Name);

            // Grab all the different roles that the user is granted
            roles.Memberships = new List<string>();
            
            ConnectionStringSettings connString = WebConfigurationManager.ConnectionStrings["YellowDoor"];
            using (SqlConnection sqlCon = new SqlConnection(connString.ConnectionString))
            {
                sqlCon.Open();
                foreach (string identity in identities)
                {
                    using (SqlCommand sqlCmd = sqlCon.CreateCommand())
                    {
                        sqlCmd.CommandText = "p_roles_find";
                        sqlCmd.CommandType = CommandType.StoredProcedure;
                        sqlCmd.Parameters.AddWithValue("@vc_environment", env.Name);
                        sqlCmd.Parameters.AddWithValue("@vc_name", identity.ToLower());
                        using (SqlDataReader reader = sqlCmd.ExecuteReader())
                        {
                            while (reader.Read())
                            {
                                string role = (string)reader["vc_role"];
                                if (!roles.Memberships.Contains(role))
                                {
                                    roles.Memberships.Add(role);
                                }
                            }
                        }
                    }
                }
            }

            return roles;
        }

        public bool HasRole(string name)
        {
            return (Memberships.Contains(name) || Memberships.Contains(SuperUser));
        }

        public void EnforceRole(string name)
        {
            if (!HasRole(name))
            {
                throw new UnauthorizedRoleException("The current user does not have the required role: " + name);
            }
        }

        public static Guid GlobalGroupId = Guid.Empty;

        public bool HasGroupAccess(Guid groupId, bool write)
        {
            if (write && groupId == GlobalGroupId)
            {
                return Roles.Current.HasRole(Roles.GroupGlobalReadWrite);
            }
            else if (write)
            {
                return Roles.Current.HasRole(Roles.GroupsReadWrite);
            }
            else
            {
                return Roles.Current.HasRole(Roles.GeneralReadOnly);
            }
        }

        public void EnforceGroupAccess(Guid groupId, bool write)
        {
            if (!HasGroupAccess(groupId, write))
            {
                throw new UnauthorizedRoleException(
                    String.Format(
                        "The current user does not have {0} access to group {1}. ",
                        write ? "write" : "read",
                        groupId
                    ));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\TitleDetails.aspx.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.Configuration;

namespace YellowDoor
{
    public partial class TitleDetails : YellowDoorPage
    {
        
        protected Button btnBaseEnable;
        protected Button btnConfirmYes;
        protected Button btnConfirmNo;
        protected CheckBoxList chkListGroups;
        protected Label lblTitleId;
        protected Label lblPlatformType;
        protected Literal litConfirm;
        protected Literal litError;
        protected Panel pnlConfirm;
        protected Panel pnlDetails;
        protected Panel pnlAssignToGroup;
        protected Repeater detailsRepeater;
        protected TextBox tbVersion;
        protected TextBox tbFilterGroups;
        protected ObjectDataSource dbGroups;

        private PlatformType platformType;

        private uint _titleId = 0;

        protected void Page_Load(object sender, EventArgs e)
        {
            Roles.Current.EnforceRole(Roles.GeneralReadOnly);

            if (!Roles.Current.HasRole(Roles.TitlesReadWrite))
            {
                this.pnlAssignToGroup.Visible = false;
            }

            if (!Page.IsPostBack)
            {
                detailsRepeater.ItemDataBound += new RepeaterItemEventHandler(detailsRepeater_ItemDataBound);
            }

            _titleId = GetParam("titleid", false, 0);

            if (_titleId > 0)
            {
                TitleVersionInstance[] instances = Environment.GetTitleVersions(_titleId);

                if (!Environment.IsGlobalEnabled)
                {
                    List<TitleVersionInstance> editedList = new List<TitleVersionInstance>();
                    foreach (TitleVersionInstance tvi in instances)
                    {
                        if (tvi.BetaGroupId != Group.GlobalGroupId)
                        {
                            editedList.Add(tvi);
                        }
                    }

                    instances = editedList.ToArray();
                }

                if (instances.Length > 0)
                {
                    if (string.Compare(GetParam("action", false, string.Empty), "remove", true) == 0)
                    {
                        int version = (int)GetParam("version", true, 0);
                        Guid groupId = GetParam("GroupId", true, Guid.Empty);

                        Environment.RemoveBaseVersion(_titleId, version, instances[0].PlatformType, groupId);
                        Response.Redirect(string.Format("~/TitleDetails.aspx?TitleId={0}", _titleId.ToString("X")));
                    } 

                    lblTitleId.Text = _titleId.ToString("X");
                    lblPlatformType.Text = string.Format("<b>{0}</b>", instances[0].PlatformName);
                    platformType = instances[0].PlatformType;
                    detailsRepeater.DataSource = instances;
                    detailsRepeater.DataBind();
                    pnlDetails.Visible = true;

                    dbGroups.SelectParameters["showGlobal"].DefaultValue = (Environment.IsGlobalEnabled && Roles.Current.HasRole(Roles.GroupGlobalReadWrite)).ToString();
                }
            }
            else
            {
                pnlDetails.Visible = false;
            }
        }

        void detailsRepeater_ItemDataBound(object sender, RepeaterItemEventArgs e)
        {
            TitleVersionInstance instance = e.Item.DataItem as TitleVersionInstance;
            if ((instance != null && (instance.BaseVersion == instance.UpdateVersion)) &&
                   ((instance.BetaGroupId != Group.GlobalGroupId && (Roles.Current.HasRole(Roles.TitlesReadWrite))) ||
                    (Environment.IsGlobalEnabled && instance.BetaGroupId == Group.GlobalGroupId && (Roles.Current.HasRole(Roles.GroupGlobalReadWrite)))
                    ))
            {
                Literal lit = e.Item.FindControl("litRemoveLink") as Literal;
                if (lit != null)
                {
                    lit.Text = string.Format("<a href='javascript:confirmRemove(\"0x{2}\", \"{3}\", \"titledetails.aspx?titleid={0}&action=remove&groupid={1}&version={2}\")'>Remove</a>",
                       _titleId, 
                       instance.BetaGroupId,
                       instance.UpdateVersion.ToString("X"),
                       instance.GroupName);
                }
            }
        }

        protected void btnBaseEnable_Click(object sender, EventArgs e)
        {
            List<string> submittedGroupIds = new List<string>();
            StringBuilder message = new StringBuilder();

            if (chkListGroups.SelectedItem == null)
            {
                this.litError.Text = "<font style='color:red'>You must select a group.</font>";
                return;
            }

            if (!string.IsNullOrEmpty(tbVersion.Text))
            {
                uint submittedTitleId = YellowDoorPage.GetUInt(tbVersion.Text, true, 0);
                message.AppendFormat("Are you sure you want to Enable 0x{0} for Group(s): ", submittedTitleId.ToString("X"));

                foreach (ListItem item in chkListGroups.Items)
                {
                    if (item.Selected)
                    {
                        submittedGroupIds.Add(item.Value);
                        message.AppendFormat("{0}, ", item.Text);
                    }
                }

                Session["submittedGroupIds"] = submittedGroupIds;
                Session["submittedTitleId"] = submittedTitleId;

                this.litConfirm.Text = message.ToString();
                this.pnlConfirm.Visible = true;
                this.pnlDetails.Visible = false;
            }
            else
            {
                this.litError.Text = "<font style='color:red'>You must supply a version to base enable.</font>";
            }
        }

        protected void btnConfirm_Click(object sender, EventArgs e)
        {
            List<string> submittedGroupIds = Session["submittedGroupIds"] as List<string>;
            uint submittedTitleId = (uint)Session["submittedTitleId"];

            if (submittedGroupIds != null)
            {
                foreach (string guid in submittedGroupIds)
                {
                    Environment.AddBaseVersion(GetParam("TitleId", true, 0), (int)submittedTitleId, platformType, new Guid(guid));
                }
            }

            this.pnlConfirm.Visible = false;
            Response.Redirect(string.Format("~/TitleDetails.aspx?TitleId={0}", GetParam("TitleId", true, 0).ToString("X")));
        }

        protected void btnNo_Click(object sender, EventArgs e)
        {
            Response.Redirect(string.Format("~/TitleDetails.aspx?TitleId={0}", GetParam("TitleId", true, 0).ToString("X")));
        }

        protected void btnFilterClear_Click(object sender, EventArgs e)
        {
            tbFilterGroups.Text = "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\TitleVersionInstance.cs ===
using System;

using MixTitleVersionInstance = xonline.mix.titlemanagement.contracts.V1.TitleVersionInstance;

namespace YellowDoor
{
    public enum PlatformType : int
    { 
        Xbox1 = 0,
        XboxCom = 1,
        Xenon = 2,
        Marketplace = 3,
        PC = 4,
        Mobile = 5,
        WebGames = 6,
    }

    public class TitleVersionInstance
    {
        public Guid BetaGroupId { get; private set; }
        public int BaseVersion { get; private set; }
        public uint TitleId { get; private set; }
        public int UpdateVersion { get; private set; }
        public PlatformType PlatformType {get; private set;}
        public string GroupName { get; private set; }
        public string PlatformName
        {
            get
            {
              switch (PlatformType)
              {
                  case PlatformType.Xbox1:
                      return "Xbox1";
                  case PlatformType.XboxCom:
                      return "Xbox.com";
                  case PlatformType.Xenon:
                      return "Xenon";
                  case PlatformType.Marketplace:
                      return "Marketplace";
                  case PlatformType.PC:
                      return "PC";
                  case PlatformType.Mobile:
                      return "Mobile";
                  case PlatformType.WebGames:
                      return "Web Games";
                  default:
                      throw new NotSupportedException();
                }
            }
        }

        public static TitleVersionInstance FromServiceInstance(MixTitleVersionInstance serviceVersion, IEnvironment env)
        {
            TitleVersionInstance instance = new TitleVersionInstance();
            instance.BetaGroupId = serviceVersion.BetaGroup;

            if (serviceVersion.BetaGroup == Group.GlobalGroupId)
            {
                instance.GroupName = "GLOBAL";
            }
            else
            {
                instance.GroupName = env.GetGroupInfo(serviceVersion.BetaGroup).Summary.Name;
            }
            instance.BaseVersion = serviceVersion.BaseVersion;
            instance.TitleId = serviceVersion.TitleId;
            instance.UpdateVersion = serviceVersion.UpdateVersion;
            instance.PlatformType = (PlatformType)((int)serviceVersion.PlatformType);

            return instance;
        }

        private TitleVersionInstance()
        { 
        
        }
    }

    //public class TitleVersions
    //{
    //    public TitleVersionInstance[] Versions { get; private set; }
    //}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\validateenvironmenttask.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Configuration;

using YellowDoor.ToolsMgmtProxy;

namespace YellowDoor
{
    public class ValidateEnvironmentTask : WebTask
    {
        protected static string TestFileName
        {
            get { return "ydtest.txt"; }
        }

        protected IEnvironment TargetEnvironment { get; set; }

        public ValidateEnvironmentTask(IEnvironment environment)
        {
            TargetEnvironment = environment;
        }

        protected override void OnTaskRun()
        {
            Guid testID = Guid.NewGuid();

            TaskProgressBuffer.AppendLine("Starting validation...");

            // Write out to the content share to verify write access. Writing the testID into the file so we can read it later
            TaskProgressBuffer.AppendLine("Step 1. Validate writing to the content share. The control file will be downloaded in step 4.");

            try
            {
                using (StreamWriter sw = File.CreateText(Path.Combine(TargetEnvironment.SystemReleaseUploadPath, TestFileName)))
                {
                    sw.WriteLine(testID.ToString());
                }
            }
            catch (Exception ex)
            {
                throw new Exception(String.Format("Failed to write to the content share. Make sure that the content share exists at {0}. Error: {1} ",
                    TargetEnvironment.SystemReleaseUploadPath, ex.Message), ex);
            }
            TaskProgressBuffer.AppendLine("    Successfully wrote to the content share.");

            TaskProgressBuffer.AppendLine();

            TaskProgressBuffer.AppendLine("Step 2. Call into IsFlashVersionPropped MIX API to validate calls through the WebSG");
            try
            {
                TargetEnvironment.IsFlashPropped(537354240);
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to call into IsFlashVersionPropped MIX API. Error: " + ex.Message, ex);
            }
            TaskProgressBuffer.AppendLine("    Successfully called into IsFlashVersionPropped");

            TaskProgressBuffer.AppendLine();

            TaskProgressBuffer.AppendLine("Step 3. Validate Tools Management");
            try
            {
                TargetEnvironment.ValidateToolsMgmt(TestFileName);
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to call into wctoolsmgmt. Error: " + ex.Message, ex);
            }

            TaskProgressBuffer.AppendLine("    Waiting for WCTools to finish executing job.");

            int dotCount = 0;
            int refreshWait = Int32.Parse(WebConfigurationManager.AppSettings["PropFlashTask.WCToolsRefreshWaitMs"]);
            PropStatus status;

            do
            {
                Thread.Sleep(refreshWait);
                status = TargetEnvironment.GetPropStatus();
                TaskProgressBuffer.Append(".");
                dotCount = (dotCount + 1) % 20;
                if (dotCount == 0)
                    TaskProgressBuffer.AppendLine();
            } while (!status.Finished);

            TaskProgressBuffer.AppendLine();

            if (status.JobFailure)
            {
                throw new Exception("Yellow Door had a problem executing the job. Please investigate whether files are uploading correctly.");
            }
            else
            {
                TaskProgressBuffer.AppendLine((status.ReturnCode == 0) ? " SUCCESS!" : "FAILURE!");
                TaskProgressBuffer.AppendFormat("LiveContent returned error code {0}. Partial output:\n{1}\n\n", status.ReturnCode, status.Output.Substring(0, 100));

                if (status.ReturnCode != 0)
                {
                    // Need to throw an error so that WebTask flags the error on the webpage.
                    throw new Exception("Live content failed to prop flash selective. See above for details");
                }
            }

            TaskProgressBuffer.AppendLine("    Successfully validated Tools Management");

            TaskProgressBuffer.AppendLine();

            // Download the file from the content url that was uploaded in the first step. Since the wctools validation has the CopyFileDelay wait time built in,
            // we won't wait again for this content file. That would be silly.
            TaskProgressBuffer.AppendLine("Step 4. Validate downloading control file from the CDN/DownIIS");

            string contentUrl = TargetEnvironment.SystemReleaseDownloadUrl;
            HttpWebResponse response;

            string url = String.Format("{0}/{1}", contentUrl, TestFileName);

            try
            {
                HttpWebRequest request = WebRequest.Create(url) as HttpWebRequest;
                response = request.GetResponse() as HttpWebResponse;
            }
            catch (Exception ex)
            {
                throw new Exception(String.Format("Failed to download test file from the content url at '{0}'. Please validate access to the download url and that Signiant successfully copied the file over. Error: {1}",
                    url, ex.Message), ex);
            }

            using (Stream s = response.GetResponseStream())
            {
                using (StreamReader reader = new StreamReader(s))
                {
                    if (reader.ReadToEnd().Trim() != testID.ToString())
                        throw new Exception("Validation of Signiant file copy to the destination share failed. This might not be a serious error because Signiant replication times may exceed 15 minutes in production environments. If concerned, please check Signiant replication to the content shares.");
                }
            }
            TaskProgressBuffer.AppendLine("    Successfully downloaded the control file");

            TaskProgressBuffer.AppendLine();
            TaskProgressBuffer.AppendLine("All validation steps completed successfully!");
            TaskProgressBuffer.AppendLine();
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\YellowDoor.Master.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace YellowDoor {
    
    
    public partial class YellowDoor {
        
        /// <summary>
        /// head control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder head;
        
        /// <summary>
        /// formMaster control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm formMaster;
        
        /// <summary>
        /// lstEnvironments control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList lstEnvironments;
        
        /// <summary>
        /// dbEnvironments control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.SqlDataSource dbEnvironments;
        
        /// <summary>
        /// TreeView1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TreeView TreeView1;
        
        /// <summary>
        /// dbMapSite control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.SiteMapDataSource dbMapSite;
        
        /// <summary>
        /// content control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder content;

        protected global::System.Web.UI.WebControls.Literal litId;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\WebTask.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Web;

namespace YellowDoor
{
    public abstract class WebTask
    {
        protected StringBuilder TaskProgressBuffer { get; private set; }

        public string TaskProgress 
        {
            get { return TaskProgressBuffer.ToString(); } 
        }

        private WebTaskResult TaskResult { get; set; }

        private WindowsIdentity Identity { get; set; }

        protected abstract void OnTaskRun();

        public IAsyncResult Run()
        {
            Identity = WindowsIdentity.GetCurrent();
            TaskProgressBuffer = new StringBuilder();
            TaskResult = new WebTaskResult(this);
            Thread t = new Thread(new ThreadStart(() => RunInternal()));
            t.Start();

            return TaskResult;
        }

        public bool HasException
        {
            get { return ((TaskResult != null) && (TaskResult.ResultException != null)); }
        }

        public Exception Exception
        {
            get { return (TaskResult.ResultException); }
        }

        private void RunInternal()
        {
            DateTime dtStart = DateTime.Now;
            WindowsImpersonationContext ctx = null;

            try
            {
                TaskProgressBuffer.AppendLine(string.Format("Asynchronous web task started at: {0:G}\n", dtStart));
                // ctx = Identity.Impersonate(); -- Can't do this unless we enable ASP.NET delegation
                OnTaskRun();
            }
            catch (Exception e)
            {
                TaskResult.ResultException = e;
            }
            finally
            {
                if (ctx != null)
                {
                    ctx.Undo();
                }
                TimeSpan s = DateTime.Now - dtStart;
                TaskProgressBuffer.AppendLine(string.Format("Asynchronous web task completed in: {0:00}:{1:00}:{2:00}\n", s.Hours, s.Minutes, s.Seconds));
                if (TaskResult.ResultException != null)
                {
                    TaskProgressBuffer.AppendLine(string.Format("Asynchronous web task thrown an exception:"));
                    TaskProgressBuffer.AppendLine(string.Format(TaskResult.ResultException.ToString()));
                    if (TaskResult.ResultException.InnerException != null)
                    {
                        TaskProgressBuffer.AppendLine(string.Format("\n\n--Inner Exception:"));
                        TaskProgressBuffer.AppendLine(string.Format(TaskResult.ResultException.InnerException.ToString()));
                    }
                }
                TaskResult.IsCompleted = true;
            }
        }

        private class WebTaskResult : IAsyncResult
        {
            public object AsyncState { get; set; }

            private ManualResetEvent AsyncEventHandle { get; set; }

            public WaitHandle AsyncWaitHandle
            {
                get
                {
                    return AsyncEventHandle;
                }
            }

            public bool CompletedSynchronously { get; set; }

            private bool _isCompleted;

            public bool IsCompleted
            {
                get
                {
                    return _isCompleted;
                }

                set
                {
                    _isCompleted = value;
                    if (_isCompleted)
                    {
                        AsyncEventHandle.Set();
                    }
                }
            }

            public Exception ResultException { get; set; }

            public WebTaskResult(WebTask task)
            {
                AsyncEventHandle = new ManualResetEvent(false);
                AsyncState = task;
                CompletedSynchronously = false;
                IsCompleted = false;
                ResultException = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\YellowDoorPage.cs ===
using System;
using System.Globalization;
using System.Web.UI;


namespace YellowDoor
{
    public class YellowDoorPage : Page
    {
        private IEnvironment _env = null;

        public static uint GetUInt(string val, bool throwOnNotFound, uint defaultValue)
        {
            try
            {
                val = val.Trim().ToLower();

                if (val.Contains("a") ||
                    val.Contains("b") ||
                    val.Contains("c") ||
                    val.Contains("d") ||
                    val.Contains("e") ||
                    val.Contains("f") ||
                    val.Contains("x"))
                {
                    if (!val.Contains("x"))
                    {
                        val = string.Format("0x{0}", val);
                    }

                    return Convert.ToUInt32(val, 16);
                }
                else
                {
                    return uint.Parse(val);
                }
            }
            catch
            {
                if (throwOnNotFound) throw;
                return defaultValue;
            }
        
        }

        public YellowDoorPage()
        { 
            
        }

        public Guid GetParam(string name, bool throwOnNotFound, Guid defaultValue)
        {
            string val = GetParam(name, throwOnNotFound, string.Empty);
            if (string.IsNullOrEmpty(val)) return defaultValue;

            try
            {
                return new Guid(val);
            }
            catch
            {
                if (throwOnNotFound) throw;
                return defaultValue;
            }
        }

        public uint GetParam(string name, bool throwOnNotFound, uint defaultValue)
        {
            string val = GetParam(name, throwOnNotFound, string.Empty);
            if (string.IsNullOrEmpty(val)) return defaultValue;
            return GetUInt(val, throwOnNotFound, defaultValue);
        }

        public string GetParam(string name, bool throwOnNotFound, string defaultValue)
        {
            try
            {
                return Request.QueryString[name];
            }
            catch
            {
                if (throwOnNotFound) throw;
                return defaultValue;
            }
        }

        public IEnvironment Environment
        {
            get
            {
                if (_env == null)
                {
                    _env = Session["environment"] as IEnvironment;
                }

                return _env;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\YellowDoor.Master.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace YellowDoor
{
    public partial class YellowDoor : System.Web.UI.MasterPage
    {
        protected void Page_Init(object sender, EventArgs e)
        {
            IEnvironment env = Session["environment"] as IEnvironment;
            if (env == null)
            {
                HttpCookie cookie = Request.Cookies["environment"];
                if (cookie != null)
                {
                    try
                    {
                        env = EnvironmentFactory.GetEnvironment(cookie.Value);
                        Session["environment"] = env;
                    }
                    catch (Exception)
                    {
                    }
                }
            }
            if (env == null)
            {
                env = EnvironmentFactory.GetDefaultEnvironment();
                Session["environment"] = env;
                // No need to save a cookie if we're using default environment
            }
        }

        protected void Page_Load(object sender, EventArgs e)
        {
            litId.Text = HttpContext.Current.Request.LogonUserIdentity.Name;
        }

        protected void lstEnvironments_SelectedIndexChanged(object sender, EventArgs e)
        {
            IEnvironment env = EnvironmentFactory.GetEnvironment(lstEnvironments.SelectedValue);
            Session.Abandon();
            Session["environment"] = env;
            // Without expiration date, this cookie will only preserved until the user closes their browser.
            // After that, user will be back to DefaultEnvironment defined in Web.config. This is by-design.
            Response.Cookies.Add(new HttpCookie("environment", env.Name));
            Response.Redirect("Default.aspx");
        }

        protected void lstEnvironments_DataBound(object sender, EventArgs e)
        {
            IEnvironment selectedEnvironment = Session["environment"] as IEnvironment;
            for (int i = 0; i < lstEnvironments.Items.Count; ++i)
            {
                if (selectedEnvironment != null && lstEnvironments.Items[i].Value == selectedEnvironment.Name)
                {
                    lstEnvironments.SelectedIndex = i;
                    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\MgmtInterface.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: MgmtInterface.h
//
//  Interface MgmtInterface Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Pre-Declarations
//-----------------------------------------------------------------------------
class CXMgmtControlCallback;
class CMgmtInterface;


//-----------------------------------------------------------------------------
// Types/Structures
//-----------------------------------------------------------------------------
typedef HRESULT (*MgmtCmdHandler)(
    IN LPVOID lpCmdData,
    IN CMgmtInterface *pMgmtInf,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    );

typedef struct _XomMgmtCmd {
    char*           szCmdName;
    DWORD           dwCmdNameLen;
    MgmtCmdHandler  pfnCmdProc;
    char*           szCmdHelp;
    LPVOID          lpData;
} XomMgmtCmd;

//-----------------------------------------------------------------------------
// CMgmtInterface
//-----------------------------------------------------------------------------

class CMgmtInterface
{
public:
    CMgmtInterface( );
    virtual ~CMgmtInterface(void);

    // call before using.
    HRESULT Initialize( DWORD dwNumOfCmds );

    // sycn TCPIP XMGMT connection to specified address.
    HRESULT SendRequest( char *szSG, LPCSTR lpszRequest, char* szResponse, DWORD dwResponseBufferSize, DWORD *pdwBytesRecv, HRESULT *pHr );

    HRESULT RegisterCommand( XomMgmtCmd newCmd );

    DWORD   GetNumberOfRegisteredCommands() { return m_dwNumRegCmds; }

    friend CXMgmtControlCallback;

    static HRESULT MgmtCmdHelp(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    // overrides
    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }
   

protected:
    CXMgmtControlCallback* m_pMgmtHandler;

    XomMgmtCmd *m_pCmdList;
    DWORD m_dwMaxCmds;
    DWORD m_dwNumRegCmds;    
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\MgmtInterface.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: MgmtInterface.cpp
//
//  Implementation of the mgmt interface.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "MgmtInterface.h"

#include <xmgmt.h>
#include <XAlloc.h>

#include <Time.h>

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------
XomDefineArea(XMGMT);

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
#define MAX_MGMT_RESPONSE_SIZE          256

//-----------------------------------------------------------------------------
//  Constant
//-----------------------------------------------------------------------------
const DWORD c_dwDefaultQueueSize        = 400;
const DWORD c_dwDefaultMaxFileSize      = 200000;

//-----------------------------------------------------------------------------
//  Local Function Declaration
//-----------------------------------------------------------------------------
BOOL                StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutes, DWORD *pdwSeconds );
void                StringToLowerCase( char *szResult, char *szSrc, DWORD dwSrcSize );


//-----------------------------------------------------------------------------
// CXMgmtControlCallback provides mgmt interface for XDS service
//-----------------------------------------------------------------------------
class CXMgmtControlCallback : public CXomControlCallback
{
    IMPLEMENT_REFCOUNT_COM;

    CXMgmtControlCallback(CMgmtInterface *pMI) :
        CXomControlCallback(),
        m_pMgmtInterface(pMI)
    {
    }

    virtual ~CXMgmtControlCallback()
    {
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );
    
 protected:
    HRESULT ParseArgList(
        IN  LPCSTR pszRequest,
        OUT DWORD *pdwArgc,
        OUT LPCSTR **ppArgv );
    
    CMgmtInterface* m_pMgmtInterface;
    
};


//-----------------------------------------------------------------------------
//  CMgmtInterface Implementation
//-----------------------------------------------------------------------------
CMgmtInterface::CMgmtInterface()
{
    m_dwNumRegCmds = 0;
    m_dwMaxCmds    = 0;
    m_pCmdList     = NULL;
}

CMgmtInterface::~CMgmtInterface(void)
{
    DWORD dwX = 0;

    if ( m_pCmdList )
    {        
        delete[] m_pCmdList;
    }

    m_dwNumRegCmds = 0;
    m_dwMaxCmds    = 0;
    m_pCmdList     = NULL;
}

//-----------------------------------------------------------------------------
//  Initialize:  Creates the node bag.
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::Initialize( DWORD dwNumOfCmds )
{
    HRESULT hr = S_OK;

    
    XomTrace( XMGMT, L_NORMAL, "CMgmtInterface::Initialize:  Initializing MGMT Interface.");

    // install the mgmt command handler
    m_pMgmtHandler = new CXMgmtControlCallback(this);
    if ( NULL == m_pMgmtHandler )
    {
        // not enough memory to create a mgmt control callback object.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt control callback handler.   Modify the configuration or add more phyical memory to this machine.");
        XomTrace( XMGMT, L_ERROR, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt control callback handler.   Modify the configuration or add more phyical memory to this machine.");
            
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    XomTrace( XMGMT, L_NORMAL, "CMgmtInterface::Initialize:  Registering mgmt control handler.");
    hr = g_xomcentral.RegisterControlCallback(m_pMgmtHandler);
    if ( FAILED(hr) )
    {
        // not enough memory to create a mgmt control callback object.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_1, "CMgmtInterface::Initialize:  Failed to register mgmt callbacks.  This could be due to a lack of memory.  Result=0x%X", hr);
        XomTrace( XMGMT, L_ERROR, "CMgmtInterface::Initialize:  Failed to register mgmt callbacks.  This could be due to a lack of memory.  Result=0x%X", hr);
            
        goto Exit;
    }

    m_dwMaxCmds = dwNumOfCmds;
    m_pCmdList = new XomMgmtCmd[dwNumOfCmds];
    if ( NULL == m_pCmdList )
    {
        // not enough memory to create a mgmt control callback object.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_2, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt command list.   Modify the configuration or add more phyical memory to this machine.");
        XomTrace( XMGMT, L_ERROR, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt command list.   Modify the configuration or add more phyical memory to this machine.");
            
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    m_dwNumRegCmds = 0;
    
Exit:    
    XomTrace( XMGMT, L_LOW, "CMgmtInterface::Initialize:  Complete with result = 0x%X.", hr);
    return hr;
}

//-----------------------------------------------------------------------------
//  RegisterCommand:  Registers a callback command with the interface..
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::RegisterCommand( XomMgmtCmd newCmd )
{
    HRESULT hr = S_OK;
    XOMASSERT( m_dwNumRegCmds < m_dwMaxCmds );

    // copy information into structure.
    if ( newCmd.szCmdName == NULL )
    {
        // the send request failed.
        XomTrace( XMGMT, L_ERROR, "CMgmtInterface::RegisterCommand:  Registering command must have a name.");
        XOMASSERT( FALSE );        
    }
    
    m_pCmdList[m_dwNumRegCmds].szCmdName = newCmd.szCmdName;
    m_pCmdList[m_dwNumRegCmds].dwCmdNameLen= newCmd.dwCmdNameLen;
    
    // copy pointer values
    m_pCmdList[m_dwNumRegCmds].lpData = newCmd.lpData;
    m_pCmdList[m_dwNumRegCmds].pfnCmdProc = newCmd.pfnCmdProc;

    // copy the help name
    m_pCmdList[m_dwNumRegCmds].szCmdHelp = newCmd.szCmdHelp;
    
    // increase the number of register commands.
    m_dwNumRegCmds++;
    
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdHelp:  help command.  Displays commands
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdHelp(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;

    CHAR szHelpText[MAX_MGMT_RESPONSE_SIZE];
    
    _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
              "XMGMT commands: \n"
              );
    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);

    for (DWORD i=0; i < pMgmtInf->GetNumberOfRegisteredCommands(); i++)
    {
        // don't print help for the help command
        if ( 0 == _strnicmp(pMgmtInf->m_pCmdList[i].szCmdName, argv[0], pMgmtInf->m_pCmdList[i].dwCmdNameLen) )
        {
            continue;
        }
            
        if ( NULL == pMgmtInf->m_pCmdList[i].szCmdHelp )
        {
            _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
                      "  %s\r\n",
                      pMgmtInf->m_pCmdList[i].szCmdName);
        }
        else
        {
            _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
                      "  %s %s\r\n",
                      pMgmtInf->m_pCmdList[i].szCmdName,
                      pMgmtInf->m_pCmdList[i].szCmdHelp);
        }
        
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);
    }
    
    // perform the response

    return hr;
}


//------------------------------------------------------------------------------
//  CXMgmtControlCallback Implementation.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//  ParseArgList:  Parses the arguements and calls the correct register function.
//     Code from BaseProvider.cpp
//------------------------------------------------------------------------------
HRESULT CXMgmtControlCallback::ParseArgList(
    IN  LPCSTR pszRequest,
    OUT DWORD *pdwArgc,
    OUT LPCSTR **ppArgv
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;

    if ( NULL == pdwArgc || NULL == ppArgv )
    {
        return E_INVALIDARG;
    }
    
    // initialize return params
    *pdwArgc = 0;
    *ppArgv = NULL;
    
    // parse the request into separate arguments
    DWORD dwCmdTextSize = strlen(pszRequest) + 1;
    LPSTR pszCmdText = (LPSTR)XAlloc(dwCmdTextSize);
    if ( NULL == pszCmdText )
    {
        XomNtEvent(XEVENT_UDPADPT_GENERIC_ERROR_3, "CXMgmtControlCallback::ParseArgList: Failed to allocate %d bytes.", strlen(pszRequest));
        XomTrace(XMGMT, L_ERROR, "CXMgmtControlCallback::ParseArgList: Failed to allocate %d bytes.",  strlen(pszRequest));
        
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    ZeroMemory(pszCmdText, dwCmdTextSize);
    
    // get rid of leading, trailing, and extra whitespace
    LPCSTR src = pszRequest;
    LPSTR dst = pszCmdText;

    // advance past any leading whitespace
    while ( *src && isspace(*src) )
        src++;

    // copy cmd string eliminating any extra whitespace and putting NUL chars
    // between the arguments
    while ( *src )
    {
        if ( '"' == *src )
        {
            src++;
            while ( *src && '"' != *src )
            {
                *dst++ = *src++;
            }
            
            if ( '"' != *src )
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
            
            // skip any whitespace after the "
            while ( isspace(*++src) )
                ;
            
            *dst++ = '\0';
            dwArgc++;
            continue;
        }

        *dst = *src;

        if ( isspace(*src) )
        {
            *dst = '\0';
            dwArgc++;
            src++;
            while ( *src && isspace(*src) )
            {
                src++;
            }
        }
        else
        {
            src++;
        }
        dst++;
    }

    // if the last character copied wasn't whitespace, increment arg count
    if ( src > pszRequest && !isspace(*(src-1)) && '"' != *(src-1) )
    {
        dwArgc++;
    }
    
    // remove any trailing spaces
    dst = pszCmdText + strlen(pszCmdText) - 1;
    while (*dst && isspace(*dst))
    {
        dst--;
    }

    // allocate and assign the argument list
    if ( dwArgc > 0 )
    {
        DWORD dwSize = dwArgc * sizeof(pArgv[0]);
        DWORD i = 0;
        DWORD j = 0;
        LPCSTR pArg = NULL;
        
        pArgv = (LPCSTR*)XAlloc(dwSize);
        if ( NULL == pArgv )
        {
            XomNtEvent(XEVENT_UDPADPT_GENERIC_ERROR_4, "CXMgmtControlCallback::ParseArgList: failed to allocate %d bytes.", dwSize);
            XomTrace(XMGMT, L_ERROR, "CXMgmtControlCallback::ParseArgList: failed to allocate %d bytes.", dwSize);

            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pArgv, dwSize);

        pArg = pszCmdText;
        for ( i=0; i < dwArgc; i++ )
        {
            pArgv[i] = pArg;
            pArg = pArg + strlen(pArg) + 1;
        }
    }

    if ( !FAILED(hr) )
    {
        *pdwArgc = dwArgc;
        *ppArgv = pArgv;
    }

Exit:
    return hr;
}


//------------------------------------------------------------------------------
//  OnControlRequest:  Called when cmd received through XMGMT stuff.
//     Code from BaseProvider.cpp
//------------------------------------------------------------------------------
HRESULT CXMgmtControlCallback::OnControlRequest(
    IN  LPCSTR pszRequest,
    IN  DWORD dwRequestId,
    IN  CXomControlResponseInterface* pResponseInterface
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;
    DWORD i = 0;

    XOMASSERT( m_pMgmtInterface != NULL );

    hr = ParseArgList(pszRequest, &dwArgc, &pArgv);
    if ( FAILED(hr) )
    {
        CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "CXMgmtControlCallback::OnControlRequest: failed with hr = 0x%08X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
    }
    
    for ( i=0; i < m_pMgmtInterface->GetNumberOfRegisteredCommands(); i++ )
    {
        if ( 0 == _strnicmp(pszRequest, m_pMgmtInterface->m_pCmdList[i].szCmdName, m_pMgmtInterface->m_pCmdList[i].dwCmdNameLen) )
        {
            hr = (*(m_pMgmtInterface->m_pCmdList[i].pfnCmdProc))(
                    m_pMgmtInterface->m_pCmdList[i].lpData,
                    m_pMgmtInterface,
                    dwRequestId,
                    pResponseInterface,
                    dwArgc,
                    pArgv
                    );

            
            if ( FAILED(hr) )
            {
                CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
                _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "%s: failed with hr = 0x%08X.\r\n", m_pMgmtInterface->m_pCmdList[i].szCmdName, hr);
                pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
            }
            
            break;
        }
    }

    if ( pArgv )
    {
        if ( pArgv[0] )
        {
            XFree((LPVOID)pArgv[0]);
            pArgv[0] = NULL;
        }
        
        XFree((LPVOID)pArgv);
        pArgv = 0;
        dwArgc = 0;
    }
    
    return hr;
}


//------------------------------------------------------------------------------
//  Local Function Implementation
//------------------------------------------------------------------------------
 
//------------------------------------------------------------------
//  StringToTime:  Basic breakdown of an hours, minutes seconds
//          string into a value for hours, minutes and seconds.
//          FORMAT:  All seconds values are followed by s
//                   All minute values are followed by m
//                   All hour values are followed by h
//          Returns fales for invalid params.
//------------------------------------------------------------------
BOOL StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutes, DWORD *pdwSeconds )
{
    int nStrSize = 0;
    BOOL bRes = TRUE;                                   // result value.
    int nCurValSize = 0;
    char *szPos = NULL;
    char *szStart = NULL;

    // ensure values.
    if ( szTimeStr == NULL || 
         pdwHours == NULL  || 
         pdwMinutes == NULL || 
         pdwSeconds == NULL )
    {
        bRes = FALSE;
        goto CleanUp;
    }

    // get the size of the time string.
    nStrSize = (int)strlen( szTimeStr );

    // set up values for scan
    szPos = (char*)szTimeStr;
    szStart = szPos;
    nCurValSize = 0;
    *pdwHours = 0;
    *pdwMinutes = 0;
    *pdwSeconds = 0;

    // scan the string and get what we want
    while ( *szPos != '\0' )
    {        
        if ( *szPos >= '0' && *szPos <= '9'  )
        {
            nCurValSize++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 's' || *szPos == 'S' ) )
        {
            *szPos = '\0';
            *pdwSeconds = atoi(szStart);
            *szPos = 's';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 'h' || *szPos == 'H' ) )
        {
            *szPos = '\0';
            *pdwHours = atoi(szStart);
            *szPos = 'h';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 'm' || *szPos == 'M' ) )
        {
            *szPos = '\0';
            *pdwMinutes = atoi(szStart);
            *szPos = 'm';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else
        {
            // I don't know what's in this buffer... just keep moving.
            szStart = szPos;
            szStart++;
            nCurValSize = 0;
        }
        szPos++;
    }

    // we got some value but we dont' know what  ... assume it means seconds.
    if ( nCurValSize > 0 )
    {
        *pdwSeconds = atoi(szStart);
    }

CleanUp:
    return bRes;

}

//------------------------------------------------------------------
// StringToLowerCase: Change string to lower case.
//------------------------------------------------------------------
void StringToLowerCase( char *szResult, char *szSrc, DWORD dwSrcSize )
{
    DWORD dwX = 0;
    XOMASSERT( szResult != NULL );
    XOMASSERT( szSrc != NULL );

    // for each element in szSrc
    for ( dwX = 0; dwX < dwSrcSize; dwX++ )
    {
        szResult[dwX] = (char)tolower((int)szSrc[dwX]);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// NetworkReader.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\YellowDoor\Server\ToolsMgmtProxy.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace YellowDoor.ToolsMgmtProxy {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ToolsMgmtSoap", Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ToolsMgmt : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetActionTableOperationCompleted;
        
        private System.Threading.SendOrPostCallback BeginWorkOperationCompleted;
        
        private System.Threading.SendOrPostCallback WorkFilesReadyOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetWorkStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddActionOperationCompleted;
        
        private System.Threading.SendOrPostCallback ExecuteJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetJobStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetActionStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetActionResultOperationCompleted;
        
        private System.Threading.SendOrPostCallback CleanupJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetJobLogOperationCompleted;
        
        /// <remarks/>
        public ToolsMgmt() {
            this.Url = "http://paulram002:12000/wctoolsmgmt/toolsmgmt.asmx";
        }
        
        /// <remarks/>
        public event GetActionTableCompletedEventHandler GetActionTableCompleted;
        
        /// <remarks/>
        public event BeginWorkCompletedEventHandler BeginWorkCompleted;
        
        /// <remarks/>
        public event WorkFilesReadyCompletedEventHandler WorkFilesReadyCompleted;
        
        /// <remarks/>
        public event GetWorkStatusCompletedEventHandler GetWorkStatusCompleted;
        
        /// <remarks/>
        public event CreateJobCompletedEventHandler CreateJobCompleted;
        
        /// <remarks/>
        public event AddActionCompletedEventHandler AddActionCompleted;
        
        /// <remarks/>
        public event ExecuteJobCompletedEventHandler ExecuteJobCompleted;
        
        /// <remarks/>
        public event CancelJobCompletedEventHandler CancelJobCompleted;
        
        /// <remarks/>
        public event GetJobStatusCompletedEventHandler GetJobStatusCompleted;
        
        /// <remarks/>
        public event GetActionStatusCompletedEventHandler GetActionStatusCompleted;
        
        /// <remarks/>
        public event GetActionResultCompletedEventHandler GetActionResultCompleted;
        
        /// <remarks/>
        public event CleanupJobCompletedEventHandler CleanupJobCompleted;
        
        /// <remarks/>
        public event GetJobLogCompletedEventHandler GetJobLogCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionTable", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetActionTable() {
            object[] results = this.Invoke("GetActionTable", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionTable(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionTable", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetActionTable(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionTableAsync() {
            this.GetActionTableAsync(null);
        }
        
        /// <remarks/>
        public void GetActionTableAsync(object userState) {
            if ((this.GetActionTableOperationCompleted == null)) {
                this.GetActionTableOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionTableOperationCompleted);
            }
            this.InvokeAsync("GetActionTable", new object[0], this.GetActionTableOperationCompleted, userState);
        }
        
        private void OnGetActionTableOperationCompleted(object arg) {
            if ((this.GetActionTableCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionTableCompleted(this, new GetActionTableCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/BeginWork", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public BeginWorkResult BeginWork(BeginWorkInfo bwi) {
            object[] results = this.Invoke("BeginWork", new object[] {
                        bwi});
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBeginWork(BeginWorkInfo bwi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BeginWork", new object[] {
                        bwi}, callback, asyncState);
        }
        
        /// <remarks/>
        public BeginWorkResult EndBeginWork(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public void BeginWorkAsync(BeginWorkInfo bwi) {
            this.BeginWorkAsync(bwi, null);
        }
        
        /// <remarks/>
        public void BeginWorkAsync(BeginWorkInfo bwi, object userState) {
            if ((this.BeginWorkOperationCompleted == null)) {
                this.BeginWorkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBeginWorkOperationCompleted);
            }
            this.InvokeAsync("BeginWork", new object[] {
                        bwi}, this.BeginWorkOperationCompleted, userState);
        }
        
        private void OnBeginWorkOperationCompleted(object arg) {
            if ((this.BeginWorkCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BeginWorkCompleted(this, new BeginWorkCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/WorkFilesReady", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public WorkFilesReadyResult WorkFilesReady(WorkFilesReadyInfo wfri) {
            object[] results = this.Invoke("WorkFilesReady", new object[] {
                        wfri});
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWorkFilesReady(WorkFilesReadyInfo wfri, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WorkFilesReady", new object[] {
                        wfri}, callback, asyncState);
        }
        
        /// <remarks/>
        public WorkFilesReadyResult EndWorkFilesReady(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public void WorkFilesReadyAsync(WorkFilesReadyInfo wfri) {
            this.WorkFilesReadyAsync(wfri, null);
        }
        
        /// <remarks/>
        public void WorkFilesReadyAsync(WorkFilesReadyInfo wfri, object userState) {
            if ((this.WorkFilesReadyOperationCompleted == null)) {
                this.WorkFilesReadyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWorkFilesReadyOperationCompleted);
            }
            this.InvokeAsync("WorkFilesReady", new object[] {
                        wfri}, this.WorkFilesReadyOperationCompleted, userState);
        }
        
        private void OnWorkFilesReadyOperationCompleted(object arg) {
            if ((this.WorkFilesReadyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WorkFilesReadyCompleted(this, new WorkFilesReadyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetWorkStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetWorkStatusResult GetWorkStatus(GetWorkStatusInfo gwsi) {
            object[] results = this.Invoke("GetWorkStatus", new object[] {
                        gwsi});
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetWorkStatus(GetWorkStatusInfo gwsi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetWorkStatus", new object[] {
                        gwsi}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetWorkStatusResult EndGetWorkStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public void GetWorkStatusAsync(GetWorkStatusInfo gwsi) {
            this.GetWorkStatusAsync(gwsi, null);
        }
        
        /// <remarks/>
        public void GetWorkStatusAsync(GetWorkStatusInfo gwsi, object userState) {
            if ((this.GetWorkStatusOperationCompleted == null)) {
                this.GetWorkStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetWorkStatusOperationCompleted);
            }
            this.InvokeAsync("GetWorkStatus", new object[] {
                        gwsi}, this.GetWorkStatusOperationCompleted, userState);
        }
        
        private void OnGetWorkStatusOperationCompleted(object arg) {
            if ((this.GetWorkStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetWorkStatusCompleted(this, new GetWorkStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CreateJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long CreateJob(string description, out JobInfo jobInfo) {
            object[] results = this.Invoke("CreateJob", new object[] {
                        description});
            jobInfo = ((JobInfo)(results[1]));
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateJob(string description, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateJob", new object[] {
                        description}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndCreateJob(System.IAsyncResult asyncResult, out JobInfo jobInfo) {
            object[] results = this.EndInvoke(asyncResult);
            jobInfo = ((JobInfo)(results[1]));
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void CreateJobAsync(string description) {
            this.CreateJobAsync(description, null);
        }
        
        /// <remarks/>
        public void CreateJobAsync(string description, object userState) {
            if ((this.CreateJobOperationCompleted == null)) {
                this.CreateJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateJobOperationCompleted);
            }
            this.InvokeAsync("CreateJob", new object[] {
                        description}, this.CreateJobOperationCompleted, userState);
        }
        
        private void OnCreateJobOperationCompleted(object arg) {
            if ((this.CreateJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateJobCompleted(this, new CreateJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/AddAction", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int AddAction(ActionInfo actionInfo) {
            object[] results = this.Invoke("AddAction", new object[] {
                        actionInfo});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddAction(ActionInfo actionInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddAction", new object[] {
                        actionInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndAddAction(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void AddActionAsync(ActionInfo actionInfo) {
            this.AddActionAsync(actionInfo, null);
        }
        
        /// <remarks/>
        public void AddActionAsync(ActionInfo actionInfo, object userState) {
            if ((this.AddActionOperationCompleted == null)) {
                this.AddActionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddActionOperationCompleted);
            }
            this.InvokeAsync("AddAction", new object[] {
                        actionInfo}, this.AddActionOperationCompleted, userState);
        }
        
        private void OnAddActionOperationCompleted(object arg) {
            if ((this.AddActionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddActionCompleted(this, new AddActionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/ExecuteJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ExecuteJob(long jobId) {
            object[] results = this.Invoke("ExecuteJob", new object[] {
                        jobId});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExecuteJob(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExecuteJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndExecuteJob(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ExecuteJobAsync(long jobId) {
            this.ExecuteJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void ExecuteJobAsync(long jobId, object userState) {
            if ((this.ExecuteJobOperationCompleted == null)) {
                this.ExecuteJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExecuteJobOperationCompleted);
            }
            this.InvokeAsync("ExecuteJob", new object[] {
                        jobId}, this.ExecuteJobOperationCompleted, userState);
        }
        
        private void OnExecuteJobOperationCompleted(object arg) {
            if ((this.ExecuteJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExecuteJobCompleted(this, new ExecuteJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CancelJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CancelJob(long jobId) {
            this.Invoke("CancelJob", new object[] {
                        jobId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelJob(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelJob(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CancelJobAsync(long jobId) {
            this.CancelJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void CancelJobAsync(long jobId, object userState) {
            if ((this.CancelJobOperationCompleted == null)) {
                this.CancelJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelJobOperationCompleted);
            }
            this.InvokeAsync("CancelJob", new object[] {
                        jobId}, this.CancelJobOperationCompleted, userState);
        }
        
        private void OnCancelJobOperationCompleted(object arg) {
            if ((this.CancelJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelJobCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetJobStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public JobState GetJobStatus(long jobId) {
            object[] results = this.Invoke("GetJobStatus", new object[] {
                        jobId});
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetJobStatus(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetJobStatus", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public JobState EndGetJobStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public void GetJobStatusAsync(long jobId) {
            this.GetJobStatusAsync(jobId, null);
        }
        
        /// <remarks/>
        public void GetJobStatusAsync(long jobId, object userState) {
            if ((this.GetJobStatusOperationCompleted == null)) {
                this.GetJobStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetJobStatusOperationCompleted);
            }
            this.InvokeAsync("GetJobStatus", new object[] {
                        jobId}, this.GetJobStatusOperationCompleted, userState);
        }
        
        private void OnGetJobStatusOperationCompleted(object arg) {
            if ((this.GetJobStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetJobStatusCompleted(this, new GetJobStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public JobState GetActionStatus(long jobId, int rank) {
            object[] results = this.Invoke("GetActionStatus", new object[] {
                        jobId,
                        rank});
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionStatus(long jobId, int rank, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionStatus", new object[] {
                        jobId,
                        rank}, callback, asyncState);
        }
        
        /// <remarks/>
        public JobState EndGetActionStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionStatusAsync(long jobId, int rank) {
            this.GetActionStatusAsync(jobId, rank, null);
        }
        
        /// <remarks/>
        public void GetActionStatusAsync(long jobId, int rank, object userState) {
            if ((this.GetActionStatusOperationCompleted == null)) {
                this.GetActionStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionStatusOperationCompleted);
            }
            this.InvokeAsync("GetActionStatus", new object[] {
                        jobId,
                        rank}, this.GetActionStatusOperationCompleted, userState);
        }
        
        private void OnGetActionStatusOperationCompleted(object arg) {
            if ((this.GetActionStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionStatusCompleted(this, new GetActionStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionResult", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ActionResult GetActionResult(long jobId, int rank) {
            object[] results = this.Invoke("GetActionResult", new object[] {
                        jobId,
                        rank});
            return ((ActionResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionResult(long jobId, int rank, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionResult", new object[] {
                        jobId,
                        rank}, callback, asyncState);
        }
        
        /// <remarks/>
        public ActionResult EndGetActionResult(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ActionResult)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionResultAsync(long jobId, int rank) {
            this.GetActionResultAsync(jobId, rank, null);
        }
        
        /// <remarks/>
        public void GetActionResultAsync(long jobId, int rank, object userState) {
            if ((this.GetActionResultOperationCompleted == null)) {
                this.GetActionResultOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionResultOperationCompleted);
            }
            this.InvokeAsync("GetActionResult", new object[] {
                        jobId,
                        rank}, this.GetActionResultOperationCompleted, userState);
        }
        
        private void OnGetActionResultOperationCompleted(object arg) {
            if ((this.GetActionResultCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionResultCompleted(this, new GetActionResultCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CleanupJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool CleanupJob(ulong jobId) {
            object[] results = this.Invoke("CleanupJob", new object[] {
                        jobId});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCleanupJob(ulong jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CleanupJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndCleanupJob(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void CleanupJobAsync(ulong jobId) {
            this.CleanupJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void CleanupJobAsync(ulong jobId, object userState) {
            if ((this.CleanupJobOperationCompleted == null)) {
                this.CleanupJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCleanupJobOperationCompleted);
            }
            this.InvokeAsync("CleanupJob", new object[] {
                        jobId}, this.CleanupJobOperationCompleted, userState);
        }
        
        private void OnCleanupJobOperationCompleted(object arg) {
            if ((this.CleanupJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CleanupJobCompleted(this, new CleanupJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetJobLog", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetJobLog(int jobId, out JobLogEntry[] jobLog) {
            object[] results = this.Invoke("GetJobLog", new object[] {
                        jobId});
            jobLog = ((JobLogEntry[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetJobLog(int jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetJobLog", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetJobLog(System.IAsyncResult asyncResult, out JobLogEntry[] jobLog) {
            object[] results = this.EndInvoke(asyncResult);
            jobLog = ((JobLogEntry[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetJobLogAsync(int jobId) {
            this.GetJobLogAsync(jobId, null);
        }
        
        /// <remarks/>
        public void GetJobLogAsync(int jobId, object userState) {
            if ((this.GetJobLogOperationCompleted == null)) {
                this.GetJobLogOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetJobLogOperationCompleted);
            }
            this.InvokeAsync("GetJobLog", new object[] {
                        jobId}, this.GetJobLogOperationCompleted, userState);
        }
        
        private void OnGetJobLogOperationCompleted(object arg) {
            if ((this.GetJobLogCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetJobLogCompleted(this, new GetJobLogCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class BeginWorkInfo {
        
        private uint workTypeField;
        
        private string titleIdField;
        
        /// <remarks/>
        public uint workType {
            get {
                return this.workTypeField;
            }
            set {
                this.workTypeField = value;
            }
        }
        
        /// <remarks/>
        public string titleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class JobLogEntry {
        
        private System.DateTime loggedField;
        
        private int levelField;
        
        private string logField;
        
        /// <remarks/>
        public System.DateTime logged {
            get {
                return this.loggedField;
            }
            set {
                this.loggedField = value;
            }
        }
        
        /// <remarks/>
        public int level {
            get {
                return this.levelField;
            }
            set {
                this.levelField = value;
            }
        }
        
        /// <remarks/>
        public string log {
            get {
                return this.logField;
            }
            set {
                this.logField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ActionResult {
        
        private JobState stateField;
        
        private int returnCodeField;
        
        private string consoleOutputField;
        
        /// <remarks/>
        public JobState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public int returnCode {
            get {
                return this.returnCodeField;
            }
            set {
                this.returnCodeField = value;
            }
        }
        
        /// <remarks/>
        public string consoleOutput {
            get {
                return this.consoleOutputField;
            }
            set {
                this.consoleOutputField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public enum JobState {
        
        /// <remarks/>
        Created,
        
        /// <remarks/>
        Pending,
        
        /// <remarks/>
        Download,
        
        /// <remarks/>
        Running,
        
        /// <remarks/>
        Canceled,
        
        /// <remarks/>
        Complete,
        
        /// <remarks/>
        Failed,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class Parameter {
        
        private string nameField;
        
        private string valueField;
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ActionInfo {
        
        private long jobIdField;
        
        private string toolFileNameField;
        
        private Parameter[] parametersField;
        
        private string[] filesField;
        
        /// <remarks/>
        public long jobId {
            get {
                return this.jobIdField;
            }
            set {
                this.jobIdField = value;
            }
        }
        
        /// <remarks/>
        public string toolFileName {
            get {
                return this.toolFileNameField;
            }
            set {
                this.toolFileNameField = value;
            }
        }
        
        /// <remarks/>
        public Parameter[] parameters {
            get {
                return this.parametersField;
            }
            set {
                this.parametersField = value;
            }
        }
        
        /// <remarks/>
        public string[] files {
            get {
                return this.filesField;
            }
            set {
                this.filesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class JobInfo {
        
        private long jobIdField;
        
        private ulong spaceAvailableField;
        
        private string uploadPathField;
        
        /// <remarks/>
        public long jobId {
            get {
                return this.jobIdField;
            }
            set {
                this.jobIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong spaceAvailable {
            get {
                return this.spaceAvailableField;
            }
            set {
                this.spaceAvailableField = value;
            }
        }
        
        /// <remarks/>
        public string uploadPath {
            get {
                return this.uploadPathField;
            }
            set {
                this.uploadPathField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class GetWorkStatusResult {
        
        private bool workCompleteField;
        
        private int returnCodeField;
        
        private string consoleOutputField;
        
        /// <remarks/>
        public bool workComplete {
            get {
                return this.workCompleteField;
            }
            set {
                this.workCompleteField = value;
            }
        }
        
        /// <remarks/>
        public int returnCode {
            get {
                return this.returnCodeField;
            }
            set {
                this.returnCodeField = value;
            }
        }
        
        /// <remarks/>
        public string consoleOutput {
            get {
                return this.consoleOutputField;
            }
            set {
                this.consoleOutputField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class GetWorkStatusInfo {
        
        private ulong workIdField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class WorkFilesReadyResult {
        
        private bool successField;
        
        /// <remarks/>
        public bool success {
            get {
                return this.successField;
            }
            set {
                this.successField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class WorkFilesReadyInfo {
        
        private ulong workIdField;
        
        private string relativePathField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
        
        /// <remarks/>
        public string relativePath {
            get {
                return this.relativePathField;
            }
            set {
                this.relativePathField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class BeginWorkResult {
        
        private ulong workIdField;
        
        private ulong spaceAvailableField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong spaceAvailable {
            get {
                return this.spaceAvailableField;
            }
            set {
                this.spaceAvailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionTableCompletedEventHandler(object sender, GetActionTableCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionTableCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionTableCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BeginWorkCompletedEventHandler(object sender, BeginWorkCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BeginWorkCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BeginWorkCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public BeginWorkResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((BeginWorkResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WorkFilesReadyCompletedEventHandler(object sender, WorkFilesReadyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WorkFilesReadyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WorkFilesReadyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public WorkFilesReadyResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WorkFilesReadyResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetWorkStatusCompletedEventHandler(object sender, GetWorkStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetWorkStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetWorkStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetWorkStatusResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetWorkStatusResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateJobCompletedEventHandler(object sender, CreateJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public JobInfo jobInfo {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobInfo)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddActionCompletedEventHandler(object sender, AddActionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddActionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddActionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ExecuteJobCompletedEventHandler(object sender, ExecuteJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ExecuteJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ExecuteJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelJobCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetJobStatusCompletedEventHandler(object sender, GetJobStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetJobStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetJobStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public JobState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionStatusCompletedEventHandler(object sender, GetActionStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public JobState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionResultCompletedEventHandler(object sender, GetActionResultCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionResultCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionResultCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ActionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ActionResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CleanupJobCompletedEventHandler(object sender, CleanupJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CleanupJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CleanupJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetJobLogCompletedEventHandler(object sender, GetJobLogCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetJobLogCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetJobLogCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public JobLogEntry[] jobLog {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobLogEntry[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\UAPerfCtrs.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Udp Adaptor Service (UA) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: UAPerfCtrs.cpp
//
//  Implementation for the perf counter class.
//-----------------------------------------------------------------------------

#include "UAPerfCtrs.h"
#include "UAPerf.h"
#include "perfapi.h"


enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    BYTE *pbPerfCtrData;
};

#define NUM_SERVER_PERF_COUNTERS    12

#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, NULL }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, NULL }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, NULL }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, NULL }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, NULL }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, NULL }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, NULL }


//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs[ NUM_SERVER_PERF_COUNTERS ] =
{
    DWORD_RATE   ( UA_REQUESTS_PER_SEC_COUNTER               ),
    QWORD_COUNTER( UA_REQUESTS_COUNTER                       ),
    DWORD_RATE   ( UA_FAILED_REQUESTS_PER_SEC_COUNTER        ),
    QWORD_COUNTER( UA_FAILED_REQUESTS_COUNTER                ),
    DWORD_RATE   ( UA_INVALID_HTTP_PAYLOADS_PER_SEC_COUNTER  ),
    QWORD_COUNTER( UA_INVALID_HTTP_PAYLOADS_REQUESTS_COUNTER ),
    DWORD_RATE   ( UA_FAILED_HTTP_REQUESTS_PER_SEC_COUNTER   ),
    QWORD_COUNTER( UA_FAILED_HTTP_REQUESTS_COUNTER           ),
    DWORD_RATE   ( UA_FAILED_UDP_REPLIES_PER_SEC_COUNTER     ),
    QWORD_COUNTER( UA_FAILED_UDP_REPLIES_COUNTER             ),
    DWORD_RATE   ( UA_SUCCESSFUL_REPLIES_PER_SEC_COUNTER     ),
    QWORD_COUNTER( UA_SUCCESSFUL_UDP_REPLIES_COUNTER         ),
};


//////////////////////////////////////////////////////////////////////////////
CPERFCounters::CPERFCounters() :
    m_hServerPerfObj( NULL )
{
}


//////////////////////////////////////////////////////////////////////////////
CPERFCounters::~CPERFCounters()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CPERFCounters::Init()
{
    HRESULT hr;
    
    do
    {
        //
        // Create the server perf object and associated counters
        //
        BYTE *pbServCtrsStart = NULL;

        assert( NULL == m_hServerPerfObj );

        m_hServerPerfObj = CreatePerfObject(
                                    UA_SERVER_OBJECT,
                                    0,
                                    (void **) &pbServCtrsStart );

        if( NULL == m_hServerPerfObj )
        {
            hr = E_UNEXPECTED;
            break;
        }

        for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
        {
            DWORD dwCounterDataOffset = CreatePerfCounter(
                                                s_ServerPerfCtrs[ dwCtr ].dwPerfType,
                                                0,       // dwScale
                                                s_ServerPerfCtrs[ dwCtr ].dwDataSize,
                                                m_hServerPerfObj,
                                                s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
                                                NULL );

            assert( 0xffffffff != dwCounterDataOffset );

            s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData = pbServCtrsStart + dwCounterDataOffset;

            //
            // Zero every counter on startup
            //
            ZeroMemory(
                s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData,
                s_ServerPerfCtrs[ dwCtr ].dwDataSize );
        }
    
        hr = S_OK;
    }
    while( FALSE );
    
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CPERFCounters::GetCurrentValue32( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    return( *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::SetCurrentValue32(
                                    DWORD dwCounterID,
                                    DWORD dwVal )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchange(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        (LONG) dwVal );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::IncrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchangeAdd(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        (LONG) dwAmount );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::DecrementValue32(
                                    DWORD dwCounterID,
                                    DWORD dwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    InterlockedExchangeAdd(
        (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
        - (LONG) dwAmount );
}


//////////////////////////////////////////////////////////////////////////////
QWORD CPERFCounters::GetCurrentValue64( DWORD dwCounterID )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    return( *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::SetCurrentValue64(
                                    DWORD dwCounterID,
                                    QWORD qwVal )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwVal;
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::IncrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;
    
    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += qwAmount;
}


//////////////////////////////////////////////////////////////////////////////
void CPERFCounters::DecrementValue64(
                                    DWORD dwCounterID,
                                    QWORD qwAmount )
{
    DWORD dwCounterIndex = ( ( dwCounterID - UA_SERVER_OBJECT ) / 2 ) - 1;

    assert( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    assert( XQPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= qwAmount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\UAMain.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Udp Adaptor (UdpAdpt) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: UAMain.h
//
//  Interface for the main udp adaptor object (singleton)
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include <ntservice.h>
#include <XAlloc.h>
#include <cutil.h>

#include "WinHttpMgr.h"

//-----------------------------------------------------------------------------
//  Pre-Declared Classes
//-----------------------------------------------------------------------------
class CCompletionPort;
class CMgmtInterface;
class CUdpMgr;

//-----------------------------------------------------------------------------
//  Global definitions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const DWORD c_dwMaxTransmissionSize = 1452;

//-----------------------------------------------------------------------------
//  types/structures
//-----------------------------------------------------------------------------

struct UA_CONTEXT : public REQUEST_CONTEXT
{
    DWORD       _dwRefCnt;
    sockaddr_in _saFrom;

    BYTE*       _pVerb;
    BYTE*       _pObject;
    BYTE*       _pAdditionalHeaders;
    BYTE*       _pBody;

    QWORD       _qwUdpRecvId;

    DWORD       _cMsg;
    BYTE        _aMsg[c_dwMaxTransmissionSize];
    
};

//-----------------------------------------------------------------------------
//  Global functions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CUAMain Interface
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CUAMain Interface
//-----------------------------------------------------------------------------
class CUAMain : public CNTService, 
                public CWinHttpCallback
{
public:
    static CUAMain*     GetInstance();
    static void         ReleaseInstance();

    // overrides:  Initializes the service.
    virtual HRESULT     InitService( DWORD dwArgc, LPWSTR *pszArgv );

    // overrides:  run the service.
    virtual HRESULT     RunService( BOOL *pfServiceRan );

    // tells the xds its time to shutdown.
    void                Shutdown() { SetEvent( ShutdownEvent() ); }
    BOOL                IsComplete() { return m_bIsComplete; }


    //--------------------------------------------------------
    //  callbacks for winhttpmgr
    virtual LONG    AddRef();    
    virtual LONG    Release();
    virtual HRESULT OnClose( REQUEST_CONTEXT* pContext );
    virtual HRESULT OnError( REQUEST_CONTEXT* pContext, HRESULT hr, DWORD_PTR dwResult );
    virtual HRESULT OnSendRequestComplete( REQUEST_CONTEXT* pContext );
    virtual HRESULT OnHeadersAvailable( REQUEST_CONTEXT* pContext, LPVOID lpData, DWORD  cData );
    virtual HRESULT OnResponseReceived( REQUEST_CONTEXT* pContext );
    virtual HRESULT OnDataAvailable( REQUEST_CONTEXT* pContext, LPVOID lpData, DWORD  cData );
    virtual HRESULT OnReadComplete( REQUEST_CONTEXT* pContext, LPVOID lpData, DWORD  cData );

    virtual HRESULT OnSendingRequest( REQUEST_CONTEXT* pContext );
    virtual HRESULT OnRequestSent( REQUEST_CONTEXT* pContext );
    virtual HRESULT OnReceivingResponse( REQUEST_CONTEXT* pContext );


    // mgmt cmd callback.
    static HRESULT MgmtCmdShutdown(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );



    // overrides
    void *operator      new(size_t len) { return XAlloc(len); }
    void operator       delete(void *pv) { XFree(pv); }
   
protected:
    CUAMain(void);
    virtual ~CUAMain(void);

    // main program 
    HRESULT             Start();
    HRESULT             Run();
    HRESULT             Term();

    // used to keep track of packet nodes.
    void                AddRefContext( UA_CONTEXT *pNode );
    void                ReleaseContext( UA_CONTEXT *pNode );
    UA_CONTEXT*         GetContext();

    // UdpMgr Callbacks
    static HRESULT UDPMsgAlloc( LPVOID* ppBuffer, DWORD* pcBuffer );
    static HRESULT UDPMsgFree( LPVOID pBuffer );
    static HRESULT UDPPostMsg( LPVOID pBuffer, DWORD cBuffer, const sockaddr_in* psaFrom, const sockaddr_in* psaTo, QWORD qwRecvId );

    // set up mgmt callbacks.
    void InitializeCallbacks();

    // load the config.
    HRESULT             LoadConfig();

    HRESULT ConstructPortList( char *szPortList );

    // tools to read from the config.
    DWORD GetDWORDSetting( CComBSTR bstrSettingName, DWORD dwDefault );
    void GetStringSetting( LPWSTR pch, DWORD cch, CComBSTR bstrSettingName, const WCHAR *c_wszDefault );
    void GetStringSetting( LPSTR pch, DWORD cch, CComBSTR bstrSettingName, const char *c_szDefault );
    


    // attributes
    CLookAsideList      m_oContextBuffer;
    DWORD               m_dwNumOfThreads;
    CComBSTR            m_bstrIPAddr;
    CComBSTR            m_bstrPortList;

    CWinHttpMgr*        m_pWinHttpMgr;
    CUdpMgr*            m_pUdpMgr;

    DWORD               m_dwPortListSize;
    DWORD*              m_pdwPortList;
    
    // interface for mgmt stuff
    CMgmtInterface*     m_pMgmtInterface;

    // indicates whether the ua service is complete or not.
    BOOL                m_bIsComplete;
    HANDLE              m_hShutdown;                    // udpadpt shutdown handle... fired when shutdown is complete.

    CCompletionPort*    m_pCompletionPort;              // the main completion port.

    // config db interface for the KDCs.
    CComPtr<IConfig>        m_pConfig;


private:
    static CUAMain*     m_pInstance;
    static DWORD        m_dwRefCount;

#ifdef _DEBUG
public:
    HRESULT UnitTest();

    DWORD m_dwUnitTest;
#endif 

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\UAPerfCtrs.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsPerfCtrs.h
//
//  Interface for the perf counter class.
//-----------------------------------------------------------------------------
#pragma once
#include <windows.h>
#include "wmsstd.h"

//////////////////////////////////////////////////////////////////////////////
class CPERFCounters
{
public:
    CPERFCounters();
    ~CPERFCounters();

    HRESULT Init();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32( DWORD dwCounterID );

    void SetCurrentValue32( DWORD dwCounterID, DWORD dwVal );

    void IncrementValue32( DWORD dwCounterID, DWORD dwAmount );

    void DecrementValue32( DWORD dwCounterID, DWORD dwAmount );

    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64( DWORD dwCounterID );

    void SetCurrentValue64( DWORD dwCounterID, QWORD qwVal );

    void IncrementValue64( DWORD dwCounterID, QWORD qwAmount );

    void DecrementValue64( DWORD dwCounterID, QWORD qwAmount );

private:
    HANDLE m_hServerPerfObj;
};

extern CPERFCounters g_Counters;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once
#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <windows.h>

#include <wsockntp.h>
#include <Iphlpapi.h>

#include <xonlinep.h>
#include <winsock2.h>
#include <xmgmt.h>
#include <xeventids.h>
#include "xalloc.h"
#include <xlocks.h>
#include "addref.h"

#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>
#include <atlsafe.h>
#include <atlconv.h>
using namespace ATL;

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;
#include <commonconfig.h>

#ifndef ASSERT
#define ASSERT XOMASSERT
#endif

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x)/sizeof(x[0]))
#endif

using namespace xlocks;

#ifdef _DEBUG
XomImportArea(UNITTEST);

//-----------------------------------------------------------------------------
//  Unit Test  -- Definitions
//-----------------------------------------------------------------------------
#define SUCCESS_UT(x) XomTrace( UNITTEST, L_NORMAL, "UnitTest Successful %s", x )
#define FAIL_UT(x) { XomTrace( UNITTEST, L_NORMAL, "UnitTest Failed %s", x ); hr = E_FAIL; goto Exit; }
#endif

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\UAMain.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox UDP adaptor (UA) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: UAMain.cpp
//
//  Implementation of the main udp adaptor object.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

#include "UAMain.h"
#include "MgmtInterface.h"

#include "UAPerfCtrs.h"
#include "UAPerf.h"
#include "UDPMgr.h"
#include "WinHttpMgr.h"

#include "XAlloc.h"

#include <atlbase.h>

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
XomImportArea(UDPADAPT);
XomImportArea(UDPADPTLog);

//-----------------------------------------------------------------------------
//  Static Declarations
//-----------------------------------------------------------------------------
CUAMain* CUAMain::m_pInstance = NULL;
DWORD    CUAMain::m_dwRefCount = 0;

CNTService* g_pService = NULL;

CPERFCounters g_Counters;

//-----------------------------------------------------------------------------
//  Pre-Declarations for local functions
//-----------------------------------------------------------------------------
void    GetXOMSetting( char** pszValue, const char *c_szArea, const char *c_szDefault );
void    GetXOMSetting( WCHAR** pwszValue, const char *c_szArea, const WCHAR *c_wszDefault );
void    GetXOMSetting( DWORD* pdwValue, const char *c_szArea, DWORD c_dwDefault );

BOOL    IsPrintable( BYTE *pbArr, DWORD cbArr );
BOOL    IsNumericASCII( BYTE *pbArr, DWORD cbArr );
void    MakePresentableOutput( char *szName, DWORD dwNameSize, char *pszSrc );


//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const XomMgmtCmd c_aCmdList[] = {
    { "help",           strlen("help"),               CMgmtInterface::MgmtCmdHelp,           NULL,                                      NULL },
    { "shutdown",       strlen("shutdown"),           CUAMain::MgmtCmdShutdown,              NULL,                                      NULL },
};

const DWORD c_dwNumOfCommands               = ARRAY_ELEMENTS(c_aCmdList);
    
// used for ini file loading.
const char  c_szIp[]                        = "UdpAdpt.Ip";
const char  c_szNumOfPorts[]                = "UdpAdpt.NumberOfPorts";
const char  c_szListOfPorts[]               = "UdpAdpt.PortList";
const char  c_szNumOfThreads[]              = "UdpAdpt.NumOfThreads";


const char  c_szDefaultIp[]                 = "0.0.0.0";                
const WCHAR c_wszDefaultIp[]                = L"127.0.0.1";                
const DWORD c_dwDefaultNumOfPorts           = 1;
const char  c_szDefaultListOfPorts[]        = "8080";                
const DWORD c_dwDefaultNumberOfThreads      = 2;                

const DWORD c_ShutdownTime                  = 1200000;          // 20 seconds to free memory and shut down.

const WCHAR c_szServiceName[]               = L"UdpAdpt";
const WCHAR c_szServiceDisplayName[]        = L"Xbox Udp Adaptor";
const WCHAR c_szServiceDescription[]        = L"Xbox Udp Adaptor";
const WCHAR c_szPerfBaseName[]              = L"UAPerf";

const DWORD c_dwMaxAcceptedVerbSize         = 32;

const char  c_szAdditionalUAHeaders[]       = "%s\r\nAdaptedFromUDP: Yes\r\nSGIPPort: %d.%d.%d.%d:%d\r\n\0";

class CXAllocMemAlloc : public IMemAlloc
{
public:
    void* Alloc(size_t size)
    {
        return XAlloc(size);
    }

    void Free (void* memblock)
    {
        XFree(memblock);
    }
};

static CXAllocMemAlloc g_xAlloc;


//-----------------------------------------------------------------------------
//  CUAMain Implementation
//-----------------------------------------------------------------------------
CUAMain::CUAMain(void) : CNTService( c_szServiceName, c_szServiceDisplayName, c_szServiceDescription, c_szPerfBaseName, Component_udpadpt )
{
    m_bIsComplete = TRUE;
    m_pMgmtInterface = NULL;
    m_pWinHttpMgr = NULL;
    m_pUdpMgr = NULL;
    m_pdwPortList = NULL;
}

CUAMain::~CUAMain(void)
{
    m_bIsComplete = TRUE;
    m_pMgmtInterface = NULL;

    m_pWinHttpMgr = NULL;
    m_pUdpMgr = NULL;
}

//-----------------------------------------------------------------------------
//  GetInstance:  Gets an instance of the UA
//-----------------------------------------------------------------------------
CUAMain* CUAMain::GetInstance()
{
    if ( m_pInstance == NULL )
    {
        XOMASSERT( m_dwRefCount == 0 );
        m_pInstance = new CUAMain();
        g_pService = m_pInstance;
        if ( m_pInstance == NULL )
        {
            // not enough memory to create UA instance.
            XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_5, "CUAMain::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            XomTrace( UDPADAPT, L_ERROR, "CUAMain::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            goto Exit;
        }
    }

    InterlockedIncrement( (LPLONG)&(m_dwRefCount) );

Exit:
    return m_pInstance;
}

//-----------------------------------------------------------------------------
//  ReleaseInstance:  Releases the instance of the UA.
//-----------------------------------------------------------------------------
void CUAMain::ReleaseInstance()
{
    LONG lValue = 0;
    XOMASSERT( m_dwRefCount > 0 && m_pInstance != NULL );
    lValue = InterlockedDecrement( (LPLONG)&(m_dwRefCount) );
    if ( lValue == 0 )
    {
        delete m_pInstance;
        m_pInstance = NULL;
    }
}

//-----------------------------------------------------------------------------
//  AddRef:  Referense methods for callbacks
//-----------------------------------------------------------------------------
LONG CUAMain::AddRef()
{
    LONG lResult = InterlockedIncrement( (LPLONG)&m_dwRefCount );
    return( lResult );
}

//-----------------------------------------------------------------------------
//  Release:  Referense methods for callbacks
//-----------------------------------------------------------------------------
LONG CUAMain::Release()
{
    LONG lResult = InterlockedDecrement( (LPLONG)&m_dwRefCount );
    if( 0 == lResult )
    {
        delete m_pInstance;
        m_pInstance = NULL;
        return S_OK;
    }

    return S_FALSE;
}

//-----------------------------------------------------------------------------
//  Start:  Initializes and starts the UA service.
//-----------------------------------------------------------------------------
HRESULT CUAMain::Start()
{
    HRESULT hr = S_OK;    

    XOMASSERT( m_pMgmtInterface == NULL );
    XOMASSERT( m_bIsComplete == TRUE );
    
    if ( !m_bIsComplete )
    {
        // the UA server is already running.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_6, "CUAMain::Start:  Udp Adaptor service already started.");
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Udp Adaptor already started.");
        hr = E_FAIL;
        goto Exit;                        
    }
    
    XomTrace( UDPADAPT, L_NORMAL, "CUAMain::Start:  Starting Udp Adaptor.");
    
    //-------------------------------------------------------------
    // CONFIG
    XomTrace( UDPADAPT, L_LOW, "CUAMain::Start:  Reading config data.");
    hr = LoadConfig();
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_7, "CUAMain::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;                
    }
    
    // construct the port list.
    hr = ConstructPortList( CW2A(m_bstrPortList) );
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_8, "CUAMain::Start:  Failed to create the port list.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to create the port list.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;                
    }
    else if ( hr != S_OK )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_INVALID_PORT_LIST_WARNING, "CUAMain::Start:  Port List has more entries than expected.  Only using first %d entries.", m_dwPortListSize );
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Port List has more entries than expected.  Only using first %d entries.", m_dwPortListSize );
        goto Exit;                
    }

    // no shutdown event ... bummer.
    m_hShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( m_hShutdown == NULL ) 
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_9, "CUAMain::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;                        
    }

    //-------------------------------------------------------------
    // Initialize the perf counters
    hr = g_Counters.Init();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_UDPADPT_INIT_FAILURE, "CUAMain::Start:  Failed to initialize Perf Counters.  RESULT = 0x%X.", hr);
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to initialize Perf Counters.  RESULT = 0x%X.", hr);
        goto Exit;
    }
    
        
    //-------------------------------------------------------------
    // Initialize completion port. 
    XomTrace( UDPADAPT, L_LOW, "CUAMain::Start:  Creating the completion port.");
    hr = CCompletionPort::CreateInstance( 0, m_dwNumOfThreads, THREAD_PRIORITY_NORMAL, &m_pCompletionPort);
    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_UDPADPT_INIT_FAILURE_1, "CUAMain::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.", hr);
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.", hr);
        goto Exit;
    }

    //-------------------------------------------------------------
    //  Request Context Memory pool
    XomTrace( UDPADAPT, L_LOW, "CUAMain::Start:  Creating packet buffer object.");
    // create a new node bag.
    // @@@ TODO - Need to determine size of pool that is more reasonable.
    m_oContextBuffer.Init(sizeof( UA_CONTEXT ), 100, &g_xAlloc);
    /*
    if ( m_pContextBuffer == NULL )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_10, "CUAMain::Start:  Failed to allocated memory for the memory pool handle.  Please ensure machine has enough available RAM to run this program.");
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to allocated memory for the memory pool handle.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
    */

    //-------------------------------------------------------------
    // Mgmt Interface
    XomTrace( UDPADAPT, L_LOW, "CUAMain::Start:  Creating the XMGMT Interface.");
    // create a new mgmt interface
    m_pMgmtInterface = new CMgmtInterface();
    if ( m_pMgmtInterface == NULL )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_11, "CUAMain::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.");
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    hr = m_pMgmtInterface->Initialize( c_dwNumOfCommands );
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to initialize the Mgmt interface.  RESULT = 0x%X", hr );
        goto Exit;        
    }

    // intialize mgmt the callbacks
    InitializeCallbacks();

    // initialize the WinHttpMgr
    hr = CWinHttpMgr::CreateInstance();
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_12, "CUAMain::Start:  Failed to create WinHttpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to create WinHttpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        goto Exit;        
    }

    m_pWinHttpMgr = CWinHttpMgr::GetInstance();
    hr = m_pWinHttpMgr->Initialize((CWinHttpCallback*)this);
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_WINHTTP_ERROR, "CUAMain::Start:  Failed to initialize WinHttpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to initialize WinHttpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        goto Exit;        
    }

    // initialize the CUdpMgr
    hr = CUdpMgr::CreateInstance();
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_13, "CUAMain::Start:  Failed to create UdpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to create UdpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        goto Exit;        
    }
    
    // setup the UDP Mgr.
    m_pUdpMgr = CUdpMgr::GetInstance();
    hr = m_pUdpMgr->Initialize( CW2A(m_bstrIPAddr), 
                                m_pdwPortList, 
                                m_dwPortListSize,
                                m_pCompletionPort, 
                                (MemAlloc)(UDPMsgAlloc), 
                                (MemFree)(UDPMsgFree), 
                                (MsgPostHandle)(UDPPostMsg));
    if ( FAILED(hr) )
    {
        // not enough memory to create UA instance.
        XomNtEvent( XEVENT_UDPADPT_UDPMGR_ERROR, "CUAMain::Start:  Failed to initialize UdpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::Start:  Failed to initialize UdpMgr interface.  Please ensure this machine has the correct setup.  hr=0x%X", hr );
        goto Exit;        
    }
    

    XomNtEvent( XEVENT_UDPADPT_INIT_SUCCESS, "CUAMain::Start:  Successfully started UA.");
    XomTrace( UDPADAPT, L_NORMAL, "CUAMain::Start:  Successfully started UA.");
    m_bIsComplete = FALSE;

Exit:
    if ( m_pdwPortList )
    {
        // we don't need the port list anymore.
        XFree( m_pdwPortList );
        m_pdwPortList = NULL;
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
//  Run:  runs until everything is quit.
//-----------------------------------------------------------------------------
HRESULT CUAMain::Run()
{
    HRESULT hr = S_OK;

    if ( m_bIsComplete == TRUE )
    {
        goto Exit;
    }
    
    WaitForSingleObject( ShutdownEvent(), INFINITE );

Exit:    
    return hr;
}

//-----------------------------------------------------------------------------
//  Term:  Termintates UA service.
//-----------------------------------------------------------------------------
HRESULT CUAMain::Term()
{
    HRESULT hr = S_OK;


    XOMASSERT( m_pMgmtInterface != NULL);
    XOMASSERT( m_pCompletionPort != NULL );

    //-----
    
    // blow away the completion port
    if ( m_pCompletionPort )
    {
        m_pCompletionPort->Shutdown();        
        hr = m_pCompletionPort->Release();
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_14, "CUAMain::RunService:  We experienced troubles release down the completion port.  RESULT = 0x%X", hr );
            XomTrace( UDPADAPT, L_ERROR, "CUAMain::RunService:  We experienced troubles release down the completion port.  RESULT = 0x%X", hr );
        }

        m_pCompletionPort = NULL;
    }

    // Mgmt Interface
    if ( m_pMgmtInterface )
    {
        delete m_pMgmtInterface;
        m_pMgmtInterface = NULL;
    }

    // TODO:  Shutdown the UDPMgr here.
            
    m_bIsComplete = TRUE;

    // blow away the list of ports.
    
    XomNtEvent( XEVENT_UDPADPT_TERM_SUCCESS ,"CUAMain::Term:  Successfully terminated UA service.");
    XomTrace( UDPADAPT, L_NORMAL ,"CUAMain::Term:  Successfully terminated UA service.");

    return hr;
}


//-----------------------------------------------------------------------------
//  InitService:  initialize the UA service
//      overrides:  Initializes the service.
//-----------------------------------------------------------------------------
HRESULT CUAMain::InitService( DWORD dwArgc, LPWSTR *pszArgv )
{
    return Start();
}

//-----------------------------------------------------------------------------
//  InitService:  initialize the UA service
//      overrides:  run the service.
//-----------------------------------------------------------------------------
HRESULT CUAMain::RunService( BOOL *pfServiceRan )
{
    HRESULT hr = S_OK;
    
    hr = Run();
    if ( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_UDPADPT_TERM_FAIL, "CUAMain::RunService:  Failed to stop properly. 0x%X", hr);
        goto Exit;
    }
    *pfServiceRan = TRUE;

    Term();
Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  LoadConfig:  Loads config data from UA.ini
//-----------------------------------------------------------------------------
HRESULT CUAMain::LoadConfig()
{
    HRESULT hr = S_OK;
    DWORD   dwTemp = 0;
    CComPtr<IInterfaceInfo> pInterfaceInfo;
    CComBSTR bstrNumOfPorts;
    CComBSTR bstrServerName;
    

    XomLog(UDPADAPT, "---------------------------------------------------" );
    XomLog(UDPADAPT, "   Udp Adaptor Config Settings" );
    XomLog(UDPADAPT, "---------------------------------------------------" );

    // create the config db instance for all KDCs
    hr = m_pConfig.CoCreateInstance(  __uuidof(ConfigInterop) );
    if ( FAILED(hr) )
    {
        XomTrace(UDPADAPT, L_ERROR, "CUAMain::LoadConfig: Failed to create instance of the configDB interface.  Please investigate.  hr = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_164, "CUAMain::LoadConfig: Failed to create instance of the configDB interface.  Please investigate.  hr = 0x%X", hr);
        goto Exit;
    }

    hr = m_pConfig->get_Server( &bstrServerName );
    if (FAILED(hr))
    {
        XomTrace( UDPADAPT, L_WARNING, "CUAMain::LoadConfig  Failed to get the server name for UDPAdpt.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_165, "CUAMain::LoadConfig  Failed to get the server name for UDPAdpt.  RESULT = 0x%X", hr);
        goto Exit;
    }
    
    hr = m_pConfig->GetInterface( bstrServerName, Interface_udpadpt, &pInterfaceInfo);
    if (FAILED(hr))
    {
        XomTrace( UDPADAPT, L_WARNING, "CUAMain::LoadConfig  Failed to get config interface for UDPAdpt.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_166, "CUAMain::LoadConfig  Failed to get config interface for UDPAdpt.  RESULT = 0x%X", hr);
        goto Exit;
    }

    //------------------------------------------------------------------
    //  Read the ip address
    hr = pInterfaceInfo->get_IPAddressString( &m_bstrIPAddr );
    if ( FAILED(hr) || m_bstrIPAddr.m_str == NULL )
    {
        XomTrace( UDPADAPT, L_WARNING, "CUAMain::LoadConfig  Failed to get a valid IP address for UDPAdpt.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_167, "CUAMain::LoadConfig  Failed to get a valid IP address for UDPAdpt.  RESULT = 0x%X", hr);
        goto Exit;
    }
    XomTrace( UDPADAPT, L_NORMAL, "CUAMain::LoadConfig  IPAddr=%S.  ", m_bstrIPAddr );

    //------------------------------------------------------------------
    //  Read the number of ports to receive from
    hr = pInterfaceInfo->get_Info1( &bstrNumOfPorts );
    if ( FAILED(hr) )
    {
        XomTrace( UDPADAPT, L_WARNING, "CUAMain::LoadConfig  Failed to get the info 1 setting for the number of ports on UDPAdpt.  Using default of 1.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_168, "CUAMain::LoadConfig  Failed to get the info 1 setting for the number of ports on UDPAdpt.  Using default of 1.  RESULT = 0x%X", hr);
        goto Exit;
    }
    else if ( bstrNumOfPorts.m_str == NULL )
    {
        m_dwPortListSize = c_dwDefaultNumOfPorts;
    }
    else
    {
        m_dwPortListSize = _wtoi( bstrNumOfPorts );
    }
    XomTrace( UDPADAPT, L_NORMAL, "CUAMain::LoadConfig  NumOfPorts=%d.  ", m_dwPortListSize );
        
    //------------------------------------------------------------------
    //  Read the port list from info 2
    hr = pInterfaceInfo->get_Info2( &m_bstrPortList );
    if ( FAILED(hr) )
    {
        XomTrace( UDPADAPT, L_WARNING, "CUAMain::LoadConfig  Failed to get the info 2 setting for the port list on UDPAdpt.  Using default of 1.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_169, "CUAMain::LoadConfig  Failed to get the info 2 setting for the port list on UDPAdpt.  Using default of 1.  RESULT = 0x%X", hr);
        goto Exit;
    }
    else if ( bstrNumOfPorts.m_str == NULL )
    {
        m_bstrPortList = c_szDefaultListOfPorts;
    }
    XomTrace( UDPADAPT, L_NORMAL, "CUAMain::LoadConfig  PortList=%S.  ", m_bstrPortList );

    //------------------------------------------------------------------
    //  Read the number of threads to use.
    m_dwNumOfThreads = GetDWORDSetting( Setting_udpadpt_numOfThreads, c_dwDefaultNumberOfThreads );
    XomTrace( UDPADAPT, L_NORMAL, "CUAMain::LoadConfig  NumOfThreads=%d.  ", m_dwNumOfThreads );

    XomLog(UDPADAPT, "---------------------------------------------------" );

Exit:
    return hr;    
}


//------------------------------------------------------------------
// AddRefContext:  Increments the reference counter for this node.
//------------------------------------------------------------------
void CUAMain::AddRefContext( UA_CONTEXT *pNode )
{
    AddRef();
    InterlockedIncrement( (LPLONG)&(pNode->_dwRefCnt) );
}

//------------------------------------------------------------------
// Release:  removes the reference counter for this node.  Also,
//    Zero's out memory fo node when complete.
//------------------------------------------------------------------
void CUAMain::ReleaseContext( UA_CONTEXT *pNode )
{
    LONG lValue = 0;
    
    if ( pNode == NULL )
    {
        return;
    }
    
    XOMASSERT( pNode->_dwRefCnt > 0 );
    
    lValue = InterlockedDecrement( (LPLONG)&(pNode->_dwRefCnt) );
    if ( lValue == 0 )
    {
        ZeroMemory( pNode, sizeof(UA_CONTEXT) );    
        m_oContextBuffer.Free( (void*)pNode );    
    }
    Release();
}

//------------------------------------------------------------------
// GetPacketNode:  returns a packet node
//------------------------------------------------------------------
UA_CONTEXT* CUAMain::GetContext()
{
    UA_CONTEXT *pNode = NULL;
    
    // get a node for this job
    pNode = (UA_CONTEXT*)m_oContextBuffer.Alloc();
    if ( pNode != NULL )
    {
        pNode->_dwRefCnt = 0;
        AddRefContext(pNode);
    }

    return pNode;
}

//------------------------------------------------------------------
//  InitializeCallbacks:  Initializes callback with mgmt interface.
//------------------------------------------------------------------
void CUAMain::InitializeCallbacks()
{
    HRESULT hr = S_OK;
    DWORD   dwX = 0;

    for ( dwX = 0; dwX < c_dwNumOfCommands;  dwX++ )
    {
        hr = m_pMgmtInterface->RegisterCommand( c_aCmdList[dwX] );
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_UDPADPT_GENERIC_ERROR_15,"CUAMain::InitializeCallbacks:  Failed to initialize mgmt interface commands.  RESULT = 0x%X", hr );        
            XomTrace( UDPADAPT, L_ERROR, "CUAMain::InitializeCallbacks:  Failed to initialize mgmt interface commands.  RESULT = 0x%X", hr );
        }
    }
}


//------------------------------------------------------------------
//  ConstructPortList:  generates a port list.
//------------------------------------------------------------------
HRESULT CUAMain::ConstructPortList( char *szPortList )
{
    HRESULT hr = S_OK;
    char *szPos = szPortList;
    char *szInit = szPortList;
    DWORD dwCounter = 0;
    char *szMidPos = NULL;

    m_pdwPortList = (DWORD*)XAllocZ( sizeof(DWORD) * m_dwPortListSize );
    if ( m_pdwPortList == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    szPos = szPortList;
    dwCounter = 0;

    // remove leading white-spaces
    while ( *szPos == ' ' ) 
    {
        *szPos = '\0';
        szPos++;
    }   

    szInit = szPos;

    // while ',' is found
    while ( NULL != ( szPos = strchr( szPos, ',' ) ) )
    {
         char *szRev = szPos - 1;
         szMidPos = NULL;

         *szPos = '\0';
         
         // remove whitespaces.
         while ( szRev != szPortList && ( *szRev == ' ') )
         {
            *szRev = '\0';
            szRev--;
         }
         szPos++;
         while ( *szPos == ' ' ) 
         {
            *szPos = '\0';
            szPos++;
         }   
         
         // look for - to see if we have a range.
         if ( NULL != ( szMidPos = strchr( szInit, '-' ) ) )
         {
            DWORD dwStart = 0;
            DWORD dwEnd = 0;
            DWORD dwI = 0;
            szRev = szMidPos - 1;

            // remove whitespaces.
            while ( szRev >= szPortList && ( *szRev == ' ') )
            {
                *szRev = '\0';
                szRev--;
            }
            szMidPos++;
            while ( *szMidPos == ' ' ) 
            {
                *szMidPos = '\0';
                szMidPos++;
            }   

            // we now have a start and end to the range...
            dwStart = MIN(atoi(szInit), atoi(szMidPos)) ;
            dwEnd = MAX(atoi(szInit), atoi(szMidPos)) ;
            for ( dwI = dwStart; dwI <= dwEnd; dwI++ )
            {
                if ( dwCounter >= m_dwPortListSize )
                {
                    hr = S_THRESHOLD;
                    goto Exit;
                }
                (m_pdwPortList)[dwCounter] = dwI;
                dwCounter++;
            }
         } 
         else
         {
            if ( dwCounter >= m_dwPortListSize )
            {
                hr = S_THRESHOLD;
                goto Exit;
            }
            (m_pdwPortList)[dwCounter] = (DWORD)atoi(szInit);
            dwCounter++;
         }

         szInit = szPos;
    }

    // check the last entry.
    if ( NULL != ( szMidPos = strchr( szInit, '-' ) ) )
    {
       char *szRev = szMidPos - 1;
       DWORD dwStart = 0;
       DWORD dwEnd = 0;
       DWORD dwI = 0;

       // remove whitespaces.
       while ( szRev >= szPortList && ( *szRev == ' ') )
       {
           *szRev = '\0';
           szRev--;
       }
       szMidPos++;
       while ( *szMidPos == ' ' ) 
       {
           *szMidPos = '\0';
           szMidPos++;
       }   

       // we now have a start and end to the range...
       dwStart = MIN(atoi(szInit), atoi(szMidPos)) ;
       dwEnd = MAX(atoi(szInit), atoi(szMidPos)) ;
       for ( dwI = dwStart; dwI <= dwEnd; dwI++ )
       {
            if ( dwCounter >= m_dwPortListSize )
            {
                hr = S_THRESHOLD;
                goto Exit;
            }
            (m_pdwPortList)[dwCounter] = dwI;
            dwCounter++;
       }
    } 
    else
    {
        if ( dwCounter >= m_dwPortListSize )
        {
            hr = S_THRESHOLD;
            goto Exit;
        }
       (m_pdwPortList)[dwCounter] = (DWORD)atoi(szInit);
       dwCounter++;
    }

    m_dwPortListSize =  dwCounter;

Exit:

    return hr;

}


//------------------------------------------------------------------
//  UDPMsgAlloc:  The msg buffer allocator callback for UDPMgr.
//------------------------------------------------------------------
HRESULT CUAMain::UDPMsgAlloc( LPVOID* ppBuffer, DWORD* pcBuffer )
{
    HRESULT hr = S_OK;
    UA_CONTEXT* pCtxt = NULL;
    CUAMain* pMain = CUAMain::GetInstance();

    // check for the object.
    if ( pMain == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }
    
    XOMASSERT( ppBuffer != NULL );

    *pcBuffer = 0;

    // get a context node.
    pCtxt = pMain->GetContext();
    *ppBuffer = (LPVOID)(pCtxt->_aMsg);
    if ( *ppBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // only give the UDP Mgr the buffer portion... 
    *pcBuffer = pCtxt->_cMsg = sizeof(pCtxt->_aMsg);

Exit:
    CUAMain::ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------
//  UDPMsgFree:  The msg buffer free callback for UDP Manager.
//------------------------------------------------------------------
HRESULT CUAMain::UDPMsgFree( LPVOID pBuffer )
{
    UA_CONTEXT *pCtxt = NULL;
    HRESULT hr = S_OK;
    CUAMain* pMain = CUAMain::GetInstance();

    // check for the object.
    if ( pMain == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }
    
    XOMASSERT( pBuffer != NULL );

    // the UDP Mgr will only be given the memory buffer... we have to find where the struct starts.
    pCtxt = (UA_CONTEXT*)(CONTAINING_RECORD( pBuffer, UA_CONTEXT, _aMsg ));
    
    pMain->ReleaseContext( pCtxt );

Exit:
    CUAMain::ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------
//  UDPPostMsg:  The post message callback for UDP manager.
//------------------------------------------------------------------
HRESULT CUAMain::UDPPostMsg( LPVOID pBuffer, DWORD cBuffer, const sockaddr_in* psaFrom , const sockaddr_in* psaTo , QWORD qwRecvId )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = NULL;
    char *pszPos = NULL;
    BOOL bParseHeader = TRUE;
    DWORD dwCharsParsed = 0;
    DWORD dwContentLength = 0;
    BOOL bLookForHeaderEnd = FALSE;
    char szAdditionHeadersBuffer[1600]; //max buffer size is 1500, use 1600 because we add more data ourselves.
    CUAMain* pMain = CUAMain::GetInstance();

    // check for the object.
    if ( pMain == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }
    
    XOMASSERT( pBuffer != NULL );
    XOMASSERT( psaFrom );

    g_Counters.IncrementValue32( UA_REQUESTS_PER_SEC_COUNTER, 1);
    g_Counters.IncrementValue64( UA_REQUESTS_COUNTER, 1);

    // the UDP Mgr will only be given the memory buffer... we have to find where the struct starts.
    pCtxt = (UA_CONTEXT*)(CONTAINING_RECORD( pBuffer, UA_CONTEXT, _aMsg ));

    // 1.  Add a reference.
    pMain->AddRefContext( pCtxt );
    
    // 2.  copy information into UA_CONTEXT.
    memcpy( &(pCtxt->_saFrom), psaFrom, sizeof( *psaFrom ) );

    // set reference id (which happens to be the sock_addr for now.
    memcpy( &(pCtxt->_qwIdentifier), psaFrom, sizeof( pCtxt->_qwIdentifier ) );

    // set the receiver id so we can send from the same receiver later.
    pCtxt->_qwUdpRecvId = qwRecvId;
    
    // 3.  Determine where the Header and Footer start.
    pszPos = (char*)&(pCtxt->_aMsg[2]);
    dwCharsParsed = 3;
    
    // set the action verb (POST or GET or somehting else?)
    pCtxt->_pVerb = &(pCtxt->_aMsg[0]);
    pCtxt->_pObject = NULL;
    pCtxt->_pAdditionalHeaders = NULL;

    // parse the header for what we need.
    while ( bParseHeader )
    {
        pszPos++;
        dwCharsParsed++;
        
        if ( *pszPos == ' ' && !bLookForHeaderEnd )
        {
            *pszPos = '\0';

            // the object should be the next thing on the line.
            if ( pCtxt->_pObject == NULL )
            {
                pCtxt->_pObject = (BYTE*)( pszPos + 1 );
            }
        }
        else if ( *pszPos == '\r' )
        {
            if ( pCtxt->_pObject == NULL )
            {
                // NOTE:  ok... we shouldn't be here ... somethings wrong with this format.
                //  we're about to read additional headers without reading anything an object
                // in the http header... this is invalid formatting.
                XomTrace(UDPADAPT, L_LOW, "CUAMain::UDPPostMsg:  End of line out of place. Msg: %s", pCtxt->_aMsg );

                hr = E_UNEXPECTED;
                goto Exit;                
            }
            else if ( pCtxt->_pObject != NULL && !bLookForHeaderEnd )
            {
                // NOTE:  we have an object and hit the end of the line.
                //   now we're reading additional headers.
                if ( *( pszPos + 1 ) == '\n' )
                {
                    pCtxt->_pAdditionalHeaders = (BYTE*)( pszPos + 2 );
                    pszPos = ( pszPos + 2 );
                    dwCharsParsed += 2;
                    bLookForHeaderEnd = TRUE;
                }
                else
                {
                    XomTrace(UDPADAPT, L_LOW, "CUAMain::UDPPostMsg:  Invalid line feed. Id:0x%X", pCtxt->_qwIdentifier );
                    hr = E_UNEXPECTED;
                    goto Exit;                
                }
            }
            else if ( bLookForHeaderEnd )
            {
                //NOTE:  Headers end with "\r\n\r\n".  We will accept the request if this is true.
                if ( dwCharsParsed + 4 >= ( cBuffer ) )
                {
                    //NOTE:  we have the end of the request header before the return carriages.
                    //  Accept it but this means we have no body.
                    pCtxt->_pBody = WINHTTP_NO_REQUEST_DATA;
                    dwContentLength = 0;
                    dwCharsParsed = cBuffer;
                    bParseHeader = FALSE;
                }
                else if ( *(pszPos + 1) == '\n' && *(pszPos + 2) == '\r' && *(pszPos + 3) == '\n' )
                {
                    *pszPos = '\0';
                    pCtxt->_pBody = (BYTE*)(pszPos + 4);
                    dwCharsParsed += 3;
                    dwContentLength = cBuffer - ( dwCharsParsed );
                    bParseHeader = FALSE;
                }
            }
        }

        // format check
        if ( pCtxt->_pObject == NULL && dwCharsParsed > c_dwMaxAcceptedVerbSize )
        {
            // NOTE:  ok at this point we've got a action verb or 35+ characters.
            //  but neither GET or POST come close to that... Other action requests
            //  don't come close to 35 either...  At this time I think it's safe assume this 
            //  message is invalid.  So rather than parse all 1500 bytes let's just say
            //  we have an invalid packet.and toss it.
            XomTrace(UDPADAPT, L_LOW, "CUAMain::UDPPostMsg:  Invalid action specified. Id:0x%I64X Msg: %s", pCtxt->_qwIdentifier, pCtxt->_aMsg );
            hr = E_UNEXPECTED;
            goto Exit;
        }

        // see if we hit that last position in this array.
        if ( dwCharsParsed == ( cBuffer ) )
        {
            // NOTE:  Ok, we've just scanned the entire message and the format off...  toss it.
            XomTrace(UDPADAPT, L_LOW, "CUAMain::UDPPostMsg:  Entire message read without attaining desired information. Id:0x%I64X", pCtxt->_qwIdentifier );
            hr = E_UNEXPECTED;
            goto Exit;
        }
        
    }

    // if we get here we know the follow is try.
    XOMASSERT( pCtxt->_pVerb != NULL );
    XOMASSERT( pCtxt->_pObject != NULL );
    XOMASSERT( pCtxt->_pAdditionalHeaders != NULL );
    
    // we've added the \0 character... this is now a safe operation. 
    // copy these headers... so we can add our own.
    //  Don't forget to change the sinport to host order.
    _snprintf( szAdditionHeadersBuffer, 
                    sizeof(szAdditionHeadersBuffer), 
                    c_szAdditionalUAHeaders, 
                    (char*)(pCtxt->_pAdditionalHeaders),
                    (pCtxt->_saFrom.sin_addr.S_un.S_un_b.s_b1),
                    (pCtxt->_saFrom.sin_addr.S_un.S_un_b.s_b2),
                    (pCtxt->_saFrom.sin_addr.S_un.S_un_b.s_b3),
                    (pCtxt->_saFrom.sin_addr.S_un.S_un_b.s_b4),
                    ntohs(pCtxt->_saFrom.sin_port)
                    );

    // 4. send that data
    CWinHttpMgr* pWinHttp = CWinHttpMgr::GetInstance();
    if ( pWinHttp == NULL )
    {
        hr = E_NOINTERFACE;
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::UDPPostMsg:  No WinHttpMgr object exists.  RESULT = 0x%X", hr );
        goto Exit;
    }

    // add a reference for the winhttp object.
    pMain->AddRefContext( pCtxt );

    // call the winhttpmgr to send our data.
    hr = pWinHttp->Send( (REQUEST_CONTEXT*)pCtxt, 
                    (LPCWSTR)pMain->m_bstrIPAddr, 
                    ntohs((WORD)(psaTo->sin_port)), 
                    A2W((char*)pCtxt->_pVerb), 
                    A2W((char*)pCtxt->_pObject), 
                    (BYTE*)szAdditionHeadersBuffer, 
                    -1L,                        //unspecified length
                    pCtxt->_pBody, 
                    dwContentLength);
    if (FAILED(hr))
    {
        g_Counters.IncrementValue32( UA_FAILED_HTTP_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_HTTP_REQUESTS_COUNTER, 1);

        // remove the reference for the winhttp object.
        pMain->ReleaseContext( pCtxt );
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::UDPPostMsg:  Send failed.  Id:0x%I64X, RESULT = 0x%X", pCtxt->_qwIdentifier,  hr );
        goto Exit;
    }
    

Exit:
    if ( FAILED(hr) )
    {
        g_Counters.IncrementValue32( UA_FAILED_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_REQUESTS_COUNTER, 1);        
    }
    
    if ( hr == E_UNEXPECTED )        
    {
        // we return unexpected if we don't know what this packet is all about.
        g_Counters.IncrementValue32( UA_INVALID_HTTP_PAYLOADS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_INVALID_HTTP_PAYLOADS_REQUESTS_COUNTER, 1);
    }
    pMain->ReleaseContext( pCtxt );
    CUAMain::ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------
//  OnClose:  close callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnClose( REQUEST_CONTEXT* pContext )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;
    CUdpMgr* pUdp = NULL;
    CUAMain *pMain = CUAMain::GetInstance();
    if ( pMain == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnClose:  Id:0x%I64X, Bytes Received: %d, hrStatus:0x%X", pCtxt->_qwIdentifier, pCtxt->_dwContentLength, pCtxt->_hrStatus );

    // if we encountered an error... don't send anything back.
    if ( FAILED( pCtxt->_hrStatus ) )
    {
        g_Counters.IncrementValue32( UA_FAILED_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_REQUESTS_COUNTER, 1);        

        g_Counters.IncrementValue32( UA_FAILED_HTTP_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_HTTP_REQUESTS_COUNTER, 1);        

        goto Exit;
    }
    
    // let's send this off to our UDP component.
    pUdp = CUdpMgr::GetInstance();
    if ( pUdp == NULL )
    {
        hr = E_NOINTERFACE;
        XomTrace( UDPADAPT, L_ERROR, "CUAMain::OnClose:  No UDP Mgr interface exists.  Dropping response.  Id:0x%I64X, Bytes Received: %d", pCtxt->_qwIdentifier, pCtxt->_dwContentLength);    
        goto Exit;
    }

    // send the response.
    hr = pUdp->Send( &(pCtxt->_saFrom), pCtxt->_aMsg, pCtxt->_cMsg, pCtxt->_qwUdpRecvId );
    if ( FAILED(hr) )
    {
        g_Counters.IncrementValue32( UA_FAILED_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_REQUESTS_COUNTER, 1);        

        g_Counters.IncrementValue32( UA_FAILED_UDP_REPLIES_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_UDP_REPLIES_COUNTER, 1);        

        XomTrace( UDPADAPT, L_ERROR, "CUAMain::OnClose:  Failed to send UDP response.  Dropping response.  Id:0x%I64X, Bytes Received: %d, Result: 0x%X", pCtxt->_qwIdentifier, pCtxt->_dwContentLength, hr);    
        goto Exit;        
    }

    g_Counters.IncrementValue32( UA_SUCCESSFUL_REPLIES_PER_SEC_COUNTER, 1);
    g_Counters.IncrementValue64( UA_SUCCESSFUL_UDP_REPLIES_COUNTER, 1);        
    
Exit:
    if ( pUdp != NULL )
    {
        pUdp->Release();
    }
    pMain->ReleaseContext( pCtxt );
    CUAMain::ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------
//  OnError:  error callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnError( REQUEST_CONTEXT* pContext, HRESULT hrError, DWORD_PTR dwResult )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;
    CUAMain *pMain = CUAMain::GetInstance();
    if ( pMain == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnError:  Id:0x%I64X, Error Result: 0x%X, Result: 0x%X", pCtxt->_qwIdentifier, hr, dwResult );

Exit:
    CUAMain::ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------
//  OnSendRequestComplete:  send complete callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnSendRequestComplete( REQUEST_CONTEXT* pContext )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;
    CUAMain *pMain = CUAMain::GetInstance();
    if ( pMain == NULL )
    {
        pMain->ReleaseContext( pCtxt );        
        hr = E_NOINTERFACE;
        goto Exit;
    }

    pCtxt->_cMsg = 0;
    
    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnSendRequestComplete:  Id:0x%I64X", pCtxt->_qwIdentifier);
Exit:
    CUAMain::ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------
//  OnHeadersAvailable:  headers available callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnHeadersAvailable( REQUEST_CONTEXT* pContext, LPVOID lpData, DWORD  cData )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;
    CUAMain *pMain = CUAMain::GetInstance();
    if ( pMain == NULL )
    {
        pMain->ReleaseContext( pCtxt );        
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // winhttp give us back a buffer full of LPWSTR... we don't want WCHAR.... we want chars...
    //      it will give just more room.
    
    // make sure we can send this in one packet.
    if ( pCtxt->_cMsg + ( cData / sizeof(WCHAR) ) > sizeof(pCtxt->_aMsg) )
    {
        g_Counters.IncrementValue32( UA_FAILED_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_REQUESTS_COUNTER, 1);        

        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    // cat the data to the end of what we already have.
    memcpy( &(pCtxt->_aMsg[pCtxt->_cMsg]), W2A((WCHAR*)lpData), cData / sizeof(WCHAR) );
    pCtxt->_cMsg += ( cData / sizeof(WCHAR) );
    

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnHeadersAvailable:  Id:0x%I64X", pCtxt->_qwIdentifier);
Exit:
    CUAMain::ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------
//  OnResponseReceived:  response received callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnResponseReceived( REQUEST_CONTEXT* pContext )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnResponseReceived:  Id:0x%I64X", pCtxt->_qwIdentifier);
    return hr;
}

//------------------------------------------------------------------
//  OnDataAvailable:  data available callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnDataAvailable( REQUEST_CONTEXT* pContext, LPVOID lpData, DWORD  cData )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;
    CUAMain *pMain = CUAMain::GetInstance();
    if ( pMain == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // make sure we can send this in one packet.
    if ( pCtxt->_cMsg + cData > sizeof(pCtxt->_aMsg) )
    {
        g_Counters.IncrementValue32( UA_FAILED_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( UA_FAILED_REQUESTS_COUNTER, 1);        

        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    // cat the data to the end of what we already have.
    memcpy( &(pCtxt->_aMsg[pCtxt->_cMsg]), lpData, cData );
    pCtxt->_cMsg += cData;
    
    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnDataAvailable:  Id:0x%I64X", pCtxt->_qwIdentifier);

Exit:
    CUAMain::ReleaseInstance();    
    return hr;
}

//------------------------------------------------------------------
//  OnReadComplete:  read complete callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnReadComplete( REQUEST_CONTEXT* pContext, LPVOID lpData, DWORD  cData )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;

    // OnDataAvailable is the important one... this is just returning the size read.
    
    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnReadComplete:  Id:0x%I64X", pCtxt->_qwIdentifier);
    return hr;
}

//------------------------------------------------------------------
//  OnSendingRequest:  sending request callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnSendingRequest( REQUEST_CONTEXT* pContext )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnSendingRequest:  Id:0x%I64X", pCtxt->_qwIdentifier);
    return hr;
}

//------------------------------------------------------------------
//  OnRequestSent:  request sent callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnRequestSent( REQUEST_CONTEXT* pContext )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnRequestSent:  Id:0x%I64X", pCtxt->_qwIdentifier);
    return hr;
}

//------------------------------------------------------------------
//  OnReceivingResponse:  receiving response callback for winhttpmgr.
//------------------------------------------------------------------
HRESULT CUAMain::OnReceivingResponse( REQUEST_CONTEXT* pContext )
{
    HRESULT hr = S_OK;
    UA_CONTEXT *pCtxt = (UA_CONTEXT*)pContext;

    XomTrace( UDPADAPT, L_LOW, "CUAMain::OnReceivingResponse:  Id:0x%I64X", pCtxt->_qwIdentifier);
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdHelp:  help command.  Displays commands
//------------------------------------------------------------------------------
HRESULT CUAMain::MgmtCmdShutdown(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;
    CUAMain *pInst = CUAMain::GetInstance();

    pInst->Shutdown();

    CUAMain::ReleaseInstance();

    return hr;
}

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void CUAMain::GetStringSetting( LPSTR pch, DWORD cch, CComBSTR bstrSettingName, const char *c_szDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );
    
    // get the setting
    hr = m_pConfig->GetSetting( bstrSettingName, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snprintf( pch, cch, "%s\0", c_szDefault );
        XomTrace( UDPADAPT, L_WARNING,  "UDPADPT:(Config)  Name: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB", static_cast<wchar_t *> (bstrSettingName), pch );
    }
    else
    {
        // copy the setting into the static buffer.
        _snprintf( pch, cch, "%S\0", bstrSetting ); 
        XomTrace( UDPADAPT, L_LOW,  "UDPADPT:(Config)  Name: %ws, Value: %S.", static_cast<wchar_t *> (bstrSettingName), pch );
    }

    
 }

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void CUAMain::GetStringSetting( LPWSTR pch, DWORD cch, CComBSTR bstrSettingName, const WCHAR *c_wszDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );
    
    // get the setting
    hr = m_pConfig->GetSetting( bstrSettingName, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snwprintf( pch, cch, L"%s\0", c_wszDefault ); 
        XomTrace( UDPADAPT, L_WARNING,  "UDPADPT:(Config)  Name: %ws, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.", static_cast<wchar_t *> (bstrSettingName), pch );
    }
    else
    {
        // copy the setting into the static buffer.
        _snwprintf( pch, cch, L"%s\0", bstrSetting ); 
        XomTrace( UDPADAPT, L_LOW,  "UDPADPT:(Config)  Name: %ws, Value: %S.", static_cast<wchar_t *> (bstrSettingName), pch );
    }

    
 }

//-----------------------------------------------------------------------------
//  GetDWORDSetting:  Loads a dword value from config interface.
//-----------------------------------------------------------------------------
DWORD CUAMain::GetDWORDSetting( CComBSTR bstrSettingName, DWORD dwDefault )
{
    HRESULT hr = S_OK;
    CComBSTR bstrSetting;
    DWORD dwValue = 0;

    // get the setting
    hr = m_pConfig->GetSetting( bstrSettingName, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        dwValue = dwDefault;
        XomTrace( UDPADAPT, L_WARNING,  "UDPADPT:(Config)  Name: %ws, Value (Default): 0x%X.  Config set to default since no value could be attained from ConfigDB.", static_cast<wchar_t *> (bstrSettingName), dwValue );
    }
    else
    {
        // copy the setting into the static buffer.
        dwValue = _wtoi( bstrSetting );
        XomTrace( UDPADAPT, L_LOW,  "UDPADPT:(Config)  Name: %ws, Value: 0x%X.", static_cast<wchar_t *> (bstrSettingName), dwValue );
    }

    return dwValue;    
}

//-----------------------------------------------------------------------------
//  Local function implementations.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( char** pszValue, const char *c_szArea, const char *c_szDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pszValue = (char*)pSet->GetStr();
        XomLog(UDPADAPT, "CUAMain::LoadConfig: %s=%s", c_szArea, *pszValue );
    }
    else
    {
        XomLog(UDPADAPT, "CUAMain::LoadConfig: Failed to attain a value for %s, using default of %s.", c_szArea, c_szDefault );
        *pszValue = (char*)c_szDefault;
    }
 }

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( WCHAR** pwszValue, const char *c_szArea, const WCHAR *c_wszDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pwszValue = (WCHAR*)pSet->GetWStr();
        XomLog(UDPADAPT, "CUAMain::LoadConfig: %s=%S", c_szArea, *pwszValue );
    }
    else
    {
        XomLog(UDPADAPT, "CUAMain::LoadConfig: Failed to attain a value for %s, using default of %S.", c_szArea, c_wszDefault );
        *pwszValue = (WCHAR*)c_wszDefault;
    }
 }

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( DWORD* pdwValue, const char *c_szArea, DWORD dwDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pdwValue = pSet->GetDw();
        XomLog(UDPADAPT, "CUAMain::LoadConfig: %s=%d", c_szArea, *pdwValue );
    }
    else
    {
        XomLog(UDPADAPT, "CUAMain::LoadConfig: Failed to attain a value for %s, using default of %d.", c_szArea, dwDefault );
        *pdwValue = dwDefault;
    }
 }


//------------------------------------------------------------------
//  IsPrintable:  takes a given byte string and ensure all bytes
//      can be printed.
//------------------------------------------------------------------
BOOL IsPrintable( BYTE *pbArr, DWORD cbArr )
{
    BOOL bRes = TRUE;
    DWORD dwX = 0;

    // scan the entire byte stream.
    for ( dwX = 0; dwX < cbArr; dwX++ )
    {
        if ( !( bRes = isprint( pbArr[dwX] ) ) )
        {
            break;
        }
    }

    return bRes;
}

//------------------------------------------------------------------
//  IsNumericASCII:  takes a given byte string and ensures all bytes
//      are numeric asci.
//------------------------------------------------------------------
BOOL IsNumericASCII( BYTE *pbArr, DWORD cbArr )
{
    BOOL bRes = TRUE;
    DWORD dwX = 0;

    // scan the entire byte stream.
    for ( dwX = 0; dwX < cbArr; dwX++ )
    {
        if ( !( bRes = isdigit( pbArr[dwX] ) ) )
        {
            break;
        }
    }

    return bRes;
}


//------------------------------------------------------------------
//  MakePresentableLogName:  Construct a log-able name from give 
//      data.
//------------------------------------------------------------------
void MakePresentableOutput( char *szName, DWORD dwNameSize, char *pszSrc )
{
    DWORD dwX = 0;

    XOMASSERT( szName );
    XOMASSERT( pszSrc );
    
    ZeroMemory( szName, dwNameSize * sizeof(szName[0]) );
    // scan this name and replace the  '|'
    for ( dwX = 0; dwX < (dwNameSize - 1); dwX++ )
    {
        // check for the end of the string.
        if ( pszSrc[dwX] == L'\0' )
        {
            szName[dwX] = '\0';
            break;
        }        

        // validate the character.  If not valid then toss it.
        if ( pszSrc[dwX] > 127 || pszSrc[dwX] == '|' || (isprint(pszSrc[dwX]) == 0) )
        {
            szName[dwX] = '?';
        }
        else
        {
            szName[dwX] = (char)(pszSrc[dwX]);
        }
    }
    szName[dwNameSize] = '\0';
}

#ifdef _DEBUG
//-----------------------------------------------------------------------------
//  Unit Test  -- debug only
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Unit Test  -- function declaration.
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//  Unit Test  -- Definitions
//-----------------------------------------------------------------------------

HRESULT CUAMain::UnitTest()
{
    HRESULT hr = S_OK;
    CUdpMgr* pMgr = NULL;
    CWinHttpMgr* pWinHttpMgr = NULL;

    //get the instnace of the UDP manager.
    hr = CUdpMgr::CreateInstance();
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CUAMain::UnitTest:  Failed to create instance of UDPMgr.  Hresult=0x%X", hr );
        goto Exit;
    }
    
    pMgr = CUdpMgr::GetInstance();

/*    // run the unit test for the UDP manager.
    hr = pMgr->UnitTest();
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CUAMain::UnitTest:  Failed to create instance of UDPMgr. HResult=0x%X", hr );
        goto Exit;
    }

*/
    hr = CWinHttpMgr::CreateInstance();
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CUAMain::UnitTest:  Failed to create instance of CWinHttpMgr. HResult=0x%X", hr );
        goto Exit;
    }

    pWinHttpMgr = CWinHttpMgr::GetInstance();
    XOMASSERT( pWinHttpMgr != NULL );

    hr = pWinHttpMgr->UnitTest();
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CUAMain::UnitTest:  Failed to initialize CWinHttpMgr. HResult=0x%X", hr );
        goto Exit;
    }
    

Exit:
    pMgr->Release();
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\udpadpt.cpp ===
//  Microsoft (R) Udp Adaptor Service (UA) (tm).
//
//  UdpAdpt.cpp : Defines the entry point for the UA nt service application.
//

//-----------------------------------------------------------------------------
//  Includes
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "cryptohelper.h"
#include <windows.h>

#include "UAMain.h"

//-----------------------------------------------------------------------------
//  Logging Area
//-----------------------------------------------------------------------------
XomDefineArea(UDPADAPT);
XomDefineArea(UDPADPTLog);

#ifdef _DEBUG
XomDefineArea(UNITTEST);
#endif

//-----------------------------------------------------------------------------
//  Local Functions
//-----------------------------------------------------------------------------
void BinToHex( char *szString, DWORD dwStringSize, char **szHexString );
void HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData );
BOOL StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutess, DWORD *pdwSeconds );

//-----------------------------------------------------------------------------
//  GLOBAL VARIABLES
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CONSTANTS
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  IMPLEMENTATION
//-----------------------------------------------------------------------------

int __cdecl wmain(int argc, WCHAR* argv[])
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    CUAMain* pUA = NULL;

    // initialize COM before g_xomcentral has a chance.
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED(hr) ) {
        // error time!!!! --- something bad happened... make note and do what you can.
        XomNtEvent( XEVENT_TOOLS_CONFIG_82, "XkdcProvider: Failed CoInitializeEx.  Stopping UdpAdpt.  Hresult = 0xX", hr );

        return 1;
    }

    // attach the debugging information.
    hr = g_xomcentral.Init( "UdpAdpt" );
    if ( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_UDPADPT_INIT_FAILURE_2, "Failed to initialize the xmgmt config classes and logging. 0x%X", hr);
        return 1;
    }

    pUA = CUAMain::GetInstance();

    dwErr = pUA->ProcessMain( (DWORD)argc, argv );
    if ( ERROR_SUCCESS != dwErr )
    {
        XomNtEvent( XEVENT_TOOLS_CODE_172, "Failed to start properly. 0x%X", dwErr);
        return 1;
    }

    CUAMain::ReleaseInstance();

    // terminate the logging and debugging.
    g_xomcentral.Term();

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\UDPMgr.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) UDP Adaptor (UDPAdpt) (tm). 
//  Copyright (C) 2003. All rights reserved.
//
//  FILE: UDPMgr.h
//
//  UDP Mgr Interface.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "servsock.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD c_dwMaxUDPTransmittionSize = 1400;

//-----------------------------------------------------------------------------
// Pre-Declarations
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Types/Structures
//-----------------------------------------------------------------------------
typedef HRESULT (*MemAlloc)(
    OUT LPVOID*             ppBuffer,
    OUT DWORD*              pcBuffer
    );

typedef HRESULT (*MemFree)(
    IN LPVOID               lpBuffer
    );

typedef HRESULT (*MsgPostHandle)(
    IN LPVOID               lpBuffer,
    IN DWORD                cBuffer,
    IN const sockaddr_in*   pSockAddrFrom,
    IN const sockaddr_in*   pSockAddrTo,
    IN QWORD                qwRecvId
    );

typedef struct _UDP_SOCKET_DATA
{
    CServerSocket*          _pSocket;
    sockaddr_in             _sockAddr;
} UDP_SOCKET_DATA;

//-----------------------------------------------------------------------------
// CUdpMgr
//-----------------------------------------------------------------------------

class CUdpMgr:
            public CServerSocketCallback
{
public:
    // singleton calls
    static HRESULT  __stdcall CreateInstance();
    static CUdpMgr* __stdcall GetInstance();

    virtual ULONG AddRef();
    virtual ULONG Release();

    // call before using.
    HRESULT Initialize( LPCSTR pszAddr, 
                     DWORD* pdwPortList, 
                     DWORD cPortList, 
                     CCompletionPort* pComPort, 
                     MemAlloc pfnMemAlloc, 
                     MemFree pfnMemFree, 
                     MsgPostHandle pfnMsgPostHandle );
    
    HRESULT Shutdown();
   
    HRESULT Send( const sockaddr_in* psaTo, LPVOID lpBuffer, DWORD cBuffer, QWORD qwRecvId );

    // action
    virtual void OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual void OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg );

    virtual void OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg );

    // overrides
    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }


protected:
    CUdpMgr();
    virtual ~CUdpMgr(void);

protected:
    // members
    MemAlloc m_pMsgAllocHandler;
    MemFree  m_pMsgFreeHandler;

    MsgPostHandle m_pMsgPostHandle;

    CCompletionPort* m_pIOCP;
    UDP_SOCKET_DATA* m_pSockDataList;
    DWORD            m_cSockDataList;

private:
    static CUdpMgr* m_pThis;
    static LONG     m_lCount;
    
#ifdef _DEBUG
public:
    HRESULT UnitTest();
#endif 
        
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\UDPMgr.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) UDP Adaptor (UDPAdpt) (tm). 
//  Copyright (C) 2003. All rights reserved.
//
//  FILE: UdpMgr.cpp
//
//  Implementation of the udp manager interface.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "UdpMgr.h"

#include "servsock.h"
#include <XAlloc.h>

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------
XomDefineArea(UDPMGR);

#ifdef _DEBUG
XomImportArea(UNITTEST);
#endif

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
CUdpMgr* CUdpMgr::m_pThis  = NULL;
LONG     CUdpMgr::m_lCount = 0;

//-----------------------------------------------------------------------------
//  Constant
//-----------------------------------------------------------------------------
const DWORD c_dwMaxNumOfRecvFromRetries = 5;

//-----------------------------------------------------------------------------
//  Local Function Declaration
//-----------------------------------------------------------------------------
HRESULT BuildSocketAddr( LPCSTR pszAddr, DWORD dwPort, sockaddr_in* pSockAddr );

//-----------------------------------------------------------------------------
//  CUdpMgr Implementation
//-----------------------------------------------------------------------------
CUdpMgr::CUdpMgr()
{
    m_pIOCP = NULL;
    m_pSockDataList = NULL;
    m_cSockDataList = 0;
}

CUdpMgr::~CUdpMgr(void)
{
    Shutdown();
    m_pIOCP = NULL;
    m_pSockDataList = NULL;
}

HRESULT CUdpMgr::CreateInstance()
{
    HRESULT hr = S_OK;
    
    if ( m_pThis != NULL )
    {        
        hr = E_FAIL;
        goto Exit;
    }

    m_pThis = new CUdpMgr();
    
Exit:
    return hr;
}

ULONG CUdpMgr::AddRef()
{
    LONG lResult = InterlockedIncrement( &m_lCount );
    return( lResult );
}

CUdpMgr* CUdpMgr::GetInstance()
{
    LONG lResult = InterlockedIncrement( &m_lCount );    
    return( m_pThis );
}

ULONG CUdpMgr::Release()
{
    LONG lResult = InterlockedDecrement( &m_lCount );
    if( 0 == lResult )
    {
        delete m_pThis;
        m_pThis = NULL;
        return S_OK;
    }

    return S_FALSE;
}

//-----------------------------------------------------------------------------
//  Initialize:  Set up the UDP Mgr object.
//-----------------------------------------------------------------------------
HRESULT CUdpMgr::Initialize( 
                          LPCSTR pszAddr,                   // IP addr or hostname to listen on
                          DWORD* pdwPortList,               // list of ports to listen on.
                          DWORD cPortList,                  // number of ports in the list.
                          CCompletionPort *pComPort,        // pointer to the post method.
                          MemAlloc pMemAlloc, 
                          MemFree  pMemFree, 
                          MsgPostHandle pMsgPostHandle
                        )
{
    HRESULT hr = S_OK;
    BYTE *pRecvBuffer = NULL;
    DWORD cRecvBuffer = 0;
    DWORD dwRetryCounter = 0;
    DWORD dwX = 0;
    
    XomTrace( UDPMGR, L_NORMAL, "CUdpMgr::Initialize:  Initializing MGMT Interface.");

    XOMASSERT( pszAddr          != NULL );
    XOMASSERT( pMemAlloc        != NULL );
    XOMASSERT( pMsgPostHandle   != NULL );
    XOMASSERT( pMemFree         != NULL );
    XOMASSERT( pComPort         != NULL );
    
    // set the completion port.
    pComPort->AddRef();
    m_pIOCP = pComPort;

    // set the memory allocator.
    m_pMsgAllocHandler = pMemAlloc;
    m_pMsgFreeHandler = pMemFree;

    // set the msg post handle
    m_pMsgPostHandle = pMsgPostHandle;

    // set the size of the port list.    
    m_cSockDataList = cPortList;

    m_pSockDataList = (UDP_SOCKET_DATA*)XAllocZ( sizeof( UDP_SOCKET_DATA ) * m_cSockDataList );
    if ( m_pSockDataList == NULL )
    {
        hr = E_OUTOFMEMORY;
        XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Initialize:  Not enough memory for internal socket data list.  Result = 0x%X.", hr);
        goto Exit;
    }

    for ( dwX = 0; dwX < m_cSockDataList; dwX++ )
    {
        // build the socket addr structure
        hr = BuildSocketAddr( pszAddr, pdwPortList[dwX], &(m_pSockDataList[dwX]._sockAddr) );
        if ( FAILED(hr) )
        {
            Shutdown();
            XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Initialize:  Failed to build socket addr from given.  Port = %d, Result = 0x%X.", pdwPortList[dwX], hr);
            goto Exit;
        }

        // initialize the server socket to listen on UDP.
        hr = CServerSocket::CreateInstance(&(m_pSockDataList[dwX]._pSocket), m_pIOCP, m_pIOCP);
        if(FAILED(hr))
        {
            Shutdown();
            XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Initialize:  Failed to create instance of server socket.  Port = %d, Result = 0x%X.", pdwPortList[dwX], hr);
            goto Exit;
        }

        // initial our udp connection.
        hr = m_pSockDataList[dwX]._pSocket->Init(IPPROTO_UDP, &(m_pSockDataList[dwX]._sockAddr), FALSE, NULL );
        if(FAILED(hr))
        {
            Shutdown();
            XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Initialize:  Failed to init the socket.  Port = %d, Result = 0x%X.", pdwPortList[dwX], hr);
            goto Exit;
        }

        // use our mem alloc callback to get a buffer.
        hr = (*m_pMsgAllocHandler)( (LPVOID*)&pRecvBuffer, &cRecvBuffer );
        if ( FAILED(hr) )
        {
            Shutdown();
            XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Initialize:  Failed to attain memory from given allocator.  Port = %d, Result = 0x%X.", pdwPortList[dwX], hr);
            goto Exit;
        }

        XOMASSERT( pRecvBuffer != NULL && cRecvBuffer > 0 );
    
        // get the socket to listen for information.
        while ( ( hr = m_pSockDataList[dwX]._pSocket->ReceiveFrom( pRecvBuffer, cRecvBuffer, this, (QWORD)dwX) != S_OK ) && dwRetryCounter < c_dwMaxNumOfRecvFromRetries );    
        if(FAILED(hr))
        {
            Shutdown();
            XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Initialize:  Fail to setup ReceiveFrom callback.  Result = 0x%X.", hr);
            // free the message buffer... we failed to set up the receive.
            (*m_pMsgFreeHandler)( (LPVOID)pRecvBuffer );
            goto Exit;
        }
    }
Exit:    
    return hr;
}


//-----------------------------------------------------------------------------
//  Send:  Sends data to specified addr
//-----------------------------------------------------------------------------
HRESULT CUdpMgr::Send( const sockaddr_in* psaTo, LPVOID lpBuffer, DWORD cBuffer, QWORD qwRecvId )
{
    HRESULT hr = S_OK;
    UDP_SOCKET_DATA* pSData = NULL;

    XOMASSERT( lpBuffer != NULL );

    if ( qwRecvId == NULL )
    {
        // as default, just use the first port.
        pSData = &(m_pSockDataList[0]);
    }
    else
    {
        // the recv id we give to our callback is actually a poitner to the socket data.
        pSData = (UDP_SOCKET_DATA*)&(m_pSockDataList[qwRecvId] );
    }

    XomTrace( UDPMGR, L_LOW, "CUdpMgr::Send:  Sending %d bytes to IP:0x%X, Port:%d. Sent from port:%d.", 
                    cBuffer,
                    psaTo->sin_addr.s_addr,
                    psaTo->sin_port,
                    pSData->_sockAddr.sin_port );

    // send the data.
    hr = pSData->_pSocket->SendTo( (BYTE*)lpBuffer, cBuffer, psaTo, this, *((QWORD*)(psaTo)) );
    if ( FAILED(hr) )
    {
        XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Send:  Failed to send %d bytes to IP:0x%X, Port:%d. Sent from port:%d. HRESULT = 0x%X", 
                    cBuffer,
                    psaTo->sin_addr.s_addr,
                    psaTo->sin_port,
                    pSData->_sockAddr.sin_port,
                    hr);
        goto Exit;
    }
    
Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Send:  Sends data to specified addr
//-----------------------------------------------------------------------------
HRESULT CUdpMgr::Shutdown()
{
    HRESULT hr = S_OK;
    DWORD dwX = 0;

    // we no longer have an interface to work with...
    if ( m_pSockDataList == NULL )
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // go through the entire list.
    for ( dwX = 0; dwX < m_cSockDataList; dwX++ )
    {
        if ( m_pSockDataList[dwX]._pSocket == NULL )
        {
            // don't know why this doesn't exist... perhaps an error occurred... 
            // let's must make sure no on else has this problem.
            continue;
        }
        
        hr = m_pSockDataList[dwX]._pSocket->Close();
        if ( FAILED(hr) )
        {
            XomTrace( UDPMGR, L_ERROR, "CUdpMgr::Shutdown:  Failed to close server socket.  HRESULT = 0x%X", 
                        hr);
        }

        m_pSockDataList[dwX]._pSocket->Release();
        ZeroMemory( &m_pSockDataList[dwX], sizeof(UDP_SOCKET_DATA));
    }

    XFree( m_pSockDataList );
    m_pIOCP->Release();
    m_pIOCP = NULL;
    
Exit:
    
    return hr;
    
}


//-----------------------------------------------------------------------------
//  OnSocketSendTo:  Callback
//-----------------------------------------------------------------------------
void CUdpMgr::OnSocketSendTo(
                        BYTE *pbBufferSent,
                        DWORD cbToSend,
                        DWORD cbSent,
                        HRESULT hr,
                        QWORD qwCallbackArg )
{
    CUdpMgr *pMgr = CUdpMgr::GetInstance();    
    if ( pMgr == NULL )
    {
        return;
    }

    if ( FAILED(hr) )
    {
        XomTrace( UDPMGR, L_WARNING, "CUdpMgr::OnSocketSendTo:  Send Failed.  BytesToSend:%d BytesSent:%d Arg:0x%I64X.  HRESULT = 0x%X", 
                    cbToSend,
                    cbSent,
                    qwCallbackArg,
                    hr);
    }
    else
    {        
        XomTrace( UDPMGR, L_LOW, "CUdpMgr::OnSocketSendTo:  Send Completed.  BytesToSend:%d BytesSent:%d Arg:0x%I64X.  HRESULT = 0x%X", 
                    cbToSend,
                    cbSent,
                    qwCallbackArg,
                    hr);
    }

    pMgr->Release();
}

//-----------------------------------------------------------------------------
//  OnSocketClose:  Close Callback
//-----------------------------------------------------------------------------
void CUdpMgr::OnSocketClose(
                        HRESULT hr,
                        QWORD qwCallbackArg )
{
    CUdpMgr *pMgr = CUdpMgr::GetInstance();    
    if ( pMgr == NULL )
    {
        return;
    }
    
    XomTrace( UDPMGR, L_INFO, "CUdpMgr::OnSocketClose:  Socket Closed... .  Arg:0x%I64X HRESULT = 0x%X", 
                    qwCallbackArg,
                    hr);

    pMgr->Release();
}

//-----------------------------------------------------------------------------
//  OnSocketReceiveFrom:  Recevie From Callback
//-----------------------------------------------------------------------------
void CUdpMgr::OnSocketReceiveFrom(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        sockaddr_in *pFilledInFrom,
                        HRESULT hr,
                        QWORD qwCallbackArg )
{
    HRESULT hrFinal = S_OK;
    BYTE *pRecvBuffer = NULL;
    DWORD cRecvBuffer = 0;
    DWORD dwRetryCounter = 0;
    
    CUdpMgr *pMgr = CUdpMgr::GetInstance();    
    if ( pMgr == NULL )
    {
        goto Exit;
    }

    // check if the socket has been destroyed.
    if( HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED ) == hr )
    {    
        goto Exit;
    }
    
    // use our mem alloc callback to get a buffer.
    hrFinal = (*m_pMsgAllocHandler)( (LPVOID*)&pRecvBuffer, &cRecvBuffer );
    if ( FAILED(hrFinal) )
    {
        XomTrace( UDPMGR, L_ERROR, "CUdpMgr::OnSocketReceiveFrom:  Failed to attain message memory from handle.  HRESULT = 0x%X", hrFinal);
        goto Exit;
    }

    XOMASSERT( pRecvBuffer != NULL && cRecvBuffer > 0 );

    // call receive from until successful or we just give up on it.
    while ( ( hrFinal = m_pSockDataList[qwCallbackArg]._pSocket->ReceiveFrom( pRecvBuffer, cRecvBuffer, this, qwCallbackArg) != S_OK ) && dwRetryCounter < c_dwMaxNumOfRecvFromRetries );    
    if(FAILED(hrFinal))
    {        
        XomTrace( UDPMGR, L_ERROR, "CUdpMgr::OnSocketReceiveFrom:  ReceiveFrom failed.  HRESULT = 0x%X", hrFinal);
        // free the message buffer... we failed to set up the receive.
        (*m_pMsgFreeHandler)( pRecvBuffer );
        goto Exit;
    }

    if ( FAILED(hr) )
    {                
        // nuts... we failed for some reason.  Don't post.
        XomTrace( UDPMGR, L_ERROR, "CUdpMgr::OnSocketReceiveFrom:  ReceiveFrom encountered an error.  HRESULT = 0x%X", hr);
        goto Exit;
    }

    // post the received message to the interested party.
    hrFinal = (*m_pMsgPostHandle)( pbFilledInBuffer, cbRead, pFilledInFrom, &(m_pSockDataList[qwCallbackArg]._sockAddr), (qwCallbackArg) );
    if(FAILED(hrFinal))
    {        
        XomTrace( UDPMGR, L_ERROR, "CUdpMgr::OnSocketReceiveFrom:  Failed to post the message to the given handle.  HRESULT = 0x%X", hrFinal);
        goto Exit;
    }

    
Exit:
    if ( pMgr )
    {
        pMgr->Release();
    }
    
    // free this buffer... we won't use it anymore.
    (*m_pMsgFreeHandler)( pbFilledInBuffer );
}


//-----------------------------------------------------------------------------
//  Local Function Implementation
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  BuildSocketAddr:  takes a given IP or host name and port and puts the
//          values in the given SockAddr.  Note pSockAddr != NULL
//-----------------------------------------------------------------------------
HRESULT BuildSocketAddr( LPCSTR pszAddr, DWORD dwPort, sockaddr_in* pSockAddr )
{
    HRESULT hr = S_OK;
    
    XOMASSERT( pSockAddr != NULL );

    ZeroMemory( pSockAddr, sizeof(*pSockAddr));

    pSockAddr->sin_family = AF_INET;
    pSockAddr->sin_port = htons((u_short)dwPort);

    // The address in pszAddress could either be in the IP format or it
    // could be the hostname. Let's try it as an IP first.
    
    pSockAddr->sin_addr.s_addr = inet_addr(pszAddr);

    if( 0 == pSockAddr->sin_addr.s_addr ||
        INADDR_NONE == pSockAddr->sin_addr.s_addr )
    {
        // Hmmm, it's not in the IP format or it's an invalid IP. Let's 
        // assume that it is a hostname. Now we need to figure out its IP.

        hostent* pHost = gethostbyname(pszAddr);

        if(NULL == pHost)
        {
            hr = HRESULT_FROM_WIN32(WSAGetLastError());
            goto Exit;
        }

        pSockAddr->sin_addr.s_addr = ((in_addr*)pHost->h_addr_list[0])->s_addr;
    }

Exit:
    return hr;
}



#ifdef _DEBUG
//-----------------------------------------------------------------------------
//  Unit Test  -- debug only
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Unit Test  -- function declaration.
//-----------------------------------------------------------------------------
HRESULT UnitTest_MemAlloc( LPVOID* ppBuffer, DWORD* pcBuffer );
HRESULT UnitTest_MemFree( LPVOID pBuffer );
HRESULT UnitTest_PostHandle( LPVOID pBuffer, DWORD cBuffer, const sockaddr_in* psaFrom, const sockaddr_in* psaTo, QWORD qwRecvId );

HRESULT CUdpMgr::UnitTest()
{
    HRESULT hr = S_OK;
    char szValue[] = "UnitTest Data.";
    DWORD aPort[1] = {8090};
    CCompletionPort* pComPort = NULL;

    XomTrace( UNITTEST, L_NORMAL, "CUdpMgr::UnitTest:  Testing UDPMgr.", hr);

    // create a completion port for this test.
    hr = CCompletionPort::CreateInstance( 0, 1, THREAD_PRIORITY_ABOVE_NORMAL, &pComPort );
    if ( FAILED(hr) || pComPort == NULL )
    {
        hr = E_OUTOFMEMORY;
        XomTrace( UNITTEST, L_ERROR, "CUdpMgr::UnitTest:  Insufficient memory for Unit Testing. hr = 0x%X", hr);
    }

    //-----------------------------------------
    // 1.  Init --> with invalid host
    hr = Initialize( "Findthisipinthatlist", 
                aPort, 
                1,
                pComPort, 
                (UnitTest_MemAlloc), 
                (UnitTest_MemFree), 
                (UnitTest_PostHandle));
    if ( FAILED(hr) )
    {
        SUCCESS_UT("CUdpMgr::UnitTest: 1");
    }
    else
    {
        FAIL_UT("CUdpMgr::UnitTest: 1");
    }

    //-----------------------------------------
    // 2.  Init --> success
    aPort[0] = 8080;
    hr = Initialize( "localhost", 
                aPort, 
                1,
                pComPort, 
                (UnitTest_MemAlloc), 
                (UnitTest_MemFree), 
                (UnitTest_PostHandle));
    if ( FAILED(hr) )
    {
        FAIL_UT("CUdpMgr::UnitTest: 2");
    }
    else
    {
        SUCCESS_UT("CUdpMgr::UnitTest: 2");
    }
    
    //-----------------------------------------
    // 3. Send to nowhere...
    //   -- send to 0.0.0.1 ... 
    //   -- the result will succeed but we'll get a failure in the callback.
    sockaddr_in saTo;    

    saTo.sin_family = AF_INET;
    saTo.sin_port = htons(200);
    saTo.sin_addr.s_addr = 1;

    hr = Send( &saTo, (LPVOID)(szValue), sizeof(szValue), 0);
    if ( FAILED(hr) )
    {
        FAIL_UT("CUdpMgr::UnitTest: 3");
    }
    else
    {
        SUCCESS_UT("CUdpMgr::UnitTest: 3");
    }
    
    //-----------------------------------------
    // 4. Send to self.
    //   -- send to local host.
    //   -- should see a message in the receive buffer.
    //   -- should be successful send.
    hr = BuildSocketAddr( "127.0.0.1", 8080, &saTo);
    hr = Send( &saTo, (LPVOID)szValue, sizeof(szValue), 0);
    if ( FAILED(hr) )
    {
        FAIL_UT("CUdpMgr::UnitTest: 4");
    }
    else
    {
        SUCCESS_UT("CUdpMgr::UnitTest: 4");
    }

    //-----------------------------------------
    // 5. Call successful shutdown.    
    hr = Shutdown();
    if ( FAILED(hr) )
    {
        FAIL_UT("CUdpMgr::UnitTest: 5");
    }
    else
    {
        SUCCESS_UT("CUdpMgr::UnitTest: 5");
    }
    
    
    //-----------------------------------------
    // 6. Call shutdown twice
    hr = Shutdown();
    if ( FAILED(hr) )
    {
        SUCCESS_UT("CUdpMgr::UnitTest: 6");
    }
    else
    {
        FAIL_UT("CUdpMgr::UnitTest: 6");
    }
    
    hr = S_OK;
Exit:
    XomTrace( UNITTEST, L_NORMAL, "CUdpMgr::UnitTest:  Completed UDPMgr Test.  HRESULT = 0x%x", hr);    

    if ( pComPort )
    {
        pComPort->Shutdown();
        pComPort->Release();
    }

    return hr;
}

HRESULT UnitTest_MemAlloc( LPVOID* ppBuffer, DWORD* pcBuffer )
{
    HRESULT hr = S_OK;    
    XOMASSERT( ppBuffer != NULL );

    *pcBuffer = 0;

    *ppBuffer = XAlloc( c_dwMaxUDPTransmittionSize );
    if ( *ppBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    *pcBuffer = c_dwMaxUDPTransmittionSize;

Exit:
    return hr;
}

HRESULT UnitTest_MemFree( LPVOID pBuffer )
{
    XOMASSERT( pBuffer != NULL );

    XFree( pBuffer );
    return S_OK;
}

HRESULT UnitTest_PostHandle( LPVOID pBuffer, DWORD cBuffer, const sockaddr_in* psaFrom , const sockaddr_in* psaTo, QWORD qwRecvId )
{
    XOMASSERT( pBuffer != NULL );
    XOMASSERT( psaFrom );

    XomTrace( UNITTEST, L_INFO, "UnitTest_PostHandle:  Received %d bytes from IP:0x%X, %d. To: 0x%X, %d  Id: 0xI64X.  Buffer = %s", 
                    cBuffer,                    
                    psaFrom->sin_addr.s_addr,
                    psaFrom->sin_port,
                    psaTo->sin_addr.s_addr,
                    psaTo->sin_port,
                    qwRecvId,
                    (char*)(pBuffer)
                    );

     return S_OK;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\WinHttpConnectionPool.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Udp Adaptor Service (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WinHttpConnectionPool.h.cpp
//
//  Implementation of the winhttp connection pool.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#pragma once

#include <windows.h>
#include <httpext.h>
#include <winhttp.h>

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
#define MAX_DESTINATIONS 256
#define MAX_CONNECTIONS 4096

#define MAX_FULL_DATA_BUFFER_SIZE   65536
#define MAX_DATA_BUFFER_SIZE        16384
#define MAX_RETURN_HEADER_SIZE      4096
#define MAX_INCOMING_HEADER_SIZE    4096
#define MAX_CERT_SUBJECT_LENGTH     512
#define MAX_IPADDRESS_LENGTH        32
#define MAX_REQUESTID_LENGTH        20
#define MAX_LOG_STRING_SIZE         256


//-----------------------------------------------------------------------------
// CWinHttpConnectionPool:
//      Helper class to reuse WinHttp Connections
//-----------------------------------------------------------------------------

class CWinHttpConnectionPool
{
    
public:
    
    // singleton calls
    static HRESULT                  __stdcall CreateInstance( HINTERNET hSession );
    static CWinHttpConnectionPool*  __stdcall GetInstance();

    virtual ULONG AddRef();
    virtual ULONG Release();

    HINTERNET GetWinHttpConnection(LPCWSTR pswzServerName, INTERNET_PORT nServerPort);
    
    void ReleaseWinHttpConnection(HINTERNET hConnect, LPCWSTR pswzServerName, INTERNET_PORT nServerPort);

protected:
    CWinHttpConnectionPool();
    virtual ~CWinHttpConnectionPool();

    
private:
    static CWinHttpConnectionPool* m_pThis;
    static LONG m_lCount;

    // Session handle.
    HINTERNET m_hSession;
    
    struct ConnectionDestination
    {
        WCHAR wszIp[MAX_IPADDRESS_LENGTH];
        INTERNET_PORT nPort;
        int nConnect;
        HINTERNET hConnect[MAX_CONNECTIONS];
    };

    CRITICAL_SECTION m_cs;

    int m_nDest;
    ConnectionDestination m_dest[MAX_DESTINATIONS];

#ifdef _DEBUG
public:
    HRESULT UnitTest();
#endif 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_udpadpt_none_12.4.56.0_none_dffc1cf65a2c0c74
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=udpadpt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.manifest
XP_MANIFEST_PATH=manifests\x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.cat
XP_CATALOG_PATH=manifests\x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.cat
XP_PAYLOAD_PATH=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=udpadpt,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_udpadpt_none_12.4.56.0_none_dffc1cf65a2c0c74
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=udpadpt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.manifest
XP_MANIFEST_PATH=manifests\x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.cat
XP_CATALOG_PATH=manifests\x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e.cat
XP_PAYLOAD_PATH=x86_udpadpt_no-public-key_12.4.56.0_x-ww_998e3e5e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=udpadpt,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\WinHttpMgr.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Udp Adaptor Service (UA) (tm). 
//  Copyright (C) 2003. All rights reserved.
//
//  FILE: WinHttpMgr.cpp
//
//  Implementation of the winhttp manager for udpadpt.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#pragma once

#include <windows.h>
#include <httpext.h>
#include <winhttp.h>

#include "perfapi.h"
#include "WinHttpConnectionPool.h"

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Pre-declarations
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
#define NO_BYTES_READ   -1L

//-----------------------------------------------------------------------------
// CWinHttpCallback:
//      Helper class for WinHttp class interaction.
//-----------------------------------------------------------------------------
struct REQUEST_CONTEXT
{
    HINTERNET   _hConnect;       // connection handle.
    HINTERNET   _hRequest;       // Resource request handle

    WCHAR       _wszServerIp[MAX_IPADDRESS_LENGTH];
    WORD        _nServerPort;

    DWORD       _dwLastRead;
    HRESULT     _hrStatus;

    DWORD       _dwAvailableDataSize;

    QWORD       _qwIdentifier;   // 64bit values to represent this request.
    DWORD       _dwContentLength;

};

//-----------------------------------------------------------------------------
// CWinHttpCallback:
//      Helper class for WinHttp class interaction.
//-----------------------------------------------------------------------------
class CWinHttpCallback
{
public:
    virtual LONG AddRef() = 0;
    virtual LONG Release() = 0;
    
    virtual HRESULT OnClose( 
                        REQUEST_CONTEXT* pContext                        
                        ) = 0;

    virtual HRESULT OnError( 
                        REQUEST_CONTEXT* pContext,
                        HRESULT hr,
                        DWORD_PTR dwResult
                        ) = 0;

    virtual HRESULT OnSendingRequest(
                        REQUEST_CONTEXT* pContext
                        ) = 0;

    virtual HRESULT OnRequestSent(
                        REQUEST_CONTEXT* pContext
                        ) = 0;

    virtual HRESULT OnSendRequestComplete(
                        REQUEST_CONTEXT* pContext
                        ) = 0;

    virtual HRESULT OnReceivingResponse(
                        REQUEST_CONTEXT* pContext
                        ) = 0;

    virtual HRESULT OnHeadersAvailable(
                        REQUEST_CONTEXT* pContext,
                        LPVOID lpData,
                        DWORD  cData
                        ) = 0;

    virtual HRESULT OnResponseReceived(
                        REQUEST_CONTEXT* pContext
                        ) = 0;

    virtual HRESULT OnDataAvailable(
                        REQUEST_CONTEXT* pContext,
                        LPVOID lpData,
                        DWORD  cData
                        ) = 0;

    virtual HRESULT OnReadComplete(
                        REQUEST_CONTEXT* pContext,
                        LPVOID lpData,
                        DWORD  cData
                        ) = 0;

};

//-----------------------------------------------------------------------------
// CWinHttpMgr:
//      Helper class for WinHttp class interaction.
//-----------------------------------------------------------------------------
class CWinHttpMgr
{
public:
    // singleton calls
    static HRESULT                  __stdcall CreateInstance();
    static CWinHttpMgr*             __stdcall GetInstance();
    
    virtual ULONG Release();
    
    HRESULT Initialize( CWinHttpCallback* pCallback );
    HRESULT Shutdown();

    HRESULT Send( 
            IN REQUEST_CONTEXT* pContext,
            IN LPCWSTR pswzServerName, 
            IN WORD nServerPort, 
            IN WCHAR* wszAction,
            IN WCHAR* wszObjectName,
            IN BYTE* pHeader,
            IN DWORD cHeader,
            IN BYTE* pBuffer, 
            IN DWORD cBuffer 
            );
    

protected:
    CWinHttpMgr();
    virtual ~CWinHttpMgr();

    CWinHttpCallback* m_pCallback;
    CWinHttpConnectionPool* m_pConnectionPool;

    HINTERNET m_hInternet;

    // winhttp callback function
    static void __stdcall WinHttpCallback( 
        HINTERNET hInternet, 
        DWORD dwContext,
        DWORD dwInternetStatus,
        LPVOID lpvStatusInformation,
        DWORD dwStatusInformationLength
        );    


    HRESULT QueryData(REQUEST_CONTEXT *cpContext);
    HRESULT ReadData(REQUEST_CONTEXT *cpContext, BYTE* pDataBuffer, DWORD* pcDataBuffer );
    HRESULT Header(REQUEST_CONTEXT *cpContext, BYTE* pHeaderBuffer, DWORD* pdwSize );
    HRESULT CompleteRequest(REQUEST_CONTEXT *pContext, HRESULT hr);


private:
    static CWinHttpMgr* m_pThis;
    static LONG m_lCount;    
        
#ifdef _DEBUG
public:
    HRESULT UnitTest();
#endif 

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\WinHttpMgr.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) UDP Adaptor (UDPAdpt) (tm). 
//  Copyright (C) 2003. All rights reserved.
//
//  FILE: WinHttpMgr.cpp
//
//  Implementation of the win http mgr manager interface.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "WinHttpMgr.h"
#include <atlbase.h>

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------
XomImportArea(WINHTTP);

#ifdef _DEBUG
XomImportArea(UNITTEST);
#endif

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Globals
//-----------------------------------------------------------------------------
CWinHttpMgr*    CWinHttpMgr::m_pThis   = NULL;
LONG            CWinHttpMgr::m_lCount  = 0;

//-----------------------------------------------------------------------------
//  Constant
//-----------------------------------------------------------------------------
const WCHAR c_wszUserAgent[] = L"WinHttpMgr";

//-----------------------------------------------------------------------------
//  Local Function Declaration
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  CWinHttpMgr Implementation
//-----------------------------------------------------------------------------
CWinHttpMgr::CWinHttpMgr()
{
    m_pCallback = NULL;
    m_pConnectionPool = NULL;
}

CWinHttpMgr::~CWinHttpMgr()
{
    Shutdown();
}

HRESULT CWinHttpMgr::CreateInstance()
{
    HRESULT hr = S_OK;
    
    if ( m_pThis != NULL )
    {        
        hr = E_FAIL;
        goto Exit;
    }

    m_pThis = new CWinHttpMgr();
    
Exit:
    return hr;
}

CWinHttpMgr* CWinHttpMgr::GetInstance()
{
    LONG lResult = InterlockedIncrement( &m_lCount );    
    return( m_pThis );
}

ULONG CWinHttpMgr::Release()
{
    LONG lResult = InterlockedDecrement( &m_lCount );
    if( 0 == lResult )
    {
        delete m_pThis;
        m_pThis = NULL;
        return S_OK;
    }

    return S_FALSE;
}

//-----------------------------------------------------------------------------
//  Send:  Send the http request.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::Send( 
            IN REQUEST_CONTEXT* pContext,
            IN LPCWSTR pswzServerName, 
            IN WORD nServerPort, 
            IN WCHAR* wszAction,
            IN WCHAR* wszObjectName,
            IN BYTE* pHeader,
            IN DWORD cHeader,
            IN BYTE* pBuffer, 
            IN DWORD cBuffer 
            )
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    BOOL httpResult = TRUE;
   
    XomTrace( WINHTTP, L_LOW, "Sending RequestId:[%I64X] to [%S:%d]", pContext->_qwIdentifier, pswzServerName, nServerPort );

    wcsncpy(pContext->_wszServerIp, pswzServerName, MAX_IPADDRESS_LENGTH - 1);
    pContext->_nServerPort = (WORD)nServerPort;

    pContext->_hConnect = m_pConnectionPool->GetWinHttpConnection(pContext->_wszServerIp, pContext->_nServerPort);
    if ( NULL == pContext->_hConnect )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomTrace(  WINHTTP, 
                    L_ERROR, 
                    "CWinHttpMgr::Send: Failed to attain a connection failed.  RequestId:[0x%I64X] ServerName=%S, Port=%d, hr = %x", 
                    pContext->_qwIdentifier,
                    pContext->_wszServerIp,
                    pContext->_nServerPort,
                    hr);
        goto Exit;
    }
        
    // Open and Send a Request Header.
    pContext->_hRequest = WinHttpOpenRequest( 
                                            pContext->_hConnect, 
                                            wszAction,
                                            wszObjectName,
                                            NULL, 
                                            WINHTTP_NO_REFERER, 
                                            WINHTTP_DEFAULT_ACCEPT_TYPES, 
                                            0); 

    if ( NULL == pContext->_hRequest )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomTrace(  WINHTTP, 
                    L_ERROR, 
                    "CWinHttpMgr::Send: Failed to Open connection.  RequestId:[0x%I64X] ServerName=%S, Port=%d, hr = %x", 
                    pContext->_qwIdentifier,
                    pContext->_wszServerIp,
                    pContext->_nServerPort,
                    hr);
        goto Exit;
    }


    WINHTTP_STATUS_CALLBACK dwRes = WinHttpSetStatusCallback( pContext->_hRequest,
                (WINHTTP_STATUS_CALLBACK)(WinHttpCallback),
                WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
                NULL);
    if ( dwRes == WINHTTP_INVALID_STATUS_CALLBACK )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomTrace(  WINHTTP, 
                    L_ERROR, 
                    "CWinHttpMgr::Send: Failed to set status callback flags.  RequestId:[0x%I64X] ServerName=%S, Port=%d, hr = %x", 
                    pContext->_qwIdentifier,
                    pContext->_wszServerIp,
                    pContext->_nServerPort,
                    hr);
        
        goto Exit;
    }

    // set the context marker with no bytes read.
    pContext->_dwLastRead = NO_BYTES_READ;
    
    // Continued in AsyncCallback:WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE            
    httpResult = WinHttpSendRequest( pContext->_hRequest,
                                    A2W((char*)pHeader), 
                                    cHeader,
                                    pBuffer,
                                    cBuffer, 
                                    cBuffer,
                                    (DWORD_PTR)pContext
                                    );
    if (!httpResult)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());  
        XomTrace(  WINHTTP, 
                    L_ERROR, 
                    "CWinHttpMgr::Send: WinHttpSendRequest failed.  RequestId:[0x%I64X] ServerName=%S, Port=%d, hr = %x", 
                    pContext->_qwIdentifier,
                    pContext->_wszServerIp,
                    pContext->_nServerPort,
                    hr);
        goto Exit;
    }

    return S_OK;

Exit:

    if ( pContext && pContext->_hRequest )
    {
        WinHttpCloseHandle( pContext->_hRequest );
    }

    if ( pContext && pContext->_hConnect)
    {                
        m_pConnectionPool->ReleaseWinHttpConnection( pContext->_hConnect, pContext->_wszServerIp, pContext->_nServerPort);
    }

    return hr;
}
    

//-----------------------------------------------------------------------------
//  Initialize:  initial the manager object.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::Initialize( CWinHttpCallback* pCallback )
{
    HRESULT hr = S_OK;

    XOMASSERT( pCallback != NULL );
    XOMASSERT( m_pCallback == NULL );
    XOMASSERT( m_pConnectionPool == NULL );
    
    // add our reference to the callback
    pCallback->AddRef();
    m_pCallback = pCallback;

    // initialize http object.
    m_hInternet = WinHttpOpen(  c_wszUserAgent, 
                                WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 
                                NULL, 
                                NULL, 
                                WINHTTP_FLAG_ASYNC );
    if ( m_hInternet == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomTrace( WINHTTP, L_ERROR, "CWinHttpMgr::Initialize:  Failed to create connection pool.  HR = 0x%x", hr);
        goto Exit;        
    }


    // create the connection pool.
    hr = CWinHttpConnectionPool::CreateInstance( m_hInternet );
    if ( FAILED(hr) && hr != E_FAIL )
    {
        XomTrace( WINHTTP, L_ERROR, "CWinHttpMgr::Initialize:  Failed to create connection pool.  HR = 0x%x", hr);
        goto Exit;        
    }

    m_pConnectionPool = CWinHttpConnectionPool::GetInstance();
    XOMASSERT( m_pConnectionPool != NULL );

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Shutdown: shuts down the object.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::Shutdown()
{
    HRESULT hr = S_OK;
    if ( m_pCallback == NULL )
    {
        goto Exit;
    }
    
    // release the pool then the callback...
    //   this is important to avoid concurrency problems.
    m_pConnectionPool->Release();

    WinHttpCloseHandle( m_hInternet );

    m_pCallback->Release();
    
    m_pCallback = NULL;
    m_pConnectionPool = NULL;

Exit: 
    return hr;
}

//-----------------------------------------------------------------------------
//  WinHttpCallback
//      Here is a typical callback order for a successfull http request
//  [0x10] WINHTTP_CALLBACK_STATUS_SENDING_REQUEST
//  [0x20] WINHTTP_CALLBACK_STATUS_REQUEST_SENT
//  [0x400000] WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE
//  [0x40] WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE
//  [0x80] WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED
//  [0x8000] WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE
//  [0x40] WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE
//  [0x80] WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED
//  [0x20000] WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
//
//  [0x40000] WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
//  [0x80000] WINHTTP_CALLBACK_STATUS_READ_COMPLETE
//
//  those two notifications are repeated as a number of data blocks returned by the WebCache
//
//  [0x40000] WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE - last one, no data
//  [0x800] WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING - closing the request
//
//  In a case of failure  
//  [0x200000] WINHTTP_CALLBACK_STATUS_REQUEST_ERROR is received, with error specification,
//  move to cleanup
//-----------------------------------------------------------------------------

void __stdcall CWinHttpMgr::WinHttpCallback( 
                                HINTERNET hInternet, 
                                DWORD dwContext,
                                DWORD dwInternetStatus,
                                LPVOID lpvStatusInformation,
                                DWORD dwStatusInformationLength)
{
    HRESULT hr = S_OK;
    REQUEST_CONTEXT *pContext = NULL;
    WINHTTP_ASYNC_RESULT *pAR = NULL;
    CWinHttpMgr *pThis = CWinHttpMgr::GetInstance();

    // check that we've been created before this is called.
    if ( pThis == NULL || pThis->m_pCallback == NULL )
    {
        return;
    }
    
    pContext = (REQUEST_CONTEXT*)dwContext;

    XomTrace( WINHTTP, L_LOW, "CWinHttpMgr::WinHttpCallback: [0x%x], InfoLen: %d, requestId: [0x%I64X]", dwInternetStatus, dwStatusInformationLength, pContext->_qwIdentifier );
    
    switch (dwInternetStatus)
    {
        case WINHTTP_CALLBACK_STATUS_SENDING_REQUEST:
            hr = pThis->m_pCallback->OnSendingRequest( pContext );
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }
            break;
        case WINHTTP_CALLBACK_STATUS_REQUEST_SENT:
            hr = pThis->m_pCallback->OnRequestSent( pContext );
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }
            break;
        case WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE:
            hr = pThis->m_pCallback->OnReceivingResponse( pContext );
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }
            break;
        case WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED:
            hr = pThis->m_pCallback->OnResponseReceived( pContext );
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }
            break;
        case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
            // Prepare the request handle to receive a response.
            // Continued in WinHttpCallback:WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE            
            if ( !WinHttpReceiveResponse( pContext->_hRequest, NULL) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                pContext->_hrStatus = hr;
                XomTrace(  WINHTTP, 
                                L_ERROR, 
                                "CWinHttpMgr::WinHttpCallback:  Failed to call WinHttpReceiveResponse, Request: [0x%I64X], hr = [0x%x]", 
                                pContext->_qwIdentifier, 
                                hr );
                pThis->CompleteRequest( pContext, hr );
                break;
            }

            // tell the callback about the header.
            hr = pThis->m_pCallback->OnSendRequestComplete( pContext );
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }

            break;

        case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:  
            {
                DWORD cHeader = MAX_RETURN_HEADER_SIZE;
                BYTE pHeader[MAX_RETURN_HEADER_SIZE];
                
                hr = pThis->Header( pContext, pHeader, &cHeader);
                if( FAILED(hr) )
                {
                    pContext->_hrStatus = hr;
                    XomTrace(  WINHTTP, 
                                L_ERROR, 
                                "CWinHttpMgr::WinHttpCallback:  Failed to receive response header, Request: [%s], hr = [0x%x]", 
                                pContext->_qwIdentifier, 
                                hr );
                    pThis->CompleteRequest( pContext, hr );
                    break;
                }

                // tell the callback about the header.
                hr = pThis->m_pCallback->OnHeadersAvailable( pContext, pHeader, cHeader );
                if ( FAILED(hr) )
                {
                    pContext->_hrStatus = hr;
                    // Close the request and connect handles for this context.
                    pThis->CompleteRequest( pContext, hr );
                    break;
                }

                // Begin downloading the resource.
                hr = pThis->QueryData( pContext );
                if( FAILED(hr) )
                {
                    pContext->_hrStatus = hr;
                    XomTrace(  WINHTTP, 
                                L_ERROR, 
                                "CWinHttpMgr::WinHttpCallback:  QueryData Failed to receive WebCache response header, Request: [0x%I64X], hr = [0x%x]", 
                                pContext->_qwIdentifier, 
                                hr );
                    pThis->CompleteRequest( pContext, hr );
                    break;
                }
            }
            break;
        case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
            {
                // Begin downloading the resource.

                if (sizeof(DWORD) != dwStatusInformationLength)
                {
                    // data length is given as sizeof(DWORD) in status info
                    XomTrace( WINHTTP, L_ERROR, "Unexpected: Data available with bad data length param (%d), expected (%d)", dwStatusInformationLength, sizeof(DWORD) );
                    pThis->CompleteRequest( pContext, E_UNEXPECTED );
                    break;
                }

                pContext->_dwAvailableDataSize = *(PDWORD)lpvStatusInformation;

                DWORD cData = MAX_DATA_BUFFER_SIZE;
                BYTE pData[MAX_DATA_BUFFER_SIZE + 1];

                if ( pContext->_dwLastRead != 0 )
                {
                    // Otherwise, read the next block of data.
                    hr = pThis->ReadData( pContext, pData, &cData );
                    if ( FAILED(hr) )
                    {
                        // Close the request and connect handles for this context.
                        pContext->_hrStatus = hr;
                        pThis->CompleteRequest( pContext, hr );
                        break;
                    }

                    hr = pThis->m_pCallback->OnDataAvailable( pContext, pData, *((DWORD*)lpvStatusInformation) );
                    if ( FAILED(hr) )
                    {
                        // Close the request and connect handles for this context.
                        pContext->_hrStatus = hr;
                        pThis->CompleteRequest( pContext, hr );
                        break;
                    }
                }
                else
                {
                    // we're done reading.
                    pThis->CompleteRequest( pContext, S_OK );
                }

            }
            break;            
        case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
            hr = pThis->m_pCallback->OnReadComplete( pContext, lpvStatusInformation, dwStatusInformationLength );
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }
                    
            // Check for more data.
            hr = pThis->QueryData(pContext);
            if ( FAILED(hr) )
            {
                pContext->_hrStatus = hr;
                // Close the request and connect handles for this context.
                pThis->CompleteRequest( pContext, hr );
                break;
            }
            
            break;

        case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
            pAR = (WINHTTP_ASYNC_RESULT *)lpvStatusInformation;
            XomTrace( WINHTTP, L_ERROR, "CWinHttpMgr::WinHttpCallback: RequestId: [0x%I64X].Request failed error = 0x%x, dwResult = 0x%x", pContext->_qwIdentifier, pAR->dwError, pAR->dwResult);     
            
            hr = pThis->m_pCallback->OnError( pContext, HRESULT_FROM_WIN32(pAR->dwError), pAR->dwResult );
            pContext->_hrStatus = HRESULT_FROM_WIN32(pAR->dwError);

            pThis->CompleteRequest( pContext, HRESULT_FROM_WIN32(pAR->dwError) );
            break;

        case WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING:            
            pThis->m_pCallback->OnClose( pContext );
            break;

        default:
            break;
    }

    // release this reference.
    pThis->Release();    
}

//-----------------------------------------------------------------------------
//  CompleteRequest:  cleans up the request handle.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::CompleteRequest(REQUEST_CONTEXT *pContext, HRESULT hr)
{
    HRESULT hrFinal = S_OK;
    
    XomTrace( WINHTTP, L_LOW, "CWinHttpMgr::CompleteRequest: RequestId: [0x%I64X], HRESULT = 0x%x", pContext->_qwIdentifier, hr );     
    
    // Close the request and connect handles for this context.
    WinHttpCloseHandle(pContext->_hRequest);
    m_pConnectionPool->ReleaseWinHttpConnection(pContext->_hConnect, pContext->_wszServerIp, pContext->_nServerPort);

    return hrFinal;
}

//-----------------------------------------------------------------------------
//  QueryData:  Queries WinHttp for more data.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::QueryData(REQUEST_CONTEXT *cpContext)
{
    HRESULT hr = S_OK;

    // Continued in WinHttpCallback:WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE            
    if (!WinHttpQueryDataAvailable(cpContext->_hRequest, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( WINHTTP, L_ERROR, "CWinHttpMgr::QueryData: RequestId [0x%I64X], Query data failed hr = 0x%x", cpContext->_qwIdentifier, hr);
    }
    return hr;
}

//-----------------------------------------------------------------------------
//  Header:  Gets response header from reply.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::Header(REQUEST_CONTEXT *cpContext, BYTE* pHeaderBuffer, DWORD* pdwSize ) 
{
    HRESULT hr = S_OK;
    DWORD dwSize = *pdwSize;
    
    // First Use WinHttpQueryHeaders to obtain the content length.
    if (!WinHttpQueryHeaders( cpContext->_hRequest, 
                                WINHTTP_QUERY_CONTENT_LENGTH,
                                WINHTTP_HEADER_NAME_BY_INDEX, 
                                pHeaderBuffer, 
                                &dwSize, 
                                WINHTTP_NO_HEADER_INDEX)
                            )
    {
        // Don't know what content length is.
        // Must be chunked, set to 0 to represent chunked encoding
        cpContext->_dwContentLength = 0;
    }
    else
    {
        cpContext->_dwContentLength = _wtoi((WCHAR*)pHeaderBuffer);
    }
    
    // Use WinHttpQueryHeaders to obtain the full header buffer.
    if (!WinHttpQueryHeaders( cpContext->_hRequest, 
                                WINHTTP_QUERY_RAW_HEADERS_CRLF,
                                WINHTTP_HEADER_NAME_BY_INDEX, 
                                pHeaderBuffer, 
                                pdwSize, 
                                WINHTTP_NO_HEADER_INDEX ) 
                            )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( WINHTTP, L_ERROR, "CWinHttpMgr::Header: RequestId [0x%I64X], Fail to read response header, hr = 0x%x", cpContext->_qwIdentifier, hr);
        goto Exit;
    }

Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  ReadData:  Reads data from winhttp.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::ReadData(REQUEST_CONTEXT *cpContext, BYTE* pDataBuffer, DWORD* pcDataBuffer ) 
{
    HRESULT hr = S_OK;
    DWORD dwBytesToRead = *pcDataBuffer;
    
    // Read the available data.
    // Continued in AsyncCallback:WINHTTP_CALLBACK_STATUS_READ_COMPLETE            
    if (!WinHttpReadData(   cpContext->_hRequest, 
                            (LPVOID)pDataBuffer,
                            dwBytesToRead, 
                            &(cpContext->_dwLastRead) )
        )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace( WINHTTP, L_ERROR, "CWinHttpMgr::ReadData: RequestId [0x%I64X]. WinHttpReadData failed, hr = 0x%x", cpContext->_qwIdentifier, hr );
        goto Exit;
    }

Exit:
    return hr;
}


//-----------------------------------------------------------------------------
#ifdef _DEBUG

const char c_szUnitTest_HttpHeader[] = "Host: UdpSender\nUser-Agent: WinHttpMgr\nContent-Length: 22\nConnection: Keep-Alive";
const char c_szUnitTest_HttpBody[] = "<html>Sender.</html>\n";


// unit test callback function.

//-----------------------------------------------------------------------------
// UNITTEST_Callback
//-----------------------------------------------------------------------------
class UNITTEST_Callback:  public CWinHttpCallback
{
    public:
    virtual LONG AddRef()	{ return 0; }
    virtual LONG Release()	{ return 0; }

    void Init()
    {
        m_hEventTestComplete = CreateEvent( NULL, TRUE, FALSE, NULL );
        XOMASSERT( m_hEventTestComplete != NULL );
    }

    void Shutdown()
    {
        CloseHandle(m_hEventTestComplete);
    }
    
    virtual HRESULT OnClose( 
                        REQUEST_CONTEXT* pContext                        
                        ) 
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnClose:  Closing [0x%I64X].", pContext->_qwIdentifier );
        SetEvent(m_hEventTestComplete);
        return S_OK;
    }

    virtual HRESULT OnError( 
                        REQUEST_CONTEXT* pContext,
                        HRESULT hr,
                        DWORD_PTR dwResult
                        ) 
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnError:  Error [0x%I64X], hr = 0x%X, Result=0x%X.", pContext->_qwIdentifier, hr, dwResult );
        SetEvent(m_hEventTestComplete);
        return S_OK;
    }


    virtual HRESULT OnSendingRequest(
                        REQUEST_CONTEXT* pContext
                        )
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnSendingRequest:  Sending request [0x%I64X].", pContext->_qwIdentifier );
        return S_OK;
    }

                        
    virtual HRESULT OnRequestSent(
                        REQUEST_CONTEXT* pContext
                        ) 
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnRequestSent:  Request sent [0x%I64X].", pContext->_qwIdentifier );
        return S_OK;        
    }

    virtual HRESULT OnSendRequestComplete(
                        REQUEST_CONTEXT* pContext
                        )
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnSendRequestComplete: [0x%I64X].", pContext->_qwIdentifier );
        return S_OK;        
    }

    virtual HRESULT OnReceivingResponse(
                        REQUEST_CONTEXT* pContext
                        )
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnReceivingResponse: [0x%I64X].", pContext->_qwIdentifier );
        return S_OK;        
    }        

    virtual HRESULT OnHeadersAvailable(
                        REQUEST_CONTEXT* pContext,
                        LPVOID lpData,
                        DWORD  cData
                        ) 
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnReceivingResponse: [0x%I64X].  Size=%d, Data=%S", pContext->_qwIdentifier, cData, (WCHAR*)lpData );
        return S_OK;        
    }
    
    virtual HRESULT OnResponseReceived(
                        REQUEST_CONTEXT* pContext
                        ) 
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnResponseReceived: [0x%I64X]", pContext->_qwIdentifier );
        return S_OK;        
    }                        

    virtual HRESULT OnDataAvailable(
                        REQUEST_CONTEXT* pContext,
                        LPVOID lpData,
                        DWORD  cData
                        ) 
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnDataAvailable: [0x%I64X].  Size=%d", pContext->_qwIdentifier, cData );
        return S_OK;        
    }                        
                        

    virtual HRESULT OnReadComplete(
                        REQUEST_CONTEXT* pContext,
                        LPVOID lpData,
                        DWORD  cData
                        )
    {
        XomTrace( UNITTEST, L_NORMAL, "UNITTEST_Callback::OnReadComplete: [0x%I64X].  Size=%d", pContext->_qwIdentifier, cData );
        return S_OK;        
    }                        

    HANDLE m_hEventTestComplete;
};

//-----------------------------------------------------------------------------
//  UnitTest:  Unittest for this module.
//-----------------------------------------------------------------------------
HRESULT CWinHttpMgr::UnitTest()
{
    HRESULT hr = S_OK;
    UNITTEST_Callback utCallback;
    REQUEST_CONTEXT ctxt;

    ZeroMemory( &ctxt, sizeof(ctxt) );

    utCallback.Init();
    
    // 1.  successful initialization.    
    hr = Initialize( &utCallback );
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CWinHttpMgr::UnitTest: Failed to initialize test. hr = 0x%X", hr );
        goto Exit;
    }

    // 2. Send some data 
    hr = Send( &ctxt, 
                L"lohab-s", 
                (WORD)8090, 
                L"GET", 
                L"testcity/WebForm1.aspx", 
                (BYTE*)c_szUnitTest_HttpHeader, 
                sizeof( c_szUnitTest_HttpHeader), 
                (BYTE*)c_szUnitTest_HttpBody,
                sizeof( c_szUnitTest_HttpBody ));
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CWinHttpMgr::UnitTest: Failed to perform send. hr = 0x%X", hr );
        goto Exit;
    }

    WaitForSingleObject( utCallback.m_hEventTestComplete, INFINITE );
    
    // 3.  shutdown object now.
    hr = Shutdown();
    if ( FAILED(hr) )
    {
        XomTrace( UNITTEST, L_ERROR, "CWinHttpMgr::UnitTest: Failed to shutdown test. hr = 0x%X", hr );
        goto Exit;
    }
    
Exit:
    return hr;
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\HttpListener\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\stress\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\UdpSender\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\WinHttpConnectionPool.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) UDP Adaptor (UDPAdpt) (tm). 
//  Copyright (C) 2003. All rights reserved.
//
//  FILE: WinHttpConnectionPool.cpp
//
//  Implementation of the win http connection pool interface.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "WinHttpConnectionPool.h"

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------
XomDefineArea(WINHTTP);

#ifdef _DEBUG
XomImportArea(UNITTEST);
#endif

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Globals
//-----------------------------------------------------------------------------
CWinHttpConnectionPool* CWinHttpConnectionPool::m_pThis   = NULL;
LONG                    CWinHttpConnectionPool::m_lCount  = 0;

//-----------------------------------------------------------------------------
//  Constant
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  Local Function Declaration
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  CWinHttpConnectionPool Implementation
//-----------------------------------------------------------------------------
CWinHttpConnectionPool::CWinHttpConnectionPool()
{
    m_nDest = 0;
    ZeroMemory( m_dest, sizeof(m_dest) );

    ZeroMemory( &m_hSession, sizeof(m_hSession) );
    InitializeCriticalSection( &m_cs );
}

CWinHttpConnectionPool::~CWinHttpConnectionPool()
{
    DeleteCriticalSection( &m_cs );
    int i,j;

    for (i=0; i<m_nDest; ++i)
    {
        for (j=0; j<m_dest[i].nConnect; ++j)
        {
            WinHttpCloseHandle(m_dest[i].hConnect[j]);
        }
        m_dest[i].nConnect = 0;
    }
    m_nDest = 0;
}

HRESULT CWinHttpConnectionPool::CreateInstance( HINTERNET hSession )
{
    HRESULT hr = S_OK;
    
    if ( m_pThis != NULL )
    {        
        hr = E_FAIL;
        goto Exit;
    }

    m_pThis = new CWinHttpConnectionPool();
    m_pThis->m_hSession = hSession;
    
Exit:
    return hr;
}

ULONG CWinHttpConnectionPool::AddRef()
{
    LONG lResult = InterlockedIncrement( &m_lCount );
    return( lResult );
}

CWinHttpConnectionPool* CWinHttpConnectionPool::GetInstance()
{
    LONG lResult = InterlockedIncrement( &m_lCount );    
    return( m_pThis );
}

ULONG CWinHttpConnectionPool::Release()
{
    LONG lResult = InterlockedDecrement( &m_lCount );
    if( 0 == lResult )
    {
        delete m_pThis;
        m_pThis = NULL;
        return S_OK;
    }

    return S_FALSE;
}


//-----------------------------------------------------------------------------
//  GetWinHttpConnection:  Gets a win HTTP connection to the desired server.
//-----------------------------------------------------------------------------
HINTERNET CWinHttpConnectionPool::GetWinHttpConnection(LPCWSTR pswzServerName, INTERNET_PORT nServerPort)
{
    EnterCriticalSection( &m_cs );

    HINTERNET hConnect = NULL;
    int i;

    for (i=0; i<m_nDest; ++i)
    {
        if (nServerPort == m_dest[i].nPort && wcscmp(m_dest[i].wszIp,pswzServerName) == 0)
        {
            if (m_dest[i].nConnect == 0)
            {
                hConnect = WinHttpConnect( m_hSession, pswzServerName, nServerPort, 0 );
                goto Cleanup;
            }
            else
            {
                m_dest[i].nConnect--;
                hConnect = m_dest[i].hConnect[m_dest[i].nConnect];
                goto Cleanup;
            }
        }
    }

    if (m_nDest == MAX_DESTINATIONS)
    {
        XomTrace( WINHTTP, L_ERROR , "CWinHttpConnectionPool::GetWinHttpConnection:  More than %d WinHttpConnection destinations needed.", m_nDest );
    }
    else
    {
        wcsncpy(m_dest[m_nDest].wszIp, pswzServerName, MAX_IPADDRESS_LENGTH - 1);
        m_dest[m_nDest].nPort = nServerPort;
        m_dest[m_nDest].nConnect = 0;
        m_nDest++;
    }

    hConnect = WinHttpConnect( m_hSession, pswzServerName, nServerPort, 0 );
    
Cleanup:
    LeaveCriticalSection( &m_cs );
    return hConnect;
}

//-----------------------------------------------------------------------------
//  ReleaseWinHttpConnection:  Releases a win HTTP connection to the 
//    to the specified server..
//-----------------------------------------------------------------------------
void CWinHttpConnectionPool::ReleaseWinHttpConnection(HINTERNET hConnect, LPCWSTR pswzServerName, INTERNET_PORT nServerPort)
{
    EnterCriticalSection( &m_cs );
    int i;

    for (i=0; i<m_nDest; ++i)
    {
        if (nServerPort == m_dest[i].nPort && wcscmp(m_dest[i].wszIp,pswzServerName) == 0)
        {
            if (m_dest[i].nConnect == MAX_CONNECTIONS)
            {
                XomTrace( WINHTTP, L_ERROR , "CWinHttpConnectionPool::ReleaseWinHttpConnection:  More than %d WinHttpConnection connections needed.", m_nDest );
            }
            else
            {
                m_dest[i].hConnect[m_dest[i].nConnect] = hConnect;
                m_dest[i].nConnect++;
            }
        }
    }
    
    LeaveCriticalSection( &m_cs );
}

#ifdef _DEBUG

HRESULT CWinHttpConnectionPool::UnitTest()
{
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\stress\UAStress.cs ===
using System;

namespace xonline.utilities.udpadpt.test.stress 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class UAStress
	{
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            bool bRun = true;
            long suc = 0;
            long fail = 0;
            long timeout = 0;
            long lifetime = 0;

            long total = 0;

            string output = "";

            StressMgr sm = new StressMgr( args[0] );

            while ( bRun )
            {
                switch( Console.Read() )
                {
                    case 'b':
                    {
                        sm._stats.GetStats( ref suc, ref fail, ref timeout, ref lifetime );

                        total = suc + fail + timeout;

                        output =  "\nSuccess -->  " + (suc/lifetime).ToString() + " per second,  Total:  " + suc.ToString() + "\n";
                        output += "Failed  -->  " + (fail/lifetime).ToString() + " per second,  Total:  " + fail.ToString() + "\n";
                        output += "Timeout -->  " + (timeout/lifetime).ToString() + " per second,  Total:  " + timeout.ToString() + "\n";
                        output += "Total   -->  " + (total/lifetime).ToString() + " per second,  Total:  " + total.ToString() + "\n";


                        Console.Write( output );
                    }
                        break;
                    case 'q':
                    {
                        bRun = false;
                    }
                        break;
                }
            }

            sm.Close();
            sm._stats.GetStats( ref suc, ref fail, ref timeout, ref lifetime );

            total = suc + fail + timeout;

            output +=  "Success            -->  " + (suc/lifetime).ToString() + " per second,  Total:  " + suc.ToString() + "\n";
            output += "Failed             -->  " + (fail/lifetime).ToString() + " per second,  Total:  " + fail.ToString() + "\n";
            output += "Timeout            -->  " + (timeout/lifetime).ToString() + " per second,  Total:  " + timeout.ToString() + "\n";
            output += "Total              -->  " + (total/lifetime).ToString() + " per second,  Total:  " + total.ToString() + "\n";

            Console.Write( output );

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\HttpListener\HttpListener.cs ===
using System;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;

namespace xonline.utilities.udpadpt.test.httplistener 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class HttpListener
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            bool bRun = true;

            try
            {
                if ( args.Length < 2 )
                {
                    throw new Exception("Not enough args!!!!  Usage:  HttpListener Ip Port");
                }

                ListenerThread lt = new ListenerThread( args[0], Int32.Parse(args[1]) );

                lt.Start();

                while ( bRun )
                {
                    switch( Console.Read() )
                    {
                        case 'q':
                        {
                            bRun = false;
                        }
                            break;
                    }
                }

                lt.Close();
            }
            catch ( Exception e )
            {
                Console.WriteLine( "Error:  "  + e.ToString() );
            }
		}
	}

    public class ListenerThread
    {
        protected TcpListener   _tcp;
        protected Thread        _internalThread;
        protected string        _Ip;
        protected int           _port;

        public ListenerThread( string Ip, int port )
        {
            _Ip = Ip;
            _port = port;

            IPAddress ipAddress = Array.Find(Dns.GetHostEntry(Ip).AddressList,
                                        delegate(IPAddress ip)
                                        { return ip.AddressFamily == AddressFamily.InterNetwork; });

            _tcp = new TcpListener( ipAddress, port );

            ThreadStart ts = new ThreadStart( Run );
            _internalThread = new Thread(ts);

        }

        public void Start()
        {
            _tcp.Start();
            _internalThread.Start();            
        }

        public void Close()
        {
            _tcp.Stop();
            _internalThread.Abort();
            _internalThread = null;
        }

        private void Run()
        {
            TcpClient tc = null;

            // do until told otherwise.
            while (true)
            {
                try
                {
                    tc = null;
                    while ( ! _tcp.Pending() )
                    {
                        System.Threading.Thread.Sleep( 500 );
                    }

                    tc = _tcp.AcceptTcpClient();

                    // read the http request.
                    byte[] buffer = new byte[MAX_DATA_SIZE];
                    int bytesRead = 0;
                    bytesRead = tc.GetStream().Read( buffer, 0, MAX_DATA_SIZE );
                    if ( bytesRead == MAX_DATA_SIZE )
                    {
                        throw new Exception("Buffer not big enough. Asked: " + MAX_DATA_SIZE + " Got: " + bytesRead );
                    }
                    
                    string msg = ASCIIEncoding.ASCII.GetString( buffer, 0, bytesRead );


                    // print the contents...
                    Console.Write( "ListenerThread::Run:(Msg)\n" + msg + "\n\n COMPLETE-- \n\n" );
                    
                    // post the http response.
                    buffer = ASCIIEncoding.ASCII.GetBytes( postreply );
                    tc.GetStream().Write( buffer, 0, buffer.Length );
                }
                catch ( ThreadAbortException ae )
                {
                    string something = ae.Message;
                    break;
                }
                catch ( Exception e )
                {
                    string something = e.Message;
                    // do something with e.
                    Console.WriteLine( "ListenerThread::Run:(Error)  " + something );
                }
                finally
                {
                    if ( tc != null )
                    {
                        // close connection if we have one.
                        tc.GetStream().Close();
                        tc.Close();
                    }
                }
            }
        }

        private const string postreply = "HTTP/1.1 200 OK\r\nServer:HttpListener\r\nPRAGMA:no-cache\r\nContent-Type:text/html\r\nConnection:closed\r\n\r\n<html>OK</html>";
        private const int MAX_DATA_SIZE = 65536;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\stress\StressMgr.cs ===
using System;
using System.Threading;
using System.Xml;
using System.Net;
using System.Net.Sockets;
using System.Timers;

namespace xonline.utilities.udpadpt.test.stress 
{
    // used to store data for test cases.
    public struct TestCase
    {
        public string _payload;
        public bool   _result;
        public int    _timeout;
        public int    _port;
    }

    // statistics structure
    public class CStressStats
    {
        protected long _success;
        protected long _fail;
        protected long _timeout;
        protected DateTime _startTime;

        public void GetStats( 
            ref long success, 
            ref long fail, 
            ref long timeout,
            ref long timeIntervalInSecs)
        {
            DateTime dt;
            TimeSpan tsNow;
            TimeSpan tsStart;

            lock( this )
            {
                // copy out the current values and unlock.
                success = _success;
                fail = _fail;
                timeout = _timeout;
                dt = DateTime.Now;
            }

            tsNow = new TimeSpan( dt.Ticks );
            tsStart = new TimeSpan( _startTime.Ticks );

            timeIntervalInSecs = (long)((tsNow - tsStart).TotalSeconds);
        }

        public void INC_Success()
        {
            lock( this )
            {
                _success++;
            }
            Console.Write("+");
        }

        public void INC_Fail()
        {
            lock( this )
            {
                _fail++;
            }
            Console.Write("-");
        }

        public void INC_Timeout()
        {
            lock( this )
            {
                _timeout++;
            }
            Console.Write("X");
        }

        public void Start_Time()
        {
            lock(this)
            {
                _startTime = DateTime.Now;
            }
        }

    }

    /// <summary>
    /// Summary description for StressComponent.
    /// </summary>
    public class StressMgr
    {
        protected StressThread[]    _aStressThreadList;
        protected int               _numberOfThreads;
        protected int               _numberOfIPs;
        protected CfgIPAddr[]       _IPAddrs;
        protected int               _numberOfTestCases;
        protected TestCase[]        _testcases;

        public CStressStats         _stats;


        public StressMgr( string xmlCfgFileName )
        {
            // load form xml ini file.
            LoadConfig( xmlCfgFileName );

            // create teh statistics.
            _stats = new CStressStats();
            
            // create and start the threads.
            CreateThreads();
        }

        public void Close()
        {
            // start all the threads.
            for ( int nCount = 0; nCount < _numberOfThreads; nCount++ )
            {
                _aStressThreadList[nCount].Close();
            }            
        }

        private void LoadConfig( string xmlCfgFileName )
        {
            XmlDocument cfg = new XmlDocument();
            int nCount = 0;

            //Load the the document with the last book node.
            XmlTextReader reader = new XmlTextReader( xmlCfgFileName );
            reader.WhitespaceHandling = WhitespaceHandling.None;
            reader.MoveToContent();
            cfg.Load(reader);

            XmlElement uatest = cfg.DocumentElement;
            XmlNodeList nl = uatest.SelectNodes( "//uatest/stress/config/threads" );

            // we'll only consider the first setting.
            _numberOfThreads = int.Parse((nl[0].Attributes.GetNamedItem("number")).Value);
            
            // load the xds ip configuration.
            nl = uatest.SelectNodes( "//uatest/stress/config/ua" );
            _numberOfIPs = nl.Count;

            _IPAddrs = new CfgIPAddr[_numberOfIPs];
            foreach( XmlNode xn in nl )
            {
                _IPAddrs[nCount]._ipAddr     = xn.Attributes.GetNamedItem("ip").Value;
                _IPAddrs[nCount]._nUsagePct  = int.Parse(xn.Attributes.GetNamedItem("usagePct").Value);

                nCount++;
            }

            // load the test cases.
            nl = uatest.SelectNodes( "//uatest/stress/cases" );
            _numberOfTestCases = nl.Count;

            // reset the counter;
            nCount = 0;

            // setup up the array.
            _testcases = new TestCase[_numberOfTestCases];
            foreach( XmlNode xn in nl )
            {
                _testcases[nCount]._payload             = xn.Attributes.GetNamedItem("payload").Value;
                _testcases[nCount]._timeout             = int.Parse(xn.Attributes.GetNamedItem("timeout").Value);
                _testcases[nCount]._result              = (bool.Parse(xn.Attributes.GetNamedItem("result").Value));
                _testcases[nCount]._port                = int.Parse(xn.Attributes.GetNamedItem("port").Value);
                nCount++;
            }
        
        }

        // responsible for setting up the threads and starting them.
        private void CreateThreads()
        {
            int nCount = 0;
            Random rand = new Random();
            int totalPct = 0;

            // create the thread list.
            _aStressThreadList = new StressThread[_numberOfThreads];

            // get the total percentage these amount to.
            foreach( CfgIPAddr cia in _IPAddrs )
            {
                totalPct += cia._nUsagePct;
            }

            // create each thread with different params.
            for ( nCount = 0; nCount < _numberOfThreads; nCount++ )
            {
                string chosenRemoteIp = "";
                int chosenRemotePort = 0;
                int selection = 0;
                int nRange = 0;

                selection = rand.Next( totalPct );

                // check which sector the selection fell into.
                for ( int nX = 0; nX < _numberOfIPs; nX++ )
                {
                    // check the range
                    if ( selection >= nRange && selection <= ( nRange + _IPAddrs[nX]._nUsagePct ))
                    {
                        // set the default values... we're using this one.
                        chosenRemoteIp      = _IPAddrs[nX]._ipAddr;
                        chosenRemotePort    = _IPAddrs[nX]._port;
                        break;
                    }
                    // move to the next sector.
                    nRange += _IPAddrs[nX]._nUsagePct;
                }

                // figure out which test case this thread will run.
                selection = rand.Next( _numberOfTestCases );

                _aStressThreadList[nCount] = new StressThread( chosenRemoteIp, _testcases[selection]._port, _testcases[selection], _stats );
            }

            // set the starting time stamp.
            _stats.Start_Time();

            // start all the threads.
            for ( nCount = 0; nCount < _numberOfThreads; nCount++ )
            {
                _aStressThreadList[nCount].Start();
            }

        }

        protected struct CfgIPAddr
        {
            public string _ipAddr;
            public ushort _port;
            public int    _nUsagePct;
        }

    }


    public class StressThread
    {
        protected Socket        _udp;
        protected Thread        _internalThread;
        protected string        _remoteIpAddr;
        protected int           _port;
        protected TestCase      _testcase;
        protected CStressStats  _stats;

        public StressThread( string remoteIpAddr, int port, TestCase testcase, CStressStats stats )
        {
            _remoteIpAddr = remoteIpAddr;
            _port = port;

            _testcase = testcase;

            _stats = stats;

            _udp = new Socket( AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            // bind to the local host.
            IPHostEntry localHE = Dns.GetHostByName(Dns.GetHostName());
				
            //Bind the UDP client to any local port chosen by the kernel.
            IPEndPoint localIpEP = new IPEndPoint( localHE.AddressList[0], 0 );
				
            _udp.Bind( localIpEP );

            ThreadStart ts = new ThreadStart( Run );
            _internalThread = new Thread(ts);

        }

        public void Start()
        {
            _internalThread.Start();
        }

        public void Close()
        {
            _internalThread.Abort();
            _internalThread = null;
            _udp.Close();
        }

        private void Run()
        {
            byte[] send = System.Text.ASCIIEncoding.ASCII.GetBytes( _testcase._payload );
            // do until told otherwise.
            while (true)
            {
                try
                {
                    byte[] recv = new byte[1500];

                    // send the UDP request.
                    if ( UdpSendAndReceive( _testcase._timeout, send, recv ) == _testcase._result )
                    {
                        _stats.INC_Success();
                    }
                    else
                    {
                        _stats.INC_Fail();
                    }
                }
                catch ( ThreadAbortException ae )
                {
                    string something = ae.Message;
                    break;
                }
                catch ( Exception e )
                {
                    string something = e.Message;
                    _stats.INC_Timeout();

                    // do something with e.
                }
            }
        }


        private bool UdpSendAndReceive( int timeOutInSecs, byte[] sendData, byte[] recvData )
        {
            System.Net.IPEndPoint remoteIPEP = null;
            bool bRes = true;
            int bytesSent = 0;
            int bytesRecv = 0;
                        
            try 
            {
                remoteIPEP = new IPEndPoint( IPAddress.Parse(_remoteIpAddr), _port );
		
                bytesSent = _udp.SendTo( sendData,  remoteIPEP );

                // ensure we sent the entire packet.
                if ( bytesSent != sendData.Length )
                {
                    throw new Exception( "The number of bytes sent does not equal the number of bytes in buffer.  bytesSent="
                        + bytesSent.ToString() + " data length=" + sendData.Length.ToString()
                        + " remote IP=" + _remoteIpAddr );
                }
                
                // poll for results
                if ( _udp.Poll( timeOutInSecs * 1000000, SelectMode.SelectRead ) )
                {
                    EndPoint remoteEP = (remoteIPEP);

                    // receive bytes.
                    bytesRecv = _udp.ReceiveFrom( recvData, ref remoteEP );

                }
                else
                {
                    bRes = false;
                }                
            }
            catch ( System.Exception exception )
            {
                string something = exception.Message;
                bRes = false;
            }

            return bRes;
        }

        private string GenerateRandomString( int size )
        {
            string result = "";
            byte[] randData = new byte[size];
            System.Text.ASCIIEncoding asci = new System.Text.ASCIIEncoding();

            System.Random rand = new System.Random();
            
            rand.NextBytes( randData );
            result = asci.GetString( randData );
            return result;
        }

    }
               
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\UdpSender\UdpSender.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;

namespace xonline.utilities.udpadpt.test.udpsender 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class UdpSender
	{
        // ----------------------------------
        // Constants
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------

        /// <summary>
        /// Constructor
        /// </summary>
        public UdpSender()
        {
            _testList   = null;
            _recvQueue  = null;
        }

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            // create a instance.
            UdpSender udps = new UdpSender();

            // set default values.
            udps._localIp = "localhost";
            udps._localPort = 2020;
            udps._remoteIp = "localhost";
            udps._remotePort = 10160;  // xArb port
            udps._timeout = 5;
            udps._retries = 1;

            // parse the command args... modify the default values based on results
            udps.ParseArgs( args );

            // initialize the system.
            udps.Init( udps._localIp, udps._localPort);

            Console.WriteLine("Udps:  Type message to send." );
            TestUdpSend test = new TestUdpSend( udps._udp , udps._recvQueue, udps._remoteIp, udps._remotePort, udps._retries, udps._timeout, Console.ReadLine()  );
            udps._testList.Add( test );

            // run the test cases.
            foreach ( TestCase tc in udps._testList )
            {
                tc.Run();
            }

            // monitor traffic until all are complete.
            udps.Monitor();

            // output results.
            foreach ( TestCase tc in udps._testList )
            {
                Console.WriteLine( "UDPS: " + tc.ToString() );
            }

            Console.ReadLine();
            // stop receiving.
            udps._recvQueue.StopReceiving();

        }

        /// <summary>
        /// ParseArgs:  Looks through the arguments
        /// </summary>
        protected void ParseArgs( string[] args )
        {
            int i = 0;

            for ( i = 0; i < args.Length - 1; i++ )
            {
                switch( args[i].ToLower() )
                {
                    case "/rip":
                        _remoteIp = args[i+1];
                        break;
                    case "/rport":
                        _remotePort = Int32.Parse( args[i+1] );
                        break;
                    case "/lip":
                        _localIp = args[i+1];
                        break;
                    case "/lport":
                        _localPort = Int32.Parse( args[i+1] );
                        break;
                    case "/t":
                        _timeout = Int32.Parse( args[i+1] );
                        break;
                    case "/r":
                        _retries = Int32.Parse( args[i+1] );
                        break;
                    case "/stress":
                        _retries = Int32.Parse( args[i+1] );
                        break;
                    default:
                        break;
                }
            }
        }

        /// <summary>
        /// Monitor:  Monitors the receiver queue until all test cases are complete.
        /// </summary>
        protected void Monitor()
        {
            bool allNotComplete = true;

            while (allNotComplete)
            {
                Object obj = null;

                // get an entry from the receiver queue.
                obj = _recvQueue.Pop();

                // see who this packet belongs too... if no one 
                //  then just drop it.
                for ( int nX = 0; nX < _testList.Count ; nX++ )
                {
                    TestCase tc = (TestCase)_testList[nX];

                    if ( tc.Process( obj ) )
                    {
                        break;
                    }
                }

                // check if all test cases are complete.
                allNotComplete = false;                
                for ( int nX = 0; nX < _testList.Count ; nX++ )
                {
                    TestCase tc = (TestCase)_testList[nX];
                    if ( ! tc.IsComplete() )
                    {
                        allNotComplete = true;
                        break;
                    }
                }

            }
        }

        /// <summary>
        /// Init:  Initialize the receiver and test cases based on config.
        /// </summary>
        protected void Init( string Ip, int port )
        {
            // create the test list.
            _testList = new List<TestCase>();
            
            // create a new udp socket.
            _udp = new Socket( AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            // bind to the local host.
            IPHostEntry localHE = Dns.GetHostEntry(Ip);

            
            //Bind the UDP client to any local port chosen by the kernel.
            IPEndPoint localIpEP = new IPEndPoint( 
                Array.Find(localHE.AddressList, delegate(IPAddress ip) { return ip.AddressFamily == AddressFamily.InterNetwork; }),
                port );
		
		    // bind the new socket to the local IP port.
            _udp.Bind( localIpEP );
        
            // set up the receiver queue.
            _recvQueue = new UdpsRecvQueue( _udp, 1500 );
            _recvQueue.BeginReceiving();
            
        }

        /// <summary>
        /// OutputHelp:  Outputs help data.
        /// </summary>
        protected void OutputHelp()
        {
            // TODO:  Complete this.
            Console.Write(  "udpsool: (Usage) Udps.exe <OPTIONS>\n" +
                            "/rip <remote hostname or Ip>\n" +
                            "/rport <remote port>\n" +
                            "/lip <local hostname or Ip>\n" +
                            "/lport <local port>\n" +
                            "/t <timeout in seconds>\n" +
                            "/r <number of retries>\n" +
                            "/stress <number of threads>\n" +
                            "\n"
                         );
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected UdpsRecvQueue  _recvQueue;
        protected List<TestCase> _testList;
        protected Socket         _udp;
        protected string         _localIp;
        protected int            _localPort;
        protected string         _remoteIp;
        protected int            _remotePort;
        protected int            _timeout;
        protected int            _retries;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\inc\lestver.h ===
/****************************************************************************
 *                                                                          *
 *      *Ver.H    -- version information for internal builds                *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VER_PRODUCTBUILD value.                                             *
 *                                                                          *
 *      NOTE: The file version for the Panorama DLL is established here,    *
 *      and this version is used as the "system version" (aka, "dash        *
 *      version" for the purpose of title updates, etc.  However, the       *
 *      "product version" value in the DLL's version resource is            *
 *      established by xboxverp.h, and is used to indicate the version of   *
 *      the associated Panorama SDK (and also of the corresponding XDK).    *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD line must contain the product           */
/* comments (Win9x or NT) and end with the build#<CR><LF>       */
/*--------------------------------------------------------------*/

#if _MSC_VER > 1000
#pragma once
#endif
#define VER_PRODUCTMAJORVERSION     12
#define VER_PRODUCTMINORVERSION     78
#define VER_PRODUCTBUILD            424
#define VER_PRODUCTBUILD_QFE        0

#define VER_FILEVERSION_STRING       "12.78"
#define VER_PRODUCTVERSION_STRING    VER_FILEVERSION_STRING
#define VER_FILEVERSION_STRING_W     L"12.78"
#define VER_PRODUCTVERSION_STRING_W  VER_FILEVERSION_STRING_W

#define VER_FILEBETA_STR         ""
#undef VER_FILEVERSION
#define VER_FILEVERSION          VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION       VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE

#if     (VER_PRODUCTBUILD < 10)
#define VER_FILEBPAD    "000"
#define VER_FILEBPAD_W L"000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_FILEBPAD    "00"
#define VER_FILEBPAD_W L"00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_FILEBPAD    "0"
#define VER_FILEBPAD_W L"0"
#else
#define VER_FILEBPAD
#define VER_FILEBPAD_W
#endif

#define VER_FILEVERSION_STR2(x,y)   VER_FILEVERSION_STRING    "." VER_FILEBPAD  #x  "."  #y
#define VER_FILEVERSION_STR2_W(x,y) VER_FILEVERSION_STRING_W L"." VER_FILEBPAD L#x L"." L#y
#define VER_FILEVERSION_STR1(x,y)   VER_FILEVERSION_STR2(x, y)
#define VER_FILEVERSION_STR1_W(x,y) VER_FILEVERSION_STR2_W(x, y)

#undef VER_FILEVERSION_STR
#define VER_FILEVERSION_STR       VER_FILEVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
#define VER_PRODUCTVERSION_STR    VER_FILEVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

#define VER_FILEVERSION_STR_W     VER_FILEVERSION_STR1_W(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
#define VER_PRODUCTVERSION_STR_W  VER_FILEVERSION_STR1_W(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

#if     (VER_PRODUCTBUILD_QFE >= 256)
#error  "QFE number cannot exceed 255"
#endif

/* default is nodebug */
#if defined(DBG) && DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if defined(BETA) && BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if defined(OFFICIAL_BUILD) && OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) LEET"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation."
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\UdpSender\RecvQueue.cs ===
using System;
using System.Net;
using System.Threading;
using System.Collections;
using System.Net.Sockets;

namespace xonline.utilities.udpadpt.test.udpsender 
{
    /// <summary>
    /// RecvQueue  (BASE CLASS):  Event driven queue.  Pop blocks when the queue is empty.
    ///      Push puts an element into the list and signals the event.
    ///     (Classic sleeping barber implementation.)
    /// </summary>
    public class RecvQueue
    {

        // ----------------------------------
        //  Methods
        // ----------------------------------

        /// <summary>
        /// Constructor
        /// </summary>
        public RecvQueue()
        {
            _syncObj = new Object();
            _pendingItems = new ManualResetEvent( false );
            _recvQueue = new Queue();

        }
            
        /// <summary>
        /// Pop:  Gets the first item from the queue.Ob
        /// </summary>
        public Object Pop()
        {
            Object result = null;

            // wait for something in the queue.
            while ( _pendingItems.WaitOne() )
            {
                lock( _syncObj )
                {
                    // make sure no one beat me to this point.
                    if ( 0 == _recvQueue.Count )
                    {
                        // DOH!!!  just go back and wait.
                        continue;
                    }

                    // get the item from the queue.
                    result = _recvQueue.Dequeue();

                    // if zero... reset the event.
                    if ( 0 == _recvQueue.Count )
                    {
                        _pendingItems.Reset();
                    }

                    break;
                }
            }

            return result;
        }

        /// <summary>
        /// Push:  Puts item into the queue.
        /// </summary>
        public void Push(Object item)
        {
            lock( _syncObj )
            {
                _recvQueue.Enqueue( item );
                _pendingItems.Set();
            }
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected Queue             _recvQueue;
        protected ManualResetEvent  _pendingItems;
        protected Object            _syncObj;

    }

    /// <summary>
    /// UdpsRecvQueue:  The Async UDP receiver queue that pushes incoming 
    ///     requests onto the queue.  
    ///     Assumes given socket already bound to port.
    /// </summary>
    public class UdpsRecvQueue : RecvQueue
    {
        // ----------------------------------
        //  constants
        // ----------------------------------
        protected const int pollLifeTimeInMicroSeconds = 500000;    // default of 5 seconds to poll.

        // ----------------------------------
        //  Methods
        // ----------------------------------

        /// <summary>
        /// Constructor
        /// </summary>
        public UdpsRecvQueue( Socket udpReceiver, int bufferSize )
        {
            ThreadStart ts = null;

            // set up receiver attributes
            _udp = udpReceiver;
            _readNoMore = false;
            _bufferSize = bufferSize;

            // set up the thread.
            ts = new ThreadStart( Run );
            _recvThread = new Thread( ts );
        }

        /// <summary>
        /// BeginReceiving:  Starts the Async
        /// </summary>
        public void BeginReceiving()
        {
            _readNoMore = false;
            _recvThread.Start();
        }

        /// <summary>
        /// StopReceiving:  Stops receiving after the next packet.
        /// </summary>
        public void StopReceiving()
        {
            _readNoMore = true;
        }

        // ----------------------------------
        //  Threads
        // ----------------------------------
        protected void Run()
        {           
            // loop still we're told to stop
            while( !_readNoMore )
            {
                try
                {    
                    UdpsPacket recvPacket = null;
                    byte[] msgBuffer = null;
                    IPEndPoint remoteIPEP = new IPEndPoint( 1, 1 );
                    EndPoint remoteEP = (EndPoint)remoteIPEP;
                    int bytesRecv = 0;

                    // poll the socket for activity.
                    if ( !_udp.Poll( pollLifeTimeInMicroSeconds, SelectMode.SelectRead ) )
                    {
                        // hmmm... nothing yet... let's see if we're suppose to quit?
                        continue;
                    }
             
                    // set up the memory to receive the packet.
                    msgBuffer = new byte[_bufferSize];

                    // receive that data.
                    bytesRecv = _udp.ReceiveFrom( msgBuffer, ref remoteEP );        

                    // create a packet for this received data.
                    recvPacket = new UdpsPacket( 
                        UdpsPacket.PacketType.RESPONSE, 
                        0, 
                        0, 
                        msgBuffer, 
                        remoteIPEP, 
                        _udp, 
                        this );

                    // post it.
                    Push( (Object)recvPacket );

                }
                catch( ThreadAbortException tae )
                {
                    // someone is trying to abort me... I'll be nice and go away.
                    string msg = tae.Message;
                    _readNoMore = true;
                }
                catch( ObjectDisposedException ode )
                {
                    // udp probably went away... close up.
                    string msg = ode.Message;
                    _readNoMore = true;
                }
                catch( SocketException se )
                {
                    // this is expected for ICMP.
                    string msg = se.Message;
                }
                catch( Exception e )
                {
                    // TODO:   Log or report something here...
                    Console.WriteLine( "Xdtool: (ERROR) " + e.Message );
                }
            }
        }


        // ----------------------------------
        //  Members
        // ----------------------------------
        protected Socket    _udp;
        private bool        _readNoMore;
        private int         _bufferSize;
        protected Thread    _recvThread;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\UdpSender\TestCase.cs ===
using System;
using System.Text;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.IO;


namespace xonline.utilities.udpadpt.test.udpsender 
{
    /// <summary>
    /// UdpsTestCase:  The base class for the test cases used by xdtool.
    /// </summary>
    public class TestCase : Object
    {
        // ----------------------------------
        //  Constants
        // ----------------------------------

        // the protocol version to be used by all requests for this program.
        public const int NumberOfRetriesBeforeTimeout   = 5;
        public const int DefaultTimeoutInSeconds        = 2;
        public const int DefaultRemotePort              = 8090;
        public const string DefaultRemoteIP             = "lohab-s";

        // ----------------------------------
        //  Type
        // ----------------------------------
        protected enum UDPTEST_STATE
        {
            NONE                = 0,
            COMPLETE            = 1,
            WAITING_RESPONSE    = 2,
        };

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestCase()
        {
            _resultstring = "Invalid";
        }

        /// <summary>
        /// Run:  executes the test case.  Should be overridden.
        /// </summary>
        public virtual void Run()
        {
            // override this method executing
            throw new Exception( "Method not supported." );
        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public virtual bool Process( Object packet )
        {
            // override this method executing
            throw new Exception( "Method not supported." );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public virtual bool VerifyOwnership( byte[] id )
        {
            // override this method executing
            throw new Exception( "Method not supported." );
        }

        /// <summary>
        /// IsComplete:  (Should be overridden) True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public virtual bool IsComplete()
        {
            throw new Exception("Please implement this function.");
        }

        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        /// </summary>
        public virtual int Result
        {
            get
            {
                return _result;
            }
        }


        /// <summary>
        /// ToString:  returns the result string for this entry.
        /// </summary>
        public override string ToString()
        {
            return _resultstring;
        }



        // ----------------------------------
        //  Members
        // ----------------------------------
        protected int       _result;
        protected string    _resultstring;
    }

    /// <summary>
    /// TestUdpSend:  .
    /// </summary>
    public class TestUdpSend: TestCase
    {
        // ----------------------------------
        //  Constant
        // ----------------------------------

        // ----------------------------------
        //  Methods
        // ----------------------------------
        public TestUdpSend( Socket udpSocket, UdpsRecvQueue recvQueue, string remoteIp, int remotePort, int numberOfRetires, int timeoutInSecs, string message )
        {
            _result = 0;
            _state = UDPTEST_STATE.NONE;
            _resultstring = "Udp Test:  Object created.";

            _udp = udpSocket;
            _recvQueue = recvQueue;
            _message = message;

            _numberOfRetries = numberOfRetires;
            _timeoutInSecs = timeoutInSecs;

            _remoteIp = new IPEndPoint(
                Array.Find(Dns.GetHostEntry(remoteIp).AddressList, delegate(IPAddress ip) { return ip.AddressFamily == AddressFamily.InterNetwork; }),
                remotePort );

            _packet     = null;
        }

        /// <summary>
        /// Run:  start, execute the test case.
        /// </summary>
        public override void Run()
        {
            byte[] buffer = null;

            // create http payload.
            buffer = ASCIIEncoding.ASCII.GetBytes( http_request_header + _message );

            // create the packet... this is the method we'll use to send the packet async.
            //   -  5 retries... after that it's safe to say it won't be coming back.
            _packet = new UdpsPacket( 
                UdpsPacket.PacketType.REQUEST,
                _numberOfRetries,
                _timeoutInSecs,
                buffer,
                _remoteIp,
                _udp,
                _recvQueue );

            // send the message.
            _packet.Send();

            // modify the state.
            _state = UDPTEST_STATE.WAITING_RESPONSE;
            _resultstring = "UDP Test:  Waiting.  The request has been sent, waiting for a reply.";
        }

        /// <summary>
        /// Process:  Takes a given packet returning true if it belongs to this case.
        /// </summary>
        public override bool Process( Object data )
        {
            UdpsPacket reply = (UdpsPacket)data;
            bool result = true;

            // Ensure this is our response.
            if ( reply.Type == UdpsPacket.PacketType.RESPONSE && !VerifyOwnership(reply.Message)  )
            {
                result = false;
                goto Exit;    
            }

            // tell the packet to stop processing
            _packet.Complete();

            // if it does...  determine our state.
            switch( _state )
            {
                case UDPTEST_STATE.WAITING_RESPONSE:
                {
                    _state = UDPTEST_STATE.COMPLETE;
                    if ( reply.Type == UdpsPacket.PacketType.REQUEST )
                    {
                        _result = 0;
                        // darn ... timeout... set our status to complete now... and set the result indicator.
                        _resultstring = "Udp Test:  Failed!  No reply was ever received.  "
                            + ".";
                        
                    }
                    else
                    {
                        // tell the packet not to do any more retries....
                        _resultstring = "Udp Test:  Success.";
                        _result = 1;
                    }
                }
                    break;
                case UDPTEST_STATE.COMPLETE:
                {
                    // this could be because of the timeout.... 
                    //   ignore the message.
                    // QUEUSTION:  Is this ok?  what if it's a delayed response?
                    _resultstring += "  Received additional responses.";
                }
                    break;
                case UDPTEST_STATE.NONE:
                default:
                {
                    throw new Exception( "Invalid MTU state." );
                }
            }

            // modify the state and result.
            string resp = System.Text.ASCIIEncoding.ASCII.GetString( reply.Message );
            _resultstring = _resultstring + "\n  Id = " + _message + "\nResponse=\n" + resp;

            Exit:
                return result;
        }

        /// <summary>
        /// IsComplete:  True if test case complete.
        /// </summary>
        /// <returns>Whether operation is complete or not.</returns>
        public override bool IsComplete()
        {
            return ( _state == UDPTEST_STATE.COMPLETE );
        }

        /// <summary>
        /// VerifyOwnership:  determines if a packet belongs to the test case.
        /// </summary>
        /// <param name="id">byte array of id to check</param>
        /// <returns>true if the id belongs to this test case.</returns>
        public override bool VerifyOwnership( byte[] id )
        {
            return true;
        }



        /// <summary>
        /// Result:  The final result of the test case...  set to false if not complete.
        ///     0 -- failed.
        ///     1 -- passed.
        /// </summary>
        public override int Result
        {
            get
            {
                if ( _state == UDPTEST_STATE.COMPLETE )
                {
                    return _result;
                }
                else
                {
                    return 0;
                }
            }
        }

        // ----------------------------------
        //  Members
        // ----------------------------------
        protected UDPTEST_STATE     _state;
        protected int               _numberOfRetries;
        protected int               _timeoutInSecs;
        protected IPEndPoint        _remoteIp;
        protected Socket            _udp;
        protected UdpsRecvQueue     _recvQueue;
        protected string            _message;

        private UdpsPacket           _packet;

        private const string http_request_header = "POST / HTTP/1.0\r\nAccept: */*\r\nUser-Agent: UdpSender\r\nHost: UdpSender\r\n\r\n";
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\utilities\udpadpt\test\UdpSender\UdpsPacket.cs ===
using System;
using System.Timers;
using System.Net;
using System.Net.Sockets;

namespace xonline.utilities.udpadpt.test.udpsender 
{
    /// <summary>
    /// UdpSender
    /// A carrier object to help handle sending and receiving UDP packets.
    /// The packet also carries the feature of executing it's own retries should no response
    /// be received in time.
    /// This shouldn't be necessary for Xbox code.
    /// </summary>
    public class UdpsPacket : object
    {
        // ----------------------------------
        //  Types
        // ----------------------------------
        public enum PacketType
        {
            REQUEST     = 0,
            RESPONSE    = 1,
        }

        public enum MessageState
        {
            NONE        = 0,
            SENDING     = 1,
            WAITING     = 2,            
            TIMEOUT     = 3,
            COMPLETE    = 4,
        }

        // ----------------------------------
        //  Methods
        // ----------------------------------

        /// <summary>
        /// Constructor
        /// </summary>
        public UdpsPacket( PacketType ptype, int numOfRetries, int timeoutInSecs, byte[] msg , IPEndPoint ipDest, Socket udpSocket, UdpsRecvQueue receiverQueue )
        {
            // set the sync object.
            _syncObj    = new Object();

            // set object members
            _msg        = msg;
            _packettype = ptype;
            _retries    = numOfRetries;
            _udp        = udpSocket;
            _dest       = ipDest;
            _recvQueue  = receiverQueue;
            
            // set the initial state.
            _state      = MessageState.NONE;
            
            // set the timer.
            _timer = new System.Timers.Timer( );
            if ( timeoutInSecs != 0 )
            {
                _timer.Elapsed += new ElapsedEventHandler(OnTimeout);
                _timer.Interval = (double)(timeoutInSecs * 1000);
                _timer.AutoReset = false;
                _timer.Enabled = false;
            }
            
            
        }

        /// <summary>
        /// Complete:  marks the packet as complete and ends the timeout waiting.
        /// </summary>
        public void Complete()
        {
            lock( _syncObj )
            {
                // modify the state
                _state = MessageState.COMPLETE;

                _timer.Stop();
            }

            // 
        }

        /// <summary>
        /// Send:  send that packet async.
        /// </summary>
        public void Send()
        {
            lock( _syncObj )
            {
                // if complete... don't resend.
                if ( _state == MessageState.COMPLETE )
                {
                    return;
                }

                // change the state.  
                _state = MessageState.SENDING;
            }
    
            // do the async send.
            _udp.BeginSendTo( 
                _msg, 
                0, 
                _msg.Length, 
                SocketFlags.None, 
                _dest, 
                new AsyncCallback( SendCallback ), 
                this );
        }

        /// <summary>
        /// HandleTimeout -- determines that state of this packet and resends it if necessary
        /// </summary>
        public void HandleTimeout()
        {
            bool bResend = false;
            lock( _syncObj )
            {
                switch( _state )
                {
                    case MessageState.WAITING:
                    {
                        _retries--;

                        // make sure we haven't used all the retries.
                        if ( _retries < 1 )
                        {
                            // don't send this again.
                            _retries = 0;
                            _state = MessageState.TIMEOUT;

                            // signal receiver queue that this entry has completed with a timeout.
                            _recvQueue.Push( (Object)this );
                            break;
                        }
                        
                        // mark the need for a retry.
                        bResend = true;

                    }
                        break;
                    case MessageState.COMPLETE:
                    {
                        // already done, we don't need to do anything.
                        _timer.Close();
                    }
                        break;
                    case MessageState.NONE:
                    case MessageState.SENDING:
                    case MessageState.TIMEOUT:
                    default:
                    {
                        throw new InvalidOperationException("This objects current state is invalid.  This is not possible!");
                    }
                }
            }            

            // if we were told to... then resubmit.
            if ( bResend )
            {
                try
                {
                    // otherwise ... re-send the message.
                    Send();
                }
                catch ( Exception e )
                {
                    // TODO: (lohab) Log this somehow!!!!!
                    Console.WriteLine( "Xdtool:  (ERROR) " + e.Message );
                }
            }

        }

        // ----------------------------------
        // Callbacks
        // ----------------------------------

        /// <summary>
        /// OnTimeout:  callback for the timer.  Resends message.
        /// </summary>
        protected void OnTimeout(object source, ElapsedEventArgs e)
        {
            _timer.Stop();
            HandleTimeout();
        }

        /// <summary>
        /// SendCallback:  callback for async sending.
        /// </summary>
        protected static void SendCallback(IAsyncResult ar) 
        {
            int bytesSent = 0;
            UdpsPacket objThis = null;

            try 
            {
                objThis = (UdpsPacket)ar.AsyncState;

                // Complete sending the data to the remote device.
                bytesSent = objThis._udp.EndSend(ar);

                // lock the node... modify the state and start the timer.
                lock( objThis.SyncObj )
                {
                    switch(objThis._state)
                    {
                        case MessageState.SENDING:
                        {
                            // move back the waiting state.
                            objThis._state = MessageState.WAITING;
                            objThis._timer.Start();
                        }
                            break;
                        case MessageState.COMPLETE:
                        {
                            // it's done.... we don't need to send.
                        }
                            break;
                        case MessageState.NONE:
                        case MessageState.WAITING:
                        case MessageState.TIMEOUT:
                        default:
                        {
                            throw new InvalidOperationException("This objects current state is invalid.  This is not possible!");
                        }
                    }
                }
            } 
            catch (Exception e) 
            {
                // TODO: (lohab) Log this somehow!!!!!
                Console.WriteLine( "Xdtool:  (ERROR) " + e.Message );
            }
        }

        // ----------------------------------
        //  Properties
        // ----------------------------------

        /// <summary>
        /// Message -- Gets the initialized byte array in the object.
        /// </summary>
        public byte[] Message
        {
            get
            {
                return _msg;
            }
            set
            {
                lock( _syncObj )
                {
                    if ( _state == MessageState.NONE )
                    {
                        _msg = value;
                    }
                }
            }
        }

        /// <summary>
        /// SyncObj -- get the sync object for this structure.
        /// </summary>
        protected Object SyncObj
        {
            get
            {
                return _syncObj;
            }
        }

        /// <summary>
        /// RecvQueue:  The receiver that received this packet.
        /// </summary>
        public UdpsRecvQueue RecvQueue
        {
            get
            {
                return _recvQueue;
            }
        }

        /// <summary>
        /// Type:  the packet type of this request.
        /// </summary>
        public PacketType Type
        {
            get
            {
                return _packettype;
            }
        }

        /// <summary>
        /// DestIp:  the destination of the packet.
        /// </summary>
        public IPEndPoint DestIp 
        {
            get
            {
                return _dest;
            }
            set
            {
                lock( _syncObj )
                {
                    if ( _state == MessageState.NONE )
                    {
                        _dest = value;
                    }
                }
            }
        }

        // ----------------------------------
        //  Memebers
        // ----------------------------------
        private byte[]          _msg;
        private int             _retries;
        private MessageState    _state;
        private Object          _syncObj;
        private Socket          _udp;
        private IPEndPoint      _dest;
        private UdpsRecvQueue    _recvQueue;
        private PacketType      _packettype;
        private Timer           _timer;
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\CloudServices\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\Configuration\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\CustomCultures\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\DiagnosticsDatabase\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\ReplaceXml\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\wsdl\ContentIngestionService.wsdl.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ContentIngestionService {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="CatalogServicesSoap", Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Media))]
    public partial class CatalogServices : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback PingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SearchOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCatalogIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExternalIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetEntityOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetEntity1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableEntityIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableCategoryIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableCategorySystemIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableRatingSystemIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableRatingValueIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableRatingDescriptorIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableLicenseTypeIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExternalFeedSourceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExternalFeedSource1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExternalFeedMappingObjectOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetExternalFeedMappingObject1OperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveExternalFeedMappingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveEntityOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetImageOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveImageOperationCompleted;
        
        private System.Threading.SendOrPostCallback SavePublishingBatchRequestOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetOfferOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveOfferOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMediaOfferOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPodcastOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPodcast1OperationCompleted;
        
        private System.Threading.SendOrPostCallback SavePodcastOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVideoOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveVideoOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVideoSeasonOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveVideoSeasonOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVideoSeriesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveVideoSeriesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetContributorRelationshipTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCountryOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCountry1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCurrencyOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCurrency1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCategorySystemOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCategorySystem1OperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveCategoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingSystemOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingSystem1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetArticleOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetArticle1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetContributorOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetContributor1OperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveVideoEncodingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveAudioEncodingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveContributorOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAudioEncodingOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetClientTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLocaleOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetImageFormatOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetImageSizeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMediaRelationshipTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPreviewMediaInstanceTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRoleOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetStoreOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTaskStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTasksByStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTasksOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAvailableTaskAsXMLOperationCompleted;
        
        private System.Threading.SendOrPostCallback PurgeTaskQueueOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveTaskOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveDRMTaskOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveTask1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVideoDefinitionOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVideoEncodingOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVisibilityLevelOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetVisibilityStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetProviderOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetProvider1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMetadataProviderOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMetadataProvider1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDRMLicenseIssuerOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDRMLicenseIssuer1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLicenseTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLicenseType1OperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveLicenseTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLicenseClassOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLicenseClass1OperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPricingRuleOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPricingRule1OperationCompleted;
        
        private System.Threading.SendOrPostCallback SavePricingRuleOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMediaTypeOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveGameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetGameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveGameContentOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetGameContentOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPaymentMethodOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPaymentMethod1OperationCompleted;
        
        /// <remarks/>
        public CatalogServices() {
            this.Url = "http://localhost/wsdlreflection.asmx";
        }
        
        /// <remarks/>
        public event PingCompletedEventHandler PingCompleted;
        
        /// <remarks/>
        public event SearchCompletedEventHandler SearchCompleted;
        
        /// <remarks/>
        public event GetCatalogIdCompletedEventHandler GetCatalogIdCompleted;
        
        /// <remarks/>
        public event GetExternalIdCompletedEventHandler GetExternalIdCompleted;
        
        /// <remarks/>
        public event GetEntityCompletedEventHandler GetEntityCompleted;
        
        /// <remarks/>
        public event GetEntity1CompletedEventHandler GetEntity1Completed;
        
        /// <remarks/>
        public event GetAvailableEntityIdCompletedEventHandler GetAvailableEntityIdCompleted;
        
        /// <remarks/>
        public event GetAvailableCategoryIdCompletedEventHandler GetAvailableCategoryIdCompleted;
        
        /// <remarks/>
        public event GetAvailableCategorySystemIdCompletedEventHandler GetAvailableCategorySystemIdCompleted;
        
        /// <remarks/>
        public event GetAvailableRatingSystemIdCompletedEventHandler GetAvailableRatingSystemIdCompleted;
        
        /// <remarks/>
        public event GetAvailableRatingValueIdCompletedEventHandler GetAvailableRatingValueIdCompleted;
        
        /// <remarks/>
        public event GetAvailableRatingDescriptorIdCompletedEventHandler GetAvailableRatingDescriptorIdCompleted;
        
        /// <remarks/>
        public event GetAvailableLicenseTypeIdCompletedEventHandler GetAvailableLicenseTypeIdCompleted;
        
        /// <remarks/>
        public event GetExternalFeedSourceCompletedEventHandler GetExternalFeedSourceCompleted;
        
        /// <remarks/>
        public event GetExternalFeedSource1CompletedEventHandler GetExternalFeedSource1Completed;
        
        /// <remarks/>
        public event GetExternalFeedMappingObjectCompletedEventHandler GetExternalFeedMappingObjectCompleted;
        
        /// <remarks/>
        public event GetExternalFeedMappingObject1CompletedEventHandler GetExternalFeedMappingObject1Completed;
        
        /// <remarks/>
        public event SaveExternalFeedMappingCompletedEventHandler SaveExternalFeedMappingCompleted;
        
        /// <remarks/>
        public event SaveEntityCompletedEventHandler SaveEntityCompleted;
        
        /// <remarks/>
        public event GetImageCompletedEventHandler GetImageCompleted;
        
        /// <remarks/>
        public event SaveImageCompletedEventHandler SaveImageCompleted;
        
        /// <remarks/>
        public event SavePublishingBatchRequestCompletedEventHandler SavePublishingBatchRequestCompleted;
        
        /// <remarks/>
        public event GetOfferCompletedEventHandler GetOfferCompleted;
        
        /// <remarks/>
        public event SaveOfferCompletedEventHandler SaveOfferCompleted;
        
        /// <remarks/>
        public event GetMediaOfferCompletedEventHandler GetMediaOfferCompleted;
        
        /// <remarks/>
        public event GetPodcastCompletedEventHandler GetPodcastCompleted;
        
        /// <remarks/>
        public event GetPodcast1CompletedEventHandler GetPodcast1Completed;
        
        /// <remarks/>
        public event SavePodcastCompletedEventHandler SavePodcastCompleted;
        
        /// <remarks/>
        public event GetVideoCompletedEventHandler GetVideoCompleted;
        
        /// <remarks/>
        public event SaveVideoCompletedEventHandler SaveVideoCompleted;
        
        /// <remarks/>
        public event GetVideoSeasonCompletedEventHandler GetVideoSeasonCompleted;
        
        /// <remarks/>
        public event SaveVideoSeasonCompletedEventHandler SaveVideoSeasonCompleted;
        
        /// <remarks/>
        public event GetVideoSeriesCompletedEventHandler GetVideoSeriesCompleted;
        
        /// <remarks/>
        public event SaveVideoSeriesCompletedEventHandler SaveVideoSeriesCompleted;
        
        /// <remarks/>
        public event GetContributorRelationshipTypeCompletedEventHandler GetContributorRelationshipTypeCompleted;
        
        /// <remarks/>
        public event GetCountryCompletedEventHandler GetCountryCompleted;
        
        /// <remarks/>
        public event GetCountry1CompletedEventHandler GetCountry1Completed;
        
        /// <remarks/>
        public event GetCurrencyCompletedEventHandler GetCurrencyCompleted;
        
        /// <remarks/>
        public event GetCurrency1CompletedEventHandler GetCurrency1Completed;
        
        /// <remarks/>
        public event GetCategorySystemCompletedEventHandler GetCategorySystemCompleted;
        
        /// <remarks/>
        public event GetCategorySystem1CompletedEventHandler GetCategorySystem1Completed;
        
        /// <remarks/>
        public event SaveCategoryCompletedEventHandler SaveCategoryCompleted;
        
        /// <remarks/>
        public event GetRatingSystemCompletedEventHandler GetRatingSystemCompleted;
        
        /// <remarks/>
        public event GetRatingSystem1CompletedEventHandler GetRatingSystem1Completed;
        
        /// <remarks/>
        public event GetArticleCompletedEventHandler GetArticleCompleted;
        
        /// <remarks/>
        public event GetArticle1CompletedEventHandler GetArticle1Completed;
        
        /// <remarks/>
        public event GetContributorCompletedEventHandler GetContributorCompleted;
        
        /// <remarks/>
        public event GetContributor1CompletedEventHandler GetContributor1Completed;
        
        /// <remarks/>
        public event SaveVideoEncodingCompletedEventHandler SaveVideoEncodingCompleted;
        
        /// <remarks/>
        public event SaveAudioEncodingCompletedEventHandler SaveAudioEncodingCompleted;
        
        /// <remarks/>
        public event SaveContributorCompletedEventHandler SaveContributorCompleted;
        
        /// <remarks/>
        public event GetAudioEncodingCompletedEventHandler GetAudioEncodingCompleted;
        
        /// <remarks/>
        public event GetClientTypeCompletedEventHandler GetClientTypeCompleted;
        
        /// <remarks/>
        public event GetLocaleCompletedEventHandler GetLocaleCompleted;
        
        /// <remarks/>
        public event GetImageFormatCompletedEventHandler GetImageFormatCompleted;
        
        /// <remarks/>
        public event GetImageSizeCompletedEventHandler GetImageSizeCompleted;
        
        /// <remarks/>
        public event GetMediaRelationshipTypeCompletedEventHandler GetMediaRelationshipTypeCompleted;
        
        /// <remarks/>
        public event GetPreviewMediaInstanceTypeCompletedEventHandler GetPreviewMediaInstanceTypeCompleted;
        
        /// <remarks/>
        public event GetRoleCompletedEventHandler GetRoleCompleted;
        
        /// <remarks/>
        public event GetStoreCompletedEventHandler GetStoreCompleted;
        
        /// <remarks/>
        public event GetTaskStatusCompletedEventHandler GetTaskStatusCompleted;
        
        /// <remarks/>
        public event GetTasksByStatusCompletedEventHandler GetTasksByStatusCompleted;
        
        /// <remarks/>
        public event GetTasksCompletedEventHandler GetTasksCompleted;
        
        /// <remarks/>
        public event GetAvailableTaskAsXMLCompletedEventHandler GetAvailableTaskAsXMLCompleted;
        
        /// <remarks/>
        public event PurgeTaskQueueCompletedEventHandler PurgeTaskQueueCompleted;
        
        /// <remarks/>
        public event SaveTaskCompletedEventHandler SaveTaskCompleted;
        
        /// <remarks/>
        public event SaveDRMTaskCompletedEventHandler SaveDRMTaskCompleted;
        
        /// <remarks/>
        public event SaveTask1CompletedEventHandler SaveTask1Completed;
        
        /// <remarks/>
        public event GetUserTypeCompletedEventHandler GetUserTypeCompleted;
        
        /// <remarks/>
        public event GetVideoDefinitionCompletedEventHandler GetVideoDefinitionCompleted;
        
        /// <remarks/>
        public event GetVideoEncodingCompletedEventHandler GetVideoEncodingCompleted;
        
        /// <remarks/>
        public event GetVisibilityLevelCompletedEventHandler GetVisibilityLevelCompleted;
        
        /// <remarks/>
        public event GetVisibilityStatusCompletedEventHandler GetVisibilityStatusCompleted;
        
        /// <remarks/>
        public event GetProviderCompletedEventHandler GetProviderCompleted;
        
        /// <remarks/>
        public event GetProvider1CompletedEventHandler GetProvider1Completed;
        
        /// <remarks/>
        public event GetMetadataProviderCompletedEventHandler GetMetadataProviderCompleted;
        
        /// <remarks/>
        public event GetMetadataProvider1CompletedEventHandler GetMetadataProvider1Completed;
        
        /// <remarks/>
        public event GetDRMLicenseIssuerCompletedEventHandler GetDRMLicenseIssuerCompleted;
        
        /// <remarks/>
        public event GetDRMLicenseIssuer1CompletedEventHandler GetDRMLicenseIssuer1Completed;
        
        /// <remarks/>
        public event GetLicenseTypeCompletedEventHandler GetLicenseTypeCompleted;
        
        /// <remarks/>
        public event GetLicenseType1CompletedEventHandler GetLicenseType1Completed;
        
        /// <remarks/>
        public event SaveLicenseTypeCompletedEventHandler SaveLicenseTypeCompleted;
        
        /// <remarks/>
        public event GetLicenseClassCompletedEventHandler GetLicenseClassCompleted;
        
        /// <remarks/>
        public event GetLicenseClass1CompletedEventHandler GetLicenseClass1Completed;
        
        /// <remarks/>
        public event GetPricingRuleCompletedEventHandler GetPricingRuleCompleted;
        
        /// <remarks/>
        public event GetPricingRule1CompletedEventHandler GetPricingRule1Completed;
        
        /// <remarks/>
        public event SavePricingRuleCompletedEventHandler SavePricingRuleCompleted;
        
        /// <remarks/>
        public event GetMediaTypeCompletedEventHandler GetMediaTypeCompleted;
        
        /// <remarks/>
        public event SaveGameCompletedEventHandler SaveGameCompleted;
        
        /// <remarks/>
        public event GetGameCompletedEventHandler GetGameCompleted;
        
        /// <remarks/>
        public event SaveGameContentCompletedEventHandler SaveGameContentCompleted;
        
        /// <remarks/>
        public event GetGameContentCompletedEventHandler GetGameContentCompleted;
        
        /// <remarks/>
        public event GetPaymentMethodCompletedEventHandler GetPaymentMethodCompleted;
        
        /// <remarks/>
        public event GetPaymentMethod1CompletedEventHandler GetPaymentMethod1Completed;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/Ping", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string Ping() {
            object[] results = this.Invoke("Ping", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPing(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Ping", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndPing(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void PingAsync() {
            this.PingAsync(null);
        }
        
        /// <remarks/>
        public void PingAsync(object userState) {
            if ((this.PingOperationCompleted == null)) {
                this.PingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPingOperationCompleted);
            }
            this.InvokeAsync("Ping", new object[0], this.PingOperationCompleted, userState);
        }
        
        private void OnPingOperationCompleted(object arg) {
            if ((this.PingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PingCompleted(this, new PingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/Search", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Response[] Search(Request request) {
            object[] results = this.Invoke("Search", new object[] {
                        request});
            return ((Response[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSearch(Request request, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Search", new object[] {
                        request}, callback, asyncState);
        }
        
        /// <remarks/>
        public Response[] EndSearch(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Response[])(results[0]));
        }
        
        /// <remarks/>
        public void SearchAsync(Request request) {
            this.SearchAsync(request, null);
        }
        
        /// <remarks/>
        public void SearchAsync(Request request, object userState) {
            if ((this.SearchOperationCompleted == null)) {
                this.SearchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSearchOperationCompleted);
            }
            this.InvokeAsync("Search", new object[] {
                        request}, this.SearchOperationCompleted, userState);
        }
        
        private void OnSearchOperationCompleted(object arg) {
            if ((this.SearchCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SearchCompleted(this, new SearchCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCatalogId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetCatalogId(string externalId, int feedSourceId, int externalmappingObjectId) {
            object[] results = this.Invoke("GetCatalogId", new object[] {
                        externalId,
                        feedSourceId,
                        externalmappingObjectId});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCatalogId(string externalId, int feedSourceId, int externalmappingObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCatalogId", new object[] {
                        externalId,
                        feedSourceId,
                        externalmappingObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetCatalogId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetCatalogIdAsync(string externalId, int feedSourceId, int externalmappingObjectId) {
            this.GetCatalogIdAsync(externalId, feedSourceId, externalmappingObjectId, null);
        }
        
        /// <remarks/>
        public void GetCatalogIdAsync(string externalId, int feedSourceId, int externalmappingObjectId, object userState) {
            if ((this.GetCatalogIdOperationCompleted == null)) {
                this.GetCatalogIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCatalogIdOperationCompleted);
            }
            this.InvokeAsync("GetCatalogId", new object[] {
                        externalId,
                        feedSourceId,
                        externalmappingObjectId}, this.GetCatalogIdOperationCompleted, userState);
        }
        
        private void OnGetCatalogIdOperationCompleted(object arg) {
            if ((this.GetCatalogIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCatalogIdCompleted(this, new GetCatalogIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetExternalId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetExternalId([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<int> catalogId, int feedSourceId, int externalmappingObjectId) {
            object[] results = this.Invoke("GetExternalId", new object[] {
                        catalogId,
                        feedSourceId,
                        externalmappingObjectId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExternalId(System.Nullable<int> catalogId, int feedSourceId, int externalmappingObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExternalId", new object[] {
                        catalogId,
                        feedSourceId,
                        externalmappingObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetExternalId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetExternalIdAsync(System.Nullable<int> catalogId, int feedSourceId, int externalmappingObjectId) {
            this.GetExternalIdAsync(catalogId, feedSourceId, externalmappingObjectId, null);
        }
        
        /// <remarks/>
        public void GetExternalIdAsync(System.Nullable<int> catalogId, int feedSourceId, int externalmappingObjectId, object userState) {
            if ((this.GetExternalIdOperationCompleted == null)) {
                this.GetExternalIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExternalIdOperationCompleted);
            }
            this.InvokeAsync("GetExternalId", new object[] {
                        catalogId,
                        feedSourceId,
                        externalmappingObjectId}, this.GetExternalIdOperationCompleted, userState);
        }
        
        private void OnGetExternalIdOperationCompleted(object arg) {
            if ((this.GetExternalIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExternalIdCompleted(this, new GetExternalIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetEntity", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Entity GetEntity(int entityId) {
            object[] results = this.Invoke("GetEntity", new object[] {
                        entityId});
            return ((Entity)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEntity(int entityId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEntity", new object[] {
                        entityId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Entity EndGetEntity(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Entity)(results[0]));
        }
        
        /// <remarks/>
        public void GetEntityAsync(int entityId) {
            this.GetEntityAsync(entityId, null);
        }
        
        /// <remarks/>
        public void GetEntityAsync(int entityId, object userState) {
            if ((this.GetEntityOperationCompleted == null)) {
                this.GetEntityOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetEntityOperationCompleted);
            }
            this.InvokeAsync("GetEntity", new object[] {
                        entityId}, this.GetEntityOperationCompleted, userState);
        }
        
        private void OnGetEntityOperationCompleted(object arg) {
            if ((this.GetEntityCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetEntityCompleted(this, new GetEntityCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetEntity1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetEntityArray", RequestElementName="GetEntityArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetEntityArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetEntityArrayResult")]
        public Entity[] GetEntity() {
            object[] results = this.Invoke("GetEntity1", new object[0]);
            return ((Entity[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEntity1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEntity1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Entity[] EndGetEntity1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Entity[])(results[0]));
        }
        
        /// <remarks/>
        public void GetEntity1Async() {
            this.GetEntity1Async(null);
        }
        
        /// <remarks/>
        public void GetEntity1Async(object userState) {
            if ((this.GetEntity1OperationCompleted == null)) {
                this.GetEntity1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetEntity1OperationCompleted);
            }
            this.InvokeAsync("GetEntity1", new object[0], this.GetEntity1OperationCompleted, userState);
        }
        
        private void OnGetEntity1OperationCompleted(object arg) {
            if ((this.GetEntity1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetEntity1Completed(this, new GetEntity1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableEntityId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableEntityId() {
            object[] results = this.Invoke("GetAvailableEntityId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableEntityId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableEntityId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableEntityId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableEntityIdAsync() {
            this.GetAvailableEntityIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableEntityIdAsync(object userState) {
            if ((this.GetAvailableEntityIdOperationCompleted == null)) {
                this.GetAvailableEntityIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableEntityIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableEntityId", new object[0], this.GetAvailableEntityIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableEntityIdOperationCompleted(object arg) {
            if ((this.GetAvailableEntityIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableEntityIdCompleted(this, new GetAvailableEntityIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableCategoryId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableCategoryId() {
            object[] results = this.Invoke("GetAvailableCategoryId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableCategoryId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableCategoryId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableCategoryId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableCategoryIdAsync() {
            this.GetAvailableCategoryIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableCategoryIdAsync(object userState) {
            if ((this.GetAvailableCategoryIdOperationCompleted == null)) {
                this.GetAvailableCategoryIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableCategoryIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableCategoryId", new object[0], this.GetAvailableCategoryIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableCategoryIdOperationCompleted(object arg) {
            if ((this.GetAvailableCategoryIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableCategoryIdCompleted(this, new GetAvailableCategoryIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableCategorySystemId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableCategorySystemId() {
            object[] results = this.Invoke("GetAvailableCategorySystemId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableCategorySystemId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableCategorySystemId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableCategorySystemId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableCategorySystemIdAsync() {
            this.GetAvailableCategorySystemIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableCategorySystemIdAsync(object userState) {
            if ((this.GetAvailableCategorySystemIdOperationCompleted == null)) {
                this.GetAvailableCategorySystemIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableCategorySystemIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableCategorySystemId", new object[0], this.GetAvailableCategorySystemIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableCategorySystemIdOperationCompleted(object arg) {
            if ((this.GetAvailableCategorySystemIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableCategorySystemIdCompleted(this, new GetAvailableCategorySystemIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableRatingSystemId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableRatingSystemId() {
            object[] results = this.Invoke("GetAvailableRatingSystemId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableRatingSystemId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableRatingSystemId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableRatingSystemId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableRatingSystemIdAsync() {
            this.GetAvailableRatingSystemIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableRatingSystemIdAsync(object userState) {
            if ((this.GetAvailableRatingSystemIdOperationCompleted == null)) {
                this.GetAvailableRatingSystemIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableRatingSystemIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableRatingSystemId", new object[0], this.GetAvailableRatingSystemIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableRatingSystemIdOperationCompleted(object arg) {
            if ((this.GetAvailableRatingSystemIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableRatingSystemIdCompleted(this, new GetAvailableRatingSystemIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableRatingValueId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableRatingValueId() {
            object[] results = this.Invoke("GetAvailableRatingValueId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableRatingValueId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableRatingValueId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableRatingValueId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableRatingValueIdAsync() {
            this.GetAvailableRatingValueIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableRatingValueIdAsync(object userState) {
            if ((this.GetAvailableRatingValueIdOperationCompleted == null)) {
                this.GetAvailableRatingValueIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableRatingValueIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableRatingValueId", new object[0], this.GetAvailableRatingValueIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableRatingValueIdOperationCompleted(object arg) {
            if ((this.GetAvailableRatingValueIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableRatingValueIdCompleted(this, new GetAvailableRatingValueIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableRatingDescriptorId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableRatingDescriptorId() {
            object[] results = this.Invoke("GetAvailableRatingDescriptorId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableRatingDescriptorId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableRatingDescriptorId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableRatingDescriptorId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableRatingDescriptorIdAsync() {
            this.GetAvailableRatingDescriptorIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableRatingDescriptorIdAsync(object userState) {
            if ((this.GetAvailableRatingDescriptorIdOperationCompleted == null)) {
                this.GetAvailableRatingDescriptorIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableRatingDescriptorIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableRatingDescriptorId", new object[0], this.GetAvailableRatingDescriptorIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableRatingDescriptorIdOperationCompleted(object arg) {
            if ((this.GetAvailableRatingDescriptorIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableRatingDescriptorIdCompleted(this, new GetAvailableRatingDescriptorIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableLicenseTypeId", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetAvailableLicenseTypeId() {
            object[] results = this.Invoke("GetAvailableLicenseTypeId", new object[0]);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableLicenseTypeId(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableLicenseTypeId", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetAvailableLicenseTypeId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableLicenseTypeIdAsync() {
            this.GetAvailableLicenseTypeIdAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableLicenseTypeIdAsync(object userState) {
            if ((this.GetAvailableLicenseTypeIdOperationCompleted == null)) {
                this.GetAvailableLicenseTypeIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableLicenseTypeIdOperationCompleted);
            }
            this.InvokeAsync("GetAvailableLicenseTypeId", new object[0], this.GetAvailableLicenseTypeIdOperationCompleted, userState);
        }
        
        private void OnGetAvailableLicenseTypeIdOperationCompleted(object arg) {
            if ((this.GetAvailableLicenseTypeIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableLicenseTypeIdCompleted(this, new GetAvailableLicenseTypeIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetExternalFeedSourceOne", RequestElementName="GetExternalFeedSourceOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetExternalFeedSourceOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetExternalFeedSourceOneResult")]
        public ExternalFeedSource GetExternalFeedSource(int id) {
            object[] results = this.Invoke("GetExternalFeedSource", new object[] {
                        id});
            return ((ExternalFeedSource)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExternalFeedSource(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExternalFeedSource", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExternalFeedSource EndGetExternalFeedSource(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExternalFeedSource)(results[0]));
        }
        
        /// <remarks/>
        public void GetExternalFeedSourceAsync(int id) {
            this.GetExternalFeedSourceAsync(id, null);
        }
        
        /// <remarks/>
        public void GetExternalFeedSourceAsync(int id, object userState) {
            if ((this.GetExternalFeedSourceOperationCompleted == null)) {
                this.GetExternalFeedSourceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExternalFeedSourceOperationCompleted);
            }
            this.InvokeAsync("GetExternalFeedSource", new object[] {
                        id}, this.GetExternalFeedSourceOperationCompleted, userState);
        }
        
        private void OnGetExternalFeedSourceOperationCompleted(object arg) {
            if ((this.GetExternalFeedSourceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExternalFeedSourceCompleted(this, new GetExternalFeedSourceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetExternalFeedSource1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetExternalFeedSourceArray", RequestElementName="GetExternalFeedSourceArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetExternalFeedSourceArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetExternalFeedSourceArrayResult")]
        public ExternalFeedSource[] GetExternalFeedSource() {
            object[] results = this.Invoke("GetExternalFeedSource1", new object[0]);
            return ((ExternalFeedSource[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExternalFeedSource1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExternalFeedSource1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public ExternalFeedSource[] EndGetExternalFeedSource1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExternalFeedSource[])(results[0]));
        }
        
        /// <remarks/>
        public void GetExternalFeedSource1Async() {
            this.GetExternalFeedSource1Async(null);
        }
        
        /// <remarks/>
        public void GetExternalFeedSource1Async(object userState) {
            if ((this.GetExternalFeedSource1OperationCompleted == null)) {
                this.GetExternalFeedSource1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExternalFeedSource1OperationCompleted);
            }
            this.InvokeAsync("GetExternalFeedSource1", new object[0], this.GetExternalFeedSource1OperationCompleted, userState);
        }
        
        private void OnGetExternalFeedSource1OperationCompleted(object arg) {
            if ((this.GetExternalFeedSource1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExternalFeedSource1Completed(this, new GetExternalFeedSource1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetExternalFeedMappingObjectOne", RequestElementName="GetExternalFeedMappingObjectOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetExternalFeedMappingObjectOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetExternalFeedMappingObjectOneResult")]
        public ExternalFeedMappingObject GetExternalFeedMappingObject(int id) {
            object[] results = this.Invoke("GetExternalFeedMappingObject", new object[] {
                        id});
            return ((ExternalFeedMappingObject)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExternalFeedMappingObject(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExternalFeedMappingObject", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExternalFeedMappingObject EndGetExternalFeedMappingObject(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExternalFeedMappingObject)(results[0]));
        }
        
        /// <remarks/>
        public void GetExternalFeedMappingObjectAsync(int id) {
            this.GetExternalFeedMappingObjectAsync(id, null);
        }
        
        /// <remarks/>
        public void GetExternalFeedMappingObjectAsync(int id, object userState) {
            if ((this.GetExternalFeedMappingObjectOperationCompleted == null)) {
                this.GetExternalFeedMappingObjectOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExternalFeedMappingObjectOperationCompleted);
            }
            this.InvokeAsync("GetExternalFeedMappingObject", new object[] {
                        id}, this.GetExternalFeedMappingObjectOperationCompleted, userState);
        }
        
        private void OnGetExternalFeedMappingObjectOperationCompleted(object arg) {
            if ((this.GetExternalFeedMappingObjectCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExternalFeedMappingObjectCompleted(this, new GetExternalFeedMappingObjectCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetExternalFeedMappingObject1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetExternalFeedMappingObjectArray", RequestElementName="GetExternalFeedMappingObjectArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetExternalFeedMappingObjectArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetExternalFeedMappingObjectArrayResult")]
        public ExternalFeedMappingObject[] GetExternalFeedMappingObject() {
            object[] results = this.Invoke("GetExternalFeedMappingObject1", new object[0]);
            return ((ExternalFeedMappingObject[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExternalFeedMappingObject1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExternalFeedMappingObject1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public ExternalFeedMappingObject[] EndGetExternalFeedMappingObject1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExternalFeedMappingObject[])(results[0]));
        }
        
        /// <remarks/>
        public void GetExternalFeedMappingObject1Async() {
            this.GetExternalFeedMappingObject1Async(null);
        }
        
        /// <remarks/>
        public void GetExternalFeedMappingObject1Async(object userState) {
            if ((this.GetExternalFeedMappingObject1OperationCompleted == null)) {
                this.GetExternalFeedMappingObject1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetExternalFeedMappingObject1OperationCompleted);
            }
            this.InvokeAsync("GetExternalFeedMappingObject1", new object[0], this.GetExternalFeedMappingObject1OperationCompleted, userState);
        }
        
        private void OnGetExternalFeedMappingObject1OperationCompleted(object arg) {
            if ((this.GetExternalFeedMappingObject1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetExternalFeedMappingObject1Completed(this, new GetExternalFeedMappingObject1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveExternalFeedMapping", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveExternalFeedMapping(ExternalFeedMapping e) {
            this.Invoke("SaveExternalFeedMapping", new object[] {
                        e});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveExternalFeedMapping(ExternalFeedMapping e, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveExternalFeedMapping", new object[] {
                        e}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveExternalFeedMapping(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveExternalFeedMappingAsync(ExternalFeedMapping e) {
            this.SaveExternalFeedMappingAsync(e, null);
        }
        
        /// <remarks/>
        public void SaveExternalFeedMappingAsync(ExternalFeedMapping e, object userState) {
            if ((this.SaveExternalFeedMappingOperationCompleted == null)) {
                this.SaveExternalFeedMappingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveExternalFeedMappingOperationCompleted);
            }
            this.InvokeAsync("SaveExternalFeedMapping", new object[] {
                        e}, this.SaveExternalFeedMappingOperationCompleted, userState);
        }
        
        private void OnSaveExternalFeedMappingOperationCompleted(object arg) {
            if ((this.SaveExternalFeedMappingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveExternalFeedMappingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveEntity", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveEntity(Entity e) {
            this.Invoke("SaveEntity", new object[] {
                        e});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveEntity(Entity e, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveEntity", new object[] {
                        e}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveEntity(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveEntityAsync(Entity e) {
            this.SaveEntityAsync(e, null);
        }
        
        /// <remarks/>
        public void SaveEntityAsync(Entity e, object userState) {
            if ((this.SaveEntityOperationCompleted == null)) {
                this.SaveEntityOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveEntityOperationCompleted);
            }
            this.InvokeAsync("SaveEntity", new object[] {
                        e}, this.SaveEntityOperationCompleted, userState);
        }
        
        private void OnSaveEntityOperationCompleted(object arg) {
            if ((this.SaveEntityCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveEntityCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetImage", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Image GetImage(System.Guid imageId) {
            object[] results = this.Invoke("GetImage", new object[] {
                        imageId});
            return ((Image)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetImage(System.Guid imageId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetImage", new object[] {
                        imageId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Image EndGetImage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Image)(results[0]));
        }
        
        /// <remarks/>
        public void GetImageAsync(System.Guid imageId) {
            this.GetImageAsync(imageId, null);
        }
        
        /// <remarks/>
        public void GetImageAsync(System.Guid imageId, object userState) {
            if ((this.GetImageOperationCompleted == null)) {
                this.GetImageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetImageOperationCompleted);
            }
            this.InvokeAsync("GetImage", new object[] {
                        imageId}, this.GetImageOperationCompleted, userState);
        }
        
        private void OnGetImageOperationCompleted(object arg) {
            if ((this.GetImageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetImageCompleted(this, new GetImageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveImage", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveImage(Image image) {
            this.Invoke("SaveImage", new object[] {
                        image});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveImage(Image image, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveImage", new object[] {
                        image}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveImage(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveImageAsync(Image image) {
            this.SaveImageAsync(image, null);
        }
        
        /// <remarks/>
        public void SaveImageAsync(Image image, object userState) {
            if ((this.SaveImageOperationCompleted == null)) {
                this.SaveImageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveImageOperationCompleted);
            }
            this.InvokeAsync("SaveImage", new object[] {
                        image}, this.SaveImageOperationCompleted, userState);
        }
        
        private void OnSaveImageOperationCompleted(object arg) {
            if ((this.SaveImageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveImageCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SavePublishingBatchRequest", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SavePublishingBatchRequest(Publishing Publishing) {
            this.Invoke("SavePublishingBatchRequest", new object[] {
                        Publishing});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSavePublishingBatchRequest(Publishing Publishing, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SavePublishingBatchRequest", new object[] {
                        Publishing}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSavePublishingBatchRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SavePublishingBatchRequestAsync(Publishing Publishing) {
            this.SavePublishingBatchRequestAsync(Publishing, null);
        }
        
        /// <remarks/>
        public void SavePublishingBatchRequestAsync(Publishing Publishing, object userState) {
            if ((this.SavePublishingBatchRequestOperationCompleted == null)) {
                this.SavePublishingBatchRequestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSavePublishingBatchRequestOperationCompleted);
            }
            this.InvokeAsync("SavePublishingBatchRequest", new object[] {
                        Publishing}, this.SavePublishingBatchRequestOperationCompleted, userState);
        }
        
        private void OnSavePublishingBatchRequestOperationCompleted(object arg) {
            if ((this.SavePublishingBatchRequestCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SavePublishingBatchRequestCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetOffer", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Offer GetOffer(System.Guid offerId) {
            object[] results = this.Invoke("GetOffer", new object[] {
                        offerId});
            return ((Offer)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetOffer(System.Guid offerId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetOffer", new object[] {
                        offerId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Offer EndGetOffer(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Offer)(results[0]));
        }
        
        /// <remarks/>
        public void GetOfferAsync(System.Guid offerId) {
            this.GetOfferAsync(offerId, null);
        }
        
        /// <remarks/>
        public void GetOfferAsync(System.Guid offerId, object userState) {
            if ((this.GetOfferOperationCompleted == null)) {
                this.GetOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetOfferOperationCompleted);
            }
            this.InvokeAsync("GetOffer", new object[] {
                        offerId}, this.GetOfferOperationCompleted, userState);
        }
        
        private void OnGetOfferOperationCompleted(object arg) {
            if ((this.GetOfferCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetOfferCompleted(this, new GetOfferCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveOffer", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveOffer(Offer offer) {
            this.Invoke("SaveOffer", new object[] {
                        offer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveOffer(Offer offer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveOffer", new object[] {
                        offer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveOffer(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveOfferAsync(Offer offer) {
            this.SaveOfferAsync(offer, null);
        }
        
        /// <remarks/>
        public void SaveOfferAsync(Offer offer, object userState) {
            if ((this.SaveOfferOperationCompleted == null)) {
                this.SaveOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveOfferOperationCompleted);
            }
            this.InvokeAsync("SaveOffer", new object[] {
                        offer}, this.SaveOfferOperationCompleted, userState);
        }
        
        private void OnSaveOfferOperationCompleted(object arg) {
            if ((this.SaveOfferCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetMediaOffer", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MediaOffer GetMediaOffer(System.Guid mediaId) {
            object[] results = this.Invoke("GetMediaOffer", new object[] {
                        mediaId});
            return ((MediaOffer)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMediaOffer(System.Guid mediaId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMediaOffer", new object[] {
                        mediaId}, callback, asyncState);
        }
        
        /// <remarks/>
        public MediaOffer EndGetMediaOffer(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MediaOffer)(results[0]));
        }
        
        /// <remarks/>
        public void GetMediaOfferAsync(System.Guid mediaId) {
            this.GetMediaOfferAsync(mediaId, null);
        }
        
        /// <remarks/>
        public void GetMediaOfferAsync(System.Guid mediaId, object userState) {
            if ((this.GetMediaOfferOperationCompleted == null)) {
                this.GetMediaOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMediaOfferOperationCompleted);
            }
            this.InvokeAsync("GetMediaOffer", new object[] {
                        mediaId}, this.GetMediaOfferOperationCompleted, userState);
        }
        
        private void OnGetMediaOfferOperationCompleted(object arg) {
            if ((this.GetMediaOfferCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMediaOfferCompleted(this, new GetMediaOfferCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetPodcastById", RequestElementName="GetPodcastById", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetPodcastByIdResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetPodcastByIdResult")]
        public Podcast GetPodcast(System.Guid podcastId) {
            object[] results = this.Invoke("GetPodcast", new object[] {
                        podcastId});
            return ((Podcast)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPodcast(System.Guid podcastId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPodcast", new object[] {
                        podcastId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Podcast EndGetPodcast(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Podcast)(results[0]));
        }
        
        /// <remarks/>
        public void GetPodcastAsync(System.Guid podcastId) {
            this.GetPodcastAsync(podcastId, null);
        }
        
        /// <remarks/>
        public void GetPodcastAsync(System.Guid podcastId, object userState) {
            if ((this.GetPodcastOperationCompleted == null)) {
                this.GetPodcastOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPodcastOperationCompleted);
            }
            this.InvokeAsync("GetPodcast", new object[] {
                        podcastId}, this.GetPodcastOperationCompleted, userState);
        }
        
        private void OnGetPodcastOperationCompleted(object arg) {
            if ((this.GetPodcastCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPodcastCompleted(this, new GetPodcastCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetPodcast1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetPodcastByUri", RequestElementName="GetPodcastByUri", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetPodcastByUriResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetPodcastByUriResult")]
        public Podcast GetPodcast(string podcastUri) {
            object[] results = this.Invoke("GetPodcast1", new object[] {
                        podcastUri});
            return ((Podcast)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPodcast1(string podcastUri, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPodcast1", new object[] {
                        podcastUri}, callback, asyncState);
        }
        
        /// <remarks/>
        public Podcast EndGetPodcast1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Podcast)(results[0]));
        }
        
        /// <remarks/>
        public void GetPodcast1Async(string podcastUri) {
            this.GetPodcast1Async(podcastUri, null);
        }
        
        /// <remarks/>
        public void GetPodcast1Async(string podcastUri, object userState) {
            if ((this.GetPodcast1OperationCompleted == null)) {
                this.GetPodcast1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPodcast1OperationCompleted);
            }
            this.InvokeAsync("GetPodcast1", new object[] {
                        podcastUri}, this.GetPodcast1OperationCompleted, userState);
        }
        
        private void OnGetPodcast1OperationCompleted(object arg) {
            if ((this.GetPodcast1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPodcast1Completed(this, new GetPodcast1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SavePodcast", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SavePodcast(Podcast podcast) {
            this.Invoke("SavePodcast", new object[] {
                        podcast});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSavePodcast(Podcast podcast, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SavePodcast", new object[] {
                        podcast}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSavePodcast(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SavePodcastAsync(Podcast podcast) {
            this.SavePodcastAsync(podcast, null);
        }
        
        /// <remarks/>
        public void SavePodcastAsync(Podcast podcast, object userState) {
            if ((this.SavePodcastOperationCompleted == null)) {
                this.SavePodcastOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSavePodcastOperationCompleted);
            }
            this.InvokeAsync("SavePodcast", new object[] {
                        podcast}, this.SavePodcastOperationCompleted, userState);
        }
        
        private void OnSavePodcastOperationCompleted(object arg) {
            if ((this.SavePodcastCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SavePodcastCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVideo", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Video GetVideo(System.Guid videoId) {
            object[] results = this.Invoke("GetVideo", new object[] {
                        videoId});
            return ((Video)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVideo(System.Guid videoId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVideo", new object[] {
                        videoId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Video EndGetVideo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Video)(results[0]));
        }
        
        /// <remarks/>
        public void GetVideoAsync(System.Guid videoId) {
            this.GetVideoAsync(videoId, null);
        }
        
        /// <remarks/>
        public void GetVideoAsync(System.Guid videoId, object userState) {
            if ((this.GetVideoOperationCompleted == null)) {
                this.GetVideoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVideoOperationCompleted);
            }
            this.InvokeAsync("GetVideo", new object[] {
                        videoId}, this.GetVideoOperationCompleted, userState);
        }
        
        private void OnGetVideoOperationCompleted(object arg) {
            if ((this.GetVideoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVideoCompleted(this, new GetVideoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveVideo", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveVideo(Video video) {
            this.Invoke("SaveVideo", new object[] {
                        video});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveVideo(Video video, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveVideo", new object[] {
                        video}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveVideo(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveVideoAsync(Video video) {
            this.SaveVideoAsync(video, null);
        }
        
        /// <remarks/>
        public void SaveVideoAsync(Video video, object userState) {
            if ((this.SaveVideoOperationCompleted == null)) {
                this.SaveVideoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveVideoOperationCompleted);
            }
            this.InvokeAsync("SaveVideo", new object[] {
                        video}, this.SaveVideoOperationCompleted, userState);
        }
        
        private void OnSaveVideoOperationCompleted(object arg) {
            if ((this.SaveVideoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveVideoCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVideoSeason", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public VideoSeason GetVideoSeason(System.Guid videoSeasonId) {
            object[] results = this.Invoke("GetVideoSeason", new object[] {
                        videoSeasonId});
            return ((VideoSeason)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVideoSeason(System.Guid videoSeasonId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVideoSeason", new object[] {
                        videoSeasonId}, callback, asyncState);
        }
        
        /// <remarks/>
        public VideoSeason EndGetVideoSeason(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VideoSeason)(results[0]));
        }
        
        /// <remarks/>
        public void GetVideoSeasonAsync(System.Guid videoSeasonId) {
            this.GetVideoSeasonAsync(videoSeasonId, null);
        }
        
        /// <remarks/>
        public void GetVideoSeasonAsync(System.Guid videoSeasonId, object userState) {
            if ((this.GetVideoSeasonOperationCompleted == null)) {
                this.GetVideoSeasonOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVideoSeasonOperationCompleted);
            }
            this.InvokeAsync("GetVideoSeason", new object[] {
                        videoSeasonId}, this.GetVideoSeasonOperationCompleted, userState);
        }
        
        private void OnGetVideoSeasonOperationCompleted(object arg) {
            if ((this.GetVideoSeasonCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVideoSeasonCompleted(this, new GetVideoSeasonCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveVideoSeason", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveVideoSeason(VideoSeason videoSeason) {
            this.Invoke("SaveVideoSeason", new object[] {
                        videoSeason});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveVideoSeason(VideoSeason videoSeason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveVideoSeason", new object[] {
                        videoSeason}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveVideoSeason(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveVideoSeasonAsync(VideoSeason videoSeason) {
            this.SaveVideoSeasonAsync(videoSeason, null);
        }
        
        /// <remarks/>
        public void SaveVideoSeasonAsync(VideoSeason videoSeason, object userState) {
            if ((this.SaveVideoSeasonOperationCompleted == null)) {
                this.SaveVideoSeasonOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveVideoSeasonOperationCompleted);
            }
            this.InvokeAsync("SaveVideoSeason", new object[] {
                        videoSeason}, this.SaveVideoSeasonOperationCompleted, userState);
        }
        
        private void OnSaveVideoSeasonOperationCompleted(object arg) {
            if ((this.SaveVideoSeasonCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveVideoSeasonCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVideoSeries", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public VideoSeries GetVideoSeries(System.Guid videoSeriesId) {
            object[] results = this.Invoke("GetVideoSeries", new object[] {
                        videoSeriesId});
            return ((VideoSeries)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVideoSeries(System.Guid videoSeriesId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVideoSeries", new object[] {
                        videoSeriesId}, callback, asyncState);
        }
        
        /// <remarks/>
        public VideoSeries EndGetVideoSeries(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VideoSeries)(results[0]));
        }
        
        /// <remarks/>
        public void GetVideoSeriesAsync(System.Guid videoSeriesId) {
            this.GetVideoSeriesAsync(videoSeriesId, null);
        }
        
        /// <remarks/>
        public void GetVideoSeriesAsync(System.Guid videoSeriesId, object userState) {
            if ((this.GetVideoSeriesOperationCompleted == null)) {
                this.GetVideoSeriesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVideoSeriesOperationCompleted);
            }
            this.InvokeAsync("GetVideoSeries", new object[] {
                        videoSeriesId}, this.GetVideoSeriesOperationCompleted, userState);
        }
        
        private void OnGetVideoSeriesOperationCompleted(object arg) {
            if ((this.GetVideoSeriesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVideoSeriesCompleted(this, new GetVideoSeriesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveVideoSeries", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveVideoSeries(VideoSeries videoSeries) {
            this.Invoke("SaveVideoSeries", new object[] {
                        videoSeries});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveVideoSeries(VideoSeries videoSeries, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveVideoSeries", new object[] {
                        videoSeries}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveVideoSeries(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveVideoSeriesAsync(VideoSeries videoSeries) {
            this.SaveVideoSeriesAsync(videoSeries, null);
        }
        
        /// <remarks/>
        public void SaveVideoSeriesAsync(VideoSeries videoSeries, object userState) {
            if ((this.SaveVideoSeriesOperationCompleted == null)) {
                this.SaveVideoSeriesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveVideoSeriesOperationCompleted);
            }
            this.InvokeAsync("SaveVideoSeries", new object[] {
                        videoSeries}, this.SaveVideoSeriesOperationCompleted, userState);
        }
        
        private void OnSaveVideoSeriesOperationCompleted(object arg) {
            if ((this.SaveVideoSeriesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveVideoSeriesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetContributorRelationshipTypeArra" +
            "y", RequestElementName="GetContributorRelationshipTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetContributorRelationshipTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetContributorRelationshipTypeArrayResult")]
        public ContributorRelationshipType[] GetContributorRelationshipType() {
            object[] results = this.Invoke("GetContributorRelationshipType", new object[0]);
            return ((ContributorRelationshipType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetContributorRelationshipType(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetContributorRelationshipType", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public ContributorRelationshipType[] EndGetContributorRelationshipType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ContributorRelationshipType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetContributorRelationshipTypeAsync() {
            this.GetContributorRelationshipTypeAsync(null);
        }
        
        /// <remarks/>
        public void GetContributorRelationshipTypeAsync(object userState) {
            if ((this.GetContributorRelationshipTypeOperationCompleted == null)) {
                this.GetContributorRelationshipTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetContributorRelationshipTypeOperationCompleted);
            }
            this.InvokeAsync("GetContributorRelationshipType", new object[0], this.GetContributorRelationshipTypeOperationCompleted, userState);
        }
        
        private void OnGetContributorRelationshipTypeOperationCompleted(object arg) {
            if ((this.GetContributorRelationshipTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetContributorRelationshipTypeCompleted(this, new GetContributorRelationshipTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCountry", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Country GetCountry(string countryCode) {
            object[] results = this.Invoke("GetCountry", new object[] {
                        countryCode});
            return ((Country)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCountry(string countryCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCountry", new object[] {
                        countryCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public Country EndGetCountry(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Country)(results[0]));
        }
        
        /// <remarks/>
        public void GetCountryAsync(string countryCode) {
            this.GetCountryAsync(countryCode, null);
        }
        
        /// <remarks/>
        public void GetCountryAsync(string countryCode, object userState) {
            if ((this.GetCountryOperationCompleted == null)) {
                this.GetCountryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCountryOperationCompleted);
            }
            this.InvokeAsync("GetCountry", new object[] {
                        countryCode}, this.GetCountryOperationCompleted, userState);
        }
        
        private void OnGetCountryOperationCompleted(object arg) {
            if ((this.GetCountryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCountryCompleted(this, new GetCountryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetCountry1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCountryArray", RequestElementName="GetCountryArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetCountryArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetCountryArrayResult")]
        public Country[] GetCountry() {
            object[] results = this.Invoke("GetCountry1", new object[0]);
            return ((Country[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCountry1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCountry1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Country[] EndGetCountry1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Country[])(results[0]));
        }
        
        /// <remarks/>
        public void GetCountry1Async() {
            this.GetCountry1Async(null);
        }
        
        /// <remarks/>
        public void GetCountry1Async(object userState) {
            if ((this.GetCountry1OperationCompleted == null)) {
                this.GetCountry1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCountry1OperationCompleted);
            }
            this.InvokeAsync("GetCountry1", new object[0], this.GetCountry1OperationCompleted, userState);
        }
        
        private void OnGetCountry1OperationCompleted(object arg) {
            if ((this.GetCountry1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCountry1Completed(this, new GetCountry1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCurrency", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Currency GetCurrency(string currencyCode) {
            object[] results = this.Invoke("GetCurrency", new object[] {
                        currencyCode});
            return ((Currency)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCurrency(string currencyCode, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCurrency", new object[] {
                        currencyCode}, callback, asyncState);
        }
        
        /// <remarks/>
        public Currency EndGetCurrency(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Currency)(results[0]));
        }
        
        /// <remarks/>
        public void GetCurrencyAsync(string currencyCode) {
            this.GetCurrencyAsync(currencyCode, null);
        }
        
        /// <remarks/>
        public void GetCurrencyAsync(string currencyCode, object userState) {
            if ((this.GetCurrencyOperationCompleted == null)) {
                this.GetCurrencyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCurrencyOperationCompleted);
            }
            this.InvokeAsync("GetCurrency", new object[] {
                        currencyCode}, this.GetCurrencyOperationCompleted, userState);
        }
        
        private void OnGetCurrencyOperationCompleted(object arg) {
            if ((this.GetCurrencyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCurrencyCompleted(this, new GetCurrencyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetCurrency1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCurrencyArray", RequestElementName="GetCurrencyArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetCurrencyArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetCurrencyArrayResult")]
        public Currency[] GetCurrency() {
            object[] results = this.Invoke("GetCurrency1", new object[0]);
            return ((Currency[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCurrency1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCurrency1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Currency[] EndGetCurrency1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Currency[])(results[0]));
        }
        
        /// <remarks/>
        public void GetCurrency1Async() {
            this.GetCurrency1Async(null);
        }
        
        /// <remarks/>
        public void GetCurrency1Async(object userState) {
            if ((this.GetCurrency1OperationCompleted == null)) {
                this.GetCurrency1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCurrency1OperationCompleted);
            }
            this.InvokeAsync("GetCurrency1", new object[0], this.GetCurrency1OperationCompleted, userState);
        }
        
        private void OnGetCurrency1OperationCompleted(object arg) {
            if ((this.GetCurrency1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCurrency1Completed(this, new GetCurrency1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCategorySystem", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CategorySystem GetCategorySystem(int id) {
            object[] results = this.Invoke("GetCategorySystem", new object[] {
                        id});
            return ((CategorySystem)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCategorySystem(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCategorySystem", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public CategorySystem EndGetCategorySystem(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CategorySystem)(results[0]));
        }
        
        /// <remarks/>
        public void GetCategorySystemAsync(int id) {
            this.GetCategorySystemAsync(id, null);
        }
        
        /// <remarks/>
        public void GetCategorySystemAsync(int id, object userState) {
            if ((this.GetCategorySystemOperationCompleted == null)) {
                this.GetCategorySystemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCategorySystemOperationCompleted);
            }
            this.InvokeAsync("GetCategorySystem", new object[] {
                        id}, this.GetCategorySystemOperationCompleted, userState);
        }
        
        private void OnGetCategorySystemOperationCompleted(object arg) {
            if ((this.GetCategorySystemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCategorySystemCompleted(this, new GetCategorySystemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetCategorySystem1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetCategorySystemArray", RequestElementName="GetCategorySystemArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetCategorySystemArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetCategorySystemArrayResult")]
        public CategorySystem[] GetCategorySystem() {
            object[] results = this.Invoke("GetCategorySystem1", new object[0]);
            return ((CategorySystem[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCategorySystem1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCategorySystem1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public CategorySystem[] EndGetCategorySystem1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CategorySystem[])(results[0]));
        }
        
        /// <remarks/>
        public void GetCategorySystem1Async() {
            this.GetCategorySystem1Async(null);
        }
        
        /// <remarks/>
        public void GetCategorySystem1Async(object userState) {
            if ((this.GetCategorySystem1OperationCompleted == null)) {
                this.GetCategorySystem1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCategorySystem1OperationCompleted);
            }
            this.InvokeAsync("GetCategorySystem1", new object[0], this.GetCategorySystem1OperationCompleted, userState);
        }
        
        private void OnGetCategorySystem1OperationCompleted(object arg) {
            if ((this.GetCategorySystem1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCategorySystem1Completed(this, new GetCategorySystem1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveCategory", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveCategory(Category category) {
            this.Invoke("SaveCategory", new object[] {
                        category});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveCategory(Category category, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveCategory", new object[] {
                        category}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveCategory(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveCategoryAsync(Category category) {
            this.SaveCategoryAsync(category, null);
        }
        
        /// <remarks/>
        public void SaveCategoryAsync(Category category, object userState) {
            if ((this.SaveCategoryOperationCompleted == null)) {
                this.SaveCategoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveCategoryOperationCompleted);
            }
            this.InvokeAsync("SaveCategory", new object[] {
                        category}, this.SaveCategoryOperationCompleted, userState);
        }
        
        private void OnSaveCategoryOperationCompleted(object arg) {
            if ((this.SaveCategoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveCategoryCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetRatingSystem", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RatingSystem GetRatingSystem(int id) {
            object[] results = this.Invoke("GetRatingSystem", new object[] {
                        id});
            return ((RatingSystem)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingSystem(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingSystem", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public RatingSystem EndGetRatingSystem(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RatingSystem)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingSystemAsync(int id) {
            this.GetRatingSystemAsync(id, null);
        }
        
        /// <remarks/>
        public void GetRatingSystemAsync(int id, object userState) {
            if ((this.GetRatingSystemOperationCompleted == null)) {
                this.GetRatingSystemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingSystemOperationCompleted);
            }
            this.InvokeAsync("GetRatingSystem", new object[] {
                        id}, this.GetRatingSystemOperationCompleted, userState);
        }
        
        private void OnGetRatingSystemOperationCompleted(object arg) {
            if ((this.GetRatingSystemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingSystemCompleted(this, new GetRatingSystemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetRatingSystem1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetRatingSystemArray", RequestElementName="GetRatingSystemArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetRatingSystemArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetRatingSystemArrayResult")]
        public RatingSystem[] GetRatingSystem() {
            object[] results = this.Invoke("GetRatingSystem1", new object[0]);
            return ((RatingSystem[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingSystem1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingSystem1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public RatingSystem[] EndGetRatingSystem1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RatingSystem[])(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingSystem1Async() {
            this.GetRatingSystem1Async(null);
        }
        
        /// <remarks/>
        public void GetRatingSystem1Async(object userState) {
            if ((this.GetRatingSystem1OperationCompleted == null)) {
                this.GetRatingSystem1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingSystem1OperationCompleted);
            }
            this.InvokeAsync("GetRatingSystem1", new object[0], this.GetRatingSystem1OperationCompleted, userState);
        }
        
        private void OnGetRatingSystem1OperationCompleted(object arg) {
            if ((this.GetRatingSystem1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingSystem1Completed(this, new GetRatingSystem1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetArticle", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Article GetArticle(System.Guid id) {
            object[] results = this.Invoke("GetArticle", new object[] {
                        id});
            return ((Article)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetArticle(System.Guid id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetArticle", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public Article EndGetArticle(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Article)(results[0]));
        }
        
        /// <remarks/>
        public void GetArticleAsync(System.Guid id) {
            this.GetArticleAsync(id, null);
        }
        
        /// <remarks/>
        public void GetArticleAsync(System.Guid id, object userState) {
            if ((this.GetArticleOperationCompleted == null)) {
                this.GetArticleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetArticleOperationCompleted);
            }
            this.InvokeAsync("GetArticle", new object[] {
                        id}, this.GetArticleOperationCompleted, userState);
        }
        
        private void OnGetArticleOperationCompleted(object arg) {
            if ((this.GetArticleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetArticleCompleted(this, new GetArticleCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetArticle1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetArticleArray", RequestElementName="GetArticleArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetArticleArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetArticleArrayResult")]
        public Article[] GetArticle(System.Guid[] ids) {
            object[] results = this.Invoke("GetArticle1", new object[] {
                        ids});
            return ((Article[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetArticle1(System.Guid[] ids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetArticle1", new object[] {
                        ids}, callback, asyncState);
        }
        
        /// <remarks/>
        public Article[] EndGetArticle1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Article[])(results[0]));
        }
        
        /// <remarks/>
        public void GetArticle1Async(System.Guid[] ids) {
            this.GetArticle1Async(ids, null);
        }
        
        /// <remarks/>
        public void GetArticle1Async(System.Guid[] ids, object userState) {
            if ((this.GetArticle1OperationCompleted == null)) {
                this.GetArticle1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetArticle1OperationCompleted);
            }
            this.InvokeAsync("GetArticle1", new object[] {
                        ids}, this.GetArticle1OperationCompleted, userState);
        }
        
        private void OnGetArticle1OperationCompleted(object arg) {
            if ((this.GetArticle1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetArticle1Completed(this, new GetArticle1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetContributor", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Contributor GetContributor(System.Guid id) {
            object[] results = this.Invoke("GetContributor", new object[] {
                        id});
            return ((Contributor)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetContributor(System.Guid id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetContributor", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public Contributor EndGetContributor(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Contributor)(results[0]));
        }
        
        /// <remarks/>
        public void GetContributorAsync(System.Guid id) {
            this.GetContributorAsync(id, null);
        }
        
        /// <remarks/>
        public void GetContributorAsync(System.Guid id, object userState) {
            if ((this.GetContributorOperationCompleted == null)) {
                this.GetContributorOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetContributorOperationCompleted);
            }
            this.InvokeAsync("GetContributor", new object[] {
                        id}, this.GetContributorOperationCompleted, userState);
        }
        
        private void OnGetContributorOperationCompleted(object arg) {
            if ((this.GetContributorCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetContributorCompleted(this, new GetContributorCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetContributor1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetContributorArray", RequestElementName="GetContributorArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetContributorArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetContributorArrayResult")]
        public Contributor[] GetContributor(System.Guid[] ids) {
            object[] results = this.Invoke("GetContributor1", new object[] {
                        ids});
            return ((Contributor[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetContributor1(System.Guid[] ids, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetContributor1", new object[] {
                        ids}, callback, asyncState);
        }
        
        /// <remarks/>
        public Contributor[] EndGetContributor1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Contributor[])(results[0]));
        }
        
        /// <remarks/>
        public void GetContributor1Async(System.Guid[] ids) {
            this.GetContributor1Async(ids, null);
        }
        
        /// <remarks/>
        public void GetContributor1Async(System.Guid[] ids, object userState) {
            if ((this.GetContributor1OperationCompleted == null)) {
                this.GetContributor1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetContributor1OperationCompleted);
            }
            this.InvokeAsync("GetContributor1", new object[] {
                        ids}, this.GetContributor1OperationCompleted, userState);
        }
        
        private void OnGetContributor1OperationCompleted(object arg) {
            if ((this.GetContributor1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetContributor1Completed(this, new GetContributor1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveVideoEncoding", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveVideoEncoding(VideoEncoding videoEncoding) {
            this.Invoke("SaveVideoEncoding", new object[] {
                        videoEncoding});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveVideoEncoding(VideoEncoding videoEncoding, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveVideoEncoding", new object[] {
                        videoEncoding}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveVideoEncoding(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveVideoEncodingAsync(VideoEncoding videoEncoding) {
            this.SaveVideoEncodingAsync(videoEncoding, null);
        }
        
        /// <remarks/>
        public void SaveVideoEncodingAsync(VideoEncoding videoEncoding, object userState) {
            if ((this.SaveVideoEncodingOperationCompleted == null)) {
                this.SaveVideoEncodingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveVideoEncodingOperationCompleted);
            }
            this.InvokeAsync("SaveVideoEncoding", new object[] {
                        videoEncoding}, this.SaveVideoEncodingOperationCompleted, userState);
        }
        
        private void OnSaveVideoEncodingOperationCompleted(object arg) {
            if ((this.SaveVideoEncodingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveVideoEncodingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveAudioEncoding", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveAudioEncoding(AudioEncoding audioEncoding) {
            this.Invoke("SaveAudioEncoding", new object[] {
                        audioEncoding});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveAudioEncoding(AudioEncoding audioEncoding, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveAudioEncoding", new object[] {
                        audioEncoding}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveAudioEncoding(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveAudioEncodingAsync(AudioEncoding audioEncoding) {
            this.SaveAudioEncodingAsync(audioEncoding, null);
        }
        
        /// <remarks/>
        public void SaveAudioEncodingAsync(AudioEncoding audioEncoding, object userState) {
            if ((this.SaveAudioEncodingOperationCompleted == null)) {
                this.SaveAudioEncodingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveAudioEncodingOperationCompleted);
            }
            this.InvokeAsync("SaveAudioEncoding", new object[] {
                        audioEncoding}, this.SaveAudioEncodingOperationCompleted, userState);
        }
        
        private void OnSaveAudioEncodingOperationCompleted(object arg) {
            if ((this.SaveAudioEncodingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveAudioEncodingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveContributor", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveContributor(Contributor contributor) {
            this.Invoke("SaveContributor", new object[] {
                        contributor});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveContributor(Contributor contributor, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveContributor", new object[] {
                        contributor}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveContributor(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveContributorAsync(Contributor contributor) {
            this.SaveContributorAsync(contributor, null);
        }
        
        /// <remarks/>
        public void SaveContributorAsync(Contributor contributor, object userState) {
            if ((this.SaveContributorOperationCompleted == null)) {
                this.SaveContributorOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveContributorOperationCompleted);
            }
            this.InvokeAsync("SaveContributor", new object[] {
                        contributor}, this.SaveContributorOperationCompleted, userState);
        }
        
        private void OnSaveContributorOperationCompleted(object arg) {
            if ((this.SaveContributorCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveContributorCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAudioEncodingArray", RequestElementName="GetAudioEncodingArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetAudioEncodingArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetAudioEncodingArrayResult")]
        public AudioEncoding[] GetAudioEncoding() {
            object[] results = this.Invoke("GetAudioEncoding", new object[0]);
            return ((AudioEncoding[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAudioEncoding(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAudioEncoding", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public AudioEncoding[] EndGetAudioEncoding(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AudioEncoding[])(results[0]));
        }
        
        /// <remarks/>
        public void GetAudioEncodingAsync() {
            this.GetAudioEncodingAsync(null);
        }
        
        /// <remarks/>
        public void GetAudioEncodingAsync(object userState) {
            if ((this.GetAudioEncodingOperationCompleted == null)) {
                this.GetAudioEncodingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAudioEncodingOperationCompleted);
            }
            this.InvokeAsync("GetAudioEncoding", new object[0], this.GetAudioEncodingOperationCompleted, userState);
        }
        
        private void OnGetAudioEncodingOperationCompleted(object arg) {
            if ((this.GetAudioEncodingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAudioEncodingCompleted(this, new GetAudioEncodingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetClientTypeArray", RequestElementName="GetClientTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetClientTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetClientTypeArrayResult")]
        public ClientType[] GetClientType() {
            object[] results = this.Invoke("GetClientType", new object[0]);
            return ((ClientType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetClientType(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetClientType", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public ClientType[] EndGetClientType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ClientType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetClientTypeAsync() {
            this.GetClientTypeAsync(null);
        }
        
        /// <remarks/>
        public void GetClientTypeAsync(object userState) {
            if ((this