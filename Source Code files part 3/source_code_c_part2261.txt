PC_FAR *Max )( 
            IRangeList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IRangeList __RPC_FAR * This,
            /* [out] */ byte __RPC_FAR *__RPC_FAR *ppbDestination,
            /* [out] */ ULONG __RPC_FAR *pulSizeOfDestination);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IRangeList __RPC_FAR * This,
            /* [size_is][in] */ byte __RPC_FAR *pbSource,
            /* [in] */ const ULONG ulSizeOfSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRange )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG low,
            /* [in] */ const ULONG high);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSingleValue )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG value);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRangeList )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const IRangeList __RPC_FAR *prl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRange )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG low,
            /* [in] */ const ULONG high);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSingleValue )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG value);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRangeList )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const IRangeList __RPC_FAR *prl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MinOfRange )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG value,
            /* [out] */ ULONG __RPC_FAR *pulMinOfRange);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MaxOfRange )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG value,
            /* [out] */ ULONG __RPC_FAR *pulMaxOfRange);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeToIMAPString )( 
            IRangeList __RPC_FAR * This,
            /* [out] */ LPSTR __RPC_FAR *ppszDestination,
            /* [out] */ LPDWORD pdwLengthOfDestination);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG current,
            /* [out] */ ULONG __RPC_FAR *pulNext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Prev )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG current,
            /* [out] */ ULONG __RPC_FAR *pulPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cardinality )( 
            IRangeList __RPC_FAR * This,
            ULONG __RPC_FAR *pulCardinality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CardinalityFrom )( 
            IRangeList __RPC_FAR * This,
            /* [in] */ const ULONG ulStartPoint,
            /* [out] */ ULONG __RPC_FAR *pulCardinalityFrom);
        
        END_INTERFACE
    } IRangeListVtbl;

    interface IRangeList
    {
        CONST_VTBL struct IRangeListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRangeList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRangeList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRangeList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRangeList_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IRangeList_IsInRange(This,value)	\
    (This)->lpVtbl -> IsInRange(This,value)

#define IRangeList_Min(This,pulMin)	\
    (This)->lpVtbl -> Min(This,pulMin)

#define IRangeList_Max(This,pulMax)	\
    (This)->lpVtbl -> Max(This,pulMax)

#define IRangeList_Save(This,ppbDestination,pulSizeOfDestination)	\
    (This)->lpVtbl -> Save(This,ppbDestination,pulSizeOfDestination)

#define IRangeList_Load(This,pbSource,ulSizeOfSource)	\
    (This)->lpVtbl -> Load(This,pbSource,ulSizeOfSource)

#define IRangeList_AddRange(This,low,high)	\
    (This)->lpVtbl -> AddRange(This,low,high)

#define IRangeList_AddSingleValue(This,value)	\
    (This)->lpVtbl -> AddSingleValue(This,value)

#define IRangeList_AddRangeList(This,prl)	\
    (This)->lpVtbl -> AddRangeList(This,prl)

#define IRangeList_DeleteRange(This,low,high)	\
    (This)->lpVtbl -> DeleteRange(This,low,high)

#define IRangeList_DeleteSingleValue(This,value)	\
    (This)->lpVtbl -> DeleteSingleValue(This,value)

#define IRangeList_DeleteRangeList(This,prl)	\
    (This)->lpVtbl -> DeleteRangeList(This,prl)

#define IRangeList_MinOfRange(This,value,pulMinOfRange)	\
    (This)->lpVtbl -> MinOfRange(This,value,pulMinOfRange)

#define IRangeList_MaxOfRange(This,value,pulMaxOfRange)	\
    (This)->lpVtbl -> MaxOfRange(This,value,pulMaxOfRange)

#define IRangeList_RangeToIMAPString(This,ppszDestination,pdwLengthOfDestination)	\
    (This)->lpVtbl -> RangeToIMAPString(This,ppszDestination,pdwLengthOfDestination)

#define IRangeList_Next(This,current,pulNext)	\
    (This)->lpVtbl -> Next(This,current,pulNext)

#define IRangeList_Prev(This,current,pulPrev)	\
    (This)->lpVtbl -> Prev(This,current,pulPrev)

#define IRangeList_Cardinality(This,pulCardinality)	\
    (This)->lpVtbl -> Cardinality(This,pulCardinality)

#define IRangeList_CardinalityFrom(This,ulStartPoint,pulCardinalityFrom)	\
    (This)->lpVtbl -> CardinalityFrom(This,ulStartPoint,pulCardinalityFrom)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRangeList_Clear_Proxy( 
    IRangeList __RPC_FAR * This);


void __RPC_STUB IRangeList_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_IsInRange_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG value);


void __RPC_STUB IRangeList_IsInRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Min_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulMin);


void __RPC_STUB IRangeList_Min_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Max_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulMax);


void __RPC_STUB IRangeList_Max_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Save_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [out] */ byte __RPC_FAR *__RPC_FAR *ppbDestination,
    /* [out] */ ULONG __RPC_FAR *pulSizeOfDestination);


void __RPC_STUB IRangeList_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Load_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [size_is][in] */ byte __RPC_FAR *pbSource,
    /* [in] */ const ULONG ulSizeOfSource);


void __RPC_STUB IRangeList_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_AddRange_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG low,
    /* [in] */ const ULONG high);


void __RPC_STUB IRangeList_AddRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_AddSingleValue_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG value);


void __RPC_STUB IRangeList_AddSingleValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_AddRangeList_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const IRangeList __RPC_FAR *prl);


void __RPC_STUB IRangeList_AddRangeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_DeleteRange_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG low,
    /* [in] */ const ULONG high);


void __RPC_STUB IRangeList_DeleteRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_DeleteSingleValue_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG value);


void __RPC_STUB IRangeList_DeleteSingleValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_DeleteRangeList_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const IRangeList __RPC_FAR *prl);


void __RPC_STUB IRangeList_DeleteRangeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_MinOfRange_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG value,
    /* [out] */ ULONG __RPC_FAR *pulMinOfRange);


void __RPC_STUB IRangeList_MinOfRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_MaxOfRange_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG value,
    /* [out] */ ULONG __RPC_FAR *pulMaxOfRange);


void __RPC_STUB IRangeList_MaxOfRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_RangeToIMAPString_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [out] */ LPSTR __RPC_FAR *ppszDestination,
    /* [out] */ LPDWORD pdwLengthOfDestination);


void __RPC_STUB IRangeList_RangeToIMAPString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Next_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG current,
    /* [out] */ ULONG __RPC_FAR *pulNext);


void __RPC_STUB IRangeList_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Prev_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG current,
    /* [out] */ ULONG __RPC_FAR *pulPrev);


void __RPC_STUB IRangeList_Prev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_Cardinality_Proxy( 
    IRangeList __RPC_FAR * This,
    ULONG __RPC_FAR *pulCardinality);


void __RPC_STUB IRangeList_Cardinality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRangeList_CardinalityFrom_Proxy( 
    IRangeList __RPC_FAR * This,
    /* [in] */ const ULONG ulStartPoint,
    /* [out] */ ULONG __RPC_FAR *pulCardinalityFrom);


void __RPC_STUB IRangeList_CardinalityFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRangeList_INTERFACE_DEFINED__ */


#ifndef __IIMAPCallback_INTERFACE_DEFINED__
#define __IIMAPCallback_INTERFACE_DEFINED__

/* interface IIMAPCallback */
/* [object][local][helpstring][uuid] */ 

typedef DWORD IMAP_MBOXFLAGS;

#define	IMAP_MBOX_NOFLAGS	( 0 )

#define	IMAP_MBOX_MARKED	( 0x1 )

#define	IMAP_MBOX_NOINFERIORS	( 0x2 )

#define	IMAP_MBOX_NOSELECT	( 0x4 )

#define	IMAP_MBOX_UNMARKED	( 0x8 )

#define	IMAP_MBOX_ALLFLAGS	( 0xf )

typedef 
enum tagIMAP_RESPONSE_TYPE
    {	irtERROR_NOTIFICATION	= 0,
	irtCOMMAND_COMPLETION	= irtERROR_NOTIFICATION + 1,
	irtSERVER_ALERT	= irtCOMMAND_COMPLETION + 1,
	irtPARSE_ERROR	= irtSERVER_ALERT + 1,
	irtMAILBOX_UPDATE	= irtPARSE_ERROR + 1,
	irtDELETED_MSG	= irtMAILBOX_UPDATE + 1,
	irtFETCH_BODY	= irtDELETED_MSG + 1,
	irtUPDATE_MSG	= irtFETCH_BODY + 1,
	irtAPPLICABLE_FLAGS	= irtUPDATE_MSG + 1,
	irtPERMANENT_FLAGS	= irtAPPLICABLE_FLAGS + 1,
	irtUIDVALIDITY	= irtPERMANENT_FLAGS + 1,
	irtREADWRITE_STATUS	= irtUIDVALIDITY + 1,
	irtTRYCREATE	= irtREADWRITE_STATUS + 1,
	irtSEARCH	= irtTRYCREATE + 1,
	irtMAILBOX_LISTING	= irtSEARCH + 1,
	irtMAILBOX_STATUS	= irtMAILBOX_LISTING + 1,
	irtAPPEND_PROGRESS	= irtMAILBOX_STATUS + 1,
	irtUPDATE_MSG_EX	= irtAPPEND_PROGRESS + 1
    }	IMAP_RESPONSE_TYPE;

typedef struct tagFETCH_BODY_PART
    {
    DWORD dwMsgSeqNum;
    LPSTR pszBodyTag;
    DWORD dwTotalBytes;
    DWORD dwSizeOfData;
    DWORD dwOffset;
    BOOL fDone;
    LPSTR pszData;
    LPARAM lpFetchCookie1;
    LPARAM lpFetchCookie2;
    }	FETCH_BODY_PART;

typedef struct tagFETCH_CMD_RESULTS
    {
    DWORD dwMsgSeqNum;
    BOOL bMsgFlags;
    IMAP_MSGFLAGS mfMsgFlags;
    BOOL bRFC822Size;
    DWORD dwRFC822Size;
    BOOL bUID;
    DWORD dwUID;
    BOOL bInternalDate;
    FILETIME ftInternalDate;
    LPARAM lpFetchCookie1;
    LPARAM lpFetchCookie2;
    }	FETCH_CMD_RESULTS;

typedef struct tagIMAPADDR
    {
    LPSTR pszName;
    LPSTR pszADL;
    LPSTR pszMailbox;
    LPSTR pszHost;
    struct tagIMAPADDR __RPC_FAR *pNext;
    }	IMAPADDR;

typedef struct tagFETCH_CMD_RESULTS_EX
    {
    DWORD dwMsgSeqNum;
    BOOL bMsgFlags;
    IMAP_MSGFLAGS mfMsgFlags;
    BOOL bRFC822Size;
    DWORD dwRFC822Size;
    BOOL bUID;
    DWORD dwUID;
    BOOL bInternalDate;
    FILETIME ftInternalDate;
    LPARAM lpFetchCookie1;
    LPARAM lpFetchCookie2;
    BOOL bEnvelope;
    FILETIME ftENVDate;
    LPSTR pszENVSubject;
    IMAPADDR __RPC_FAR *piaENVFrom;
    IMAPADDR __RPC_FAR *piaENVSender;
    IMAPADDR __RPC_FAR *piaENVReplyTo;
    IMAPADDR __RPC_FAR *piaENVTo;
    IMAPADDR __RPC_FAR *piaENVCc;
    IMAPADDR __RPC_FAR *piaENVBcc;
    LPSTR pszENVInReplyTo;
    LPSTR pszENVMessageID;
    DWORD dwReserved1;
    DWORD dwReserved2;
    DWORD dwReserved3;
    }	FETCH_CMD_RESULTS_EX;

typedef struct tagMBOX_MSGCOUNT
    {
    BOOL bGotExistsResponse;
    DWORD dwExists;
    BOOL bGotRecentResponse;
    DWORD dwRecent;
    BOOL bGotUnseenResponse;
    DWORD dwUnseen;
    }	MBOX_MSGCOUNT;

typedef struct tagIMAP_LISTLSUB_RESPONSE
    {
    LPSTR pszMailboxName;
    IMAP_MBOXFLAGS imfMboxFlags;
    char cHierarchyChar;
    }	IMAP_LISTLSUB_RESPONSE;

typedef struct tagIMAP_STATUS_RESPONSE
    {
    LPSTR pszMailboxName;
    BOOL fMessages;
    DWORD dwMessages;
    BOOL fRecent;
    DWORD dwRecent;
    BOOL fUIDNext;
    DWORD dwUIDNext;
    BOOL fUIDValidity;
    DWORD dwUIDValidity;
    BOOL fUnseen;
    DWORD dwUnseen;
    }	IMAP_STATUS_RESPONSE;

typedef struct tagAPPEND_PROGRESS
    {
    DWORD dwUploaded;
    DWORD dwTotal;
    }	APPEND_PROGRESS;

typedef /* [switch_type] */ union tagIMAP_RESPONSE_DATA
    {
    /* [case()] */ MBOX_MSGCOUNT __RPC_FAR *pmcMsgCount;
    /* [case()] */ DWORD dwDeletedMsgSeqNum;
    /* [case()] */ FETCH_BODY_PART __RPC_FAR *pFetchBodyPart;
    /* [case()] */ FETCH_CMD_RESULTS __RPC_FAR *pFetchResults;
    /* [case()] */ IMAP_MSGFLAGS imfImapMessageFlags;
    /* [case()] */ DWORD dwUIDValidity;
    /* [case()] */ BOOL bReadWrite;
    /* [case()] */ IRangeList __RPC_FAR *prlSearchResults;
    /* [case()] */ IMAP_LISTLSUB_RESPONSE illrdMailboxListing;
    /* [case()] */ IMAP_STATUS_RESPONSE __RPC_FAR *pisrStatusResponse;
    /* [case()] */ APPEND_PROGRESS __RPC_FAR *papAppendProgress;
    /* [case()] */ FETCH_CMD_RESULTS_EX __RPC_FAR *pFetchResultsEx;
    }	IMAP_RESPONSE_DATA;

typedef struct tagIMAP_RESPONSE
    {
    WPARAM wParam;
    LPARAM lParam;
    HRESULT hrResult;
    LPSTR lpszResponseText;
    IMAP_RESPONSE_TYPE irtResponseType;
    /* [switch_is] */ IMAP_RESPONSE_DATA irdResponseData;
    }	IMAP_RESPONSE;


EXTERN_C const IID IID_IIMAPCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9E9D8A3-4EDD-11d0-874F-00AA00530EE9")
    IIMAPCallback : public ITransportCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ const IMAP_RESPONSE __RPC_FAR *pirIMAPResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMAPCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIMAPCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIMAPCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIMAPCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimeout )( 
            IIMAPCallback __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwTimeout,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLogonPrompt )( 
            IIMAPCallback __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        INT ( STDMETHODCALLTYPE __RPC_FAR *OnPrompt )( 
            IIMAPCallback __RPC_FAR * This,
            /* [in] */ HRESULT hrError,
            /* [in] */ LPCTSTR pszText,
            /* [in] */ LPCTSTR pszCaption,
            /* [in] */ UINT uType,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IIMAPCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnError )( 
            IIMAPCallback __RPC_FAR * This,
            /* [in] */ IXPSTATUS ixpstatus,
            /* [in] */ LPIXPRESULT pResult,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCommand )( 
            IIMAPCallback __RPC_FAR * This,
            /* [in] */ CMDTYPE cmdtype,
            /* [in] */ LPSTR pszLine,
            /* [in] */ HRESULT hrResponse,
            /* [in] */ IInternetTransport __RPC_FAR *pTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            IIMAPCallback __RPC_FAR * This,
            /* [in] */ const IMAP_RESPONSE __RPC_FAR *pirIMAPResponse);
        
        END_INTERFACE
    } IIMAPCallbackVtbl;

    interface IIMAPCallback
    {
        CONST_VTBL struct IIMAPCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMAPCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIMAPCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIMAPCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIMAPCallback_OnTimeout(This,pdwTimeout,pTransport)	\
    (This)->lpVtbl -> OnTimeout(This,pdwTimeout,pTransport)

#define IIMAPCallback_OnLogonPrompt(This,pInetServer,pTransport)	\
    (This)->lpVtbl -> OnLogonPrompt(This,pInetServer,pTransport)

#define IIMAPCallback_OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)	\
    (This)->lpVtbl -> OnPrompt(This,hrError,pszText,pszCaption,uType,pTransport)

#define IIMAPCallback_OnStatus(This,ixpstatus,pTransport)	\
    (This)->lpVtbl -> OnStatus(This,ixpstatus,pTransport)

#define IIMAPCallback_OnError(This,ixpstatus,pResult,pTransport)	\
    (This)->lpVtbl -> OnError(This,ixpstatus,pResult,pTransport)

#define IIMAPCallback_OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)	\
    (This)->lpVtbl -> OnCommand(This,cmdtype,pszLine,hrResponse,pTransport)


#define IIMAPCallback_OnResponse(This,pirIMAPResponse)	\
    (This)->lpVtbl -> OnResponse(This,pirIMAPResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIMAPCallback_OnResponse_Proxy( 
    IIMAPCallback __RPC_FAR * This,
    /* [in] */ const IMAP_RESPONSE __RPC_FAR *pirIMAPResponse);


void __RPC_STUB IIMAPCallback_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIMAPCallback_INTERFACE_DEFINED__ */


#ifndef __IIMAPTransport_INTERFACE_DEFINED__
#define __IIMAPTransport_INTERFACE_DEFINED__

/* interface IIMAPTransport */
/* [object][local][helpstring][uuid] */ 

#define	IMAP_CAPABILITY_IMAP4	( 0x1 )

#define	IMAP_CAPABILITY_IMAP4rev1	( 0x2 )

#define	IMAP_CAPABILITY_IDLE	( 0x4 )

#define	IMAP_CAPABILITY_ALLFLAGS	( 0x7 )


EXTERN_C const IID IID_IIMAPTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9E9D8A8-4EDD-11d0-874F-00AA00530EE9")
    IIMAPTransport : public IInternetTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewIRangeList( 
            /* [out] */ IRangeList __RPC_FAR *__RPC_FAR *pprlNewRangeList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Capability( 
            /* [out] */ DWORD __RPC_FAR *pdwCapabilityFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Examine( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rename( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName,
            /* [in] */ LPSTR lpszNewMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Subscribe( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsubscribe( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE List( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxNameReference,
            /* [in] */ LPSTR lpszMailboxNamePattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lsub( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxNameReference,
            /* [in] */ LPSTR lpszMailboxNamePattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName,
            /* [in] */ LPSTR lpszMessageFlags,
            /* [in] */ FILETIME ftMessageDateTime,
            /* [in] */ LPSTREAM lpstmMessageToSave) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Expunge( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Search( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszSearchCriteria,
            /* [in] */ boolean bReturnUIDs,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Fetch( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDMsgRange,
            /* [in] */ LPSTR lpszFetchArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Store( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList,
            /* [in] */ LPSTR lpszStoreArgs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Copy( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList,
            /* [in] */ LPSTR lpszMailboxName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Noop( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeMsgSeqNumTable( 
            /* [in] */ DWORD dwSizeOfMbox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateSeqNumToUID( 
            /* [in] */ DWORD dwMsgSeqNum,
            /* [in] */ DWORD dwUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSequenceNum( 
            /* [in] */ DWORD dwDeletedMsgSeqNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MsgSeqNumToUID( 
            /* [in] */ DWORD dwMsgSeqNum,
            /* [out] */ DWORD __RPC_FAR *pdwUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMsgSeqNumToUIDArray( 
            /* [out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwMsgSeqNumToUIDArray,
            /* [out] */ DWORD __RPC_FAR *pdwNumberOfElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHighestMsgSeqNum( 
            /* [out] */ DWORD __RPC_FAR *pdwHighestMSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetMsgSeqNumToUID( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultCBHandler( 
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Status( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR pszMailboxName,
            /* [in] */ LPSTR pszStatusCmdArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMAPTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIMAPTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIMAPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IIMAPTransport __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            IIMAPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            IIMAPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IIMAPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            IIMAPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IIMAPTransport __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewIRangeList )( 
            IIMAPTransport __RPC_FAR * This,
            /* [out] */ IRangeList __RPC_FAR *__RPC_FAR *pprlNewRangeList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Capability )( 
            IIMAPTransport __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilityFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Examine )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName,
            /* [in] */ LPSTR lpszNewMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Subscribe )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unsubscribe )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *List )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxNameReference,
            /* [in] */ LPSTR lpszMailboxNamePattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lsub )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxNameReference,
            /* [in] */ LPSTR lpszMailboxNamePattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName,
            /* [in] */ LPSTR lpszMessageFlags,
            /* [in] */ FILETIME ftMessageDateTime,
            /* [in] */ LPSTREAM lpstmMessageToSave);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expunge )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Search )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszSearchCriteria,
            /* [in] */ boolean bReturnUIDs,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Fetch )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDMsgRange,
            /* [in] */ LPSTR lpszFetchArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Store )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList,
            /* [in] */ LPSTR lpszStoreArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Noop )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResizeMsgSeqNumTable )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ DWORD dwSizeOfMbox);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateSeqNumToUID )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ DWORD dwMsgSeqNum,
            /* [in] */ DWORD dwUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSequenceNum )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ DWORD dwDeletedMsgSeqNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MsgSeqNumToUID )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ DWORD dwMsgSeqNum,
            /* [out] */ DWORD __RPC_FAR *pdwUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMsgSeqNumToUIDArray )( 
            IIMAPTransport __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwMsgSeqNumToUIDArray,
            /* [out] */ DWORD __RPC_FAR *pdwNumberOfElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHighestMsgSeqNum )( 
            IIMAPTransport __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwHighestMSN);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetMsgSeqNumToUID )( 
            IIMAPTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultCBHandler )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Status )( 
            IIMAPTransport __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR pszMailboxName,
            /* [in] */ LPSTR pszStatusCmdArgs);
        
        END_INTERFACE
    } IIMAPTransportVtbl;

    interface IIMAPTransport
    {
        CONST_VTBL struct IIMAPTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMAPTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIMAPTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIMAPTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIMAPTransport_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define IIMAPTransport_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define IIMAPTransport_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define IIMAPTransport_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define IIMAPTransport_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define IIMAPTransport_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define IIMAPTransport_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IIMAPTransport_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define IIMAPTransport_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define IIMAPTransport_InitNew(This,pszLogFilePath,pCBHandler)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCBHandler)

#define IIMAPTransport_NewIRangeList(This,pprlNewRangeList)	\
    (This)->lpVtbl -> NewIRangeList(This,pprlNewRangeList)

#define IIMAPTransport_Capability(This,pdwCapabilityFlags)	\
    (This)->lpVtbl -> Capability(This,pdwCapabilityFlags)

#define IIMAPTransport_Select(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Select(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport_Examine(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Examine(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport_Create(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Create(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport_Delete(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Delete(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport_Rename(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszNewMailboxName)	\
    (This)->lpVtbl -> Rename(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszNewMailboxName)

#define IIMAPTransport_Subscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Subscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport_Unsubscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Unsubscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport_List(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)	\
    (This)->lpVtbl -> List(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)

#define IIMAPTransport_Lsub(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)	\
    (This)->lpVtbl -> Lsub(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)

#define IIMAPTransport_Append(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszMessageFlags,ftMessageDateTime,lpstmMessageToSave)	\
    (This)->lpVtbl -> Append(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszMessageFlags,ftMessageDateTime,lpstmMessageToSave)

#define IIMAPTransport_Close(This,wParam,lParam,pCBHandler)	\
    (This)->lpVtbl -> Close(This,wParam,lParam,pCBHandler)

#define IIMAPTransport_Expunge(This,wParam,lParam,pCBHandler)	\
    (This)->lpVtbl -> Expunge(This,wParam,lParam,pCBHandler)

#define IIMAPTransport_Search(This,wParam,lParam,pCBHandler,lpszSearchCriteria,bReturnUIDs,pMsgRange,bUIDRangeList)	\
    (This)->lpVtbl -> Search(This,wParam,lParam,pCBHandler,lpszSearchCriteria,bReturnUIDs,pMsgRange,bUIDRangeList)

#define IIMAPTransport_Fetch(This,wParam,lParam,pCBHandler,pMsgRange,bUIDMsgRange,lpszFetchArgs)	\
    (This)->lpVtbl -> Fetch(This,wParam,lParam,pCBHandler,pMsgRange,bUIDMsgRange,lpszFetchArgs)

#define IIMAPTransport_Store(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszStoreArgs)	\
    (This)->lpVtbl -> Store(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszStoreArgs)

#define IIMAPTransport_Copy(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszMailboxName)	\
    (This)->lpVtbl -> Copy(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszMailboxName)

#define IIMAPTransport_Noop(This,wParam,lParam,pCBHandler)	\
    (This)->lpVtbl -> Noop(This,wParam,lParam,pCBHandler)

#define IIMAPTransport_ResizeMsgSeqNumTable(This,dwSizeOfMbox)	\
    (This)->lpVtbl -> ResizeMsgSeqNumTable(This,dwSizeOfMbox)

#define IIMAPTransport_UpdateSeqNumToUID(This,dwMsgSeqNum,dwUID)	\
    (This)->lpVtbl -> UpdateSeqNumToUID(This,dwMsgSeqNum,dwUID)

#define IIMAPTransport_RemoveSequenceNum(This,dwDeletedMsgSeqNum)	\
    (This)->lpVtbl -> RemoveSequenceNum(This,dwDeletedMsgSeqNum)

#define IIMAPTransport_MsgSeqNumToUID(This,dwMsgSeqNum,pdwUID)	\
    (This)->lpVtbl -> MsgSeqNumToUID(This,dwMsgSeqNum,pdwUID)

#define IIMAPTransport_GetMsgSeqNumToUIDArray(This,ppdwMsgSeqNumToUIDArray,pdwNumberOfElements)	\
    (This)->lpVtbl -> GetMsgSeqNumToUIDArray(This,ppdwMsgSeqNumToUIDArray,pdwNumberOfElements)

#define IIMAPTransport_GetHighestMsgSeqNum(This,pdwHighestMSN)	\
    (This)->lpVtbl -> GetHighestMsgSeqNum(This,pdwHighestMSN)

#define IIMAPTransport_ResetMsgSeqNumToUID(This)	\
    (This)->lpVtbl -> ResetMsgSeqNumToUID(This)

#define IIMAPTransport_SetDefaultCBHandler(This,pCBHandler)	\
    (This)->lpVtbl -> SetDefaultCBHandler(This,pCBHandler)

#define IIMAPTransport_Status(This,wParam,lParam,pCBHandler,pszMailboxName,pszStatusCmdArgs)	\
    (This)->lpVtbl -> Status(This,wParam,lParam,pCBHandler,pszMailboxName,pszStatusCmdArgs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIMAPTransport_InitNew_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ LPSTR pszLogFilePath,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);


void __RPC_STUB IIMAPTransport_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_NewIRangeList_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [out] */ IRangeList __RPC_FAR *__RPC_FAR *pprlNewRangeList);


void __RPC_STUB IIMAPTransport_NewIRangeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Capability_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCapabilityFlags);


void __RPC_STUB IIMAPTransport_Capability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Select_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Examine_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Examine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Create_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Delete_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Rename_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName,
    /* [in] */ LPSTR lpszNewMailboxName);


void __RPC_STUB IIMAPTransport_Rename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Subscribe_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Subscribe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Unsubscribe_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Unsubscribe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_List_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxNameReference,
    /* [in] */ LPSTR lpszMailboxNamePattern);


void __RPC_STUB IIMAPTransport_List_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Lsub_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxNameReference,
    /* [in] */ LPSTR lpszMailboxNamePattern);


void __RPC_STUB IIMAPTransport_Lsub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Append_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszMailboxName,
    /* [in] */ LPSTR lpszMessageFlags,
    /* [in] */ FILETIME ftMessageDateTime,
    /* [in] */ LPSTREAM lpstmMessageToSave);


void __RPC_STUB IIMAPTransport_Append_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Close_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);


void __RPC_STUB IIMAPTransport_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Expunge_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);


void __RPC_STUB IIMAPTransport_Expunge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Search_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR lpszSearchCriteria,
    /* [in] */ boolean bReturnUIDs,
    /* [in] */ IRangeList __RPC_FAR *pMsgRange,
    /* [in] */ boolean bUIDRangeList);


void __RPC_STUB IIMAPTransport_Search_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Fetch_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ IRangeList __RPC_FAR *pMsgRange,
    /* [in] */ boolean bUIDMsgRange,
    /* [in] */ LPSTR lpszFetchArgs);


void __RPC_STUB IIMAPTransport_Fetch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Store_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ IRangeList __RPC_FAR *pMsgRange,
    /* [in] */ boolean bUIDRangeList,
    /* [in] */ LPSTR lpszStoreArgs);


void __RPC_STUB IIMAPTransport_Store_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Copy_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ IRangeList __RPC_FAR *pMsgRange,
    /* [in] */ boolean bUIDRangeList,
    /* [in] */ LPSTR lpszMailboxName);


void __RPC_STUB IIMAPTransport_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Noop_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);


void __RPC_STUB IIMAPTransport_Noop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_ResizeMsgSeqNumTable_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ DWORD dwSizeOfMbox);


void __RPC_STUB IIMAPTransport_ResizeMsgSeqNumTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_UpdateSeqNumToUID_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ DWORD dwMsgSeqNum,
    /* [in] */ DWORD dwUID);


void __RPC_STUB IIMAPTransport_UpdateSeqNumToUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_RemoveSequenceNum_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ DWORD dwDeletedMsgSeqNum);


void __RPC_STUB IIMAPTransport_RemoveSequenceNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_MsgSeqNumToUID_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ DWORD dwMsgSeqNum,
    /* [out] */ DWORD __RPC_FAR *pdwUID);


void __RPC_STUB IIMAPTransport_MsgSeqNumToUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_GetMsgSeqNumToUIDArray_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwMsgSeqNumToUIDArray,
    /* [out] */ DWORD __RPC_FAR *pdwNumberOfElements);


void __RPC_STUB IIMAPTransport_GetMsgSeqNumToUIDArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_GetHighestMsgSeqNum_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwHighestMSN);


void __RPC_STUB IIMAPTransport_GetHighestMsgSeqNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_ResetMsgSeqNumToUID_Proxy( 
    IIMAPTransport __RPC_FAR * This);


void __RPC_STUB IIMAPTransport_ResetMsgSeqNumToUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_SetDefaultCBHandler_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);


void __RPC_STUB IIMAPTransport_SetDefaultCBHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport_Status_Proxy( 
    IIMAPTransport __RPC_FAR * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
    /* [in] */ LPSTR pszMailboxName,
    /* [in] */ LPSTR pszStatusCmdArgs);


void __RPC_STUB IIMAPTransport_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIMAPTransport_INTERFACE_DEFINED__ */


#ifndef __IIMAPTransport2_INTERFACE_DEFINED__
#define __IIMAPTransport2_INTERFACE_DEFINED__

/* interface IIMAPTransport2 */
/* [object][local][helpstring][uuid] */ 

#define	IMAP_MBOXXLATE_DEFAULT	( 0 )

#define	IMAP_MBOXXLATE_DISABLE	( 0x1 )

#define	IMAP_MBOXXLATE_DISABLEIMAP4	( 0x2 )

#define	IMAP_MBOXXLATE_VERBATIMOK	( 0x4 )

#define	IMAP_MBOXXLATE_RETAINCP	( 0x8 )

#define	IMAP_IDLE_DISABLE	( 0 )

#define	IMAP_IDLE_ENABLE	( 0x1 )

#define	IMAP_FETCHEX_DISABLE	( 0 )

#define	IMAP_FETCHEX_ENABLE	( 0x1 )


EXTERN_C const IID IID_IIMAPTransport2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DA8283C0-37C5-11d2-ACD9-0080C7B6E3C5")
    IIMAPTransport2 : public IIMAPTransport
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDefaultCP( 
            /* [in] */ DWORD dwTranslateFlags,
            /* [in] */ UINT uiCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MultiByteToModifiedUTF7( 
            /* [in] */ LPCSTR pszSource,
            /* [out] */ LPSTR __RPC_FAR *ppszDestination,
            /* [in] */ UINT uiSourceCP,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifiedUTF7ToMultiByte( 
            /* [in] */ LPCSTR pszSource,
            /* [out] */ LPSTR __RPC_FAR *ppszDestination,
            /* [in] */ UINT uiDestinationCP,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIdleMode( 
            /* [in] */ DWORD dwIdleFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableFetchEx( 
            /* [in] */ DWORD dwFetchExFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindow( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetWindow( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIMAPTransport2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerInfo )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        IXPTYPE ( STDMETHODCALLTYPE __RPC_FAR *GetIXPType )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsState )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ IXPISSTATE isstate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InetServerFromAccount )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ IImnAccount __RPC_FAR *pAccount,
            /* [out][in] */ LPINETSERVER pInetServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ LPINETSERVER pInetServer,
            /* [in] */ boolean fAuthenticate,
            /* [in] */ boolean fCommandLogging);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandsOffCallback )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DropConnection )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [out] */ IXPSTATUS __RPC_FAR *pCurrentStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ LPSTR pszLogFilePath,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewIRangeList )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [out] */ IRangeList __RPC_FAR *__RPC_FAR *pprlNewRangeList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Capability )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCapabilityFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Examine )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rename )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName,
            /* [in] */ LPSTR lpszNewMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Subscribe )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unsubscribe )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *List )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxNameReference,
            /* [in] */ LPSTR lpszMailboxNamePattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lsub )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxNameReference,
            /* [in] */ LPSTR lpszMailboxNamePattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszMailboxName,
            /* [in] */ LPSTR lpszMessageFlags,
            /* [in] */ FILETIME ftMessageDateTime,
            /* [in] */ LPSTREAM lpstmMessageToSave);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expunge )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Search )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR lpszSearchCriteria,
            /* [in] */ boolean bReturnUIDs,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Fetch )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDMsgRange,
            /* [in] */ LPSTR lpszFetchArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Store )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList,
            /* [in] */ LPSTR lpszStoreArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ IRangeList __RPC_FAR *pMsgRange,
            /* [in] */ boolean bUIDRangeList,
            /* [in] */ LPSTR lpszMailboxName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Noop )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResizeMsgSeqNumTable )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwSizeOfMbox);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateSeqNumToUID )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwMsgSeqNum,
            /* [in] */ DWORD dwUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSequenceNum )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwDeletedMsgSeqNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MsgSeqNumToUID )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwMsgSeqNum,
            /* [out] */ DWORD __RPC_FAR *pdwUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMsgSeqNumToUIDArray )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *__RPC_FAR *ppdwMsgSeqNumToUIDArray,
            /* [out] */ DWORD __RPC_FAR *pdwNumberOfElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHighestMsgSeqNum )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwHighestMSN);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetMsgSeqNumToUID )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultCBHandler )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Status )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ IIMAPCallback __RPC_FAR *pCBHandler,
            /* [in] */ LPSTR pszMailboxName,
            /* [in] */ LPSTR pszStatusCmdArgs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultCP )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwTranslateFlags,
            /* [in] */ UINT uiCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MultiByteToModifiedUTF7 )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ LPCSTR pszSource,
            /* [out] */ LPSTR __RPC_FAR *ppszDestination,
            /* [in] */ UINT uiSourceCP,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifiedUTF7ToMultiByte )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ LPCSTR pszSource,
            /* [out] */ LPSTR __RPC_FAR *ppszDestination,
            /* [in] */ UINT uiDestinationCP,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIdleMode )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwIdleFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableFetchEx )( 
            IIMAPTransport2 __RPC_FAR * This,
            /* [in] */ DWORD dwFetchExFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWindow )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetWindow )( 
            IIMAPTransport2 __RPC_FAR * This);
        
        END_INTERFACE
    } IIMAPTransport2Vtbl;

    interface IIMAPTransport2
    {
        CONST_VTBL struct IIMAPTransport2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIMAPTransport2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIMAPTransport2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIMAPTransport2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIMAPTransport2_GetServerInfo(This,pInetServer)	\
    (This)->lpVtbl -> GetServerInfo(This,pInetServer)

#define IIMAPTransport2_GetIXPType(This)	\
    (This)->lpVtbl -> GetIXPType(This)

#define IIMAPTransport2_IsState(This,isstate)	\
    (This)->lpVtbl -> IsState(This,isstate)

#define IIMAPTransport2_InetServerFromAccount(This,pAccount,pInetServer)	\
    (This)->lpVtbl -> InetServerFromAccount(This,pAccount,pInetServer)

#define IIMAPTransport2_Connect(This,pInetServer,fAuthenticate,fCommandLogging)	\
    (This)->lpVtbl -> Connect(This,pInetServer,fAuthenticate,fCommandLogging)

#define IIMAPTransport2_HandsOffCallback(This)	\
    (This)->lpVtbl -> HandsOffCallback(This)

#define IIMAPTransport2_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IIMAPTransport2_DropConnection(This)	\
    (This)->lpVtbl -> DropConnection(This)

#define IIMAPTransport2_GetStatus(This,pCurrentStatus)	\
    (This)->lpVtbl -> GetStatus(This,pCurrentStatus)


#define IIMAPTransport2_InitNew(This,pszLogFilePath,pCBHandler)	\
    (This)->lpVtbl -> InitNew(This,pszLogFilePath,pCBHandler)

#define IIMAPTransport2_NewIRangeList(This,pprlNewRangeList)	\
    (This)->lpVtbl -> NewIRangeList(This,pprlNewRangeList)

#define IIMAPTransport2_Capability(This,pdwCapabilityFlags)	\
    (This)->lpVtbl -> Capability(This,pdwCapabilityFlags)

#define IIMAPTransport2_Select(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Select(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport2_Examine(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Examine(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport2_Create(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Create(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport2_Delete(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Delete(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport2_Rename(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszNewMailboxName)	\
    (This)->lpVtbl -> Rename(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszNewMailboxName)

#define IIMAPTransport2_Subscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Subscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport2_Unsubscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)	\
    (This)->lpVtbl -> Unsubscribe(This,wParam,lParam,pCBHandler,lpszMailboxName)

#define IIMAPTransport2_List(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)	\
    (This)->lpVtbl -> List(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)

#define IIMAPTransport2_Lsub(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)	\
    (This)->lpVtbl -> Lsub(This,wParam,lParam,pCBHandler,lpszMailboxNameReference,lpszMailboxNamePattern)

#define IIMAPTransport2_Append(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszMessageFlags,ftMessageDateTime,lpstmMessageToSave)	\
    (This)->lpVtbl -> Append(This,wParam,lParam,pCBHandler,lpszMailboxName,lpszMessageFlags,ftMessageDateTime,lpstmMessageToSave)

#define IIMAPTransport2_Close(This,wParam,lParam,pCBHandler)	\
    (This)->lpVtbl -> Close(This,wParam,lParam,pCBHandler)

#define IIMAPTransport2_Expunge(This,wParam,lParam,pCBHandler)	\
    (This)->lpVtbl -> Expunge(This,wParam,lParam,pCBHandler)

#define IIMAPTransport2_Search(This,wParam,lParam,pCBHandler,lpszSearchCriteria,bReturnUIDs,pMsgRange,bUIDRangeList)	\
    (This)->lpVtbl -> Search(This,wParam,lParam,pCBHandler,lpszSearchCriteria,bReturnUIDs,pMsgRange,bUIDRangeList)

#define IIMAPTransport2_Fetch(This,wParam,lParam,pCBHandler,pMsgRange,bUIDMsgRange,lpszFetchArgs)	\
    (This)->lpVtbl -> Fetch(This,wParam,lParam,pCBHandler,pMsgRange,bUIDMsgRange,lpszFetchArgs)

#define IIMAPTransport2_Store(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszStoreArgs)	\
    (This)->lpVtbl -> Store(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszStoreArgs)

#define IIMAPTransport2_Copy(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszMailboxName)	\
    (This)->lpVtbl -> Copy(This,wParam,lParam,pCBHandler,pMsgRange,bUIDRangeList,lpszMailboxName)

#define IIMAPTransport2_Noop(This,wParam,lParam,pCBHandler)	\
    (This)->lpVtbl -> Noop(This,wParam,lParam,pCBHandler)

#define IIMAPTransport2_ResizeMsgSeqNumTable(This,dwSizeOfMbox)	\
    (This)->lpVtbl -> ResizeMsgSeqNumTable(This,dwSizeOfMbox)

#define IIMAPTransport2_UpdateSeqNumToUID(This,dwMsgSeqNum,dwUID)	\
    (This)->lpVtbl -> UpdateSeqNumToUID(This,dwMsgSeqNum,dwUID)

#define IIMAPTransport2_RemoveSequenceNum(This,dwDeletedMsgSeqNum)	\
    (This)->lpVtbl -> RemoveSequenceNum(This,dwDeletedMsgSeqNum)

#define IIMAPTransport2_MsgSeqNumToUID(This,dwMsgSeqNum,pdwUID)	\
    (This)->lpVtbl -> MsgSeqNumToUID(This,dwMsgSeqNum,pdwUID)

#define IIMAPTransport2_GetMsgSeqNumToUIDArray(This,ppdwMsgSeqNumToUIDArray,pdwNumberOfElements)	\
    (This)->lpVtbl -> GetMsgSeqNumToUIDArray(This,ppdwMsgSeqNumToUIDArray,pdwNumberOfElements)

#define IIMAPTransport2_GetHighestMsgSeqNum(This,pdwHighestMSN)	\
    (This)->lpVtbl -> GetHighestMsgSeqNum(This,pdwHighestMSN)

#define IIMAPTransport2_ResetMsgSeqNumToUID(This)	\
    (This)->lpVtbl -> ResetMsgSeqNumToUID(This)

#define IIMAPTransport2_SetDefaultCBHandler(This,pCBHandler)	\
    (This)->lpVtbl -> SetDefaultCBHandler(This,pCBHandler)

#define IIMAPTransport2_Status(This,wParam,lParam,pCBHandler,pszMailboxName,pszStatusCmdArgs)	\
    (This)->lpVtbl -> Status(This,wParam,lParam,pCBHandler,pszMailboxName,pszStatusCmdArgs)


#define IIMAPTransport2_SetDefaultCP(This,dwTranslateFlags,uiCodePage)	\
    (This)->lpVtbl -> SetDefaultCP(This,dwTranslateFlags,uiCodePage)

#define IIMAPTransport2_MultiByteToModifiedUTF7(This,pszSource,ppszDestination,uiSourceCP,dwFlags)	\
    (This)->lpVtbl -> MultiByteToModifiedUTF7(This,pszSource,ppszDestination,uiSourceCP,dwFlags)

#define IIMAPTransport2_ModifiedUTF7ToMultiByte(This,pszSource,ppszDestination,uiDestinationCP,dwFlags)	\
    (This)->lpVtbl -> ModifiedUTF7ToMultiByte(This,pszSource,ppszDestination,uiDestinationCP,dwFlags)

#define IIMAPTransport2_SetIdleMode(This,dwIdleFlags)	\
    (This)->lpVtbl -> SetIdleMode(This,dwIdleFlags)

#define IIMAPTransport2_EnableFetchEx(This,dwFetchExFlags)	\
    (This)->lpVtbl -> EnableFetchEx(This,dwFetchExFlags)

#define IIMAPTransport2_SetWindow(This)	\
    (This)->lpVtbl -> SetWindow(This)

#define IIMAPTransport2_ResetWindow(This)	\
    (This)->lpVtbl -> ResetWindow(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIMAPTransport2_SetDefaultCP_Proxy( 
    IIMAPTransport2 __RPC_FAR * This,
    /* [in] */ DWORD dwTranslateFlags,
    /* [in] */ UINT uiCodePage);


void __RPC_STUB IIMAPTransport2_SetDefaultCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport2_MultiByteToModifiedUTF7_Proxy( 
    IIMAPTransport2 __RPC_FAR * This,
    /* [in] */ LPCSTR pszSource,
    /* [out] */ LPSTR __RPC_FAR *ppszDestination,
    /* [in] */ UINT uiSourceCP,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IIMAPTransport2_MultiByteToModifiedUTF7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport2_ModifiedUTF7ToMultiByte_Proxy( 
    IIMAPTransport2 __RPC_FAR * This,
    /* [in] */ LPCSTR pszSource,
    /* [out] */ LPSTR __RPC_FAR *ppszDestination,
    /* [in] */ UINT uiDestinationCP,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IIMAPTransport2_ModifiedUTF7ToMultiByte_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport2_SetIdleMode_Proxy( 
    IIMAPTransport2 __RPC_FAR * This,
    /* [in] */ DWORD dwIdleFlags);


void __RPC_STUB IIMAPTransport2_SetIdleMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport2_EnableFetchEx_Proxy( 
    IIMAPTransport2 __RPC_FAR * This,
    /* [in] */ DWORD dwFetchExFlags);


void __RPC_STUB IIMAPTransport2_EnableFetchEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport2_SetWindow_Proxy( 
    IIMAPTransport2 __RPC_FAR * This);


void __RPC_STUB IIMAPTransport2_SetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIMAPTransport2_ResetWindow_Proxy( 
    IIMAPTransport2 __RPC_FAR * This);


void __RPC_STUB IIMAPTransport2_ResetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIMAPTransport2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imnxport_0096 */
/* [local] */ 

// --------------------------------------------------------------------------------
// Exported C Functions
// --------------------------------------------------------------------------------
#if !defined(_IMNXPORT_)
#define IMNXPORTAPI DECLSPEC_IMPORT HRESULT WINAPI
#else
#define IMNXPORTAPI HRESULT WINAPI
#endif
#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------------
//   CreateRASTransport
//   
//   Description:
//   This method creates a IRASTransport object. The client must initialize the
//   object by calling IRASTransport::InitNew
//   
//   Parameters:
//   ppTransport                 Upon successful return, contains the a pointer to
//                               an IRASTransport interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppTransport is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateRASTransport(
                  /* out */      IRASTransport **ppTransport);

// --------------------------------------------------------------------------------
//   CreateNNTPTransport
//   
//   Description:
//   This method creates a INNTPTransport object. The client must initialize the
//   object by calling INNTPTransport::InitNew
//   
//   Parameters:
//   ppTransport                 Upon successful return, contains the a pointer to
//                               an INNTPTransport interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppTransport is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateNNTPTransport(
                  /* out */      INNTPTransport **ppTransport);

// --------------------------------------------------------------------------------
//   CreateSMTPTransport
//   
//   Description:
//   This method creates a ISMTPTransport object. The client must initialize the
//   object by calling ISMTPTransport::InitNew
//   
//   Parameters:
//   ppTransport                 Upon successful return, contains the a pointer to
//                               an ISMTPTransport interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppTransport is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateSMTPTransport(
                  /* out */      ISMTPTransport **ppTransport);

// --------------------------------------------------------------------------------
//   CreatePOP3Transport
//   
//   Description:
//   This method creates a IPOP3Transport object. The client must initialize the
//   object by calling IPOP3Transport::InitNew
//   
//   Parameters:
//   ppTransport                 Upon successful return, contains the a pointer to
//                               an IPOP3Transport interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppTransport is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreatePOP3Transport(
                  /* out */      IPOP3Transport **ppTransport);

// --------------------------------------------------------------------------------
//   CreateIMAPTransport
//   
//   Description:
//   This method creates a IIMAPTransport object. The client must initialize the
//   object by calling IIMAPTransport::InitNew
//   
//   Parameters:
//   ppTransport                 Upon successful return, contains the a pointer to
//                               an IIMAPTransport interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppTransport is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateIMAPTransport(
                  /* out */      IIMAPTransport **ppTransport);

// --------------------------------------------------------------------------------
//   CreateIMAPTransport2
//   
//   Description:
//   This method creates an IIMAPTransport2 object. The client must initialize the
//   object by calling IIMAPTransport2::InitNew
//   
//   Parameters:
//   ppTransport                 Upon successful return, contains the a pointer to
//                               an IIMAPTransport2 interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppTransport is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateIMAPTransport2(
                  /* out */      IIMAPTransport2 **ppTransport);

// --------------------------------------------------------------------------------
//   CreateRangeList
//   
//   Description:
//   This method creates a IRangeList object.
//   
//   Parameters:
//   ppRangeList                 Upon successful return, contains the a pointer to
//                               an IRangeList interface
//   
//   Return Values:
//   S_OK                        Successful.
//   E_INVALIDARG                ppRangeList is NULL
//   E_OUTOFMEMORY               Memory allocation failure...
//   
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateRangeList(
                  /* out */      IRangeList **ppRangeList);

#ifdef __cplusplus
}
#endif



extern RPC_IF_HANDLE __MIDL_itf_imnxport_0096_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imnxport_0096_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\in6addr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation

Module Name:

    in6addr.h

Environment:

    user mode or kernel mode

--*/

#ifndef s6_addr
#pragma once

//
// IPv6 Internet address (RFC 2553)
// This is an 'on-wire' format structure.
//
typedef struct in6_addr {
    union {
        UCHAR       Byte[16];
        USHORT      Word[8];
    } u;
} IN6_ADDR, *PIN6_ADDR, FAR *LPIN6_ADDR;

#define in_addr6 in6_addr

//
// Defines to match RFC 2553.
//
#define _S6_un      u
#define _S6_u8      Byte
#define s6_addr     _S6_un._S6_u8

//
// Defines for our implementation.
//
#define s6_bytes    u.Byte
#define s6_words    u.Word

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\inetreg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

//
//      INETREG.H - String literals for HKEYs in registry
//

#ifndef _INETREGSTRS_H_
#define _INETREGSTRS_H_


//
// HKEY: HKEY_CURRENT_USER
//

//
// Top level defines
//
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH        TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define TSZWININETPATH   TSZWINCURVERPATH TEXT("\\Internet Settings")

// Windows : HKLM
#define REGSTR_PATH_RUNONCE_KEY TSZWINCURVERPATH TEXT("\\RunOnce")

// INETCPL : HKLM
#define REGSTR_PATH_INETCPL_PS_EXTENTIONS TSZWINCURVERPATH TEXT("\\Controls Folder\\Internet")

//
// Explorer : HKCU
//
#define REGSTR_PATH_IEXPLORER           TSZIEPATH

// Main
#define SZ_IE_MAIN                      "Main"
#define REGSTR_PATH_MAIN                TSZIEPATH TEXT( "\\") TEXT(SZ_IE_MAIN)
#define REGSTR_KEY_MAIN                 TEXT(SZ_IE_MAIN)

#define REGSTR_VAL_SMOOTHSCROLL         TEXT("SmoothScroll")
#define REGSTR_VAL_SMOOTHSCROLL_DEF     TRUE

#define REGSTR_VAL_SHOWTOOLBAR          TEXT("Show_ToolBar")
#define REGSTR_VAL_SHOWADDRESSBAR       TEXT("Show_URLToolBar")
#define REGSTR_VAL_STARTPAGE            TEXT("Start Page")
#define REGSTRA_VAL_STARTPAGE           "Start Page"
#define REGSTR_VAL_SEARCHPAGE           TEXT("Search Page")
#define REGSTR_VAL_LOCALPAGE            TEXT("Local Page")

#define REGSTR_VAL_USESTYLESHEETS       TEXT("Use Stylesheets")
#define REGSTR_VAL_USESTYLESHEETS_TYPE  REG_SZ  // "yes" or "no"
#define REGSTR_VAL_USESTYLESHEETS_DEF   TEXT("yes")

#define REGSTR_VAL_USEICM               TEXT("UseICM")
#define REGSTR_VAL_USEICM_DEF           FALSE

#define REGSTR_VAL_SHOWFOCUS            TEXT("Tabstop - MouseDown")
#define REGSTR_VAL_SHOWFOCUS_TYPE       REG_SZ  // "yes" or "no"
#define REGSTR_VAL_SHOWFOCUS_DEF        TEXT("no")

#define REGSTR_VAL_LOADIMAGES           TEXT("Display Inline Images")
#define REGSTR_VAL_PLAYSOUNDS           TEXT("Play_Background_Sounds")
#define REGSTR_VAL_PLAYVIDEOS           TEXT("Display Inline Videos")
#define REGSTR_VAL_ANCHORUNDERLINE      TEXT("Anchor Underline")
#define REGSTR_VAL_USEDLGCOLORS         TEXT("Use_DlgBox_Colors")
#define REGSTR_VAL_CHECKASSOC           TEXT("Check_Associations")
#define REGSTR_VAL_SHOWFULLURLS         TEXT("Show_FullURL")
#define REGSTR_VAL_AUTOSEARCH           TEXT("Do404Search")
#define REGSTR_VAL_AUTONAVIGATE         TEXT("SearchForExtensions")
#define REGSTR_VAL_HTTP_ERRORS          TEXT("Friendly http errors")

#define REGSTR_VAL_PAGETRANSITIONS      TEXT("Page_Transitions")
#define REGSTR_VAL_PAGETRANSITIONS_DEF  TRUE

#define REGSTR_VAL_USEIBAR              TEXT("UseBar")

// Settings
#define SZ_IE_SETTINGS  "Settings"
#define REGSTR_PATH_IE_SETTINGS         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SETTINGS)
#define REGSTR_KEY_IE_SETTINGS          TEXT(SZ_IE_SETTINGS)

#define REGSTR_VAL_IE_CUSTOMCOLORS      TEXT("Custom Colors")
#define REGSTR_VAL_IE_CUSTOMCOLORS_TYPE REG_BINARY

#define REGSTR_VAL_ANCHORCOLOR          TEXT("Anchor Color")
#define REGSTR_VAL_ANCHORCOLORVISITED   TEXT("Anchor Color Visited")
#define REGSTR_VAL_BACKGROUNDCOLOR      TEXT("Background Color")
#define REGSTR_VAL_TEXTCOLOR            TEXT("Text Color")
#define REGSTR_VAL_ANCHORCOLORHOVER     TEXT("Anchor Color Hover")
#define REGSTR_VAL_USEHOVERCOLOR        TEXT("Use Anchor Hover Color")

// Security
#define SZ_IE_SECURITY  "Security"
#define REGSTR_PATH_IE_SECURITY         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SECURITY)
#define REGSTR_KEY_IE_SECURITY          TEXT(SZ_IE_SECURITY)

#define REGSTR_VAL_SAFETYWARNINGLEVEL   TEXT("Safety Warning Level")

// HTML Editing
#define SZ_IE_DEFAULT_HTML_EDITOR       "Default HTML Editor"
#define REGSTR_PATH_DEFAULT_HTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_HTML_EDITOR)
#define REGSTR_KEY_DEFAULT_HTML_EDITOR  TEXT(SZ_IE_DEFAULT_HTML_EDITOR)

// Autocomplete
#define REGSTR_PATH_AUTOCOMPLETE        TSZWINCURVERPATH TEXT("\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

// Old IE4 autocomplete key
#define REGSTR_VAL_USEAUTOCOMPLETE      TEXT("Use AutoComplete")

// iBar
#define SZ_IE_IBAR                      "Bar"
#define TSZIBARPATH                     TSZIEPATH TEXT( "\\") TEXT(SZ_IE_IBAR)
#define REGSTR_PATH_IBAR                TSZIBARPATH
#define REGSTR_KEY_IBAR                 TEXT(SZ_IE_IBAR)

#define SZ_IE_IBAR_BANDS                "Bands"
#define REGSTR_PATH_IBAR_BANDS          TSZIBARPATH TEXT("\\") TEXT(SZ_IE_IBAR_BANDS)
#define REGSTR_KEY_IBAR_BANDS           TEXT(SZ_IE_IBAR_BANDS)


//
// Internet : HKCU
//
// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNETSETTINGS    TSZWININETPATH
#define REGSTR_PATH_INTERNET_SETTINGS   REGSTR_PATH_INTERNETSETTINGS

#define REGSTR_VAL_USERAGENT            TEXT("User Agent")

// path to lan-specific settings
#define REGSTR_PATH_INTERNET_LAN_SETTINGS REGSTR_PATH_INTERNETSETTINGS TEXT("\\LAN")

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETENTRY        TEXT("InternetProfile")
#define REGSTR_VAL_INTERNETPROFILE      REGSTR_VAL_INTERNETENTRY

#define REGSTR_VAL_INTERNETENTRYBKUP    TEXT("BackupInternetProfile")

#define REGSTR_VAL_CODEDOWNLOAD         TEXT("Code Download")
#define REGSTR_VAL_CODEDOWNLOAD_DEF     TEXT("yes")
#define REGSTR_VAL_CODEDOWNLOAD_TYPE    REG_SZ // "yes" or "no"

// policy key for inetcpl restrictions

#define REGSTR_PATH_INETCPL_RESTRICTIONS  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")

// reg valuenames to restrict whether a tab should be shown or not;
// a value of non-zero means don't show that tab.
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_GENERALTAB     TEXT("GeneralTab")
#define REGSTR_VAL_INETCPL_SECURITYTAB    TEXT("SecurityTab")
#define REGSTR_VAL_INETCPL_CONTENTTAB     TEXT("ContentTab")
#define REGSTR_VAL_INETCPL_CONNECTIONSTAB TEXT("ConnectionsTab")
#define REGSTR_VAL_INETCPL_PROGRAMSTAB    TEXT("ProgramsTab")
#define REGSTR_VAL_INETCPL_ADVANCEDTAB    TEXT("AdvancedTab")
#define REGSTR_VAL_INETCPL_PRIVACYTAB     TEXT("PrivacyTab")

// setting to indicate whether or not IEAK launched this instance of inetcpl so extra
// info can be exposed
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_IEAK           TEXT("IEAKContext")

//
//  Cache
//
#define REGSTR_PATH_CACHE  \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Cache")

#define REGSTR_PATH_CACHE_PATHS \
    REGSTR_PATH_CACHE TEXT("\\Paths")

#define REGSTR_PATH_EXTENSIBLE_CACHE \
    REGSTR_PATH_CACHE TEXT("\\Extensible Cache")

#define REGSTR_PATH_TRACKING \
    REGSTR_PATH_EXTENSIBLE_CACHE TEXT("\\Log")

#define REGSTR_PATH_CACHE_SPECIAL_PATHS \
    REGSTR_PATH_CACHE TEXT("Special Paths")

#define REGSTR_VAL_DIRECTORY           TEXT("Directory")
#define REGSTR_VAL_DIRECTORY_TYPE            REG_EXPAND_SZ

#define REGSTR_VAL_NEWDIRECTORY         TEXT("NewDirectory")
#define REGSTR_VAL_NEWDIRECTORY_TYPE    REG_EXPAND_SZ

#define REGSTR_VAL_CACHEPREFIX              TEXT("CachePrefix")
#define REGSTR_VAL_CACHEPREFIX_TYPE     REG_SZ

#define REGSTR_PATH_URLHISTORY \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Url History")

#define REGSTR_PATH_SUBSCRIPTION \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Subscription Folder")

//
// Search Format Strings
//
#define SZ_IE_SEARCHSTRINGS             "UrlTemplate"
#define REGSTR_PATH_SEARCHSTRINGS       REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_SEARCHSTRINGS)
#define REGSTR_KEY_SEARCHSTRINGS        TEXT(SZ_IE_SEARCHSTRINGS)

#define MAX_SEARCH_FORMAT_STRING        255

//
// Server error page dispaly/don't display length thresholds.
//
#define SZ_IE_THRESHOLDS                "ErrorThresholds"
#define REGSTR_PATH_THRESHOLDS          REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_THRESHOLDS)


//
// Access Medium
//
#define REGSTR_VAL_ACCESSMEDIUM         TEXT("AccessMedium")
// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE           TEXT("AccessType")

//
// AutoDial
//
// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME      TEXT("AutodialDllName")
#define REGSTR_VAL_AUTODIALFCNNAME      TEXT("AutodialFcnName")
// class name for window to receive Winsock activity messages
#define REGSTR_VAL_AUTODIAL_MONITORCLASSNAME    TEXT("MS_AutodialMonitor")
#define REGSTR_VAL_AUTODIAL_TRYONLYONCE         TEXT("TryAutodialOnce")

//
// Remote Access
//
// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS        TEXT("RemoteAccess")
#define REGSTR_PATH_REMOTEACESS         REGSTR_PATH_REMOTEACCESS
// this is under HKLM... we are using this to determine if RNA is installed
// or not. We can't rely on finding the DLL since removing this component
// with the control panel's "Add/Remove Software" does not remove the RNAdll.
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")

// values under HKCU\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
// If ForceAutodial is true, will always dial similar to IE4 behavior.
// If it's false, will only dial if network is not available.
#define REGSTR_VAL_ENABLEAUTODIAL               TEXT("EnableAutodial")
#define REGSTR_VAL_ENABLEUNATTENDED             TEXT("EnableUnattended")
#define REGSTR_VAL_NONETAUTODIAL                TEXT("NoNetAutodial")

#define REGSTR_VAL_REDIALATTEMPTS               TEXT("RedialAttempts")
#define REGSTR_VAL_REDIALINTERVAL               TEXT("RedialWait")

#define REGSTR_VAL_ENABLEAUTODIALDISCONNECT     TEXT("EnableAutodisconnect")
#define REGSTR_VAL_ENABLEAUTODISCONNECT         REGSTR_VAL_ENABLEAUTODIALDISCONNECT
#define REGSTR_VAL_ENABLEEXITDISCONNECT         TEXT("EnableExitDisconnect")

#define REGSTR_VAL_ENABLESECURITYCHECK          TEXT("EnableSecurityCheck")

#define REGSTR_VAL_COVEREXCLUDE                 TEXT("CoverExclude")
// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME   TEXT("DisconnectIdleTime")

//
// MOS
//
#define REGSTR_PATH_MOSDISCONNECT       TSZMICROSOFTPATH TEXT("\\MOS\\Preferences")
#define REGSTR_VAL_MOSDISCONNECT        TEXT("DisconnectTimeout")

//
// Proxy : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_PROXYENABLE          TEXT("ProxyEnable")
#define REGSTR_VAL_PROXYSERVER          TEXT("ProxyServer")
#define REGSTR_VAL_PROXYOVERRIDE        TEXT("ProxyOverride")
#define REGSTR_VAL_BYPASSAUTOCONFIG     TEXT("BypassAutoconfig")



//
// Security : HKCU\\WININETPATH
//
#define SZTRUSTWARNLEVEL                    "Trust Warning Level"
#define REGSTR_KEY_TRUSTWARNINGLEVEL        TSZWININETPATH  TEXT(SZTRUSTWARNLEVEL)
#define REGSTR_VAL_TRUSTWARNINGLEVEL        TEXT(SZTRUSTWARNLEVEL) //"none" will turn off WinVerifyTrust warnings.
#define REGSTR_VAL_TRUSTWARNINGLEVEL_TYPE   REG_SZ
#define REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH   TEXT("High")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_MED    TEXT("Medium")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_LOW    TEXT("No Security")
// default depends on MSHTML's prefs nSafetyWarningLevel

#define REGSTR_VAL_SECURITYWARNONSEND       TEXT("WarnOnPost")
#define REGSTR_VAL_SECURITYWARNONSEND_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONSEND_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONSENDALWAYS         TEXT("WarnAlwaysOnPost")
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_TYPE    REG_BINARY // FALSE-Only if... TRUE-Always
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONVIEW       TEXT("WarnOnView")
#define REGSTR_VAL_SECURITYWARNONVIEW_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONVIEW_DEF   TRUE

#define REGSTR_VAL_SECURITYALLOWCOOKIES         TEXT("AllowCookies")
#define REGSTR_VAL_SECURITYALLOWCOOKIES_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYALLOWCOOKIES_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONZONECROSSING       TEXT("WarnOnZoneCrossing")
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING         TEXT("WarnOnBadCertRecving")
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING         TEXT("WarnOnBadCertSending")
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF     TRUE

#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES       TEXT("DisableCachingOfSSLPages")
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_TYPE  REG_DWORD
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF   FALSE


//
// Run/Show ActiveX / Java : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_SECURITYACTIVEX              TEXT("Security_RunActiveXControls")
#define REGSTR_VAL_SECURITYACTIVEX_TYPE         REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTIVEX_DEF          TRUE

#define REGSTR_VAL_SECURITYACTICEXSCRIPTS       TEXT("Security_RunScripts")
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_TYPE  REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF   TRUE

#define REGSTR_VAL_SECURITYJAVA                 TEXT("Security_RunJavaApplets")
#define REGSTR_VAL_SECURITYJAVA_TYPE            REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYJAVA_DEF             TRUE

//
// Java VM exclusively : HKCU
//
#define SZJAVAVMPATH                            "\\Java VM"
#define REGSTR_PATH_JAVAVM                      TSZMICROSOFTPATH TEXT(SZJAVAVMPATH)

#define REGSTR_VAL_JAVAJIT                      TEXT("EnableJIT")
#define REGSTR_VAL_JAVAJIT_TYPE                 REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVAJIT_DEF                  FALSE

#define REGSTR_VAL_JAVALOGGING                   TEXT("EnableLogging")
#define REGSTR_VAL_JAVALOGGING_TYPE              REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVALOGGING_DEF               FALSE


//
// QuickLinks
//
// this is where custom quicklinks are stored
#define SZTOOLBAR               "\\Toolbar"
#define TSZTOOLBAR              TEXT(SZTOOLBAR)
#define REGSTR_PATH_TOOLBAR     TSZIEPATH TEXT(SZTOOLBAR)
#define REGSTR_KEY_QUICKLINKS   TSZIEPATH TSZTOOLBAR TEXT("\\Links")
#define REGSTR_VAL_DAYSTOKEEP   TEXT("DaysToKeep")

#define SZNOTEXT                "NoText"
#define REGSTR_VAL_NOTEXT       TEXT(SZNOTEXT)
#define REGSTR_KEY_NOTEXT       TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZNOTEXT)
#define SZVISIBLE               "VisibleBands"
#define REGSTR_VAL_VISIBLE      TEXT(SZVISIBLE)
#define REGSTR_KEY_VISIBLE      TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZVISIBLE)


#define REGSTR_VAL_VISIBLEBANDS         TEXT("VisibleBands")
#define REGSTR_VAL_VISIBLEBANDS_TYPE    REG_DWORD   // 3 bits (see below)
#define REGSTR_VAL_VISIBLEBANDS_DEF     0x7         // all three bands
#define TOOLSBAND                       0x1
#define ADDRESSBAND                     0x2
#define LINKSBAND                       0x4

#define SZBACKBITMAP          "BackBitmap"
#define REGSTR_VAL_BACKBITMAP       TEXT("BackBitmap")
#define REGSTR_VAL_BACKBITMAP_TYPE  REG_SZ
// "" = no bitmap or fillin with valid path, delete for default

#define REGSTR_KEY_BACKBITMAP   TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZBACKBITMAP)

#define REGSTR_PATH_QUICKCOMPLETE REGSTR_PATH_TOOLBAR TEXT("\\") TEXT("QuickComplete")
#define REGSTR_SHIFTQUICKSUFFIX TEXT("ShiftQuickCompleteSuffix")

//
// Schannel Settings: HKLM
//

#define TSZSCHANNELPATH             TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define TSZSCHANNELPROTOCOLSPATH    TSZSCHANNELPATH TEXT("\\Protocols")

#define REGSTR_PATH_PCT1            TSZSCHANNELPROTOCOLSPATH TEXT("\\PCT 1.0\\Client")
#define REGSTR_PATH_SSL2            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 2.0\\Client")
#define REGSTR_PATH_SSL3            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 3.0\\Client")
#define REGSTR_PATH_UNIHELLO        TSZSCHANNELPROTOCOLSPATH TEXT("\\Multi-Protocol Unified Hello\\Client")

#define REGSTR_VAL_SCHANNELENABLEPROTOCOL         TEXT("Enabled")
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_TYPE    REG_DWORD
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF     TRUE


//
// Mail and News: HKLM
//
#ifdef UNIX

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Microsoft\\Internet Explorer\\Unix")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\MailCommand")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\NewsCommand")
#define REGSTR_PATH_VSOURCECLIENTS  TSZINTERNETCLIENTSPATH  TEXT("\\VSourceCommand")
#define REGSTR_PATH_EDITORS         TSZINTERNETCLIENTSPATH  TEXT("\\Editors")
#define REGSTR_PATH_DEFAULT         TEXT("default")
#define REGSTR_PATH_CURRENT         TEXT("current")

#else

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Clients")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Mail")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\News")
#define REGSTR_PATH_CALENDARCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Calendar")
#define REGSTR_PATH_CONTACTCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Contacts")
#define REGSTR_PATH_CALLCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Internet Call")

#endif // !UNIX

#ifdef UNIX
// Registry item containing the exe name to check for disabling OE
#define IE_USE_OE_PRESENT_HKEY HKEY_LOCAL_MACHINE
#define IE_USE_OE_PRESENT_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe")
#define IE_USE_OE_PRESENT_VALUE NULL

// locations for new OE control variables for unix
#define IE_USE_OE_MAIL_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_MAIL_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Mail")
#define IE_USE_OE_MAIL_VALUE TEXT("Use Outlook Express")

#define IE_USE_OE_NEWS_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_NEWS_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\News")
#define IE_USE_OE_NEWS_VALUE TEXT("Use Outlook Express")
#endif // UNIX

// this is under the mail and news paths
#define TSZPROTOCOLSPATH            TEXT("Protocols\\")
// and one these is under the protocols path
#define TSZMAILTOPROTOCOL           TEXT("mailto")
#define TSZNEWSPROTOCOL             TEXT("news")
#define TSZCALLTOPROTOCOL           TEXT("callto")
#define TSZLDAPPROTOCOL             TEXT("ldap")
#define TSZCALENDARPROTOCOL         TEXT("unk")

#ifdef UNIX
#define TSZVSOURCEPROTOCOL          TEXT("view source")
#endif

//
// International and Fonts: HKCU\\TSZIEPATH
//
#define REGSTR_PATH_INTERNATIONAL   TSZIEPATH   TEXT("\\International")

#define REGSTR_PATH_INTERNATIONAL_SCRIPTS  TSZIEPATH   TEXT("\\International\\Scripts")

#define REGSTR_VAL_DEFAULT_CODEPAGE         TEXT("Default_CodePage")
#define REGSTR_VAL_DEFAULT_CODEPAGE_TYPE    REG_SZ  // code page
                   // will grab default from system if not found

#define REGSTR_VAL_DEFAULT_SCRIPT         TEXT("Default_Script")
#define REGSTR_VAL_DEFAULT_SCRIPT_TYPE    REG_SZ  
                   // will grab default from system if not found


#define REGSTR_VAL_ACCEPT_LANGUAGE          TEXT("AcceptLanguage")
#define REGSTR_VAL_ACCETP_LANGUAGE_TYPE     REG_SZ


// each CHARSET has a unique key under REGSTR_PATH_INTERNATIONAL
// which has the following values defined
#define REGSTR_VAL_FONT_SCRIPTS          TEXT("Scripts")
#define REGSTR_VAL_FONT_SCRIPT           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_TYPE      REG_SZ  // friendly name of font if other than system
                                                 // no default

#define REGSTR_VAL_FONT_SCRIPT_NAME           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_NAME_TYPE      REG_SZ                                                        


#define REGSTR_VAL_DEF_ENCODING         TEXT("Default_Encoding")
#define REGSTR_VAL_DEF_ENCODING_TYPE    REG_SZ  // internal MIME table name
                                                // no default

#define REGSTR_VAL_DEF_INETENCODING         TEXT("Default_InternetEncoding")
#define REGSTR_VAL_DEF_INETENCODING_TYPE    REG_DWORD
                                                // no default

#define REGSTR_VAL_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_SCRIPT_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_SCRIPT_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_FONT_SIZE        TEXT("IEFontSize")
#define REGSTR_VAL_FONT_SIZE_TYPE   REG_BINARY
#define REGSTR_VAL_FONT_SIZE_DEF    2       // default size : Medium

#define REGSTR_VAL_AUTODETECT         TEXT("AutoDetect")
#define REGSTR_VAL_AUTODETECT_TYPE    REG_SZ

// MIME database charset extension
#define REGSTR_PATH_MIME_DATABASE           TEXT("MIME\\Database")
#define REGSTR_KEY_MIME_DATABASE_CHARSET    REGSTR_PATH_MIME_DATABASE TEXT("\\Charset")
#define REGSTR_KEY_MIME_DATABASE_CODEPAGE   REGSTR_PATH_MIME_DATABASE TEXT("\\CodePage")
#define REGSTR_KEY_MIME_DATABASE_RFC1766    REGSTR_PATH_MIME_DATABASE TEXT("\\Rfc1766")

#define REGSTR_VAL_CODEPAGE                 TEXT("CodePage")
#define REGSTR_VAL_CODEPAGE_TYPE            REG_DWORD

#define REGSTR_VAL_INETENCODING             TEXT("InternetEncoding")
#define REGSTR_VAL_INETENCODING_TYPE        REG_DWORD

#define REGSTR_VAL_FAMILY                   TEXT("Family")
#define REGSTR_VAL_FAMILY_TYPE              REG_DWORD

#define REGSTR_VAL_LEVEL                    TEXT("Level")
#define REGSTR_VAL_LEVEL_TYPE               REG_DWORD

#define REGSTR_VAL_ALIASTO                  TEXT("AliasForCharset")
#define REGSTR_VAL_ALIASTO_TYPE             REG_SZ

#define REGSTR_VAL_ENCODENAME               TEXT("EncodingName")
#define REGSTR_VAL_ENCODENAME_TYPE          REG_SZ

#define REGSTR_VAL_DESCRIPTION              TEXT("Description")
#define REGSTR_VAL_DESCRIPTION_TYPE         REG_SZ

#define REGSTR_VAL_WEBCHARSET               TEXT("WebCharset")
#define REGSTR_VAL_WEBCHARSET_TYPE          REG_SZ

#define REGSTR_VAL_BODYCHARSET              TEXT("BodyCharset")
#define REGSTR_VAL_BODYCHARSET_TYPE         REG_SZ

#define REGSTR_VAL_HEADERCHARSET            TEXT("HeaderCharset")
#define REGSTR_VAL_HEADERCHARSET_TYPE       REG_SZ

#define REGSTR_VAL_FIXEDWIDTHFONT           TEXT("FixedWidthFont")
#define REGSTR_VAL_FIXEDWIDTHFONT_TYPE      REG_SZ

#define REGSTR_VAL_PROPORTIONALFONT         TEXT("ProportionalFont")
#define REGSTR_VAL_PROPOPRTIONALFONT_TYPE   REG_SZ

#define REGSTR_VAL_PRIVCONVERTER            TEXT("PrivConverter")
#define REGSTR_VAL_PRIVCONVERTER_TYPE       REG_SZ

#define REGSTR_PATH_DEFAULT_FEEDS REGSTR_PATH_MAIN L"\\Default Feeds"

#endif // _INETREGSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\inaddr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation

Module Name:

    inaddr.h

Environment:

    user mode or kernel mode

--*/

#ifndef s_addr
#pragma once

//
// IPv4 Internet address
// This is an 'on-wire' format structure.
//
typedef struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
#define s_addr  S_un.S_addr /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2    // host on imp
#define s_net   S_un.S_un_b.s_b1    // network
#define s_imp   S_un.S_un_w.s_w2    // imp
#define s_impno S_un.S_un_b.s_b4    // imp #
#define s_lh    S_un.S_un_b.s_b3    // logical host
} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\inetmsg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetmsg.mc

Abstract:

    Contains internationalizable message text for Windows Internet Client DLL
    error codes

Author:

    Richard L Firth (rfirth) 03-Feb-1995

Revision History:

    03-Feb-1995 rfirth
        Created

--*/
//
// INTERNET errors - errors common to all functionality
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: INTERNET_ERROR_BASE
//
// MessageText:
//
//  INTERNET_ERROR_BASE
//
#define INTERNET_ERROR_BASE              12000L

//
// MessageId: ERROR_INTERNET_OUT_OF_HANDLES
//
// MessageText:
//
// No more Internet handles can be allocated
//
#define ERROR_INTERNET_OUT_OF_HANDLES    12001L

//
// MessageId: ERROR_INTERNET_TIMEOUT
//
// MessageText:
//
// The operation timed out
//
#define ERROR_INTERNET_TIMEOUT           12002L

//
// MessageId: ERROR_INTERNET_EXTENDED_ERROR
//
// MessageText:
//
// The server returned extended information
//
#define ERROR_INTERNET_EXTENDED_ERROR    12003L

//
// MessageId: ERROR_INTERNET_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in the Microsoft Internet extensions
//
#define ERROR_INTERNET_INTERNAL_ERROR    12004L

//
// MessageId: ERROR_INTERNET_INVALID_URL
//
// MessageText:
//
// The URL is invalid
//
#define ERROR_INTERNET_INVALID_URL       12005L

//
// MessageId: ERROR_INTERNET_UNRECOGNIZED_SCHEME
//
// MessageText:
//
// The URL does not use a recognized protocol
//
#define ERROR_INTERNET_UNRECOGNIZED_SCHEME 12006L

//
// MessageId: ERROR_INTERNET_NAME_NOT_RESOLVED
//
// MessageText:
//
// The server name or address could not be resolved
//
#define ERROR_INTERNET_NAME_NOT_RESOLVED 12007L

//
// MessageId: ERROR_INTERNET_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// A protocol with the required capabilities was not found
//
#define ERROR_INTERNET_PROTOCOL_NOT_FOUND 12008L

//
// MessageId: ERROR_INTERNET_INVALID_OPTION
//
// MessageText:
//
// The option is invalid
//
#define ERROR_INTERNET_INVALID_OPTION    12009L

//
// MessageId: ERROR_INTERNET_BAD_OPTION_LENGTH
//
// MessageText:
//
// The length is incorrect for the option type
//
#define ERROR_INTERNET_BAD_OPTION_LENGTH 12010L

//
// MessageId: ERROR_INTERNET_OPTION_NOT_SETTABLE
//
// MessageText:
//
// The option value cannot be set
//
#define ERROR_INTERNET_OPTION_NOT_SETTABLE 12011L

//
// MessageId: ERROR_INTERNET_SHUTDOWN
//
// MessageText:
//
// Microsoft Internet Extension support has been shut down
//
#define ERROR_INTERNET_SHUTDOWN          12012L

//
// MessageId: ERROR_INTERNET_INCORRECT_USER_NAME
//
// MessageText:
//
// The user name was not allowed
//
#define ERROR_INTERNET_INCORRECT_USER_NAME 12013L

//
// MessageId: ERROR_INTERNET_INCORRECT_PASSWORD
//
// MessageText:
//
// The password was not allowed
//
#define ERROR_INTERNET_INCORRECT_PASSWORD 12014L

//
// MessageId: ERROR_INTERNET_LOGIN_FAILURE
//
// MessageText:
//
// The login request was denied
//
#define ERROR_INTERNET_LOGIN_FAILURE     12015L

//
// MessageId: ERROR_INTERNET_INVALID_OPERATION
//
// MessageText:
//
// The requested operation is invalid
//
#define ERROR_INTERNET_INVALID_OPERATION 12106L

//
// MessageId: ERROR_INTERNET_OPERATION_CANCELLED
//
// MessageText:
//
// The operation has been canceled
//
#define ERROR_INTERNET_OPERATION_CANCELLED 12017L

//
// MessageId: ERROR_INTERNET_INCORRECT_HANDLE_TYPE
//
// MessageText:
//
// The supplied handle is the wrong type for the requested operation
//
#define ERROR_INTERNET_INCORRECT_HANDLE_TYPE 12018L

//
// MessageId: ERROR_INTERNET_INCORRECT_HANDLE_STATE
//
// MessageText:
//
// The handle is in the wrong state for the requested operation
//
#define ERROR_INTERNET_INCORRECT_HANDLE_STATE 12019L

//
// MessageId: ERROR_INTERNET_NOT_PROXY_REQUEST
//
// MessageText:
//
// The request cannot be made on a Proxy session
//
#define ERROR_INTERNET_NOT_PROXY_REQUEST 12020L

//
// MessageId: ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND
//
// MessageText:
//
// The registry value could not be found
//
#define ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND 12021L

//
// MessageId: ERROR_INTERNET_BAD_REGISTRY_PARAMETER
//
// MessageText:
//
// The registry parameter is incorrect
//
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER 12022L

//
// MessageId: ERROR_INTERNET_NO_DIRECT_ACCESS
//
// MessageText:
//
// Direct Internet access is not available
//
#define ERROR_INTERNET_NO_DIRECT_ACCESS  12023L

//
// MessageId: ERROR_INTERNET_NO_CONTEXT
//
// MessageText:
//
// No context value was supplied
//
#define ERROR_INTERNET_NO_CONTEXT        12024L

//
// MessageId: ERROR_INTERNET_NO_CALLBACK
//
// MessageText:
//
// No status callback was supplied
//
#define ERROR_INTERNET_NO_CALLBACK       12025L

//
// MessageId: ERROR_INTERNET_REQUEST_PENDING
//
// MessageText:
//
// There are outstanding requests
//
#define ERROR_INTERNET_REQUEST_PENDING   12026L

//
// MessageId: ERROR_INTERNET_INCORRECT_FORMAT
//
// MessageText:
//
// The information format is incorrect
//
#define ERROR_INTERNET_INCORRECT_FORMAT  12027L

//
// MessageId: ERROR_INTERNET_ITEM_NOT_FOUND
//
// MessageText:
//
// The requested item could not be found
//
#define ERROR_INTERNET_ITEM_NOT_FOUND    12028L

//
// MessageId: ERROR_INTERNET_CANNOT_CONNECT
//
// MessageText:
//
// A connection with the server could not be established
//
#define ERROR_INTERNET_CANNOT_CONNECT    12029L

//
// MessageId: ERROR_INTERNET_CONNECTION_ABORTED
//
// MessageText:
//
// The connection with the server was terminated abnormally
//
#define ERROR_INTERNET_CONNECTION_ABORTED 12030L

//
// MessageId: ERROR_INTERNET_CONNECTION_RESET
//
// MessageText:
//
// The connection with the server was reset
//
#define ERROR_INTERNET_CONNECTION_RESET  12031L

//
// MessageId: ERROR_INTERNET_FORCE_RETRY
//
// MessageText:
//
// The action must be retried
//
#define ERROR_INTERNET_FORCE_RETRY       12032L

//
// MessageId: ERROR_INTERNET_INVALID_PROXY_REQUEST
//
// MessageText:
//
// The proxy request is invalid
//
#define ERROR_INTERNET_INVALID_PROXY_REQUEST 12033L

//
// MessageId: ERROR_INTERNET_NEED_UI
//
// MessageText:
//
// User interaction is required to complete the operation
//
#define ERROR_INTERNET_NEED_UI           12034L

//
// MessageId: ERROR_INTERNET_HANDLE_EXISTS
//
// MessageText:
//
// The handle already exists
//
#define ERROR_INTERNET_HANDLE_EXISTS     12036L

//
// MessageId: ERROR_INTERNET_SEC_CERT_DATE_INVALID
//
// MessageText:
//
// The date in the certificate is invalid or has expired
//
#define ERROR_INTERNET_SEC_CERT_DATE_INVALID 12037L

//
// MessageId: ERROR_INTERNET_SEC_CERT_CN_INVALID
//
// MessageText:
//
// The host name in the certificate is invalid or does not match
//
#define ERROR_INTERNET_SEC_CERT_CN_INVALID 12038L

//
// MessageId: ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR
//
// MessageText:
//
// A redirect request will change a non-secure to a secure connection
//
#define ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR 12039L

//
// MessageId: ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR
//
// MessageText:
//
// A redirect request will change a secure to a non-secure connection
//
#define ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR 12040L

//
// MessageId: ERROR_INTERNET_MIXED_SECURITY
//
// MessageText:
//
// Mixed secure and non-secure connections
//
#define ERROR_INTERNET_MIXED_SECURITY    12041L

//
// MessageId: ERROR_INTERNET_CHG_POST_IS_NON_SECURE
//
// MessageText:
//
// Changing to non-secure post
//
#define ERROR_INTERNET_CHG_POST_IS_NON_SECURE 12042L

//
// MessageId: ERROR_INTERNET_POST_IS_NON_SECURE
//
// MessageText:
//
// Data is being posted on a non-secure connection
//
#define ERROR_INTERNET_POST_IS_NON_SECURE 12043L

//
// MessageId: ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED
//
// MessageText:
//
// A certificate is required to complete client authentication
//
#define ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED 12044L

//
// MessageId: ERROR_INTERNET_INVALID_CA
//
// MessageText:
//
// The certificate authority is invalid or incorrect
//
#define ERROR_INTERNET_INVALID_CA        12045L

//
// MessageId: ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP
//
// MessageText:
//
// Client authentication has not been correctly installed
//
#define ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP 12046L

//
// MessageId: ERROR_INTERNET_ASYNC_THREAD_FAILED
//
// MessageText:
//
// An error has occurred in a Wininet asynchronous thread. You may need to restart
//
#define ERROR_INTERNET_ASYNC_THREAD_FAILED 12047L

//
// MessageId: ERROR_INTERNET_REDIRECT_SCHEME_CHANGE
//
// MessageText:
//
// The protocol scheme has changed during a redirect operaiton
//
#define ERROR_INTERNET_REDIRECT_SCHEME_CHANGE 12048L

//
// MessageId: ERROR_INTERNET_DIALOG_PENDING
//
// MessageText:
//
// There are operations awaiting retry
//
#define ERROR_INTERNET_DIALOG_PENDING    12049L

//
// MessageId: ERROR_INTERNET_RETRY_DIALOG
//
// MessageText:
//
// The operation must be retried
//
#define ERROR_INTERNET_RETRY_DIALOG      12050L

//
// MessageId: ERROR_INTERNET_NO_NEW_CONTAINERS
//
// MessageText:
//
// There are no new cache containers
//
#define ERROR_INTERNET_NO_NEW_CONTAINERS 12051L

//
// MessageId: ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR
//
// MessageText:
//
// A security zone check indicates the operation must be retried
//
#define ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR 12052L

//
// MessageId: ERROR_INTERNET_SECURITY_CHANNEL_ERROR
//
// MessageText:
//
// An error occurred in the secure channel support
//
#define ERROR_INTERNET_SECURITY_CHANNEL_ERROR 12157L

//
// MessageId: ERROR_INTERNET_UNABLE_TO_CACHE_FILE
//
// MessageText:
//
// The file could not be written to the cache
//
#define ERROR_INTERNET_UNABLE_TO_CACHE_FILE 12158L

//
// MessageId: ERROR_INTERNET_TCPIP_NOT_INSTALLED
//
// MessageText:
//
// The TCP/IP protocol is not installed properly
//
#define ERROR_INTERNET_TCPIP_NOT_INSTALLED 12159L

//
// MessageId: ERROR_INTERNET_DISCONNECTED
//
// MessageText:
//
// The computer is disconnected from the network
//
#define ERROR_INTERNET_DISCONNECTED      12163L

//
// MessageId: ERROR_INTERNET_SERVER_UNREACHABLE
//
// MessageText:
//
// The server is unreachable
//
#define ERROR_INTERNET_SERVER_UNREACHABLE 12164L

//
// MessageId: ERROR_INTERNET_PROXY_SERVER_UNREACHABLE
//
// MessageText:
//
// The proxy server is unreachable
//
#define ERROR_INTERNET_PROXY_SERVER_UNREACHABLE 12165L

//
// MessageId: ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT
//
// MessageText:
//
// The proxy auto-configuration script is in error
//
#define ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT 12166L

//
// MessageId: ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT
//
// MessageText:
//
// Could not download the proxy auto-configuration script file
//
#define ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT 12167L

//
// MessageId: ERROR_INTERNET_SEC_INVALID_CERT
//
// MessageText:
//
// The supplied certificate is invalid
//
#define ERROR_INTERNET_SEC_INVALID_CERT  12169L

//
// MessageId: ERROR_INTERNET_SEC_CERT_REVOKED
//
// MessageText:
//
// The supplied certificate has been revoked
//
#define ERROR_INTERNET_SEC_CERT_REVOKED  12170L

//
// MessageId: ERROR_INTERNET_FAILED_DUETOSECURITYCHECK
//
// MessageText:
//
// The Dialup failed because file sharing was turned on and a failure was requested if security check was needed
//
#define ERROR_INTERNET_FAILED_DUETOSECURITYCHECK 12171L

//
// MessageId: ERROR_INTERNET_DECODING_FAILED
//
// MessageText:
//
// Content decoding has failed
//
#define ERROR_INTERNET_DECODING_FAILED   12175L

//
// FTP errors
//
//
// MessageId: ERROR_FTP_TRANSFER_IN_PROGRESS
//
// MessageText:
//
// There is already an FTP request in progress on this session
//
#define ERROR_FTP_TRANSFER_IN_PROGRESS   12110L

//
// MessageId: ERROR_FTP_DROPPED
//
// MessageText:
//
// The FTP session was terminated
//
#define ERROR_FTP_DROPPED                12111L

//
// MessageId: ERROR_FTP_NO_PASSIVE_MODE
//
// MessageText:
//
// FTP Passive mode is not available
//
#define ERROR_FTP_NO_PASSIVE_MODE        12112L

//
// GOPHER errors
//
//
// MessageId: ERROR_GOPHER_PROTOCOL_ERROR
//
// MessageText:
//
// A gopher protocol error occurred
//
#define ERROR_GOPHER_PROTOCOL_ERROR      12130L

//
// MessageId: ERROR_GOPHER_NOT_FILE
//
// MessageText:
//
// The locator must be for a file
//
#define ERROR_GOPHER_NOT_FILE            12131L

//
// MessageId: ERROR_GOPHER_DATA_ERROR
//
// MessageText:
//
// An error was detected while parsing the data
//
#define ERROR_GOPHER_DATA_ERROR          12132L

//
// MessageId: ERROR_GOPHER_END_OF_DATA
//
// MessageText:
//
// There is no more data
//
#define ERROR_GOPHER_END_OF_DATA         12133L

//
// MessageId: ERROR_GOPHER_INVALID_LOCATOR
//
// MessageText:
//
// The locator is invalid
//
#define ERROR_GOPHER_INVALID_LOCATOR     12134L

//
// MessageId: ERROR_GOPHER_INCORRECT_LOCATOR_TYPE
//
// MessageText:
//
// The locator type is incorrect for this operation
//
#define ERROR_GOPHER_INCORRECT_LOCATOR_TYPE 12135L

//
// MessageId: ERROR_GOPHER_NOT_GOPHER_PLUS
//
// MessageText:
//
// The request must be for a gopher+ item
//
#define ERROR_GOPHER_NOT_GOPHER_PLUS     12136L

//
// MessageId: ERROR_GOPHER_ATTRIBUTE_NOT_FOUND
//
// MessageText:
//
// The requested attribute was not found
//
#define ERROR_GOPHER_ATTRIBUTE_NOT_FOUND 12137L

//
// MessageId: ERROR_GOPHER_UNKNOWN_LOCATOR
//
// MessageText:
//
// The locator type is not recognized
//
#define ERROR_GOPHER_UNKNOWN_LOCATOR     12138L

//
// HTTP errors
//
//
// MessageId: ERROR_HTTP_HEADER_NOT_FOUND
//
// MessageText:
//
// The requested header was not found
//
#define ERROR_HTTP_HEADER_NOT_FOUND      12150L

//
// MessageId: ERROR_HTTP_DOWNLEVEL_SERVER
//
// MessageText:
//
// The server does not support the requested protocol level
//
#define ERROR_HTTP_DOWNLEVEL_SERVER      12151L

//
// MessageId: ERROR_HTTP_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The server returned an invalid or unrecognized response
//
#define ERROR_HTTP_INVALID_SERVER_RESPONSE 12152L

//
// MessageId: ERROR_HTTP_INVALID_HEADER
//
// MessageText:
//
// The supplied HTTP header is invalid
//
#define ERROR_HTTP_INVALID_HEADER        12153L

//
// MessageId: ERROR_HTTP_INVALID_QUERY_REQUEST
//
// MessageText:
//
// The request for a HTTP header is invalid
//
#define ERROR_HTTP_INVALID_QUERY_REQUEST 12154L

//
// MessageId: ERROR_HTTP_HEADER_ALREADY_EXISTS
//
// MessageText:
//
// The HTTP header already exists
//
#define ERROR_HTTP_HEADER_ALREADY_EXISTS 12155L

//
// MessageId: ERROR_HTTP_REDIRECT_FAILED
//
// MessageText:
//
// The HTTP redirect request failed
//
#define ERROR_HTTP_REDIRECT_FAILED       12156L

//
// MessageId: ERROR_HTTP_NOT_REDIRECTED
//
// MessageText:
//
// The HTTP request was not redirected
//
#define ERROR_HTTP_NOT_REDIRECTED        12160L

//
// MessageId: ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION
//
// MessageText:
//
// A cookie from the server must be confirmed by the user
//
#define ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION 12161L

//
// MessageId: ERROR_HTTP_COOKIE_DECLINED
//
// MessageText:
//
// A cookie from the server has been declined acceptance
//
#define ERROR_HTTP_COOKIE_DECLINED       12162L

//
// MessageId: ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION
//
// MessageText:
//
// The HTTP redirect request must be confirmed by the user
//
#define ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION 12168L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\initguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************\
*                                                                             *
* initguid.h -  Definitions for controlling GUID initialization               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID  DECLSPEC_SELECTANY  name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\inethelp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

//
// HELP.H - IDHs for the Internet Control Panel
//

//
// GLOBALS... ie... used to give the same info on every page
//

#include <iehelpid.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\inkctrls.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Copyright (c) Microsoft Corporation.  All rights reserved. 
//
// Use of this source code is subject to the terms of your Windows Mobile 
// Software Shared Source Premium Derivatives License Form or other 
// applicable Microsoft license agreement for the software. If you did not 
// accept the terms of such a license, you are not authorized to use this 
// source code.

//////////////////////////////////////////////////////////////////////
//  Module: InkCtrls.h
//
//  Description:
//
//      This file contains the public interfaces to the InkCtrls.dll
//////////////////////////////////////////////////////////////////////


#pragma once

#ifndef _INKCTRLS_H_
#define _INKCTRLS_H_

#include <windows.h>


// 
// Register the WLINKCANVAS window class. This MUST be called
// before creating a canvas window 
//
BOOL InitInkControls();


//
// InkCanvas Window Class constant
//

#define WC_INKCANVAS    L"WLINKCANVAS"


// Enum for pen types
enum IC_PENTYPE
{
    IC_PENTYPE_NORMAL, 
    IC_PENTYPE_HIGHLIGHTER
};

typedef enum IC_PENTYPE IC_PENTYPE;


// Enum for canvas types
enum IC_CANVASTYPE
{
    IC_CANVASTYPE_FIXEDCANVAS, 
    IC_CANVASTYPE_VARIABLECANVAS
};

typedef enum IC_CANVASTYPE IC_CANVASTYPE;


// Enum for editing mode
enum IC_EDITINGMODE
{
    // Enable inking, gestures disabled
    IC_EDITINGMODE_INK = 1,

    // Enable selection, gestures disabled
    IC_EDITINGMODE_SELECT = 2,

    // Delete ink, gestures disabled
    IC_EDITINGMODE_DELETE = 3,

    // View only. Handle flick gesture by scrolling
    IC_EDITINGMODE_VIEW = 4
};

typedef enum IC_EDITINGMODE IC_EDITINGMODE;


// Enum for ink encoding types
enum IC_INKENCODING
{
    IC_INKENCODING_BINARY, 
    IC_INKENCODING_BASE64,
    IC_INKENCODING_GIF,
    IC_INKENCODING_BASE64GIF
};

typedef enum IC_INKENCODING IC_INKENCODING;


// The penstyle strucutre
typedef struct PENSTYLE
{
    size_t         cbSize;              // The size of the structure
    float          dPenWidth;           // Widht of the pen in mm
    COLORREF       crColor;             // The color of the pen
    IC_PENTYPE     ptPenType;           // The type of the pen
}PENSTYLE;


// The structure for notifying the WM_CHAR message
// NM_CHAR is not defined on Windows CE
typedef struct NMCHR
{
    NMHDR hdr;              // contains additional info. about this notification
    UINT   ch;              // Character that is being processed. The wParam of the WM_CHAR message
    DWORD info;             // lParam of the WM_CHAR message
} NMCHR, *LPNMCHR;


// The structure for notifying the ICNM_STROKEADDED
// and ICNM_STROKEDELETED message
typedef struct NMSTROKE
{
    NMHDR hdr;              // contains additional info. about this notification
    long  lStrokeID;        // Stroke ID of the added/deleted strokes. If multiple strokes 
                            // are added/deleted, this is 0.
} NMSTROKE, *LPNMSTROKE;




//////////////////////////////////////////////////////////
// InkCanvas and InkControl Window Style definitinos

// ICS_FIXEDCANVAS
// This flag creates a fixed canvas
#define ICS_FIXEDCANVAS             0x00010000



#define ICM_BASE                (WM_USER + 500)


/////////////////////////////////////////////////////////////////////////////
// User defined messages that InkCanvas will handle
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
// ICM_GETMODE
//
// Returns the current editing mode
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
// Return value
// 
//      editingmode: One of the values of IC_EDITINGMODE
//
// --------------------------------------------------------------------------
#define ICM_GETMODE             ICM_BASE + 1 


// --------------------------------------------------------------------------
// ICM_SETMODE
//
// Sets the editing mode
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) (IC_EDITINGMODE) editingmode
//
//
// Parameters
//
//  editingmode
// 
//  The mode to which we wish to switch. One of IC_EDITINGMODE values.
//
// Return value
//
//  Returns 0 if there are errors
// --------------------------------------------------------------------------
#define ICM_SETMODE             ICM_BASE + 2 


// --------------------------------------------------------------------------
// ICM_GETINK
//
// Returns a reference to the ink object in the canvas
//
// lParam = (LPARAM) (IInkDisp**) ppInk
// wparam = (WPARAM) 0
//
//
// Parameters
//
//  ppInk
//
//  Pointer to a pointer to an ink object. Should not be NULL.
//
// Return value
//
//  Returns 0 if there are errors
// --------------------------------------------------------------------------
#define ICM_GETINK              ICM_BASE + 3  


// --------------------------------------------------------------------------
// ICM_GETINKDATA
//
// Returns the Ink data in the requested format
//
// lParam = (LPARAM) (VARIANT*) pvData
// wParam = (WPARAM) (IC_INKENCODING) encoding
//
//
// Parameters
//
//  pvData
//  
//  Pointer to a variant. The caller has to call VariantClear (to free the 
//  memory allocated for the data). 
//
//  encoding
//
//  The encoding in which the data is required. One of the IC_INKENCODING values.
//
// Return value
// 
//  Returns 0 if there are errors.
// 
// Remarks
//  Upon successfully saving the data *pvData will have the save ink data
//  Variant type is either 
//     VT_UI1|VT_ARRAY   - for binary formats: isf and gif
//     VT_BSTR           - for base64 formats: base64isf and base64gif
//  Caller has to call VariantClear() to free the memory allocated
// --------------------------------------------------------------------------
#define ICM_GETINKDATA          ICM_BASE + 4


// --------------------------------------------------------------------------
// ICM_GETINKDATAASBITMAP
//
// Returns a bitmap of the ink on the canvas.
//
// lParam = (LPARAM) (HBITMAP*) pHBitmap
// wParam = (WPARAM) 0
//
//
// Parameters
// 
//  pHBitmap
// 
//  Pointer to an HBITMAP. The bitmap is created by us and its the caller's 
//  responsibility to free it.
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_GETINKDATAASBITMAP  ICM_BASE + 5


// --------------------------------------------------------------------------
// ICM_LOADINKDATA
//
// Loads the ink data supplied into the canvas. This discards the existing 
// ink data.
//
// lParam = (LPARAM) (VARIANT*) pvData
// wParam = (WPARAM) 0
//
//
// Parameters
// 
//  pvData
// 
//  Pointer to a variant. The data supplied in the variant is loaded into the ink
//  on the canvas, replacing whatever is already there.
//
// Return value
// 
//  Returns 0 if there are errors.
//
// Remarks
//  Variant type is either 
//     VT_UI1|VT_ARRAY   - for binary formats: isf and gif
//     VT_BSTR           - for base64 formats: base64isf and base64gif
// --------------------------------------------------------------------------
#define ICM_LOADINKDATA         ICM_BASE + 6


// --------------------------------------------------------------------------
// ICM_CLEARCANVAS
//
// Clears the canvas. This action cannot be undone.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_CLEARCANVAS         ICM_BASE + 7


// --------------------------------------------------------------------------
// ICM_SETPENSTYLE
//
// Sets the supplied penstyle as the new penstyle for the canvas.
//
// lParam = (LPARAM) (PENSTYLE*) pPenstyle
// wParam = (WPARAM) 0
//
// Parameters
//
//  pPenstyle 
//
//  Pointer to a penstyle structure which has the new penstyle info. The size field
//  (cbSize) must be filled in by the caller.
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETPENSTYLE         ICM_BASE + 8


// --------------------------------------------------------------------------
// ICM_GETPENSTYLE
//
// Returns the current penstyle being used.
//
// lParam = (LPARAM) (PENSTYLE*) pPenstyle
// wParam = (WPARAM) 0
//
// Parameters
//
//  pPenstyle 
//
//  Pointer to a penstyle structure. This is where we fill in the current penstyle
//  info. The structure should be allocated by the caller and the size field (cbSize) 
//  must be filled in by the caller.
//  
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_GETPENSTYLE         ICM_BASE + 9


// --------------------------------------------------------------------------
// ICM_SETKBKGNDCOLOR
//
// Sets the background color of the canvas
//
// lParam = (LPARAM) (COLOREF) color
// wParam = (WPARAM) 0
//
// Parameters
//
//  color
//
//  The color which we want to set the background to. To create a COLORREF value, 
//  use the RGB macro.
//  
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETBKGNDCOLOR       ICM_BASE + 10


// --------------------------------------------------------------------------
// ICM_CANCOPY
//
// Returns if it's possible to copy data to the clipboard.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  nSelected: The number of strokes that can be copied. 0 if no data can be copied.
// --------------------------------------------------------------------------
#define ICM_CANCOPY             ICM_BASE + 11


// --------------------------------------------------------------------------
// ICM_CANPASTE
//
// Returns if it's possible to paste data from the clipboard to the canvas
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 0 if data cannot be pasted
// --------------------------------------------------------------------------
#define ICM_CANPASTE            ICM_BASE + 12


// --------------------------------------------------------------------------
// ICM_CANUNDO
//
// Returns if an undo operation can be performed
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 1 if undo can be performed
// --------------------------------------------------------------------------
#define ICM_CANUNDO             ICM_BASE + 13


// --------------------------------------------------------------------------
// ICM_CANREDO
//
// Returns if a redo operation can be performed
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 1 if a redo can be performed
// --------------------------------------------------------------------------
#define ICM_CANREDO             ICM_BASE + 14


// --------------------------------------------------------------------------
// ICM_GETZOOM
//
// Returns the current zoom level
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  nZoomLevel: The current zoom level in percentage
// --------------------------------------------------------------------------
#define ICM_GETZOOM             ICM_BASE + 15


// --------------------------------------------------------------------------
// ICM_SETZOOM
//
// Sets the current zoom level
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) (LONG) nZoomLevel
//
// Parameters
//
//  nZoomlevel
//
//  Zoom level as a percentage. The range is from 20% to 500%
//
// 
// Return value
// 
//  Returns 0 if there are errors
// --------------------------------------------------------------------------
#define ICM_SETZOOM             ICM_BASE + 16


// --------------------------------------------------------------------------
// ICM_GETCANVASSIZE
//
// Returns the size of the canvas in pixels.
//
// lParam = (LPARAM) (SIZE*) pCanvasSize
// wParam = (WPARAM) 0
//
// Parameters
//
//  pCanvasSize
//
//  Pointer to a user allocated SIZE structure. The dimensions returned are in 
//  pixels and they are the dimensions of the actual canvas.
//  
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_GETCANVASSIZE       ICM_BASE + 18


// --------------------------------------------------------------------------
// ICM_SETCANVASSIZE
//
// Set the size of the current canvas
//
// lParam = (LPARAM) (SIZE*) pCanvasSize
// wParam = (WPARAM) 0
//
// Parameters
//
//  pCanvasSize
//
//  Pointer to a SIZE structure. The dimensions are in pixles. The ink object is 
//  clipped to fit inside the canvas size supplied.
//  
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETCANVASSIZE       ICM_BASE + 19


// --------------------------------------------------------------------------
// ICM_REDO
//
// Redo the last undone action.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 0 if redo was unsuccessful
// --------------------------------------------------------------------------
#define ICM_REDO                ICM_BASE + 20


// --------------------------------------------------------------------------
// ICM_UNDO
//
// Undo the most recent undoable action
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 0 if undo was unsuccessful
// --------------------------------------------------------------------------
#define ICM_UNDO                ICM_BASE + 40


// --------------------------------------------------------------------------
// ICM_SETCANVASCOLOR
//
// Sets the color of the canvas.
//
// lParam = (LPARAM) (COLORREF) color
// wParam = (WPARAM) 0
//
// Parameters
//
//  color
//
//  The color which we want to set the canvas to. To create a COLORREF value, 
//  use the RGB macro. Note that this call is different from ICM_SETBKGNDCOLOR.
//  That color is used to paint the region on the window which lies outside the
//  canvas.
//  
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETCANVASCOLOR      ICM_BASE + 21


// --------------------------------------------------------------------------
// ICM_ERASEALLINK
//
// Erase all the ink on the canvas. This action can be undone.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_ERASEALLINK         ICM_BASE + 22


// --------------------------------------------------------------------------
// ICM_SETAUTOSCROLL
//
// Use this to enable/disable autoscrolling when the user inks near the end of
// the canvas window. By default autoscroll is off. This is only applicable for
// scrolling vertically.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) (VARIANT_BOOL) vbAutoScroll
//
// Parameters
//
//  vbAutoScroll
//
//  VARIANT_BOOL indicating whether scrolling should be on(VARIANT_TRUE) or 
//  off(VARIANT_FALSE).
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETAUTOSCROLL       ICM_BASE + 23


// --------------------------------------------------------------------------
// ICM_SETAUTOEXPAND
//
// Turns canvas expansion on or off. When enabled, the canvas is expanded when the 
// user inks near the edge of the canvas. Canvas expansion happens in both directions. 
// 
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) (VARIANT_BOOL) vbAutoScroll
//
// Parameters
//
//  vbAutoScroll
//
//  VARIANT_BOOL indicating whether expansion should be on(VARIANT_TRUE) or 
//  off(VARIANT_FALSE).
//
// Note
//  This can be enabled only for variable canvas types. This message is different 
//  from autoscroll. This merely expands the canvas but doesn't neccessarily scroll it. 
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETAUTOEXPAND       ICM_BASE + 24


// --------------------------------------------------------------------------
// ICM_GETUNDOCOUNT
//
// Returns the number of undo operations that can be performed.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
//
// Return value
// 
//  nUndoCount: The number of undo operations that can be performed.
// --------------------------------------------------------------------------
#define ICM_GETUNDOCOUNT        ICM_BASE + 25 


// --------------------------------------------------------------------------
// ICM_GETNOTIFICATIONMASK
//
// Returns the mask of the notifications the user has subscribed to.
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) 0
//
// Note
//  By default the ICMASK_DEFAULT is used. 
//  
// Return value
// 
//  lMask: The current notification mask.
// --------------------------------------------------------------------------
#define ICM_GETNOTIFICATIONMASK ICM_BASE + 26


// --------------------------------------------------------------------------
// ICM_SETNOTIFICATIONMASK
//
// Sets the mask of the notifications one would like to receive.
// 
//
// lParam = (LPARAM) 0
// wParam = (WPARAM) (LONG) lMask
//
// Parameters
//
//  lMask
//
//  This could be a bitwise OR of the various notifications. ICNM_xxx defines
//  the notifications that canvas provides.
//
// Return value
// 
//  Returns 0 if there are errors.
// --------------------------------------------------------------------------
#define ICM_SETNOTIFICATIONMASK ICM_BASE + 27


/////////////////////////////////////////////////////////////////////////////
// Notification codes that canvas passes on to the parent window by sending the
// WM_NOTIFY message. 
/////////////////////////////////////////////////////////////////////////////


// Base for the notification codes
#define ICNM_BASE               ICM_BASE + 100


// --------------------------------------------------------------------------
// ICNM_CHAR 
//
// A WM_NOTIFY message is sent to the parent with this notification code when
// we don't handle the WM_CHAR message. 
//
// lParam = (LPARAM) (LPNMHDR) pNmChar
// wParam = (WPARAM) (int) idCtrl
//
// Parameters
//
//  pNmChar 
//
//  Pointer to an NMCHR structure containing information about the character.
//
//  idCtrl
// 
//  The control ID of this window
//
// --------------------------------------------------------------------------
#define ICNM_CHAR               ICNM_BASE + 1


// --------------------------------------------------------------------------
// ICNM_STROKEADDED
//
// A WM_NOTIFY message is sent to the parent with this notification code when
// a new stroke is added.
//
// lParam = (LPARAM) (NMSTROKE*) pNmStroke
// wParam = (WPARAM) (int) idCtrl
//
// Parameters
//
//  pNmStroke
//
//  Pointer to an NMSTROKE structure containing information about the stroke added.
//
//  idCtrl
// 
//  The control ID of this window
//
// --------------------------------------------------------------------------
#define ICNM_STROKEADDED        ICNM_BASE + 2


// --------------------------------------------------------------------------
// ICNM_STROKEDELETED
//
// A WM_NOTIFY message is sent to the parent with this notification code when
// stroke(s) are deleted.
//
// lParam = (LPARAM) (NMSTROKE*) pNmStroke
// wParam = (WPARAM) (int) idCtrl
//
// Parameters
//
//  pNmStroke
//
//  Pointer to an NMSTROKE structure containing information about the deleted stroke(s).
//
//  idCtrl
// 
//  The control ID of this window
//
// --------------------------------------------------------------------------
#define ICNM_STROKEDELETED      ICNM_BASE + 4


// Notification masks that apps can set for receiving notifications

// Mask set to receive the ICNM_CHAR notification
#define ICMASK_CHAR             0x00000001

// Mask set to receive the ICNM_STROKEADDED notification
#define ICMASK_STROKEADDED      0x00000002

// Mask set to receive the ICNM_STROKEDELETED notification
#define ICMASK_STROKEDELETED    0x00000004

// The default mask. Only forwards the ICNM_CHAR notification
#define ICMASK_DEFAULT          0x00000001

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\InputScope.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _INPUTSCOPES_H_
#define _INPUTSCOPES_H_

#if (_MSC_VER >= 1000)
#pragma once
#endif

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

enum InputScope
{
    // Extended InputScope values
    IS_PHRASELIST           = -1,
    IS_REGULAREXPRESSION    = -2,   // Reserved.  Not currently supported.
    IS_SRGS                 = -3,
    IS_XML                  = -4,   // Reserved.  Not currently supported.
    IS_ENUMSTRING           = -5,   // Reserved.  Not currently supported.

    // Standard InputScope values
    IS_DEFAULT                          = 0x0000,
    IS_URL                              = 0x0001,
    IS_FILE_FULLFILEPATH                = 0x0002,
    IS_FILE_FILENAME                    = 0x0003,
    IS_EMAIL_USERNAME                   = 0x0004,
    IS_EMAIL_SMTPEMAILADDRESS           = 0x0005,
    IS_LOGINNAME                        = 0x0006,
    IS_PERSONALNAME_FULLNAME            = 0x0007,
    IS_PERSONALNAME_PREFIX              = 0x0008,
    IS_PERSONALNAME_GIVENNAME           = 0x0009,
    IS_PERSONALNAME_MIDDLENAME          = 0x000A,
    IS_PERSONALNAME_SURNAME             = 0x000B,
    IS_PERSONALNAME_SUFFIX              = 0x000C,
    IS_ADDRESS_FULLPOSTALADDRESS        = 0x000D,
    IS_ADDRESS_POSTALCODE               = 0x000E,
    IS_ADDRESS_STREET                   = 0x000F,
    IS_ADDRESS_STATEORPROVINCE          = 0x0010,
    IS_ADDRESS_CITY                     = 0x0011,
    IS_ADDRESS_COUNTRYNAME              = 0x0012,
    IS_ADDRESS_COUNTRYSHORTNAME         = 0x0013,
    IS_CURRENCY_AMOUNTANDSYMBOL         = 0x0014,
    IS_CURRENCY_AMOUNT                  = 0x0015,
    IS_DATE_FULLDATE                    = 0x0016,
    IS_DATE_MONTH                       = 0x0017,
    IS_DATE_DAY                         = 0x0018,
    IS_DATE_YEAR                        = 0x0019,
    IS_DATE_MONTHNAME                   = 0x001A,
    IS_DATE_DAYNAME                     = 0x001B,
    IS_DIGITS                           = 0x001C,
    IS_NUMBER                           = 0x001D,
    IS_ONECHAR                          = 0x001E,
    IS_PASSWORD                         = 0x001F,
    IS_TELEPHONE_FULLTELEPHONENUMBER    = 0x0020,
    IS_TELEPHONE_COUNTRYCODE            = 0x0021,
    IS_TELEPHONE_AREACODE               = 0x0022,
    IS_TELEPHONE_LOCALNUMBER            = 0x0023,
    IS_TIME_FULLTIME                    = 0x0024,
    IS_TIME_HOUR                        = 0x0025,
    IS_TIME_MINORSEC                    = 0x0026,
    IS_NUMBER_FULLWIDTH                 = 0x0027,
    IS_ALPHANUMERIC_HALFWIDTH           = 0x0028,
    IS_ALPHANUMERIC_FULLWIDTH           = 0x0029,
    IS_CURRENCY_CHINESE                 = 0x002A,
    IS_BOPOMOFO                         = 0x002B,
    IS_HIRAGANA                         = 0x002C,
    IS_KATAKANA_HALFWIDTH               = 0x002D,
    IS_KATAKANA_FULLWIDTH               = 0x002E,
    IS_HANJA                            = 0x002F,
    IS_YOMI                             = 0x0030,
    IS_APPLICATION_END                  = 0x0030
};
typedef enum InputScope InputScope;

HRESULT
SetInputScope(
    HWND hwnd,
    InputScope inputScope
);

HRESULT
SetInputScopes(
    HWND hwnd,
    __in_ecount_opt(cInputScopes) const InputScope *pInputScopes,
    UINT cInputScopes,
    __in_ecount_opt(cPhrases) WCHAR **pszPhraseList,
    UINT cPhrases,
    __in_opt WCHAR *pszRegExp,
    __in_opt WCHAR *pszSrgs
);

HRESULT
GetInputScopes(
    HWND hwnd,
    __deref_out InputScope **ppInputScopes,
    __out UINT *pcInputScopes
);

HRESULT
GetInputScopePhrases(
    HWND hwnd,
    __deref_out LPWSTR **ppszPhraseList,
    __out UINT *pcCount
);

HRESULT
GetInputScopeSrgs(
    HWND hwnd,
    __out LPWSTR *pszSrgs
);

#ifdef __cplusplus
}
#endif

#endif // _INPUTSCOPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\inseng.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//=--------------------------------------------------------------------------=
// inseng.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
//
// interface declaration for the InstallEngine control.
//
#ifndef _INSENG_H_

#ifdef __cplusplus
extern "C"{
#endif

#define MAX_ID_LENGTH            48
#define MAX_DISPLAYNAME_LENGTH  128


#define ICI_NOTINSTALLED          0
#define ICI_INSTALLED             1
#define ICI_NEWVERSIONAVAILABLE   2
#define ICI_UNKNOWN               3
#define ICI_OLDVERSIONAVAILABLE   4
#define ICI_NOTINITIALIZED        0xffffffff

#define ABORTINSTALL_NORMAL       0
#define ABORTINSTALL_IMMEADIATE   1


#define ENGINESTATUS_NOTREADY     0
#define ENGINESTATUS_LOADING      1
#define ENGINESTATUS_INSTALLING   2
#define ENGINESTATUS_READY        3

#define CDINSTALL                     1
#define WEBINSTALL                    2
#define WEBINSTALL_DIFFERENTMACHINE   3
#define NETWORKINSTALL                4
#define LOCALINSTALL                  5

#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'


#define SETACTION_NONE            0x00000000
#define SETACTION_INSTALL         0x00000001

#define INSTALLOPTIONS_NOCACHE             0x00000001
#define INSTALLOPTIONS_DOWNLOAD            0x00000002
#define INSTALLOPTIONS_INSTALL             0x00000004
#define INSTALLOPTIONS_DONTALLOWXPLATFORM  0x00000008
#define INSTALLOPTIONS_FORCEDEPENDENCIES    0x00000010

#define EXECUTEJOB_SILENT              0x00000001
#define EXECUTEJOB_DELETE_JOB          0x00000002

#define EXECUTEJOB_VERIFYFILES         0x00000008
#define EXECUTEJOB_IGNORETRUST         0x00000010
#define EXECUTEJOB_IGNOREDOWNLOADERROR 0x00000020
#define EXECUTEJOB_DONTALLOWCANCEL     0x00000040


#define E_FILESMISSING             _HRESULT_TYPEDEF_(0x80100003L)



HRESULT WINAPI CheckTrust(LPCSTR pszFilename, HWND hwndForUI, BOOL bShowBadUI);
HRESULT WINAPI CheckTrustEx(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved);
HRESULT WINAPI PurgeDownloadDir(LPCSTR pszDir);
HRESULT WINAPI CheckForVersionConflict();


typedef struct
{
   DWORD cbSize;
   DWORD dwInstallSize;
   DWORD dwWinDriveSize;
   DWORD dwDownloadSize;
   DWORD dwDependancySize;
   DWORD dwInstallDriveReq;
   DWORD dwWinDriveReq;
   DWORD dwDownloadDriveReq;
   CHAR  chWinDrive;
   CHAR  chInstallDrive;
   CHAR  chDownloadDrive;
   DWORD dwTotalDownloadSize;
} COMPONENT_SIZES;

typedef struct
{
   DWORD cbSize;
   DWORD dwDownloadKBRemaining;
   DWORD dwInstallKBRemaining;
   DWORD dwDownloadSecsRemaining;
   DWORD dwInstallSecsRemaining;
} INSTALLPROGRESS;


enum InstallStatus
{
   INSTALLSTATUS_INITIALIZING,
   INSTALLSTATUS_DEPENDENCY,
   INSTALLSTATUS_DOWNLOADING,
   INSTALLSTATUS_COPYING,
   INSTALLSTATUS_RETRYING,
   INSTALLSTATUS_CHECKINGTRUST,
   INSTALLSTATUS_EXTRACTING,
   INSTALLSTATUS_RUNNING,
   INSTALLSTATUS_FINISHED,
   INSTALLSTATUS_DOWNLOADFINISHED
};

// defines for engine problems  (OnEngineProblem)
#define ENGINEPROBLEM_DOWNLOADFAIL   0x00000001


// Actions particular to ENGINEPROBLEM_DOWNLOAD
#define DOWNLOADFAIL_RETRY   0x00000001


#define STOPINSTALL_REBOOTNEEDED   0x00000001
#define STOPINSTALL_REBOOTREFUSED  0x00000002


DEFINE_GUID(IID_IInstallEngineCallback,0x6E449685L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngineCallback

DECLARE_INTERFACE_(IInstallEngineCallback, IUnknown)
{
   // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;


   STDMETHOD(OnEngineStatusChange)(THIS_ DWORD dwEngineStatus, DWORD substatus) PURE;
   STDMETHOD(OnStartInstall)(THIS_ DWORD dwDLSize, DWORD dwInstallSize) PURE;
   STDMETHOD(OnStartComponent)(THIS_ LPCSTR pszID, DWORD dwDLSize, DWORD dwInstallSize, LPCSTR pszString) PURE;
   STDMETHOD(OnComponentProgress)(THIS_ LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax) PURE;
   STDMETHOD(OnStopComponent)(THIS_ LPCSTR pszID, HRESULT hError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus) PURE;
   STDMETHOD(OnStopInstall)(THIS_ HRESULT hrError, LPCSTR szError, DWORD dwStatus) PURE;
   STDMETHOD(OnEngineProblem)(THIS_ DWORD dwEngineProblem, LPDWORD dwAction) PURE;
};



DEFINE_GUID(IID_IInstallEngine,0x6E449684L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngine

DECLARE_INTERFACE_(IInstallEngine , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   // Methods to set engine up for install
   STDMETHOD(GetEngineStatus)(THIS_ DWORD *theenginestatus) PURE;
   STDMETHOD(SetCifFile)(THIS_ LPCSTR pszCabName, LPCSTR pszCifName) PURE;
   STDMETHOD(DownloadComponents)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(InstallComponents)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(EnumInstallIDs)(THIS_ UINT uIndex, LPSTR *ppszID) PURE;
   STDMETHOD(EnumDownloadIDs)(THIS_ UINT uIndex, LPSTR *ppszID) PURE;
   STDMETHOD(IsComponentInstalled)(THIS_ LPCSTR pszID, DWORD *pdwStatus) PURE;
   STDMETHOD(RegisterInstallEngineCallback)(THIS_ IInstallEngineCallback *pcb) PURE;
   STDMETHOD(UnregisterInstallEngineCallback)(THIS) PURE;
   STDMETHOD(SetAction)(THIS_ LPCSTR pszID, DWORD dwAction, DWORD dwPriority) PURE;
   STDMETHOD(GetSizes)(THIS_ LPCSTR pszID, COMPONENT_SIZES *pSizes) PURE;
   STDMETHOD(LaunchExtraCommand)(THIS_ LPCSTR pszInfName, LPCSTR pszSection) PURE;
   STDMETHOD(GetDisplayName)(THIS_ LPCSTR pszID, LPSTR *ppszName) PURE;

   // Info about the install (should be structure to fill in
   //   like GetBindInfo (GetInstallInfo)
   STDMETHOD(SetBaseUrl)(THIS_ LPCSTR pszBaseName) PURE;
   STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir) PURE;
   STDMETHOD(SetInstallDrive)(THIS_ CHAR chDrive) PURE;
   STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag) PURE;
   STDMETHOD(SetHWND)(THIS_ HWND hForUI) PURE;
   STDMETHOD(SetIStream)(THIS_ IStream *pstm) PURE;


   // Engine control during installation (seperate interface?)
   STDMETHOD(Abort)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(Suspend)(THIS) PURE;
   STDMETHOD(Resume)(THIS) PURE;

};

DEFINE_GUID(IID_IInstallEngineTiming,0x6E449687L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngineTiming

DECLARE_INTERFACE_(IInstallEngineTiming , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(GetRates)(THIS_ DWORD *pdwDownload, DWORD *pdwInstall) PURE;
   STDMETHOD(GetInstallProgress)(THIS_ INSTALLPROGRESS *pinsprog) PURE;
};


DEFINE_GUID(CLSID_InstallEngine,0x6E449686L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);


//  The site manager interface

typedef struct
{
   UINT cbSize;
   LPSTR pszLang;
   LPSTR pszRegion;
} SITEQUERYPARAMS;

typedef struct
{
   UINT cbSize;
   LPSTR pszUrl;
   LPSTR pszFriendlyName;
   LPSTR pszLang;
   LPSTR pszRegion;
} DOWNLOADSITE;


// {BFC880F3-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSite,
0xbfc880f3, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IDownloadSite

DECLARE_INTERFACE_(IDownloadSite , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(GetData)(THIS_ DOWNLOADSITE **pds) PURE;
};

// {BFC880F0-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSiteMgr,
0xbfc880f0, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IDownloadSiteMgr

DECLARE_INTERFACE_(IDownloadSiteMgr , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(Initialize)(THIS_ LPCSTR pszUrl, SITEQUERYPARAMS *pqp) PURE;
   STDMETHOD(EnumSites)(THIS_ DWORD dwIndex, IDownloadSite **pds) PURE;
};

// {BFC880F1-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(CLSID_DownloadSiteMgr,
0xbfc880f1, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);


// defines for dwUrlFlags
#define URLF_DEFAULT                0x00000000
#define URLF_EXTRACT                0x00000001
#define URLF_RELATIVEURL            0x00000002
#define URLF_DELETE_AFTER_EXTRACT   0x00000004

// types of dependancies
#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'

// platform defines
#define PLATFORM_WIN95              0x00000001
#define PLATFORM_WIN98              0x00000002
#define PLATFORM_NT4                0x00000004
#define PLATFORM_NT5                0x00000008
#define PLATFORM_NT4ALPHA           0x00000010
#define PLATFORM_NT5ALPHA           0x00000020
#define PLATFORM_MILLEN		    0x00000040
#define PLATFORM_ALL     (PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN)
               

// The action to be taken on this component ((Get)SetInstallQueueStatus, SetAction
enum ComponentAction { ActionNone, ActionInstall, ActionUninstall };

// Type for commands
                     //   0            1           2           3             4
enum CommandType     { InfCommand, WExtractExe, Win32Exe, InfExCommand, HRESULTWin32Exe };



#undef INTERFACE
#define INTERFACE ICifComponent

DECLARE_INTERFACE(ICifComponent)
{
   // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize)PURE;
   STDMETHOD(GetGUID)(THIS_ LPSTR pszGUID, DWORD dwSize)PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize)PURE;
   STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize) PURE;
   STDMETHOD(GetUrl)(THIS_ UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)  PURE;
   STDMETHOD(GetFileExtractList)(THIS_ UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)  PURE;
   STDMETHOD(GetUrlCheckRange)(THIS_ UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)  PURE;
   STDMETHOD(GetCommand)(THIS_ UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                         DWORD dwSwitchSize, LPDWORD pdwType)  PURE;
   STDMETHOD(GetVersion)(THIS_ LPDWORD pdwVersion, LPDWORD pdwBuild)  PURE;
   STDMETHOD(GetLocale)(THIS_ LPSTR pszLocale, DWORD dwSize)  PURE;
   STDMETHOD(GetUninstallKey)(THIS_ LPSTR pszKey, DWORD dwSize)  PURE;
   STDMETHOD(GetInstalledSize)(THIS_ LPDWORD pdwWin, LPDWORD pdwApp)  PURE;
   STDMETHOD_(DWORD, GetDownloadSize)(THIS)  PURE;
   STDMETHOD_(DWORD, GetExtractSize)(THIS)  PURE;
   STDMETHOD(GetSuccessKey)(THIS_ LPSTR pszKey, DWORD dwSize)  PURE;
   STDMETHOD(GetProgressKeys)(THIS_ LPSTR pszProgress, DWORD dwProgSize, 
                              LPSTR pszCancel, DWORD dwCancelSize)  PURE;
   STDMETHOD(IsActiveSetupAware)(THIS)  PURE;
   STDMETHOD(IsRebootRequired)(THIS)  PURE;
   STDMETHOD(RequiresAdminRights)(THIS) PURE;
   STDMETHOD_(DWORD, GetPriority)(THIS)  PURE;
   STDMETHOD(GetDependency)(THIS_ UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)  PURE;
   STDMETHOD_(DWORD, GetPlatform)(THIS)  PURE;
   STDMETHOD(GetMode)(THIS_ UINT uModeNum, LPSTR pszMode, DWORD dwSize)  PURE;
   STDMETHOD(GetGroup)(THIS_ LPSTR pszID, DWORD dwSize)  PURE;
   STDMETHOD(IsUIVisible)(THIS)  PURE;
   STDMETHOD(GetPatchID)(THIS_ LPSTR pszID, DWORD dwSize)  PURE;
   STDMETHOD(GetDetVersion)(THIS_ LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize) PURE;
   STDMETHOD(GetTreatAsOneComponents)(THIS_ UINT uNum, LPSTR pszID, DWORD dwBuf) PURE;
   STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize) PURE;

   // access to state
   STDMETHOD_(DWORD, IsComponentInstalled)(THIS)  PURE;
   STDMETHOD(IsComponentDownloaded)(THIS)  PURE;
   STDMETHOD_(DWORD, IsThisVersionInstalled)(THIS_ DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild) PURE;
   STDMETHOD_(DWORD, GetInstallQueueState)(THIS)  PURE;
   STDMETHOD(SetInstallQueueState)(THIS_ DWORD dwState)  PURE;
   STDMETHOD_(DWORD, GetActualDownloadSize)(THIS)  PURE;
   STDMETHOD_(DWORD, GetCurrentPriority)(THIS) PURE;
   STDMETHOD(SetCurrentPriority)(THIS_ DWORD dwPriority) PURE;
};

DECLARE_INTERFACE_(ICifRWComponent, ICifComponent)
{
   STDMETHOD(SetGUID)(THIS_ LPCSTR pszGUID)PURE;
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc)PURE;
   STDMETHOD(SetUrl)(THIS_ UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags)  PURE;
   STDMETHOD(SetCommand)(THIS_ UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType)  PURE;
   STDMETHOD(SetVersion)(THIS_ LPCSTR pszVersion)  PURE;
   STDMETHOD(SetUninstallKey)(THIS_ LPCSTR pszKey)  PURE;
   STDMETHOD(SetInstalledSize)(THIS_ DWORD dwWin, DWORD dwApp)  PURE;
   STDMETHOD(SetDownloadSize)(THIS_ DWORD)  PURE;
   STDMETHOD(SetExtractSize)(THIS_ DWORD)  PURE;
   STDMETHOD(DeleteDependency)(THIS_ LPCSTR pszID, char chType)  PURE;
   STDMETHOD(AddDependency)(THIS_ LPCSTR pszID, char chType)  PURE;
   STDMETHOD(SetUIVisible)(THIS_ BOOL)  PURE;
   STDMETHOD(SetGroup)(THIS_ LPCSTR pszID)  PURE;
   STDMETHOD(SetPlatform)(THIS_ DWORD)  PURE;
   STDMETHOD(SetPriority)(THIS_ DWORD)  PURE;
   STDMETHOD(SetReboot)(THIS_ BOOL)  PURE;
   
   STDMETHOD(DeleteFromModes)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(AddToMode)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(SetModes)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(CopyComponent)(THIS_ LPCSTR pszCifFile)  PURE;
   STDMETHOD(AddToTreatAsOne)(THIS_ LPCSTR pszCompID)  PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDesc) PURE;
};

DECLARE_INTERFACE_(IEnumCifComponents, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifComponent **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DECLARE_INTERFACE(ICifGroup)
{
  // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize) PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
  
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD_(DWORD, GetCurrentPriority)(THIS) PURE;

};

DECLARE_INTERFACE_(ICifRWGroup, ICifGroup)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;
   STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails) PURE;
};

DECLARE_INTERFACE_(IEnumCifGroups, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifGroup **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DECLARE_INTERFACE(ICifMode)
{
  // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize) PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize) PURE;
  
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
};

DECLARE_INTERFACE_(ICifRWMode, ICifMode)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails) PURE;
};

DECLARE_INTERFACE_(IEnumCifModes, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifMode **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DEFINE_GUID(IID_ICifFile,0x6E449688L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

DECLARE_INTERFACE_(ICifFile, IUnknown)
{
 // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
 
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindComponent)(THIS_ LPCSTR pszID, ICifComponent **p) PURE;

   STDMETHOD(EnumGroups)(THIS_ IEnumCifGroups **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindGroup)(THIS_ LPCSTR pszID, ICifGroup **p) PURE;

   STDMETHOD(EnumModes)(THIS_ IEnumCifModes **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindMode)(THIS_ LPCSTR pszID, ICifMode **p) PURE;

   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD(GetDetDlls)(THIS_ LPSTR pszDlls, DWORD dwSize) PURE;

};

DECLARE_INTERFACE_(ICifRWFile, ICifFile)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;    
   STDMETHOD(CreateComponent)(THIS_ LPCSTR pszID, ICifRWComponent **p) PURE;
   STDMETHOD(CreateGroup)(THIS_ LPCSTR pszID, ICifRWGroup **p) PURE;
   STDMETHOD(CreateMode)(THIS_ LPCSTR pszID, ICifRWMode **p) PURE;
   STDMETHOD(DeleteComponent)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(DeleteGroup)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(DeleteMode)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(Flush)(THIS) PURE;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Detection DLL 

// Returns from DetectVersion
#define DET_NOTINSTALLED          0
#define DET_INSTALLED             1
#define DET_NEWVERSIONINSTALLED   2
#define DET_OLDVERSIONINSTALLED   3


   
// Function prototype
typedef struct
{
   DWORD          dwSize;
   LPDWORD        pdwInstalledVer;
   LPDWORD        pdwInstalledBuild;
   LPSTR          pszGUID;
   LPSTR          pszLocale;
   DWORD          dwAskVer;
   DWORD          dwAskBuild;
   ICifFile      *pCifFile; 
   ICifComponent *pCifComp; 
} DETECTION_STRUCT;


typedef DWORD (WINAPI *DETECTVERSION)(DETECTION_STRUCT *pDetectionStruct);

///////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_GUID(IID_IInstallEngine2,0x6E449689L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngine2

DECLARE_INTERFACE_(IInstallEngine2 , IInstallEngine)
{
   STDMETHOD(SetLocalCif)(THIS_ LPCSTR pszCif) PURE;
   STDMETHOD(GetICifFile)(THIS_ ICifFile **picif) PURE;
};

HRESULT WINAPI GetICifFileFromFile(ICifFile **, LPCSTR pszFile);

HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **, LPCSTR pszFile);

#ifdef __cplusplus
}
#endif

#define _INSENG_H_
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ipexport.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** IPEXPORT.H - IP public definitions.
//
//  This file contains public definitions exported to transport layer and
//  application software.
//

#ifndef IP_EXPORT_INCLUDED
#define IP_EXPORT_INCLUDED  1

#if _MSC_VER > 1000
#pragma once
#endif

//
// IP type definitions.
//
typedef ULONG IPAddr;       // An IP address.
typedef ULONG IPMask;       // An IP subnet mask.
typedef ULONG IP_STATUS;    // Status code returned from IP APIs.

#include <in6addr.h>

typedef struct in6_addr IPv6Addr;

#include <inaddr.h>

/*INC*/

//
// The ip_option_information structure describes the options to be
// included in the header of an IP packet. The TTL, TOS, and Flags
// values are carried in specific fields in the header. The OptionsData
// bytes are carried in the options area following the standard IP header.
// With the exception of source route options, this data must be in the
// format to be transmitted on the wire as specified in RFC 791. A source
// route option should contain the full route - first hop thru final
// destination - in the route data. The first hop will be pulled out of the
// data and the option will be reformatted accordingly. Otherwise, the route
// option should be formatted as specified in RFC 791.
//

typedef struct ip_option_information {
    UCHAR   Ttl;                // Time To Live
    UCHAR   Tos;                // Type Of Service
    UCHAR   Flags;              // IP header flags
    UCHAR   OptionsSize;        // Size in bytes of options data
    PUCHAR  OptionsData;        // Pointer to options data
} IP_OPTION_INFORMATION, *PIP_OPTION_INFORMATION;

#if defined(_WIN64)

typedef struct ip_option_information32 {
    UCHAR   Ttl;
    UCHAR   Tos;
    UCHAR   Flags;
    UCHAR   OptionsSize;
    UCHAR * POINTER_32 OptionsData;
} IP_OPTION_INFORMATION32, *PIP_OPTION_INFORMATION32;

#endif // _WIN64

//
// The icmp_echo_reply structure describes the data returned in response
// to an echo request.
//

typedef struct icmp_echo_reply {
    IPAddr  Address;            // Replying address
    ULONG   Status;             // Reply IP_STATUS
    ULONG   RoundTripTime;      // RTT in milliseconds
    USHORT  DataSize;           // Reply data size in bytes
    USHORT  Reserved;           // Reserved for system use
    PVOID   Data;               // Pointer to the reply data
    struct ip_option_information Options; // Reply options
} ICMP_ECHO_REPLY, *PICMP_ECHO_REPLY;

#if defined(_WIN64)

typedef struct icmp_echo_reply32 {
    IPAddr  Address;
    ULONG   Status;
    ULONG   RoundTripTime;
    USHORT  DataSize;
    USHORT  Reserved;
    VOID * POINTER_32 Data;
    struct ip_option_information32 Options;
} ICMP_ECHO_REPLY32, *PICMP_ECHO_REPLY32;

#endif // _WIN64

#include <packon.h>
typedef struct _IPV6_ADDRESS_EX_LH {
    USHORT sin6_port;
    ULONG  sin6_flowinfo;
    USHORT sin6_addr[8];
    ULONG  sin6_scope_id;
} IPV6_ADDRESS_EX_LH, *PIPV6_ADDRESS_EX_LH;
#include <packoff.h>

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef  IPV6_ADDRESS_EX_LH IPV6_ADDRESS_EX;
typedef  IPV6_ADDRESS_EX_LH *PIPV6_ADDRESS_EX ;
#endif

typedef struct icmpv6_echo_reply_lh {
    IPV6_ADDRESS_EX_LH Address;    // Replying address.
    ULONG Status;               // Reply IP_STATUS.
    unsigned int RoundTripTime; // RTT in milliseconds.
    // Reply data follows this structure in memory.
} ICMPV6_ECHO_REPLY_LH, *PICMPV6_ECHO_REPLY_LH;

#if 0
// [stjong] rem this out for now
// as net\afd has issue.
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef ICMPV6_ECHO_REPLY_LH ICMPV6_ECHO_REPLY;
typedef ICMPV6_ECHO_REPLY_LH *PICMPV6_ECHO_REPLY;
#endif
#endif


typedef struct arp_send_reply {
    IPAddr  DestAddress;
    IPAddr  SrcAddress;
} ARP_SEND_REPLY, *PARP_SEND_REPLY;

typedef struct tcp_reserve_port_range {
    USHORT  UpperRange;
    USHORT  LowerRange;
} TCP_RESERVE_PORT_RANGE, *PTCP_RESERVE_PORT_RANGE;

#define MAX_ADAPTER_NAME 128

typedef struct _IP_ADAPTER_INDEX_MAP {
    ULONG   Index;
    WCHAR   Name[MAX_ADAPTER_NAME];
} IP_ADAPTER_INDEX_MAP, *PIP_ADAPTER_INDEX_MAP;

typedef struct _IP_INTERFACE_INFO {
    LONG    NumAdapters;
    IP_ADAPTER_INDEX_MAP Adapter[1];
} IP_INTERFACE_INFO,*PIP_INTERFACE_INFO;

typedef struct _IP_UNIDIRECTIONAL_ADAPTER_ADDRESS {
    ULONG   NumAdapters;
    IPAddr  Address[1];
} IP_UNIDIRECTIONAL_ADAPTER_ADDRESS, *PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS;

typedef struct _IP_ADAPTER_ORDER_MAP {
    ULONG   NumAdapters;
    ULONG   AdapterOrder[1];
} IP_ADAPTER_ORDER_MAP, *PIP_ADAPTER_ORDER_MAP;

typedef struct _IP_MCAST_COUNTER_INFO {
    ULONG64 InMcastOctets;
    ULONG64 OutMcastOctets;
    ULONG64 InMcastPkts;
    ULONG64 OutMcastPkts;
} IP_MCAST_COUNTER_INFO, *PIP_MCAST_COUNTER_INFO;

//
// IP_STATUS codes returned from IP APIs
//

#define IP_STATUS_BASE              11000

#define IP_SUCCESS                  0
#define IP_BUF_TOO_SMALL            (IP_STATUS_BASE + 1)
#define IP_DEST_NET_UNREACHABLE     (IP_STATUS_BASE + 2)
#define IP_DEST_HOST_UNREACHABLE    (IP_STATUS_BASE + 3)
#define IP_DEST_PROT_UNREACHABLE    (IP_STATUS_BASE + 4)
#define IP_DEST_PORT_UNREACHABLE    (IP_STATUS_BASE + 5)
#define IP_NO_RESOURCES             (IP_STATUS_BASE + 6)
#define IP_BAD_OPTION               (IP_STATUS_BASE + 7)
#define IP_HW_ERROR                 (IP_STATUS_BASE + 8)
#define IP_PACKET_TOO_BIG           (IP_STATUS_BASE + 9)
#define IP_REQ_TIMED_OUT            (IP_STATUS_BASE + 10)
#define IP_BAD_REQ                  (IP_STATUS_BASE + 11)
#define IP_BAD_ROUTE                (IP_STATUS_BASE + 12)
#define IP_TTL_EXPIRED_TRANSIT      (IP_STATUS_BASE + 13)
#define IP_TTL_EXPIRED_REASSEM      (IP_STATUS_BASE + 14)
#define IP_PARAM_PROBLEM            (IP_STATUS_BASE + 15)
#define IP_SOURCE_QUENCH            (IP_STATUS_BASE + 16)
#define IP_OPTION_TOO_BIG           (IP_STATUS_BASE + 17)
#define IP_BAD_DESTINATION          (IP_STATUS_BASE + 18)

//
// Variants of the above using IPv6 terminology, where different
//

#define IP_DEST_NO_ROUTE            (IP_STATUS_BASE + 2)
#define IP_DEST_ADDR_UNREACHABLE    (IP_STATUS_BASE + 3)
#define IP_DEST_PROHIBITED          (IP_STATUS_BASE + 4)
#define IP_DEST_PORT_UNREACHABLE    (IP_STATUS_BASE + 5)
#define IP_HOP_LIMIT_EXCEEDED       (IP_STATUS_BASE + 13)
#define IP_REASSEMBLY_TIME_EXCEEDED (IP_STATUS_BASE + 14)
#define IP_PARAMETER_PROBLEM        (IP_STATUS_BASE + 15)

//
// IPv6-only status codes
//

#define IP_DEST_UNREACHABLE         (IP_STATUS_BASE + 40)
#define IP_TIME_EXCEEDED            (IP_STATUS_BASE + 41)
#define IP_BAD_HEADER               (IP_STATUS_BASE + 42)
#define IP_UNRECOGNIZED_NEXT_HEADER (IP_STATUS_BASE + 43)
#define IP_ICMP_ERROR               (IP_STATUS_BASE + 44)
#define IP_DEST_SCOPE_MISMATCH      (IP_STATUS_BASE + 45)

//
// The next group are status codes passed up on status indications to
// transport layer protocols.
//
#define IP_ADDR_DELETED             (IP_STATUS_BASE + 19)
#define IP_SPEC_MTU_CHANGE          (IP_STATUS_BASE + 20)
#define IP_MTU_CHANGE               (IP_STATUS_BASE + 21)
#define IP_UNLOAD                   (IP_STATUS_BASE + 22)
#define IP_ADDR_ADDED               (IP_STATUS_BASE + 23)
#define IP_MEDIA_CONNECT            (IP_STATUS_BASE + 24)
#define IP_MEDIA_DISCONNECT         (IP_STATUS_BASE + 25)
#define IP_BIND_ADAPTER             (IP_STATUS_BASE + 26)
#define IP_UNBIND_ADAPTER           (IP_STATUS_BASE + 27)
#define IP_DEVICE_DOES_NOT_EXIST    (IP_STATUS_BASE + 28)
#define IP_DUPLICATE_ADDRESS        (IP_STATUS_BASE + 29)
#define IP_INTERFACE_METRIC_CHANGE  (IP_STATUS_BASE + 30)
#define IP_RECONFIG_SECFLTR         (IP_STATUS_BASE + 31)
#define IP_NEGOTIATING_IPSEC        (IP_STATUS_BASE + 32)
#define IP_INTERFACE_WOL_CAPABILITY_CHANGE  (IP_STATUS_BASE + 33)
#define IP_DUPLICATE_IPADD          (IP_STATUS_BASE + 34)

#define IP_GENERAL_FAILURE          (IP_STATUS_BASE + 50)
#define MAX_IP_STATUS               IP_GENERAL_FAILURE
#define IP_PENDING                  (IP_STATUS_BASE + 255)


//
// Values used in the Flags field of IP_OPTION_INFORMATION.
//
#define IP_FLAG_REVERSE 0x1         // Do a round-trip echo request.
#define IP_FLAG_DF      0x2         // Don't fragment this packet.

//
// Supported IP Option Types.
//
// These types define the options which may be used in the OptionsData field
// of the ip_option_information structure.  See RFC 791 for a complete
// description of each.
//
#define IP_OPT_EOL      0          // End of list option
#define IP_OPT_NOP      1          // No operation
#define IP_OPT_SECURITY 0x82       // Security option
#define IP_OPT_LSRR     0x83       // Loose source route
#define IP_OPT_SSRR     0x89       // Strict source route
#define IP_OPT_RR       0x7        // Record route
#define IP_OPT_TS       0x44       // Timestamp
#define IP_OPT_SID      0x88       // Stream ID (obsolete)
#define IP_OPT_ROUTER_ALERT 0x94  // Router Alert Option

#define MAX_OPT_SIZE    40         // Maximum length of IP options in bytes

#ifdef CHICAGO

// Ioctls code exposed by Memphis tcpip stack.
// For NT these ioctls are define in ntddip.h  (private\inc)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST   101
#define IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST  102
#define IOCTL_ARP_SEND_REQUEST             103
#define IOCTL_IP_INTERFACE_INFO            104
#define IOCTL_IP_GET_BEST_INTERFACE        105
#define IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS        106

#endif


#endif // IP_EXPORT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\io.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#include <ntcompat.h>   // For PWORKER_THREAD_ROUTINE, PDEVICE_OBJECT

// IO_WORKITEM is opaque
typedef struct _IO_WORKITEM IO_WORKITEM, *PIO_WORKITEM;

//
//  IO Functions
//

typedef
VOID
IO_WORKITEM_ROUTINE (
    __in PDEVICE_OBJECT DeviceObject,
    __in_opt PVOID Context
    );
    
typedef IO_WORKITEM_ROUTINE *PIO_WORKITEM_ROUTINE;

typedef
VOID
IO_WORKITEM_ROUTINE_EX (
    __in PVOID IoObject,
    __in_opt PVOID Context,
    __in PIO_WORKITEM IoWorkItem
    );

typedef IO_WORKITEM_ROUTINE_EX *PIO_WORKITEM_ROUTINE_EX;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
);

ULONG
IoSizeofWorkItem();

VOID  
IoInitializeWorkItem(    
    IN  PVOID         IoObject,    
    OUT PIO_WORKITEM  IoWorkItem);

VOID
IoUninitializeWorkItem(
    __in IN PIO_WORKITEM IoWorkItem
    );
    
PIO_WORKITEM
IoAllocateWorkItem(PDEVICE_OBJECT DeviceObject);

VOID
IoFreeWorkItem(PIO_WORKITEM pIoWorkItem);

VOID
IoQueueWorkItem(
	IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context);
    
VOID
IoQueueWorkItemEx(    
    IN PIO_WORKITEM             IoWorkItem,    
    IN PIO_WORKITEM_ROUTINE_EX  WorkerRoutineEx,    
    IN WORK_QUEUE_TYPE          QueueType,    
    IN PVOID                    Context    );

#ifndef DISPATCH_LEVEL
#define DISPATCH_LEVEL 2
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\invokesearch.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    InvokeSearch.h

Abstract:

    Search defines.

--*/

#pragma once

#include "vrtldata.h"
#include "searchapi.h"

#ifdef __cplusplus
extern "C" {
#endif

// Search APIs
//

/// This message is posted to the Search-aware application window
/// with focus to start the invocation of the search application.
/// WPARAM and LPARAM are not used. Applications should respond to
/// this message by calling either SearchInvokeList
#define WM_STARTSEARCH      (WM_APP+600)

/// <summary>
/// Argument for RegisterSearchKeys indicating whether child
/// window inherit the registration or not
/// </summary>
enum INVOKESEARCH_REGISTER 
{ 
    INVOKESEARCH_REGISTER_NOINHERIT = 0, 
    INVOKESEARCH_REGISTER_INHERIT 
};

/// <summary>
/// Register the set of keys that will launch Smartsearch
/// </summary>
/// <param name="hwndRegisteredKeys">
///  Handle of the window that is "Smartsearch-able"
/// </param>
/// <param name="registerInherit">
///  Indicates whether the registration applies only to 
///  hwndRegisteredKeys, or is also inherited by child 
///  windows created after hwndRegisteredKeys is registered.
/// </param>
/// <returns>
/// TRUE if all registrations succeeded
/// </returns>
/// <remarks>
/// When any of the registered keys are directed to the window or to any of its
/// registered children, a WM_FORWARDKEYDOWN is sent to the window with keyboard 
/// focus and to its parent window up the line until the message is handled or the
/// chain of parent windows ends.
/// </remarks>
BOOL RegisterSearchKeys(HWND hwndRegisteredKeys, INVOKESEARCH_REGISTER registerInherit);

/// <summary>
/// Unregister the window that will launch Smartsearch
/// </summary>
/// <param name="hwndRegisteredKeys">
///  Handle of the window that was "Smartsearch-able" and now won't be
/// </param>
/// <returns>
/// TRUE if all un-registrations succeeded
/// </returns>
/// <remarks>
/// <para>
/// Calling this function unregisters a window from GWES so that typing into that
/// window will not launch Smartsearch
/// </para>
/// </remarks>
BOOL UnregisterSearchKeys(HWND hwndRegisteredKeys);

/// <summary>
/// One of the registered keys has been pressed, so start forwarding.
/// </summary>
/// <returns>
/// BOOL TRUE if success
/// </returns>
BOOL ForwardSearchKeys();

/// <summary>
/// Processes a message for the search-aware window. An application should
/// typically call this method for all messages on the window.
/// </summary>
/// <param name="msg">The message code.</param>
/// <param name="wp">The first message parameter.</param>
/// <param name="lp">The second message parameter.</param>
/// <returns>
/// Returns TRUE if the message was processed. Returns FALSE if 
/// the application should perform its own processing on the message. 
/// </returns>
BOOL IsSearchMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


// Accumulator dial mode when Search is invoked
typedef enum _SEARCH_MODE {
    SEARCH_MODE_DIAL,
    SEARCH_MODE_FILTER,
} SEARCH_MODE;

/// <summary>
/// Invoke Search with an IVirtualList
/// </summary>
/// <param name="pszPageCategory">
/// [in] pointer to category name, used to select the appropriate
/// Search page to display
/// </param>
/// <param name="DialOrFilterMode">
/// [in] Flag that places the Search accumulator in either
/// dial or filter mode. The mode persists throughout the
/// Search session until subsequently invoked. In dial mode,
/// the dial string is displayed with matching characters following
/// in the discovery accumulator. In filter mode, the characters
/// are displayed directly in the accumulator.
/// </param>
/// <param name="pszContextTitle">
/// [in] pointer to title displayed in the group header for the
/// context data item added to the page
/// </param>
/// <param name="pContextData">
/// pointer to IVirtualList context object. 
/// </param>
/// <returns>
/// <para>
/// HRESULT - SUCCEEDED or FAILED
/// </para>
/// </returns>
HRESULT SearchInvokeList(
        __in LPCTSTR pszPageCategory, 
        __in SEARCH_MODE DialOrFilterMode,
        __in_opt LPCTSTR pszContextTitle, 
        __in_opt IVirtualList* pContextData);

/// <summary>
/// Invoke Search with an array of ISearchQuery objects
/// </summary>
/// <param name="pszPageCategory">
/// [in] pointer to category name, used to select the appropriate
/// Search page to display
/// </param>
/// <param name="DialOrFilterMode">
/// [in] Flag that places the Search accumulator in either
/// dial or filter mode. The mode persists throughout the
/// Search session until subsequently invoked. In dial mode,
/// the dial string is displayed with matching characters following
/// in the discovery accumulator. In filter mode, the characters
/// are displayed directly in the accumulator and the discovery 
/// accumulator is not displayed.
/// </param>
/// <param name="pszContextTitle">
/// [in] pointer to title displayed in the group header for the
/// context data item added to the page
/// </param>
/// <param name="pContextData">
/// pointer to a pointer to an ISearchQuery context data object
/// </param>
/// <returns>
/// <para>
/// HRESULT - SUCCEEDED or FAILED
/// </para>
/// </returns>
HRESULT SearchInvokeQuery(
        __in LPCTSTR pszPageCategory, 
        __in SEARCH_MODE DialOrFilterMode,
        __in LPCTSTR pszContextTitle, 
        __in ISearchQuery* pContextData);

/// <summary>
/// Invoke Smartdial
/// </summary>
/// <returns>
/// <para>
/// HRESULT - SUCCEEDED or FAILED
/// </para>
/// </returns>
HRESULT SmartDial();

// Search Icon state defs
#define SEARCH_ICON_STATE_DEFAULT 0
#define SEARCH_ICON_STATE_SHOW    1
#define SEARCH_ICON_STATE_HIDE    2

/// <summary>
/// Shows or hides the Search icon in the titlebar for
/// Search-aware applications. This API is called 
/// automatically in IsSearchMessage,
/// but the API is public so applications can show or hide
/// the icon depending on the state of the application (in
/// the event the application enters a state where invoking
/// Search is not appropriate.)
/// </summary>
/// <param name="hwnd">
/// The window that should have the search status changed
/// </param>
/// <param name="stateDisplay">
/// Either SEARCH_ICON_STATE_DEFAULT, SEARCH_ICON_STATE_HIDE, SEARCH_ICON_STATE_SHOW 
/// to hide or show the icon respectively.
/// </param>
/// <returns>
/// Returns HRESULT: S_OK if succeeded, else failed.
/// the application should perform its own processing on the message. 
/// </returns>
HRESULT SearchSetIconState(HWND hwnd, UINT stateDisplay);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\intsafe.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/******************************************************************
*                                                                 *
*  intsafe.h -- This module defines helper functions to prevent   *
*               integer overflow bugs.                            *
*                                                                 *
*                                                                 *
******************************************************************/
#ifndef _INTSAFE_H_INCLUDED_
#define _INTSAFE_H_INCLUDED_

#if (_MSC_VER > 1000)
#pragma once
#endif

#include <specstrings.h>    // for __in, etc.

// compiletime asserts (failure results in error C2118: negative subscript)
#ifndef C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#endif

//
// typedefs
//
#ifndef __wtypes_h__ //defines following
typedef          char       CHAR;
typedef unsigned char       UCHAR;
typedef unsigned char       BYTE;
typedef          short      SHORT;
typedef unsigned short      USHORT;
typedef unsigned short      WORD;
typedef          int        INT;
typedef unsigned int        UINT;
typedef          long       LONG;
typedef unsigned long       ULONG;
typedef unsigned long       DWORD;
typedef unsigned __int64    ULONGLONG;
#endif//__wtypes_h__
typedef          __int64    INT64;

#if (__midl > 501)
typedef [public]          __int3264 INT_PTR;
typedef [public] unsigned __int3264 UINT_PTR;
typedef [public]          __int3264 LONG_PTR;
typedef [public] unsigned __int3264 ULONG_PTR;
#else

#ifdef _WIN64
#ifndef _BASETSD_H_ //INT_PTR & UINT_PTR defined in basestd.h
typedef          __int64    INT_PTR;
typedef unsigned __int64    UINT_PTR;
#endif //_BASETSD_H_ 
typedef          __int64    LONG_PTR;
typedef unsigned __int64    ULONG_PTR;

#else

#ifndef _BASETSD_H_ //INT_PTR & UINT_PTR defined in basestd.h
typedef _W64 int            INT_PTR;
typedef _W64 unsigned int   UINT_PTR;
#endif  //_BASETSD_H_ 
typedef _W64 long           LONG_PTR;
typedef _W64 unsigned long  ULONG_PTR;
#endif // WIN64
#endif // (__midl > 501)

#ifndef _SIZE_T_DEFINED 
#ifdef _WIN64
typedef          __int64    ptrdiff_t;
typedef unsigned __int64    size_t;
#else
typedef _W64 int            ptrdiff_t;
typedef __w64 unsigned int  size_t;
typedef _W64 unsigned int   size_t;
#endif  // !_WIN64

#define _SIZE_T_DEFINED            
#endif  // !_SIZE_T_DEFINED		   	

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

typedef ULONG_PTR   DWORD_PTR;
typedef LONG_PTR    SSIZE_T;
typedef ULONG_PTR   SIZE_T;

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;
#endif // !_HRESULT_DEFINED

#ifndef SUCCEEDED
#define SUCCEEDED(hr)  ((HRESULT)(hr) >= 0)
#endif

#ifndef FAILED
#define FAILED(hr)  ((HRESULT)(hr) < 0)
#endif

#ifndef S_OK
#define S_OK  ((HRESULT)0x00000000L)
#endif

#define INTSAFE_E_ARITHMETIC_OVERFLOW   ((HRESULT)0x80070216L)  // 0x216 = 534 = ERROR_ARITHMETIC_OVERFLOW

#ifndef LOWORD
#define LOWORD(_dw)     ((WORD)((DWORD_PTR)(_dw) & 0xffff))
#endif
#ifndef HIWORD
#define HIWORD(_dw)     ((WORD)(((DWORD_PTR)(_dw)) >> 16))
#endif // !HIWORD
#ifndef LODWORD
#define LODWORD(_qw)    ((DWORD)((unsigned __int64)(_qw)))
#endif // !LODWORD
#ifndef HIDWORD
#define HIDWORD(_qw)    ((DWORD)(((unsigned __int64)(_qw)) >> 32))
#endif // !HIDWORD

//
// AMD64 intrinsic UnsignedMultiply128 definition
//
#if defined(_AMD64_)
#ifdef __cplusplus
extern "C" {
#endif
#define UnsignedMultiply128 _umul128
ULONG64
UnsignedMultiply128 (
    __in ULONG64  Multiplier,
    __in ULONG64  Multiplicand,
    __out ULONG64 *HighProduct
    );
#pragma intrinsic(_umul128)
#ifdef __cplusplus
}
#endif
#endif // _AMD64_

//
// UInt32x32To64 macro
//
#ifndef UInt32x32To64
#define UInt32x32To64(a, b) ((unsigned __int64)((unsigned long)(a)) * (unsigned __int64)((unsigned long)(b)))
#endif // !UInt32x32To64

#ifndef INT_MAX
#define INT_MAX         2147483647
#endif // !INT_MAX

//
// It is common for -1 to be used as an error value for various types
//
#define SIZET_ERROR     ((size_t)-1)
#define UINTPTR_ERROR   ((unsigned __int64)-1)

//
// Min/Max type values
//
#define INTSAFE_SHORT_MIN       (-32768)
#define INTSAFE_INT_MIN         (-2147483647 - 1)
#define INTSAFE_LONG_MIN        (-2147483647L - 1)
#define INTSAFE_INT64_MIN       (-9223372036854775807i64 - 1)

#ifdef _WIN64
#define INTSAFE_INT_PTR_MIN     INTSAFE_INT64_MIN
#define INTSAFE_LONG_PTR_MIN    INTSAFE_INT64_MIN
#define INTSAFE_ptrdiff_t_MIN   INTSAFE_INT64_MIN
#define INTSAFE_SSIZE_T_MIN     INTSAFE_INT64_MIN
#else
#define INTSAFE_INT_PTR_MIN     INTSAFE_INT_MIN
#define INTSAFE_LONG_PTR_MIN    INTSAFE_LONG_MIN
#define INTSAFE_ptrdiff_t_MIN   INTSAFE_INT_MIN
#define INTSAFE_SSIZE_T_MIN     INTSAFE_LONG_MIN
#endif

#define INTSAFE_BYTE_MAX        0xff
#define INTSAFE_SHORT_MAX       32767
#define INTSAFE_USHORT_MAX      0xffff
#define INTSAFE_WORD_MAX        0xffff
#define INTSAFE_INT_MAX         2147483647
#define INTSAFE_UINT_MAX        0xffffffff
#define INTSAFE_LONG_MAX        2147483647L
#define INTSAFE_ULONG_MAX       0xffffffffUL
#define INTSAFE_DWORD_MAX       0xffffffffUL
#define INTSAFE_INT64_MAX       9223372036854775807i64
#define INTSAFE_ULONGLONG_MAX   0xffffffffffffffffui64

#ifdef _WIN64
#define INTSAFE_INT_PTR_MAX     INTSAFE_INT64_MAX
#define INTSAFE_UINT_PTR_MAX    INTSAFE_ULONGLONG_MAX
#define INTSAFE_LONG_PTR_MAX    INTSAFE_INT64_MAX
#define INTSAFE_ULONG_PTR_MAX   INTSAFE_ULONGLONG_MAX
#define INTSAFE_DWORD_PTR_MAX   INTSAFE_ULONGLONG_MAX
#define INTSAFE_ptrdiff_t_MAX   INTSAFE_INT64_MAX
#define INTSAFE_size_t_MAX      INTSAFE_ULONGLONG_MAX
#define INTSAFE_SSIZE_T_MAX     INTSAFE_INT64_MAX
#define INTSAFE_SIZE_T_MAX      INTSAFE_ULONGLONG_MAX
#else
#define INTSAFE_INT_PTR_MAX     INTSAFE_INT_MAX 
#define INTSAFE_UINT_PTR_MAX    INTSAFE_UINT_MAX
#define INTSAFE_LONG_PTR_MAX    INTSAFE_LONG_MAX
#define INTSAFE_ULONG_PTR_MAX   INTSAFE_ULONG_MAX
#define INTSAFE_DWORD_PTR_MAX   INTSAFE_DWORD_MAX
#define INTSAFE_ptrdiff_t_MAX   INTSAFE_INT_MAX
#define INTSAFE_size_t_MAX      INTSAFE_UINT_MAX
#define INTSAFE_SSIZE_T_MAX     INTSAFE_LONG_MAX
#define INTSAFE_SIZE_T_MAX      INTSAFE_ULONG_MAX
#endif


//
// It is common for -1 to be used as an error value
//
#define BYTE_ERROR      0xff
#define SHORT_ERROR     (-1)

#ifndef USHORT_ERROR
#define USHORT_ERROR    0xffff
#endif
#ifndef WORD_ERROR
#define WORD_ERROR      USHORT_ERROR
#endif
#ifndef INT_ERROR
#define INT_ERROR       (-1)
#endif
#ifndef UINT_ERROR
#define UINT_ERROR      0xffffffff
#endif
#ifndef LONG_ERROR
#define LONG_ERROR      (-1L)
#endif
#ifndef ULONG_ERROR
#define ULONG_ERROR     0xffffffffUL
#endif
#ifndef DWORD_ERROR
#define DWORD_ERROR     ULONG_ERROR
#endif
#ifndef INT64_ERROR
#define INT64_ERROR     (-1i64)
#endif
#ifndef ULONGLONG_ERROR
#define ULONGLONG_ERROR (0xffffffffffffffffui64)
#endif

#ifdef _WIN64
#define INT_PTR_ERROR   INT64_ERROR
#define UINT_PTR_ERROR  ULONGLONG_ERROR
#define LONG_PTR_ERROR  INT64_ERROR
#define ULONG_PTR_ERROR ULONGLONG_ERROR
#define DWORD_PTR_ERROR ULONGLONG_ERROR
#define ptrdiff_t_ERROR INT64_ERROR
#define size_t_ERROR    ULONGLONG_ERROR
#define SSIZE_T_ERROR   INT64_ERROR
#define SIZE_T_ERROR    ULONGLONG_ERROR
#else
#define INT_PTR_ERROR   INT_ERROR 
#define UINT_PTR_ERROR  UINT_ERROR
#define LONG_PTR_ERROR  LONG_ERROR
#define ULONG_PTR_ERROR ULONG_ERROR
#define DWORD_PTR_ERROR DWORD_ERROR
#define ptrdiff_t_ERROR INT_ERROR
#define size_t_ERROR    UINT_ERROR
#define SSIZE_T_ERROR   LONG_ERROR
#define SIZE_T_ERROR    ULONG_ERROR
#endif


//
// We make some assumptions about the sizes of various types. Let's be
// explicit about those assumptions and check them.
//
C_ASSERT(sizeof(USHORT) == 2);
C_ASSERT(sizeof(INT) == 4);
C_ASSERT(sizeof(UINT) == 4);
C_ASSERT(sizeof(LONG) == 4);
C_ASSERT(sizeof(ULONG) == 4);
C_ASSERT(sizeof(UINT_PTR) == sizeof(ULONG_PTR));


// ============================================================================
// Conversion functions
//
// There are three reasons for having conversion functions:
//
// 1. We are converting from a signed type to an unsigned type of the same
//    size, or vice-versa
//
//    Since we only have unsigned math functions, this allows people to convert
//    to unsigned, do the math, and then convert back to signed
//
// 2. We are converting to a smaller type, and we could therefore possibly
//    overflow.
//
//    However, it makes no sense to have functions that convert from a
//    ULONGLONG -> BYTE (too big of a transition). If you want this then write
//    your own wrapper function that calls ULongLongToLong() and ULongToByte().
//
// 3. We are converting to a bigger type, and we are signed and the type we are
//    converting to is unsigned.
//
//=============================================================================


//
// SHORT -> UCHAR conversion
//
__inline
__checkReturn
HRESULT
ShortToUChar(
    __in SHORT sOperand,
    __out UCHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if ((sOperand >= 0) && (sOperand <= 255))
    {
        *pch = (UCHAR)sOperand;
        hr = S_OK;
    }

    return hr;
}

//
// SHORT -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
__forceinline
__checkReturn
HRESULT
ShortToChar(
    __in SHORT sOperand,
    __out CHAR* pch)
{
    return ShortToUChar(sOperand, (UCHAR*)pch);
}
#else
__inline
__checkReturn
HRESULT
ShortToChar(
    __in SHORT sOperand,
    __out CHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if ((sOperand >= -128) && (sOperand <= 127))
    {
        *pch = (CHAR)sOperand;
        hr = S_OK;
    }

    return hr;
}
#endif // _CHAR_UNSIGNED

//
// SHORT -> BYTE conversion
//
#define ShortToByte  ShortToUChar

//
// SHORT -> USHORT conversion
//
__inline
__checkReturn
HRESULT
ShortToUShort(
    __in SHORT sOperand,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (sOperand >= 0)
    {
        *pusResult = (USHORT)sOperand;
        hr = S_OK;
    }

    return hr;
}

//
// SHORT -> WORD conversion
//
#define ShortToWord ShortToUShort

//
// USHORT -> UCHAR conversion
//
__inline
__checkReturn
HRESULT
UShortToUChar(
    __in USHORT usOperand,
    __out UCHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if (usOperand <= 255)
    {
        *pch = (UCHAR)usOperand;
        hr = S_OK;
    }

    return hr;
}

//
// USHORT -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
__forceinline
__checkReturn
HRESULT
UShortToChar(
    __in USHORT usOperand,
    __out CHAR* pch)
{
    return UShortToUChar(usOperand, (UCHAR*)pch);
}
#else
__inline
__checkReturn
HRESULT
UShortToChar(
    __in USHORT usOperand,
    __out CHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if (usOperand <= 127)
    {
        *pch = (CHAR)usOperand;
        hr = S_OK;
    }

    return hr;
}
#endif // _CHAR_UNSIGNED

//
// USHORT -> BYTE conversion
//
#define UShortToByte    UShortToUChar

//
// USHORT -> SHORT conversion
//
__inline
__checkReturn
HRESULT
UShortToShort(
    __in USHORT usOperand,
    __out SHORT* psResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *psResult = SHORT_ERROR;

    if (usOperand <= INTSAFE_SHORT_MAX)
    {
        *psResult = (SHORT)usOperand;
        hr = S_OK;
    }

    return hr;
}

//
// WORD -> CHAR conversion
//
#define WordToChar  UShortToChar

//
// WORD -> UCHAR conversion
//
#define WordToUChar UShortToUChar

//
// WORD -> BYTE conversion
//
#define WordToByte  UShortToByte

//
// WORD -> SHORT conversion
//
#define WordToShort UShortToShort

//
// INT -> UCHAR conversion
//
__forceinline
__checkReturn
HRESULT
IntToUChar(
    __in INT iOperand,
    __out UCHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if ((iOperand >= 0) && (iOperand <= 255))
    {
        *pch = (UCHAR)iOperand;
        hr = S_OK;
    }

    return hr;
}

//
// INT -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
__forceinline
__checkReturn
HRESULT
IntToChar(
    __in INT iOperand,
    __out CHAR* pch)
{
    return IntToUChar(iOperand, (UCHAR*)pch);
}
#else
__forceinline
__checkReturn
HRESULT
IntToChar(
    __in INT iOperand,
    __out CHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if ((iOperand >= -128) && (iOperand <= 127))
    {
        *pch = (CHAR)iOperand;
		hr = S_OK;
    }
    
    return hr;
}
#endif // _CHAR_UNSIGNED

//
// INT -> BYTE conversion
//
#define IntToByte   IntToUChar

//
// INT -> SHORT conversion
//
__inline
__checkReturn
HRESULT
IntToShort(
    __in INT iOperand,
    __out SHORT* psResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *psResult = SHORT_ERROR;

    if ((iOperand >= INTSAFE_SHORT_MIN) && (iOperand <= INTSAFE_SHORT_MAX))
    {
        *psResult = (SHORT)iOperand;
        hr = S_OK;
    }

    return hr;
}

//
// INT -> USHORT conversion
//
__inline
__checkReturn
HRESULT
IntToUShort(
    __in INT iOperand,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if ((iOperand >= 0) && (iOperand <= INTSAFE_USHORT_MAX))
    {
        *pusResult = (USHORT)iOperand;
        hr = S_OK;
    }

    return hr;
}

//
// INT -> WORD conversion
//
#define IntToWord   IntToUShort

//
// INT -> UINT conversion
//
__forceinline
__checkReturn
HRESULT
IntToUInt(
    __in INT iOperand,
    __out UINT* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_ERROR;

    if (iOperand >= 0)
    {
        *puResult = (UINT)iOperand;
        hr = S_OK;
    }

    return hr;
}

//
// INT -> UINT_PTR conversion
//
#ifdef _WIN64
#define IntToUIntPtr    IntToULongLong
#else
#define IntToUIntPtr    IntToUInt
#endif

//
// INT -> ULONG conversion
//
__inline
__checkReturn
HRESULT
IntToULong(
    __in INT iOperand,
    __out ULONG* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG)iOperand;
        hr = S_OK;
    }

    return hr;
}

//
// INT -> ULONG_PTR conversion
//
#ifdef _WIN64
#define IntToULongPtr   IntToULongLong
#else
#define IntToULongPtr   IntToULong
#endif

//
// INT -> DWORD conversion
//
#define IntToDWord  IntToULong

//
// INT -> DWORD_PTR conversion
//
#define IntToDWordPtr   IntToULongPtr

//
// INT -> ULONGLONG conversion
//
__inline
__checkReturn
HRESULT
IntToULongLong(
    __in INT iOperand,
    __out ULONGLONG* pullResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;

    if (iOperand >= 0)
    {
        *pullResult = (ULONGLONG)iOperand;
        hr = S_OK;
    }

    return hr;
}

//
// INT -> size_t conversion
//
#define IntToSizeT  IntToUIntPtr

//
// INT -> SIZE_T conversion
//
#define IntToSIZET  IntToULongPtr

//
// UINT_PTR -> USHORT conversion
//
__inline
HRESULT
UIntPtrToUShort(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) USHORT* pusResult)
{
    HRESULT hr;

    if (uOperand <= INTSAFE_USHORT_MAX)
    {
        *pusResult = (USHORT)uOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT_PTR -> INT conversion
//
#ifdef _WIN64
#define IntPtrToInt Int64ToInt
#else
__inline
__checkReturn
HRESULT
IntPtrToInt(
    __in INT_PTR iOperand,
    __out INT* piResult)
{
    *piResult = (INT)iOperand;
    return S_OK;
}
#endif

//
// INT_PTR -> UINT conversion
//
#ifdef _WIN64
#define IntPtrToUInt    Int64ToUInt
#else
#define IntPtrToUInt    IntToUInt
#endif

//
// INT_PTR -> UINT_PTR conversion
//
#ifdef _WIN64
#define IntPtrToUIntPtr Int64ToULongLong
#else
#define IntPtrToUIntPtr IntToUInt
#endif

//
// INT_PTR -> LONG conversion
//
#ifdef _WIN64
#define IntPtrToLong    Int64ToLong
#else
__inline
__checkReturn
HRESULT
IntPtrToLong(
    __in INT_PTR iOperand,
    __out LONG* plResult)
{
    *plResult = (LONG)iOperand;
    return S_OK;
}    
#endif

//
// INT_PTR -> ULONG conversion
//
#ifdef _WIN64
#define IntPtrToULong   Int64ToULong
#else
#define IntPtrToULong   IntToULong
#endif

//
// INT_PTR -> ULONG_PTR conversion
//
#ifdef _WIN64
#define IntPtrToULongPtr    Int64ToULongLong
#else
#define IntPtrToULongPtr    IntToULong
#endif

//
// INT_PTR -> DWORD conversion
//
#define IntPtrToDWord   IntPtrToULong

//    
// INT_PTR -> DWORD_PTR conversion
//
#define IntPtrToDWordPtr    IntPtrToULongPtr

//
// INT_PTR -> ULONGLONG conversion
//
#ifdef _WIN64
#define IntPtrToULongLong   Int64ToULongLong
#else
#define IntPtrToULongLong   IntToULongLong
#endif

//
// INT_PTR -> size_t conversion
//
#define IntPtrToSizeT   IntPtrToUIntPtr

//
// INT_PTR -> SIZE_T conversion
//
#define IntPtrToSIZET   IntPtrToULongPtr

//
// UINT -> UCHAR conversion
//
__forceinline
__checkReturn
HRESULT
UIntToUChar(
    __in UINT uOperand,
    __out UCHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if (uOperand <= 255)
    {
        *pch = (UCHAR)uOperand;
        hr = S_OK;
    }

    return hr;
}

//
// UINT -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
__forceinline
__checkReturn
HRESULT
UIntToChar(
    __in UINT uOperand,
    __out CHAR* pch)
{
    return UIntToUChar(uOperand, (UCHAR*)pch);
}
#else
__forceinline
__checkReturn
HRESULT
UIntToChar(
    __in UINT uOperand,
    __out CHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if (uOperand <= 127)
    {
        *pch = (CHAR)uOperand;
        hr = S_OK;
    }

    return hr;
}
#endif // _CHAR_UNSIGNED

//
// UINT -> BYTE conversion
//
#define UIntToByte   UIntToUChar

//
// UINT -> SHORT conversion
//
__inline
__checkReturn
HRESULT
UIntToShort(
    __in UINT uOperand,
    __out SHORT* psResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *psResult = SHORT_ERROR;

    if (uOperand <= INTSAFE_SHORT_MAX)
    {
        *psResult = (SHORT)uOperand;
        hr = S_OK;
    }

    return hr;
}

//
// UINT -> USHORT conversion
//
__inline
__checkReturn
HRESULT
UIntToUShort(
    __in UINT uOperand,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (uOperand <= INTSAFE_USHORT_MAX)
    {
        *pusResult = (USHORT)uOperand;
        hr = S_OK;
    }

    return hr;
}

//
// UINT -> WORD conversion
//
#define UIntToWord  UIntToUShort

//
// UINT -> INT conversion
//
__forceinline
__checkReturn
HRESULT
UIntToInt(
    __in UINT uOperand,
    __out INT* piResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *piResult = INT_ERROR;

    if (uOperand <= INTSAFE_INT_MAX)
    {
        *piResult = (INT)uOperand;
        hr = S_OK;
    }

    return hr;
}

//
// UINT -> INT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
UIntToIntPtr(
    __in UINT uOperand,
    __out INT_PTR* piResult)
{
    *piResult = (INT_PTR)uOperand;
    return S_OK;
}
#else
#define UIntToIntPtr    UIntToInt
#endif

//
// UINT -> LONG conversion
//
__inline
__checkReturn
HRESULT
UIntToLong(
    __in UINT uOperand,
    __out LONG* plResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *plResult = LONG_ERROR;

    if (uOperand <= INTSAFE_LONG_MAX)
    {
        *plResult = (LONG)uOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// UINT -> LONG_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
UIntToLongPtr(
    __in UINT uOperand,
    __out LONG_PTR* plResult)
{
    *plResult = (LONG_PTR)uOperand;
    return S_OK;
}
#else
#define UIntToLongPtr   UIntToLong
#endif

//
// UINT -> ptrdiff_t conversion
//
#define UIntToPtrdiffT  UIntToIntPtr

//
// UINT -> SSIZE_T conversion
//
#define UIntToSSIZET    UIntToLongPtr

//
// UINT_PTR -> INT conversion
//
#ifdef _WIN64
#define UIntPtrToInt    ULongLongToInt
#else
#define UIntPtrToInt    UIntToInt
#endif

//
// UINT_PTR -> INT_PTR conversion
//
#ifdef _WIN64
#define UIntPtrToIntPtr ULongLongToInt64
#else
#define UIntPtrToIntPtr UIntToInt
#endif

//
// UINT_PTR -> UINT conversion
//
#ifdef _WIN64
#define UIntPtrToUInt   ULongLongToUInt
#else
__inline
__checkReturn
HRESULT
UIntPtrToUInt(
    __in UINT_PTR uOperand,
    __out UINT* puResult)
{
    *puResult = (UINT)uOperand;
    return S_OK;
}
#endif

//
// UINT_PTR -> LONG conversion
//
#ifdef _WIN64
#define UIntPtrToLong   ULongLongToLong
#else
#define UIntPtrToLong   UIntToLong
#endif

//
// UINT_PTR -> LONG_PTR conversion
//
#ifdef _WIN64
#define UIntPtrToLongPtr    ULongLongToInt64
#else
#define UIntPtrToLongPtr    UIntToLong
#endif

//
// UINT_PTR -> ULONG conversion
//
#ifdef _WIN64
#define UIntPtrToULong  ULongLongToULong
#else
__inline
__checkReturn
HRESULT
UIntPtrToULong(
    __in UINT_PTR uOperand,
    __out ULONG* pulResult)
{
    *pulResult = (ULONG)uOperand;
    return S_OK;
}
#endif

//
// UINT_PTR -> DWORD conversion
//
#define UIntPtrToDWord  UIntPtrToULong

//
// UINT_PTR -> INT64 conversion
//
__inline
__checkReturn
HRESULT
UIntPtrToInt64(
    __in UINT_PTR uOperand,
    __out INT64* pi64Result)
{
#ifdef _WIN64
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pi64Result = INT64_ERROR;
    
    if (uOperand <= INTSAFE_INT64_MAX)
    {
        *pi64Result = (INT64)uOperand;
        hr = S_OK;
    }
    
    return hr;
#else
    *pi64Result = (INT64)uOperand;
    return S_OK;
#endif
}

//
// UINT_PTR -> ptrdiff_t conversion
//
#define UIntPtrToPtrdiffT   UIntPtrToIntPtr

//
// UINT_PTR -> SSIZE_T conversion
//
#define UIntPtrToSSIZET UIntPtrToLongPtr

//
// LONG -> UCHAR conversion
//
__inline
__checkReturn
HRESULT
LongToUChar(
    __in LONG lOperand,
    __out UCHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if ((lOperand >= 0) && (lOperand <= 255))
    {
        *pch = (UCHAR)lOperand;
        hr = S_OK;
    }

    return hr;
}

//
// LONG -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
__forceinline
__checkReturn
HRESULT
LongToChar(
    __in LONG lOperand,
    __out CHAR* pch)
{
    return LongToUChar(lOperand, (UCHAR*)pch);
}
#else
__inline
__checkReturn
HRESULT
LongToChar(
    __in LONG lOperand,
    __out CHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if ((lOperand >= -128) && (lOperand <= 127))
    {
        *pch = (CHAR)lOperand;
        hr = S_OK;
    }

    return hr;
}
#endif // _CHAR_UNSIGNED

//
// LONG -> BYTE conversion
//
#define LongToByte  LongToUChar

//
// LONG -> SHORT conversion
//
__inline
__checkReturn
HRESULT
LongToShort(
    __in LONG lOperand,
    __out SHORT* psResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *psResult = SHORT_ERROR;
     
    if ((lOperand >= INTSAFE_SHORT_MIN) && (lOperand <= INTSAFE_SHORT_MAX))
    {
       *psResult = (SHORT)lOperand;
       hr = S_OK;
    }
     
    return hr;
}

//
// LONG -> USHORT conversion
//
__inline
__checkReturn
HRESULT
LongToUShort(
    __in LONG lOperand,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;
    
    if ((lOperand >= 0) && (lOperand <= INTSAFE_USHORT_MAX))
    {
        *pusResult = (USHORT)lOperand;
        hr = S_OK;
    }
    
    return hr;
}

//   
// LONG -> WORD conversion
//
#define LongToWord  LongToUShort

//
// LONG -> INT conversion
//
__inline
__checkReturn
HRESULT
LongToInt(
    __in LONG lOperand,
    __out INT* piResult)
{
    // we have C_ASSERT's above that ensures that this assignment is ok
    *piResult = (INT)lOperand;
    return S_OK;
}

//
// LONG -> INT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
LongToIntPtr(
    __in LONG lOperand,
    __out INT_PTR* piResult)
{
    *piResult = (INT_PTR)lOperand;
    return S_OK;
}
#else
#define LongToIntPtr    LongToInt
#endif

//
// LONG -> UINT conversion
//
__inline
__checkReturn
HRESULT
LongToUInt(
    __in LONG lOperand,
    __out UINT* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_ERROR;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT)lOperand;
        hr = S_OK;
    }
    
    return hr;
}   

//
// LONG -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
LongToUIntPtr(
    __in LONG lOperand,
    __out UINT_PTR* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_PTR_ERROR;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT_PTR)lOperand;
        hr = S_OK;
    }
    
    return hr;
}
#else
#define LongToUIntPtr   LongToUInt
#endif

//
// LONG -> ULONG conversion
//
__inline
__checkReturn
HRESULT
LongToULong(
    __in LONG lOperand,
    __out ULONG* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG)lOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// LONG -> ULONG_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
LongToULongPtr(
    __in LONG lOperand,
    __out ULONG_PTR* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_PTR_ERROR;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG_PTR)lOperand;
        hr = S_OK;
    }
    
    return hr;
}
#else
#define LongToULongPtr  LongToULong
#endif

//
// LONG -> DWORD conversion
//
#define LongToDWord LongToULong

//
// LONG -> DWORD_PTR conversion
//
#define LongToDWordPtr  LongToULongPtr

//
// LONG -> ULONGLONG conversion
//
__inline
__checkReturn
HRESULT
LongToULongLong(
    __in LONG lOperand,
    __out ULONGLONG* pullResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;
    
    if (lOperand >= 0)
    {
        *pullResult = (ULONGLONG)lOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// LONG -> ptrdiff_t conversion
//
#define LongToPtrdiffT  LongToIntPtr

//
// LONG -> size_t conversion
//
#define LongToSizeT LongToUIntPtr

//
// LONG -> SIZE_T conversion
//
#define LongToSIZET LongToULongPtr

//
// LONG_PTR -> INT conversion
//
#ifdef _WIN64
#define LongPtrToInt    Int64ToInt
#else
#define LongPtrToInt    LongToInt
#endif

//
// LONG_PTR -> INT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
LongPtrToIntPtr(
    __in LONG_PTR lOperand,
    __out INT_PTR* piResult)
{
    *piResult = (INT_PTR)lOperand;
    return S_OK;
}
#else
#define LongPtrToIntPtr LongToInt
#endif

//
// LONG_PTR -> UINT conversion
//
#ifdef _WIN64
#define LongPtrToUInt   Int64ToUInt
#else
#define LongPtrToUInt   LongToUInt
#endif

//
// LONG_PTR -> UINT_PTR conversion
//
#ifdef _WIN64
#define LongPtrToUIntPtr    Int64ToULongLong
#else
#define LongPtrToUIntPtr    LongToUInt
#endif

//
// LONG_PTR -> LONG conversion
//
__inline
__checkReturn
HRESULT
LongPtrToLong(
    __in LONG_PTR lOperand,
    __out LONG* plResult)
{
#ifdef _WIN64
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *plResult = LONG_ERROR;
    
    if ((lOperand >= INTSAFE_LONG_MIN) && (lOperand <= INTSAFE_LONG_MAX))
    {
        *plResult = (LONG)lOperand;
        hr = S_OK;
    }
    
    return hr;
#else
    *plResult = (LONG)lOperand;
    return S_OK;
#endif
}

//    
// LONG_PTR -> ULONG conversion
//
#ifdef _WIN64
#define LongPtrToULong  Int64ToULong
#else
#define LongPtrToULong  LongToULong
#endif

//
// LONG_PTR -> ULONG_PTR conversion
//
#ifdef _WIN64
#define LongPtrToULongPtr   Int64ToULongLong
#else
#define LongPtrToULongPtr   LongToULong
#endif

//
// LONG_PTR -> DWORD conversion
//
#define LongPtrToDWord  LongPtrToULong

//
// LONG_PTR -> DWORD_PTR conversion
//
#define LongPtrToDWordPtr   LongPtrToULongPtr 

//
// LONG_PTR -> ULONGLONG conversion
//
#ifdef _WIN64
#define LongPtrToULongLong  Int64ToULongLong
#else
#define LongPtrToULongLong  LongToULongLong
#endif

//
// LONG_PTR -> size_t conversion
//
#define LongPtrToSizeT  LongPtrToUIntPtr

//
// LONG_PTR -> SIZE_T conversion
//
#define LongPtrToSIZET  LongPtrToULongPtr

//
// UINT -> UCHAR conversion
//
__inline
__checkReturn
HRESULT
ULongToUChar(
    __in ULONG ulOperand,
    __out UCHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if (ulOperand <= 255)
    {
        *pch = (UCHAR)ulOperand;
        hr = S_OK;
    }

    return hr;
}

//
// ULONG -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
__forceinline
__checkReturn
HRESULT
ULongToChar(
    __in ULONG ulOperand,
    __out CHAR* pch)
{
    return ULongToUChar(ulOperand, (UCHAR*)pch);
}
#else
__inline
__checkReturn
HRESULT
ULongToChar(
    __in ULONG ulOperand,
    __out CHAR* pch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pch = '\0';

    if (ulOperand <= 127)
    {
        *pch = (CHAR)ulOperand;
        hr = S_OK;
    }

    return hr;
}
#endif // _CHAR_UNSIGNED

//
// ULONG -> BYTE conversion
//
#define ULongToByte ULongToUChar

//
// ULONG -> SHORT conversion
//
__inline
__checkReturn
HRESULT
ULongToShort(
    __in ULONG ulOperand,
    __out SHORT* psResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *psResult = SHORT_ERROR;

    if (ulOperand <= INTSAFE_SHORT_MAX)
    {
        *psResult = (SHORT)ulOperand;
        hr = S_OK;
    }

    return hr;
}

//
// ULONG -> USHORT conversion
//
__inline
__checkReturn
HRESULT
ULongToUShort(
    __in ULONG ulOperand,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (ulOperand <= INTSAFE_USHORT_MAX)
    {
        *pusResult = (USHORT)ulOperand;
        hr = S_OK;
    }

    return hr;
}

//
// ULONG -> WORD conversion
//
#define ULongToWord ULongToUShort

//
// ULONG -> INT conversion
//
__inline
__checkReturn
HRESULT
ULongToInt(
    __in ULONG ulOperand,
    __out INT* piResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *piResult = INT_ERROR;
    
    if (ulOperand <= INTSAFE_INT_MAX)
    {
        *piResult = (INT)ulOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONG -> INT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongToIntPtr(
    __in ULONG ulOperand,
    __out INT_PTR* piResult)
{
    *piResult = (INT_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongToIntPtr   ULongToInt
#endif

//
// ULONG -> UINT conversion
//
__inline
__checkReturn
HRESULT
ULongToUInt(
    __in ULONG ulOperand,
    __out UINT* puResult)
{
    // we have C_ASSERT's above that ensures that this assignment is ok    
    *puResult = (UINT)ulOperand;    
    return S_OK;
}

//
// ULONG -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongToUIntPtr(
    __in LONG ulOperand,
    __out UINT_PTR* puiResult)
{
    *puiResult = (UINT_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongToUIntPtr  ULongToUInt
#endif

//
// ULONG -> LONG conversion
//
__inline
__checkReturn
HRESULT
ULongToLong(
    __in ULONG ulOperand,
    __out LONG* plResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *plResult = LONG_ERROR;
    
    if (ulOperand <= INTSAFE_LONG_MAX)
    {
        *plResult = (LONG)ulOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONG -> LONG_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongToLongPtr(
    __in ULONG ulOperand,
    __out LONG_PTR* plResult)
{
    *plResult = (LONG_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongToLongPtr  ULongToLong
#endif

//
// ULONG -> ptrdiff_t conversion
//
#define ULongToPtrdiffT ULongToIntPtr

//
// ULONG -> SSIZE_T conversion
//
#define ULongToSSIZET   ULongToLongPtr

//
// ULONG_PTR -> INT conversion
//
#ifdef _WIN64
#define ULongPtrToInt   ULongLongToInt
#else
#define ULongPtrToInt   ULongToInt
#endif

//
// ULONG_PTR -> INT_PTR conversion
//
#ifdef _WIN64
#define ULongPtrToIntPtr    ULongLongToInt64
#else
#define ULongPtrToIntPtr    ULongToInt
#endif

//
// ULONG_PTR -> UINT conversion
//
#ifdef _WIN64
#define ULongPtrToUInt  ULongLongToUInt
#else
#define ULongPtrToUInt  ULongToUInt
#endif

//
// ULONG_PTR -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongPtrToUIntPtr(
    __in ULONG_PTR ulOperand,
    __out UINT_PTR* puResult)
{
    *puResult = (UINT_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongPtrToUIntPtr   ULongToUInt
#endif

//
// ULONG_PTR -> LONG conversion
//
#ifdef _WIN64
#define ULongPtrToLong  ULongLongToLong
#else
#define ULongPtrToLong  ULongToLong
#endif

//        
// ULONG_PTR -> LONG_PTR conversion
//
#ifdef _WIN64
#define ULongPtrToLongPtr   ULongLongToInt64
#else
#define ULongPtrToLongPtr   ULongToLong
#endif

//
// ULONG_PTR -> ULONG conversion
//
__inline
__checkReturn
HRESULT
ULongPtrToULong(
    __in ULONG_PTR ulOperand,
    __out ULONG* pulResult)
{
#ifdef _WIN64
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;

    if (ulOperand <= INTSAFE_ULONG_MAX)
    {
        *pulResult = (ULONG)ulOperand;
        hr = S_OK;
    }
    
    return hr;
#else
    *pulResult = (ULONG)ulOperand;
    return S_OK;
#endif    
}

//
// ULONG_PTR -> DWORD conversion
//
#define ULongPtrToDWord ULongPtrToULong

//
// ULONG_PTR -> INT64
//
__inline
__checkReturn
HRESULT
ULongPtrToInt64(
    __in ULONG_PTR ulOperand,
    __out INT64* pi64Result)
{
#ifdef _WIN64
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pi64Result = INT64_ERROR;
    
    if (ulOperand <= INTSAFE_INT64_MAX)
    {
        *pi64Result = (INT64)ulOperand;
        hr = S_OK;
    }
    
    return hr;
#else
    *pi64Result = (INT64)ulOperand;
    return S_OK;
#endif
}

//
// ULONG_PTR -> ptrdiff_t conversion
//
#define ULongPtrToPtrdiffT  ULongPtrToIntPtr

//
// ULONG_PTR -> SSIZE_T conversion
//
#define ULongPtrToSSIZET    ULongPtrToLongPtr

//
// DWORD -> CHAR conversion
//
#define DWordToChar ULongToChar

//
// DWORD -> UCHAR conversion
//
#define DWordToUChar    ULongToUChar

//
// DWORD -> BYTE conversion
//
#define DWordToByte ULongToUChar

//
// DWORD -> SHORT conversion
//
#define DWordToShort    ULongToShort

//
// DWORD -> USHORT conversion
//
#define DWordToUShort   ULongToUShort

//
// DWORD -> WORD conversion
//
#define DWordToWord ULongToUShort

//
// DWORD -> INT conversion
//
#define DWordToInt  ULongToInt

//
// DWORD -> INT_PTR conversion
//
#define DWordToIntPtr   ULongToIntPtr

//
// DWORD -> UINT conversion
//
#define DWordToUInt ULongToUInt

//
// DWORD -> UINT_PTR conversion
//
#define DWordToUIntPtr  ULongToUIntPtr

//
// DWORD -> LONG conversion
//
#define DWordToLong ULongToLong

//
// DWORD -> LONG_PTR conversion
//
#define DWordToLongPtr  ULongToLongPtr

//
// DWORD -> ptrdiff_t conversion
//
#define DWordToPtrdiffT ULongToIntPtr

//
// DWORD -> SSIZE_T conversion
//
#define DWordToSSIZET   ULongToLongPtr

//
// DWORD_PTR -> INT conversion
//
#define DWordPtrToInt   ULongPtrToInt

//
// DWORD_PTR -> INT_PTR conversion
//
#define DWordPtrToIntPtr    ULongPtrToIntPtr

//
// DWORD_PTR -> UINT conversion
//
#define DWordPtrToUInt  ULongPtrToUInt

//
// DWODR_PTR -> UINT_PTR conversion
//
#define DWordPtrToUIntPtr   ULongPtrToUIntPtr

//
// DWORD_PTR -> LONG conversion
//
#define DWordPtrToLong  ULongPtrToLong

//
// DWORD_PTR -> LONG_PTR conversion
//
#define DWordPtrToLongPtr   ULongPtrToLongPtr

//
// DWORD_PTR -> ULONG conversion
//
#define DWordPtrToULong ULongPtrToULong

//
// DWORD_PTR -> DWORD conversion
//
#define DWordPtrToDWord ULongPtrToULong

//
// DWORD_PTR -> INT64 conversion
//
#define DWordPtrToInt64 ULongPtrToInt64

//
// DWORD_PTR -> ptrdiff_t conversion
//
#define DWordPtrToPtrdiffT  ULongPtrToIntPtr

//
// DWORD_PTR -> SSIZE_T conversion
//
#define DWordPtrToSSIZET    ULongPtrToLongPtr

//
// INT64 -> INT conversion
//
__inline
__checkReturn
HRESULT
Int64ToInt(
    __in INT64 i64Operand,
    __out INT* piResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *piResult = INT_ERROR;
    
    if ((i64Operand >= INTSAFE_INT_MIN) && (i64Operand <= INTSAFE_INT_MAX))
    {
        *piResult = (INT)i64Operand;
        hr = S_OK;
    }
    
    return hr;
}

//
// INT64 -> INT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
Int64ToIntPtr(
    __in INT64 i64Operand,
    __out INT_PTR* piResult)
{
    *piResult = (INT_PTR)i64Operand;
    return S_OK;
}
#else
#define Int64ToIntPtr   Int64ToInt
#endif

//
// INT64 -> UINT conversion
//
__inline
__checkReturn
HRESULT
Int64ToUInt(
    __in INT64 i64Operand,
    __out UINT* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_ERROR;
    
    if ((i64Operand >= 0) && (i64Operand <= INTSAFE_UINT_MAX))
    {
        *puResult = (UINT)i64Operand;
        hr = S_OK;
    }
    
    return hr;    
}

//
// INT64 -> UINT_PTR conversion
//
#ifdef _WIN64
#define Int64ToUIntPtr  Int64ToULongLong
#else
#define Int64ToUIntPtr  Int64ToUInt
#endif

//
// INT64 -> LONG conversion
//
__inline
__checkReturn
HRESULT
Int64ToLong(
    __in INT64 i64Operand,
    __out LONG* plResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *plResult = LONG_ERROR;
    
    if ((i64Operand >= INTSAFE_LONG_MIN) && (i64Operand <= INTSAFE_LONG_MAX))
    {
        *plResult = (LONG)i64Operand;
        hr = S_OK;
    }
    
    return hr;    
}

//
// INT64 -> LONG_PTR conversion
//
#ifdef _WIN64
#define Int64ToLongPtr  Int64ToIntPtr
#else
#define Int64ToLongPtr  Int64ToLong
#endif

//
// INT64 -> ULONG conversion
//
__inline
__checkReturn
HRESULT
Int64ToULong(
    __in INT64 i64Operand,
    __out ULONG* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;
    
    if ((i64Operand >= 0) && (i64Operand <= INTSAFE_ULONG_MAX))
    {
        *pulResult = (ULONG)i64Operand;
        hr = S_OK;
    }
    
    return hr;    
}

//
// INT64 -> ULONG_PTR conversion
//
#ifdef _WIN64
#define Int64ToULongPtr Int64ToULongLong
#else
#define Int64ToULongPtr Int64ToULong
#endif

//
// INT64 -> DWORD conversion
//
#define Int64ToDWord    Int64ToULong

//
// INT64 -> DWORD_PTR conversion
//
#define Int64ToDWordPtr Int64ToULongPtr

//
// INT64 -> ULONGLONG conversion
//
__inline
__checkReturn
HRESULT
Int64ToULongLong(
    __in INT64 i64Operand,
    __out ULONGLONG* pullResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;
    
    if (i64Operand >= 0)
    {
        *pullResult = (ULONGLONG)i64Operand;
        hr = S_OK;
    }
    
    return hr; 
}

//
// INT64 -> ptrdiff_t conversion
//
#define Int64ToPtrdiffT Int64ToIntPtr

//
// INT64 -> size_t conversion
//
#define Int64ToSizeT    Int64ToUIntPtr

//
// INT64 -> SSIZE_T conversion
//
#define Int64ToSSIZET   Int64ToLongPtr

//
// INT64 -> SIZE_T conversion
//
#define Int64ToSIZET    Int64ToULongPtr

//
// ULONGLONG -> INT conversion
//
__inline
__checkReturn
HRESULT
ULongLongToInt(
    __in ULONGLONG ullOperand,
    __out INT* piResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *piResult = INT_ERROR;
    
    if (ullOperand <= INTSAFE_INT_MAX)
    {
        *piResult = (INT)ullOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONGLONG -> INT_PTR conversion
//
#ifdef _WIN64
#define ULongLongToIntPtr   ULongLongToInt64
#else
#define ULongLongToIntPtr   ULongLongToInt
#endif

//
// ULONGLONG -> UINT conversion
//
__forceinline
__checkReturn
HRESULT
ULongLongToUInt(
    __in ULONGLONG ullOperand,
    __out UINT* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_ERROR;
    
    if (ullOperand <= INTSAFE_UINT_MAX)
    {
        *puResult = (UINT)ullOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONGLONG -> UINT_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongLongToUIntPtr(
    __in ULONGLONG ullOperand,
    __out UINT_PTR* puResult)
{
    *puResult = (UINT_PTR)ullOperand;
    return S_OK;
}
#else    
#define ULongLongToUIntPtr  ULongLongToUInt
#endif

//
// ULONGLONG -> LONG conversion
//
__inline
__checkReturn
HRESULT
ULongLongToLong(
    __in ULONGLONG ullOperand,
    __out LONG* plResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *plResult = LONG_ERROR;
    
    if (ullOperand <= INTSAFE_LONG_MAX)
    {
        *plResult = (LONG)ullOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONGLONG -> LONG_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongLongToLongPtr(
    __in ULONGLONG ullOperand,
    __out LONG_PTR* plResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *plResult = LONG_PTR_ERROR;
    
    if (ullOperand <= INTSAFE_LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)ullOperand;
        hr = S_OK;
    }
    
    return hr;
}
#else
#define ULongLongToLongPtr  ULongLongToLong
#endif

//
// ULONGLONG -> ULONG conversion
//
__forceinline
__checkReturn
HRESULT
ULongLongToULong(
    __in ULONGLONG ullOperand,
    __out ULONG* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;
    
    if (ullOperand <= INTSAFE_ULONG_MAX)
    {
        *pulResult = (ULONG)ullOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONGLONG -> ULONG_PTR conversion
//
#ifdef _WIN64
__inline
__checkReturn
HRESULT
ULongLongToULongPtr(
    __in ULONGLONG ullOperand,
    __out ULONG_PTR* pulResult)
{
    *pulResult = (ULONG_PTR)ullOperand;
    return S_OK;
}
#else
#define ULongLongToULongPtr ULongLongToULong
#endif

//
// ULONGLONG -> DWORD conversion
//
#define ULongLongToDWord    ULongLongToULong

//
// ULONGLONG -> DWORD_PTR conversion
//
#define ULongLongToDWordPtr ULongLongToULongPtr

//
// ULONGLONG -> INT64 conversion
//
__inline
__checkReturn
HRESULT
ULongLongToInt64(
    __in ULONGLONG ullOperand,
    __out INT64* pi64Result)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pi64Result = INT64_ERROR;
    
    if (ullOperand <= INTSAFE_INT64_MAX)
    {
        *pi64Result = (INT64)ullOperand;
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONGLONG -> ptrdiff_t conversion
//
#define ULongLongToPtrdiffT ULongLongToIntPtr

//
// ULONGLONG -> size_t conversion
//
#define ULongLongToSizeT    ULongLongToUIntPtr

//
// ULONGLONG -> SSIZE_T conversion
//
#define ULongLongToSSIZET   ULongLongToLongPtr

//
// ULONGLONG -> SIZE_T conversion
//
#define ULongLongToSIZET    ULongLongToULongPtr

//
// ptrdiff_t -> INT conversion
//
#define PtrdiffTToInt   IntPtrToInt

//
// ptrdiff_t -> UINT conversion
//
#define PtrdiffTToUInt  IntPtrToUInt

//
// ptrdiff_t -> UINT_PTR conversion
//
#define PtrdiffTToUIntPtr   IntPtrToUIntPtr

//
// ptrdiff_t -> LONG conversion
//
#define PtrdiffTToLong  IntPtrToLong

//
// ptrdiff_t -> ULONG conversion
//
#define PtrdiffTToULong IntPtrToULong

//
// ptrdiff_t -> ULONG_PTR conversion
//
#define PtrdiffTToULongPtr  IntPtrToULongPtr

//
// ptrdiff_t -> DWORD conversion
//
#define PtrdiffTToDWord IntPtrToULong

//
// ptrdiff_t -> DWORD_PTR conversion
//
#define PtrdiffTToDWordPtr  IntPtrToULongPtr

//
// ptrdiff_t -> size_t conversion
//
#define PtrdiffTToSizeT IntPtrToUIntPtr

//
// ptrdiff_t -> SIZE_T conversion
//
#define PtrdiffTToSIZET IntPtrToULongPtr

//
// size_t -> INT conversion
//
#define SizeTToInt  UIntPtrToInt

//
// size_t -> INT_PTR conversion
//
#define SizeTToIntPtr   UIntPtrToIntPtr

//
// size_t -> UINT conversion
//
#define SizeTToUInt UIntPtrToUInt

//
// size_t -> LONG conversion
//
#define SizeTToLong UIntPtrToLong

//
// size_t -> LONG_PTR conversion
//
#define SizeTToLongPtr  UIntPtrToLongPtr

//
// size_t -> ULONG conversion
//
#define SizeTToULong    UIntPtrToULong

//
// size_t -> DWORD conversion
//
#define SizeTToDWord    UIntPtrToULong

//
// size_t -> INT64
//
__inline
__checkReturn
HRESULT
SizeTToInt64(
    __in size_t Operand,
    __out INT64* pi64Result)
{
#ifdef _WIN64
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pi64Result = INT64_ERROR;
    
    if (Operand <= INTSAFE_INT64_MAX)
    {
        *pi64Result = (INT64)Operand;
        hr = S_OK;
    }
    
    return hr; 
#else
    *pi64Result = (INT64)Operand;
    return S_OK;
#endif
}

//
// size_t -> WORD
//
#define SizeTToWord UIntPtrToUShort

//   
// size_t -> ptrdiff_t conversion
//
#define SizeTToPtrdiffT UIntPtrToIntPtr

//
// size_t -> SSIZE_T conversion
//
#define SizeTToSSIZET   UIntPtrToLongPtr

//
// SSIZE_T -> INT conversion
//
#define SSIZETToInt LongPtrToInt

//
// SSIZE_T -> INT_PTR conversion
//
#define SSIZETToIntPtr  LongPtrToIntPtr

//
// SSIZE_T -> UINT conversion
//
#define SSIZETToUInt    LongPtrToUInt

//
// SSIZE_T -> UINT_PTR conversion
//
#define SSIZETToUIntPtr LongPtrToUIntPtr

//
// SSIZE_T -> LONG conversion
//
#define SSIZETToLong    LongPtrToLong

//
// SSIZE_T -> ULONG conversion
//
#define SSIZETToULong   LongPtrToULong

//
// SSIZE_T -> ULONG_PTR conversion
//
#define SSIZETToULongPtr    LongPtrToULongPtr

//
// SSIZE_T -> DWORD conversion
//
#define SSIZETToDWord   LongPtrToULong

//
// SSIZE_T -> DWORD_PTR conversion
//
#define SSIZETToDWordPtr    LongPtrToULongPtr

//
// SSIZE_T -> size_t conversion
//
#define SSIZETToSizeT   LongPtrToUIntPtr

//
// SSIZE_T -> SIZE_T conversion
//
#define SSIZETToSIZET   LongPtrToULongPtr

//
// SIZE_T -> INT conversion
//
#define SIZETToInt  ULongPtrToInt

//
// SIZE_T -> INT_PTR conversion
//
#define SIZETToIntPtr   ULongPtrToIntPtr

//
// SIZE_T -> UINT conversion
//
#define SIZETToUInt ULongPtrToUInt

//
// SIZE_T -> LONG conversion
//
#define SIZETToLong ULongPtrToLong

//
// SIZE_T -> LONG_PTR conversion
//
#define SIZETToLongPtr  ULongPtrToLongPtr

//
// SIZE_T -> ULONG conversion
//
#define SIZETToULong    ULongPtrToULong

//
// SIZE_T -> DWORD conversion
//
#define SIZETToDWord    ULongPtrToULong

//
// SIZE_T -> INT64
//
#define SIZETToInt64    ULongPtrToInt64

//
// SIZE_T -> ptrdiff_t conversion
//
#define SIZETToPtrdiffT ULongPtrToIntPtr

//
// SIZE_T -> SSIZE_T conversion
//
#define SIZETToSSIZET   ULongPtrToLongPtr


// ============================================================================
// Addition functions
//=============================================================================

//
// USHORT addition
//
__forceinline
__checkReturn
HRESULT
UShortAdd(
    __in USHORT usAugend,
    __in USHORT usAddend,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (((USHORT)(usAugend + usAddend)) >= usAugend)
    {
        *pusResult = (usAugend + usAddend);
        hr = S_OK;
    }
    
    return hr;
}

//
// WORD addtition
//
#define WordAdd     UShortAdd

//
// UINT addition
//
__forceinline
__checkReturn
HRESULT
UIntAdd(
    __in UINT uAugend,
    __in UINT uAddend,
    __out UINT* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_ERROR;

    if ((unsigned int)(uAugend + uAddend) >= uAugend)
    {
        *puResult = (uAugend + uAddend);
        hr = S_OK;
    }
    
    return hr;
}

//
// UINT_PTR addition
//
#ifdef _WIN64
#define UIntPtrAdd      ULongLongAdd
#else
#define UIntPtrAdd      UIntAdd
#endif // _WIN64

//
// ULONG addition
//
__forceinline
__checkReturn
HRESULT
ULongAdd(
    __in ULONG ulAugend,
    __in ULONG ulAddend,
    __out ULONG* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;

    if ((unsigned long)(ulAugend + ulAddend) >= ulAugend) 
    {
        *pulResult = (ulAugend + ulAddend);
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONG_PTR addition
//
#ifdef _WIN64
#define ULongPtrAdd     ULongLongAdd
#else
#define ULongPtrAdd     ULongAdd
#endif // _WIN64

//
// DWORD addition
//
#define DWordAdd        ULongAdd

//
// DWORD_PTR addition
//
#ifdef _WIN64
#define DWordPtrAdd     ULongLongAdd
#else
#define DWordPtrAdd     ULongAdd
#endif // _WIN64

//
// size_t addition
//
__forceinline
__checkReturn
HRESULT
SizeTAdd(
    __in size_t Augend,
    __in size_t Addend,
    __out size_t* pResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pResult = size_t_ERROR;

    if ((Augend + Addend) >= Augend)
    {
        *pResult = (Augend + Addend);
        hr = S_OK;
    }
    
    return hr;
}

//
// SIZE_T addition
//
#ifdef _WIN64
#define SIZETAdd      ULongLongAdd
#else
#define SIZETAdd      ULongAdd
#endif // _WIN64

//
// ULONGLONG addition
//
__forceinline
__checkReturn
HRESULT
ULongLongAdd(
    __in ULONGLONG ullAugend,
    __in ULONGLONG ullAddend,
    __out ULONGLONG* pullResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;

    if ((ullAugend + ullAddend) >= ullAugend)
    {
        *pullResult = (ullAugend + ullAddend);
        hr = S_OK;
    }
    
    return hr;
}


// ============================================================================
// Subtraction functions
//=============================================================================

//
// USHORT subtraction
//
__forceinline
__checkReturn
HRESULT
UShortSub(
    __in USHORT usMinuend,
    __in USHORT usSubtrahend,
    __out USHORT* pusResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (usMinuend >= usSubtrahend)
    {
        *pusResult = (usMinuend - usSubtrahend);
        hr = S_OK;
    }
    
    return hr;
}

//
// WORD subtraction
//
#define WordSub     UShortSub


//
// UINT subtraction
//
__forceinline
__checkReturn
HRESULT
UIntSub(
    __in UINT uMinuend,
    __in UINT uSubtrahend,
    __out UINT* puResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *puResult = UINT_ERROR;

    if (uMinuend >= uSubtrahend)
    {
        *puResult = (uMinuend - uSubtrahend);
        hr = S_OK;
    }
    
    return hr;
}

//
// UINT_PTR subtraction
//
#ifdef _WIN64
#define UIntPtrSub  ULongLongSub
#else
#define UIntPtrSub  UIntSub
#endif // _WIN64

//
// ULONG subtraction
//
__forceinline
__checkReturn
HRESULT
ULongSub(
    __in ULONG ulMinuend,
    __in ULONG ulSubtrahend,
    __out ULONG* pulResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pulResult = ULONG_ERROR;

    if (ulMinuend >= ulSubtrahend)
    {
        *pulResult = (ulMinuend - ulSubtrahend);
        hr = S_OK;
    }
    
    return hr;
}

//
// ULONG_PTR subtraction
//
#ifdef _WIN64
#define ULongPtrSub ULongLongSub
#else
#define ULongPtrSub ULongSub
#endif // _WIN64


//
// DWORD subtraction
//
#define DWordSub        ULongSub

//
// DWORD_PTR subtraction
//
#ifdef _WIN64
#define DWordPtrSub     ULongLongSub
#else
#define DWordPtrSub     ULongSub
#endif // _WIN64

//
// size_t subtraction
//
__forceinline
__checkReturn
HRESULT
SizeTSub(
    __in size_t Minuend,
    __in size_t Subtrahend,
    __out size_t* pResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pResult = size_t_ERROR;

    if (Minuend >= Subtrahend)
    {
        *pResult = (Minuend - Subtrahend);
        hr = S_OK;
    }
    
    return hr;
}

//
// SIZE_T subtraction
//
#ifdef _WIN64
#define SIZETSub    ULongLongSub
#else
#define SIZETSub    ULongSub
#endif // _WIN64

//
// ULONGLONG subtraction
//
__forceinline
__checkReturn
HRESULT
ULongLongSub(
    __in ULONGLONG ullMinuend,
    __in ULONGLONG ullSubtrahend,
    __out ULONGLONG* pullResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;

    if (ullMinuend >= ullSubtrahend)
    {
        *pullResult = (ullMinuend - ullSubtrahend);
        hr = S_OK;
    }
    
    return hr;
}


// ============================================================================
// Multiplication functions
//=============================================================================

//
// USHORT multiplication
//
__forceinline
__checkReturn
HRESULT
UShortMult(
    __in USHORT usMultiplicand,
    __in USHORT usMultiplier,
    __out USHORT* pusResult)
{
    ULONG ulResult = ((ULONG)usMultiplicand) * (ULONG)usMultiplier;
    
    return ULongToUShort(ulResult, pusResult);
}

//
// WORD multiplication
//
#define WordMult      UShortMult

//
// UINT multiplication
//
__forceinline
__checkReturn
HRESULT
UIntMult(
    __in UINT uMultiplicand,
    __in UINT uMultiplier,
    __out UINT* puResult)
{
    ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

    return ULongLongToUInt(ull64Result, puResult);
}

//
// UINT_PTR multiplication
//
#ifdef _WIN64
#define UIntPtrMult     ULongLongMult
#else
#define UIntPtrMult     UIntMult
#endif // _WIN64

//
// ULONG multiplication
//
__forceinline
__checkReturn
HRESULT
ULongMult(
    __in ULONG ulMultiplicand,
    __in ULONG ulMultiplier,
    __out ULONG* pulResult)
{
    ULONGLONG ull64Result = UInt32x32To64(ulMultiplicand, ulMultiplier);
    
    return ULongLongToULong(ull64Result, pulResult);
}

//
// ULONG_PTR multiplication
//
#ifdef _WIN64
#define ULongPtrMult    ULongLongMult
#else
#define ULongPtrMult    ULongMult
#endif // _WIN64


//
// DWORD multiplication
//
#define DWordMult       ULongMult

//
// DWORD_PTR multiplication
//
#ifdef _WIN64
#define DWordPtrMult    ULongLongMult
#else
#define DWordPtrMult    ULongMult
#endif // _WIN64

//
// size_t multiplication
//

#ifdef _WIN64
#define SizeTMult       ULongLongMult
#else
#define SizeTMult       UIntMult
#endif // _WIN64

//
// SIZE_T multiplication
//
#ifdef _WIN64
#define SIZETMult       ULongLongMult
#else
#define SIZETMult       ULongMult
#endif // _WIN64

//
// ULONGLONG multiplication
//
__inline
__checkReturn
HRESULT
ULongLongMult(
    __in ULONGLONG ullMultiplicand,
    __in ULONGLONG ullMultiplier,
    __out ULONGLONG* pullResult)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
#ifdef _AMD64_
    ULONGLONG u64ResultHigh;
    ULONGLONG u64ResultLow;
    
    *pullResult = ULONGLONG_ERROR;
    
    u64ResultLow = UnsignedMultiply128(ullMultiplicand, ullMultiplier, &u64ResultHigh);
    if (u64ResultHigh == 0)
    {
        *pullResult = u64ResultLow;
        hr = S_OK;
    }
#else
    // 64x64 into 128 is like 32.32 x 32.32.
    //
    // a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
    // back in non-decimal notation where A=a*2^32 and C=c*2^32:  
    // A*C + A*d + b*C + b*d
    // So there are four components to add together.
    //   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
    //
    // a * c must be 0 or there would be bits in the high 64-bits
    // a * d must be less than 2^32 or there would be bits in the high 64-bits
    // b * c must be less than 2^32 or there would be bits in the high 64-bits
    // then there must be no overflow of the resulting values summed up.
    
    ULONG dw_a;
    ULONG dw_b;
    ULONG dw_c;
    ULONG dw_d;
    ULONGLONG ad = 0;
    ULONGLONG bc = 0;
    ULONGLONG bd = 0;
    ULONGLONG ullResult = 0;
    
    *pullResult = ULONGLONG_ERROR;

    dw_a = (ULONG)(ullMultiplicand >> 32);
    dw_c = (ULONG)(ullMultiplier >> 32);

    // common case -- if high dwords are both zero, no chance for overflow
    if ((dw_a == 0) && (dw_c == 0))
    {
        dw_b = (DWORD)ullMultiplicand;
        dw_d = (DWORD)ullMultiplier;

        *pullResult = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
        hr = S_OK;
    }
    else
    {
        // a * c must be 0 or there would be bits set in the high 64-bits
        if ((dw_a == 0) ||
            (dw_c == 0))
        {
            dw_d = (DWORD)ullMultiplier;

            // a * d must be less than 2^32 or there would be bits set in the high 64-bits
            ad = (((ULONGLONG)dw_a) * (ULONGLONG)dw_d);
            if ((ad & 0xffffffff00000000) == 0)
            {
                dw_b = (DWORD)ullMultiplicand;

                // b * c must be less than 2^32 or there would be bits set in the high 64-bits
                bc = (((ULONGLONG)dw_b) * (ULONGLONG)dw_c);
                if ((bc & 0xffffffff00000000) == 0)
                {
                    // now sum them all up checking for overflow.
                    // shifting is safe because we already checked for overflow above
#ifdef _WIN64 
                    if (SUCCEEDED(ULongLongAdd(bc << 32, ad << 32, &ullResult)))                        
#else
                    // << 32 not supported on 32-bit compilers
                    if (SUCCEEDED(ULongLongAdd(bc * 4294967295, ad * 4294967295, &ullResult)))
#endif                                      
                                                   {
                        // b * d
                        bd = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
                    
                        if (SUCCEEDED(ULongLongAdd(ullResult, bd, &ullResult)))
                        {
                            *pullResult = ullResult;
                            hr = S_OK;
                        }
                    }
                }
            }
        }
    }
#endif // _AMD64_  
    
    return hr;
}

#ifdef UNDER_CE
// Extra helper functions specific to CE

__inline
HRESULT
CeULongAdd3(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__out unsigned long* pResult)
{
	if(SUCCEEDED(ULongAdd(arg1,arg2,pResult)) &&
		SUCCEEDED(ULongAdd(*pResult,arg3,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}

__inline
HRESULT
CeULongAdd4(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__in unsigned long arg4,
	__out unsigned long* pResult)
{
	if(SUCCEEDED(ULongAdd(arg1,arg2,pResult)) &&
		SUCCEEDED(ULongAdd(*pResult,arg3,pResult)) &&
		SUCCEEDED(ULongAdd(*pResult,arg4,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}

__inline
HRESULT
CeULongAdd10(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__in unsigned long arg4,
	__in unsigned long arg5,
	__in unsigned long arg6,
	__in unsigned long arg7,
	__in unsigned long arg8,
	__in unsigned long arg9,
	__in unsigned long arg10,
    __out unsigned long* pResult)
{
	if(SUCCEEDED(CeULongAdd4(arg1,arg2,arg3,arg4,pResult)) &&
		SUCCEEDED(CeULongAdd4(*pResult,arg5,arg6,arg7,pResult)) &&
		SUCCEEDED(CeULongAdd4(*pResult,arg8,arg9,arg10,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}


// (arg1*arg2) + arg3
__inline
HRESULT
CeULongMult2Add(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__out unsigned long* pResult)
{
	if(SUCCEEDED(ULongMult(arg1,arg2,pResult)) &&
		SUCCEEDED(ULongAdd(*pResult,arg3,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}

// (arg1+arg2) * arg3
__inline
HRESULT
CeULongAdd2Mult(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__out unsigned long* pResult)
{
	if(SUCCEEDED(ULongAdd(arg1,arg2,pResult)) &&
		SUCCEEDED(ULongMult(*pResult,arg3,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}

#define CeDWordAdd3(arg1,arg2,arg3,pResult) CeULongAdd3(arg1,arg2,arg3,pResult)

#define CeDWordAdd4(arg1,arg2,arg3,arg4,pResult) CeULongAdd4(arg1,arg2,arg3,arg4,pResult)

#define CeDWordMult2Add(arg1,arg2,arg3,pResult) CeULongMult2Add(arg1,arg2,arg3,pResult)

#define CeDWordAdd2Mult(arg1,arg2,arg3,pResult) CeULongAdd2Mult(arg1,arg2,arg3,pResult)

__inline
HRESULT
CeUIntAdd3(
	__in unsigned int arg1,
	__in unsigned int arg2,
	__in unsigned int arg3,
	__out unsigned int* pResult)
{
	if(SUCCEEDED(UIntAdd(arg1,arg2,pResult)) &&
		SUCCEEDED(UIntAdd(*pResult,arg3,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}

__inline
HRESULT
CeUIntAdd4(
	__in unsigned int arg1,
	__in unsigned int arg2,
	__in unsigned int arg3,
	__in unsigned int arg4,
	__out unsigned int* pResult)
{
	if(SUCCEEDED(UIntAdd(arg1,arg2,pResult)) &&
		SUCCEEDED(UIntAdd(*pResult,arg3,pResult)) &&
		SUCCEEDED(UIntAdd(*pResult,arg4,pResult))){
		return S_OK;
	}

	return INTSAFE_E_ARITHMETIC_OVERFLOW;
}

#endif

//
// INT -> WCHAR conversion
//
__inline
__checkReturn
HRESULT
IntToWChar(
    __in int iOperand,
    __out wchar_t* pwch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pwch = L'\0';

    if ((iOperand >= 0) && (iOperand <= 65535))
    {
        *pwch = (wchar_t)iOperand;
        hr = S_OK;
    }

    return hr;
}



//
// UINT -> WCHAR conversion
//
__inline
__checkReturn
HRESULT
UIntToWChar(
    __in unsigned int uOperand,
    __out wchar_t* pwch)
{
    HRESULT hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    *pwch = L'\0';

    if (uOperand <= 65535)
    {
        *pwch = (wchar_t)uOperand;
        hr = S_OK;
    }

    return hr;
}

#endif // _INTSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\interned.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* at Thu May 22 14:45:32 2008
 */
/* Compiler settings for ..\interned.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __interned_h__
#define __interned_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISelectionObject2_FWD_DEFINED__
#define __ISelectionObject2_FWD_DEFINED__
typedef interface ISelectionObject2 ISelectionObject2;
#endif 	/* __ISelectionObject2_FWD_DEFINED__ */


#ifndef __IHTMLEditor_FWD_DEFINED__
#define __IHTMLEditor_FWD_DEFINED__
typedef interface IHTMLEditor IHTMLEditor;
#endif 	/* __IHTMLEditor_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow_FWD_DEFINED__
#define __IHTMLPrivateWindow_FWD_DEFINED__
typedef interface IHTMLPrivateWindow IHTMLPrivateWindow;
#endif 	/* __IHTMLPrivateWindow_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow2_FWD_DEFINED__
#define __IHTMLPrivateWindow2_FWD_DEFINED__
typedef interface IHTMLPrivateWindow2 IHTMLPrivateWindow2;
#endif 	/* __IHTMLPrivateWindow2_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow3_FWD_DEFINED__
#define __IHTMLPrivateWindow3_FWD_DEFINED__
typedef interface IHTMLPrivateWindow3 IHTMLPrivateWindow3;
#endif 	/* __IHTMLPrivateWindow3_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow4_FWD_DEFINED__
#define __IHTMLPrivateWindow4_FWD_DEFINED__
typedef interface IHTMLPrivateWindow4 IHTMLPrivateWindow4;
#endif 	/* __IHTMLPrivateWindow4_FWD_DEFINED__ */


#ifndef __ISubDivisionProvider_FWD_DEFINED__
#define __ISubDivisionProvider_FWD_DEFINED__
typedef interface ISubDivisionProvider ISubDivisionProvider;
#endif 	/* __ISubDivisionProvider_FWD_DEFINED__ */


#ifndef __IElementBehaviorUI_FWD_DEFINED__
#define __IElementBehaviorUI_FWD_DEFINED__
typedef interface IElementBehaviorUI IElementBehaviorUI;
#endif 	/* __IElementBehaviorUI_FWD_DEFINED__ */


#ifndef __IElementAdorner_FWD_DEFINED__
#define __IElementAdorner_FWD_DEFINED__
typedef interface IElementAdorner IElementAdorner;
#endif 	/* __IElementAdorner_FWD_DEFINED__ */


#ifndef __IHTMLEditingServices_FWD_DEFINED__
#define __IHTMLEditingServices_FWD_DEFINED__
typedef interface IHTMLEditingServices IHTMLEditingServices;
#endif 	/* __IHTMLEditingServices_FWD_DEFINED__ */


#ifndef __IEditDebugServices_FWD_DEFINED__
#define __IEditDebugServices_FWD_DEFINED__
typedef interface IEditDebugServices IEditDebugServices;
#endif 	/* __IEditDebugServices_FWD_DEFINED__ */


#ifndef __IDisplayTreeDumper_FWD_DEFINED__
#define __IDisplayTreeDumper_FWD_DEFINED__
typedef interface IDisplayTreeDumper IDisplayTreeDumper;
#endif 	/* __IDisplayTreeDumper_FWD_DEFINED__ */


#ifndef __IPrivacyServices_FWD_DEFINED__
#define __IPrivacyServices_FWD_DEFINED__
typedef interface IPrivacyServices IPrivacyServices;
#endif 	/* __IPrivacyServices_FWD_DEFINED__ */


#ifndef __IHTMLFilterPainter_FWD_DEFINED__
#define __IHTMLFilterPainter_FWD_DEFINED__
typedef interface IHTMLFilterPainter IHTMLFilterPainter;
#endif 	/* __IHTMLFilterPainter_FWD_DEFINED__ */


#ifndef __IHTMLFilterPaintSite_FWD_DEFINED__
#define __IHTMLFilterPaintSite_FWD_DEFINED__
typedef interface IHTMLFilterPaintSite IHTMLFilterPaintSite;
#endif 	/* __IHTMLFilterPaintSite_FWD_DEFINED__ */


#ifndef __IElementNamespacePrivate_FWD_DEFINED__
#define __IElementNamespacePrivate_FWD_DEFINED__
typedef interface IElementNamespacePrivate IElementNamespacePrivate;
#endif 	/* __IElementNamespacePrivate_FWD_DEFINED__ */


#ifndef __IHttpHeaderInfo_FWD_DEFINED__
#define __IHttpHeaderInfo_FWD_DEFINED__
typedef interface IHttpHeaderInfo IHttpHeaderInfo;
#endif 	/* __IHttpHeaderInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "dimm.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_interned_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// internal.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// TRIDENT Editing Services Interfaces.
//

#ifndef INTERNAL_H_
#define INTERNAL_H_



extern RPC_IF_HANDLE __MIDL_itf_interned_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_interned_0000_0000_v0_0_s_ifspec;


#ifndef __MSHTMLINTERNAL_LIBRARY_DEFINED__
#define __MSHTMLINTERNAL_LIBRARY_DEFINED__

/* library MSHTMLINTERNAL */
/* [uuid][version][helpstring][lcid] */ 

typedef 
enum _EDITOR_NOTIFICATION
    {	EDITOR_NOTIFY_TIMER_TICK	= 0,
	EDITOR_NOTIFY_DOC_ENDED	= 1,
	EDITOR_NOTIFY_DOC_CHANGED	= 2,
	EDITOR_NOTIFY_CARET_IN_CONTEXT	= 3,
	EDITOR_NOTIFY_EXIT_TREE	= 4,
	EDITOR_NOTIFY_LOSE_FOCUS_FRAME	= 5,
	EDITOR_NOTIFY_LOSE_FOCUS	= 6,
	EDITOR_NOTIFY_BEFORE_FOCUS	= 7,
	EDITOR_NOTIFY_YIELD_FOCUS	= 8,
	EDITOR_NOTIFY_EDITABLE_CHANGE	= 9,
	EDITOR_NOTIFY_BEGIN_SELECTION_UNDO	= 10,
	EDITOR_NOTIFY_ATTACH_WIN	= 11,
	EDITOR_NOTIFY_UPDATE_CARET	= 12,
	EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE	= 13,
	EDITOR_NOTIFY_SETTING_VIEW_LINK	= 14,
	EDITOR_NOTIFY_CONTAINER_ENDED	= 15,
	EDITOR_NOTIFY_SETTINGS_CHANGED	= 16,
	EDITOR_NOTIFICATION_Max	= 2147483647L
    } 	EDITOR_NOTIFICATION;

typedef 
enum _DOCNAVFLAGS
    {	DOCNAVFLAG_DOCNAVIGATE	= 1,
	DOCNAVFLAG_DONTUPDATETLOG	= 2,
	DOCNAVFLAG_HTTPERRORPAGE	= 4,
	DOCNAVFLAG_OPENINNEWWINDOW	= 8,
	DOCNAVFLAG_REFRESH	= 16,
	DOCNAVFLAG_TRUSTEDFORACTIVEX	= 32,
	DOCNAVFLAG_UNTRUSTEDFORDOWNLOAD	= 64,
	DOCNAVFLAG_CALLERUNTRUSTED	= 128,
	DOCNAVFLAGS_Max	= 2147483647L
    } 	DOCNAVFLAGS;

typedef 
enum _NAVIGATEEXOPTIONS
    {	NAVIGATEEX_NONE	= 0,
	NAVIGATEEX_DONTUPDATETRAVELLOG	= 1,
	NAVIGATEEX_EXECUTESCRIPT	= 2,
	NAVIGATEEXOPTIONS_Max	= 2147483647L
    } 	NAVIGATEEXOPTIONS;

typedef 
enum _CHAR_FORMAT_FAMILY
    {	CHAR_FORMAT_None	= 0,
	CHAR_FORMAT_FontStyle	= 1,
	CHAR_FORMAT_FontInfo	= 2,
	CHAR_FORMAT_FontName	= 4,
	CHAR_FORMAT_ColorInfo	= 8,
	CHAR_FORMAT_ParaFormat	= 16,
	CHAR_FORMAT_FAMILY_Max	= 2147483647L
    } 	CHAR_FORMAT_FAMILY;

typedef 
enum _LAYOUT_MOVE_UNIT
    {	LAYOUT_MOVE_UNIT_PreviousLine	= 1,
	LAYOUT_MOVE_UNIT_NextLine	= 2,
	LAYOUT_MOVE_UNIT_CurrentLineStart	= 3,
	LAYOUT_MOVE_UNIT_CurrentLineEnd	= 4,
	LAYOUT_MOVE_UNIT_NextLineStart	= 5,
	LAYOUT_MOVE_UNIT_PreviousLineEnd	= 6,
	LAYOUT_MOVE_UNIT_TopOfWindow	= 7,
	LAYOUT_MOVE_UNIT_BottomOfWindow	= 8,
	LAYOUT_MOVE_UNIT_OuterLineStart	= 9,
	LAYOUT_MOVE_UNIT_OuterLineEnd	= 10,
	LAYOUT_MOVE_UNIT_Max	= 2147483647L
    } 	LAYOUT_MOVE_UNIT;

typedef 
enum _CARET_GRAVITY
    {	CARET_GRAVITY_NoChange	= 0,
	CARET_GRAVITY_BeginningOfLine	= 1,
	CARET_GRAVITY_EndOfLine	= 2,
	CARET_GRAVITY_Max	= 2147483647L
    } 	CARET_GRAVITY;

typedef 
enum _CARET_VISIBILITY
    {	CARET_TYPE_Hide	= 0,
	CARET_TYPE_Show	= 1,
	CARET_VISIBILITY_Max	= 2147483647L
    } 	CARET_VISIBILITY;

typedef 
enum _POINTER_SCROLLPIN
    {	POINTER_SCROLLPIN_TopLeft	= 0,
	POINTER_SCROLLPIN_BottomRight	= 1,
	POINTER_SCROLLPIN_Minimal	= 2,
	POINTER_SCROLLPIN_Max	= 2147483647L
    } 	POINTER_SCROLLPIN;

typedef 
enum _ADORNER_HTI
    {	ADORNER_HTI_NONE	= 0,
	ADORNER_HTI_TOPBORDER	= 1,
	ADORNER_HTI_LEFTBORDER	= 2,
	ADORNER_HTI_BOTTOMBORDER	= 3,
	ADORNER_HTI_RIGHTBORDER	= 4,
	ADORNER_HTI_TOPLEFTHANDLE	= 5,
	ADORNER_HTI_LEFTHANDLE	= 6,
	ADORNER_HTI_TOPHANDLE	= 7,
	ADORNER_HTI_BOTTOMLEFTHANDLE	= 8,
	ADORNER_HTI_TOPRIGHTHANDLE	= 9,
	ADORNER_HTI_BOTTOMHANDLE	= 10,
	ADORNER_HTI_RIGHTHANDLE	= 11,
	ADORNER_HTI_BOTTOMRIGHTHANDLE	= 12,
	ADORNER_HTI_Max	= 2147483647L
    } 	ADORNER_HTI;

typedef 
enum _FILTER_DRAW_LAYERS
    {	FILTER_DRAW_BORDER	= 0x1,
	FILTER_DRAW_BACKGROUND	= 0x2,
	FILTER_DRAW_CONTENT	= 0x4,
	FILTER_DRAW_ALLLAYERS	= 0x7,
	FILTER_DRAW_LAYERS_Max	= 2147483647L
    } 	FILTER_DRAW_LAYERS;

typedef 
enum _FILTER_FLAGS
    {	FILTER_FLAGS_PAGETRANSITION	= 0x1,
	FILTER_FLAGS_Max	= 2147483647L
    } 	FILTER_FLAGS;

typedef 
enum _htmlDocumentMode
    {	htmlDocumentModeNotSet	= 0,
	htmlDocumentModeIE5	= 50000,
	htmlDocumentModeIE7	= 70000,
	htmlDocumentModeIE8	= 80000,
	htmlDocumentMode_Max	= 2147483647L
    } 	htmlDocumentMode;

typedef struct _HTMLPtrDispInfoRec
    {
    DWORD dwSize;
    LONG lBaseline;
    LONG lXPosition;
    LONG lLineHeight;
    LONG lTextHeight;
    LONG lDescent;
    LONG lTextDescent;
    BOOL fRTLLine;
    BOOL fRTLFlow;
    BOOL fAligned;
    BOOL fHasNestedRunOwner;
    } 	HTMLPtrDispInfoRec;




EXTERN_C const IID LIBID_MSHTMLINTERNAL;

#ifndef __ISelectionObject2_INTERFACE_DEFINED__
#define __ISelectionObject2_INTERFACE_DEFINED__

/* interface ISelectionObject2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISelectionObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fc-98b5-11cf-bb82-00aa00bdce0b")
    ISelectionObject2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ ISegmentList *pISegmentList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPointerInSelection( 
            /* [in] */ IDisplayPointer *pIDispPointer,
            /* [out] */ BOOL *pfPointerInSelection,
            /* [in] */ POINT *pptGlobal,
            /* [in] */ IHTMLElement *pIElementOver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmptySelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyAllSelection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionObject2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionObject2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            ISelectionObject2 * This,
            /* [in] */ ISegmentList *pISegmentList);
        
        HRESULT ( STDMETHODCALLTYPE *IsPointerInSelection )( 
            ISelectionObject2 * This,
            /* [in] */ IDisplayPointer *pIDispPointer,
            /* [out] */ BOOL *pfPointerInSelection,
            /* [in] */ POINT *pptGlobal,
            /* [in] */ IHTMLElement *pIElementOver);
        
        HRESULT ( STDMETHODCALLTYPE *EmptySelection )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySelection )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyAllSelection )( 
            ISelectionObject2 * This);
        
        END_INTERFACE
    } ISelectionObject2Vtbl;

    interface ISelectionObject2
    {
        CONST_VTBL struct ISelectionObject2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionObject2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectionObject2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectionObject2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectionObject2_Select(This,pISegmentList)	\
    ( (This)->lpVtbl -> Select(This,pISegmentList) ) 

#define ISelectionObject2_IsPointerInSelection(This,pIDispPointer,pfPointerInSelection,pptGlobal,pIElementOver)	\
    ( (This)->lpVtbl -> IsPointerInSelection(This,pIDispPointer,pfPointerInSelection,pptGlobal,pIElementOver) ) 

#define ISelectionObject2_EmptySelection(This)	\
    ( (This)->lpVtbl -> EmptySelection(This) ) 

#define ISelectionObject2_DestroySelection(This)	\
    ( (This)->lpVtbl -> DestroySelection(This) ) 

#define ISelectionObject2_DestroyAllSelection(This)	\
    ( (This)->lpVtbl -> DestroyAllSelection(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectionObject2_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditor_INTERFACE_DEFINED__
#define __IHTMLEditor_INTERFACE_DEFINED__

/* interface IHTMLEditor */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fa-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pIDocument,
            /* [in] */ IUnknown *pIContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ DWORD dword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommandTarget( 
            /* [in] */ IUnknown *pContext,
            /* [out][in] */ IUnknown **ppUnkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementToTabFrom( 
            /* [in] */ BOOL fForward,
            /* [out][in] */ IHTMLElement **ppElement,
            /* [out][in] */ BOOL *pfFindNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEditContextUIActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateIMEComposition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreHandleEvent )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *PostHandleEvent )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IHTMLEditor * This,
            /* [in] */ IUnknown *pIDocument,
            /* [in] */ IUnknown *pIContainer);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IHTMLEditor * This,
            /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ DWORD dword);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandTarget )( 
            IHTMLEditor * This,
            /* [in] */ IUnknown *pContext,
            /* [out][in] */ IUnknown **ppUnkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementToTabFrom )( 
            IHTMLEditor * This,
            /* [in] */ BOOL fForward,
            /* [out][in] */ IHTMLElement **ppElement,
            /* [out][in] */ BOOL *pfFindNext);
        
        HRESULT ( STDMETHODCALLTYPE *IsEditContextUIActive )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateIMEComposition )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IHTMLEditor * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IHTMLEditorVtbl;

    interface IHTMLEditor
    {
        CONST_VTBL struct IHTMLEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLEditor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLEditor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLEditor_PreHandleEvent(This,inEvtDispId,pIEventObj)	\
    ( (This)->lpVtbl -> PreHandleEvent(This,inEvtDispId,pIEventObj) ) 

#define IHTMLEditor_PostHandleEvent(This,inEvtDispId,pIEventObj)	\
    ( (This)->lpVtbl -> PostHandleEvent(This,inEvtDispId,pIEventObj) ) 

#define IHTMLEditor_TranslateAccelerator(This,inEvtDispId,pIEventObj)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,inEvtDispId,pIEventObj) ) 

#define IHTMLEditor_Initialize(This,pIDocument,pIContainer)	\
    ( (This)->lpVtbl -> Initialize(This,pIDocument,pIContainer) ) 

#define IHTMLEditor_Notify(This,eSelectionNotification,pUnknown,dword)	\
    ( (This)->lpVtbl -> Notify(This,eSelectionNotification,pUnknown,dword) ) 

#define IHTMLEditor_GetCommandTarget(This,pContext,ppUnkTarget)	\
    ( (This)->lpVtbl -> GetCommandTarget(This,pContext,ppUnkTarget) ) 

#define IHTMLEditor_GetElementToTabFrom(This,fForward,ppElement,pfFindNext)	\
    ( (This)->lpVtbl -> GetElementToTabFrom(This,fForward,ppElement,pfFindNext) ) 

#define IHTMLEditor_IsEditContextUIActive(This)	\
    ( (This)->lpVtbl -> IsEditContextUIActive(This) ) 

#define IHTMLEditor_TerminateIMEComposition(This)	\
    ( (This)->lpVtbl -> TerminateIMEComposition(This) ) 

#define IHTMLEditor_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLEditor_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6dc-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SuperNavigate( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPendingUrl( 
            /* [out] */ LPOLESTR *pstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPICSTarget( 
            /* [in] */ IOleCommandTarget *pctPICS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PICSComplete( 
            /* [in] */ BOOL fApproved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindWindowByName( 
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressBarUrl( 
            /* [out] */ BSTR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuperNavigate )( 
            IHTMLPrivateWindow * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingUrl )( 
            IHTMLPrivateWindow * This,
            /* [out] */ LPOLESTR *pstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetPICSTarget )( 
            IHTMLPrivateWindow * This,
            /* [in] */ IOleCommandTarget *pctPICS);
        
        HRESULT ( STDMETHODCALLTYPE *PICSComplete )( 
            IHTMLPrivateWindow * This,
            /* [in] */ BOOL fApproved);
        
        HRESULT ( STDMETHODCALLTYPE *FindWindowByName )( 
            IHTMLPrivateWindow * This,
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressBarUrl )( 
            IHTMLPrivateWindow * This,
            /* [out] */ BSTR *pbstrURL);
        
        END_INTERFACE
    } IHTMLPrivateWindowVtbl;

    interface IHTMLPrivateWindow
    {
        CONST_VTBL struct IHTMLPrivateWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLPrivateWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLPrivateWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLPrivateWindow_SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)	\
    ( (This)->lpVtbl -> SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags) ) 

#define IHTMLPrivateWindow_GetPendingUrl(This,pstrURL)	\
    ( (This)->lpVtbl -> GetPendingUrl(This,pstrURL) ) 

#define IHTMLPrivateWindow_SetPICSTarget(This,pctPICS)	\
    ( (This)->lpVtbl -> SetPICSTarget(This,pctPICS) ) 

#define IHTMLPrivateWindow_PICSComplete(This,fApproved)	\
    ( (This)->lpVtbl -> PICSComplete(This,fApproved) ) 

#define IHTMLPrivateWindow_FindWindowByName(This,pstrTargeName,ppWindow)	\
    ( (This)->lpVtbl -> FindWindowByName(This,pstrTargeName,ppWindow) ) 

#define IHTMLPrivateWindow_GetAddressBarUrl(This,pbstrURL)	\
    ( (This)->lpVtbl -> GetAddressBarUrl(This,pbstrURL) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLPrivateWindow_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow2_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow2_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30510410-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NavigateEx( 
            /* [in] */ IUri *pUri,
            /* [in] */ IUri *pUnencodedUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags,
            /* [in] */ IDispatch *pDispCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInnerWindowUnknown( 
            /* [out][in] */ IUnknown **ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx )( 
            IHTMLPrivateWindow2 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ IUri *pUnencodedUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags,
            /* [in] */ IDispatch *pDispCaller);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerWindowUnknown )( 
            IHTMLPrivateWindow2 * This,
            /* [out][in] */ IUnknown **ppUnknown);
        
        END_INTERFACE
    } IHTMLPrivateWindow2Vtbl;

    interface IHTMLPrivateWindow2
    {
        CONST_VTBL struct IHTMLPrivateWindow2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLPrivateWindow2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLPrivateWindow2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLPrivateWindow2_NavigateEx(This,pUri,pUnencodedUri,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags,pDispCaller)	\
    ( (This)->lpVtbl -> NavigateEx(This,pUri,pUnencodedUri,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags,pDispCaller) ) 

#define IHTMLPrivateWindow2_GetInnerWindowUnknown(This,ppUnknown)	\
    ( (This)->lpVtbl -> GetInnerWindowUnknown(This,ppUnknown) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLPrivateWindow2_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow3_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow3_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow3 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30510411-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow3 : public IHTMLPrivateWindow2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenEx( 
            /* [in] */ IUri *pUri,
            /* [in] */ BSTR urlContext,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [in] */ IDispatch *pDispCaller,
            /* [out] */ IHTMLWindow2 **pomWindowResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateEx2( 
            /* [in] */ BSTR bstrExpandedUri,
            /* [in] */ BSTR bstrOriginalUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrSubReferer,
            /* [in] */ BSTR bstrExtraHeaders,
            /* [in] */ BSTR bstrAcceptLanguage,
            /* [in] */ BSTR bstrUserAgent,
            /* [in] */ VARIANT varPostData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwBindf,
            /* [in] */ DWORD dwCodePage,
            /* [in] */ DWORD dwLoadf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ IUri *pUnencodedUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags,
            /* [in] */ IDispatch *pDispCaller);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerWindowUnknown )( 
            IHTMLPrivateWindow3 * This,
            /* [out][in] */ IUnknown **ppUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *OpenEx )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ BSTR urlContext,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [in] */ IDispatch *pDispCaller,
            /* [out] */ IHTMLWindow2 **pomWindowResult);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx2 )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ BSTR bstrExpandedUri,
            /* [in] */ BSTR bstrOriginalUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrSubReferer,
            /* [in] */ BSTR bstrExtraHeaders,
            /* [in] */ BSTR bstrAcceptLanguage,
            /* [in] */ BSTR bstrUserAgent,
            /* [in] */ VARIANT varPostData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwBindf,
            /* [in] */ DWORD dwCodePage,
            /* [in] */ DWORD dwLoadf);
        
        END_INTERFACE
    } IHTMLPrivateWindow3Vtbl;

    interface IHTMLPrivateWindow3
    {
        CONST_VTBL struct IHTMLPrivateWindow3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLPrivateWindow3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLPrivateWindow3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLPrivateWindow3_NavigateEx(This,pUri,pUnencodedUri,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags,pDispCaller)	\
    ( (This)->lpVtbl -> NavigateEx(This,pUri,pUnencodedUri,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags,pDispCaller) ) 

#define IHTMLPrivateWindow3_GetInnerWindowUnknown(This,ppUnknown)	\
    ( (This)->lpVtbl -> GetInnerWindowUnknown(This,ppUnknown) ) 


#define IHTMLPrivateWindow3_OpenEx(This,pUri,urlContext,name,features,replace,pDispCaller,pomWindowResult)	\
    ( (This)->lpVtbl -> OpenEx(This,pUri,urlContext,name,features,replace,pDispCaller,pomWindowResult) ) 

#define IHTMLPrivateWindow3_NavigateEx2(This,bstrExpandedUri,bstrOriginalUri,bstrLocation,bstrSubReferer,bstrExtraHeaders,bstrAcceptLanguage,bstrUserAgent,varPostData,dwFlags,dwBindf,dwCodePage,dwLoadf)	\
    ( (This)->lpVtbl -> NavigateEx2(This,bstrExpandedUri,bstrOriginalUri,bstrLocation,bstrSubReferer,bstrExtraHeaders,bstrAcceptLanguage,bstrUserAgent,varPostData,dwFlags,dwBindf,dwCodePage,dwLoadf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLPrivateWindow3_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow4_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow4_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow4 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f594-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow4 : public IHTMLPrivateWindow
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SuperNavigate2( 
            /* [in] */ IUri *pUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuperNavigate3( 
            /* [in] */ IUri *pUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ IStream *pstmDwnPost,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuperNavigate )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingUrl )( 
            IHTMLPrivateWindow4 * This,
            /* [out] */ LPOLESTR *pstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetPICSTarget )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ IOleCommandTarget *pctPICS);
        
        HRESULT ( STDMETHODCALLTYPE *PICSComplete )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ BOOL fApproved);
        
        HRESULT ( STDMETHODCALLTYPE *FindWindowByName )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressBarUrl )( 
            IHTMLPrivateWindow4 * This,
            /* [out] */ BSTR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *SuperNavigate2 )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SuperNavigate3 )( 
            IHTMLPrivateWindow4 * This,
            /* [in] */ IUri *pUri,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ IStream *pstmDwnPost,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IHTMLPrivateWindow4Vtbl;

    interface IHTMLPrivateWindow4
    {
        CONST_VTBL struct IHTMLPrivateWindow4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLPrivateWindow4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLPrivateWindow4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLPrivateWindow4_SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)	\
    ( (This)->lpVtbl -> SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags) ) 

#define IHTMLPrivateWindow4_GetPendingUrl(This,pstrURL)	\
    ( (This)->lpVtbl -> GetPendingUrl(This,pstrURL) ) 

#define IHTMLPrivateWindow4_SetPICSTarget(This,pctPICS)	\
    ( (This)->lpVtbl -> SetPICSTarget(This,pctPICS) ) 

#define IHTMLPrivateWindow4_PICSComplete(This,fApproved)	\
    ( (This)->lpVtbl -> PICSComplete(This,fApproved) ) 

#define IHTMLPrivateWindow4_FindWindowByName(This,pstrTargeName,ppWindow)	\
    ( (This)->lpVtbl -> FindWindowByName(This,pstrTargeName,ppWindow) ) 

#define IHTMLPrivateWindow4_GetAddressBarUrl(This,pbstrURL)	\
    ( (This)->lpVtbl -> GetAddressBarUrl(This,pbstrURL) ) 


#define IHTMLPrivateWindow4_SuperNavigate2(This,pUri,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)	\
    ( (This)->lpVtbl -> SuperNavigate2(This,pUri,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags) ) 

#define IHTMLPrivateWindow4_SuperNavigate3(This,pUri,bstrLocation,bstrShortcut,bstrFrameName,pstmDwnPost,dwFlags)	\
    ( (This)->lpVtbl -> SuperNavigate3(This,pUri,bstrLocation,bstrShortcut,bstrFrameName,pstmDwnPost,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLPrivateWindow4_INTERFACE_DEFINED__ */


#ifndef __ISubDivisionProvider_INTERFACE_DEFINED__
#define __ISubDivisionProvider_INTERFACE_DEFINED__

/* interface ISubDivisionProvider */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISubDivisionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4d2-98b5-11cf-bb82-00aa00bdce0b")
    ISubDivisionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionCount( 
            /* [out][retval] */ LONG *pcSubDivision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionTabs( 
            /* [in] */ LONG cTabs,
            /* [out][retval] */ LONG *pSubDivisionTabs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubDivisionFromPt( 
            /* [in] */ POINT pt,
            /* [out][retval] */ LONG *piSubDivision) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISubDivisionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubDivisionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubDivisionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubDivisionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionCount )( 
            ISubDivisionProvider * This,
            /* [out][retval] */ LONG *pcSubDivision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionTabs )( 
            ISubDivisionProvider * This,
            /* [in] */ LONG cTabs,
            /* [out][retval] */ LONG *pSubDivisionTabs);
        
        HRESULT ( STDMETHODCALLTYPE *SubDivisionFromPt )( 
            ISubDivisionProvider * This,
            /* [in] */ POINT pt,
            /* [out][retval] */ LONG *piSubDivision);
        
        END_INTERFACE
    } ISubDivisionProviderVtbl;

    interface ISubDivisionProvider
    {
        CONST_VTBL struct ISubDivisionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubDivisionProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISubDivisionProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISubDivisionProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISubDivisionProvider_GetSubDivisionCount(This,pcSubDivision)	\
    ( (This)->lpVtbl -> GetSubDivisionCount(This,pcSubDivision) ) 

#define ISubDivisionProvider_GetSubDivisionTabs(This,cTabs,pSubDivisionTabs)	\
    ( (This)->lpVtbl -> GetSubDivisionTabs(This,cTabs,pSubDivisionTabs) ) 

#define ISubDivisionProvider_SubDivisionFromPt(This,pt,piSubDivision)	\
    ( (This)->lpVtbl -> SubDivisionFromPt(This,pt,piSubDivision) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISubDivisionProvider_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorUI_INTERFACE_DEFINED__
#define __IElementBehaviorUI_INTERFACE_DEFINED__

/* interface IElementBehaviorUI */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4bf-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnReceiveFocus( 
            /* [in] */ BOOL fFocus,
            /* [in] */ LONG lSubDivision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionProvider( 
            /* [out][retval] */ ISubDivisionProvider **ppProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanTakeFocus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnReceiveFocus )( 
            IElementBehaviorUI * This,
            /* [in] */ BOOL fFocus,
            /* [in] */ LONG lSubDivision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionProvider )( 
            IElementBehaviorUI * This,
            /* [out][retval] */ ISubDivisionProvider **ppProvider);
        
        HRESULT ( STDMETHODCALLTYPE *CanTakeFocus )( 
            IElementBehaviorUI * This);
        
        END_INTERFACE
    } IElementBehaviorUIVtbl;

    interface IElementBehaviorUI
    {
        CONST_VTBL struct IElementBehaviorUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IElementBehaviorUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IElementBehaviorUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IElementBehaviorUI_OnReceiveFocus(This,fFocus,lSubDivision)	\
    ( (This)->lpVtbl -> OnReceiveFocus(This,fFocus,lSubDivision) ) 

#define IElementBehaviorUI_GetSubDivisionProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetSubDivisionProvider(This,ppProvider) ) 

#define IElementBehaviorUI_CanTakeFocus(This)	\
    ( (This)->lpVtbl -> CanTakeFocus(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IElementBehaviorUI_INTERFACE_DEFINED__ */


#ifndef __IElementAdorner_INTERFACE_DEFINED__
#define __IElementAdorner_INTERFACE_DEFINED__

/* interface IElementAdorner */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementAdorner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f607-98b5-11cf-bb82-00aa00bdce0b")
    IElementAdorner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPoint( 
            /* [in] */ POINT *pt,
            /* [in] */ LPRECT prc,
            /* [out][in] */ BOOL *fResult,
            /* [out][in] */ ADORNER_HTI *peAdornerHTI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [in] */ SIZE *pSizeElem,
            /* [in] */ SIZE *pSizeAdorn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [in] */ POINT *pPosElem,
            /* [in] */ POINT *pPosAdorn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPositionSet( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementAdornerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementAdorner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementAdorner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementAdorner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IElementAdorner * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prc);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPoint )( 
            IElementAdorner * This,
            /* [in] */ POINT *pt,
            /* [in] */ LPRECT prc,
            /* [out][in] */ BOOL *fResult,
            /* [out][in] */ ADORNER_HTI *peAdornerHTI);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IElementAdorner * This,
            /* [in] */ SIZE *pSizeElem,
            /* [in] */ SIZE *pSizeAdorn);
        
        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
            IElementAdorner * This,
            /* [in] */ POINT *pPosElem,
            /* [in] */ POINT *pPosAdorn);
        
        HRESULT ( STDMETHODCALLTYPE *OnPositionSet )( 
            IElementAdorner * This);
        
        END_INTERFACE
    } IElementAdornerVtbl;

    interface IElementAdorner
    {
        CONST_VTBL struct IElementAdornerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementAdorner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IElementAdorner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IElementAdorner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IElementAdorner_Draw(This,hdc,prc)	\
    ( (This)->lpVtbl -> Draw(This,hdc,prc) ) 

#define IElementAdorner_HitTestPoint(This,pt,prc,fResult,peAdornerHTI)	\
    ( (This)->lpVtbl -> HitTestPoint(This,pt,prc,fResult,peAdornerHTI) ) 

#define IElementAdorner_GetSize(This,pSizeElem,pSizeAdorn)	\
    ( (This)->lpVtbl -> GetSize(This,pSizeElem,pSizeAdorn) ) 

#define IElementAdorner_GetPosition(This,pPosElem,pPosAdorn)	\
    ( (This)->lpVtbl -> GetPosition(This,pPosElem,pPosAdorn) ) 

#define IElementAdorner_OnPositionSet(This)	\
    ( (This)->lpVtbl -> OnPositionSet(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IElementAdorner_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditingServices_INTERFACE_DEFINED__
#define __IHTMLEditingServices_INTERFACE_DEFINED__

/* interface IHTMLEditingServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditingServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fb-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditingServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BOOL fAdjustPointers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Paste( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BSTR bstrText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PasteFromClipboard( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ IDataObject *pDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LaunderSpaces( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSanitizedText( 
            /* [in] */ IMarkupPointer *InsertHere,
            /* [in] */ OLECHAR *pstrText,
            /* [in] */ LONG cChInput,
            /* [in] */ BOOL fDataBinding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UrlAutoDetectCurrentWord( 
            /* [in] */ IMarkupPointer *pWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UrlAutoDetectRange( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShouldUpdateAnchorText( 
            /* [in] */ OLECHAR *pstrHref,
            /* [in] */ OLECHAR *pstrAnchorText,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdjustPointerForInsert( 
            /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
            /* [in] */ BOOL fFurtherInDocument,
            /* [in] */ IMarkupPointer *pConstraintStart,
            /* [in] */ IMarkupPointer *pConstraintEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindSiteSelectableElement( 
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerEnd,
            /* [in] */ IHTMLElement **ppIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementSiteSelectable( 
            /* [in] */ IHTMLElement *pIHTMLElement,
            /* [out] */ IHTMLElement **ppIElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementUIActivatable( 
            /* [in] */ IHTMLElement *pIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementAtomic( 
            /* [in] */ IHTMLElement *pIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PositionPointersInMaster( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditingServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditingServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditingServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditingServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BOOL fAdjustPointers);
        
        HRESULT ( STDMETHODCALLTYPE *Paste )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BSTR bstrText);
        
        HRESULT ( STDMETHODCALLTYPE *PasteFromClipboard )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ IDataObject *pDO);
        
        HRESULT ( STDMETHODCALLTYPE *LaunderSpaces )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSanitizedText )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *InsertHere,
            /* [in] */ OLECHAR *pstrText,
            /* [in] */ LONG cChInput,
            /* [in] */ BOOL fDataBinding);
        
        HRESULT ( STDMETHODCALLTYPE *UrlAutoDetectCurrentWord )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pWord);
        
        HRESULT ( STDMETHODCALLTYPE *UrlAutoDetectRange )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldUpdateAnchorText )( 
            IHTMLEditingServices * This,
            /* [in] */ OLECHAR *pstrHref,
            /* [in] */ OLECHAR *pstrAnchorText,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustPointerForInsert )( 
            IHTMLEditingServices * This,
            /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
            /* [in] */ BOOL fFurtherInDocument,
            /* [in] */ IMarkupPointer *pConstraintStart,
            /* [in] */ IMarkupPointer *pConstraintEnd);
        
        HRESULT ( STDMETHODCALLTYPE *FindSiteSelectableElement )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerEnd,
            /* [in] */ IHTMLElement **ppIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementSiteSelectable )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement,
            /* [out] */ IHTMLElement **ppIElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementUIActivatable )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementAtomic )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *PositionPointersInMaster )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd);
        
        END_INTERFACE
    } IHTMLEditingServicesVtbl;

    interface IHTMLEditingServices
    {
        CONST_VTBL struct IHTMLEditingServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditingServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLEditingServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLEditingServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLEditingServices_Delete(This,pStart,pEnd,fAdjustPointers)	\
    ( (This)->lpVtbl -> Delete(This,pStart,pEnd,fAdjustPointers) ) 

#define IHTMLEditingServices_Paste(This,pStart,pEnd,bstrText)	\
    ( (This)->lpVtbl -> Paste(This,pStart,pEnd,bstrText) ) 

#define IHTMLEditingServices_PasteFromClipboard(This,pStart,pEnd,pDO)	\
    ( (This)->lpVtbl -> PasteFromClipboard(This,pStart,pEnd,pDO) ) 

#define IHTMLEditingServices_LaunderSpaces(This,pStart,pEnd)	\
    ( (This)->lpVtbl -> LaunderSpaces(This,pStart,pEnd) ) 

#define IHTMLEditingServices_InsertSanitizedText(This,InsertHere,pstrText,cChInput,fDataBinding)	\
    ( (This)->lpVtbl -> InsertSanitizedText(This,InsertHere,pstrText,cChInput,fDataBinding) ) 

#define IHTMLEditingServices_UrlAutoDetectCurrentWord(This,pWord)	\
    ( (This)->lpVtbl -> UrlAutoDetectCurrentWord(This,pWord) ) 

#define IHTMLEditingServices_UrlAutoDetectRange(This,pStart,pEnd)	\
    ( (This)->lpVtbl -> UrlAutoDetectRange(This,pStart,pEnd) ) 

#define IHTMLEditingServices_ShouldUpdateAnchorText(This,pstrHref,pstrAnchorText,pfResult)	\
    ( (This)->lpVtbl -> ShouldUpdateAnchorText(This,pstrHref,pstrAnchorText,pfResult) ) 

#define IHTMLEditingServices_AdjustPointerForInsert(This,pDispWhereIThinkIAm,fFurtherInDocument,pConstraintStart,pConstraintEnd)	\
    ( (This)->lpVtbl -> AdjustPointerForInsert(This,pDispWhereIThinkIAm,fFurtherInDocument,pConstraintStart,pConstraintEnd) ) 

#define IHTMLEditingServices_FindSiteSelectableElement(This,pPointerStart,pPointerEnd,ppIHTMLElement)	\
    ( (This)->lpVtbl -> FindSiteSelectableElement(This,pPointerStart,pPointerEnd,ppIHTMLElement) ) 

#define IHTMLEditingServices_IsElementSiteSelectable(This,pIHTMLElement,ppIElement)	\
    ( (This)->lpVtbl -> IsElementSiteSelectable(This,pIHTMLElement,ppIElement) ) 

#define IHTMLEditingServices_IsElementUIActivatable(This,pIHTMLElement)	\
    ( (This)->lpVtbl -> IsElementUIActivatable(This,pIHTMLElement) ) 

#define IHTMLEditingServices_IsElementAtomic(This,pIHTMLElement)	\
    ( (This)->lpVtbl -> IsElementAtomic(This,pIHTMLElement) ) 

#define IHTMLEditingServices_PositionPointersInMaster(This,pIElement,pIStart,pIEnd)	\
    ( (This)->lpVtbl -> PositionPointersInMaster(This,pIElement,pIStart,pIEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLEditingServices_INTERFACE_DEFINED__ */


#ifndef __IEditDebugServices_INTERFACE_DEFINED__
#define __IEditDebugServices_INTERFACE_DEFINED__

/* interface IEditDebugServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IEditDebugServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f60b-98b5-11cf-bb82-00aa00bdce0b")
    IEditDebugServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCp( 
            /* [in] */ IMarkupPointer *pIPointer,
            /* [out] */ long *pcp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugName( 
            /* [in] */ IMarkupPointer *pIPointer,
            /* [in] */ LPCTSTR strDbgName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayPointerDebugName( 
            /* [in] */ IDisplayPointer *pDispPointer,
            /* [in] */ LPCTSTR strDbgName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DumpTree( 
            /* [in] */ IMarkupPointer *pIPointer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LinesInElement( 
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ long *piLines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FontsOnLine( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ long iLine,
            /* [out] */ BSTR *pbstrFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixel( 
            /* [in] */ long X,
            /* [in] */ long Y,
            /* [out] */ long *piColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingBckgrnRecalc( 
            /* [out] */ BOOL *pfUsingBckgrnRecalc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEncodingAutoSelect( 
            /* [out] */ BOOL *pfEncodingAutoSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableEncodingAutoSelect( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingTableIncRecalc( 
            /* [out] */ BOOL *pfUsingTableIncRecalc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEditDebugServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEditDebugServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEditDebugServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEditDebugServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCp )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer,
            /* [out] */ long *pcp);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugName )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer,
            /* [in] */ LPCTSTR strDbgName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayPointerDebugName )( 
            IEditDebugServices * This,
            /* [in] */ IDisplayPointer *pDispPointer,
            /* [in] */ LPCTSTR strDbgName);
        
        HRESULT ( STDMETHODCALLTYPE *DumpTree )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer);
        
        HRESULT ( STDMETHODCALLTYPE *LinesInElement )( 
            IEditDebugServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ long *piLines);
        
        HRESULT ( STDMETHODCALLTYPE *FontsOnLine )( 
            IEditDebugServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ long iLine,
            /* [out] */ BSTR *pbstrFonts);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixel )( 
            IEditDebugServices * This,
            /* [in] */ long X,
            /* [in] */ long Y,
            /* [out] */ long *piColor);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingBckgrnRecalc )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfUsingBckgrnRecalc);
        
        HRESULT ( STDMETHODCALLTYPE *IsEncodingAutoSelect )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfEncodingAutoSelect);
        
        HRESULT ( STDMETHODCALLTYPE *EnableEncodingAutoSelect )( 
            IEditDebugServices * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTableIncRecalc )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfUsingTableIncRecalc);
        
        END_INTERFACE
    } IEditDebugServicesVtbl;

    interface IEditDebugServices
    {
        CONST_VTBL struct IEditDebugServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEditDebugServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEditDebugServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEditDebugServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEditDebugServices_GetCp(This,pIPointer,pcp)	\
    ( (This)->lpVtbl -> GetCp(This,pIPointer,pcp) ) 

#define IEditDebugServices_SetDebugName(This,pIPointer,strDbgName)	\
    ( (This)->lpVtbl -> SetDebugName(This,pIPointer,strDbgName) ) 

#define IEditDebugServices_SetDisplayPointerDebugName(This,pDispPointer,strDbgName)	\
    ( (This)->lpVtbl -> SetDisplayPointerDebugName(This,pDispPointer,strDbgName) ) 

#define IEditDebugServices_DumpTree(This,pIPointer)	\
    ( (This)->lpVtbl -> DumpTree(This,pIPointer) ) 

#define IEditDebugServices_LinesInElement(This,pIElement,piLines)	\
    ( (This)->lpVtbl -> LinesInElement(This,pIElement,piLines) ) 

#define IEditDebugServices_FontsOnLine(This,pIElement,iLine,pbstrFonts)	\
    ( (This)->lpVtbl -> FontsOnLine(This,pIElement,iLine,pbstrFonts) ) 

#define IEditDebugServices_GetPixel(This,X,Y,piColor)	\
    ( (This)->lpVtbl -> GetPixel(This,X,Y,piColor) ) 

#define IEditDebugServices_IsUsingBckgrnRecalc(This,pfUsingBckgrnRecalc)	\
    ( (This)->lpVtbl -> IsUsingBckgrnRecalc(This,pfUsingBckgrnRecalc) ) 

#define IEditDebugServices_IsEncodingAutoSelect(This,pfEncodingAutoSelect)	\
    ( (This)->lpVtbl -> IsEncodingAutoSelect(This,pfEncodingAutoSelect) ) 

#define IEditDebugServices_EnableEncodingAutoSelect(This,fEnable)	\
    ( (This)->lpVtbl -> EnableEncodingAutoSelect(This,fEnable) ) 

#define IEditDebugServices_IsUsingTableIncRecalc(This,pfUsingTableIncRecalc)	\
    ( (This)->lpVtbl -> IsUsingTableIncRecalc(This,pfUsingTableIncRecalc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEditDebugServices_INTERFACE_DEFINED__ */


#ifndef __IDisplayTreeDumper_INTERFACE_DEFINED__
#define __IDisplayTreeDumper_INTERFACE_DEFINED__

/* interface IDisplayTreeDumper */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDisplayTreeDumper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30510415-98b5-11cf-bb82-00aa00bdce0b")
    IDisplayTreeDumper : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DumpDisplayTree( 
            /* [in] */ IStream *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDisplayTreeDumperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDisplayTreeDumper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDisplayTreeDumper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDisplayTreeDumper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDisplayTreeDumper * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDisplayTreeDumper * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDisplayTreeDumper * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDisplayTreeDumper * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *DumpDisplayTree )( 
            IDisplayTreeDumper * This,
            /* [in] */ IStream *pStream);
        
        END_INTERFACE
    } IDisplayTreeDumperVtbl;

    interface IDisplayTreeDumper
    {
        CONST_VTBL struct IDisplayTreeDumperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplayTreeDumper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDisplayTreeDumper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDisplayTreeDumper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDisplayTreeDumper_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDisplayTreeDumper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDisplayTreeDumper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDisplayTreeDumper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDisplayTreeDumper_DumpDisplayTree(This,pStream)	\
    ( (This)->lpVtbl -> DumpDisplayTree(This,pStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDisplayTreeDumper_INTERFACE_DEFINED__ */


#ifndef __IPrivacyServices_INTERFACE_DEFINED__
#define __IPrivacyServices_INTERFACE_DEFINED__

/* interface IPrivacyServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IPrivacyServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f84b-98b5-11cf-bb82-00aa00bdce0b")
    IPrivacyServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPrivacyInfoToList( 
            /* [in] */ LPOLESTR pstrUrl,
            /* [in] */ LPOLESTR pstrPolicyRef,
            /* [in] */ LPOLESTR pstrP3PHeader,
            /* [in] */ LONG dwReserved,
            /* [in] */ DWORD privacyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivacyServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivacyServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivacyServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivacyServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPrivacyInfoToList )( 
            IPrivacyServices * This,
            /* [in] */ LPOLESTR pstrUrl,
            /* [in] */ LPOLESTR pstrPolicyRef,
            /* [in] */ LPOLESTR pstrP3PHeader,
            /* [in] */ LONG dwReserved,
            /* [in] */ DWORD privacyFlags);
        
        END_INTERFACE
    } IPrivacyServicesVtbl;

    interface IPrivacyServices
    {
        CONST_VTBL struct IPrivacyServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivacyServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrivacyServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrivacyServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrivacyServices_AddPrivacyInfoToList(This,pstrUrl,pstrPolicyRef,pstrP3PHeader,dwReserved,privacyFlags)	\
    ( (This)->lpVtbl -> AddPrivacyInfoToList(This,pstrUrl,pstrPolicyRef,pstrP3PHeader,dwReserved,privacyFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPrivacyServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLFilterPainter_INTERFACE_DEFINED__
#define __IHTMLFilterPainter_INTERFACE_DEFINED__

/* interface IHTMLFilterPainter */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLFilterPainter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6de-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLFilterPainter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateRectUnfiltered( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgnUnfiltered( 
            /* [in] */ HRGN hrgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeElementVisibility( 
            /* [in] */ BOOL fVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLFilterPainterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLFilterPainter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLFilterPainter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLFilterPainter * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRectUnfiltered )( 
            IHTMLFilterPainter * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRgnUnfiltered )( 
            IHTMLFilterPainter * This,
            /* [in] */ HRGN hrgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeElementVisibility )( 
            IHTMLFilterPainter * This,
            /* [in] */ BOOL fVisible);
        
        END_INTERFACE
    } IHTMLFilterPainterVtbl;

    interface IHTMLFilterPainter
    {
        CONST_VTBL struct IHTMLFilterPainterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLFilterPainter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLFilterPainter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLFilterPainter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLFilterPainter_InvalidateRectUnfiltered(This,prcInvalid)	\
    ( (This)->lpVtbl -> InvalidateRectUnfiltered(This,prcInvalid) ) 

#define IHTMLFilterPainter_InvalidateRgnUnfiltered(This,hrgnInvalid)	\
    ( (This)->lpVtbl -> InvalidateRgnUnfiltered(This,hrgnInvalid) ) 

#define IHTMLFilterPainter_ChangeElementVisibility(This,fVisible)	\
    ( (This)->lpVtbl -> ChangeElementVisibility(This,fVisible) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLFilterPainter_INTERFACE_DEFINED__ */


#ifndef __IHTMLFilterPaintSite_INTERFACE_DEFINED__
#define __IHTMLFilterPaintSite_INTERFACE_DEFINED__

/* interface IHTMLFilterPaintSite */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLFilterPaintSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6d3-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLFilterPaintSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DrawUnfiltered( 
            /* [in] */ HDC hdc,
            /* [in] */ IUnknown *punkDrawObject,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawLayers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPointUnfiltered( 
            /* [in] */ POINT pt,
            /* [in] */ LONG lDrawLayers,
            /* [out][retval] */ BOOL *pbHit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRectFiltered( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgnFiltered( 
            /* [in] */ HRGN hrgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeFilterVisibility( 
            /* [in] */ BOOL fVisible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureViewForFilterSite( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            /* [out][retval] */ void **ppDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterFlags( 
            /* [out][retval] */ DWORD *nFlagVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLFilterPaintSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLFilterPaintSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLFilterPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawUnfiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ HDC hdc,
            /* [in] */ IUnknown *punkDrawObject,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawLayers);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPointUnfiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ POINT pt,
            /* [in] */ LONG lDrawLayers,
            /* [out][retval] */ BOOL *pbHit);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRectFiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRgnFiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ HRGN hrgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeFilterVisibility )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ BOOL fVisible);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureViewForFilterSite )( 
            IHTMLFilterPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IHTMLFilterPaintSite * This,
            /* [out][retval] */ void **ppDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterFlags )( 
            IHTMLFilterPaintSite * This,
            /* [out][retval] */ DWORD *nFlagVal);
        
        END_INTERFACE
    } IHTMLFilterPaintSiteVtbl;

    interface IHTMLFilterPaintSite
    {
        CONST_VTBL struct IHTMLFilterPaintSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLFilterPaintSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHTMLFilterPaintSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHTMLFilterPaintSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHTMLFilterPaintSite_DrawUnfiltered(This,hdc,punkDrawObject,rcBounds,rcUpdate,lDrawLayers)	\
    ( (This)->lpVtbl -> DrawUnfiltered(This,hdc,punkDrawObject,rcBounds,rcUpdate,lDrawLayers) ) 

#define IHTMLFilterPaintSite_HitTestPointUnfiltered(This,pt,lDrawLayers,pbHit)	\
    ( (This)->lpVtbl -> HitTestPointUnfiltered(This,pt,lDrawLayers,pbHit) ) 

#define IHTMLFilterPaintSite_InvalidateRectFiltered(This,prcInvalid)	\
    ( (This)->lpVtbl -> InvalidateRectFiltered(This,prcInvalid) ) 

#define IHTMLFilterPaintSite_InvalidateRgnFiltered(This,hrgnInvalid)	\
    ( (This)->lpVtbl -> InvalidateRgnFiltered(This,hrgnInvalid) ) 

#define IHTMLFilterPaintSite_ChangeFilterVisibility(This,fVisible)	\
    ( (This)->lpVtbl -> ChangeFilterVisibility(This,fVisible) ) 

#define IHTMLFilterPaintSite_EnsureViewForFilterSite(This)	\
    ( (This)->lpVtbl -> EnsureViewForFilterSite(This) ) 

#define IHTMLFilterPaintSite_GetDirectDraw(This,ppDirectDraw)	\
    ( (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw) ) 

#define IHTMLFilterPaintSite_GetFilterFlags(This,nFlagVal)	\
    ( (This)->lpVtbl -> GetFilterFlags(This,nFlagVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHTMLFilterPaintSite_INTERFACE_DEFINED__ */


#ifndef __IElementNamespacePrivate_INTERFACE_DEFINED__
#define __IElementNamespacePrivate_INTERFACE_DEFINED__

/* interface IElementNamespacePrivate */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespacePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7ff-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespacePrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTagPrivate( 
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrBaseTagName,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespacePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespacePrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespacePrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespacePrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTagPrivate )( 
            IElementNamespacePrivate * This,
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrBaseTagName,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IElementNamespacePrivateVtbl;

    interface IElementNamespacePrivate
    {
        CONST_VTBL struct IElementNamespacePrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespacePrivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IElementNamespacePrivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IElementNamespacePrivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IElementNamespacePrivate_AddTagPrivate(This,bstrTagName,bstrBaseTagName,lFlags)	\
    ( (This)->lpVtbl -> AddTagPrivate(This,bstrTagName,bstrBaseTagName,lFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IElementNamespacePrivate_INTERFACE_DEFINED__ */


#ifndef __IHttpHeaderInfo_INTERFACE_DEFINED__
#define __IHttpHeaderInfo_INTERFACE_DEFINED__

/* interface IHttpHeaderInfo */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHttpHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B9C155B-19BF-434c-9968-A4875AEAD66A")
    IHttpHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetExtraHeaders( 
            /* [in] */ LPCWSTR pszSinkSpecificHeaders,
            /* [out] */ LPWSTR *ppszExtraHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAcceptHeader( 
            /* [out] */ LPWSTR *ppszAcceptHeader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpHeaderInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpHeaderInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpHeaderInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtraHeaders )( 
            IHttpHeaderInfo * This,
            /* [in] */ LPCWSTR pszSinkSpecificHeaders,
            /* [out] */ LPWSTR *ppszExtraHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetAcceptHeader )( 
            IHttpHeaderInfo * This,
            /* [out] */ LPWSTR *ppszAcceptHeader);
        
        END_INTERFACE
    } IHttpHeaderInfoVtbl;

    interface IHttpHeaderInfo
    {
        CONST_VTBL struct IHttpHeaderInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpHeaderInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpHeaderInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpHeaderInfo_SetExtraHeaders(This,pszSinkSpecificHeaders,ppszExtraHeaders)	\
    ( (This)->lpVtbl -> SetExtraHeaders(This,pszSinkSpecificHeaders,ppszExtraHeaders) ) 

#define IHttpHeaderInfo_GetAcceptHeader(This,ppszAcceptHeader)	\
    ( (This)->lpVtbl -> GetAcceptHeader(This,ppszAcceptHeader) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpHeaderInfo_INTERFACE_DEFINED__ */

#endif /* __MSHTMLINTERNAL_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_interned_0001_0079 */
/* [local] */ 

#endif //INTERNAL_H_


extern RPC_IF_HANDLE __MIDL_itf_interned_0001_0079_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_interned_0001_0079_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iphlpapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iphlpapi.h

Abstract:
    Header file for functions to interact with the IP Stack for MIB-II and
    related functionality

--*/

#ifndef __IPHLPAPI_H__
#define __IPHLPAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IPRTRMIB.H has the definitions of the structures used to set and get     //
// information                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <iprtrmib.h>
#include <ipexport.h>
#include <iptypes.h>
#include <tcpestats.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The GetXXXTable APIs take a buffer and a size of buffer.  If the buffer  //
// is not large enough, the APIs return ERROR_INSUFFICIENT_BUFFER  and      //
// *pdwSize is the required buffer size                                     //
// The bOrder is a BOOLEAN, which if TRUE sorts the table according to      //
// MIB-II (RFC XXXX)                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Retrieves the number of interfaces in the system. These include LAN and  //
// WAN interfaces                                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
GetNumberOfInterfaces(
    OUT PDWORD  pdwNumIf
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II ifEntry                                                  //
// The dwIndex field of the MIB_IFROW should be set to the index of the     //
// interface being queried                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfEntry(
    IN OUT PMIB_IFROW   pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II IfTable                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfTable(
    OUT    PMIB_IFTABLE pIfTable,
    IN OUT PULONG       pdwSize,
    IN     BOOL         bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the Interface to IP Address mapping                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the current IP Address to Physical Address (ARP) mapping            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
GetIpNetTable(
    OUT PMIB_IPNETTABLE IpNetTable,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the IP Routing Table  (RFX XXXX)                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpForwardTable(
    OUT    PMIB_IPFORWARDTABLE pIpForwardTable,
    IN OUT PULONG              pdwSize,
    IN     BOOL                bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets TCP Connection/UDP Listener Table                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
GetTcpTable(
    OUT PMIB_TCPTABLE TcpTable,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );

DWORD
WINAPI
GetExtendedTcpTable(
    OUT    PVOID           pTcpTable,
    IN OUT PDWORD          pdwSize,
    IN     BOOL            bOrder,
    IN     ULONG           ulAf,
    IN     TCP_TABLE_CLASS TableClass,
    IN     ULONG           Reserved
    );

DWORD
WINAPI
GetOwnerModuleFromTcpEntry(
    IN     PMIB_TCPROW_OWNER_MODULE      pTcpEntry,
    IN     TCPIP_OWNER_MODULE_INFO_CLASS Class,
    OUT    PVOID                         pBuffer,
    IN OUT PDWORD                        pdwSize
    );

ULONG
WINAPI
GetUdpTable(
    OUT PMIB_UDPTABLE UdpTable,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );

DWORD
WINAPI
GetExtendedUdpTable(
    OUT    PVOID           pUdpTable,
    IN OUT PDWORD          pdwSize,
    IN     BOOL            bOrder,
    IN     ULONG           ulAf,
    IN     UDP_TABLE_CLASS TableClass,
    IN     ULONG           Reserved
    );

DWORD
WINAPI
GetOwnerModuleFromUdpEntry(
    IN     PMIB_UDPROW_OWNER_MODULE      pUdpEntry,
    IN     TCPIP_OWNER_MODULE_INFO_CLASS Class,
    OUT    PVOID                         pBuffer,
    IN OUT PDWORD                        pdwSize
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
ULONG
WINAPI
GetTcpTable2(
    OUT PMIB_TCPTABLE2 TcpTable,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_VISTA)
//
// Deprecated APIs, Added for documentation.
//

DWORD
AllocateAndGetTcpExTableFromStack(
    OUT PVOID         *ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

DWORD
AllocateAndGetUdpExTableFromStack(
    OUT PVOID         *ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#ifdef _WS2IPDEF_
//
// The following definitions require Winsock2.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
ULONG
WINAPI
GetTcp6Table(
    OUT PMIB_TCP6TABLE TcpTable,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );

ULONG
WINAPI
GetTcp6Table2(
    OUT PMIB_TCP6TABLE2 TcpTable,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#ifdef WINAPI

ULONG
WINAPI
GetPerTcpConnectionEStats(
    PMIB_TCPROW Row,
    TCP_ESTATS_TYPE EstatsType,
    __out_bcount_opt(RwSize) PUCHAR Rw,
    ULONG RwVersion,
    ULONG RwSize,
    __out_bcount_opt(RosSize) PUCHAR Ros,
    ULONG RosVersion,
    ULONG RosSize,
    __out_bcount_opt(RodSize) PUCHAR Rod,
    ULONG RodVersion,
    ULONG RodSize
    );

ULONG
WINAPI
SetPerTcpConnectionEStats(
    PMIB_TCPROW Row,
    TCP_ESTATS_TYPE EstatsType,
    __in_bcount(RwSize) PUCHAR Rw,
    ULONG RwVersion,
    ULONG RwSize,
    ULONG Offset
    );

#ifdef _WS2IPDEF_

ULONG
WINAPI
GetPerTcp6ConnectionEStats(
    PMIB_TCP6ROW Row,
    TCP_ESTATS_TYPE EstatsType,
    __out_bcount_opt(RwSize) PUCHAR Rw,
    ULONG RwVersion,
    ULONG RwSize,
    __out_bcount_opt(RosSize) PUCHAR Ros,
    ULONG RosVersion,
    ULONG RosSize,
    __out_bcount_opt(RodSize) PUCHAR Rod,
    ULONG RodVersion,
    ULONG RodSize
    );

ULONG
WINAPI
SetPerTcp6ConnectionEStats(
    PMIB_TCP6ROW Row,
    TCP_ESTATS_TYPE EstatsType,
    __in_bcount(RwSize) PUCHAR Rw,
    ULONG RwVersion,
    ULONG RwSize,
    ULONG Offset
    );

#endif // _WS2IPDEF_

#endif // WINAPI

DWORD
WINAPI
GetOwnerModuleFromTcp6Entry(
    IN     PMIB_TCP6ROW_OWNER_MODULE     pTcpEntry,
    IN     TCPIP_OWNER_MODULE_INFO_CLASS Class,
    OUT    PVOID                         pBuffer,
    IN OUT PDWORD                        pdwSize
    );

ULONG
WINAPI
GetUdp6Table(
    OUT PMIB_UDP6TABLE Udp6Table,
    IN OUT PULONG SizePointer,
    IN BOOL Order
    );

DWORD
WINAPI
GetOwnerModuleFromUdp6Entry(
    IN     PMIB_UDP6ROW_OWNER_MODULE     pUdpEntry,
    IN     TCPIP_OWNER_MODULE_INFO_CLASS Class,
    OUT    PVOID                         pBuffer,
    IN OUT PDWORD                        pdwSize
    );

#endif // _WS2IPDEF_

DWORD
GetOwnerModuleFromPidAndInfo(
    IN ULONG                         ulPid,
    IN ULONGLONG                     *pInfo,
    IN TCPIP_OWNER_MODULE_INFO_CLASS Class,
    OUT PVOID                        pBuffer,
    IN OUT PDWORD                    pdwSize
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets IP/ICMP/TCP/UDP Statistics                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#if (NTDDI_VERSION >= NTDDI_WIN2K)
ULONG
WINAPI
GetIpStatistics(
    OUT PMIB_IPSTATS Statistics
    );


ULONG
WINAPI
GetIpStatisticsEx(
    OUT PMIB_IPSTATS Statistics,
    IN ULONG Family
    );

ULONG
WINAPI
SetIpStatisticsEx(
    IN PMIB_IPSTATS Statistics,
    IN ULONG Family
    );

#endif
ULONG
WINAPI
GetIcmpStatistics(
    OUT PMIB_ICMP Statistics
    );

#if (NTDDI_VERSION >= NTDDI_XPSP1)
ULONG
WINAPI
GetIcmpStatisticsEx(
    OUT PMIB_ICMP_EX Statistics,
    IN ULONG Family
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
ULONG
WINAPI
GetTcpStatistics(
    OUT PMIB_TCPSTATS Statistics
    );

ULONG
WINAPI
GetTcpStatisticsEx(
    OUT PMIB_TCPSTATS Statistics,
    IN ULONG Family
    );
#endif

ULONG
WINAPI
GetUdpStatistics(
    OUT PMIB_UDPSTATS Stats
    );

ULONG
WINAPI
GetUdpStatisticsEx(
    OUT PMIB_UDPSTATS Statistics,
    IN ULONG Family
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ifAdminStatus on an interface.  The only fields of the   //
// MIB_IFROW that are relevant are the dwIndex (index of the interface      //
// whose status needs to be set) and the dwAdminStatus which can be either  //
// MIB_IF_ADMIN_STATUS_UP or MIB_IF_ADMIN_STATUS_DOWN                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIfEntry(
    IN PMIB_IFROW pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete a route.  In all cases the              //
// dwForwardIfIndex, dwForwardDest, dwForwardMask, dwForwardNextHop and     //
// dwForwardPolicy MUST BE SPECIFIED. Currently dwForwardPolicy is unused   //
// and MUST BE 0.                                                           //
// For a set, the complete MIB_IPFORWARDROW structure must be specified     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
SetIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
DeleteIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ipForwarding to ON or OFF (currently only ON->OFF is     //
// allowed) and to set the defaultTTL.  If only one of the fields needs to  //
// be modified and the other needs to be the same as before the other field //
// needs to be set to MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING as  //
// the case may be                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DWORD
WINAPI
SetIpStatistics(
    IN PMIB_IPSTATS pIpStats
    );
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the defaultTTL.                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIpTTL(
    UINT nTTL
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete an ARP entry.  In all cases the dwIndex //
// dwAddr field MUST BE SPECIFIED.                                          //
// For a set, the complete MIB_IPNETROW structure must be specified         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
SetIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
DeleteIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
FlushIpNetTable(
    IN DWORD   dwIfIndex
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create or delete a Proxy ARP entry. The dwIndex is the index of  //
// the interface on which to PARP for the dwAddress.  If the interface is   //
// of a type that doesnt support ARP, e.g. PPP, then the call will fail     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    );

DWORD
WINAPI
DeleteProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the state of a TCP Connection. The only state that it can be //
// set to is MIB_TCP_STATE_DELETE_TCB.  The complete MIB_TCPROW structure   //
// MUST BE SPECIFIED                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetTcpEntry(
    IN PMIB_TCPROW pTcpRow
    );


DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    );

DWORD
WINAPI
GetUniDirectionalAdapterInfo(OUT PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo,
                 OUT PULONG dwOutBufLen
                 );

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
#ifndef NHPALLOCATEANDGETINTERFACEINFOFROMSTACK_DEFINED
#define NHPALLOCATEANDGETINTERFACEINFOFROMSTACK_DEFINED

DWORD
WINAPI
NhpAllocateAndGetInterfaceInfoFromStack(
    OUT IP_INTERFACE_NAME_INFO **ppTable,
    OUT PDWORD                 pdwCount,
    IN BOOL                    bOrder,
    IN HANDLE                  hHeap,
    IN DWORD                   dwFlags
    );

#endif
#endif // (NTDDI_VERSION >= NTDDI_WIN2KSP1)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the "best" outgoing interface for the specified destination address //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestInterface(
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    );

#pragma warning(push)
#pragma warning(disable:4115)
DWORD
WINAPI
GetBestInterfaceEx(
    IN  struct sockaddr *pDestAddr,
    OUT PDWORD           pdwBestIfIndex
    );
#pragma warning(pop)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the best (longest matching prefix) route for the given destination  //
// If the source address is also specified (i.e. is not 0x00000000), and    //
// there are multiple "best" routes to the given destination, the returned  //
// route will be one that goes out over the interface which has an address  //
// that matches the source address                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );

DWORD
WINAPI
NotifyAddrChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    );


DWORD
WINAPI
NotifyRouteChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    );

BOOL
WINAPI
CancelIPChangeNotify(
    IN  LPOVERLAPPED notifyOverlapped
    );

DWORD
WINAPI
GetAdapterIndex(
    __in IN LPWSTR  AdapterName,
    __inout OUT PULONG IfIndex
    );

DWORD
WINAPI
AddIPAddress(
    IPAddr  Address,
    IPMask  IpMask,
    DWORD   IfIndex,
    PULONG  NTEContext,
    PULONG  NTEInstance
    );

DWORD
WINAPI
DeleteIPAddress(
    ULONG NTEContext
    );

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
DWORD
WINAPI
GetNetworkParams(
    PFIXED_INFO pFixedInfo, PULONG pOutBufLen
    );
#endif

ULONG
WINAPI
GetAdaptersInfo(
    IN PIP_ADAPTER_INFO AdapterInfo,
    IN OUT PULONG SizePointer
    );

PIP_ADAPTER_ORDER_MAP
WINAPI
GetAdapterOrderMap(
    VOID
    );

#ifdef _WINSOCK2API_

//
// The following functions require Winsock2.
//

ULONG
WINAPI
GetAdaptersAddresses(
    IN ULONG Family,
    IN ULONG Flags,
    IN PVOID Reserved,
    __out_bcount_opt(*SizePointer) PIP_ADAPTER_ADDRESSES AdapterAddresses,
    IN OUT PULONG SizePointer
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
DWORD
WINAPI
GetPerAdapterInfo(
    ULONG IfIndex, PIP_PER_ADAPTER_INFO pPerAdapterInfo, PULONG pOutBufLen
    );
#endif

DWORD
WINAPI
IpReleaseAddress(
    PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );


DWORD
WINAPI
IpRenewAddress(
    PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );

DWORD
WINAPI
SendARP(
    IPAddr DestIP,
    IPAddr SrcIP,
    PVOID pMacAddr,
    PULONG  PhyAddrLen
    );

BOOL
WINAPI
GetRTTAndHopCount(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops,
    PULONG RTT
    );

DWORD
WINAPI
GetFriendlyIfIndex(
    DWORD IfIndex
    );

DWORD
WINAPI
EnableRouter(
    HANDLE* pHandle,
    OVERLAPPED* pOverlapped
    );

DWORD
WINAPI
UnenableRouter(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );
DWORD
WINAPI
DisableMediaSense(
    HANDLE *pHandle,
    OVERLAPPED *pOverLapped
    );

DWORD
WINAPI
RestoreMediaSense(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)

DWORD
WINAPI
GetIpErrorString(
    IN IP_STATUS ErrorCode,
    __out_ecount_opt(*Size + 1) PWSTR Buffer,
    __inout PDWORD Size
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
#ifdef _WS2DEF_
ULONG
WINAPI
ResolveNeighbor(
    IN SOCKADDR *NetworkAddress,
    OUT PVOID PhysicalAddress,
    IN OUT PULONG PhysicalAddressLength
    );
#endif
#endif
//
// Port reservation API routines.
//

ULONG
WINAPI
CreatePersistentTcpPortReservation(
    IN USHORT StartPort,
    IN USHORT NumberOfPorts,
    OUT PULONG64 Token
    );

ULONG
WINAPI
CreatePersistentUdpPortReservation(
    IN USHORT StartPort,
    IN USHORT NumberOfPorts,
    OUT PULONG64 Token
    );

ULONG
WINAPI
DeletePersistentTcpPortReservation(
    IN USHORT StartPort,
    IN USHORT NumberOfPorts
    );

ULONG
WINAPI
DeletePersistentUdpPortReservation(
    IN USHORT StartPort,
    IN USHORT NumberOfPorts
    );

ULONG
WINAPI
LookupPersistentTcpPortReservation(
    IN USHORT StartPort,
    IN USHORT NumberOfPorts,
    OUT PULONG64 Token
    );

ULONG
WINAPI
LookupPersistentUdpPortReservation(
    IN USHORT StartPort,
    IN USHORT NumberOfPorts,
    OUT PULONG64 Token
    );


//
// Network String parsing API
//

#define NET_STRING_IPV4_ADDRESS           0x00000001
   // The string identifies an IPv4 Host/router using literal address.
   // (port or prefix not allowed)
#define NET_STRING_IPV4_SERVICE           0x00000002
   // The string identifies an IPv4 service using literal address.
   // (port required; prefix not allowed)
#define NET_STRING_IPV4_NETWORK           0x00000004
   // The string identifies an IPv4 network.
   // (prefix required; port not allowed)
#define NET_STRING_IPV6_ADDRESS           0x00000008
   // The string identifies an IPv6 Host/router using literal address.
   // (port or prefix not allowed; scope-id allowed)
#define NET_STRING_IPV6_ADDRESS_NO_SCOPE  0x00000010
   // The string identifies an IPv6 Host/router using literal address
   // where the interface context is already known.
   // (port or prefix not allowed; scope-id not allowed)
#define NET_STRING_IPV6_SERVICE           0x00000020
   // The string identifies an IPv6 service using literal address.
   // (port required; prefix not allowed; scope-id allowed)
#define NET_STRING_IPV6_SERVICE_NO_SCOPE  0x00000040
   // The string identifies an IPv6 service using literal address
   // where the interface context is already known.
   // (port required; prefix not allowed; scope-id not allowed)
#define NET_STRING_IPV6_NETWORK           0x00000080
   // The string identifies an IPv6 network.
   // (prefix required; port or scope-id not allowed)
#define NET_STRING_NAMED_ADDRESS          0x00000100
   // The string identifies an Internet Host using DNS.
   // (port or prefix or scope-id not allowed)
#define NET_STRING_NAMED_SERVICE          0x00000200
   // The string identifies an Internet service using DNS.
   // (port required; prefix or scope-id not allowed)

#define NET_STRING_IP_ADDRESS             (NET_STRING_IPV4_ADDRESS   | \
                                           NET_STRING_IPV6_ADDRESS)

#define NET_STRING_IP_ADDRESS_NO_SCOPE    (NET_STRING_IPV4_ADDRESS   | \
                                           NET_STRING_IPV6_ADDRESS_NO_SCOPE)

#define NET_STRING_IP_SERVICE             (NET_STRING_IPV4_SERVICE   | \
                                           NET_STRING_IPV6_SERVICE)

#define NET_STRING_IP_SERVICE_NO_SCOPE    (NET_STRING_IPV4_SERVICE   | \
                                           NET_STRING_IPV6_SERVICE_NO_SCOPE)

#define NET_STRING_IP_NETWORK             (NET_STRING_IPV4_NETWORK   | \
                                           NET_STRING_IPV6_NETWORK)

#define NET_STRING_ANY_ADDRESS            (NET_STRING_NAMED_ADDRESS  | \
                                           NET_STRING_IP_ADDRESS)

#define NET_STRING_ANY_ADDRESS_NO_SCOPE   (NET_STRING_NAMED_ADDRESS  | \
                                           NET_STRING_IP_ADDRESS_NO_SCOPE)

#define NET_STRING_ANY_SERVICE            (NET_STRING_NAMED_SERVICE  | \
                                           NET_STRING_IP_SERVICE)

#define NET_STRING_ANY_SERVICE_NO_SCOPE   (NET_STRING_NAMED_SERVICE  | \
                                           NET_STRING_IP_SERVICE_NO_SCOPE)

typedef enum NET_ADDRESS_FORMAT_
{
   NET_ADDRESS_FORMAT_UNSPECIFIED = 0,

   NET_ADDRESS_DNS_NAME,
   NET_ADDRESS_IPV4,
   NET_ADDRESS_IPV6

} NET_ADDRESS_FORMAT;

#if defined (_WS2DEF_) && defined (_WS2IPDEF_) && defined(_WINDNS_INCLUDED_)
    // app must include winsock2.h, ws2ipdef.h, and windns.h to use this API

typedef struct NET_ADDRESS_INFO_
{
   NET_ADDRESS_FORMAT Format;

   union
   {
      struct {
         WCHAR Address[DNS_MAX_NAME_BUFFER_LENGTH];
         WCHAR Port[6];
      } NamedAddress;

      SOCKADDR_IN Ipv4Address;
      SOCKADDR_IN6 Ipv6Address;
      SOCKADDR IpAddress;
   };

} NET_ADDRESS_INFO, *PNET_ADDRESS_INFO;

DWORD
WINAPI
ParseNetworkString(
   IN CONST WCHAR* NetworkString,
   IN DWORD Types,
   OUT PNET_ADDRESS_INFO AddressInfo OPTIONAL,
   OUT USHORT* PortNumber OPTIONAL,
   OUT BYTE* PrefixLength OPTIONAL
   );

#endif

#include <netioapi.h>

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#ifdef __cplusplus
}
#endif

#endif //__IPHLPAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ipifcons.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ipifcons.h

Abstract:
    Constants needed for the Interface Object

--*/

#ifndef __IPIFCONS_H__
#define __IPIFCONS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Media types                                                              //
//                                                                          //  
// These are enumerated values of the ifType object defined in MIB-II's     //
// ifTable.  They are registered with IANA which publishes this list        //
// periodically, in either the Assigned Numbers RFC, or some derivative     //
// of it specific to Internet Network Management number assignments.        //
// See ftp://ftp.isi.edu/mib/ianaiftype.mib                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MIN_IF_TYPE                     1

#define IF_TYPE_OTHER                   1   // None of the below
#define IF_TYPE_REGULAR_1822            2
#define IF_TYPE_HDH_1822                3
#define IF_TYPE_DDN_X25                 4
#define IF_TYPE_RFC877_X25              5
#define IF_TYPE_ETHERNET_CSMACD         6
#define IF_TYPE_IS088023_CSMACD         7
#define IF_TYPE_ISO88024_TOKENBUS       8
#define IF_TYPE_ISO88025_TOKENRING      9
#define IF_TYPE_ISO88026_MAN            10
#define IF_TYPE_STARLAN                 11
#define IF_TYPE_PROTEON_10MBIT          12
#define IF_TYPE_PROTEON_80MBIT          13
#define IF_TYPE_HYPERCHANNEL            14
#define IF_TYPE_FDDI                    15
#define IF_TYPE_LAP_B                   16
#define IF_TYPE_SDLC                    17
#define IF_TYPE_DS1                     18  // DS1-MIB
#define IF_TYPE_E1                      19  // Obsolete; see DS1-MIB
#define IF_TYPE_BASIC_ISDN              20
#define IF_TYPE_PRIMARY_ISDN            21
#define IF_TYPE_PROP_POINT2POINT_SERIAL 22  // proprietary serial
#define IF_TYPE_PPP                     23
#define IF_TYPE_SOFTWARE_LOOPBACK       24
#define IF_TYPE_EON                     25  // CLNP over IP
#define IF_TYPE_ETHERNET_3MBIT          26
#define IF_TYPE_NSIP                    27  // XNS over IP
#define IF_TYPE_SLIP                    28  // Generic Slip
#define IF_TYPE_ULTRA                   29  // ULTRA Technologies
#define IF_TYPE_DS3                     30  // DS3-MIB
#define IF_TYPE_SIP                     31  // SMDS, coffee
#define IF_TYPE_FRAMERELAY              32  // DTE only
#define IF_TYPE_RS232                   33
#define IF_TYPE_PARA                    34  // Parallel port
#define IF_TYPE_ARCNET                  35
#define IF_TYPE_ARCNET_PLUS             36
#define IF_TYPE_ATM                     37  // ATM cells
#define IF_TYPE_MIO_X25                 38
#define IF_TYPE_SONET                   39  // SONET or SDH
#define IF_TYPE_X25_PLE                 40
#define IF_TYPE_ISO88022_LLC            41
#define IF_TYPE_LOCALTALK               42
#define IF_TYPE_SMDS_DXI                43
#define IF_TYPE_FRAMERELAY_SERVICE      44  // FRNETSERV-MIB
#define IF_TYPE_V35                     45
#define IF_TYPE_HSSI                    46
#define IF_TYPE_HIPPI                   47
#define IF_TYPE_MODEM                   48  // Generic Modem
#define IF_TYPE_AAL5                    49  // AAL5 over ATM
#define IF_TYPE_SONET_PATH              50
#define IF_TYPE_SONET_VT                51
#define IF_TYPE_SMDS_ICIP               52  // SMDS InterCarrier Interface
#define IF_TYPE_PROP_VIRTUAL            53  // Proprietary virtual/internal
#define IF_TYPE_PROP_MULTIPLEXOR        54  // Proprietary multiplexing
#define IF_TYPE_IEEE80212               55  // 100BaseVG
#define IF_TYPE_FIBRECHANNEL            56
#define IF_TYPE_HIPPIINTERFACE          57
#define IF_TYPE_FRAMERELAY_INTERCONNECT 58  // Obsolete, use 32 or 44
#define IF_TYPE_AFLANE_8023             59  // ATM Emulated LAN for 802.3
#define IF_TYPE_AFLANE_8025             60  // ATM Emulated LAN for 802.5
#define IF_TYPE_CCTEMUL                 61  // ATM Emulated circuit
#define IF_TYPE_FASTETHER               62  // Fast Ethernet (100BaseT)
#define IF_TYPE_ISDN                    63  // ISDN and X.25
#define IF_TYPE_V11                     64  // CCITT V.11/X.21
#define IF_TYPE_V36                     65  // CCITT V.36
#define IF_TYPE_G703_64K                66  // CCITT G703 at 64Kbps
#define IF_TYPE_G703_2MB                67  // Obsolete; see DS1-MIB
#define IF_TYPE_QLLC                    68  // SNA QLLC
#define IF_TYPE_FASTETHER_FX            69  // Fast Ethernet (100BaseFX)
#define IF_TYPE_CHANNEL                 70
#define IF_TYPE_IEEE80211               71  // Radio spread spectrum
#define IF_TYPE_IBM370PARCHAN           72  // IBM System 360/370 OEMI Channel
#define IF_TYPE_ESCON                   73  // IBM Enterprise Systems Connection
#define IF_TYPE_DLSW                    74  // Data Link Switching
#define IF_TYPE_ISDN_S                  75  // ISDN S/T interface
#define IF_TYPE_ISDN_U                  76  // ISDN U interface
#define IF_TYPE_LAP_D                   77  // Link Access Protocol D
#define IF_TYPE_IPSWITCH                78  // IP Switching Objects
#define IF_TYPE_RSRB                    79  // Remote Source Route Bridging
#define IF_TYPE_ATM_LOGICAL             80  // ATM Logical Port
#define IF_TYPE_DS0                     81  // Digital Signal Level 0
#define IF_TYPE_DS0_BUNDLE              82  // Group of ds0s on the same ds1
#define IF_TYPE_BSC                     83  // Bisynchronous Protocol
#define IF_TYPE_ASYNC                   84  // Asynchronous Protocol
#define IF_TYPE_CNR                     85  // Combat Net Radio
#define IF_TYPE_ISO88025R_DTR           86  // ISO 802.5r DTR
#define IF_TYPE_EPLRS                   87  // Ext Pos Loc Report Sys
#define IF_TYPE_ARAP                    88  // Appletalk Remote Access Protocol
#define IF_TYPE_PROP_CNLS               89  // Proprietary Connectionless Proto
#define IF_TYPE_HOSTPAD                 90  // CCITT-ITU X.29 PAD Protocol
#define IF_TYPE_TERMPAD                 91  // CCITT-ITU X.3 PAD Facility
#define IF_TYPE_FRAMERELAY_MPI          92  // Multiproto Interconnect over FR
#define IF_TYPE_X213                    93  // CCITT-ITU X213
#define IF_TYPE_ADSL                    94  // Asymmetric Digital Subscrbr Loop
#define IF_TYPE_RADSL                   95  // Rate-Adapt Digital Subscrbr Loop
#define IF_TYPE_SDSL                    96  // Symmetric Digital Subscriber Loop
#define IF_TYPE_VDSL                    97  // Very H-Speed Digital Subscrb Loop
#define IF_TYPE_ISO88025_CRFPRINT       98  // ISO 802.5 CRFP
#define IF_TYPE_MYRINET                 99  // Myricom Myrinet
#define IF_TYPE_VOICE_EM                100 // Voice recEive and transMit
#define IF_TYPE_VOICE_FXO               101 // Voice Foreign Exchange Office
#define IF_TYPE_VOICE_FXS               102 // Voice Foreign Exchange Station
#define IF_TYPE_VOICE_ENCAP             103 // Voice encapsulation
#define IF_TYPE_VOICE_OVERIP            104 // Voice over IP encapsulation
#define IF_TYPE_ATM_DXI                 105 // ATM DXI
#define IF_TYPE_ATM_FUNI                106 // ATM FUNI
#define IF_TYPE_ATM_IMA                 107 // ATM IMA
#define IF_TYPE_PPPMULTILINKBUNDLE      108 // PPP Multilink Bundle
#define IF_TYPE_IPOVER_CDLC             109 // IBM ipOverCdlc
#define IF_TYPE_IPOVER_CLAW             110 // IBM Common Link Access to Workstn
#define IF_TYPE_STACKTOSTACK            111 // IBM stackToStack
#define IF_TYPE_VIRTUALIPADDRESS        112 // IBM VIPA
#define IF_TYPE_MPC                     113 // IBM multi-proto channel support
#define IF_TYPE_IPOVER_ATM              114 // IBM ipOverAtm
#define IF_TYPE_ISO88025_FIBER          115 // ISO 802.5j Fiber Token Ring
#define IF_TYPE_TDLC                    116 // IBM twinaxial data link control
#define IF_TYPE_GIGABITETHERNET         117
#define IF_TYPE_HDLC                    118
#define IF_TYPE_LAP_F                   119
#define IF_TYPE_V37                     120
#define IF_TYPE_X25_MLP                 121 // Multi-Link Protocol
#define IF_TYPE_X25_HUNTGROUP           122 // X.25 Hunt Group
#define IF_TYPE_TRANSPHDLC              123
#define IF_TYPE_INTERLEAVE              124 // Interleave channel
#define IF_TYPE_FAST                    125 // Fast channel
#define IF_TYPE_IP                      126 // IP (for APPN HPR in IP networks)
#define IF_TYPE_DOCSCABLE_MACLAYER      127 // CATV Mac Layer
#define IF_TYPE_DOCSCABLE_DOWNSTREAM    128 // CATV Downstream interface
#define IF_TYPE_DOCSCABLE_UPSTREAM      129 // CATV Upstream interface
#define IF_TYPE_A12MPPSWITCH            130 // Avalon Parallel Processor
#define IF_TYPE_TUNNEL                  131 // Encapsulation interface
#define IF_TYPE_COFFEE                  132 // Coffee pot
#define IF_TYPE_CES                     133 // Circuit Emulation Service
#define IF_TYPE_ATM_SUBINTERFACE        134 // ATM Sub Interface
#define IF_TYPE_L2_VLAN                 135 // Layer 2 Virtual LAN using 802.1Q
#define IF_TYPE_L3_IPVLAN               136 // Layer 3 Virtual LAN using IP
#define IF_TYPE_L3_IPXVLAN              137 // Layer 3 Virtual LAN using IPX
#define IF_TYPE_DIGITALPOWERLINE        138 // IP over Power Lines
#define IF_TYPE_MEDIAMAILOVERIP         139 // Multimedia Mail over IP
#define IF_TYPE_DTM                     140 // Dynamic syncronous Transfer Mode
#define IF_TYPE_DCN                     141 // Data Communications Network
#define IF_TYPE_IPFORWARD               142 // IP Forwarding Interface
#define IF_TYPE_MSDSL                   143 // Multi-rate Symmetric DSL
#define IF_TYPE_IEEE1394                144 // IEEE1394 High Perf Serial Bus
#define IF_TYPE_IF_GSN                  145
#define IF_TYPE_DVBRCC_MACLAYER         146
#define IF_TYPE_DVBRCC_DOWNSTREAM       147
#define IF_TYPE_DVBRCC_UPSTREAM         148
#define IF_TYPE_ATM_VIRTUAL             149
#define IF_TYPE_MPLS_TUNNEL             150
#define IF_TYPE_SRP                     151
#define IF_TYPE_VOICEOVERATM            152
#define IF_TYPE_VOICEOVERFRAMERELAY     153
#define IF_TYPE_IDSL                    154
#define IF_TYPE_COMPOSITELINK           155
#define IF_TYPE_SS7_SIGLINK             156
#define IF_TYPE_PROP_WIRELESS_P2P       157
#define IF_TYPE_FR_FORWARD              158
#define IF_TYPE_RFC1483                 159
#define IF_TYPE_USB                     160
#define IF_TYPE_IEEE8023AD_LAG          161
#define IF_TYPE_BGP_POLICY_ACCOUNTING   162
#define IF_TYPE_FRF16_MFR_BUNDLE        163
#define IF_TYPE_H323_GATEKEEPER         164
#define IF_TYPE_H323_PROXY              165
#define IF_TYPE_MPLS                    166
#define IF_TYPE_MF_SIGLINK              167
#define IF_TYPE_HDSL2                   168
#define IF_TYPE_SHDSL                   169
#define IF_TYPE_DS1_FDL                 170
#define IF_TYPE_POS                     171
#define IF_TYPE_DVB_ASI_IN              172
#define IF_TYPE_DVB_ASI_OUT             173
#define IF_TYPE_PLC                     174
#define IF_TYPE_NFAS                    175
#define IF_TYPE_TR008                   176
#define IF_TYPE_GR303_RDT               177
#define IF_TYPE_GR303_IDT               178
#define IF_TYPE_ISUP                    179
#define IF_TYPE_PROP_DOCS_WIRELESS_MACLAYER      180
#define IF_TYPE_PROP_DOCS_WIRELESS_DOWNSTREAM    181
#define IF_TYPE_PROP_DOCS_WIRELESS_UPSTREAM      182
#define IF_TYPE_HIPERLAN2                        183
#define IF_TYPE_PROP_BWA_P2MP                    184
#define IF_TYPE_SONET_OVERHEAD_CHANNEL           185
#define IF_TYPE_DIGITAL_WRAPPER_OVERHEAD_CHANNEL 186
#define IF_TYPE_AAL2                             187
#define IF_TYPE_RADIO_MAC                        188
#define IF_TYPE_ATM_RADIO                        189
#define IF_TYPE_IMT                              190
#define IF_TYPE_MVL                              191
#define IF_TYPE_REACH_DSL                        192
#define IF_TYPE_FR_DLCI_ENDPT                    193
#define IF_TYPE_ATM_VCI_ENDPT                    194
#define IF_TYPE_OPTICAL_CHANNEL                  195
#define IF_TYPE_OPTICAL_TRANSPORT                196

#define MAX_IF_TYPE                     196

typedef ULONG IFTYPE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Access types                                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef enum _IF_ACCESS_TYPE {
    IF_ACCESS_LOOPBACK             = 1,
    IF_ACCESS_BROADCAST            = 2,
    IF_ACCESS_POINT_TO_POINT       = 3, // New definition.
    IF_ACCESS_POINTTOPOINT         = 3, // Old definition.
    IF_ACCESS_POINT_TO_MULTI_POINT = 4, // New definition.
    IF_ACCESS_POINTTOMULTIPOINT    = 4, // Old definition.
} IF_ACCESS_TYPE;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Interface Capabilities (bit flags)                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_CHECK_NONE                   0x00
#define IF_CHECK_MCAST                  0x01
#define IF_CHECK_SEND                   0x02


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Connection Types                                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_CONNECTION_DEDICATED         1
#define IF_CONNECTION_PASSIVE           2
#define IF_CONNECTION_DEMAND            3


#define IF_ADMIN_STATUS_UP              1
#define IF_ADMIN_STATUS_DOWN            2
#define IF_ADMIN_STATUS_TESTING         3

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the the operational states for WAN and LAN interfaces. //
// The order of the states seems weird, but is done for a purpose. All      //
// states >= CONNECTED can transmit data right away. States >= DISCONNECTED //
// can tx data but some set up might be needed. States < DISCONNECTED can   //
// not transmit data.                                                       //
// A card is marked UNREACHABLE if DIM calls InterfaceUnreachable for       //
// reasons other than failure to connect.                                   //
//                                                                          //
// NON_OPERATIONAL -- Valid for LAN Interfaces. Means the card is not       //
//                      working or not plugged in or has no address.        //
// UNREACHABLE     -- Valid for WAN Interfaces. Means the remote site is    //
//                      not reachable at this time.                         //
// DISCONNECTED    -- Valid for WAN Interfaces. Means the remote site is    //
//                      not connected at this time.                         //
// CONNECTING      -- Valid for WAN Interfaces. Means a connection attempt  //
//                      has been initiated to the remote site.              //
// CONNECTED       -- Valid for WAN Interfaces. Means the remote site is    //
//                      connected.                                          //
// OPERATIONAL     -- Valid for LAN Interfaces. Means the card is plugged   //
//                      in and working.                                     //
//                                                                          //
// It is the users duty to convert these values to MIB-II values if they    //
// are to be used by a subagent                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef enum _INTERNAL_IF_OPER_STATUS {
    IF_OPER_STATUS_NON_OPERATIONAL = 0,
    IF_OPER_STATUS_UNREACHABLE     = 1,
    IF_OPER_STATUS_DISCONNECTED    = 2,
    IF_OPER_STATUS_CONNECTING      = 3,
    IF_OPER_STATUS_CONNECTED       = 4,
    IF_OPER_STATUS_OPERATIONAL     = 5,
} INTERNAL_IF_OPER_STATUS;

#define MIB_IF_TYPE_OTHER               1
#define MIB_IF_TYPE_ETHERNET            6
#define MIB_IF_TYPE_TOKENRING           9
#define MIB_IF_TYPE_FDDI                15
#define MIB_IF_TYPE_PPP                 23
#define MIB_IF_TYPE_LOOPBACK            24
#define MIB_IF_TYPE_SLIP                28

#define MIB_IF_ADMIN_STATUS_UP          1
#define MIB_IF_ADMIN_STATUS_DOWN        2
#define MIB_IF_ADMIN_STATUS_TESTING     3

//
// N.B. The name is a misnomer.  These are NOT the values used by MIB-II.
//
#define MIB_IF_OPER_STATUS_NON_OPERATIONAL      IF_OPER_STATUS_NON_OPERATIONAL
#define MIB_IF_OPER_STATUS_UNREACHABLE          IF_OPER_STATUS_UNREACHABLE
#define MIB_IF_OPER_STATUS_DISCONNECTED         IF_OPER_STATUS_DISCONNECTED
#define MIB_IF_OPER_STATUS_CONNECTING           IF_OPER_STATUS_CONNECTING
#define MIB_IF_OPER_STATUS_CONNECTED            IF_OPER_STATUS_CONNECTED
#define MIB_IF_OPER_STATUS_OPERATIONAL          IF_OPER_STATUS_OPERATIONAL

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_IPIFCONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\IPlayAudio.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Sun Feb 24 19:37:38 2008
 */
/* Compiler settings for .\IPlayAudio.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __IPlayAudio_h__
#define __IPlayAudio_h__

/* Forward Declarations */

#ifndef __IPlayAudio_FWD_DEFINED__
#define __IPlayAudio_FWD_DEFINED__
typedef interface IPlayAudio IPlayAudio;
#endif  /* __IPlayAudio_FWD_DEFINED__ */


#ifndef __IPlayAudioFactory_FWD_DEFINED__
#define __IPlayAudioFactory_FWD_DEFINED__
typedef interface IPlayAudioFactory IPlayAudioFactory;
#endif  /* __IPlayAudioFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IPlayAudio_INTERFACE_DEFINED__
#define __IPlayAudio_INTERFACE_DEFINED__

/* interface IPlayAudio */
/* [unique][uuid][local][object] */


EXTERN_C const IID IID_IPlayAudio;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("0EDB016A-3F26-4116-B1CA-448C861B0DBD")
    IPlayAudio : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDoneEvent(
            /* [out] */ HANDLE __RPC_FAR *phDoneEvent) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDuration(
            /* [out] */ LONGLONG __RPC_FAR *pRefTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetPosition(
            /* [in] */ LONGLONG __RPC_FAR *pRefTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetPosition(
            /* [out] */ LONGLONG __RPC_FAR *pRefTime) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetVolume(
            /* [in] */ LONG Volume) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetVolume(
            /* [out] */ LONG __RPC_FAR *pVolume) = 0;

    };

#else   /* C style interface */

    typedef struct IPlayAudioVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPlayAudio __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPlayAudio __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPlayAudio __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )(
            IPlayAudio __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )(
            IPlayAudio __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDoneEvent )(
            IPlayAudio __RPC_FAR * This,
            /* [out] */ HANDLE __RPC_FAR *phDoneEvent);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuration )(
            IPlayAudio __RPC_FAR * This,
            /* [out] */ LONGLONG __RPC_FAR *pRefTime);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPosition )(
            IPlayAudio __RPC_FAR * This,
            /* [in] */ LONGLONG __RPC_FAR *pRefTime);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPosition )(
            IPlayAudio __RPC_FAR * This,
            /* [out] */ LONGLONG __RPC_FAR *pRefTime);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume )(
            IPlayAudio __RPC_FAR * This,
            /* [in] */ LONG Volume);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolume )(
            IPlayAudio __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pVolume);

        END_INTERFACE
    } IPlayAudioVtbl;

    interface IPlayAudio
    {
        CONST_VTBL struct IPlayAudioVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPlayAudio_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPlayAudio_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IPlayAudio_Release(This)        \
    (This)->lpVtbl -> Release(This)


#define IPlayAudio_Play(This)   \
    (This)->lpVtbl -> Play(This)

#define IPlayAudio_Pause(This)  \
    (This)->lpVtbl -> Pause(This)

#define IPlayAudio_GetDoneEvent(This,phDoneEvent)       \
    (This)->lpVtbl -> GetDoneEvent(This,phDoneEvent)

#define IPlayAudio_GetDuration(This,pRefTime)   \
    (This)->lpVtbl -> GetDuration(This,pRefTime)

#define IPlayAudio_SetPosition(This,pRefTime)   \
    (This)->lpVtbl -> SetPosition(This,pRefTime)

#define IPlayAudio_GetPosition(This,pRefTime)   \
    (This)->lpVtbl -> GetPosition(This,pRefTime)

#define IPlayAudio_SetVolume(This,Volume)       \
    (This)->lpVtbl -> SetVolume(This,Volume)

#define IPlayAudio_GetVolume(This,pVolume)      \
    (This)->lpVtbl -> GetVolume(This,pVolume)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPlayAudio_Play_Proxy(
    IPlayAudio __RPC_FAR * This);


void __RPC_STUB IPlayAudio_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_Pause_Proxy(
    IPlayAudio __RPC_FAR * This);


void __RPC_STUB IPlayAudio_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_GetDoneEvent_Proxy(
    IPlayAudio __RPC_FAR * This,
    /* [out] */ HANDLE __RPC_FAR *phDoneEvent);


void __RPC_STUB IPlayAudio_GetDoneEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_GetDuration_Proxy(
    IPlayAudio __RPC_FAR * This,
    /* [out] */ LONGLONG __RPC_FAR *pRefTime);


void __RPC_STUB IPlayAudio_GetDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_SetPosition_Proxy(
    IPlayAudio __RPC_FAR * This,
    /* [in] */ LONGLONG __RPC_FAR *pRefTime);


void __RPC_STUB IPlayAudio_SetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_GetPosition_Proxy(
    IPlayAudio __RPC_FAR * This,
    /* [out] */ LONGLONG __RPC_FAR *pRefTime);


void __RPC_STUB IPlayAudio_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_SetVolume_Proxy(
    IPlayAudio __RPC_FAR * This,
    /* [in] */ LONG Volume);


void __RPC_STUB IPlayAudio_SetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudio_GetVolume_Proxy(
    IPlayAudio __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *pVolume);


void __RPC_STUB IPlayAudio_GetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPlayAudio_INTERFACE_DEFINED__ */


#ifndef __IPlayAudioFactory_INTERFACE_DEFINED__
#define __IPlayAudioFactory_INTERFACE_DEFINED__

/* interface IPlayAudioFactory */
/* [unique][uuid][local][object] */


EXTERN_C const IID IID_IPlayAudioFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("F2A74447-B681-451a-8A67-CCA245AF561E")
    IPlayAudioFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open(
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ UINT DeviceId,
            /* [out] */ IPlayAudio __RPC_FAR *__RPC_FAR *ppIPlayAudio) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenIStream(
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ UINT DeviceId,
            /* [out] */ IPlayAudio __RPC_FAR *__RPC_FAR *ppIPlayAudio) = 0;

    };

#else   /* C style interface */

    typedef struct IPlayAudioFactoryVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPlayAudioFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPlayAudioFactory __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPlayAudioFactory __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )(
            IPlayAudioFactory __RPC_FAR * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ UINT DeviceId,
            /* [out] */ IPlayAudio __RPC_FAR *__RPC_FAR *ppIPlayAudio);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenIStream )(
            IPlayAudioFactory __RPC_FAR * This,
            /* [in] */ LPCWSTR lpcwstrFile,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ UINT DeviceId,
            /* [out] */ IPlayAudio __RPC_FAR *__RPC_FAR *ppIPlayAudio);

        END_INTERFACE
    } IPlayAudioFactoryVtbl;

    interface IPlayAudioFactory
    {
        CONST_VTBL struct IPlayAudioFactoryVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPlayAudioFactory_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPlayAudioFactory_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IPlayAudioFactory_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IPlayAudioFactory_Open(This,lpcwstrFile,DeviceId,ppIPlayAudio)  \
    (This)->lpVtbl -> Open(This,lpcwstrFile,DeviceId,ppIPlayAudio)

#define IPlayAudioFactory_OpenIStream(This,lpcwstrFile,pStream,DeviceId,ppIPlayAudio)   \
    (This)->lpVtbl -> OpenIStream(This,lpcwstrFile,pStream,DeviceId,ppIPlayAudio)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPlayAudioFactory_Open_Proxy(
    IPlayAudioFactory __RPC_FAR * This,
    /* [in] */ LPCWSTR lpcwstrFile,
    /* [in] */ UINT DeviceId,
    /* [out] */ IPlayAudio __RPC_FAR *__RPC_FAR *ppIPlayAudio);


void __RPC_STUB IPlayAudioFactory_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPlayAudioFactory_OpenIStream_Proxy(
    IPlayAudioFactory __RPC_FAR * This,
    /* [in] */ LPCWSTR lpcwstrFile,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ UINT DeviceId,
    /* [out] */ IPlayAudio __RPC_FAR *__RPC_FAR *ppIPlayAudio);


void __RPC_STUB IPlayAudioFactory_OpenIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPlayAudioFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_IPlayAudio_0065 */
/* [local] */

DEFINE_GUID(CLSID_IPlayAudioFactory,   0x9bf60f60, 0x7987, 0x4df2, 0xbe, 0x61, 0xcf, 0x21, 0xce, 0x2a, 0xb8, 0xc0);


extern RPC_IF_HANDLE __MIDL_itf_IPlayAudio_0065_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_IPlayAudio_0065_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ipmib.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ipmib.h

Abstract:

    This module contains the public definitions and structures for the
    IP-specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

--*/

#ifndef _IPMIB_
#define _IPMIB_
#pragma once

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

//
// Pick up definitions of MAXLEN_PHYSADDR, etc.
//
#include <ifmib.h>

#include <nldef.h>

#define MIB_IPADDR_PRIMARY      0x0001 // Primary ipaddr
#define MIB_IPADDR_DYNAMIC      0x0004 // Dynamic ipaddr
#define MIB_IPADDR_DISCONNECTED 0x0008 // Address is on disconnected interface
#define MIB_IPADDR_DELETED      0x0040 // Address being deleted
#define MIB_IPADDR_TRANSIENT    0x0080 // Transient address
#define MIB_IPADDR_DNS_ELIGIBLE 0X0100 // Address is published in DNS.

typedef struct _MIB_IPADDRROW_XP {
    DWORD dwAddr;
    IF_INDEX dwIndex;
    DWORD dwMask;
    DWORD dwBCastAddr;
    DWORD dwReasmSize;
    unsigned short unused1;
    unsigned short wType;
} MIB_IPADDRROW_XP, *PMIB_IPADDRROW_XP;

typedef struct _MIB_IPADDRROW_W2K {
    DWORD dwAddr;
    DWORD dwIndex;
    DWORD dwMask;
    DWORD dwBCastAddr;
    DWORD dwReasmSize;
    unsigned short unused1;
    unsigned short unused2;
} MIB_IPADDRROW_W2K, *PMIB_IPADDRROW_W2K;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_IPADDRROW_XP MIB_IPADDRROW;
typedef MIB_IPADDRROW_XP *PMIB_IPADDRROW;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPADDRROW_W2K MIB_IPADDRROW;
typedef MIB_IPADDRROW_W2K *PMIB_IPADDRROW;
#else
typedef MIB_IPADDRROW_XP MIB_IPADDRROW;
typedef MIB_IPADDRROW_XP *PMIB_IPADDRROW;
#endif

typedef struct _MIB_IPADDRTABLE {
    DWORD dwNumEntries;
    MIB_IPADDRROW table[ANY_SIZE];
} MIB_IPADDRTABLE, *PMIB_IPADDRTABLE;


#define SIZEOF_IPADDRTABLE(X) (FIELD_OFFSET(MIB_IPADDRTABLE,table[0]) + \
                               ((X) * sizeof(MIB_IPADDRROW)) + ALIGN_SIZE)

typedef struct _MIB_IPFORWARDNUMBER {
    DWORD dwValue;
} MIB_IPFORWARDNUMBER,*PMIB_IPFORWARDNUMBER;

typedef NL_ROUTE_PROTOCOL MIB_IPFORWARD_PROTO;

typedef enum {
    MIB_IPROUTE_TYPE_OTHER    = 1,
    MIB_IPROUTE_TYPE_INVALID  = 2,
    MIB_IPROUTE_TYPE_DIRECT   = 3,
    MIB_IPROUTE_TYPE_INDIRECT = 4,
} MIB_IPFORWARD_TYPE;

typedef struct _MIB_IPFORWARDROW {
    DWORD dwForwardDest;
    DWORD dwForwardMask;
    DWORD dwForwardPolicy;
    DWORD dwForwardNextHop;
    IF_INDEX dwForwardIfIndex;
    union {
        DWORD dwForwardType;              // Old field name uses DWORD type.
        MIB_IPFORWARD_TYPE ForwardType;   // New field name uses enum type.
    };
    union {
        DWORD dwForwardProto;             // Old field name uses DWORD type.
        MIB_IPFORWARD_PROTO ForwardProto; // New field name uses enum type.
    };
    DWORD dwForwardAge;
    DWORD dwForwardNextHopAS;
    DWORD dwForwardMetric1;
    DWORD dwForwardMetric2;
    DWORD dwForwardMetric3;
    DWORD dwForwardMetric4;
    DWORD dwForwardMetric5;
} MIB_IPFORWARDROW, *PMIB_IPFORWARDROW;

#define MIB_IPROUTE_TYPE_OTHER    1
#define MIB_IPROUTE_TYPE_INVALID  2
#define MIB_IPROUTE_TYPE_DIRECT   3
#define MIB_IPROUTE_TYPE_INDIRECT 4

#define MIB_IPROUTE_METRIC_UNUSED    (DWORD)-1


typedef struct _MIB_IPFORWARDTABLE {
    DWORD dwNumEntries;
    MIB_IPFORWARDROW table[ANY_SIZE];
} MIB_IPFORWARDTABLE, *PMIB_IPFORWARDTABLE;

#define SIZEOF_IPFORWARDTABLE(X) \
            (FIELD_OFFSET(MIB_IPFORWARDTABLE,table[0]) + \
             ((X) * sizeof(MIB_IPFORWARDROW)) + ALIGN_SIZE)


typedef enum {
    MIB_IPNET_TYPE_OTHER   = 1,
    MIB_IPNET_TYPE_INVALID = 2,
    MIB_IPNET_TYPE_DYNAMIC = 3,
    MIB_IPNET_TYPE_STATIC  = 4,
} MIB_IPNET_TYPE;

typedef struct _MIB_IPNETROW_LH {
    IF_INDEX dwIndex;
    DWORD dwPhysAddrLen;
    UCHAR bPhysAddr[MAXLEN_PHYSADDR];
    DWORD dwAddr;
    union {
        DWORD dwType;           // Old field name was just a DWORD.
        MIB_IPNET_TYPE Type;    // New field name uses the enum type.
    };
} MIB_IPNETROW_LH, *PMIB_IPNETROW_LH;

typedef struct _MIB_IPNETROW_W2K {
    IF_INDEX dwIndex;
    DWORD dwPhysAddrLen;
    UCHAR bPhysAddr[MAXLEN_PHYSADDR];
    DWORD dwAddr;
    DWORD dwType;
} MIB_IPNETROW_W2K, *PMIB_IPNETROW_W2K;


#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef MIB_IPNETROW_LH MIB_IPNETROW;
typedef MIB_IPNETROW_LH *PMIB_IPNETROW;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPNETROW_W2K MIB_IPNETROW;
typedef MIB_IPNETROW_W2K *PMIB_IPNETROW;
#else
typedef MIB_IPNETROW_LH MIB_IPNETROW;
typedef MIB_IPNETROW_LH *PMIB_IPNETROW;
#endif

typedef struct _MIB_IPNETTABLE {
    DWORD dwNumEntries;
    MIB_IPNETROW table[ANY_SIZE];
} MIB_IPNETTABLE, *PMIB_IPNETTABLE;

#define SIZEOF_IPNETTABLE(X) (FIELD_OFFSET(MIB_IPNETTABLE, table[0]) + \
                              ((X) * sizeof(MIB_IPNETROW)) + ALIGN_SIZE)

typedef enum {
    MIB_IP_FORWARDING     = 1,
    MIB_IP_NOT_FORWARDING = 2,
} MIB_IPSTATS_FORWARDING, *PMIB_IPSTATS_FORWARDING;

#define MIB_USE_CURRENT_TTL         ((DWORD)-1)
#define MIB_USE_CURRENT_FORWARDING  ((DWORD)-1)

typedef struct _MIB_IPSTATS_LH {
    union {
        DWORD dwForwarding;
        MIB_IPSTATS_FORWARDING Forwarding;
    };
    DWORD dwDefaultTTL;
    DWORD dwInReceives;
    DWORD dwInHdrErrors;
    DWORD dwInAddrErrors;
    DWORD dwForwDatagrams;
    DWORD dwInUnknownProtos;
    DWORD dwInDiscards;
    DWORD dwInDelivers;
    DWORD dwOutRequests;
    DWORD dwRoutingDiscards;
    DWORD dwOutDiscards;
    DWORD dwOutNoRoutes;
    DWORD dwReasmTimeout;
    DWORD dwReasmReqds;
    DWORD dwReasmOks;
    DWORD dwReasmFails;
    DWORD dwFragOks;
    DWORD dwFragFails;
    DWORD dwFragCreates;
    DWORD dwNumIf;
    DWORD dwNumAddr;
    DWORD dwNumRoutes;
} MIB_IPSTATS_LH, *PMIB_IPSTATS_LH;

typedef struct _MIB_IPSTATS_W2K {
    DWORD dwForwarding;
    DWORD dwDefaultTTL;
    DWORD dwInReceives;
    DWORD dwInHdrErrors;
    DWORD dwInAddrErrors;
    DWORD dwForwDatagrams;
    DWORD dwInUnknownProtos;
    DWORD dwInDiscards;
    DWORD dwInDelivers;
    DWORD dwOutRequests;
    DWORD dwRoutingDiscards;
    DWORD dwOutDiscards;
    DWORD dwOutNoRoutes;
    DWORD dwReasmTimeout;
    DWORD dwReasmReqds;
    DWORD dwReasmOks;
    DWORD dwReasmFails;
    DWORD dwFragOks;
    DWORD dwFragFails;
    DWORD dwFragCreates;
    DWORD dwNumIf;
    DWORD dwNumAddr;
    DWORD dwNumRoutes;
} MIB_IPSTATS_W2K, *PMIB_IPSTATS_W2K;

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef MIB_IPSTATS_LH MIB_IPSTATS;
typedef MIB_IPSTATS_LH *PMIB_IPSTATS;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPSTATS_W2K MIB_IPSTATS;
typedef MIB_IPSTATS_W2K *PMIB_IPSTATS;
#endif

typedef struct _MIBICMPSTATS {
    DWORD dwMsgs;
    DWORD dwErrors;
    DWORD dwDestUnreachs;
    DWORD dwTimeExcds;
    DWORD dwParmProbs;
    DWORD dwSrcQuenchs;
    DWORD dwRedirects;
    DWORD dwEchos;
    DWORD dwEchoReps;
    DWORD dwTimestamps;
    DWORD dwTimestampReps;
    DWORD dwAddrMasks;
    DWORD dwAddrMaskReps;
} MIBICMPSTATS, *PMIBICMPSTATS;

typedef struct _MIBICMPINFO {
    MIBICMPSTATS icmpInStats;
    MIBICMPSTATS icmpOutStats;
} MIBICMPINFO;

typedef struct _MIB_ICMP {
    MIBICMPINFO stats;
} MIB_ICMP,*PMIB_ICMP;

typedef struct _MIBICMPSTATS_EX_XPSP1 {
    DWORD dwMsgs;
    DWORD dwErrors;
    DWORD rgdwTypeCount[256];
} MIBICMPSTATS_EX_XPSP1, *PMIBICMPSTATS_EX_XPSP1;
#if (NTDDI_VERSION >= NTDDI_XPSP1)
typedef  MIBICMPSTATS_EX_XPSP1 MIBICMPSTATS_EX;
typedef  MIBICMPSTATS_EX_XPSP1 *PMIBICMPSTATS_EX;
#endif

typedef struct _MIB_ICMP_EX_XPSP1 {
    MIBICMPSTATS_EX icmpInStats;
    MIBICMPSTATS_EX icmpOutStats;
} MIB_ICMP_EX_XPSP1,*PMIB_ICMP_EX_XPSP1;
#if (NTDDI_VERSION >= NTDDI_XPSP1)
typedef  MIB_ICMP_EX_XPSP1 MIB_ICMP_EX;
typedef  MIB_ICMP_EX_XPSP1 *PMIB_ICMP_EX;
#else
//
// Still need these in case application does not set
// NTDDI_VERSION to one of the above.
//
typedef  MIB_ICMP_EX_XPSP1 MIB_ICMP_EX;
typedef  MIB_ICMP_EX_XPSP1 *PMIB_ICMP_EX;
#endif

//
// ICMP6_TYPE
//
// ICMPv6 Type Values from RFC 2292, 2461 (ND), and 3810 (MLDv2)
//
typedef enum {
    ICMP6_DST_UNREACH          =   1,
    ICMP6_PACKET_TOO_BIG       =   2,
    ICMP6_TIME_EXCEEDED        =   3,
    ICMP6_PARAM_PROB           =   4,
    ICMP6_ECHO_REQUEST         = 128,
    ICMP6_ECHO_REPLY           = 129,
    ICMP6_MEMBERSHIP_QUERY     = 130,
    ICMP6_MEMBERSHIP_REPORT    = 131,
    ICMP6_MEMBERSHIP_REDUCTION = 132,
    ND_ROUTER_SOLICIT          = 133,
    ND_ROUTER_ADVERT           = 134,
    ND_NEIGHBOR_SOLICIT        = 135,
    ND_NEIGHBOR_ADVERT         = 136,
    ND_REDIRECT                = 137,
    ICMP6_V2_MEMBERSHIP_REPORT = 143,
} ICMP6_TYPE, *PICMP6_TYPE;


//
// Used to identify informational/error messages.
//
#define ICMP6_INFOMSG_MASK 0x80
#define ICMP6_ISTYPEINFORMATIONAL(Type) (((Type) & ICMP6_INFOMSG_MASK) != 0)
#define ICMP6_ISTYPEERROR(Type) (!ICMP6_ISTYPEINFORMATIONAL(Type))

//
// ICMP4_TYPE
//
// There are no RFC-specified defines for ICMPv4 message types, so we try to
// use the ICMP6 values from RFC 2292 modified to be prefixed with ICMP4.
//
typedef enum {
    ICMP4_ECHO_REPLY        =  0, // Echo Reply.
    ICMP4_DST_UNREACH       =  3, // Destination Unreachable.
    ICMP4_SOURCE_QUENCH     =  4, // Source Quench.
    ICMP4_REDIRECT          =  5, // Redirect.
    ICMP4_ECHO_REQUEST      =  8, // Echo Request.
    ICMP4_ROUTER_ADVERT     =  9, // Router Advertisement.
    ICMP4_ROUTER_SOLICIT    = 10, // Router Solicitation.
    ICMP4_TIME_EXCEEDED     = 11, // Time Exceeded.
    ICMP4_PARAM_PROB        = 12, // Parameter Problem.
    ICMP4_TIMESTAMP_REQUEST = 13, // Timestamp Request.
    ICMP4_TIMESTAMP_REPLY   = 14, // Timestamp Reply.
    ICMP4_MASK_REQUEST      = 17, // Address Mask Request.
    ICMP4_MASK_REPLY        = 18, // Address Mask Reply.
} ICMP4_TYPE, *PICMP4_TYPE;

//
// See RFC 1812, section 4.3.1.
//
#define ICMP4_ISTYPEERROR(Type) \
    (((Type) == ICMP4_DST_UNREACH) || \
     ((Type) == ICMP4_SOURCE_QUENCH) || \
     ((Type) == ICMP4_REDIRECT) || \
     ((Type) == ICMP4_PARAM_PROB) || \
     ((Type) == ICMP4_TIME_EXCEEDED)) \

typedef struct _MIB_IPMCAST_OIF_XP {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    DWORD   dwReserved;
    DWORD   dwReserved1;
} MIB_IPMCAST_OIF_XP, *PMIB_IPMCAST_OIF_XP ;

typedef struct _MIB_IPMCAST_OIF_W2K {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    PVOID   pvReserved;
    DWORD   dwReserved;
} MIB_IPMCAST_OIF_W2K, *PMIB_IPMCAST_OIF_W2K;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_IPMCAST_OIF_XP MIB_IPMCAST_OIF;
typedef MIB_IPMCAST_OIF_XP *PMIB_IPMCAST_OIF;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPMCAST_OIF_W2K MIB_IPMCAST_OIF;
typedef MIB_IPMCAST_OIF_W2K *PMIB_IPMCAST_OIF;
#else
typedef MIB_IPMCAST_OIF_XP MIB_IPMCAST_OIF;
typedef MIB_IPMCAST_OIF_XP *PMIB_IPMCAST_OIF;
#endif

typedef struct _MIB_IPMCAST_MFE {
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulTimeOut;
    ULONG   ulNumOutIf;
    DWORD   fFlags;
    DWORD   dwReserved;
    MIB_IPMCAST_OIF rgmioOutInfo[ANY_SIZE];
} MIB_IPMCAST_MFE, *PMIB_IPMCAST_MFE;

typedef struct _MIB_MFE_TABLE {
    DWORD           dwNumEntries;
    MIB_IPMCAST_MFE table[ANY_SIZE];
} MIB_MFE_TABLE, *PMIB_MFE_TABLE;


#define SIZEOF_BASIC_MIB_MFE          \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE, rgmioOutInfo[0]))

#define SIZEOF_MIB_MFE(X)             \
    (SIZEOF_BASIC_MIB_MFE + ((X) * sizeof(MIB_IPMCAST_OIF)))


typedef struct _MIB_IPMCAST_OIF_STATS_LH {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    DWORD   dwDialContext;
    ULONG   ulTtlTooLow;
    ULONG   ulFragNeeded;
    ULONG   ulOutPackets;
    ULONG   ulOutDiscards;
} MIB_IPMCAST_OIF_STATS_LH, *PMIB_IPMCAST_OIF_STATS_LH;

typedef struct _MIB_IPMCAST_OIF_STATS_W2K {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    PVOID   pvDialContext;
    ULONG   ulTtlTooLow;
    ULONG   ulFragNeeded;
    ULONG   ulOutPackets;
    ULONG   ulOutDiscards;
} MIB_IPMCAST_OIF_STATS_W2K, *PMIB_IPMCAST_OIF_STATS_W2K;

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef  MIB_IPMCAST_OIF_STATS_LH MIB_IPMCAST_OIF_STATS;
typedef  MIB_IPMCAST_OIF_STATS_LH *PMIB_IPMCAST_OIF_STATS;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef  MIB_IPMCAST_OIF_STATS_W2K MIB_IPMCAST_OIF_STATS;
typedef  MIB_IPMCAST_OIF_STATS_W2K *PMIB_IPMCAST_OIF_STATS;
#else
typedef  MIB_IPMCAST_OIF_STATS_LH MIB_IPMCAST_OIF_STATS;
typedef  MIB_IPMCAST_OIF_STATS_LH *PMIB_IPMCAST_OIF_STATS;
#endif

typedef struct _MIB_IPMCAST_MFE_STATS {
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulNumOutIf;
    ULONG   ulInPkts;
    ULONG   ulInOctets;
    ULONG   ulPktsDifferentIf;
    ULONG   ulQueueOverflow;

    MIB_IPMCAST_OIF_STATS   rgmiosOutStats[ANY_SIZE];
} MIB_IPMCAST_MFE_STATS, *PMIB_IPMCAST_MFE_STATS;

typedef struct _MIB_MFE_STATS_TABLE {
    DWORD       dwNumEntries;
    MIB_IPMCAST_MFE_STATS   table[ANY_SIZE];
} MIB_MFE_STATS_TABLE, *PMIB_MFE_STATS_TABLE;

#define SIZEOF_BASIC_MIB_MFE_STATS    \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS, rgmiosOutStats[0]))

#define SIZEOF_MIB_MFE_STATS(X)       \
    (SIZEOF_BASIC_MIB_MFE_STATS + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))


typedef struct _MIB_IPMCAST_MFE_STATS_EX_XP {
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulNumOutIf;
    ULONG   ulInPkts;
    ULONG   ulInOctets;
    ULONG   ulPktsDifferentIf;
    ULONG   ulQueueOverflow;
    ULONG   ulUninitMfe;
    ULONG   ulNegativeMfe;
    ULONG   ulInDiscards;
    ULONG   ulInHdrErrors;
    ULONG   ulTotalOutPackets;

    MIB_IPMCAST_OIF_STATS   rgmiosOutStats[ANY_SIZE];
} MIB_IPMCAST_MFE_STATS_EX_XP,
 *PMIB_IPMCAST_MFE_STATS_EX_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_IPMCAST_MFE_STATS_EX_XP MIB_IPMCAST_MFE_STATS_EX;
typedef MIB_IPMCAST_MFE_STATS_EX_XP *PMIB_IPMCAST_MFE_STATS_EX;
#endif

typedef struct _MIB_MFE_STATS_TABLE_EX_XP {
    DWORD       dwNumEntries;
    PMIB_IPMCAST_MFE_STATS_EX_XP   table[ANY_SIZE];
} MIB_MFE_STATS_TABLE_EX_XP, *PMIB_MFE_STATS_TABLE_EX_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_MFE_STATS_TABLE_EX_XP MIB_MFE_STATS_TABLE_EX;
typedef MIB_MFE_STATS_TABLE_EX_XP *PMIB_MFE_STATS_TABLE_EX;

#define SIZEOF_BASIC_MIB_MFE_STATS_EX    \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS_EX, rgmiosOutStats[0]))

#define SIZEOF_MIB_MFE_STATS_EX(X)       \
    (SIZEOF_BASIC_MIB_MFE_STATS_EX + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))
#endif

typedef struct _MIB_IPMCAST_GLOBAL {
    DWORD   dwEnable;
} MIB_IPMCAST_GLOBAL, *PMIB_IPMCAST_GLOBAL;

typedef struct _MIB_IPMCAST_IF_ENTRY {
    DWORD   dwIfIndex;
    DWORD   dwTtl;
    DWORD   dwProtocol;
    DWORD   dwRateLimit;
    ULONG   ulInMcastOctets;
    ULONG   ulOutMcastOctets;
} MIB_IPMCAST_IF_ENTRY, *PMIB_IPMCAST_IF_ENTRY;

typedef struct _MIB_IPMCAST_IF_TABLE {
    DWORD       dwNumEntries;
    MIB_IPMCAST_IF_ENTRY   table[ANY_SIZE];
} MIB_IPMCAST_IF_TABLE, *PMIB_IPMCAST_IF_TABLE;

#define SIZEOF_MCAST_IF_TABLE(X) \
    (FIELD_OFFSET(MIB_IPMCAST_IF_TABLE, table[0]) +  \
     ((X) * sizeof(MIB_IPMCAST_IF_ENTRY)) +  \
     ALIGN_SIZE)

#endif // _IPMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\irapistream.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* at Fri Sep 17 22:09:50 2004
 */
/* Compiler settings for ..\IRAPIStream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __IRAPIStream_h__
#define __IRAPIStream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRAPIStream_FWD_DEFINED__
#define __IRAPIStream_FWD_DEFINED__
typedef interface IRAPIStream IRAPIStream;
#endif     /* __IRAPIStream_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "rapitypes.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IRAPIStream_INTERFACE_DEFINED__
#define __IRAPIStream_INTERFACE_DEFINED__

/* interface IRAPIStream */
/* [object][uuid] */ 


EXTERN_C const IID IID_IRAPIStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("449FE623-24B0-454b-A889-129BB05DDBED")
    IRAPIStream : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRapiStat( 
            /* [in] */ RAPISTREAMFLAG Flag,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRapiStat( 
            /* [in] */ RAPISTREAMFLAG Flag,
            /* [out] */ DWORD *pdwValue) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct IRAPIStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRAPIStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRAPIStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRAPIStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IRAPIStream * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IRAPIStream * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IRAPIStream * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IRAPIStream * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IRAPIStream * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IRAPIStream * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IRAPIStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IRAPIStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IRAPIStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IRAPIStream * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IRAPIStream * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *SetRapiStat )( 
            IRAPIStream * This,
            /* [in] */ RAPISTREAMFLAG Flag,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetRapiStat )( 
            IRAPIStream * This,
            /* [in] */ RAPISTREAMFLAG Flag,
            /* [out] */ DWORD *pdwValue);
        
        END_INTERFACE
    } IRAPIStreamVtbl;

    interface IRAPIStream
    {
        CONST_VTBL struct IRAPIStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRAPIStream_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRAPIStream_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IRAPIStream_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IRAPIStream_Read(This,pv,cb,pcbRead)    \
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IRAPIStream_Write(This,pv,cb,pcbWritten)    \
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define IRAPIStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)    \
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IRAPIStream_SetSize(This,libNewSize)    \
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IRAPIStream_CopyTo(This,pstm,cb,pcbRead,pcbWritten)    \
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IRAPIStream_Commit(This,grfCommitFlags)    \
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IRAPIStream_Revert(This)    \
    (This)->lpVtbl -> Revert(This)

#define IRAPIStream_LockRegion(This,libOffset,cb,dwLockType)    \
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IRAPIStream_UnlockRegion(This,libOffset,cb,dwLockType)    \
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IRAPIStream_Stat(This,pstatstg,grfStatFlag)    \
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IRAPIStream_Clone(This,ppstm)    \
    (This)->lpVtbl -> Clone(This,ppstm)


#define IRAPIStream_SetRapiStat(This,Flag,dwValue)    \
    (This)->lpVtbl -> SetRapiStat(This,Flag,dwValue)

#define IRAPIStream_GetRapiStat(This,Flag,pdwValue)    \
    (This)->lpVtbl -> GetRapiStat(This,Flag,pdwValue)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE IRAPIStream_SetRapiStat_Proxy( 
    IRAPIStream * This,
    /* [in] */ RAPISTREAMFLAG Flag,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IRAPIStream_SetRapiStat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRAPIStream_GetRapiStat_Proxy( 
    IRAPIStream * This,
    /* [in] */ RAPISTREAMFLAG Flag,
    /* [out] */ DWORD *pdwValue);


void __RPC_STUB IRAPIStream_GetRapiStat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __IRAPIStream_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ipsectypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for ipsectypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ipsectypes_h__
#define __ipsectypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"
#include "iketypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ipsectypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct FWPM_FILTER0_ FWPM_FILTER0;

typedef struct IPSEC_SA_LIFETIME0_
    {
    UINT32 lifetimeSeconds;
    UINT32 lifetimeKilobytes;
    UINT32 lifetimePackets;
    } 	IPSEC_SA_LIFETIME0;

typedef /* [v1_enum] */ 
enum IPSEC_TRANSFORM_TYPE_
    {	IPSEC_TRANSFORM_AH	= 1,
	IPSEC_TRANSFORM_ESP_AUTH	= ( IPSEC_TRANSFORM_AH + 1 ) ,
	IPSEC_TRANSFORM_ESP_CIPHER	= ( IPSEC_TRANSFORM_ESP_AUTH + 1 ) ,
	IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER	= ( IPSEC_TRANSFORM_ESP_CIPHER + 1 ) ,
	IPSEC_TRANSFORM_TYPE_MAX	= ( IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER + 1 ) 
    } 	IPSEC_TRANSFORM_TYPE;

typedef /* [v1_enum] */ 
enum IPSEC_AUTH_TYPE_
    {	IPSEC_AUTH_MD5	= 0,
	IPSEC_AUTH_SHA_1	= ( IPSEC_AUTH_MD5 + 1 ) ,
	IPSEC_AUTH_SHA_256	= ( IPSEC_AUTH_SHA_1 + 1 ) ,
	IPSEC_AUTH_AES_128	= ( IPSEC_AUTH_SHA_256 + 1 ) ,
	IPSEC_AUTH_AES_192	= ( IPSEC_AUTH_AES_128 + 1 ) ,
	IPSEC_AUTH_AES_256	= ( IPSEC_AUTH_AES_192 + 1 ) ,
	IPSEC_AUTH_MAX	= ( IPSEC_AUTH_AES_256 + 1 ) 
    } 	IPSEC_AUTH_TYPE;

typedef UINT8 IPSEC_AUTH_CONFIG;

#define IPSEC_AUTH_CONFIG_HMAC_MD5_96         (0)
#define IPSEC_AUTH_CONFIG_HMAC_SHA_1_96       (1)
#define IPSEC_AUTH_CONFIG_HMAC_SHA_256_128    (2)
#define IPSEC_AUTH_CONFIG_GCM_AES_128         (3)
#define IPSEC_AUTH_CONFIG_GCM_AES_192         (4)
#define IPSEC_AUTH_CONFIG_GCM_AES_256         (5)
#define IPSEC_AUTH_CONFIG_MAX                 (6)
typedef struct IPSEC_AUTH_TRANSFORM_ID0_
    {
    IPSEC_AUTH_TYPE authType;
    IPSEC_AUTH_CONFIG authConfig;
    } 	IPSEC_AUTH_TRANSFORM_ID0;

typedef GUID IPSEC_CRYPTO_MODULE_ID;

typedef struct IPSEC_AUTH_TRANSFORM0_
    {
    IPSEC_AUTH_TRANSFORM_ID0 authTransformId;
    IPSEC_CRYPTO_MODULE_ID *cryptoModuleId;
    } 	IPSEC_AUTH_TRANSFORM0;

typedef /* [v1_enum] */ 
enum IPSEC_CIPHER_TYPE_
    {	IPSEC_CIPHER_TYPE_DES	= 1,
	IPSEC_CIPHER_TYPE_3DES	= ( IPSEC_CIPHER_TYPE_DES + 1 ) ,
	IPSEC_CIPHER_TYPE_AES_128	= ( IPSEC_CIPHER_TYPE_3DES + 1 ) ,
	IPSEC_CIPHER_TYPE_AES_192	= ( IPSEC_CIPHER_TYPE_AES_128 + 1 ) ,
	IPSEC_CIPHER_TYPE_AES_256	= ( IPSEC_CIPHER_TYPE_AES_192 + 1 ) ,
	IPSEC_CIPHER_TYPE_MAX	= ( IPSEC_CIPHER_TYPE_AES_256 + 1 ) 
    } 	IPSEC_CIPHER_TYPE;

typedef UINT8 IPSEC_CIPHER_CONFIG;

#define IPSEC_CIPHER_CONFIG_CBC_DES      (1)
#define IPSEC_CIPHER_CONFIG_CBC_3DES     (2)
#define IPSEC_CIPHER_CONFIG_CBC_AES_128  (3)
#define IPSEC_CIPHER_CONFIG_CBC_AES_192  (4)
#define IPSEC_CIPHER_CONFIG_CBC_AES_256  (5)
#define IPSEC_CIPHER_CONFIG_GCM_AES_128  (6)
#define IPSEC_CIPHER_CONFIG_GCM_AES_192  (7)
#define IPSEC_CIPHER_CONFIG_GCM_AES_256  (8)
#define IPSEC_CIPHER_CONFIG_MAX          (9)
typedef struct IPSEC_CIPHER_TRANSFORM_ID0_
    {
    IPSEC_CIPHER_TYPE cipherType;
    IPSEC_CIPHER_CONFIG cipherConfig;
    } 	IPSEC_CIPHER_TRANSFORM_ID0;

typedef struct IPSEC_CIPHER_TRANSFORM0_
    {
    IPSEC_CIPHER_TRANSFORM_ID0 cipherTransformId;
    IPSEC_CRYPTO_MODULE_ID *cryptoModuleId;
    } 	IPSEC_CIPHER_TRANSFORM0;

typedef struct IPSEC_AUTH_AND_CIPHER_TRANSFORM0_
    {
    IPSEC_AUTH_TRANSFORM0 authTransform;
    IPSEC_CIPHER_TRANSFORM0 cipherTransform;
    } 	IPSEC_AUTH_AND_CIPHER_TRANSFORM0;

typedef struct IPSEC_SA_TRANSFORM0_
    {
    IPSEC_TRANSFORM_TYPE ipsecTransformType;
    union 
        {
        IPSEC_AUTH_TRANSFORM0 *ahTransform;
        IPSEC_AUTH_TRANSFORM0 *espAuthTranform;
        IPSEC_CIPHER_TRANSFORM0 *espCipherTransform;
        IPSEC_AUTH_AND_CIPHER_TRANSFORM0 *espAuthAndCipherTransform;
        } 	;
    } 	IPSEC_SA_TRANSFORM0;

typedef /* [v1_enum] */ 
enum IPSEC_PFS_GROUP_
    {	IPSEC_PFS_NONE	= 0,
	IPSEC_PFS_1	= ( IPSEC_PFS_NONE + 1 ) ,
	IPSEC_PFS_2	= ( IPSEC_PFS_1 + 1 ) ,
	IPSEC_PFS_2048	= ( IPSEC_PFS_2 + 1 ) ,
	IPSEC_PFS_ECP_256	= ( IPSEC_PFS_2048 + 1 ) ,
	IPSEC_PFS_ECP_384	= ( IPSEC_PFS_ECP_256 + 1 ) ,
	IPSEC_PFS_MM	= ( IPSEC_PFS_ECP_384 + 1 ) ,
	IPSEC_PFS_MAX	= ( IPSEC_PFS_MM + 1 ) 
    } 	IPSEC_PFS_GROUP;

typedef struct IPSEC_PROPOSAL0_
    {
    IPSEC_SA_LIFETIME0 lifetime;
    UINT32 numSaTransforms;
    IPSEC_SA_TRANSFORM0 *saTransforms;
    IPSEC_PFS_GROUP pfsGroup;
    } 	IPSEC_PROPOSAL0;

typedef struct IPSEC_SA_IDLE_TIMEOUT0_
    {
    UINT32 idleTimeoutSeconds;
    UINT32 idleTimeoutSecondsFailOver;
    } 	IPSEC_SA_IDLE_TIMEOUT0;

#define IPSEC_POLICY_FLAG_ND_SECURE     (0x00000002)
#define IPSEC_POLICY_FLAG_ND_BOUNDARY   (0x00000004)
#define IPSEC_POLICY_FLAG_CLEAR_DF_ON_TUNNEL   (0x00000008)
#define IPSEC_POLICY_FLAG_NAT_ENCAP_ALLOW_PEER_BEHIND_NAT   (0x00000010)
#define IPSEC_POLICY_FLAG_NAT_ENCAP_ALLOW_GENERAL_NAT_TRAVERSAL   (0x00000020)
#define IPSEC_POLICY_FLAG_DONT_NEGOTIATE_SECOND_LIFETIME   (0x00000040)
#define IPSEC_POLICY_FLAG_DONT_NEGOTIATE_BYTE_LIFETIME   (0x00000080)
typedef struct IPSEC_TRANSPORT_POLICY0_
    {
    UINT32 numIpsecProposals;
    IPSEC_PROPOSAL0 *ipsecProposals;
    UINT32 flags;
    UINT32 ndAllowClearTimeoutSeconds;
    IPSEC_SA_IDLE_TIMEOUT0 saIdleTimeout;
    IKEEXT_EM_POLICY0 *emPolicy;
    } 	IPSEC_TRANSPORT_POLICY0;

typedef struct IPSEC_TUNNEL_ENDPOINTS0_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    } 	IPSEC_TUNNEL_ENDPOINTS0;

typedef struct IPSEC_TUNNEL_POLICY0_
    {
    UINT32 flags;
    UINT32 numIpsecProposals;
    IPSEC_PROPOSAL0 *ipsecProposals;
    IPSEC_TUNNEL_ENDPOINTS0 tunnelEndpoints;
    IPSEC_SA_IDLE_TIMEOUT0 saIdleTimeout;
    IKEEXT_EM_POLICY0 *emPolicy;
    } 	IPSEC_TUNNEL_POLICY0;

typedef struct IPSEC_KEYING_POLICY0_
    {
    UINT32 numKeyMods;
    GUID *keyModKeys;
    } 	IPSEC_KEYING_POLICY0;

typedef struct IPSEC_AGGREGATE_SA_STATISTICS0_
    {
    UINT32 activeSas;
    UINT32 pendingSaNegotiations;
    UINT32 totalSasAdded;
    UINT32 totalSasDeleted;
    UINT32 successfulRekeys;
    UINT32 activeTunnels;
    UINT32 offloadedSas;
    } 	IPSEC_AGGREGATE_SA_STATISTICS0;

typedef struct IPSEC_ESP_DROP_PACKET_STATISTICS0_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 decryptionFailuresOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 saNotInitializedOnInbound;
    } 	IPSEC_ESP_DROP_PACKET_STATISTICS0;

typedef struct IPSEC_AH_DROP_PACKET_STATISTICS0_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 saNotInitializedOnInbound;
    } 	IPSEC_AH_DROP_PACKET_STATISTICS0;

typedef struct IPSEC_AGGREGATE_DROP_PACKET_STATISTICS0_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 decryptionFailuresOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 udpEspValidationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 invalidClearTextInbound;
    UINT32 saNotInitializedOnInbound;
    UINT32 receiveOverIncorrectSaInbound;
    UINT32 secureReceivesNotMatchingFilters;
    } 	IPSEC_AGGREGATE_DROP_PACKET_STATISTICS0;

typedef struct IPSEC_TRAFFIC_STATISTICS0_
    {
    UNALIGNEDUINT64 encryptedByteCount;
    UNALIGNEDUINT64 authenticatedAHByteCount;
    UNALIGNEDUINT64 authenticatedESPByteCount;
    UNALIGNEDUINT64 transportByteCount;
    UNALIGNEDUINT64 tunnelByteCount;
    UNALIGNEDUINT64 offloadByteCount;
    } 	IPSEC_TRAFFIC_STATISTICS0;

typedef struct IPSEC_STATISTICS0_
    {
    IPSEC_AGGREGATE_SA_STATISTICS0 aggregateSaStatistics;
    IPSEC_ESP_DROP_PACKET_STATISTICS0 espDropPacketStatistics;
    IPSEC_AH_DROP_PACKET_STATISTICS0 ahDropPacketStatistics;
    IPSEC_AGGREGATE_DROP_PACKET_STATISTICS0 aggregateDropPacketStatistics;
    IPSEC_TRAFFIC_STATISTICS0 inboundTrafficStatistics;
    IPSEC_TRAFFIC_STATISTICS0 outboundTrafficStatistics;
    } 	IPSEC_STATISTICS0;

typedef UINT32 IPSEC_SA_SPI;

typedef struct IPSEC_SA_AUTH_INFORMATION0_
    {
    IPSEC_AUTH_TRANSFORM0 authTransform;
    FWP_BYTE_BLOB authKey;
    } 	IPSEC_SA_AUTH_INFORMATION0;

typedef struct IPSEC_SA_CIPHER_INFORMATION0_
    {
    IPSEC_CIPHER_TRANSFORM0 cipherTransform;
    FWP_BYTE_BLOB cipherKey;
    } 	IPSEC_SA_CIPHER_INFORMATION0;

typedef struct IPSEC_SA_AUTH_AND_CIPHER_INFORMATION0_
    {
    IPSEC_SA_CIPHER_INFORMATION0 saCipherInformation;
    IPSEC_SA_AUTH_INFORMATION0 saAuthInformation;
    } 	IPSEC_SA_AUTH_AND_CIPHER_INFORMATION0;

typedef struct IPSEC_SA0_
    {
    IPSEC_SA_SPI spi;
    IPSEC_TRANSFORM_TYPE saTransformType;
    union 
        {
        IPSEC_SA_AUTH_INFORMATION0 *ahInformation;
        IPSEC_SA_AUTH_INFORMATION0 *espAuthInformation;
        IPSEC_SA_CIPHER_INFORMATION0 *espCipherInformation;
        IPSEC_SA_AUTH_AND_CIPHER_INFORMATION0 *espAuthAndCipherInformation;
        } 	;
    } 	IPSEC_SA0;

typedef struct IPSEC_KEYMODULE_STATE0_
    {
    GUID keyModuleKey;
    FWP_BYTE_BLOB stateBlob;
    } 	IPSEC_KEYMODULE_STATE0;

#define IPSEC_SA_BUNDLE_FLAG_ND_SECURE (0x00000001)
#define IPSEC_SA_BUNDLE_FLAG_ND_BOUNDARY (0x00000002)
#define IPSEC_SA_BUNDLE_FLAG_ND_PEER_NAT_BOUNDARY (0x00000004)
#define IPSEC_SA_BUNDLE_FLAG_GUARANTEE_ENCRYPTION (0x00000008)
#define IPSEC_SA_BUNDLE_FLAG_NLB (0x00000010)
#define IPSEC_SA_BUNDLE_FLAG_NO_MACHINE_LUID_VERIFY (0x00000020)
#define IPSEC_SA_BUNDLE_FLAG_NO_IMPERSONATION_LUID_VERIFY (0x00000040)
#define IPSEC_SA_BUNDLE_FLAG_NO_EXPLICIT_CRED_MATCH (0x00000080)
#define IPSEC_SA_BUNDLE_FLAG_ALLOW_NULL_TARGET_NAME_MATCH (0x00000200)
#define IPSEC_SA_BUNDLE_FLAG_CLEAR_DF_ON_TUNNEL   (0x00000400)
#define IPSEC_SA_BUNDLE_FLAG_ASSUME_UDP_CONTEXT_OUTBOUND (0x00000800)
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define IPSEC_SA_BUNDLE_FLAG_ND_PEER_BOUNDARY (0x00001000)
#endif
typedef UNALIGNEDUINT64 IPSEC_TOKEN_HANDLE;

typedef /* [v1_enum] */ 
enum IPSEC_TOKEN_TYPE_
    {	IPSEC_TOKEN_TYPE_MACHINE	= 0,
	IPSEC_TOKEN_TYPE_IMPERSONATION	= ( IPSEC_TOKEN_TYPE_MACHINE + 1 ) ,
	IPSEC_TOKEN_TYPE_MAX	= ( IPSEC_TOKEN_TYPE_IMPERSONATION + 1 ) 
    } 	IPSEC_TOKEN_TYPE;

typedef /* [v1_enum] */ 
enum IPSEC_TOKEN_PRINCIPAL_
    {	IPSEC_TOKEN_PRINCIPAL_LOCAL	= 0,
	IPSEC_TOKEN_PRINCIPAL_PEER	= ( IPSEC_TOKEN_PRINCIPAL_LOCAL + 1 ) ,
	IPSEC_TOKEN_PRINCIPAL_MAX	= ( IPSEC_TOKEN_PRINCIPAL_PEER + 1 ) 
    } 	IPSEC_TOKEN_PRINCIPAL;

typedef /* [v1_enum] */ 
enum IPSEC_TOKEN_MODE_
    {	IPSEC_TOKEN_MODE_MAIN	= 0,
	IPSEC_TOKEN_MODE_EXTENDED	= ( IPSEC_TOKEN_MODE_MAIN + 1 ) ,
	IPSEC_TOKEN_MODE_MAX	= ( IPSEC_TOKEN_MODE_EXTENDED + 1 ) 
    } 	IPSEC_TOKEN_MODE;

typedef struct IPSEC_TOKEN0_
    {
    IPSEC_TOKEN_TYPE type;
    IPSEC_TOKEN_PRINCIPAL principal;
    IPSEC_TOKEN_MODE mode;
    IPSEC_TOKEN_HANDLE token;
    } 	IPSEC_TOKEN0;

typedef struct IPSEC_ID0_
    {
    wchar_t *mmTargetName;
    wchar_t *emTargetName;
    UINT32 numTokens;
    IPSEC_TOKEN0 *tokens;
    UNALIGNEDUINT64 explicitCredentials;
    UNALIGNEDUINT64 logonId;
    } 	IPSEC_ID0;

typedef struct IPSEC_SA_BUNDLE0_
    {
    UINT32 flags;
    IPSEC_SA_LIFETIME0 lifetime;
    UINT32 idleTimeoutSeconds;
    UINT32 ndAllowClearTimeoutSeconds;
    IPSEC_ID0 *ipsecId;
    UINT32 napContext;
    UINT32 qmSaId;
    UINT32 numSAs;
    IPSEC_SA0 *saList;
    IPSEC_KEYMODULE_STATE0 *keyModuleState;
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 peerV4PrivateAddress;
         /* Empty union arm */ 
        } 	;
    UNALIGNEDUINT64 mmSaId;
    IPSEC_PFS_GROUP pfsGroup;
    } 	IPSEC_SA_BUNDLE0;

typedef /* [v1_enum] */ 
enum IPSEC_TRAFFIC_TYPE_
    {	IPSEC_TRAFFIC_TYPE_TRANSPORT	= 0,
	IPSEC_TRAFFIC_TYPE_TUNNEL	= ( IPSEC_TRAFFIC_TYPE_TRANSPORT + 1 ) ,
	IPSEC_TRAFFIC_TYPE_MAX	= ( IPSEC_TRAFFIC_TYPE_TUNNEL + 1 ) 
    } 	IPSEC_TRAFFIC_TYPE;

typedef struct IPSEC_TRAFFIC0_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    IPSEC_TRAFFIC_TYPE trafficType;
    union 
        {
        UNALIGNEDUINT64 ipsecFilterId;
        UNALIGNEDUINT64 tunnelPolicyId;
        } 	;
    UINT16 remotePort;
    } 	IPSEC_TRAFFIC0;

typedef struct IPSEC_V4_UDP_ENCAPSULATION0_
    {
    UINT16 localUdpEncapPort;
    UINT16 remoteUdpEncapPort;
    } 	IPSEC_V4_UDP_ENCAPSULATION0;

typedef struct IPSEC_GETSPI0_
    {
    IPSEC_TRAFFIC0 inboundIpsecTraffic;
    FWP_IP_VERSION ipVersion;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *inboundUdpEncapsulation;
         /* Empty union arm */ 
        } 	;
    IPSEC_CRYPTO_MODULE_ID *rngCryptoModuleID;
    } 	IPSEC_GETSPI0;

typedef struct IPSEC_SA_DETAILS0_
    {
    FWP_IP_VERSION ipVersion;
    FWP_DIRECTION saDirection;
    IPSEC_TRAFFIC0 traffic;
    IPSEC_SA_BUNDLE0 saBundle;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *udpEncapsulation;
         /* Empty union arm */ 
        } 	;
    FWPM_FILTER0 *transportFilter;
    } 	IPSEC_SA_DETAILS0;

typedef struct IPSEC_SA_CONTEXT0_
    {
    UNALIGNEDUINT64 saContextId;
    IPSEC_SA_DETAILS0 *inboundSa;
    IPSEC_SA_DETAILS0 *outboundSa;
    } 	IPSEC_SA_CONTEXT0;

typedef struct IPSEC_SA_CONTEXT_ENUM_TEMPLATE0_
    {
    FWP_CONDITION_VALUE0 localSubNet;
    FWP_CONDITION_VALUE0 remoteSubNet;
    } 	IPSEC_SA_CONTEXT_ENUM_TEMPLATE0;

typedef struct IPSEC_SA_ENUM_TEMPLATE0_
    {
    FWP_DIRECTION saDirection;
    } 	IPSEC_SA_ENUM_TEMPLATE0;

typedef /* [v1_enum] */ 
enum IPSEC_FAILURE_POINT_
    {	IPSEC_FAILURE_NONE	= 0,
	IPSEC_FAILURE_ME	= ( IPSEC_FAILURE_NONE + 1 ) ,
	IPSEC_FAILURE_PEER	= ( IPSEC_FAILURE_ME + 1 ) ,
	IPSEC_FAILURE_POINT_MAX	= ( IPSEC_FAILURE_PEER + 1 ) 
    } 	IPSEC_FAILURE_POINT;

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_ipsectypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ipsectypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iprtrmib.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iprtrmib.h

Abstract:
    This file contains:
        o Definitions of the MIB_XX structures passed to and from the IP Router Manager
            to query and set MIB variables handled by the IP Router Manager
        o The #defines for the MIB variables IDs  handled by the IP Router Manager
            and made accessible by the MprAdminMIBXXX APIs
        o The Routing PID of the IP Router Manager (as mentioned in ipinfoid.h)

--*/

#ifndef __ROUTING_IPRTRMIB_H__
#define __ROUTING_IPRTRMIB_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Included to get the value of MAX_INTERFACE_NAME_LEN                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifdef UNDER_CE
#define MAX_INTERFACE_NAME_LEN  256
#else
#include <mprapi.h>
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Included to get the necessary constants                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <ipifcons.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This is the Id for IP Router Manager.  The Router Manager handles        //
// MIB-II, Forwarding MIB and some enterprise specific information.         //
// Calls made with any other ID are passed on to the corresponding protocol //
// For example, an MprAdminMIBXXX call with a protocol ID of PID_IP and    //
// a routing Id of 0xD will be sent to the IP Router Manager and then       //
// forwarded to OSPF                                                        //
// This lives in the same number space as the protocol Ids of RIP, OSPF     //
// etc, so any change made to it should be done keeping this in mind        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IPRTRMGR_PID 10000

#ifndef ANY_SIZE

#define ANY_SIZE 1

#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following #defines are the Ids of the MIB variables made accessible  //
// to the user via MprAdminMIBXXX Apis.  It will be noticed that these are  //
// not the same as RFC 1213, since the MprAdminMIBXXX APIs work on rows and //
// groups instead of scalar variables                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IF_NUMBER           0
#define IF_TABLE            (IF_NUMBER          + 1)
#define IF_ROW              (IF_TABLE           + 1)
#define IP_STATS            (IF_ROW             + 1)
#define IP_ADDRTABLE        (IP_STATS           + 1)
#define IP_ADDRROW          (IP_ADDRTABLE       + 1)
#define IP_FORWARDNUMBER    (IP_ADDRROW         + 1)
#define IP_FORWARDTABLE     (IP_FORWARDNUMBER   + 1)
#define IP_FORWARDROW       (IP_FORWARDTABLE    + 1)
#define IP_NETTABLE         (IP_FORWARDROW      + 1)
#define IP_NETROW           (IP_NETTABLE        + 1)
#define ICMP_STATS          (IP_NETROW          + 1)
#define TCP_STATS           (ICMP_STATS         + 1)
#define TCP_TABLE           (TCP_STATS          + 1)
#define TCP_ROW             (TCP_TABLE          + 1)
#define UDP_STATS           (TCP_ROW            + 1)
#define UDP_TABLE           (UDP_STATS          + 1)
#define UDP_ROW             (UDP_TABLE          + 1)
#define MCAST_MFE           (UDP_ROW            + 1)
#define MCAST_MFE_STATS     (MCAST_MFE          + 1)
#define BEST_IF             (MCAST_MFE_STATS    + 1)
#define BEST_ROUTE          (BEST_IF            + 1)
#define PROXY_ARP           (BEST_ROUTE         + 1)
#define MCAST_IF_ENTRY      (PROXY_ARP          + 1)
#define MCAST_GLOBAL        (MCAST_IF_ENTRY     + 1)
#define IF_STATUS           (MCAST_GLOBAL       + 1)
#define MCAST_BOUNDARY      (IF_STATUS          + 1)
#define MCAST_SCOPE         (MCAST_BOUNDARY     + 1)
#define DEST_MATCHING       (MCAST_SCOPE        + 1)
#define DEST_LONGER         (DEST_MATCHING      + 1)
#define DEST_SHORTER        (DEST_LONGER        + 1)
#define ROUTE_MATCHING      (DEST_SHORTER       + 1)
#define ROUTE_LONGER        (ROUTE_MATCHING     + 1)
#define ROUTE_SHORTER       (ROUTE_LONGER       + 1)
#define ROUTE_STATE         (ROUTE_SHORTER      + 1)
#define MCAST_MFE_STATS_EX  (ROUTE_STATE        + 1)
#define IP6_STATS           (MCAST_MFE_STATS_EX + 1)
#define UDP6_STATS          (IP6_STATS          + 1)
#define TCP6_STATS          (UDP6_STATS         + 1)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define NUMBER_OF_EXPORTED_VARIABLES    (TCP6_STATS + 1)
#else
#define NUMBER_OF_EXPORTED_VARIABLES    (ROUTE_STATE + 1)
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// MIB_OPAQUE_QUERY is the structure filled in by the user to identify a    //
// MIB variable                                                             //
//                                                                          //
//  dwVarId     ID of MIB Variable (One of the Ids #defined above)          //
//  dwVarIndex  Variable sized array containing the indices needed to       //
//              identify a variable. NOTE: Unlike SNMP we dont require that //
//              a scalar variable be indexed by 0                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _MIB_OPAQUE_QUERY
{
    DWORD  dwVarId;
    DWORD  rgdwVarIndex[ANY_SIZE];
}MIB_OPAQUE_QUERY, *PMIB_OPAQUE_QUERY;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the structures which are filled in and returned to the //
// user when a query is made, OR  are filled in BY THE USER when a set is   //
// done                                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <ipmib.h>
#include <tcpmib.h>
#include <udpmib.h>

typedef enum _TCP_TABLE_CLASS {
    TCP_TABLE_BASIC_LISTENER,
    TCP_TABLE_BASIC_CONNECTIONS,
    TCP_TABLE_BASIC_ALL,
    TCP_TABLE_OWNER_PID_LISTENER,
    TCP_TABLE_OWNER_PID_CONNECTIONS,
    TCP_TABLE_OWNER_PID_ALL,
    TCP_TABLE_OWNER_MODULE_LISTENER,
    TCP_TABLE_OWNER_MODULE_CONNECTIONS,
    TCP_TABLE_OWNER_MODULE_ALL
} TCP_TABLE_CLASS, *PTCP_TABLE_CLASS;

typedef enum _UDP_TABLE_CLASS {
    UDP_TABLE_BASIC,
    UDP_TABLE_OWNER_PID,
    UDP_TABLE_OWNER_MODULE
} UDP_TABLE_CLASS, *PUDP_TABLE_CLASS;

typedef enum _TCPIP_OWNER_MODULE_INFO_CLASS {
    TCPIP_OWNER_MODULE_INFO_BASIC
} TCPIP_OWNER_MODULE_INFO_CLASS, *PTCPIP_OWNER_MODULE_INFO_CLASS;

typedef struct _TCPIP_OWNER_MODULE_BASIC_INFO {
    PWCHAR pModuleName;
    PWCHAR pModulePath;
} TCPIP_OWNER_MODULE_BASIC_INFO, *PTCPIP_OWNER_MODULE_BASIC_INFO;

typedef struct _MIB_IPMCAST_BOUNDARY
{
    DWORD   dwIfIndex;
    DWORD   dwGroupAddress;
    DWORD   dwGroupMask;
    DWORD   dwStatus;
}MIB_IPMCAST_BOUNDARY, *PMIB_IPMCAST_BOUNDARY;

typedef struct _MIB_IPMCAST_BOUNDARY_TABLE
{
    DWORD       dwNumEntries;
    MIB_IPMCAST_BOUNDARY   table[ANY_SIZE];
}MIB_IPMCAST_BOUNDARY_TABLE, *PMIB_IPMCAST_BOUNDARY_TABLE;

#define SIZEOF_BOUNDARY_TABLE(X) (FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]) + ((X) * sizeof(MIB_IPMCAST_BOUNDARY)) + ALIGN_SIZE)

typedef struct {
    DWORD    dwGroupAddress;
    DWORD    dwGroupMask;
} MIB_BOUNDARYROW, *PMIB_BOUNDARYROW;

// Structure matching what goes in the registry in a block of type
// IP_MCAST_LIMIT_INFO.  This contains the fields of
// MIB_IPMCAST_IF_ENTRY which are configurable.

typedef struct {
    DWORD    dwTtl;
    DWORD    dwRateLimit;
} MIB_MCAST_LIMIT_ROW, *PMIB_MCAST_LIMIT_ROW;

#define MAX_SCOPE_NAME_LEN 255

//
// Scope names are unicode.  SNMP and MZAP use UTF-8 encoding.
//

#define SN_UNICODE
typedef WCHAR   SN_CHAR;
typedef SN_CHAR SCOPE_NAME_BUFFER[MAX_SCOPE_NAME_LEN+1], *SCOPE_NAME;

typedef struct _MIB_IPMCAST_SCOPE
{
    DWORD             dwGroupAddress;
    DWORD             dwGroupMask;
    SCOPE_NAME_BUFFER snNameBuffer;
    DWORD             dwStatus;
}MIB_IPMCAST_SCOPE, *PMIB_IPMCAST_SCOPE;

typedef struct _MIB_IPDESTROW
{
#ifdef __cplusplus
    MIB_IPFORWARDROW  ForwardRow;
#else
    MIB_IPFORWARDROW;
#endif

    DWORD             dwForwardPreference;
    DWORD             dwForwardViewSet;
}MIB_IPDESTROW, *PMIB_IPDESTROW;

typedef struct _MIB_IPDESTTABLE
{
    DWORD             dwNumEntries;
    MIB_IPDESTROW     table[ANY_SIZE];
}MIB_IPDESTTABLE, *PMIB_IPDESTTABLE;

typedef struct _MIB_BEST_IF
{
    DWORD       dwDestAddr;
    DWORD       dwIfIndex;
}MIB_BEST_IF, *PMIB_BEST_IF;

typedef struct _MIB_PROXYARP
{
    DWORD       dwAddress;
    DWORD       dwMask;
    DWORD       dwIfIndex;
}MIB_PROXYARP, *PMIB_PROXYARP;

typedef struct _MIB_IFSTATUS
{
    DWORD       dwIfIndex;
    DWORD       dwAdminStatus;
    DWORD       dwOperationalStatus;
    BOOL        bMHbeatActive;
    BOOL        bMHbeatAlive;
}MIB_IFSTATUS, *PMIB_IFSTATUS;

typedef struct _MIB_ROUTESTATE
{
    BOOL        bRoutesSetToStack;

}MIB_ROUTESTATE, *PMIB_ROUTESTATE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All the info passed to (SET/CREATE) and from (GET/GETNEXT/GETFIRST)      //
// IP Router Manager is encapsulated in the following "discriminated"       //
// union.  To pass, say MIB_IFROW, use the following code                   //
//                                                                          //
//  PMIB_OPAQUE_INFO    pInfo;                                              //
//  PMIB_IFROW          pIfRow;                                             //
//  DWORD rgdwBuff[(MAX_MIB_OFFSET + sizeof(MIB_IFROW))/sizeof(DWORD) + 1]; //
//                                                                          //
//  pInfo   = (PMIB_OPAQUE_INFO)rgdwBuffer;                                 //
//  pIfRow  = (MIB_IFROW *)(pInfo->rgbyData);                               //
//                                                                          //
//  This can also be accomplished by using the following macro              //
//                                                                          //
//  DEFINE_MIB_BUFFER(pInfo,MIB_IFROW, pIfRow);                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _MIB_OPAQUE_INFO
{
    DWORD  dwId;

    union
    {
        ULONGLONG   ullAlign;
        BYTE        rgbyData[1];
    };

}MIB_OPAQUE_INFO, *PMIB_OPAQUE_INFO;

#define MAX_MIB_OFFSET      8

#define MIB_INFO_SIZE(S)                \
    (MAX_MIB_OFFSET + sizeof(S))

#define MIB_INFO_SIZE_IN_DWORDS(S)      \
    ((MIB_INFO_SIZE(S))/sizeof(DWORD) + 1)

#define DEFINE_MIB_BUFFER(X,Y,Z)                                        \
    DWORD        __rgdwBuff[MIB_INFO_SIZE_IN_DWORDS(Y)]; \
    PMIB_OPAQUE_INFO    X = (PMIB_OPAQUE_INFO)__rgdwBuff;               \
    Y *                 Z = (Y *)(X->rgbyData)


#define CAST_MIB_INFO(X,Y,Z)    Z = (Y)(X->rgbyData)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif //__ROUTING_IPRTRMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iptypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iptypes.h

--*/

#ifndef IP_TYPES_INCLUDED
#define IP_TYPES_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214) // bit field types other than int

#include <time.h>
#include <ifdef.h>
#include <nldef.h>

// Definitions and structures used by getnetworkparams and getadaptersinfo apis

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         256 // arb.
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.
#define DEFAULT_MINIMUM_ENTITIES        32  // arb.
#define MAX_HOSTNAME_LEN                128 // arb.
#define MAX_DOMAIN_NAME_LEN             128 // arb.
#define MAX_SCOPE_ID_LEN                256 // arb.
#define MAX_DHCPV6_DUID_LENGTH          130 // RFC 3315.
#define MAX_DNS_SUFFIX_STRING_LENGTH    256

//
// types
//

// Node Type

#define BROADCAST_NODETYPE              1
#define PEER_TO_PEER_NODETYPE           2
#define MIXED_NODETYPE                  4
#define HYBRID_NODETYPE                 8

//
// IP_ADDRESS_STRING - store an IP address as a dotted decimal string
//

typedef struct {
    char String[4 * 4];
} IP_ADDRESS_STRING, *PIP_ADDRESS_STRING, IP_MASK_STRING, *PIP_MASK_STRING;

//
// IP_ADDR_STRING - store an IP address with its corresponding subnet mask,
// both as dotted decimal strings
//

typedef struct _IP_ADDR_STRING {
    struct _IP_ADDR_STRING* Next;
    IP_ADDRESS_STRING IpAddress;
    IP_MASK_STRING IpMask;
    DWORD Context;
} IP_ADDR_STRING, *PIP_ADDR_STRING;

//
// ADAPTER_INFO - per-adapter information. All IP addresses are stored as
// strings
//

typedef struct _IP_ADAPTER_INFO {
    struct _IP_ADAPTER_INFO* Next;
    DWORD ComboIndex;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD Index;
    UINT Type;
    UINT DhcpEnabled;
    PIP_ADDR_STRING CurrentIpAddress;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
    time_t LeaseObtained;
    time_t LeaseExpires;
} IP_ADAPTER_INFO, *PIP_ADAPTER_INFO;

#if defined(_WINSOCK2API_) || defined (_WS2DEF_)

//
// The following types require Winsock2.
//

typedef NL_PREFIX_ORIGIN IP_PREFIX_ORIGIN;
typedef NL_SUFFIX_ORIGIN IP_SUFFIX_ORIGIN;
typedef NL_DAD_STATE IP_DAD_STATE;

typedef struct _IP_ADAPTER_UNICAST_ADDRESS_LH {
    union {
        ULONGLONG Alignment;
        struct { 
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_UNICAST_ADDRESS_LH *Next;
    SOCKET_ADDRESS Address;

    IP_PREFIX_ORIGIN PrefixOrigin;
    IP_SUFFIX_ORIGIN SuffixOrigin;
    IP_DAD_STATE DadState;

    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG LeaseLifetime;
    UINT8 OnLinkPrefixLength;
} IP_ADAPTER_UNICAST_ADDRESS_LH,
 *PIP_ADAPTER_UNICAST_ADDRESS_LH;

typedef struct _IP_ADAPTER_UNICAST_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct { 
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_UNICAST_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;

    IP_PREFIX_ORIGIN PrefixOrigin;
    IP_SUFFIX_ORIGIN SuffixOrigin;
    IP_DAD_STATE DadState;

    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG LeaseLifetime;
} IP_ADAPTER_UNICAST_ADDRESS_XP, *PIP_ADAPTER_UNICAST_ADDRESS_XP;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef  IP_ADAPTER_UNICAST_ADDRESS_LH IP_ADAPTER_UNICAST_ADDRESS;
typedef  IP_ADAPTER_UNICAST_ADDRESS_LH *PIP_ADAPTER_UNICAST_ADDRESS;
#elif (NTDDI_VERSION >= NTDDI_WINXP)
typedef  IP_ADAPTER_UNICAST_ADDRESS_XP IP_ADAPTER_UNICAST_ADDRESS;
typedef  IP_ADAPTER_UNICAST_ADDRESS_XP *PIP_ADAPTER_UNICAST_ADDRESS;
#endif

//
// Bit values of IP_ADAPTER_UNICAST_ADDRESS Flags field.
//
#define IP_ADAPTER_ADDRESS_DNS_ELIGIBLE 0x01
#define IP_ADAPTER_ADDRESS_TRANSIENT    0x02

typedef struct _IP_ADAPTER_ANYCAST_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct { 
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_ANYCAST_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_ANYCAST_ADDRESS_XP, *PIP_ADAPTER_ANYCAST_ADDRESS_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_ANYCAST_ADDRESS_XP IP_ADAPTER_ANYCAST_ADDRESS;
typedef IP_ADAPTER_ANYCAST_ADDRESS_XP *PIP_ADAPTER_ANYCAST_ADDRESS;
#endif

typedef struct _IP_ADAPTER_MULTICAST_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_MULTICAST_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_MULTICAST_ADDRESS_XP, *PIP_ADAPTER_MULTICAST_ADDRESS_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_MULTICAST_ADDRESS_XP IP_ADAPTER_MULTICAST_ADDRESS;
typedef IP_ADAPTER_MULTICAST_ADDRESS_XP *PIP_ADAPTER_MULTICAST_ADDRESS;
#endif

typedef struct _IP_ADAPTER_DNS_SERVER_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Reserved;
        };
    };
    struct _IP_ADAPTER_DNS_SERVER_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_DNS_SERVER_ADDRESS_XP, *PIP_ADAPTER_DNS_SERVER_ADDRESS_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_DNS_SERVER_ADDRESS_XP IP_ADAPTER_DNS_SERVER_ADDRESS;
typedef IP_ADAPTER_DNS_SERVER_ADDRESS_XP *PIP_ADAPTER_DNS_SERVER_ADDRESS;
#endif

typedef struct _IP_ADAPTER_WINS_SERVER_ADDRESS_LH {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Reserved;
        };
    };
    struct _IP_ADAPTER_WINS_SERVER_ADDRESS_LH *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_WINS_SERVER_ADDRESS_LH, *PIP_ADAPTER_WINS_SERVER_ADDRESS_LH;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef IP_ADAPTER_WINS_SERVER_ADDRESS_LH IP_ADAPTER_WINS_SERVER_ADDRESS;
typedef IP_ADAPTER_WINS_SERVER_ADDRESS_LH *PIP_ADAPTER_WINS_SERVER_ADDRESS;
#endif


typedef struct _IP_ADAPTER_GATEWAY_ADDRESS_LH {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Reserved;
        };
    };
    struct _IP_ADAPTER_GATEWAY_ADDRESS_LH *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_GATEWAY_ADDRESS_LH, *PIP_ADAPTER_GATEWAY_ADDRESS_LH;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef IP_ADAPTER_GATEWAY_ADDRESS_LH IP_ADAPTER_GATEWAY_ADDRESS;
typedef IP_ADAPTER_GATEWAY_ADDRESS_LH *PIP_ADAPTER_GATEWAY_ADDRESS;
#endif

typedef struct _IP_ADAPTER_PREFIX_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_PREFIX_XP *Next;
    SOCKET_ADDRESS Address;
    ULONG PrefixLength;
} IP_ADAPTER_PREFIX_XP, *PIP_ADAPTER_PREFIX_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_PREFIX_XP IP_ADAPTER_PREFIX;
typedef IP_ADAPTER_PREFIX_XP *PIP_ADAPTER_PREFIX;
#endif

typedef struct _IP_ADAPTER_DNS_SUFFIX {
    struct _IP_ADAPTER_DNS_SUFFIX *Next;
    WCHAR String[MAX_DNS_SUFFIX_STRING_LENGTH];
}IP_ADAPTER_DNS_SUFFIX, *PIP_ADAPTER_DNS_SUFFIX;

//
// Bit values of IP_ADAPTER_ADDRESSES Flags field.
//
#define IP_ADAPTER_DDNS_ENABLED               0x00000001
#define IP_ADAPTER_REGISTER_ADAPTER_SUFFIX    0x00000002
#define IP_ADAPTER_DHCP_ENABLED               0x00000004
#define IP_ADAPTER_RECEIVE_ONLY               0x00000008
#define IP_ADAPTER_NO_MULTICAST               0x00000010
#define IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG 0x00000020
#define IP_ADAPTER_NETBIOS_OVER_TCPIP_ENABLED 0x00000040
#define IP_ADAPTER_IPV4_ENABLED               0x00000080
#define IP_ADAPTER_IPV6_ENABLED               0x00000100
#define IP_ADAPTER_IPV6_MANAGE_ADDRESS_CONFIG 0x00000200

typedef struct _IP_ADAPTER_ADDRESSES_LH {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            IF_INDEX IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES_LH *Next;
    PCHAR AdapterName;
    PIP_ADAPTER_UNICAST_ADDRESS_LH FirstUnicastAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS_XP FirstAnycastAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS_XP FirstMulticastAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS_XP FirstDnsServerAddress;
    PWCHAR DnsSuffix;
    PWCHAR Description;
    PWCHAR FriendlyName;
    BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    ULONG PhysicalAddressLength;
    union {
        ULONG Flags;
        struct {
            ULONG DdnsEnabled : 1;
            ULONG RegisterAdapterSuffix : 1;
            ULONG Dhcpv4Enabled : 1;
            ULONG ReceiveOnly : 1;
            ULONG NoMulticast : 1;
            ULONG Ipv6OtherStatefulConfig : 1;
            ULONG NetbiosOverTcpipEnabled : 1;
            ULONG Ipv4Enabled : 1;
            ULONG Ipv6Enabled : 1;
            ULONG Ipv6ManagedAddressConfigurationSupported : 1;
        };
    };
    ULONG Mtu;
    IFTYPE IfType;
    IF_OPER_STATUS OperStatus;
    IF_INDEX Ipv6IfIndex;
    ULONG ZoneIndices[16];
    PIP_ADAPTER_PREFIX_XP FirstPrefix;
#ifdef UNDER_CE
    DWORD PhysicalMedium;
#endif

    ULONG64 TransmitLinkSpeed;
    ULONG64 ReceiveLinkSpeed;
    PIP_ADAPTER_WINS_SERVER_ADDRESS_LH FirstWinsServerAddress;
    PIP_ADAPTER_GATEWAY_ADDRESS_LH FirstGatewayAddress;
    ULONG Ipv4Metric;
    ULONG Ipv6Metric;
    IF_LUID Luid;
    SOCKET_ADDRESS Dhcpv4Server;
    NET_IF_COMPARTMENT_ID CompartmentId;
    NET_IF_NETWORK_GUID NetworkGuid;
    NET_IF_CONNECTION_TYPE ConnectionType;    
    TUNNEL_TYPE TunnelType;
    //
    // DHCP v6 Info.
    //
    SOCKET_ADDRESS Dhcpv6Server;
    BYTE Dhcpv6ClientDuid[MAX_DHCPV6_DUID_LENGTH];
    ULONG Dhcpv6ClientDuidLength;
    ULONG Dhcpv6Iaid;
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
    PIP_ADAPTER_DNS_SUFFIX FirstDnsSuffix;
#endif
} IP_ADAPTER_ADDRESSES_LH, 
 *PIP_ADAPTER_ADDRESSES_LH;

typedef struct _IP_ADAPTER_ADDRESSES_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES_XP *Next;
    PCHAR AdapterName;
    PIP_ADAPTER_UNICAST_ADDRESS_XP FirstUnicastAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS_XP FirstAnycastAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS_XP FirstMulticastAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS_XP FirstDnsServerAddress;
    PWCHAR DnsSuffix;
    PWCHAR Description;
    PWCHAR FriendlyName;
    BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD PhysicalAddressLength;
    DWORD Flags;
    DWORD Mtu;
    DWORD IfType;
    IF_OPER_STATUS OperStatus;
    DWORD Ipv6IfIndex;
    DWORD ZoneIndices[16];
    PIP_ADAPTER_PREFIX_XP FirstPrefix;
#ifdef UNDER_CE
    DWORD PhysicalMedium;
#endif
} IP_ADAPTER_ADDRESSES_XP,
 *PIP_ADAPTER_ADDRESSES_XP;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef  IP_ADAPTER_ADDRESSES_LH IP_ADAPTER_ADDRESSES;
typedef  IP_ADAPTER_ADDRESSES_LH *PIP_ADAPTER_ADDRESSES;
#elif (NTDDI_VERSION >= NTDDI_WINXP)
typedef  IP_ADAPTER_ADDRESSES_XP IP_ADAPTER_ADDRESSES;
typedef  IP_ADAPTER_ADDRESSES_XP *PIP_ADAPTER_ADDRESSES;
#else
//
// For platforms other platforms that are including
// the file but not using the types.
//
typedef  IP_ADAPTER_ADDRESSES_XP IP_ADAPTER_ADDRESSES;
typedef  IP_ADAPTER_ADDRESSES_XP *PIP_ADAPTER_ADDRESSES;
#endif


//
// Flags used as argument to GetAdaptersAddresses().
// "SKIP" flags are added when the default is to include the information.
// "INCLUDE" flags are added when the default is to skip the information.
//
#define GAA_FLAG_SKIP_UNICAST                   0x0001
#define GAA_FLAG_SKIP_ANYCAST                   0x0002
#define GAA_FLAG_SKIP_MULTICAST                 0x0004
#define GAA_FLAG_SKIP_DNS_SERVER                0x0008
#define GAA_FLAG_INCLUDE_PREFIX                 0x0010
#define GAA_FLAG_SKIP_FRIENDLY_NAME             0x0020
#define GAA_FLAG_INCLUDE_WINS_INFO              0x0040
#define GAA_FLAG_INCLUDE_GATEWAYS               0x0080
#define GAA_FLAG_INCLUDE_ALL_INTERFACES         0x0100
#define GAA_FLAG_INCLUDE_ALL_COMPARTMENTS       0x0200
#define GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER    0x0400

#endif /* _WINSOCK2API_ */

//
// IP_PER_ADAPTER_INFO - per-adapter IP information such as DNS server list.
//

typedef struct _IP_PER_ADAPTER_INFO_W2KSP1 {
    UINT AutoconfigEnabled;
    UINT AutoconfigActive;
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
} IP_PER_ADAPTER_INFO_W2KSP1, *PIP_PER_ADAPTER_INFO_W2KSP1;
#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef  IP_PER_ADAPTER_INFO_W2KSP1 IP_PER_ADAPTER_INFO;
typedef  IP_PER_ADAPTER_INFO_W2KSP1 *PIP_PER_ADAPTER_INFO;
#endif


//
// FIXED_INFO - the set of IP-related information which does not depend on DHCP
//

typedef struct {
    char HostName[MAX_HOSTNAME_LEN + 4] ;
    char DomainName[MAX_DOMAIN_NAME_LEN + 4];
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
    UINT NodeType;
    char ScopeId[MAX_SCOPE_ID_LEN + 4];
    UINT EnableRouting;
    UINT EnableProxy;
    UINT EnableDns;
} FIXED_INFO_W2KSP1, *PFIXED_INFO_W2KSP1;
#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef  FIXED_INFO_W2KSP1 FIXED_INFO;
typedef  FIXED_INFO_W2KSP1 *PFIXED_INFO;
#endif


#ifndef IP_INTERFACE_NAME_INFO_DEFINED
#define IP_INTERFACE_NAME_INFO_DEFINED

typedef struct ip_interface_name_info_w2ksp1 {
    ULONG           Index;      // Interface Index
    ULONG           MediaType;  // Interface Types - see ipifcons.h
    UCHAR           ConnectionType;
    UCHAR           AccessType;
    GUID            DeviceGuid; // Device GUID is the guid of the device
                                // that IP exposes
    GUID            InterfaceGuid; // Interface GUID, if not GUID_NULL is the
                                // GUID for the interface mapped to the device.
} IP_INTERFACE_NAME_INFO_W2KSP1, *PIP_INTERFACE_NAME_INFO_W2KSP1;

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef IP_INTERFACE_NAME_INFO_W2KSP1 IP_INTERFACE_NAME_INFO;
typedef IP_INTERFACE_NAME_INFO_W2KSP1 *PIP_INTERFACE_NAME_INFO;
#endif

#endif

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\iso646.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/* iso646.h standard header */
#ifndef _ISO646
#define _ISO646
#define and		&&
#define and_eq	&=
#define bitand	&
#define bitor	|
#define compl	~
#define not		!
#define not_eq	!=
#define or		||
#define or_eq	|=
#define xor		^
#define xor_eq	^=
#endif /* _ISO646 */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\isguids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*
 * isguids.h - Internet Shortcut GUID definitions.
 *
 */


/* GUIDs
 ********/

#ifndef _ISGUIDS_H_
#define _ISGUIDS_H_

DEFINE_GUID(CLSID_InternetShortcut,       0xFBF23B40L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

DEFINE_GUID(IID_IUniformResourceLocatorA, 0xFBF23B80L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
DEFINE_GUID(IID_IUniformResourceLocatorW, 0xCABB0DA0L, 0xDA57, 0x11CF, 0x99, 0x74, 0x00, 0x20, 0xAF, 0xD7, 0x97, 0x62);

#ifdef UNICODE
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorW
#else
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\itspeech.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jun 13 11:59:18 2005
 */
/* Compiler settings for .\itspeech.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __itspeech_h__
#define __itspeech_h__

/* Forward Declarations */ 

#ifndef __ISpRecognizerLite_FWD_DEFINED__
#define __ISpRecognizerLite_FWD_DEFINED__
typedef interface ISpRecognizerLite ISpRecognizerLite;
#endif 	/* __ISpRecognizerLite_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_itspeech_0000 */
/* [local] */ 

typedef DWORD SPRECOGNITIONMETHOD;

typedef DWORD __RPC_FAR *PSPRECOGNITIONMETHOD;

#define SPRM_INVALID             0x00000000
#define SPRM_VOICETAG            0x00000001
#define SPRM_CONTINUOUSDIGIT     0x00000002
#define SPRM_ANY                 0xFFFFFFFF
typedef 
enum __SPTYPE
    {	SPT_NULL	= 0,
	SPT_DWORD	= SPT_NULL + 1,
	SPT_BSTR	= SPT_DWORD + 1,
	SPT_PROP	= SPT_BSTR + 1
    }	SPTYPE;

typedef enum __SPTYPE __RPC_FAR *PSPTYPE;

typedef struct __SPTYPEHEADER
    {
    UINT cbSize;
    SPTYPE spt;
    }	SPTYPEHEADER;

typedef struct __SPTYPEHEADER __RPC_FAR *PSPTYPEHEADER;

typedef struct __SPDWORD
    {
    SPTYPEHEADER spth;
    DWORD dwData;
    }	SPDWORD;

typedef struct __SPDWORD __RPC_FAR *PSPDWORD;

typedef struct __SPBSTR
    {
    SPTYPEHEADER spth;
    UINT cbBstr;
    BSTR bstr;
    }	SPBSTR;

typedef struct __SPBSTR __RPC_FAR *PSPBSTR;

typedef 
enum __SPPROPTYPE
    {	SPPT_NULL	= 0,
	SPPT_CUSTOMUI	= SPPT_NULL + 1,
	SPPT_CONTINUOUSDIGIT_TRAINING_PROGRESS	= SPPT_CUSTOMUI + 1
    }	SPPROPTYPE;

typedef enum __SPPROPTYPE __RPC_FAR *PSPPROPTYPE;

typedef struct __SPPROP
    {
    SPTYPEHEADER spth;
    SPPROPTYPE sppt;
    DWORD dwValue;
    }	SPPROP;

typedef struct __SPPROP __RPC_FAR *PSPPROP;



extern RPC_IF_HANDLE __MIDL_itf_itspeech_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_itspeech_0000_v0_0_s_ifspec;

#ifndef __ISpRecognizerLite_INTERFACE_DEFINED__
#define __ISpRecognizerLite_INTERFACE_DEFINED__

/* interface ISpRecognizerLite */
/* [object][uuid] */ 


EXTERN_C const IID IID_ISpRecognizerLite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85140985-7A18-4009-B5FB-43268FD154F8")
    ISpRecognizerLite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Train( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Recognize( 
            /* [out][in] */ PSPRECOGNITIONMETHOD peRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Playback( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReTrain( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [in] */ UINT index,
            /* [out] */ SPTYPEHEADER __RPC_FAR *psth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableItem( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVoiceInfo( 
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [in] */ SPTYPEHEADER __RPC_FAR *psthID,
            /* [out] */ SPTYPEHEADER __RPC_FAR *psthSampleInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISpRecognizerLiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISpRecognizerLite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISpRecognizerLite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            ISpRecognizerLite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Train )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Recognize )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [out][in] */ PSPRECOGNITIONMETHOD peRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Playback )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReTrain )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ IUnknown __RPC_FAR *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [in] */ UINT index,
            /* [out] */ SPTYPEHEADER __RPC_FAR *psth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableItem )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoiceInfo )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [in] */ SPRECOGNITIONMETHOD eRM,
            /* [in] */ SPTYPEHEADER __RPC_FAR *psthID,
            /* [out] */ SPTYPEHEADER __RPC_FAR *psthSampleInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            ISpRecognizerLite __RPC_FAR * This,
            /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth);
        
        END_INTERFACE
    } ISpRecognizerLiteVtbl;

    interface ISpRecognizerLite
    {
        CONST_VTBL struct ISpRecognizerLiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISpRecognizerLite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISpRecognizerLite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISpRecognizerLite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISpRecognizerLite_Initialize(This,psth)	\
    (This)->lpVtbl -> Initialize(This,psth)

#define ISpRecognizerLite_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define ISpRecognizerLite_Train(This,eRM,psth,pUnk)	\
    (This)->lpVtbl -> Train(This,eRM,psth,pUnk)

#define ISpRecognizerLite_Recognize(This,peRM,psth,pUnk)	\
    (This)->lpVtbl -> Recognize(This,peRM,psth,pUnk)

#define ISpRecognizerLite_Playback(This,eRM,psth,pUnk)	\
    (This)->lpVtbl -> Playback(This,eRM,psth,pUnk)

#define ISpRecognizerLite_Delete(This,eRM,psth,pUnk)	\
    (This)->lpVtbl -> Delete(This,eRM,psth,pUnk)

#define ISpRecognizerLite_DeleteAll(This,eRM,pUnk)	\
    (This)->lpVtbl -> DeleteAll(This,eRM,pUnk)

#define ISpRecognizerLite_ReTrain(This,eRM,psth,pUnk)	\
    (This)->lpVtbl -> ReTrain(This,eRM,psth,pUnk)

#define ISpRecognizerLite_EnumItems(This,eRM,index,psth)	\
    (This)->lpVtbl -> EnumItems(This,eRM,index,psth)

#define ISpRecognizerLite_EnableItem(This,eRM,psth,fEnable)	\
    (This)->lpVtbl -> EnableItem(This,eRM,psth,fEnable)

#define ISpRecognizerLite_GetVoiceInfo(This,eRM,psthID,psthSampleInfo)	\
    (This)->lpVtbl -> GetVoiceInfo(This,eRM,psthID,psthSampleInfo)

#define ISpRecognizerLite_GetProperty(This,psth)	\
    (This)->lpVtbl -> GetProperty(This,psth)

#define ISpRecognizerLite_SetProperty(This,psth)	\
    (This)->lpVtbl -> SetProperty(This,psth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISpRecognizerLite_Initialize_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth);


void __RPC_STUB ISpRecognizerLite_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_Abort_Proxy( 
    ISpRecognizerLite __RPC_FAR * This);


void __RPC_STUB ISpRecognizerLite_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_Train_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB ISpRecognizerLite_Train_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_Recognize_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [out][in] */ PSPRECOGNITIONMETHOD peRM,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB ISpRecognizerLite_Recognize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_Playback_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB ISpRecognizerLite_Playback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_Delete_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB ISpRecognizerLite_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_DeleteAll_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB ISpRecognizerLite_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_ReTrain_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
    /* [in] */ IUnknown __RPC_FAR *pUnk);


void __RPC_STUB ISpRecognizerLite_ReTrain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_EnumItems_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [in] */ UINT index,
    /* [out] */ SPTYPEHEADER __RPC_FAR *psth);


void __RPC_STUB ISpRecognizerLite_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_EnableItem_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ISpRecognizerLite_EnableItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_GetVoiceInfo_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [in] */ SPRECOGNITIONMETHOD eRM,
    /* [in] */ SPTYPEHEADER __RPC_FAR *psthID,
    /* [out] */ SPTYPEHEADER __RPC_FAR *psthSampleInfo);


void __RPC_STUB ISpRecognizerLite_GetVoiceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_GetProperty_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth);


void __RPC_STUB ISpRecognizerLite_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISpRecognizerLite_SetProperty_Proxy( 
    ISpRecognizerLite __RPC_FAR * This,
    /* [out][in] */ SPTYPEHEADER __RPC_FAR *psth);


void __RPC_STUB ISpRecognizerLite_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISpRecognizerLite_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\keybd.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

// Non Win32 defines and structs for WinCE keyboard.

#pragma once
#define __KEYBD_H__ // needed to not break WinMo, as they have a duplicate header

#ifdef __cplusplus
extern "C" {
#endif

///<file_doc_scope tref="Keyboard" visibility="SDK"/>


/// <summary>
/// Flags for keyboard events and shift state.
/// </summary>
/// <remarks>
/// These flags perform a number of functions:
///
/// The low order bits are used to keep track of a key state.  This
/// allows using 256 UINT8's for the key state array just like Windows does
/// already.
///
/// The upper bits keep track of shift state on a per key basis.  Since
/// we are not maintaining a complete key state array for each task, this
/// gives us some extra info without a big memory penalty.
///
/// The KeyStateDownFlag does double duty internal to the driver to
/// identify key up or key down events.
///
/// KeyShiftDeadFlag is set by the <see cref="KeybdDriverVKeyToUnicode" /> function
/// to signify that the character generated is a dead character.
///
/// KeyShiftNoCharacterFlag is set by the <see cref="KeybdDriverVKeyToUnicode" />
/// function to signify that there is no valid character to generate for the
/// given virtual key event.  This may be the case on a key up event or a key
/// which only changes the shift state.
///
/// The control, alt, shift and capital flags are set by the 
/// <see cref="KeybdDriverVKeyToUnicode" /> function to encapsulate the shift state when the
/// character was generated.
/// </remarks>
/// <seealso cref="KeybdDriverVKeyToUnicode"/>
/// <seealso cref="KeybdEventCallback"/>
typedef UINT32  KEY_STATE_FLAGS;

#define KeyStateToggledFlag         0x0001  //  Key is toggled.
#define KeyStateGetAsyncDownFlag    0x0002  //  Key went down since last GetAsyncKey call.
#define KeyStateReserved4           0x0004
#define KeyStateReserved8           0x0008
#define KeyStateReserved10          0x0010
#define KeyStateReserved20          0x0020
#define KeyStatePrevDownFlag        0x0040  //  Key was previously down.
#define KeyStateDownFlag            0x0080  //  Key is currently down.

#define KeyStateKeyEventFlag        0x80000000  //  Internal
#define KeyShiftAnyCtrlFlag         0x40000000  //  L or R control is down.
#define KeyShiftAnyShiftFlag        0x20000000  //  L or R shift is down.
#define KeyShiftAnyAltFlag          0x10000000  //  L or R alt is down.
#define KeyShiftCapitalFlag         0x08000000  //  VK_CAPITAL is toggled.
#define KeyShiftLeftCtrlFlag        0x04000000  //  L control is down.
#define KeyShiftLeftShiftFlag       0x02000000  //  L shift is down.
#define KeyShiftLeftAltFlag         0x01000000  //  L alt is down.
#define KeyShiftLeftWinFlag         0x00800000  //  L Win key is down.
#define KeyShiftRightCtrlFlag       0x00400000  //  R control is down.
#define KeyShiftRightShiftFlag      0x00200000  //  R shift is down.
#define KeyShiftRightAltFlag        0x00100000  //  R alt is down.
#define KeyShiftRightWinFlag        0x00080000  //  R Win key is down.
#define KeyShiftReserved40000       0x00040000  //  Reserved.
#define KeyShiftDeadFlag            0x00020000  //  Corresponding char is dead char.
#define KeyShiftNoCharacterFlag     0x00010000  //  No corresponding char.

#define KeyShiftLanguageFlag1       0x00008000  //  Use for language specific shifts.
#define KeyShiftKeybdEventFlag      0x00004000  //  Not for external use.

#define KeyShiftUseVKNullFlag       0x00002000  //  Not for external use.
#define KeyShiftNumLockFlag         0x00001000  //  NumLock toggled state.
#define KeyShiftScrollLockFlag      0x00000800  //  ScrollLock toggled state.
#define KeyShiftReserved400         0x00000400  //  Reserved.
#define KeyShiftReserved200         0x00000200  //  Reserved.
#define KeyShiftReserved100         0x00000100  //  Reserved.

// Japanese keyboard
#define KeyShiftKanaFlag            KeyShiftLanguageFlag1  //  Kana lock is toggled.


#define KeyStateIsDown(Flags)           (Flags&KeyStateDownFlag)
#define KeyStateIsPrevDown(Flags)       (Flags&KeyStatePrevDownFlag)
#define KeyStateIsToggled(Flags)        (Flags&KeyStateToggledFlag)
#define KeyStateIsDownTransition(Flags) ( KeyStateIsDown(Flags) && !KeyStateIsPrevDown(Flags) )


#define COUNT_VKEYS     256


/// <summary>
/// Array of virtual key states.
/// </summary>
typedef UINT8   KEY_STATE[COUNT_VKEYS];




//
// KeyboardDriverGetDeviceInfo query capability definitions
//


/// <summary>
/// Id for KeybdDriverGetInfo to get Unicode conversion info.
/// </summary>
/// <seealso cref="KeybdDriverGetInfo" />
/// <seealso cref="KBDI_VKEY_TO_UNICODE_INFO" />
/// <seealso cref="KeybdDriverVKeyToUnicode" />
#define KBDI_VKEY_TO_UNICODE_INFO_ID    0


/// <summary>
/// Info required to set up for Unicode conversion.
/// </summary>
/// <remarks>
/// cbToUnicodeState is the number of bytes necessary to store the
/// driver specific state which is required to generate characters from a
/// virtual key.  For example, a French keyboard driver may need to remember
/// that an accent key was previously pressed in order to decide on a specific
/// Unicode character to generate for a virtual key.  This value may be 0 if
/// no other state besides <see cref="KEY_STATE" /> is required to generate characters,
/// e.g., English keyboard drivers.
///
/// cMaxToUnicodeCharacters is the maximum number of characters that may
/// be generated by a call to KeybdDriverVKeyToUnicode.  For example, if a
/// user presses the '^' key and then the 'b' key, a French keyboard driver
/// would generate the two characters, '^' 'b', when the second key is
/// pressed.  Note that this is not the count of bytes required to store the
/// characters, it is just the number of characters.
/// </remarks>
/// <seealso cref="KeybdDriverGetInfo" />
/// <seealso cref="KBDI_VKEY_TO_UNICODE_INFO_ID" />
/// <seealso cref="KeybdDriverVKeyToUnicode" />
/// <seealso cref="TO_UNICODE_STATE" />
struct KBDI_VKEY_TO_UNICODE_INFO
{
    UINT32  cbToUnicodeState;               // Count of bytes required
                                            // for state info for Unicode
                                            // character generation.
    UINT32  cMaxToUnicodeCharacters;        // Maximum number of characters
                                            // generated for a single virtual key.
};




/// <summary>
/// Id for KeybdDriverGetInfo to get keyboard auto-repeat info.
/// </summary>
/// <seealso cref="KeybdDriverGetInfo" />
/// <seealso cref="KBDI_AUTOREPEAT_INFO" />
/// <seealso cref="KBDI_AUTOREPEAT_SELECTIONS_INFO_ID" />
#define KBDI_AUTOREPEAT_INFO_ID 1



/// <summary>
/// Info about the keyboard autorepeat capabilities and settings.
/// </summary>
/// <remarks>
/// cInitialDelaysSelectable gives the number of initial delays which
/// may be set.  Query again using <see cref="KBDI_AUTOREPEAT_SELECTIONS_INFO_ID" /> to
/// get the actual values available.
///
/// cRepeatRatesSelectable is similar to cInitialDelaysSelectable except
/// that it gives the number of repeat rates available.
/// </remarks>
/// <seealso cref="KeybdDriverGetInfo" />
/// <seealso cref="KBDI_AUTOREPEAT_INFO_ID" />
/// <seealso cref="KBDI_AUTOREPEAT_SELECTIONS_INFO_ID" />
struct KBDI_AUTOREPEAT_INFO
{
    INT32   CurrentInitialDelay;        // Current initial delay in milliseconds.
    INT32   CurrentRepeatRate;          // Current repeat rate in keys per second.
    INT32   cInitialDelaysSelectable;   // Number of initial delays selectable.
    INT32   cRepeatRatesSelectable;     // Number of repeat rates supported.
};

#define KBD_AUTO_REPEAT_INITIAL_DELAY_DEFAULT    500
#define KBD_AUTO_REPEAT_INITIAL_DELAY_MIN        250
#define KBD_AUTO_REPEAT_INITIAL_DELAY_MAX       1000

#define KBD_AUTO_REPEAT_KEYS_PER_SEC_DEFAULT      20
#define KBD_AUTO_REPEAT_KEYS_PER_SEC_MIN           2
#define KBD_AUTO_REPEAT_KEYS_PER_SEC_MAX          30


/// <summary>
/// Id for <see cref="KeybdDriverGetInfo" /> to get keyboard auto-repeat selections info.
/// </summary>
/// <remarks>
/// When <see cref="KeybdDriverGetInfo" /> is called with this value, the lpOutput
/// parameter should be a pointer to an array of INT32's to hold the selection
/// info.  The initial delays will be put at the beginning of the array
/// followed by the repeat rate selections.  The number of initial delay
/// values is determined by calling <see cref="KeybdDriverGetInfo" /> using 
/// <see cref="KBDI_AUTOREPEAT_INFO_ID" /> and looking at the returned
/// cInitialDelaysSelectable field.  If this value is -1, there will be two
/// (2) values, the min and max and the initial delay may be set to any value
/// in this range.  This value may be 0 if the initial delay is not settable.
/// Similarly, if cRepeatRatesSelectable is 0, there will be no repeat rate
/// information.  If it is -1, there will be two (2) values, the min and max.
/// 
/// Initial delay values are in milliseconds.  Repeat rates are in keys per
/// second.
/// </remarks>
/// <seealso cref="KeybdDriverGetInfo" />
/// <seealso cref="KBDI_AUTOREPEAT_INFO_ID" />
/// <seealso cref="KBDI_AUTOREPEAT_INFO" />
#define KBDI_AUTOREPEAT_SELECTIONS_INFO_ID  2

// INTERNATIONAL
#define KBDI_KEYBOARD_STATUS_ID 3


#define KBDI_KEYBOARD_PRESENT   0x0001  
#define KBDI_KEYBOARD_ENABLED   0x0002
#define KBDI_KEYBOARD_ENTER_ESC 0x0004
#define KBDI_KEYBOARD_ALPHA_NUM 0x0008

// Reserve for SHIME_MODE.
// Pass in the SHIME_MODE as the input parameter.
#define KBDI_SHIME_MODE_ID 4

// Reserve for SHIME_MODE.
// Pass in the SHIME_MODE as the input parameter.
#define KBDI_SHIME_MODE_ID 4

#define KBDI_SHIME_MODE_NONE                0x0000
#define KBDI_SHIME_MODE_SPELL               0x0001
#define KBDI_SHIME_MODE_SPELL_CAPS          0x0002
#define KBDI_SHIME_MODE_SPELL_CAPS_LOCK     0x0003
#define KBDI_SHIME_MODE_AMBIGUOUS           0x0004
#define KBDI_SHIME_MODE_AMBIGUOUS_CAPS      0x0005
#define KBDI_SHIME_MODE_AMBIGUOUS_CAPS_LOCK 0x0006
#define KBDI_SHIME_MODE_NUMBERS             0x0007
#define KBDI_SHIME_MODE_CUSTOM              0x0008


// External keyboard interface
#define DEVCLASS_KEYBOARD_STRING _T("{CBE6DDF2-F5D4-4e16-9F61-4CCC0B6695F3}")
#define DEVCLASS_KEYBOARD_GUID   { 0xcbe6ddf2, 0xf5d4, 0x4e16, { 0x9f, 0x61, 0x4c, 0xcc, 0xb, 0x66, 0x95, 0xf3 } }


// Pass in the KEY_STATE_FLAGS as the input parameter.
#define IOCTL_KBD_SET_MODIFIERS \
                     CTL_CODE(FILE_DEVICE_KEYBOARD,  \
                     1,                     \
                     METHOD_BUFFERED,       \
                     FILE_ANY_ACCESS)
#define IOCTL_HID_SET_MODIFIERS IOCTL_KBD_SET_MODIFIERS

// Pass in the KBDI_AUTOREPEAT_INFO as the input parameter.
#define IOCTL_KBD_SET_AUTOREPEAT \
                     CTL_CODE(FILE_DEVICE_KEYBOARD,  \
                     2,                     \
                     METHOD_BUFFERED,       \
                     FILE_ANY_ACCESS)
#define IOCTL_HID_SET_AUTOREPEAT IOCTL_KBD_SET_AUTOREPEAT

// Pass in the Input Language's fLocaleFlags as the input parameter.
#define IOCTL_KBD_SET_LOCALE_FLAGS \
                     CTL_CODE(FILE_DEVICE_KEYBOARD,  \
                     3,                     \
                     METHOD_BUFFERED,       \
                     FILE_ANY_ACCESS)

#define IOCTL_KBD_SET_DEVICE_LAYOUT \
                     CTL_CODE(FILE_DEVICE_KEYBOARD,  \
                     4,                     \
                     METHOD_BUFFERED,       \
                     FILE_ANY_ACCESS)

#define IOCTL_KBD_SET_SHIME_MODE_ID \
                     CTL_CODE(FILE_DEVICE_KEYBOARD,  \
                     5,                     \
                     METHOD_BUFFERED,       \
                     FILE_ANY_ACCESS)

#define IOCTL_KBD_GET_SHIME_MODE_ID \
                     CTL_CODE(FILE_DEVICE_KEYBOARD,  \
                     6,                     \
                     METHOD_BUFFERED,       \
                     FILE_ANY_ACCESS)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\kernsdk.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    kernSdk.h

Abstract:

    Kernel API's needed for Driver \ Server development

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
CeOpenCallerBuffer(
    PVOID* ppDestMarshalled,
    PVOID  pSrcUnmarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor,
    BOOL   ForceDuplicate
    );

HRESULT
CeCloseCallerBuffer(
    PVOID  pDestMarshalled,
    PVOID  pSrcUnmarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor
    );

//
// In Kernel mode, this following flag can be or'd with ARG_XXX for ArgumentDescriptor in calls to
//      CeAllocAsynchronousBuffer
// to force the source and destination to be aliased instead of copy-in/copy-out.
//
// NOTE: the flag must be included in the calls to
//      CeFreeAsynchronousBuffer
//      CeFlushAsynchronousBuffer
// on the buffer you allocated with the flag.
//
// And the flag has no effect (ignored) if used in any other marshal helper APIs.
// 
#define MARSHAL_FORCE_ALIAS         0x80000000

HRESULT
CeAllocAsynchronousBuffer(
    PVOID* ppDestAsyncMarshalled,
    PVOID  pSrcSyncMarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor
    );

HRESULT
CeFreeAsynchronousBuffer(
    PVOID  pDestAsyncMarshalled,
    PVOID  pSrcSyncMarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor
    );

HRESULT
CeFlushAsynchronousBuffer(
    PVOID  pDestAsyncMarshalled,
    PVOID  pSrcSyncMarshalled,
    PVOID  pSrcUnmarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor
    );

HRESULT
CeAllocDuplicateBuffer(
    PVOID* ppDestDuplicate,
    PVOID  pSrcMarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor
    );

HRESULT
CeFreeDuplicateBuffer(
    PVOID  pDestDuplicate,
    PVOID  pSrcMarshalled,
    DWORD  cbSrc,
    DWORD  ArgumentDescriptor
    );


/** Flags for LockPages: */
#define LOCKFLAG_WRITE      0x001   // write access required
#define LOCKFLAG_QUERY_ONLY 0x002   // query only, page in but don't lock
#define LOCKFLAG_READ       0x004   // read access required (as opposed to page present but PAGE_NOACCESS)

BOOL LockPages(LPVOID lpvAddress, DWORD cbSize, PDWORD pPFNs, int fOptions);
BOOL UnlockPages(LPVOID lpvAddress, DWORD cbSize);

//
// GetCallerProcess is ambiguous for it can mean "direct caller" or "caller's VM". For
// now GetCallerProcess is now mapped to "GetDirectCallerProcessId". It's strongly
// recommended that you replace GetCallerProcess with GetDirectCallerProcessId or
// GetCallerVMProcessId
//
HANDLE GetCallerProcess(void);

DWORD GetCallerVMProcessId (void);
DWORD GetDirectCallerProcessId (void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ivec.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to MMX(TM) instruction intrinsics.
 *
 */

#ifndef _IVEC_H_INCLUDED
#define _IVEC_H_INCLUDED
#ifndef RC_INVOKED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#if defined(_M_CEE_PURE)
	#error ERROR: This file is not supported in the pure mode!
#else

#include <mmintrin.h>
#include <assert.h>

/*
 * Define _SILENCE_IVEC_C4799 to disable warning C4799 inside this header.
 * Be careful that any code that uses these functions properly executes EMMS
 * or _m_empty() after using any MMX instruction and before using the x87 NDP.
 */
#if defined(_SILENCE_IVEC_C4799)
	#pragma warning(push)
	#pragma warning(disable: 4799)
#endif

/*
 * Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output
 */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#define EXPLICIT explicit

class I8vec8;			/* 8 elements, each element a signed or unsigned char data type */
class Is8vec8;			/* 8 elements, each element a signed char data type */
class Iu8vec8;			/* 8 elements, each element an unsigned char data type */
class I16vec4;			/* 4 elements, each element a signed or unsigned short */
class Is16vec4;			/* 4 elements, each element a signed short */
class Iu16vec4;			/* 4 elements, each element an unsigned short */
class I32vec2;			/* 2 elements, each element a signed or unsigned long */
class Is32vec2;			/* 2 elements, each element a signed long */
class Iu32vec2;			/* 2 elements, each element a unsigned long */
class I64vec1;			/* 1 element, a __m64 data type - Base I64vec1 class  */

#define _MM_8UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_8B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_4UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_4W(element,vector) (*((short*)&##vector + ##element))

#define _MM_2UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_2DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_QW (*((__int64*)&vec))

/* M64 Class:
 * 1 element, a __m64 data type
 * Contructors & Logical Operations
 */
class M64
{
protected:
		__m64 vec;

public:
	M64()									{ }
	M64(__m64 mm)							{ vec = mm; }
	M64(__int64 mm)							{ _MM_QW = mm; }
	M64(int i)								{ vec = _m_from_int(i); }

	operator __m64() const					{ return vec; }

	/* Logical Operations */
	M64& operator&=(const M64 &a)					{ return *this = (M64) _m_pand(vec,a); }
	M64& operator|=(const M64 &a)					{ return *this = (M64) _m_por(vec,a); }
	M64& operator^=(const M64 &a)					{ return *this = (M64) _m_pxor(vec,a); }

};

inline M64 operator&(const M64 &a, const M64 &b)	{ return _m_pand( a,b); }
inline M64 operator|(const M64 &a, const M64 &b)	{ return _m_por(a,b); }
inline M64 operator^(const M64 &a, const M64 &b)	{ return _m_pxor(a,b); }
inline M64 andnot(const M64 &a, const M64 &b)		{ return _m_pandn(a,b); }

/* I64vec1 Class:
 * 1 element, a __m64 data type
 * Contains Operations which can operate on any __m64 data type
 */

class I64vec1 : public M64
{
public:
	I64vec1()								{ }
	I64vec1(__m64 mm) : M64(mm)				{ }
	EXPLICIT I64vec1(int i) : M64(i)		{ }
	EXPLICIT I64vec1(__int64 mm) : M64(mm)	{ }

	I64vec1& operator= (const M64 &a) { return *this = (I64vec1) a; }
	I64vec1& operator&=(const M64 &a) { return *this = (I64vec1) _m_pand(vec,a); }
	I64vec1& operator|=(const M64 &a) { return *this = (I64vec1) _m_por(vec,a); }
	I64vec1& operator^=(const M64 &a) { return *this = (I64vec1) _m_pxor(vec,a); }

	/* Shift Logical Operations */
	I64vec1 operator<<(const M64 &a)				{ return _m_psllq(vec, a); }
	I64vec1 operator<<(int count) 				    { return _m_psllqi(vec, count); }
	I64vec1& operator<<=(const M64 &a)				{ return *this = (I64vec1) _m_psllq(vec, a); }
	I64vec1& operator<<=(int count) 				{ return *this = (I64vec1) _m_psllqi(vec, count); }
	I64vec1 operator>>(const M64 &a)				{ return _m_psrlq(vec, a); }
	I64vec1 operator>>(int count) 					{ return _m_psrlqi(vec, count); }
	I64vec1& operator>>=(const M64 &a)				{ return *this = (I64vec1) _m_psrlq(vec, a); }
	I64vec1& operator>>=(int count) 				{ return *this = (I64vec1) _m_psrlqi(vec, count); }
};

/* I32vec2 Class:
 * 2 elements, each element either a signed or unsigned int
 */
class I32vec2 : public M64
{
public:
	I32vec2() { }
	I32vec2(__m64 mm) : M64(mm) { }
	EXPLICIT I32vec2(int i) : M64 (i) { }
	EXPLICIT I32vec2(__int64 i): M64(i) {}

	/* Assignment Operator */
	I32vec2& operator= (const M64 &a) { return *this = (I32vec2) a; }

	/* Logical Assignment Operators */
	I32vec2& operator&=(const M64 &a) { return *this = (I32vec2) _m_pand(vec,a); }
	I32vec2& operator|=(const M64 &a) { return *this = (I32vec2) _m_por(vec,a); }
	I32vec2& operator^=(const M64 &a) { return *this = (I32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec2& operator +=(const I32vec2 &a)			{ return *this = (I32vec2) _m_paddd(vec,a); }
	I32vec2& operator -=(const I32vec2 &a)			{ return *this = (I32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	I32vec2 operator<<(const I32vec2 &a) 			{ return _m_pslld(vec,a); }
	I32vec2 operator<<(int count) 				    { return _m_pslldi(vec,count); }
	I32vec2& operator<<=(const I32vec2 &a)			{ return *this = (I32vec2) _m_pslld(vec,a); }
	I32vec2& operator<<=(int count) 				{ return *this = (I32vec2) _m_pslldi(vec,count); }

};

/* Compare For Equality */
inline I32vec2 cmpeq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline I32vec2 cmpneq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline I32vec2 unpack_low(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckldq(a,b); }
inline I32vec2 unpack_high(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* Is32vec2 Class:
 * 2 elements, each element a signed int
 */
class Is32vec2 : public I32vec2
{
public:
	Is32vec2() { }
	Is32vec2(__m64 mm) : I32vec2(mm) { }
	Is32vec2(signed int i0, signed int i1)
	{
		_MM_2DW(0,vec) = i1;
		_MM_2DW(1,vec) = i0;
	}
	EXPLICIT Is32vec2(int i) : I32vec2 (i)		{}
	EXPLICIT Is32vec2(__int64 i): I32vec2(i)	{}

	/* Assignment Operator */
	Is32vec2& operator= (const M64 &a)		{ return *this = (Is32vec2) a; }

	/* Logical Assignment Operators */
	Is32vec2& operator&=(const M64 &a)		{ return *this = (Is32vec2) _m_pand(vec,a); }
	Is32vec2& operator|=(const M64 &a)		{ return *this = (Is32vec2) _m_por(vec,a); }
	Is32vec2& operator^=(const M64 &a)		{ return *this = (Is32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec2& operator +=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_paddd(vec,a); }
	Is32vec2& operator -=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Is32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Is32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Is32vec2& operator<<=(const M64 &a)		{ return *this = (Is32vec2) _m_pslld(vec,a); }
	Is32vec2& operator<<=(int count) 		{ return *this = (Is32vec2) _m_pslldi(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec2 operator>>(const M64 &a) 		{ return _m_psrad(vec, a); }
	Is32vec2 operator>>(int count) 	  		{ return _m_psradi(vec, count); }
	Is32vec2& operator>>=(const M64 &a)		{ return *this = (Is32vec2) _m_psrad(vec, a); }
	Is32vec2& operator>>=(int count) 		{ return *this = (Is32vec2) _m_psradi(vec, count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec2 &a)
	{
		os << " [1]:" << _MM_2DW(1,a)
		<< " [0]:" << _MM_2DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}
};

/* Compares */
inline Is32vec2 cmpeq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Is32vec2 cmpneq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpgt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(a,b); }
inline Is32vec2 cmplt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(b,a); }
inline Is32vec2 cmple(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpge(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks & Pack */
inline Is32vec2 unpack_low(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckldq(a,b); }
inline Is32vec2 unpack_high(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckhdq(a,b); }

/* Iu32vec2 Class:
 * 2 elements, each element unsigned int
 */
class Iu32vec2 : public I32vec2
{
public:
	Iu32vec2() { }
	Iu32vec2(__m64 mm) : I32vec2(mm) { }
	Iu32vec2(unsigned int ui0, unsigned int ui1)
	{
		_MM_2UDW(0,vec) = ui1;
		_MM_2UDW(1,vec) = ui0;
	}

	EXPLICIT Iu32vec2(int i) : I32vec2 (i)		{ }
	EXPLICIT Iu32vec2(__int64 i) : I32vec2 (i)	{ }

	/* Assignment Operator */
	Iu32vec2& operator= (const M64 &a)		{ return *this = (Iu32vec2) a; }

	/* Logical Assignment Operators */
	Iu32vec2& operator&=(const M64 &a)		{ return *this = (Iu32vec2) _m_pand(vec,a); }
	Iu32vec2& operator|=(const M64 &a)		{ return *this = (Iu32vec2) _m_por(vec,a); }
	Iu32vec2& operator^=(const M64 &a)		{ return *this = (Iu32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec2& operator +=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_paddd(vec,a); }
	Iu32vec2& operator -=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Iu32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Iu32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Iu32vec2& operator<<=(const M64 &a)		{ return *this = (Iu32vec2) _m_pslld(vec,a); }
	Iu32vec2& operator<<=(int count) 		{ return *this = (Iu32vec2) _m_pslldi(vec,count); }
	Iu32vec2 operator>>(const M64 &a) 		{ return _m_psrld(vec,a); }
	Iu32vec2 operator>>(int count) 			{ return _m_psrldi(vec,count); }
	Iu32vec2& operator>>=(const M64 &a)		{ return *this = (Iu32vec2) _m_psrld(vec,a); }
	Iu32vec2& operator>>=(int count) 		{ return *this = (Iu32vec2) _m_psrldi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec2 &a)
	{
		os << " [1]:" << _MM_2UDW(1,a)
		<< " [0]:" << _MM_2UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}
};

/* Compares For Equality / Inequality */
inline Iu32vec2 cmpeq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Iu32vec2 cmpneq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Iu32vec2 unpack_low(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckldq(a,b); }
inline Iu32vec2 unpack_high(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* I16vec4 Class:
 * 4 elements, each element either a signed or unsigned short
 */
class I16vec4 : public M64
{
public:
	I16vec4() { }
	I16vec4(__m64 mm) : M64(mm) { }
	EXPLICIT I16vec4(__int64 i) : M64 (i) { }
	EXPLICIT I16vec4(int i) : M64 (i) { }

	/* Assignment Operator */
	I16vec4& operator= (const M64 &a)				{ return *this = (I16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator&=(const M64 &a)				{ return *this = (I16vec4) _m_pand(vec,a); }
	I16vec4& operator|=(const M64 &a)				{ return *this = (I16vec4) _m_por(vec,a); }
	I16vec4& operator^=(const M64 &a)				{ return *this = (I16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator +=(const I16vec4 &a)			{ return *this = (I16vec4)_m_paddw(vec,a); }
	I16vec4& operator -=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psubw(vec,a); }
	I16vec4& operator *=(const I16vec4 &a)			{ return *this = (I16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	I16vec4 operator<<(const I16vec4 &a) 			{ return _m_psllw(vec,a); }
	I16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	I16vec4& operator<<=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psllw(vec,a); }
	I16vec4& operator<<=(int count) 				{ return *this = (I16vec4)_m_psllwi(vec,count); }
};

inline I16vec4 operator*(const I16vec4 &a, const I16vec4 &b) 	{ return _m_pmullw(a,b); }
inline I16vec4 cmpeq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline I16vec4 cmpneq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline I16vec4 unpack_low(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline I16vec4 unpack_high(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* Is16vec4 Class:
 * 4 elements, each element signed short
 */
class Is16vec4 : public I16vec4
{
public:
	Is16vec4() { }
	Is16vec4(__m64 mm) : I16vec4(mm) { }
	Is16vec4(short i0, short i1, short i2, short i3)
	{
		_MM_4W(0,vec) = i3;
		_MM_4W(1,vec) = i2;
		_MM_4W(2,vec) = i1;
		_MM_4W(3,vec) = i0;
	}

	EXPLICIT Is16vec4(__int64 i) : I16vec4 (i)	{ }
	EXPLICIT Is16vec4(int i) : I16vec4 (i)		{ }

	/* Assignment Operator */
	Is16vec4& operator= (const M64 &a)		{ return *this = (Is16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator&=(const M64 &a)		{ return *this = (Is16vec4) _m_pand(vec,a); }
	Is16vec4& operator|=(const M64 &a)		{ return *this = (Is16vec4) _m_por(vec,a); }
	Is16vec4& operator^=(const M64 &a)		{ return *this = (Is16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator +=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_paddw(vec,a); }
	Is16vec4& operator -=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_psubw(vec,a); }
	Is16vec4& operator *=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Is16vec4 operator<<(const M64 &a) 		{ return _m_psllw(vec,a); }
	Is16vec4 operator<<(int count) 			{ return _m_psllwi(vec,count); }
	Is16vec4& operator<<=(const M64 &a)		{ return *this = (Is16vec4)_m_psllw(vec,a); }
	Is16vec4& operator<<=(int count) 		{ return *this = (Is16vec4)_m_psllwi(vec,count); }
	/* Shift Arithmetic Operations */
	Is16vec4 operator>>(const M64 &a) 		{ return _m_psraw(vec,a); }
	Is16vec4 operator>>(int count) 			{ return _m_psrawi(vec,count); }
	Is16vec4& operator>>=(const M64 &a)		{ return *this = (Is16vec4) _m_psraw(vec,a); }
	Is16vec4& operator>>=(int count) 		{ return *this = (Is16vec4) _m_psrawi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec4 &a)
	{
		os << "[3]:" << _MM_4W(3,a)
			<< " [2]:" << _MM_4W(2,a)
			<< " [1]:" << _MM_4W(1,a)
			<< " [0]:" << _MM_4W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}

	/* Element Access for Debug */
	short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}
};

inline Is16vec4 operator*(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_pmullw(a,b); }

/* Compares */
inline Is16vec4 cmpeq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Is16vec4 cmpneq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpgt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(a,b); }
inline Is16vec4 cmplt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(b,a); }
inline Is16vec4 cmple(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpge(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Is16vec4 unpack_low(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Is16vec4 unpack_high(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpckhwd(a,b); }

inline Is16vec4 sat_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_paddsw(a,b); }
inline Is16vec4 sat_sub(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_psubsw(a,b); }
inline Is16vec4 mul_high(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmulhw(a,b); }
inline Is32vec2 mul_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaddwd(a,b);}


/* Iu16vec4 Class:
 * 4 elements, each element unsigned short
 */
class Iu16vec4 : public I16vec4
{
public:
	Iu16vec4() { }
	Iu16vec4(__m64 mm) : I16vec4(mm) { }
	Iu16vec4(unsigned short ui0, unsigned short ui1, unsigned short ui2, unsigned short ui3)
	{
		_MM_4UW(0,vec) = ui3;
		_MM_4UW(1,vec) = ui2;
		_MM_4UW(2,vec) = ui1;
		_MM_4UW(3,vec) = ui0;
	}
	EXPLICIT Iu16vec4(__int64 i) : I16vec4 (i) { }
	EXPLICIT Iu16vec4(int i) : I16vec4 (i) { }

	/* Assignment Operator */
	Iu16vec4& operator= (const M64 &a)		{ return *this = (Iu16vec4) a; }

	/* Logical Assignment Operators */
	Iu16vec4& operator&=(const M64 &a)		{ return *this = (Iu16vec4) _m_pand(vec,a); }
	Iu16vec4& operator|=(const M64 &a)		{ return *this = (Iu16vec4) _m_por(vec,a); }
	Iu16vec4& operator^=(const M64 &a)		{ return *this = (Iu16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu16vec4& operator +=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_paddw(vec,a); }
	Iu16vec4& operator -=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_psubw(vec,a); }
	Iu16vec4& operator *=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Iu16vec4 operator<<(const M64 &a) 				{ return _m_psllw(vec,a); }
	Iu16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	Iu16vec4& operator<<=(const M64 &a)				{ return *this = (Iu16vec4)_m_psllw(vec,a); }
	Iu16vec4& operator<<=(int count) 				{ return *this = (Iu16vec4)_m_psllwi(vec,count); }
	Iu16vec4 operator>>(const M64 &a) 				{ return _m_psrlw(vec,a); }
	Iu16vec4 operator>>(int count) 				    { return _m_psrlwi(vec,count); }
	Iu16vec4& operator>>=(const M64 &a)				{ return *this = (Iu16vec4) _m_psrlw(vec,a); }
	Iu16vec4& operator>>=(int count) 				{ return *this = (Iu16vec4) _m_psrlwi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu16vec4 &a)
	{
		os << "[3]:" << _MM_4UW(3,a)
			<< " [2]:" << _MM_4UW(2,a)
			<< " [1]:" << _MM_4UW(1,a)
			<< " [0]:" << _MM_4UW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}
};

inline Iu16vec4 operator*(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_pmullw(a,b); }
inline Iu16vec4 cmpeq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Iu16vec4 cmpneq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline Iu16vec4 sat_add(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_paddusw(a,b); }
inline Iu16vec4 sat_sub(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_psubusw(a,b); }

inline Iu16vec4 unpack_low(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Iu16vec4 unpack_high(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* I8vec8 Class:
 * 8 elements, each element either unsigned or signed char
 */
class I8vec8 : public M64
{
public:
	I8vec8() { }
	I8vec8(__m64 mm) : M64(mm) { }
	EXPLICIT I8vec8(__int64 i) : M64 (i) { }
	EXPLICIT I8vec8(int i) : M64 (i) { }

	/* Assignment Operator */
	I8vec8& operator= (const M64 &a)		{ return *this = (I8vec8) a; }

	/* Logical Assignment Operators */
	I8vec8& operator&=(const M64 &a)		{ return *this = (I8vec8) _m_pand(vec,a); }
	I8vec8& operator|=(const M64 &a)		{ return *this = (I8vec8) _m_por(vec,a); }
	I8vec8& operator^=(const M64 &a)		{ return *this = (I8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec8& operator +=(const I8vec8 &a)	{ return *this = (I8vec8) _m_paddb(vec,a); }
	I8vec8& operator -=(const I8vec8 &a)	{ return *this = (I8vec8) _m_psubb(vec,a); }
};


inline I8vec8 cmpeq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline I8vec8 cmpneq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline I8vec8 unpack_low(const I8vec8 &a, const I8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline I8vec8 unpack_high(const I8vec8 &a, const I8vec8 &b) { return _m_punpckhbw(a,b); }

/* Is8vec8 Class:
 * 8 elements, each element signed char
 */
class Is8vec8 : public I8vec8
{
public:
	Is8vec8() { }
	Is8vec8(__m64 mm) : I8vec8(mm) { }
	Is8vec8(signed char s0,signed char s1,signed char s2,signed char s3,signed char s4,signed char s5,signed char s6,signed char s7)
	 {
		_MM_8B(0,vec) = s7;
		_MM_8B(1,vec) = s6;
		_MM_8B(2,vec) = s5;
		_MM_8B(3,vec) = s4;
		_MM_8B(4,vec) = s3;
		_MM_8B(5,vec) = s2;
		_MM_8B(6,vec) = s1;
		_MM_8B(7,vec) = s0;
	}

	EXPLICIT Is8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Is8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Is8vec8& operator= (const M64 &a)		{ return *this = (Is8vec8) a; }

	/* Logical Assignment Operators */
	Is8vec8& operator&=(const M64 &a)		{ return *this = (Is8vec8) _m_pand(vec,a); }
	Is8vec8& operator|=(const M64 &a)		{ return *this = (Is8vec8) _m_por(vec,a); }
	Is8vec8& operator^=(const M64 &a)		{ return *this = (Is8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec8& operator +=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_paddb(vec,a); }
	Is8vec8& operator -=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is8vec8 &a)
	{
		os << "[7]:" << short(_MM_8B(7,a))
			<< " [6]:" << short(_MM_8B(6,a))
			<< " [5]:" << short(_MM_8B(5,a))
			<< " [4]:" << short(_MM_8B(4,a))
			<< " [3]:" << short(_MM_8B(3,a))
			<< " [2]:" << short(_MM_8B(2,a))
			<< " [1]:" << short(_MM_8B(1,a))
			<< " [0]:" << short(_MM_8B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}
};

/* Additional Is8vec8 functions: compares, unpacks, sat add/sub */
inline Is8vec8 cmpeq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Is8vec8 cmpneq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpgt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(a,b); }
inline Is8vec8 cmplt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(b,a); }
inline Is8vec8 cmple(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpge(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(b,a), M64(0xffffffffffffffffi64)); }

inline Is8vec8 unpack_low(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Is8vec8 unpack_high(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Is8vec8 sat_add(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_paddsb(a,b); }
inline Is8vec8 sat_sub(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_psubsb(a,b); }

/* Iu8vec8 Class:
 * 8 elements, each element unsigned char
 */
class Iu8vec8 : public I8vec8
{
public:
	Iu8vec8() { }
	Iu8vec8(__m64 mm) : I8vec8(mm) { }
	Iu8vec8(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsigned char s5,unsigned char s6,unsigned char s7)
	{
		_MM_8UB(0,vec) = s7;
		_MM_8UB(1,vec) = s6;
		_MM_8UB(2,vec) = s5;
		_MM_8UB(3,vec) = s4;
		_MM_8UB(4,vec) = s3;
		_MM_8UB(5,vec) = s2;
		_MM_8UB(6,vec) = s1;
		_MM_8UB(7,vec) = s0;
	}
	EXPLICIT Iu8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Iu8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Iu8vec8& operator= (const M64 &a)		{ return *this = (Iu8vec8) a; }
	/* Logical Assignment Operators */
	Iu8vec8& operator&=(const M64 &a)		{ return *this = (Iu8vec8) _m_pand(vec,a); }
	Iu8vec8& operator|=(const M64 &a)		{ return *this = (Iu8vec8) _m_por(vec,a); }
	Iu8vec8& operator^=(const M64 &a)		{ return *this = (Iu8vec8) _m_pxor(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu8vec8& operator +=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_paddb(vec,a); }
	Iu8vec8& operator -=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UB(7,a))
			<< " [6]:" << unsigned short(_MM_8UB(6,a))
			<< " [5]:" << unsigned short(_MM_8UB(5,a))
			<< " [4]:" << unsigned short(_MM_8UB(4,a))
			<< " [3]:" << unsigned short(_MM_8UB(3,a))
			<< " [2]:" << unsigned short(_MM_8UB(2,a))
			<< " [1]:" << unsigned short(_MM_8UB(1,a))
			<< " [0]:" << unsigned short(_MM_8UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}
};

/* Additional Iu8vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu8vec8 cmpeq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Iu8vec8 cmpneq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline Iu8vec8 unpack_low(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Iu8vec8 unpack_high(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Iu8vec8 sat_add(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_paddusb(a,b); }
inline Iu8vec8 sat_sub(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_psubusb(a,b); }

inline Is16vec4 pack_sat(const Is32vec2 &a, const Is32vec2 &b)		{ return _m_packssdw(a,b); }
inline Is8vec8 pack_sat(const Is16vec4 &a, const Is16vec4 &b) 		{ return _m_packsswb(a,b); }
inline Iu8vec8 packu_sat(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_packuswb(a,b); }

/********************************* Logicals ****************************************/
#define IVEC_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pand( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_por( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pxor( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pandn( a,b); }

IVEC_LOGICALS(8,8)
IVEC_LOGICALS(u8,8)
IVEC_LOGICALS(s8,8)
IVEC_LOGICALS(16,4)
IVEC_LOGICALS(u16,4)
IVEC_LOGICALS(s16,4)
IVEC_LOGICALS(32,2)
IVEC_LOGICALS(u32,2)
IVEC_LOGICALS(s32,2)
IVEC_LOGICALS(64,1)
#undef IVEC_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_padd##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_psub##opsize( a,b); }

IVEC_ADD_SUB(8,8, b)
IVEC_ADD_SUB(u8,8, b)
IVEC_ADD_SUB(s8,8, b)
IVEC_ADD_SUB(16,4, w)
IVEC_ADD_SUB(u16,4, w)
IVEC_ADD_SUB(s16,4, w)
IVEC_ADD_SUB(32,2, d)
IVEC_ADD_SUB(u32,2, d)
IVEC_ADD_SUB(s32,2, d)
#undef IVEC_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_m_pandn(mask, arg2 )))));	\
}
IVEC_SELECT(8,s8,8,eq,c,d)
IVEC_SELECT(8,u8,8,eq,c,d)
IVEC_SELECT(8,8,8,eq,c,d)
IVEC_SELECT(8,s8,8,neq,c,d)
IVEC_SELECT(8,u8,8,neq,c,d)
IVEC_SELECT(8,8,8,neq,c,d)

IVEC_SELECT(16,s16,4,eq,c,d)
IVEC_SELECT(16,u16,4,eq,c,d)
IVEC_SELECT(16,16,4,eq,c,d)
IVEC_SELECT(16,s16,4,neq,c,d)
IVEC_SELECT(16,u16,4,neq,c,d)
IVEC_SELECT(16,16,4,neq,c,d)

IVEC_SELECT(32,s32,2,eq,c,d)
IVEC_SELECT(32,u32,2,eq,c,d)
IVEC_SELECT(32,32,2,eq,c,d)
IVEC_SELECT(32,s32,2,neq,c,d)
IVEC_SELECT(32,u32,2,neq,c,d)
IVEC_SELECT(32,32,2,neq,c,d)


IVEC_SELECT(s8,s8,8,gt,c,d)
IVEC_SELECT(s8,u8,8,gt,c,d)
IVEC_SELECT(s8,8,8,gt,c,d)
IVEC_SELECT(s8,s8,8,lt,c,d)
IVEC_SELECT(s8,u8,8,lt,c,d)
IVEC_SELECT(s8,8,8,lt,c,d)
IVEC_SELECT(s8,s8,8,le,c,d)
IVEC_SELECT(s8,u8,8,le,c,d)
IVEC_SELECT(s8,8,8,le,c,d)
IVEC_SELECT(s8,s8,8,ge,c,d)
IVEC_SELECT(s8,u8,8,ge,c,d)
IVEC_SELECT(s8,8,8,ge,c,d)

IVEC_SELECT(s16,s16,4,gt,c,d)
IVEC_SELECT(s16,u16,4,gt,c,d)
IVEC_SELECT(s16,16,4,gt,c,d)
IVEC_SELECT(s16,s16,4,lt,c,d)
IVEC_SELECT(s16,u16,4,lt,c,d)
IVEC_SELECT(s16,16,4,lt,c,d)
IVEC_SELECT(s16,s16,4,le,c,d)
IVEC_SELECT(s16,u16,4,le,c,d)
IVEC_SELECT(s16,16,4,le,c,d)
IVEC_SELECT(s16,s16,4,ge,c,d)
IVEC_SELECT(s16,u16,4,ge,c,d)
IVEC_SELECT(s16,16,4,ge,c,d)

IVEC_SELECT(s32,s32,2,gt,c,d)
IVEC_SELECT(s32,u32,2,gt,c,d)
IVEC_SELECT(s32,32,2,gt,c,d)
IVEC_SELECT(s32,s32,2,lt,c,d)
IVEC_SELECT(s32,u32,2,lt,c,d)
IVEC_SELECT(s32,32,2,lt,c,d)
IVEC_SELECT(s32,s32,2,le,c,d)
IVEC_SELECT(s32,u32,2,le,c,d)
IVEC_SELECT(s32,32,2,le,c,d)
IVEC_SELECT(s32,s32,2,ge,c,d)
IVEC_SELECT(s32,u32,2,ge,c,d)
IVEC_SELECT(s32,32,2,ge,c,d)


#undef IVEC_SELECT

inline static void empty(void) 		{ _m_empty(); }

#if defined(_SILENCE_IVEC_C4799)
	#pragma warning(pop)
#endif

#endif /* defined(_M_CEE_PURE) */

#endif /* RC_INVOKED */
#endif /* _IVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ke.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//


// CE's KeXxx Functions

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <netwdm.h>

#define KeBugCheck(a) ASSERT(0);

typedef CCHAR KPROCESSOR_MODE;

// from usermode.h

__inline
LARGE_INTEGER
KeQueryPerformanceCounter(
    OUT PLARGE_INTEGER PerformanceFrequency  OPTIONAL
    )
{
    LARGE_INTEGER Time = {0};

    if (PerformanceFrequency)
        QueryPerformanceFrequency(PerformanceFrequency);

    QueryPerformanceCounter(&Time);
        
    return Time;
}

typedef struct _KDPC KDPC, *PKDPC, *PRKDPC;

__inline
VOID
KeSetTargetProcessorDpc (
    IN PRKDPC Dpc,
    IN CCHAR Number
    )
{
    //
    // Do not have to do anything really.
    //

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Number);
}

VOID
KeInitializeDpc(
    PKDPC                   pKDpc,
    PKDEFERRED_ROUTINE      DeferredRoutine, // pointer to the CustomDpc routine
    PVOID                   DeferredContext); // value to pass as DeferredContext parameter to CustomDpc


typedef HANDLE KEVENT, *PKEVENT, *PRKEVENT;
typedef uint    EVENT_TYPE;
typedef LONG    KPRIORITY;

enum {
    NotificationEvent = 0,
    SynchronizationEvent = 1,
};

__inline void 
KeInitializeEvent(
    IN PRKEVENT     phEvent,
    IN EVENT_TYPE   Type,
    IN BOOLEAN      State)
{
    *phEvent = CreateEvent(NULL, (Type == SynchronizationEvent)? FALSE:TRUE, State, NULL);
    ASSERT(phEvent);
}

__inline LONG 
KeSetEvent(
    IN PRKEVENT     phEvent,
    IN KPRIORITY    Increment,
    IN BOOLEAN      Wait)
{
    ASSERT(0 == Increment);
    ASSERT(FALSE == Wait);
    return SetEvent(*phEvent);
}


__inline LONG KeResetEvent(
    IN PRKEVENT  phEvent)
{
    return ResetEvent(*phEvent);

}

__inline NTSTATUS
KeDelayExecutionThread (
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER IntervalInHundredsOfNanoseconds
    )
//
//  The KeDelayExecutionThread routine puts the current thread into an alertable
//  or nonalertable wait state for a given interval.
//
//  Interval - Specifies the absolute or relative time, in units of 100 nanoseconds,
//             for which the wait is to occur. A negative value indicates relative time. 
//             Absolute expiration times track any changes in system time;
//             relative expiration times are not affected by system time changes.
{
    UNREFERENCED_PARAMETER(WaitMode);
    ASSERT(FALSE == Alertable);
    
    // Relative sleep times are specified with the negative of the interval time.
    // We don't support absolute times, just discard the sign bit.
    if (IntervalInHundredsOfNanoseconds->QuadPart < 0)
        IntervalInHundredsOfNanoseconds->QuadPart = -IntervalInHundredsOfNanoseconds->QuadPart;

    // Sleep takes a time in milliseconds
    Sleep((DWORD)(IntervalInHundredsOfNanoseconds->QuadPart / 10000) + 1);
    
    return STATUS_SUCCESS;
}

//
//  The KeFlushQueuedDpcs routine returns after all queued DPCs on all
//  processors have executed.
//
VOID
KeFlushQueuedDpcs();

typedef HANDLE KMUTEX, *PKMUTEX, *PRKMUTEX;

__inline VOID 
KeInitializeMutex(
    OUT KMUTEX   *Mutex,
    IN  ULONG     Level)
//
//  The KeInitializeMutex routine initializes a mutex object at a given level number,
//  setting it to a signaled state.
//
{
    UNREFERENCED_PARAMETER(Level);
    
    *Mutex = CreateMutex(NULL, FALSE, NULL);
    if (NULL == *Mutex)
    {
        KdPrint(("CreateMutex failed: %d\n", GetLastError())); 
        ASSERT(FALSE);
    }
}

__inline LONG 
KeUninitializeMutex(
    IN OUT KMUTEX *Mutex)
//
//  Free the resources allocated by KeInitializeMutex
//
{
    return !CloseHandle(*Mutex);
}

__inline LONG 
KeReleaseMutex(
    IN OUT KMUTEX *Mutex, 
    IN     BOOLEAN Wait)
//
//  The KeReleaseMutex routine releases a given mutex object,
//  specifying whether the caller is to call one of the KeWaitXxx functions as soon as KeReleaseMutex returns control.
//
//  Returns 0 if successful (the mutex object was released and attained a state of signaled).
//
{
    UNREFERENCED_PARAMETER(Wait);

    if (ReleaseMutex(*Mutex) == 0) {
        KdPrint(("ReleaseMutex failed: %d\n", GetLastError()));
        ASSERT(FALSE);
        return 1;
    }
    return 0;
}

typedef enum _KWAIT_REASON {
    Executive,
    UserRequest        
} KWAIT_REASON;

__inline NTSTATUS
KeWaitForSingleObject( 
    IN PVOID           Object,
    IN KWAIT_REASON    WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN         Alertable,
    IN PLARGE_INTEGER  Timeout OPTIONAL)
{
    HANDLE   Handle = *(PHANDLE)Object;
    DWORD    TimeoutMs = INFINITE;
    NTSTATUS Status = STATUS_SUCCESS;
    
    UNREFERENCED_PARAMETER(WaitReason);
    UNREFERENCED_PARAMETER(WaitMode);

    if (NULL != Timeout)
    {
        // Convert 64 bit timeout in 100s of nanonseconds to milliseconds
        TimeoutMs = (DWORD)(Timeout->QuadPart / 10000);
    }
    
    Status = WaitForSingleObject(Handle, TimeoutMs);
    // the WAIT_xxx codes are the same as the STATUS_xxx codes, no need to map them
    
    return Status;
    
}

__inline NTSTATUS   
KeWaitForMutexObject(    
    IN PRKMUTEX         Mutex,    
    IN KWAIT_REASON     WaitReason,    
    IN KPROCESSOR_MODE  WaitMode,    
    IN BOOLEAN          Alertable,    
    IN PLARGE_INTEGER   Timeout  OPTIONAL    )
{
    return KeWaitForSingleObject(Mutex, WaitReason, WaitMode, Alertable, Timeout);
}

//
// Semaphore object
//
typedef KMUTEX  KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

__inline VOID
KeInitializeSemaphore(
    IN OUT PRKSEMAPHORE  pSemaphore,    
    IN LONG  Count,    
    IN LONG  Limit)
{
    // Only support binary semaphores, not counting semaphores
    ASSERT(1 == Limit);
    
    KeInitializeMutex(pSemaphore, 0);
}

__inline LONG 
KeUninitializeSemaphore(
    IN OUT PRKSEMAPHORE  pSemaphore)
{
    return KeUninitializeMutex(pSemaphore);
} 

__inline LONG   
KeReleaseSemaphore(    
    IN PRKSEMAPHORE  pSemaphore,    
    IN KPRIORITY     Increment,    
    IN LONG          Adjustment,    
    IN BOOLEAN  Wait    )
{
    // Only support binary semaphores, not counting semaphores
    ASSERT(1 == Adjustment);

    return KeReleaseMutex(pSemaphore, FALSE);
}

__inline VOID   
KeEnterCriticalRegion()
//
//  The KeEnterCriticalRegion routine temporarily disables the delivery of normal kernel APCs;
//  special kernel-mode APCs are still delivered.
//
{
    // Should be a no-op for CE as there are no APCs.
}

__inline VOID   
KeLeaveCriticalRegion()
//
//  The KeLeaveCriticalRegion routine reenables the delivery of normal kernel-mode APCs that
//  were disabled by a preceding call to KeEnterCriticalRegion.
//
{
    // Should be a no-op for CE as there are no APCs.
}


__inline ULONGLONG  
KeQueryInterruptTime()
//
//  The KeQueryInterruptTime routine returns the current value of the system interrupt-time count. 
//
//  Returns the current interrupt-time count in 100-nanosecond units.
//
{
    // This routine must be fast and efficient, so we use GetTickCount() which
    // meets that criteria, but loses on accuracy.
    
    return (ULONGLONG)GetTickCount() * 10000;
}

// Most timer functions are implemented by ntcompat.h

__inline VOID
KeInitializeTimerEx(
    IN PKTIMER     Timer,
    IN TIMER_TYPE  Type)
{
    UNREFERENCED_PARAMETER(Type);

    CeKeInitializeTimer(Timer);
}

__inline BOOLEAN
KeIsExecutingDpc()
{
    return FALSE;
}


//  cf. \sdpublic\ddk\inc\ntddk.h
NTKERNELAPI
ULONG
KeQueryActiveProcessorCount (
    __out_opt PKAFFINITY ActiveProcessors
    );


//  cf. \sdpublic\ddk\inc\ntddk.h
NTKERNELAPI
ULONG
KeQueryMaximumProcessorCount (
    VOID
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\khronos_types.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _KHRONOS_TYPES_H
#define _KHRONOS_TYPES_H

typedef float           khronos_float;
typedef signed char     khronos_int8_t;
typedef unsigned char   khronos_uint8_t;
typedef short           khronos_int16_t;
typedef int             khronos_int32_t;
typedef unsigned int    khronos_uint32_t;

#endif /* _KHRONOS_TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\kfuncs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: kfuncs.h

++*/

#ifndef __KFUNCS_H__
#define __KFUNCS_H__

#define NUM_SYS_HANDLES         32

#define SYS_HANDLE_BASE         64

//
// We now support 128 API sets. Where the API numbers are defined as follows
// 
//      0:      kernel WIN32 API set
//      1-63:   OS reserved Handle based API sets
//      64-79:  partner defined Handle based API sets
//      80-111: OS reserved non-handle based API sets
//      112-127:partner defined non-hnadle based API sets
//
// non-handle-based APIs (API set 80-127) will receive PSL notifications.
//
//
#define SH_FIRST_OS_HAPI_SET    1       // 1st OS, handle based API set
#define SH_FIRST_EXT_HAPI_SET   64      // 1st partner defined handle based API set
#define SH_FIRST_OS_API_SET     80      // 1st OS non-handle based API set
#define SH_FIRST_EXT_API_SET    112     // 1st partner defined non-handle based API set

#define SH_WIN32                0

#define SH_CURTHREAD            1
#define SH_CURPROC              2
#define SH_CURTOKEN             3

// Special handle indicies used for "typed" handle calls
#define HT_EVENT                4       // Event handle type
#define HT_MUTEX                5       // Mutex handle type
#define HT_APISET               6       // kernel API set handle type
#define HT_FILE                 7       // open file handle type
#define HT_FIND                 8       // FindFirst handle type
#define HT_DBFILE               9       // open database handle type
#define HT_DBFIND               10      // database find handle type
#define HT_SOCKET               11      // WinSock open socket handle type
#define HT_CRITSEC              12      // Critical section
#define HT_SEMAPHORE            13      // Semaphore handle type
#define HT_FSMAP                14      // mapped files
#define HT_WNETENUM             15      // Net Resource Enumeration
#define HT_AFSVOLUME            16      // file system volume handle type
#define HT_NAMESPACE            17      // namespace type
#define HT_POLICY               18      // policy type
#define HT_SECLOADER            19      // secure loader type

#define SH_LAST_NOTIFY          SH_FIRST_OS_API_SET    // Last set notified on Thread/Process Termination

#define SH_GDI                  (SH_LAST_NOTIFY+0)
#define SH_WMGR                 (SH_LAST_NOTIFY+1)
#define SH_WNET                 (SH_LAST_NOTIFY+2)      // WNet APIs for network redirector
#define SH_COMM                 (SH_LAST_NOTIFY+3)      // Communications not "COM"
#define SH_FILESYS_APIS         (SH_LAST_NOTIFY+4)      // File system APIS
#define SH_SHELL                (SH_LAST_NOTIFY+5)
#define SH_DEVMGR_APIS          (SH_LAST_NOTIFY+6)      // File system device manager
#define SH_TAPI                 (SH_LAST_NOTIFY+7)
#define SH_CPROG                (SH_LAST_NOTIFY+8)      // Cprog APIS
#define SH_SERVICES             (SH_LAST_NOTIFY+10)
#define SH_DDRAW                (SH_LAST_NOTIFY+11)
#define SH_GWEUSER              (SH_LAST_NOTIFY+13)
#define SH_CONNMGR_LEGACY       (SH_LAST_NOTIFY+14)     // ConnMgr legacy API
#define SH_DMSRV                (SH_LAST_NOTIFY+15)     // Device Management APIs
#define SH_INPUT                (SH_LAST_NOTIFY+16)     // Input API
#define SH_COMPOSITOR           (SH_LAST_NOTIFY+17)     // Window Composition
#define SH_NETCF                (SH_LAST_NOTIFY+18)     // .NET Compact Framework sever
#define SH_LASTRESERVED         (SH_FIRST_EXT_API_SET-1)

#ifdef WINCEOEM
#include <psyscall.h>    // change to include only defines required by OEMs
#endif

// NOTE: only kernel and coredll should access PUserKData directly
//       or potentially BC Break once we move on to the next OS.
#if defined(_ARM_)
    #define PUserKData        ((LPBYTE)0xFFFFC800)
#else
    #define PUserKData        ((LPBYTE)0x00005800)
#endif

DWORD __GetUserKData (DWORD dwOfst);

#define SYSHANDLE_OFFSET                0x004

// offsets in kdata/PCB to find #processors and current processor
#define PCB_CURRENT_PROCESSOR_OFFSET    0x040
#define KDATA_TOTAL_PROCESSOR_OFFSET    0x088

// offsets in PCB to find current thread owner process id
#define PCB_OWNER_PROCESS_OFFSET 0x070

#ifdef WINCEOEM
#include <pkfuncs.h>    // change to include only defines required by OEMs
#ifdef WINCEMACRO
#include <mkfuncs.h>
#endif
#endif

#ifndef EventModify
BOOL WINAPI EventModify(HANDLE hEvent, DWORD func);
#endif

#if defined(_M_MRX000) // MIPS

#if (_M_MRX000 == 16) && !defined(NOMIPS16CODE)

extern void __asm(char[], ...);
#ifdef __cplusplus
extern "C" {
#endif
  void __emit(const unsigned __int32 a);
#ifdef __cplusplus
}
#endif
#pragma intrinsic (__emit)
#if _MSC_VER < 1300
extern void DebugBreak();
#pragma intrinsic (DebugBreak)
#else
#define DebugBreak() __debugbreak()
#endif

#else

#if _MSC_VER <= 1200
#pragma warning(disable:4052)
extern void __asm(char[], ...);
_inline void DebugBreak() {
    __asm("break 1");
}
#pragma warning(default:4052)
#else
#pragma warning(disable:4052)
extern void __asm(char[], ...);
#if _MSC_VER < 1300
extern void DebugBreak();
#pragma warning(default:4052)
#else
#define DebugBreak() __debugbreak()
#endif
#endif

#endif

#elif defined(_M_IX86)

#if _MSC_VER < 1300
_inline void DebugBreak() {
    __asm int 3
}
#else
#define DebugBreak() __debugbreak()
#endif

#elif defined(_M_SH)

extern void __asm(const char *, ...);
#if _MSC_VER < 1300
#define DebugBreak() __asm("trapa #1")
#else
#define DebugBreak() __debugbreak()
#endif

#elif defined(_M_ARM)

#ifdef __cplusplus
extern "C" {
#endif
#if _MSC_VER < 1300
void DebugBreak(void);
#else
#define DebugBreak() __debugbreak()
#endif
void __emit(unsigned const __int32);
#ifdef __cplusplus
}
#endif

#else

extern void DebugBreak();

#endif

#define EVENT_PULSE     1
#define EVENT_RESET     2
#define EVENT_SET       3

/*
    @doc BOTH EXTERNAL

    @func BOOL | PulseEvent | Provides a single operation that sets (to signaled) the state 
    of the specified event object and then resets it (to nonsignaled) after releasing the 
    appropriate number of waiting threads. 
    @parm HANDLE | hEvent | handle of event object 

    @comm Follows the Win32 reference description with the following exception:
*/
_inline BOOL PulseEvent(HANDLE h) {
    return EventModify(h,EVENT_PULSE);
}

/*
    @doc BOTH EXTERNAL

    @func BOOL | ResetEvent | Sets the state of the specified event object to nonsignaled. 
    @parm HANDLE | hEvent | handle of event object 

    @comm Follows the Win32 reference description with the following exception:
*/
_inline BOOL ResetEvent(HANDLE h) {
    return EventModify(h,EVENT_RESET);
}

/*
    @doc BOTH EXTERNAL

    @func BOOL | SetEvent | Sets the state of the specified event object to signaled. 
    @parm HANDLE | hEvent | handle of event object 

    @comm Follows the Win32 reference description with the following exception:
*/
_inline BOOL SetEvent(HANDLE h) {
    return EventModify(h,EVENT_SET);
}

/*
    @doc BOTH EXTERNAL
    @func HANDLE | CreateEvent | Creates a named or unnamed event object. 
    @parm LPSECURITY_ATTRIBUTES | lpEventAttributes | address of security attributes (<p must be NULL>). 
    @parm BOOL | bManualReset | flag for manual-reset event 
    @parm BOOL | bInitialState | flag for initial state 
    @parm LPTSTR | lpName | address of event-object name
    @comm Follows the Win32 reference description with these restrictions:
    Only default security attributes are available and existing object names are not supported. 
    The <p lpEventAttributes> parameter must be set to NULL. 
*/

/*
    @doc BOTH EXTERNAL
    @func HANDLE | OpenEvent | Opens an existing named event object. 
    @parm DWORD | dwDesiredAccess | requested access to the event object (<p must be EVENT_ALL_ACCESS>)
    @parm BOOL | bInheritHandle | specifies whether the returned handle is inheritable (<p must be FALSE>)
    @parm LPTSTR | lpName | address of event-object name
    @comm Follows the Win32 reference description with these restrictions:
    The <p dwDesiredAccess> parameter may only be EVENT_ALL_ACCESS.
    The <p bInheritHandle> parameter must be FALSE.
    The <p lpName> parameter may not be NULL. 
*/

/*
    @doc BOTH EXTERNAL
    @func VOID | Sleep | Suspends the execution of the current thread for a specified interval. 
    @parm DWORD | cMilliseconds | sleep time in milliseconds 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func DWORD | WaitForSingleObject | Returns when the specified object is in the 
    signaled state or when the time-out interval elapses. 
    @parm HANDLE | hObject | <p See restrictions below> Handle of object to wait for 
    @parm DWORD | dwTimeout | time-out interval in milliseconds  
    @comm Follows the Win32 reference description without restriction
*/

/*
    @doc BOTH EXTERNAL
    @func DWORD | WaitForMultipleObjects | Returns when one of the specified objects is in the 
    signaled state or when the time-out interval elapses.
    @parm DWORD | cObjects | number of objects to wait on, must be less than MAXIMUM_WAIT_OBJECTS
    @parm const HANDLE* | lphObjects | array of handles to wait on
    @parm BOOL | fWaitAll | must be FALSE
    @parm DWORD | dwTimeout | time-out interval in milliseconds  
    @comm Follows the Win32 reference description with these restrictions:
        bWaitAll must be FALSE
*/

/*
    @doc BOTH EXTERNAL
    @func DWORD | SuspendThread | Suspends the specified thread. 
    @parm HANDLE | hThread | handle to the thread 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func DWORD | ResumeThread | Decrements a thread's suspend count. When the suspend count 
        is decremented to zero, the execution of the thread is resumed. 
    @parm HANDLE | hThread | identifies thread to restart 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func BOOL | SetThreadPriority | Sets the priority value for the specified thread. 
    This value, together with the priority class of the thread's process, determines 
    the thread's base priority level.
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func int | GetThreadPriority | Returns the priority value for the specified thread.
    @parm HANDLE | hThread | handle to thread 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/


/*
    @doc BOTH EXTERNAL
    @func DWORD | GetLastError | Returns the calling thread's last-error code value. 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func VOID | SetLastError | Sets the last-error code for the calling thread. 
    @parm DWORD | fdwError | per-thread error code  
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func BOOL | GetExitCodeThread | Retrieves the termination status of the specified thread. 
    @parm HANDLE | hThread | handle to the thread 
    @parm LPDWORD |lpdwExitCode | address to receive termination status 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

#ifndef _CRTBLD

/*
    @doc BOTH EXTERNAL
    @func HANDLE | GetCurrentThread | Returns a pseudohandle for the current thread. 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

_inline HANDLE GetCurrentThread(void) {
    return ((HANDLE)(SH_CURTHREAD+SYS_HANDLE_BASE));
}

/*
    @doc BOTH EXTERNAL
    @func HANDLE | GetCurrentProcess | Returns a pseudohandle for the current process. 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

_inline HANDLE GetCurrentProcess(void) {
    return ((HANDLE)(SH_CURPROC+SYS_HANDLE_BASE));
}

_inline HANDLE GetCurrentToken (void) {
    return ((HANDLE)(SH_CURTOKEN+SYS_HANDLE_BASE));
}

_inline DWORD GetCurrentThreadId(void) {
    return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURTHREAD * sizeof(HANDLE)));
}

_inline DWORD GetCurrentProcessId(void) {
    return __GetUserKData (SYSHANDLE_OFFSET + (SH_CURPROC * sizeof(HANDLE)));
}

#else // _CRTBLD

HANDLE GetCurrentThread(void);
HANDLE GetCurrentProcess(void);
DWORD GetCurrentThreadId(void);
DWORD GetCurrentProcessId(void);

#endif // _CRTBLD

#define TLS_FUNCALLOC   0
#define TLS_FUNCFREE    1
#define CETLS_FUNCALLOC 2
#define CETLS_FUNCFREE  3

// Error return value for TlsAlloc
#define TLS_OUT_OF_INDEXES          ((DWORD)0xFFFFFFFF)

#ifndef TlsCall
DWORD WINAPI TlsCall (DWORD p1, DWORD p2);
#endif

/*
    @doc BOTH EXTERNAL
    @func DWORD | TlsAlloc | Allocates a thread local storage (TLS) index. Any thread 
    of the process can subsequently use this index to store and retrieve values that 
    are local to the thread.
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

_inline DWORD WINAPI TlsAlloc (void) {
    return TlsCall(TLS_FUNCALLOC, 0);
}

/*
    @doc BOTH EXTERNAL
    @func BOOL | TlsFree | Releases a thread local storage (TLS) index, making it available 
    for reuse. 
    @parm DWORD | dwTlsIndex | TLS index to free  
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/
_inline BOOL WINAPI TlsFree (DWORD dwTlsIndex) {
    return TlsCall(TLS_FUNCFREE, dwTlsIndex);
}

/* TLS cleanup function prototype */
typedef void (*PFN_CETLSFREE) (DWORD ThreadId, LPVOID SlotValue);

/*
    @func DWORD | CeTlsAlloc | Allocate a new slot and set a cleanup function for the slot. 
    @parm DWORD | pfnCleanup | Cleanup function to associate with the given slot.      
    @comm returns a valid slot and associates the cleanup function with the new slot.
    Modules should call this function in their DLL_PROCESS_ATTACH to create a new
    slot and assign a custom cleanup function for this slot. The custom cleanup function
    will be called when a thread using this TLS slot exits or when the slot is cleared
    using TlsFree API call.
*/
_inline DWORD WINAPI CeTlsAlloc (PFN_CETLSFREE pfnCleanup) {
    return TlsCall(CETLS_FUNCALLOC, (DWORD)pfnCleanup);
}

/*
    @func BOOL | CeTlsFree | free the slot value in the current thread; if there is a 
    cleanup function for this slot, call the cleanup function. This should be called by 
    modules in their DLL_THREAD_DETACH code to properly cleanup any TLS value 
    stored for the given slot in the thread which is exiting. It is assumed that this call 
    is always made from DLL_THREAD_DETACH code as the cleanup function 
    associated with this slot index is called without holding any locks.
*/
_inline BOOL WINAPI CeTlsFree (DWORD dwTlsIndex) {
    return TlsCall(CETLS_FUNCFREE, dwTlsIndex);
}


#define VERIFY_READ_FLAG    0
#define VERIFY_EXECUTE_FLAG 0
#define VERIFY_WRITE_FLAG   1
#define VERIFY_KERNEL_OK    2

/*
    @doc BOTH EXTERNAL
    @func BOOL | IsBadReadPtr | Verifies that the calling process 
    has read access to the specified range of memory. 
    @parm CONST VOID | *lpvPtr | address of memory block 
    @parm UINT | cbBytes | size of block 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func BOOL | IsBadWritePtr | Verifies that the calling process has write access 
    to the specified range of memory. 
    @parm LPVOID | lpvPtr | address of memory block  
    @parm UINT | cbBytes | size of block 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func LPVOID | VirtualAlloc | Reserves or commits a region of pages in the virtual 
    address space of the calling process. Memory allocated by this function is automatically 
    initialized to zero. 
    @parm LPVOID | lpvAddress | address of region to reserve or commit  
    @parm DWORD | cbSize | size of region 
    @parm DWORD | fdwAllocationType | type of allocation 
    @parm DWORD | fdwProtect | type of access protection 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func BOOL | VirtualFree | Releases or decommits (or both) a region of pages 
    within the virtual address space of the calling process. 
    @parm LPVOID | lpvAddress | address of region of committed pages  
    @parm DWORD | cbSize | size of region 
    @parm DWORD | fdwFreeType | type of free operation 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func BOOL | VirtualProtect | Changes the access protection on a region of committed 
    pages in the virtual address space of the calling process. This function differs 
    from VirtualProtectEx, which changes the access protection of any process.
    @parm LPVOID | lpvAddress | address of region of committed pages 
    @parm DWORD | cbSize | size of the region 
    @parm DWORD | fdwNewProtect | desired access protection 
    @parm PDWORD | pfdwOldProtect | address of variable to get old protection  
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func DWORD | VirtualQuery | Information about a range of pages in the virtual 
    address space of the calling process. 
    @parm LPCVOID | lpvAddress | address of region 
    @parm MEMORY_BASIC_INFORMATION | pmbiBuffer | address of information buffer  
    @parm DWORD | cbLength | size of buffer 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/
    
/*
    @doc BOTH EXTERNAL
    @func HINSTANCE | LoadLibrary | Maps the specified executable module into the address 
    space of the calling process.
    @parm LPTSTR | lpszLibFile | address of filename of executable module 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL

    @func BOOL | FreeLibrary | Decrements the reference count of the loaded dynamic-link 
    library (DLL) module
    @parm HMODULE |hLibModule | handle of loaded library module  
    @comm Follows the Win32 reference description without restrictions or modifications. 
    @devnote Follows the Win32 reference description without restrictions or modifications
*/

/*
    @doc BOTH EXTERNAL
    @func FARPROC | GetProcAddress | Returns the address of the specified exported dynamic-link 
    library (DLL) function. 
    @parm HMODULE | hModule | handle to DLL module  
    @parm LPSTR | lpszProc | name of function 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func HRSRC | FindResource | Determines the location of a resource with the specified 
    type and name in the specified module. 
    @parm HMODULE |hModule | resource-module handle 
    @parm LPTSTR | lpName | address of resource name  
    @parm LPTSTR | lpType | address of resource type 
    @comm Follows the Win32 reference description with the exception that we don't support
    the resource id 0 (ie: FindResource(h,0,t) will not work as expected).
*/

/*
    @doc BOTH EXTERNAL
    @func HGLOBAL| LoadResource | Loads the specified resource into global memory. 
    @parm HINSTANCE | hModule | resource-module handle  
    @parm HRSRC | hResInfo | resource handle 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func LPVOID| LockResource | Locks a loaded resource
    @parm HGLOBAL | hGlob | Locked resource's handle
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

_inline LPVOID LockResource(HGLOBAL hResData) {
    return ((LPVOID)hResData);
}

/*
    @doc BOTH EXTERNAL
    @func DWORD | GetTickCount | Retrieves the number of milliseconds that have 
    elapsed since Windows was started. 
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

/*
    @doc BOTH EXTERNAL
    @func VOID | OutputDebugString| Sends a string to the debugger for the current application. 
    @parm LPTSTR | lpszOutputString | address of string to be displayed  
    @comm Follows the Win32 reference description with these restrictions:
    @comm Supports only the Unicode version of this function.
*/

/*
    @doc BOTH EXTERNAL
    @func VOID | GetSystemInfo | Returns information about the current system. 
    @parm LPSYSTEM_INFO | lpSystemInfo | address of system information structure  
    @comm Follows the Win32 reference description without restrictions or modifications. 
*/

#ifndef CeGetCurrentTrust
DWORD CeGetCurrentTrust(void);
#endif

#ifndef CeGetCallerTrust
DWORD CeGetCallerTrust(void);
#endif

#ifndef CeGetProcessTrust
DWORD CeGetProcessTrust(HANDLE hProc);
#endif

/*
 * MP Support functions
 */


/*
    @doc BOTH EXTERNAL
    @func BOOL | CeSetThreadAffinity | Returns nonzero if success, zero if failed. 
    @parm HANDLE | hThread | handle to thread
    @parm DWORD | dwProcessor | which processor to set affinity to
*/
BOOL WINAPI CeSetThreadAffinity (  
    HANDLE hThread,
    DWORD  dwProcessor
    );
    
/*
    @doc BOTH EXTERNAL
    @func DWORD | CeGetThreadAffinity | Returns the current thread affinity (processor number). 
    @parm HANDLE | hThread | handle to thread
*/
BOOL WINAPI CeGetThreadAffinity (  
    HANDLE hThread,
    LPDWORD pdwAffinity
);

/*
    @doc BOTH EXTERNAL
    @func BOOL | CeSetProcessAffinity | Returns nonzero if success, zero if failed. 
    @parm HANDLE | hProc | handle to process
    @parm DWORD | dwProcessor | which processor to set affinity to
*/
BOOL WINAPI CeSetProcessAffinity (  
    HANDLE hProc,
    DWORD  dwProcessor
    );

/*
    @doc BOTH EXTERNAL
    @func DWORD | CeGetProcessAffinity | Returns the current process affinity (processor number). 
    @parm HANDLE | hProc | handle to process
*/
BOOL WINAPI CeGetProcessAffinity (  
    HANDLE hProc,
    LPDWORD pdwAffinity
);


/*
    @doc BOTH EXTERNAL
    @func DWORD | CeGetIdleTimeEx | Returns the idle time of a processor. 
    @parm DWORD | dwProcessor | which processor
*/
BOOL WINAPI CeGetIdleTimeEx (  
    DWORD  dwProcessor,
    LPDWORD pdwIdleTime
);

/*
    @doc BOTH EXTERNAL
    @func DWORD | CeGetProcessorState | Returns the state of a processor. 
    @parm DWORD | dwProcessor | which processor
*/
#define CE_PROCESSOR_STATE_POWERED_OFF      1
#define CE_PROCESSOR_STATE_POWERED_ON       2
#define CE_PROCESSOR_STATE_IN_TRANSITION    3
DWORD WINAPI CeGetProcessorState (  
    DWORD  dwProcessor
    );

/*
    @doc BOTH EXTERNAL
    @func DWORD | CeGetTotalProcessors | Returns the number of processors. 
*/
_inline DWORD WINAPI CeGetTotalProcessors (void)
{
    return __GetUserKData (KDATA_TOTAL_PROCESSOR_OFFSET);
}

/*
    @doc BOTH EXTERNAL
    @func DWORD | GetCurrentProcessorNumber | Returns the current processor. 
    @comm Should only be used for debug, for a thread can be rescheduled to run on another
    processor right after the call. 
*/
_inline DWORD WINAPI GetCurrentProcessorNumber (void)
{
    return __GetUserKData (PCB_CURRENT_PROCESSOR_OFFSET);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\knownfolders.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma once

#ifdef DEFINE_KNOWN_FOLDER
#undef DEFINE_KNOWN_FOLDER
#endif

#ifndef UNDER_CE
#ifdef INITGUID
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name
#endif // INITGUID
#else
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
#endif


// legacy CSIDL value: CSIDL_NETWORK
// display name: "Network"
// legacy display name: "My Network Places"
// default path: 
// {D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}
DEFINE_KNOWN_FOLDER(FOLDERID_NetworkFolder, 0xD20BEEC4, 0x5CA8, 0x4905, 0xAE, 0x3B, 0xBF, 0x25, 0x1E, 0xA0, 0x9B, 0x53);

// {0AC0837C-BBF8-452A-850D-79D08E667CA7}
DEFINE_KNOWN_FOLDER(FOLDERID_ComputerFolder,   0x0AC0837C, 0xBBF8, 0x452A, 0x85, 0x0D, 0x79, 0xD0, 0x8E, 0x66, 0x7C, 0xA7);

// {4D9F7874-4E0C-4904-967B-40B0D20C3E4B}
DEFINE_KNOWN_FOLDER(FOLDERID_InternetFolder,      0x4D9F7874, 0x4E0C, 0x4904, 0x96, 0x7B, 0x40, 0xB0, 0xD2, 0x0C, 0x3E, 0x4B);

// {82A74AEB-AEB4-465C-A014-D097EE346D63}
DEFINE_KNOWN_FOLDER(FOLDERID_ControlPanelFolder,  0x82A74AEB, 0xAEB4, 0x465C, 0xA0, 0x14, 0xD0, 0x97, 0xEE, 0x34, 0x6D, 0x63);

// {76FC4E2D-D6AD-4519-A663-37BD56068185}
DEFINE_KNOWN_FOLDER(FOLDERID_PrintersFolder,      0x76FC4E2D, 0xD6AD, 0x4519, 0xA6, 0x63, 0x37, 0xBD, 0x56, 0x06, 0x81, 0x85);

// {43668BF8-C14E-49B2-97C9-747784D784B7}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncManagerFolder,       0x43668BF8, 0xC14E, 0x49B2, 0x97, 0xC9, 0x74, 0x77, 0x84, 0xD7, 0x84, 0xB7);

// {0F214138-B1D3-4a90-BBA9-27CBC0C5389A}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncSetupFolder, 0xf214138, 0xb1d3, 0x4a90, 0xbb, 0xa9, 0x27, 0xcb, 0xc0, 0xc5, 0x38, 0x9a);

// {4bfefb45-347d-4006-a5be-ac0cb0567192}
DEFINE_KNOWN_FOLDER(FOLDERID_ConflictFolder,      0x4bfefb45, 0x347d, 0x4006, 0xa5, 0xbe, 0xac, 0x0c, 0xb0, 0x56, 0x71, 0x92);

// {289a9a43-be44-4057-a41b-587a76d7e7f9}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncResultsFolder,     0x289a9a43, 0xbe44, 0x4057, 0xa4, 0x1b, 0x58, 0x7a, 0x76, 0xd7, 0xe7, 0xf9);

// {B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}
DEFINE_KNOWN_FOLDER(FOLDERID_RecycleBinFolder,    0xB7534046, 0x3ECB, 0x4C18, 0xBE, 0x4E, 0x64, 0xCD, 0x4C, 0xB7, 0xD6, 0xAC);

// {6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}
DEFINE_KNOWN_FOLDER(FOLDERID_ConnectionsFolder,   0x6F0CD92B, 0x2E97, 0x45D1, 0x88, 0xFF, 0xB0, 0xD1, 0x86, 0xB8, 0xDE, 0xDD);

// {FD228CB7-AE11-4AE3-864C-16F3910AB8FE}
DEFINE_KNOWN_FOLDER(FOLDERID_Fonts,               0xFD228CB7, 0xAE11, 0x4AE3, 0x86, 0x4C, 0x16, 0xF3, 0x91, 0x0A, 0xB8, 0xFE);

// display name:        "Desktop"
// default path:        "C:\Users\<UserName>\Desktop"
// legacy default path: "C:\Documents and Settings\<userName>\Desktop"
// legacy CSIDL value:  CSIDL_DESKTOP
// {B4BFCC3A-DB2C-424C-B029-7FE99A87C641}
DEFINE_KNOWN_FOLDER(FOLDERID_Desktop,             0xB4BFCC3A, 0xDB2C, 0x424C, 0xB0, 0x29, 0x7F, 0xE9, 0x9A, 0x87, 0xC6, 0x41);

// {B97D20BB-F46A-4C97-BA10-5E3608430854}
DEFINE_KNOWN_FOLDER(FOLDERID_Startup,             0xB97D20BB, 0xF46A, 0x4C97, 0xBA, 0x10, 0x5E, 0x36, 0x08, 0x43, 0x08, 0x54);

// {A77F5D77-2E2B-44C3-A6A2-ABA601054A51}
DEFINE_KNOWN_FOLDER(FOLDERID_Programs,            0xA77F5D77, 0x2E2B, 0x44C3, 0xA6, 0xA2, 0xAB, 0xA6, 0x01, 0x05, 0x4A, 0x51);

// {625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}
DEFINE_KNOWN_FOLDER(FOLDERID_StartMenu,           0x625B53C3, 0xAB48, 0x4EC1, 0xBA, 0x1F, 0xA1, 0xEF, 0x41, 0x46, 0xFC, 0x19);

// {AE50C081-EBD2-438A-8655-8A092E34987A}
DEFINE_KNOWN_FOLDER(FOLDERID_Recent,              0xAE50C081, 0xEBD2, 0x438A, 0x86, 0x55, 0x8A, 0x09, 0x2E, 0x34, 0x98, 0x7A);

// {8983036C-27C0-404B-8F08-102D10DCFD74}
DEFINE_KNOWN_FOLDER(FOLDERID_SendTo,              0x8983036C, 0x27C0, 0x404B, 0x8F, 0x08, 0x10, 0x2D, 0x10, 0xDC, 0xFD, 0x74);

// {FDD39AD0-238F-46AF-ADB4-6C85480369C7}
DEFINE_KNOWN_FOLDER(FOLDERID_Documents,           0xFDD39AD0, 0x238F, 0x46AF, 0xAD, 0xB4, 0x6C, 0x85, 0x48, 0x03, 0x69, 0xC7);

// {1777F761-68AD-4D8A-87BD-30B759FA33DD}
DEFINE_KNOWN_FOLDER(FOLDERID_Favorites,           0x1777F761, 0x68AD, 0x4D8A, 0x87, 0xBD, 0x30, 0xB7, 0x59, 0xFA, 0x33, 0xDD);

// {C5ABBF53-E17F-4121-8900-86626FC2C973}
DEFINE_KNOWN_FOLDER(FOLDERID_NetHood,             0xC5ABBF53, 0xE17F, 0x4121, 0x89, 0x00, 0x86, 0x62, 0x6F, 0xC2, 0xC9, 0x73);

// {9274BD8D-CFD1-41C3-B35E-B13F55A758F4}
DEFINE_KNOWN_FOLDER(FOLDERID_PrintHood,           0x9274BD8D, 0xCFD1, 0x41C3, 0xB3, 0x5E, 0xB1, 0x3F, 0x55, 0xA7, 0x58, 0xF4);

// {A63293E8-664E-48DB-A079-DF759E0509F7}
DEFINE_KNOWN_FOLDER(FOLDERID_Templates,           0xA63293E8, 0x664E, 0x48DB, 0xA0, 0x79, 0xDF, 0x75, 0x9E, 0x05, 0x09, 0xF7);

// {82A5EA35-D9CD-47C5-9629-E15D2F714E6E}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonStartup,       0x82A5EA35, 0xD9CD, 0x47C5, 0x96, 0x29, 0xE1, 0x5D, 0x2F, 0x71, 0x4E, 0x6E);

// {0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonPrograms,      0x0139D44E, 0x6AFE, 0x49F2, 0x86, 0x90, 0x3D, 0xAF, 0xCA, 0xE6, 0xFF, 0xB8);

// {A4115719-D62E-491D-AA7C-E74B8BE3B067}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonStartMenu,     0xA4115719, 0xD62E, 0x491D, 0xAA, 0x7C, 0xE7, 0x4B, 0x8B, 0xE3, 0xB0, 0x67);

// {C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDesktop,       0xC4AA340D, 0xF20F, 0x4863, 0xAF, 0xEF, 0xF8, 0x7E, 0xF2, 0xE6, 0xBA, 0x25);

// {62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramData,         0x62AB5D82, 0xFDC1, 0x4DC3, 0xA9, 0xDD, 0x07, 0x0D, 0x1D, 0x49, 0x5D, 0x97);

// {B94237E7-57AC-4347-9151-B08C6C32D1F7}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonTemplates,     0xB94237E7, 0x57AC, 0x4347, 0x91, 0x51, 0xB0, 0x8C, 0x6C, 0x32, 0xD1, 0xF7);

// {ED4824AF-DCE4-45A8-81E2-FC7965083634}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDocuments,     0xED4824AF, 0xDCE4, 0x45A8, 0x81, 0xE2, 0xFC, 0x79, 0x65, 0x08, 0x36, 0x34);

// {3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}
DEFINE_KNOWN_FOLDER(FOLDERID_RoamingAppData,      0x3EB685DB, 0x65F9, 0x4CF6, 0xA0, 0x3A, 0xE3, 0xEF, 0x65, 0x72, 0x9F, 0x3D);

// {F1B32785-6FBA-4FCF-9D55-7B8E7F157091}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalAppData,        0xF1B32785, 0x6FBA, 0x4FCF, 0x9D, 0x55, 0x7B, 0x8E, 0x7F, 0x15, 0x70, 0x91);

// {A520A1A4-1780-4FF6-BD18-167343C5AF16}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalAppDataLow,     0xA520A1A4, 0x1780, 0x4FF6, 0xBD, 0x18, 0x16, 0x73, 0x43, 0xC5, 0xAF, 0x16);

// {352481E8-33BE-4251-BA85-6007CAEDCF9D}
DEFINE_KNOWN_FOLDER(FOLDERID_InternetCache,       0x352481E8, 0x33BE, 0x4251, 0xBA, 0x85, 0x60, 0x07, 0xCA, 0xED, 0xCF, 0x9D);

// {2B0F765D-C0E9-4171-908E-08A611B84FF6}
DEFINE_KNOWN_FOLDER(FOLDERID_Cookies,             0x2B0F765D, 0xC0E9, 0x4171, 0x90, 0x8E, 0x08, 0xA6, 0x11, 0xB8, 0x4F, 0xF6);

// {D9DC8A3B-B784-432E-A781-5A1130A75963}
DEFINE_KNOWN_FOLDER(FOLDERID_History,             0xD9DC8A3B, 0xB784, 0x432E, 0xA7, 0x81, 0x5A, 0x11, 0x30, 0xA7, 0x59, 0x63);

// {1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}
DEFINE_KNOWN_FOLDER(FOLDERID_System,              0x1AC14E77, 0x02E7, 0x4E5D, 0xB7, 0x44, 0x2E, 0xB1, 0xAE, 0x51, 0x98, 0xB7);

// {D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}
DEFINE_KNOWN_FOLDER(FOLDERID_SystemX86,           0xD65231B0, 0xB2F1, 0x4857, 0xA4, 0xCE, 0xA8, 0xE7, 0xC6, 0xEA, 0x7D, 0x27);

// {F38BF404-1D43-42F2-9305-67DE0B28FC23}
DEFINE_KNOWN_FOLDER(FOLDERID_Windows,             0xF38BF404, 0x1D43, 0x42F2, 0x93, 0x05, 0x67, 0xDE, 0x0B, 0x28, 0xFC, 0x23);

// {5E6C858F-0E22-4760-9AFE-EA3317B67173}
DEFINE_KNOWN_FOLDER(FOLDERID_Profile,             0x5E6C858F, 0x0E22, 0x4760, 0x9A, 0xFE, 0xEA, 0x33, 0x17, 0xB6, 0x71, 0x73);

// {33E28130-4E1E-4676-835A-98395C3BC3BB}
DEFINE_KNOWN_FOLDER(FOLDERID_Pictures,            0x33E28130, 0x4E1E, 0x4676, 0x83, 0x5A, 0x98, 0x39, 0x5C, 0x3B, 0xC3, 0xBB);

// {7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesX86,     0x7C5A40EF, 0xA0FB, 0x4BFC, 0x87, 0x4A, 0xC0, 0xF2, 0xE0, 0xB9, 0xFA, 0x8E);

// {DE974D24-D9C6-4D3E-BF91-F4455120B917}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommonX86, 0xDE974D24, 0xD9C6, 0x4D3E, 0xBF, 0x91, 0xF4, 0x45, 0x51, 0x20, 0xB9, 0x17);

// {6D809377-6AF0-444b-8957-A3773F02200E}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesX64,     0x6d809377, 0x6af0, 0x444b, 0x89, 0x57, 0xa3, 0x77, 0x3f, 0x02, 0x20, 0x0e );

// {6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommonX64, 0x6365d5a7, 0xf0d, 0x45e5, 0x87, 0xf6, 0xd, 0xa5, 0x6b, 0x6a, 0x4f, 0x7d );

// {905e63b6-c1bf-494e-b29c-65b732d3d21a}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFiles,        0x905e63b6, 0xc1bf, 0x494e, 0xb2, 0x9c, 0x65, 0xb7, 0x32, 0xd3, 0xd2, 0x1a);

// {F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommon,  0xF7F1ED05, 0x9F6D, 0x47A2, 0xAA, 0xAE, 0x29, 0xD3, 0x17, 0xC6, 0xF0, 0x66);

// {724EF170-A42D-4FEF-9F26-B60E846FBA4F}
DEFINE_KNOWN_FOLDER(FOLDERID_AdminTools,          0x724EF170, 0xA42D, 0x4FEF, 0x9F, 0x26, 0xB6, 0x0E, 0x84, 0x6F, 0xBA, 0x4F);

// {D0384E7D-BAC3-4797-8F14-CBA229B392B5}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonAdminTools,    0xD0384E7D, 0xBAC3, 0x4797, 0x8F, 0x14, 0xCB, 0xA2, 0x29, 0xB3, 0x92, 0xB5);

// {4BD8D571-6D19-48D3-BE97-422220080E43}
DEFINE_KNOWN_FOLDER(FOLDERID_Music,               0x4BD8D571, 0x6D19, 0x48D3, 0xBE, 0x97, 0x42, 0x22, 0x20, 0x08, 0x0E, 0x43);

// {18989B1D-99B5-455B-841C-AB7C74E4DDFC}
DEFINE_KNOWN_FOLDER(FOLDERID_Videos,              0x18989B1D, 0x99B5, 0x455B, 0x84, 0x1C, 0xAB, 0x7C, 0x74, 0xE4, 0xDD, 0xFC);

// {B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicPictures,      0xB6EBFB86, 0x6907, 0x413C, 0x9A, 0xF7, 0x4F, 0xC2, 0xAB, 0xF0, 0x7C, 0xC5);

// {3214FAB5-9757-4298-BB61-92A9DEAA44FF}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicMusic,         0x3214FAB5, 0x9757, 0x4298, 0xBB, 0x61, 0x92, 0xA9, 0xDE, 0xAA, 0x44, 0xFF);

// {2400183A-6185-49FB-A2D8-4A392A602BA3}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicVideos,        0x2400183A, 0x6185, 0x49FB, 0xA2, 0xD8, 0x4A, 0x39, 0x2A, 0x60, 0x2B, 0xA3);

// {8AD10C31-2ADB-4296-A8F7-E4701232C972}
DEFINE_KNOWN_FOLDER(FOLDERID_ResourceDir,         0x8AD10C31, 0x2ADB, 0x4296, 0xA8, 0xF7, 0xE4, 0x70, 0x12, 0x32, 0xC9, 0x72);

// {2A00375E-224C-49DE-B8D1-440DF7EF3DDC}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalizedResourcesDir, 0x2A00375E, 0x224C, 0x49DE, 0xB8, 0xD1, 0x44, 0x0D, 0xF7, 0xEF, 0x3D, 0xDC);

// {C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonOEMLinks,      0xC1BAE2D0, 0x10DF, 0x4334, 0xBE, 0xDD, 0x7A, 0xA2, 0x0B, 0x22, 0x7A, 0x9D);

// {9E52AB10-F80D-49DF-ACB8-4330F5687855}
DEFINE_KNOWN_FOLDER(FOLDERID_CDBurning,           0x9E52AB10, 0xF80D, 0x49DF, 0xAC, 0xB8, 0x43, 0x30, 0xF5, 0x68, 0x78, 0x55);

// {0762D272-C50A-4BB0-A382-697DCD729B80}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProfiles,        0x0762D272, 0xC50A, 0x4BB0, 0xA3, 0x82, 0x69, 0x7D, 0xCD, 0x72, 0x9B, 0x80);

// {DE92C1C7-837F-4F69-A3BB-86E631204A23}
DEFINE_KNOWN_FOLDER(FOLDERID_Playlists,           0xDE92C1C7, 0x837F, 0x4F69, 0xA3, 0xBB, 0x86, 0xE6, 0x31, 0x20, 0x4A, 0x23);

// {15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}
DEFINE_KNOWN_FOLDER(FOLDERID_SamplePlaylists,     0x15CA69B3, 0x30EE, 0x49C1, 0xAC, 0xE1, 0x6B, 0x5E, 0xC3, 0x72, 0xAF, 0xB5);

// {B250C668-F57D-4EE1-A63C-290EE7D1AA1F}
DEFINE_KNOWN_FOLDER(FOLDERID_SampleMusic,         0xB250C668, 0xF57D, 0x4EE1, 0xA6, 0x3C, 0x29, 0x0E, 0xE7, 0xD1, 0xAA, 0x1F);

// {C4900540-2379-4C75-844B-64E6FAF8716B}
DEFINE_KNOWN_FOLDER(FOLDERID_SamplePictures,      0xC4900540, 0x2379, 0x4C75, 0x84, 0x4B, 0x64, 0xE6, 0xFA, 0xF8, 0x71, 0x6B);

// {859EAD94-2E85-48AD-A71A-0969CB56A6CD}
DEFINE_KNOWN_FOLDER(FOLDERID_SampleVideos,        0x859EAD94, 0x2E85, 0x48AD, 0xA7, 0x1A, 0x09, 0x69, 0xCB, 0x56, 0xA6, 0xCD);

// {69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}
DEFINE_KNOWN_FOLDER(FOLDERID_PhotoAlbums,         0x69D2CF90, 0xFC33, 0x4FB7, 0x9A, 0x0C, 0xEB, 0xB0, 0xF0, 0xFC, 0xB4, 0x3C);

// {DFDF76A2-C82A-4D63-906A-5644AC457385}
DEFINE_KNOWN_FOLDER(FOLDERID_Public,              0xDFDF76A2, 0xC82A, 0x4D63, 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85);

// {df7266ac-9274-4867-8d55-3bd661de872d}
DEFINE_KNOWN_FOLDER(FOLDERID_ChangeRemovePrograms,0xdf7266ac, 0x9274, 0x4867, 0x8d, 0x55, 0x3b, 0xd6, 0x61, 0xde, 0x87, 0x2d);

// {a305ce99-f527-492b-8b1a-7e76fa98d6e4}
DEFINE_KNOWN_FOLDER(FOLDERID_AppUpdates,          0xa305ce99, 0xf527, 0x492b, 0x8b, 0x1a, 0x7e, 0x76, 0xfa, 0x98, 0xd6, 0xe4);

// {de61d971-5ebc-4f02-a3a9-6c82895e5c04}
DEFINE_KNOWN_FOLDER(FOLDERID_AddNewPrograms,      0xde61d971, 0x5ebc, 0x4f02, 0xa3, 0xa9, 0x6c, 0x82, 0x89, 0x5e, 0x5c, 0x04);

// {374DE290-123F-4565-9164-39C4925E467B}
DEFINE_KNOWN_FOLDER(FOLDERID_Downloads,           0x374de290, 0x123f, 0x4565, 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b);

// {3D644C9B-1FB8-4f30-9B45-F670235F79C0}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDownloads,     0x3d644c9b, 0x1fb8, 0x4f30, 0x9b, 0x45, 0xf6, 0x70, 0x23, 0x5f, 0x79, 0xc0);

// {7d1d3a04-debb-4115-95cf-2f29da2920da}
DEFINE_KNOWN_FOLDER(FOLDERID_SavedSearches,       0x7d1d3a04, 0xdebb, 0x4115, 0x95, 0xcf, 0x2f, 0x29, 0xda, 0x29, 0x20, 0xda);

// {52a4f021-7b75-48a9-9f6b-4b87a210bc8f}
DEFINE_KNOWN_FOLDER(FOLDERID_QuickLaunch,         0x52a4f021, 0x7b75, 0x48a9, 0x9f, 0x6b, 0x4b, 0x87, 0xa2, 0x10, 0xbc, 0x8f);

// {56784854-C6CB-462b-8169-88E350ACB882}
DEFINE_KNOWN_FOLDER(FOLDERID_Contacts,            0x56784854, 0xc6cb, 0x462b, 0x81, 0x69, 0x88, 0xe3, 0x50, 0xac, 0xb8, 0x82);

// {A75D362E-50FC-4fb7-AC2C-A8BEAA314493}
DEFINE_GUID(FOLDERID_SidebarParts,                0xa75d362e, 0x50fc, 0x4fb7, 0xac, 0x2c, 0xa8, 0xbe, 0xaa, 0x31, 0x44, 0x93);

// {7B396E54-9EC5-4300-BE0A-2482EBAE1A26}
DEFINE_GUID(FOLDERID_SidebarDefaultParts,         0x7b396e54, 0x9ec5, 0x4300, 0xbe, 0xa, 0x24, 0x82, 0xeb, 0xae, 0x1a, 0x26);

// {5b3749ad-b49f-49c1-83eb-15370fbd4882}
DEFINE_KNOWN_FOLDER(FOLDERID_TreeProperties,      0x5b3749ad, 0xb49f, 0x49c1, 0x83, 0xeb, 0x15, 0x37, 0x0f, 0xbd, 0x48, 0x82);

// {DEBF2536-E1A8-4c59-B6A2-414586476AEA}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicGameTasks,     0xdebf2536, 0xe1a8, 0x4c59, 0xb6, 0xa2, 0x41, 0x45, 0x86, 0x47, 0x6a, 0xea);

// {054FAE61-4DD8-4787-80B6-090220C4B700}
DEFINE_KNOWN_FOLDER(FOLDERID_GameTasks,           0x54fae61, 0x4dd8, 0x4787, 0x80, 0xb6, 0x9, 0x2, 0x20, 0xc4, 0xb7, 0x0);

// {4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}
DEFINE_KNOWN_FOLDER(FOLDERID_SavedGames,          0x4c5c32ff, 0xbb9d, 0x43b0, 0xb5, 0xb4, 0x2d, 0x72, 0xe5, 0x4e, 0xaa, 0xa4);

// {CAC52C1A-B53D-4edc-92D7-6B2E8AC19434}
DEFINE_KNOWN_FOLDER(FOLDERID_Games,               0xcac52c1a, 0xb53d, 0x4edc, 0x92, 0xd7, 0x6b, 0x2e, 0x8a, 0xc1, 0x94, 0x34);

// {bd85e001-112e-431e-983b-7b15ac09fff1}
DEFINE_KNOWN_FOLDER(FOLDERID_RecordedTV,          0xbd85e001, 0x112e, 0x431e, 0x98, 0x3b, 0x7b, 0x15, 0xac, 0x09, 0xff, 0xf1);

// {98ec0e18-2098-4d44-8644-66979315a281}
DEFINE_KNOWN_FOLDER(FOLDERID_SEARCH_MAPI,         0x98ec0e18, 0x2098, 0x4d44, 0x86, 0x44, 0x66, 0x97, 0x93, 0x15, 0xa2, 0x81);

// {ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}
DEFINE_KNOWN_FOLDER(FOLDERID_SEARCH_CSC,          0xee32e446, 0x31ca, 0x4aba, 0x81, 0x4f, 0xa5, 0xeb, 0xd2, 0xfd, 0x6d, 0x5e);

// {bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}
DEFINE_KNOWN_FOLDER(FOLDERID_Links,               0xbfb9d5e0, 0xc6a9, 0x404c, 0xb2, 0xb2, 0xae, 0x6d, 0xb6, 0xaf, 0x49, 0x68);

// {f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}
DEFINE_KNOWN_FOLDER(FOLDERID_UsersFiles,          0xf3ce0f7c, 0x4901, 0x4acc, 0x86, 0x48, 0xd5, 0xd4, 0x4b, 0x04, 0xef, 0x8f);

// {190337d1-b8ca-4121-a639-6d472d16972a}
DEFINE_KNOWN_FOLDER(FOLDERID_SearchHome,          0x190337d1, 0xb8ca, 0x4121, 0xa6, 0x39, 0x6d, 0x47, 0x2d, 0x16, 0x97, 0x2a);

// {2C36C0AA-5812-4b87-BFD0-4CD0DFB19B39}
DEFINE_KNOWN_FOLDER(FOLDERID_OriginalImages,      0x2C36C0AA, 0x5812, 0x4b87, 0xbf, 0xd0, 0x4c, 0xd0, 0xdf, 0xb1, 0x9b, 0x39);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\kxarm.h ===
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Use of this sample source code is subject to the terms of the Microsoft
; license agreement under which you licensed this sample source code. If
; you did not accept the terms of the license agreement, you are not
; authorized to use this sample source code. For the terms of the license,
; please see the license agreement between you and Microsoft or, if applicable,
; see the LICENSE.RTF on your install media or the root of your tools installation.
; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
;
;++
;
;
; Module Name:
;
;    kxarm.h
;
; Abstract:
;
;    This is an implementation of the WINCE/ARM Calling Sequence
;    Specification.
;
; Environment:
;    String Library
;
; Revision History:
;--

        GBLS    VBar
VBar    SETS    "|"
        GBLL    HaveExceptHandler
        GBLS    AreaName
        GBLS    FuncName
        GBLS    PrologName
        GBLS    FuncEndName
        GBLS    ExceptHandler
        GBLS    ExceptData
AreaName SETS   "|.text|"
HaveExceptHandler SETL {FALSE}

    MACRO
    TEXTAREA
    AREA |.text|,ALIGN=2,CODE,READONLY
AreaName SETS "|.text|"
    MEND

    MACRO
    THUMBAREA
    AREA |.text|,ALIGN=2,CODE,READONLY,THUMB
AreaName SETS "|.text|"
    MEND

    MACRO
    STARTUPTEXT
    AREA |.astart|,ALIGN=2,CODE
AreaName SETS "|.astart|"
    MEND

    MACRO
    START_REGION    $NameBegin
    LCLS    TempName
TempName SETS    VBar:CC:"$NameBegin":CC:VBar
    EXPORT  $TempName[DATA]
$TempName
    MEND

    MACRO
    END_REGION      $NameEnd
    LCLS    TempName
TempName SETS    VBar:CC:"$NameEnd":CC:VBar
    EXPORT  $TempName[DATA]
$TempName
    MEND

;
;   This macro should be used if the assembly function is in ARM
;

    MACRO
    NESTED_ARMENTRY $Name
FuncName    SETS    VBar:CC:"$Name":CC:VBar
PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar
FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar
    LCLS    ExceptBit
    IF HaveExceptHandler
ExceptBit   SETS    "0x80000000"
    ELSE
ExceptBit   SETS    "0"
    ENDIF

    AREA |.pdata|,ALIGN=2,PDATA
    DCD     $FuncName
    DCD     (($PrologName-$FuncName)/4) :OR: ((($FuncEndName-$FuncName)/4):SHL:8) :OR: 0x40000000 :OR: $ExceptBit
    AREA $AreaName,CODE,READONLY
    ALIGN   2
    EXPORT  $FuncName [FUNC]
    IF HaveExceptHandler
    DCD $ExceptHandler
    DCD $ExceptData
HaveExceptHandler SETL {FALSE}
    ENDIF
$FuncName
    ROUT
    MEND

;
;   This macro should be used if the assembly function is in THUMB
;
    MACRO
    NESTED_THUMBENTRY   $Name
FuncName    SETS    VBar:CC:"$Name":CC:VBar
PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar
FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar
    LCLS    ExceptBit
    IF HaveExceptHandler
ExceptBit   SETS    "0x80000000"
    ELSE
ExceptBit   SETS    "0"
    ENDIF

    AREA |.pdata|,ALIGN=2,PDATA
    DCD     $FuncName
    DCD     (($PrologName-$FuncName)/2) :OR: ((($FuncEndName-$FuncName)/2):SHL:8) :OR: $ExceptBit
    AREA $AreaName,CODE,READONLY
    ALIGN   2
    EXPORT  $FuncName [FUNC]
    IF HaveExceptHandler
    DCD $ExceptHandler
    DCD $ExceptData
HaveExceptHandler SETL {FALSE}
    ENDIF
$FuncName
    ROUT
    MEND

;
;   This macro should be used if the assembly function is in ARM
;
    MACRO
    NESTED_ENTRY    $Name
FuncName    SETS    VBar:CC:"$Name":CC:VBar
PrologName  SETS    VBar:CC:"$Name":CC:"_Prolog":CC:VBar
FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar
    LCLS    ExceptBit
    IF HaveExceptHandler
ExceptBit   SETS    "0x80000000"
    ELSE
ExceptBit   SETS    "0"
    ENDIF

    AREA |.pdata|,ALIGN=2,PDATA
    DCD     $FuncName
    DCD     (($PrologName-$FuncName)/4) :OR: ((($FuncEndName-$FuncName)/4):SHL:8) :OR: 0x40000000 :OR: $ExceptBit
    AREA $AreaName,CODE,READONLY
    ALIGN   2
    EXPORT  $FuncName [FUNC]
    IF HaveExceptHandler
    DCD $ExceptHandler
    DCD $ExceptData
HaveExceptHandler SETL {FALSE}
    ENDIF
$FuncName
    ROUT
    MEND

    MACRO
    PROLOG_END
$PrologName
    MEND

    MACRO
    LEAF_ENTRY  $Name
FuncName SETS    VBar:CC:"$Name":CC:VBar
PrologName SETS "Invalid Prolog"
FuncEndName SETS    VBar:CC:"$Name":CC:"_end":CC:VBar
    ALIGN   2
    EXPORT  $FuncName [FUNC]
$FuncName
    ROUT
    MEND

    MACRO
    ALTERNATE_ENTRY $Name
    LCLS    TempName
TempName SETS    VBar:CC:"$Name":CC:VBar
    EXPORT  $TempName [FUNC]
$TempName
    MEND

    MACRO
    ENTRY_END   $Name
$FuncEndName
    MEND

    MACRO
    EXCEPTION_HANDLER   $Handler
ExceptHandler SETS    VBar:CC:"$Handler":CC:VBar
ExceptData SETS "0"
HaveExceptHandler SETL {TRUE}
    MEND

    MACRO
    EXCEPTION_HANDLER_DATA  $Handler, $HandlerData
ExceptHandler SETS    VBar:CC:"$Handler":CC:VBar
ExceptData SETS    VBar:CC:"$HandlerData":CC:VBar
HaveExceptHandler SETL {TRUE}
    MEND

    MACRO
    EXCEPTION_HANDLER_MILLICODE $Handler, $HandlerData
ExceptHandler SETS    "$Handler"
ExceptData SETS    "$HandlerData"
HaveExceptHandler SETL {TRUE}
    MEND

CE_NEW_MAPPING_TABLE EQU    0x87654321

    END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\kxx86.inc ===
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Use of this source code is subject to the terms of the Microsoft shared
; source or premium shared source license agreement under which you licensed
; this source code. If you did not accept the terms of the license agreement,
; you are not authorized to use this source code. For the terms of the license,
; please see the license agreement between you and Microsoft or, if applicable,
; see the SOURCE.RTF on your install media or the root of your tools installation.
; THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
;
;-------------------------------------------------------------------------------
;
;
;-------------------------------------------------------------------------------

CE_NEW_MAPPING_TABLE  	EQU 	087654321h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\l2cmn.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft shared
// source or premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license agreement,
// you are not authorized to use this source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the SOURCE.RTF on your install media or the root of your tools installation.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 2004 Microsoft Corporation

Module Name:

    l2cmn.h

Abstract:

    Definitions and data strcutures for common layer 2

Environment:

    User mode only

--*/

#ifndef _L2CMN_H
#define _L2CMN_H

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// Profile name max length, in characters
#define L2_PROFILE_MAX_NAME_LENGTH     256

// If a notification needs to be private that is only consumed by internal components 
// then it should be part of l2cmnpriv.h 


// the types of notification
// This signifies what kind of notification is to be passed on , the 
// 0X0000FFFF  signifies all public notifications , so all notfications that need to be public 
// should be in this range and have a single bit set as these flags can be combined.
#define L2_NOTIFICATION_SOURCE_NONE                   0
#define L2_NOTIFICATION_SOURCE_DOT3_AUTO_CONFIG       0X00000001
#define L2_NOTIFICATION_SOURCE_SECURITY  		    0X00000002
#define L2_NOTIFICATION_SOURCE_ONEX                   0X00000004	
#define L2_NOTIFICATION_SOURCE_WLAN_ACM          0X00000008
#define L2_NOTIFICATION_SOURCE_WLAN_MSM          0X00000010
#define L2_NOTIFICATION_SOURCE_WLAN_SECURITY     0X00000020
#define L2_NOTIFICATION_SOURCE_WLAN_IHV          0X00000040

#define L2_NOTIFICATION_SOURCE_ALL          				0X0000FFFF
#define L2_NOTIFICATION_CODE_PUBLIC_BEGIN         0X00000000

// L2 reason code 
// reason code bases
#define L2_REASON_CODE_GROUP_SIZE             0x10000
#define L2_REASON_CODE_GEN_BASE               0x10000
#define L2_REASON_CODE_DOT11_AC_BASE          (L2_REASON_CODE_GEN_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT11_MSM_BASE         (L2_REASON_CODE_DOT11_AC_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT11_SECURITY_BASE    (L2_REASON_CODE_DOT11_MSM_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_ONEX_BASE              (L2_REASON_CODE_DOT11_SECURITY_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT3_AC_BASE           (L2_REASON_CODE_ONEX_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT3_MSM_BASE          (L2_REASON_CODE_DOT3_AC_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_PROFILE_BASE           (L2_REASON_CODE_DOT3_MSM_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_IHV_BASE               (L2_REASON_CODE_PROFILE_BASE+L2_REASON_CODE_GROUP_SIZE)

// the common reason codes
#define L2_REASON_CODE_SUCCESS			      0

// general reason code
#define L2_REASON_CODE_UNKNOWN                  (L2_REASON_CODE_GEN_BASE+1)

// common profile section missing
#define L2_REASON_CODE_PROFILE_MISSING          0x00000001

// This structure is the notification structure which needs to be filled in by each component 
// The interface guid is filled in only by the AC 
// The NotificationSource signifies the type above 
// and NotificationCode is one of the enum values 
typedef struct _L2_NOTIFICATION_DATA {
    DWORD NotificationSource;
    DWORD NotificationCode;
    GUID InterfaceGuid;
    DWORD dwDataSize;
    
#ifdef __midl
    [unique, size_is(dwDataSize)] PBYTE pData;
#else
    __field_bcount(dwDataSize) PVOID pData;
#endif

} L2_NOTIFICATION_DATA, *PL2_NOTIFICATION_DATA;

#ifdef __cplusplus
}
#endif

#endif  // _L2CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\lass.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef LASS_H
#define LASS_H
#include <windows.h>

#ifdef __cplusplus 
extern "C" { 
#endif 

//Acronyms:
// (LASS)- Local Authentication Sub System
// (LAP) Local Authentication Plugin



//
//  Config Info
//  Per Authentication Event.
// AEFrequencyType
//

#define FT_Every_FV 0  // Every  FrequencyValue Time. set to 0 to validate every time.
#define FT_Minutes_Idle  1// Minites idle -- Not Yet Supported
#define FT_Minutes_Since_Any_AE_Verified  2 // Minites since Any AE returned from VerifyUser Succesfully
#define FT_Minutes_Since_This_AE_Verified 3 // Minites since This AE returned from VerifyUser Succesfully.


typedef struct  _AuthenticationEvent 
{
    GUID AEKey; /*Key to make all entries unique.*/
    LPWSTR Name; /*Friendly Name*/
    int  FrequencyType; /*Tells us how to interpret FrequencyValue*/
    int  FrequencyValue;   /* Used with FrequencyType */
} AuthenticationEvent;


//
//
// Some authentication Events are pre-defined - and should have special handlers in 
// The LAPs 
// Examples: 
//  



//
//  LASS Exports: 
//




// VerifyUser
// 
//  returns
//     TRUE ->  User Verified.
//     FALSE -> User not verified. GetLastError contains error.
// GetLastError () returns 
//  ERROR_CANCELLED <= The user cancelled the verification Request.
//  ERROR_WRONG_PASSWORD <= Generic code for user failed authentication. If more applicable 
                        //  code the LAP  will set it.

// Flags for dwOptions feild in Verify User.
#define VU_NO_UI  0x1      /*Return true only if a call to the LAP isn't necassary.*/
#define VU_UNTIL_SUCCESS  0x2 /* Verify User will return only if user clikced cancel, or got password correct.*/
#define VU_HANDLE_MASTER_KEY  0x4 /* Handle MasterKey Encryption/Decryption if possible. */

BOOL VerifyUser(const GUID *AEKey, /* Authenication Event Identifier */
                LPCWSTR wszAEDisplayText, /*Text Plugin will display, if null use from registry.*/
                HWND   hWndParent, /*Parent Window if Available-else use desktop window*/
                DWORD  dwOptions, /*Bitmask of possible options.*/
                PVOID pExtended /*Reserved, must be 0*/
                );

//
// Example 1: 
//     An app that wished to authenticate the user before calling a Secure Function.
//
// APP A:
// HWND hMyWindow;
// VerifyAndCallSecureFunction () 
// {
//    DWORD LastError;
//    GUID AEKeyForFoo = ...;
//
//    if (VerifyUser(&AEKeyForFoo,"App A",hMyWindow,VU_UNTIL_SUCCESS,0))  //  Call into LASS; This will  
//          CallSecureFunction()                //  call into the active LAP 
//                                              //  and show LAP specific UI.
//     else 
//          TellUserVerificationFailed(GetLastError()));  // <- display your own UI
// }
//
//


// Must be trusted to call this.
// Causes the LASS to re-read its configuration settings.
BOOL  LASSReloadConfig();

// Causes the LAP to enroll.
// Must be trusted to call this.
BOOL CreateEnrollmentConfigDialog(HWND hParentWindow);

// This function provides a method to query the LASS for values. 
BOOL LASSGetValue(DWORD ValueId,PVOID lpvOutBuffer, DWORD cbOutBuffer, DWORD* pcbReturned);

typedef HANDLE HLASS;

// This function starts an Async Verify User call.
HLASS VerifyUserAsync(const GUID *AEKey, /* Authenication Event Identifier */
                LPCWSTR wszAEDisplayText, /*Text Plugin will display, if null use from registry.*/
                HWND   hWndParent, /*Parent Window if Available-else use desktop window*/
                DWORD  dwOptions, /*Bitmask of possible options.*/
                PVOID pExtended /*Reserved, must be 0*/
                );

// This function picks up the results of an asyncronous API.
BOOL LASSGetResult(HLASS h);

// This function close an HLASS.
BOOL LASSClose(HLASS h);


// Valid values are: 
#define  LASS_VALUE_DEVICE_WIPE_THRESHOLD	 1 
//   Returns the device wipe threshold. Returns 0 if there is no device wipe
//   threshold set.	

#define  LASS_VALUE_AUTH_FAILURE_COUNT	  2
//   Returns the number of authentication failures.  If there have been no
//   failures This will return 0.



//
// This is a named event an application can wait on to 
// be notified when LASS has started. Before this event 
// is set, all LASS calls will fail.
// 

#define LASS_SRV_STARTED_EVENT_NAME L"LASS_SRV_STARTED"


// Paths used during installation - may move to another location.
//////////////////////////////////////////////////////////////////////////////
//  LAP Installation Information. - move to lap.h
//////////////////////////////////////////////////////////////////////////////
// Paths used during installation - may move to another location.
#define REG_LAP_ROOT L"Comm\\Security\\LASSD\\LAP"
#define REG_LOCKOUT_ROOT L"Comm\\Security\\LASSD\\LockOut"
#define REG_AE_ROOT L"Comm\\Security\\LASSD\\AE"
#define REG_LAP_ACTIVE_VALUE L"ActiveLap"

#define REG_AE_FRIENDLY_NAME_VALUE L"FriendlyName"
#define REG_AE_DISPLAY_TEXT_VALUE  L"DisplayText"
#define REG_AE_AUTH_FREQ_VALUE L"AEFrequencyValue"
#define REG_AE_AUTH_FREQ_TYPE L"AEFrequencyType"


#define REG_LASS_POLICY_ROOT L"Comm\\Security\\LASSD"
// Policy settings found under REG_LASS_POLICY_ROOT

#define REG_CODE_WORD L"CodeWord"
#define REG_CODE_WORD_FREQUENCY L"CodeWordFrequency"
#define REG_DEVICE_WIPE_THRESHOLD L"DeviceWipeThreshold"

#define REG_LOCKOUT_THRESHOLD L"Threshold"
#define REG_LOCKOUT_INITIAL_PENALTY L"InitialPenalty"
#define REG_LOCKOUT_INCRIMENTAL_PENALTY  L"IncrementalPenalty"

#ifdef __cplusplus 
}
#endif 

#endif //#ifndef LASS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ksuuids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//
// contains the GUIDs for the MediaType type, subtype fields and format types 
// for DVD/MPEG2 media types.


//
// --- MPEG 2 definitions ---
//

// 36523B13-8EE5-11d1-8CA3-0060B057664A
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PACK,
0x36523B13, 0x8EE5, 0x11d1, 0x8C, 0xA3, 0x00, 0x60, 0xB0, 0x57, 0x66, 0x4A)

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0


// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,                             
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange, 
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)


// {582C8C6A-6F45-4056-827B-D3C9E37A0FE4}
OUR_GUID_ENTRY(AM_KSPROPSETID_RendererPosition,
0x582c8c6a, 0x6f45, 0x4056, 0x82, 0x7b, 0xd3, 0xc9, 0xe3, 0x7a, 0xf, 0xe4)




//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)               

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


// 07dad660L-22f1-11d1-a9f4-00c04fbbde8f
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC,
0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f)


// 0A4252A0L-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_SPLITTER,
0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)


//
// guids needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 28F54685-06FD-11D2-B27A-00A0C9223196
OUR_GUID_ENTRY(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196
OUR_GUID_ENTRY(IID_IKsPinFactory,
0xCD5EBE6BL, 0x8B6E, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\lap.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef LAP_H
#define LAP_H

#ifdef __cplusplus 
extern "C" { 
#endif 

#include <windows.h>
#include <lass.h>

//
// All Local Authentication Plugin (LAP) must  implement the following interface:
//


// Support masterkey protection sementics
#define LAP_CAPABILITIES_MASTER_KEY 0x1 

typedef struct _InitLap
{
    DWORD size; // Used for version info contains size of this struct.
                // _InitLap will only grow as new functionality added.
                // A LAP should work even if InitLap.size >= sizeof(InitLap)

                // However, a LAP should not work if InitLap.size < sizeof(InitLap)

    DWORD capabilities; // Expect LAP will fill in with the LAP_CAPABILITIES_* it supports.
} InitLap;

// Sent to a LAP when it is activated.
//  Allows LAP to indicate its capabilities.
BOOL InitLAP(
        InitLap *il
        );


// Sent to a LAP when it is being unloaded.
void DeinitLAP();


//Tells the lap to verify the user.
#if 0
// From lass.h
BOOL VerifyUser(const GUID *AEKey, /* Authenication Event Identifier */
                LPCWSTR pwszAEDisplayText, /*Text Plugin will display, if null use from registry.*/
                HWND   hWndParent, /*Parent Window if Available-else use desktop window*/
                DWORD  dwOptions, /*Bitmask of possible options.*/
                PVOID pExtended /*Reserved, must be 0*/
                );

#endif 

// Causes the LAP to enroll.
// App calls CreateEnrollmentConfigDialog and then LASS will call LAPCreateEnrollmentConfigDialog
BOOL LAPCreateEnrollmentConfigDialog(HWND hParentWindow,DWORD dwOptions);

// An application calling VerifyUser with the VU_UNTIL_SUCCESS flag, can result
// in several calls to VerifyUser in the LAP. To prevent UI flash,
// VerifyUserStart will be called before any sequence of VerifyUser
// calls are made into the LAP.  After all VerifyUser calls have been made a call to
// VerifyUserStop will be made.

//
//   APP       |       |    LASS            |       | LAP   |
// ------------+       +--------------------+       +-------+
// VerifyUser()| --->  |                    |       |       |
//             |       |  VerifyUserStart() | --->  |       |
//             |       |                    | <---  |       |
//             |       |                    |       |       |
//             |       |  VerifyUser()      | --->  |       |
//             |       |                    | <---  |       |
//             |       |                    |       |       |
//             |       |  VerifyUser()      | --->  |       |
//             |       |                    | <---  |       |
//             |       |                    |       |       |
//             |       |  VerifyUserStop()  | --->  |       |
//             |       |                    | <---  |       |
//             |       |                    |       |       |
//             | <---  |                    |       |       |       
//


// VerifyUserStart gets the same paramaters as the 
// VerifyUser call.
VOID  VerifyUserStart(const GUID *AEKey, /* Authenication Event Identifier */
                LPCWSTR pwszAEDisplayText, /*Text Plugin will display, if null use from registry.*/
                HWND   hWndParent, /*Parent Window if Available-else use desktop window*/
                DWORD  dwOptions, /*Bitmask of possible options.*/
                PVOID pExtended /*Reserved, must be 0*/
                );

VOID  VerifyUserStop();

// Application calls to VerifyUser block.  This can be an issue in the
// following scenario: 

// APP1 calls VerifyUser, LAP displays UI. APP2 runs and displays UI on top of
// the LAP's UI. APP2 then calls VerifyUser and blocks.  At this point APP2 is
// blocked, but the LAP's UI is behind the APP2 UI. 


// To mitigate this issue, when a VerifyUser call is in progress, and
// VerifyUser is called again, VerifyUserToTop is called, requesting the LAP
// bring its VerifyUser UI to the top of the z order.


//    APP1     |      |   APP2     |       |    LASS            |       | LAP   |
// ------------+      +------------+       +--------------------+       +-------+
// VerifyUser()| ----------------------->  |                    |       |       |
//             |      |            |       |  VerifyUserStart() | --->  |       |
//             |      |            |       |                    | <---  |       |
//             |      |            |       |                    |       |       |
//             |      |            |       |  VerifyUser()      | --->  |       |
//             |      |            |       |                    |       |       |
//             |      |VerifyUser()| --->  |                    |       |       |
//             |      |            |       |  VerifyUserToTop() |  ---> |       |
//             |      |            |       |                    | <---  |       |
//             |      |            |       |                    |       |       |
//             |      |            |       |  VerifyUserStop()  | --->  |       |
//             |      |            |       |                    | <---  |       |
//             |      |            |       |                    |       |       |
//             | <------------------------ |                    |       |       |
//             |      |            |       |                    |       |       |
//             |      |            |       |                    |       |       |

VOID  VerifyUserToTop();

// To ensure that a 'live' user is authenticating with the device the user
// can be periodically prompted to enter a codeword.  When LAPDisplayCodeword
// is called the  LAP should display a dialog prompting for pwszCodeword to be
// entered.

BOOL LAPDisplayCodeword(HWND hwndParent, LPCWSTR pwszCodeword);

// To ensure the user is aware on the next failed verification their device
// will be wiped, the user is notified.  When LAPDispalyPreWipe is called the
// LAP should display a dialog telling the user thier device will be wiped if
// there is one more failed auth.

BOOL LAPDisplayPreWipe(HWND hwndParent);

// To allow an application to cancel an existing call to VerifyUserAsync
// this API requests the LAP shutdown any of it's verification UI if possible. 
// This API maybe called anytime between VerifyUserStart and VerifyUserStop

BOOL LAPCancelVerifySequence();

// This API Is called when the user is required to be blocked from continuing
// for cSecondsToLockout seconds. The simplest implementation of this API is to
// sleep for cSeconds seconds. A more complex implementation of this API would
// display a dialog for cSeconds seconds, that informs the user how much time
// they are locked out for.

BOOL LAPLockoutUser(HWND hwnd, LPCWSTR , DWORD cSecondsToLockout);

#ifdef __cplusplus 
}
#endif 

#endif  // LAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\limits.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#include <crtdefs.h>

#ifndef _INC_LIMITS
#define _INC_LIMITS

#include "stdlib.h"

#ifndef SIZE_MAX
#define SIZE_MAX UINT_MAX
#endif

#endif // _INC_LIMITS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\lfapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

// Location Framework API.  Used to abstract applications from determining
// physical location.

#ifndef __LF_API_H
#define __LF_API_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

// Versioning information
#define LOCATION_FRAMEWORK_VERSION_1         1
#define LOCATION_FRAMEWORK_VERSION_CURRENT   LOCATION_FRAMEWORK_VERSION_1

DECLARE_HANDLE(HLOCATION);
DECLARE_HANDLE(HLOCATIONPLUGIN);

//***************************************************************
// Reports contain location information that is generated by the plugins.
// They may follow a well-known format defined by Microsoft (e.g. Lat/Long
// or 802.11 Access Points) or alternately may be extended for a custom
// purpose by the plugin writer (e.g. nearby RFID beacons).
//
// The report structure layout is analogous to sockaddr's in Winsock,
// in that the first few bytes contain common information (LOCATION_REPORT_BASE)
// and the remaining bytes are custom depending on the report context.
//***************************************************************

// LOCATION_REPORT must be typecast to specific report with 
// specific information.  It is always safe to typecast to a LOCATION_REPORT_BASE
// object since this is the first element for all reports.
typedef void LOCATION_REPORT;
typedef void * PLOCATION_REPORT;

// Base report.  All other reports will contain this as their first member.
typedef struct _LOCATION_REPORT_BASE {
    // Version of the plugin generating the report.
    DWORD    version;
    // Lat/Long, 802.11, etc..., that specifies what type of report this is.
    GUID     type;
    // sizeof this location object.
    DWORD    size;
    // GUID of the plugin DLL that generated this report
    GUID     plugin;
    // Time (based on GetCurrentFT()) this report was created
    FILETIME creationTime;
    // Flags options.  These will be defined globally for all report types (not context specific)
    // Currently no flags are defined.
    DWORD    flags;
} LOCATION_REPORT_BASE, *PLOCATION_REPORT_BASE;


//
// Returns how old the report is, in milliseconds.
//
__inline DWORD LocationGetReportAge(LOCATION_REPORT_BASE *pReportBase) {
    __int64 currentTime, reportCreation;

    GetCurrentFT((FILETIME*)&currentTime);

    memcpy(&reportCreation, &pReportBase->creationTime, sizeof(FILETIME));

    __int64 reportAge = currentTime - reportCreation;
    if ((reportAge < 0) || (reportAge > MAXDWORD)) {
        // Indicates either a bogus report or that the system clock has changed
        // since the time this report was generated.
        return MAXDWORD;
    }

    // ((__int64)10000L) converts between FILETIME (100 nanosecond units) and ms.
    return (DWORD)(reportAge / ((__int64)10000L));
}



//***************************************************************
//
// Well-defined reports GUIDs
// 
//***************************************************************


// {78CE876B-AD03-4bcd-8AE4-CF0011C18FFF}
DEFINE_GUID(LOCATION_LATLONG_GUID,0x78ce876b, 0xad03, 0x4bcd, 0x8a, 0xe4, 0xcf, 0x0, 0x11, 0xc1, 0x8f, 0xff);

// {1F44EA7A-0B92-42bd-85DC-213965683EF5}
DEFINE_GUID(LOCATION_802_11_GUID, 0x1f44ea7a, 0x0b92, 0x42bd, 0x85, 0xdc, 0x21, 0x39, 0x65, 0x68, 0x3e, 0xf5);

// {F49AEE40-493E-4039-83A4-676666DEC812}
DEFINE_GUID(LOCATION_ADDRESS_GUID, 0xf49aee40, 0x493e, 0x4039, 0x83, 0xa4, 0x67, 0x66, 0x66, 0xde, 0xc8, 0x12);

// {CFE3B789-2DB1-4b3e-8163-EDA0ACB9D75D}
DEFINE_GUID(LOCATION_BUILDING_GUID, 0xcfe3b789, 0x2db1, 0x4b3e, 0x81, 0x63, 0xed, 0xa0, 0xac, 0xb9, 0xd7, 0x5d);




//***************************************************************
//
// Well-defined provider/resolver GUIDS
//
//***************************************************************


// {FAE85A8B-B942-43ab-971C-9A743A45DD03
DEFINE_GUID(LOCATION_PROVIDER_GPS_GUID, 0xfae85a8b, 0xb942, 0x43ab, 0x97, 0x1c, 0x9a, 0x74, 0x3a, 0x45, 0xdd, 0x3);

// {140D1B27-884F-43d0-BE64-58A3BADAED36}
DEFINE_GUID(LOCATION_PROVIDER_802_11_GUID, 0x140d1b27, 0x884f, 0x43d0, 0xbe, 0x64, 0x58, 0xa3, 0xba, 0xda, 0xed, 0x36);

// {109E4972-F2FD-4ec2-8836-9240DADD1EE2}
DEFINE_GUID(LOCATION_PROVIDER_FAKE_GUID, 0x109E4972, 0xF2FD, 0x4ec2, 0x88, 0x36, 0x92, 0x40, 0xDA, 0xDD, 0x1E, 0xE2);

// {EC738360-F603-491A-B2F5-BA38FE45EB1D}
DEFINE_GUID(LOCATION_RESOLVER_FAKE_GUID, 0xEC738360, 0xF603, 0x491A, 0xB2, 0xF5, 0xBA, 0x38, 0xFE, 0x45, 0xEB, 0x1D);




#define LOCATION_LATLONG_LAT      0x00000001
#define LOCATION_LATLONG_LONG     0x00000002
#define LOCATION_LATLONG_ALT      0x00000004
#define LOCATION_LATLONG_SPEED    0x00000008
#define LOCATION_LATLONG_HEADING  0x00000010
#define LOCATION_LATLONG_ACCURACY 0x00000020

typedef struct _LOCATION_REPORT_LATLONG {
    LOCATION_REPORT_BASE base;
    // Specific lat/long position fields below.
    // Indicates which of fields below have been determined
    DWORD    validFields;
    // Degrees latitude.  North is positive
    DOUBLE   latitude;
    // Degrees longitude.  East is positive
    DOUBLE   longitude;
    // Altitute with regards to sea level, in meters
    DOUBLE   altitudeWRTSeaLevel;
    // Speed in knots
    DOUBLE   speed;
    // Degrees heading.  True North=0
    DOUBLE   heading;
    // Accuracy - radius in meters.
    DOUBLE   accuracy;
} LOCATION_REPORT_LATLONG, *PLOCATION_REPORT_LATLONG;


#define BSSID_MAX_LEN                 6 
#define LOCATION_MAX_ACCESS_POINTS   25 

typedef struct _LOCATION_REPORT_802_11 {
    LOCATION_REPORT_BASE base;
    // Specific 802.11 position fields below
    // Number of access points we have information for.
    DWORD    numAccessPoints; 
    // Nearby Access Points.
    BYTE     BSSID[LOCATION_MAX_ACCESS_POINTS][BSSID_MAX_LEN];
    // Signal strength of the access point(s)
    FLOAT    RSSI[LOCATION_MAX_ACCESS_POINTS];
} LOCATION_REPORT_802_11, *PLOCATION_REPORT_802_11;

#define LOCATION_OFFSET_UNSET                0xFFFFFFFF

typedef struct _LOCATION_REPORT_ADDRESS {
    LOCATION_REPORT_BASE base;
    // Specific address fields below.  DWORDs are offsets into the
    // data field, with 0xFFFFFFFF indicating the field is not set.
    DWORD    countryRegionOffset;
    DWORD    administrativeDivisionOffset;
    DWORD    cityOffset;
    DWORD    postalCodeOffset;
    DWORD    addressLineOffset;
    DWORD    descriptionOffset;
    // A contiguous buffer containing the actual data
    BYTE     data[1];
} LOCATION_REPORT_ADDRESS, *PLOCATION_REPORT_ADDRESS;

typedef struct _LOCATION_REPORT_BUILDING {
    LOCATION_REPORT_BASE base;
    // Specific building/floor/room fields below.  DWORDs are offsets into the
    // data field, with 0xFFFFFFFF indicating the field is not set.
    DWORD    buildingNameOffset; 
    DWORD    floorOffset;
    DWORD    roomOffset;
    DWORD    descriptionOffset;
    // A contiguous buffer containing the actual data
    BYTE     data[1];
} LOCATION_REPORT_BUILDING, *PLOCATION_REPORT_BUILDING;

// Other locatin reports may be defined by plugin writers.

//***************************************************************
//  API and structs that apps use to retrieve location information
//***************************************************************

// 
// First call into the LF.  This handle is used by all other calls.
// LF will determine whether the application has sufficient access 
// permission in order to retrieve the user's location or not.
//
HLOCATION LocationOpen(
    DWORD version,     // Version of LF - must be LOCATION_FRAMEWORK_VERSION_1 currently
    VOID *pReserved,   // Reserved parameter - must be NULL currently
    DWORD flags        // Additional config flags - must be 0 currently
);

//
// Closes HLOCATION handle and frees resources that were associated 
// with it, stopping any plugins 
//
DWORD LocationClose(
    HLOCATION hLocation    // HLOCATION returned by LocationOpen
);

//
// Indicates to LF to start the plugin(s) required to generate
// report of this type (e.g. LOCATION_LATLONG_GUID) and to provide notifications 
// when the state of the plugins and/or new location arrives.
//
DWORD LocationRegisterForReport(
    HLOCATION hLocation,         // HLOCATION returned by LocationOpen
    HANDLE hNewLocationReport,   // HANDLE to event LF will signal when a new report arrives
    HANDLE hStateChangeEvent,    // HANDLE to event LF will signal when plugin state of report generator changes
    REFGUID reportType,          // Type of report that should be registered
    DWORD flags                  // Optional config flags - must be 0 currently
);

//
// Indicates to LF that app no longer requires plugins that generate the
// specified type of report to be loaded.
//
DWORD LocationUnRegisterForReport(
    HLOCATION hLocation,    // HLOCATION returned by LocationOpen
    REFGUID reportType,     // Type of report that should be registered
    DWORD flags             // Optional config flags - must be 0 currently
);

//
// Requests latest location report of specified type, which must have
// be no older than specified maximumAge.
//
DWORD LocationGetReport(
    HLOCATION hLocation,               // HLOCATION returned by LocationOpen
    REFGUID reportType,                // Report type that should be returned
    DWORD maximumAge,                  // Maximum age, in ms, the report may be for success.
    LOCATION_REPORT *pLocationReport,  // Buffer to hold the retrieved LOCATION_REPORT
    DWORD *pcbLocationReport,          // Sizeof pLocationReport buffer 
    DWORD flags                        // Optional config flags - must be 0 currently
);


//***************************************************************
//  API and structs that apps use to get more detailed information
//  about the state of the LF itself or its plugins.
//***************************************************************


typedef struct _LOCATION_SERVICE_STATE  {
    // Service state of location framework (from service.h)
    DWORD   serviceState;  
    // Number of loaded (theoretically available) Providers
    DWORD   numLoadedProviders;
    // Number of loaded (theoretically available) Resolvers
    DWORD   numLoadedResolvers;
    // Number of Providers retrieving location reports
    DWORD   numActiveProviders;
    // Number of Resolvers retrieving location reports
    DWORD   numActiveResolvers;
} LOCATION_SERVICE_STATE, *PLOCATION_SERVICE_STATE;

//
// Get current high-level info about the location framework as a whole.
//
DWORD LocationGetServiceState(
    HLOCATION hLocation,                    // HLOCATION returned by LocationOpen
    LOCATION_SERVICE_STATE *pServiceState   // Buffer to retrieve information about Location Framework
);

#define MAX_PLUGIN_FRIENDLY_NAME 64

// State of a particular plugin DLL.
typedef enum {
    // Plugin or report type not supported by system
    PLUGIN_STATE_NOT_SUPPORTED = 0,
    // Plugin is on the system, but it has hit an unrecoverable error
    PLUGIN_STATE_ERROR         = 1,
    // No apps currently require this plugin
    PLUGIN_STATE_OFF           = 2,
    // No apps using plugin presently, in process of turning itself off
    PLUGIN_STATE_SHUTTING_DOWN = 3,
    // Plugin (temporarily) cannot retrieve location - i.e. GPS not working in doors.
    PLUGIN_STATE_UNAVAILABLE   = 4,
    // Plugin has received 1st request for location, but not returned
    PLUGIN_STATE_STARTING_UP   = 5,
    // Plugin is active and successfully returned at least 1 location report
    PLUGIN_STATE_ON            = 6,
} PLUGIN_STATE;

//
// Gets information about which plugin (if any) is capable of 
// generating the particular report type.  If multiple plugins are
// capable of generating this report type, the one with the highest
// integer value for PLUGIN_STATE will be the one returned 
// (i.e. PLUGIN_STATE_ON > PLUGIN_STATE_UNAVAILABLE)
// 
DWORD LocationGetPluginInfoForReport(
    HLOCATION hLocation,           // HLOCATION returned by LocationOpen
    REFGUID reportType,            // Report type to query  
    PLUGIN_STATE *pPluginState,    // Plugin state of the report type
    GUID *pPluginGuid              // (Optional) GUID of the plugin, if available, 
                                   // associated with pPluginState
);


// Plugins may support a maximum of this # of reports.
#define MAX_PLUGIN_REPORT_TYPES         8

// Information that applies to both provider and resolver plugin DLL's.
typedef struct _PLUGIN_INFORMATION {
    // Version of the plugin (not location framework)
    DWORD         version;
    // Unique GUID identifying this plugin DLL
    GUID          guid;
    // User-displayable name; e.g. "Microsoft GPS Provider"
    WCHAR         friendlyName[MAX_PLUGIN_FRIENDLY_NAME];   
    // Current running state plugin is in 
    PLUGIN_STATE  pluginState;
    // How frequently the plugin attempts to startup after a failure
    DWORD         retryInterval;
    // Amount of time to wait for plugin to complete first location query
    DWORD         maximumInitialWait;
    // Number of reports that this plugin generates
    DWORD         numReportsGenerated;
    // Reports that this plugin generates
    GUID          reportsGenerated[MAX_PLUGIN_REPORT_TYPES];
    // Time last this plugin generated a location report, based on GetCurrentFT()
    FILETIME      lastUpdate;
    // Plugin configuration flags
    DWORD         pluginFlags;
} PLUGIN_INFORMATION, *PPLUGIN_INFORMATION;


// Info about a particular provider
typedef struct _PROVIDER_INFORMATION {
    // Base information about the plugin DLL
    PLUGIN_INFORMATION  pluginInfo;
    // How frequently the plugin attempts to find new location.
    DWORD               pollInterval;
    // Provider configuration flags
    DWORD               providerFlags;
} PROVIDER_INFORMATION, *PPROVIDER_INFORMATION;

// Info about a particular resolver
typedef struct _RESOLVER_INFORMATION {
    // Base information about the plugin DLL
    PLUGIN_INFORMATION  pluginInfo;
    // Minimum amount of time location framework waits between successive calls. 
    DWORD               minRequeryInterval;
    // Number of reports from plugins that this DLL can resolve
    DWORD               numReportsSupported;
    // Reports from plugins that this DLL can resolve
    GUID                reportsSupported[MAX_PLUGIN_REPORT_TYPES];
    // Resolver configuration flags
    DWORD               resolverFlags;
} RESOLVER_INFORMATION, *PRESOLVER_INFORMATION;

//
// Retrieve information about all providers on the system
//
DWORD LocationGetProvidersInfo(
    HLOCATION hLocation,                // HLOCATION returned by LocationOpen
    PROVIDER_INFORMATION *pProviders,   // Buffer that PROVIDER_INFORMATION array is written to
    DWORD *pcbBuffer                    // Number of bytes of pProviders array
);

//
// Retrieve information about all resolvers on the system
//
DWORD LocationGetResolversInfo(
    HLOCATION hLocation,                // HLOCATION returned by LocationOpen
    RESOLVER_INFORMATION *pResolvers,   // Buffer that RESOLVER_INFORMATION array is written to
    DWORD *pcbBuffer                    // Number of bytes of pResolvers array
);



//***************************************************************
//  Related to opening a direct channel to a plugin from app layer
//  Note that not all plugins implement IOCTL processing, and plugins
//  may implement or not implement any IOCTL codes as desired.
//***************************************************************


// IOCTL codes < IOCTL_LOCATION_PLUGIN_USER are reserved for the Location
// Framework to send directly to plugins and may not be specified by the application.

// IOCTL codes <= IOCTL_LOCATION_PLUGIN_USER and < IOCTL_LOCATION_PLUGIN_CUSTOM 
// have global meaning across all plugins.  They will be defined in this header.
// Plugin writers MUST NOT create custom IOCTL codes < IOCTL_LOCATION_PLUGIN_CUSTOM.
#define IOCTL_LOCATION_PLUGIN_USER            0x00000100
#define IOCTL_LOCATION_PLUGIN_CREDENTIALS     0x00000101
#define IOCTL_LOCATION_PLUGIN_REFRESH         0x00000102
// 0x00000103 - 0x000001FF are reserved for future use

// IOCTL codes that are defined for individual plugins MUST
// be defined >= IOCTL_LOCATION_PLUGIN_CUSTOM.
#define IOCTL_LOCATION_PLUGIN_CUSTOM          0x00000200

//
// Open a direct channel to a particular plugin.
//
HLOCATIONPLUGIN LocationPluginOpen(
    HLOCATION hLocation,     // HLOCATION returned by LocationOpen
    REFGUID   pluginGuid     // GUID identifier of the plugin to open
);

//
// Send the IOCTL code and buffers directly to plugin for processing
//
DWORD LocationPluginIOCTL(
    HLOCATION hLocation,       // HLOCATION returned by LocationOpen
    HLOCATIONPLUGIN hPlugin,   // HLOCATIONPLUGIN returned by LocationPluginOpen    
    DWORD dwCode,              // IOCTL code that specifies command to be performed
    BYTE *pbIn,                // Input buffer
    DWORD cbIn,                // Number of bytes in pbIn
    BYTE *pbOut,               // Output buffer
    DWORD *pcbOut              // Number of bytes in pbOut
);

//
// Close the IOCTL channel opened with the plugin
// 
DWORD LocationPluginClose(
    HLOCATION hLocation,          // HLOCATION returned by LocationOpen
    HLOCATIONPLUGIN hPlugin       // HLOCATIONPLUGIN returned by LocationPluginOpen
);


#ifdef __cplusplus
}
#endif

#endif // __LF_API_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\lass_ae.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    lass_ae.h

Abstract:

    This file defines the GUIDs  for CE OS Authentication Events (AEs).
    Policy for these GUIDs  will be found in the registry under:

    [HKEY_LOCAL_MACHINE\Comm\Security\LASSD\AE\GUID_NAME_HERE]
    ;  Authentication info here.
    
Environment:

    User Mode - Win32

--*/

#ifndef __LASS_AE_H
#define  __LASS_AE_H


//
// Pre-defined AE's
//

// AE_EVERY_TIME - will authenticate on every call.
// {8E6B0AF7-9295-45b4-8B73-55D95304144E}
static const GUID AE_EVERY_TIME = 
{ 0x8e6b0af7, 0x9295, 0x45b4, { 0x8b, 0x73, 0x55, 0xd9, 0x53, 0x4, 0x14, 0x4e } };

// AE_DEFAULT_POLICY - useful when your app wants to 
// piggyback on the default policy.
// {3C2424CC-95D3-4bea-BEB1-ABBBCF15DA96}
static const GUID AE_DEFAULT_POLICY = 
{ 0x3c2424cc, 0x95d3, 0x4bea, { 0xbe, 0xb1, 0xab, 0xbb, 0xcf, 0x15, 0xda, 0x96 } };


// Useful for testing - 1.
// {7B6A373C-F16E-4051-8F47-25EFF6F0D532}
static const GUID AE_TEST1 = 
{ 0x7b6a373c, 0xf16e, 0x4051, { 0x8f, 0x47, 0x25, 0xef, 0xf6, 0xf0, 0xd5, 0x32 } };

// Useful for testing - 2 .
// {578DCD29-9596-42e6-98C3-188C75BB4C04}
static const GUID AE_TEST2 = 
{ 0x578dcd29, 0x9596, 0x42e6, { 0x98, 0xc3, 0x18, 0x8c, 0x75, 0xbb, 0x4c, 0x4 } };


//
// We might want to move the AEs for OS components to another file.
//

// {1B38A686-7CDC-4017-A5E9-4C6A9DD7E5BA}
static const GUID AE_STARTUI = 
{ 0x1b38a686, 0x7cdc, 0x4017, { 0xa5, 0xe9, 0x4c, 0x6a, 0x9d, 0xd7, 0xe5, 0xba } };

// {8FD146DC-623E-499d-AA82-50F31454A161}
static const GUID AE_CPLMAIN = 
{ 0x8fd146dc, 0x623e, 0x499d, { 0xaa, 0x82, 0x50, 0xf3, 0x14, 0x54, 0xa1, 0x61 } };

// You must have this set to authenticate on every call.
// {71F82FA4-8589-4516-A0D7-9B7FFCB0C313}
static const GUID AE_RELOAD_SETTINGS_ENCRYPT_MASTERKEY = 
{ 0x71f82fa4, 0x8589, 0x4516, { 0xa0, 0xd7, 0x9b, 0x7f, 0xfc, 0xb0, 0xc3, 0x13 } };
#endif // __LASS_AE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\lendian.hpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       lendian.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of LENDIAN data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an LENDIAN type, use the MAKE_LENDIAN_TYPE macro.  For example, if
// you need an int_LENDIAN, say
//
//        MAKE_LENDIAN_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type LENDIAN" in your code
// with "type_LENDIAN".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// LENDIAN64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __lendian_h__
#define __lendian_h__

#if defined(_MSC_VER) && !defined(BIG_ENDIAN)

#define MAKE_LENDIAN_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_LENDIAN_UNALIGNED
#define MAKE_LENDIAN_TYPE(base,size)              typedef base             base##_LENDIAN_UNALIGNED; \
                                                  typedef base   base##_LENDIAN \

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit 
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//   
#if defined(ALPHA)
#  define MAKE_LENDIAN64_UNALIGNED_TYPE(base,size)  typedef base UNALIGNED base##_LENDIAN64_UNALIGNED
#else
#  define MAKE_LENDIAN64_UNALIGNED_TYPE(base,size)  typedef base base##_LENDIAN64_UNALIGNED
#endif
#define MAKE_LENDIAN64_TYPE(base,size)  typedef base base##_LENDIAN64

#define MAKE_LENDIANPTR_UNALIGNED_TYPE(base)      typedef base UNALIGNED *base##_LENDIANPTR_UNALIGNED
#define MAKE_LENDIANPTR_TYPE(base)                typedef base *base##_LENDIANPTR

#else // _MSC_VER

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                          \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#if defined( ux10 )
#define SET02(x,y)  SET2(x,y)
#define GET02(x)    GET2(x)
#define SET04(x,y)  SET4(x,y)
#define GET04(x)    GET4(x)
#define SET08(x,y)  SET8(x,y)
#define GET08(x)    GET8(x)
#endif

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#define GROUP(type,size,get,set,sfx)                                                            \
    LEndian##sfx##size( type v ) { set##size( v, data ); }                                      \
    type operator = ( type v )   { set##size( v, data ); return v; }                            \
    operator type()              { return get##size( data ); }                                  \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; }    \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; }    \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; }  \
    type operator <= (const type v) { set##size( get##size(data) < v, data); return *this; }    \
    type operator >= (const type v) { set##size( get##size(data) > v, data); return *this; }    \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; }    \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; }    \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; }    \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; }  \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; }    \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; }    \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; }


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class LEndian##sfx##size                                        \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}


#if defined( ux10 )
MAKE_TEMPLATE( 2, unsigned char, 0);
MAKE_TEMPLATE( 4, unsigned char, 0);
MAKE_TEMPLATE( 8, unsigned char, 0);
#else
MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
#endif
MAKE_TEMPLATE( 8, unsigned int, 64 );

#if defined( ux10 )
template<class BASE>
class LEndianPtr : LEndian04<BASE> {
public:
	LEndianPtr(const void * v) : LEndian04<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#else

template<class BASE>
class LEndianPtr : LEndian4<BASE> {
public:
	LEndianPtr(const void * v) : LEndian4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#endif


#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#if defined( ux10 )
#define MAKE_LENDIAN_TYPE(base,size)            \
   typedef LEndian0##size<base>   base##_LENDIAN; \
   typedef LEndian0##size<base>   base##_LENDIAN_UNALIGNED
#else
#define MAKE_LENDIAN_TYPE(base,size)            \
   typedef LEndian##size<base>   base##_LENDIAN; \
   typedef LEndian##size<base>   base##_LENDIAN_UNALIGNED
#endif

#define MAKE_LENDIAN64_TYPE(base,size)                          \
  typedef LEndian64##size<base> base##_LENDIAN64;                \
  typedef LEndian64##size<base> base##_LENDIAN64_UNALIGNED

#define MAKE_LENDIANPTR_TYPE(base)                              \
  typedef LEndianPtr<base>      base##_LENDIANPTR;               \
  typedef LEndianPtr<base>      base##_LENDIANPTR_UNALIGNED

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_LENDIAN_TYPE( short, 2 );
MAKE_LENDIAN_TYPE( int, 4 );
MAKE_LENDIAN_TYPE( long, 4 );
MAKE_LENDIAN_TYPE( WORD, 2 );
MAKE_LENDIAN_TYPE( DWORD, 4 );
MAKE_LENDIAN_TYPE( USHORT, 4 );
MAKE_LENDIAN_TYPE( SHORT, 4 );
MAKE_LENDIAN_TYPE( __int64, 8 );
MAKE_LENDIAN64_TYPE( __int64, 8 );

#endif // __lendian_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\malloc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#include <stdlib.h> // STDLIB is included for legacy reasons.  It contains the "old" function declarations.

#include <crtdefs.h>

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif

#define _HEAP_MAXREQ    0xFFFFFFE0

_CRTIMP _CRTNOALIAS _CRTRESTRICT __checkReturn __bcount_opt(_Size*_Count) void * __cdecl _recalloc(__in_opt void * _Memory, __in size_t _Count, __in size_t _Size);

#define _ALLOCA_S_THRESHOLD     1024
#define _ALLOCA_S_STACK_MARKER  0xCCCC
#define _ALLOCA_S_HEAP_MARKER   0xDDDD

#define _ALLOCA_S_MARKER_SIZE   8

_STATIC_ASSERT(sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE);

#if !defined(__midl) && !defined(RC_INVOKED)
__inline void *_MarkAllocaS(__out_opt __crt_typefix(unsigned int*) void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;
    }
    return _Ptr;
}
#endif

#if defined(_DEBUG)
#if !defined(_CRTDBG_MAP_ALLOC)
#undef _malloca
#define _malloca(size) \
__pragma(warning(suppress: 6255)) \
        _MarkAllocaS(malloc((size) + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_HEAP_MARKER)
#endif
#else
#undef _malloca
#define _malloca(size) \
__pragma(warning(suppress: 6255)) \
    ((((size) + _ALLOCA_S_MARKER_SIZE) <= _ALLOCA_S_THRESHOLD) ? \
        _MarkAllocaS(_alloca((size) + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_STACK_MARKER) : \
        _MarkAllocaS(malloc((size) + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_HEAP_MARKER))
#endif

#undef _FREEA_INLINE
#define _FREEA_INLINE

#ifdef _FREEA_INLINE
/* _freea must be in the header so that its allocator matches _malloca */
#if !defined(__midl) && !defined(RC_INVOKED)
#undef _freea
_CRTNOALIAS __inline void __CRTDECL _freea(__inout_opt void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - _ALLOCA_S_MARKER_SIZE;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == _ALLOCA_S_HEAP_MARKER)
        {
            free(_Memory);
        }
#if defined(_ASSERTE)
        else if (_Marker != _ALLOCA_S_STACK_MARKER)
        {
            _ASSERTE(("Corrupted pointer passed to _freea", 0));
        }
#endif
    }
}
#endif
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\lmcons.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ BUILD Version: 0003    // Increment this if a change has global effects



    LMCONS.H (was NETCONS.H in LM 2.x)

Abstract:

    This file contains constants used throughout the LAN Manager
    API header files.  It should be included in any source file
    that is going to include other LAN Manager API header files or
    call a LAN Manager API.

    NOTE:  Lengths of strings are given as the maximum lengths of the
    string in characters (not bytes).  This does not include space for the
    terminating 0-characters.  When allocating space for such an item,
    use the form:

        TCHAR username[UNLEN+1];

    Definitions of the form LN20_* define those values in effect for
    LanMan 2.0.



--*/

/*NOINC*/
#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED
/*INC*/

#ifndef PASCAL
#define PASCAL                          // pascal on OS/2
#endif

#ifndef FAR
#define FAR                             // far on OS/2
#endif

//
// String Lengths for various LanMan names
//

#define CNLEN       15                  // Computer name length
#define LM20_CNLEN  15                  // LM 2.0 Computer name length
#define DNLEN       CNLEN               // Maximum domain name length
#define LM20_DNLEN  LM20_CNLEN          // LM 2.0 Maximum domain name length

#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif

#define UNCLEN      (CNLEN+2)           // UNC computer name length
#define LM20_UNCLEN (LM20_CNLEN+2)      // LM 2.0 UNC computer name length

#define NNLEN       80                  // Net name length (share name)
#define LM20_NNLEN  12                  // LM 2.0 Net name length

#define RMLEN       (UNCLEN+1+NNLEN)    // Max remote name length
#define LM20_RMLEN  (LM20_UNCLEN+1+LM20_NNLEN) // LM 2.0 Max remote name length

#define SNLEN       80                  // Service name length
#define LM20_SNLEN  15                  // LM 2.0 Service name length
#define STXTLEN     256                 // Service text length
#define LM20_STXTLEN 63                 // LM 2.0 Service text length

#define PATHLEN     256                 // Max. path (not including drive name)
#define LM20_PATHLEN 256                // LM 2.0 Max. path

#define DEVLEN      80                  // Device name length
#define LM20_DEVLEN 8                   // LM 2.0 Device name length

#define EVLEN       16                  // Event name length

//
// User, Group and Password lengths
//

#define UNLEN       256                 // Maximum user name length
#define LM20_UNLEN  20                  // LM 2.0 Maximum user name length

#define GNLEN       UNLEN               // Group name
#define LM20_GNLEN  LM20_UNLEN          // LM 2.0 Group name

#define PWLEN       256                 // Maximum password length
#define LM20_PWLEN  14                  // LM 2.0 Maximum password length

#define SHPWLEN     8                   // Share password length (bytes)


#define CLTYPE_LEN  12                  // Length of client type string


#define MAXCOMMENTSZ 256                // Multipurpose comment length
#define LM20_MAXCOMMENTSZ 48            // LM 2.0 Multipurpose comment length

#define QNLEN       NNLEN               // Queue name maximum length
#define LM20_QNLEN  LM20_NNLEN          // LM 2.0 Queue name maximum length
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

//
// The ALERTSZ and MAXDEVENTRIES defines have not yet been NT'ized.
// Whoever ports these components should change these values appropriately.
//

#define ALERTSZ     128                 // size of alert string in server
#define MAXDEVENTRIES (sizeof (int)*8)  // Max number of device entries

                                        //
                                        // We use int bitmap to represent
                                        //

#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)

//
// Value to be used with APIs which have a "preferred maximum length"
// parameter.  This value indicates that the API should just allocate
// "as much as it takes."
//

#define MAX_PREFERRED_LENGTH    ((DWORD) -1)

//
//        Constants used with encryption
//

#define CRYPT_KEY_LEN           7
#define CRYPT_TXT_LEN           8
#define ENCRYPTED_PWLEN         16
#define SESSION_PWLEN           24
#define SESSION_CRYPT_KLEN      21

//
//  Value to be used with SetInfo calls to allow setting of all
//  settable parameters (parmnum zero option)
//
#ifndef PARMNUM_ALL
#define PARMNUM_ALL             0
#endif

#define PARM_ERROR_UNKNOWN      ( (DWORD) (-1) )
#define PARM_ERROR_NONE         0
#define PARMNUM_BASE_INFOLEVEL  1000

//
//        Message File Names
//

#define MESSAGE_FILENAME        TEXT("NETMSG")
#define OS2MSG_FILENAME         TEXT("BASE")
#define HELP_MSG_FILENAME       TEXT("NETH")


#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

//
// Keywords used in Function Prototypes
//

#define NET_API_STATUS          DWORD
#define API_RET_TYPE            NET_API_STATUS      // Old value: do not use
#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NET_API_FUNCTION    __stdcall
#else
#define NET_API_FUNCTION
#endif

// Define pseudo-keywords.
#ifndef IN
#define IN
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef OUT
#define OUT
#endif
/*INC*/



//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define PLATFORM_ID_DOS 300
#define PLATFORM_ID_OS2 400
#define PLATFORM_ID_NT  500
#define PLATFORM_ID_OSF 600
#define PLATFORM_ID_VMS 700

//
//      There message numbers assigned to different LANMAN components
//      are as defined below.
//
//      lmerr.h:        2100 - 2999     NERR_BASE
//      alertmsg.h:     3000 - 3049     ALERT_BASE
//      lmsvc.h:        3050 - 3099     SERVICE_BASE
//      lmerrlog.h:     3100 - 3299     ERRLOG_BASE
//      msgtext.h:      3300 - 3499     MTXT_BASE
//      apperr.h:       3500 - 3999     APPERR_BASE
//      apperrfs.h:     4000 - 4299     APPERRFS_BASE
//      apperr2.h:      4300 - 5299     APPERR2_BASE
//      ncberr.h:       5300 - 5499     NRCERR_BASE
//      alertmsg.h:     5500 - 5599     ALERT2_BASE
//      lmsvc.h:        5600 - 5699     SERVICE2_BASE
//      lmerrlog.h      5700 - 5799     ERRLOG2_BASE
//

#define MIN_LANMAN_MESSAGE_ID  NERR_BASE
#define MAX_LANMAN_MESSAGE_ID  5799

/*NOINC*/
#endif // NETCONS_INCLUDED
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\linklist.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

linklist.h

Abstract:  

Macros for linked-list manipulation.

Notes: 


--*/


#pragma once

#ifdef __cplusplus
extern "C" {
#endif


/*NOINC*/

#if !defined(WIN32)

typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY FAR * Flink;
    struct _LIST_ENTRY FAR * Blink;
} LIST_ENTRY;
typedef LIST_ENTRY FAR * PLIST_ENTRY;

#endif  // !WIN32

//
//  Doubly-linked list manipulation routines.
//

/// <topic name="LIST_ENTRY" displayname="Doubly Linked List Functions">
/// <summary>
/// Functions to manipulate LIST_ENTRY-based circular-doubly-linked lists
/// </summary>
/// </topic>

///<topic_scope tref="LIST_ENTRY">

#ifndef CONTAINING_RECORD
//
//
//  CONTAINING_RECORD:
//
/// <summary>
///     Calculates the address of the base of the structure given its type and the address of a field within the structure
/// </summary>
/// <param name="address">
///     A pointer to a field in an instance of a structure of type specified by the type parameter. (Typically a LIST_ENTRY field)
/// </param>
/// <param name="type">
///     The name of the type of the structure whose base address is to be returned.
/// </param>
/// <param name="field">
///     The name of the field pointed to by address and which is contained in a structure of the specified type.
/// </param>
/// <returns>
///     The address of the structure containing the specified field
/// </returns>
/// <remarks>
/// In a LIST_ENTRY-based doubly linked list, the LIST_ENTRY fields within a structure point to other LIST_ENTRYs and not to 
/// the structure within which they are declared. The LIST_ENTRY functions return pointers to LIST_ENTRYs, the CONTAINING_RECORD
/// macro provides a way to get a pointer to the actual structure which contains the LIST_ENTRY field.
/// </remarks>
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                          (LPBYTE)(address) - \
                          (LPBYTE)(&((type *)0)->field)))
#endif  // CONTAINING_RECORD


//
//  InitializeListHead:
//
/// <summary>
///     Initialize the LIST_ENTRY by setting its Flink and Blink fields to point to itself
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY to be initialized.
/// </param>
/// <returns>
///     The address of the initialized LIST_ENTRY
/// </returns>
FORCEINLINE
PLIST_ENTRY
InitializeListHead(
    IN PLIST_ENTRY ListHead)
{
    return ListHead->Flink = ListHead->Blink = ListHead;
}


//
//  IsListEmpty:
//
/// <summary>
///     Determine whether the specified LIST_ENTRY is empty
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <returns>
///     TRUE when the ListHead points back to itself (it is empty)
///     FALSE otherwise
/// </returns>
FORCEINLINE
BOOL
IsListEmpty(
    IN CONST PLIST_ENTRY ListHead)
{
    return ((ListHead)->Flink == (ListHead)) ? TRUE : FALSE;
}

#ifdef DEBUG
FORCEINLINE
VOID
CheckListEntry(
    IN PLIST_ENTRY Entry,
    IN BOOL CheckFlinkBlink)
{
    //
    //  check the PLIST_ENTRY pointer
    //  if the pointer is valid then
    //      check Flink
    //      check Blink
    //
    ASSERT( (LIST_ENTRY*) Entry        != (LIST_ENTRY*) 0xcccccccc );
    ASSERT( (LIST_ENTRY*) Entry        != (LIST_ENTRY*) NULL );


    if( TRUE == CheckFlinkBlink )
        {
        ASSERT( (LIST_ENTRY*) Entry->Flink != (LIST_ENTRY*) 0xcccccccc );
        ASSERT( (LIST_ENTRY*) Entry->Blink != (LIST_ENTRY*) 0xcccccccc );

        ASSERT( (LIST_ENTRY*) Entry->Flink != (LIST_ENTRY*) NULL );
        ASSERT( (LIST_ENTRY*) Entry->Blink != (LIST_ENTRY*) NULL );
        }
}
#define ASSERT_LIST_ENTRY CheckListEntry
#else
#define ASSERT_LIST_ENTRY
#endif


//
//  RemoveEntryList:
//
/// <summary>
///     Removes the specified LIST_ENTRY from the doubly linked list
///     NOTE: Removal is allowed on empty lists.
///     NOTE: The removed Entry is initialized to prevent possible list corruption.
/// </summary>
/// <param name="Entry">
///     A pointer to a LIST_ENTRY in a doubly linked list.
/// </param>
FORCEINLINE
VOID
RemoveEntryList(
    IN PLIST_ENTRY Entry)
{
    PLIST_ENTRY _EX_Entry = Entry;

    ASSERT_LIST_ENTRY( Entry, TRUE );

    _EX_Entry->Blink->Flink = _EX_Entry->Flink;
    _EX_Entry->Flink->Blink = _EX_Entry->Blink;

    ASSERT_LIST_ENTRY( Entry, TRUE );

    //
    //  re-initialize the removed list entry to prevent it from pointing
    //  back into a list from which it has already been removed
    //
    InitializeListHead( Entry );
}


//
//  RemoveEntryLockedList:
//
/// <summary>
///     Removes the specified LIST_ENTRY from the doubly linked list with a CRITICAL_SECTION taken
/// </summary>
/// <param name="Entry">
///     A pointer to a LIST_ENTRY in a doubly linked list.
/// </param>
/// <param name="CS">
///     The CRITICAL_SECTION that guards the doubly linked list
/// </param>
FORCEINLINE
VOID
RemoveEntryLockedList(
    IN PLIST_ENTRY Entry,
    IN LPCRITICAL_SECTION CS)
{
    EnterCriticalSection(CS);
    RemoveEntryList( Entry );
    LeaveCriticalSection(CS);
}


//
//  RemoveHeadList:
//
/// <summary>
///     Removes the first entry from the doubly linked list specified by ListHead.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <returns>
///     A pointer to the entry removed from the list. If the list is empty, then ListHead is returned.
/// </returns>
FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
    IN PLIST_ENTRY ListHead)
{
    PLIST_ENTRY HeadEntry = ListHead->Flink;
    ASSERT_LIST_ENTRY( ListHead, TRUE );
    RemoveEntryList( HeadEntry );
    return HeadEntry;
}


//
//  RemoveHeadLockedList
//
/// <summary>
///     Removes the first entry from the list specified by ListHead with a CRITICAL_SECTION taken.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <param name="CS">
///     The CRITICAL_SECTION that guards the doubly linked list
/// </param>
/// <returns>
///     A pointer to the entry removed from the list. If the list is empty, then ListHead is returned.
/// </returns>
FORCEINLINE
PLIST_ENTRY
RemoveHeadLockedList(
    IN PLIST_ENTRY ListHead,
    IN LPCRITICAL_SECTION CS)
{
    PLIST_ENTRY HeadEntry;

    EnterCriticalSection(CS);
    HeadEntry = RemoveHeadList( ListHead );
    LeaveCriticalSection(CS);

    return HeadEntry;
}


//
//  RemoveTailList:
//
/// <summary>
///     Removes the last entry from the doubly linked list specified by ListHead.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <returns>
///     A pointer to the entry removed from the list. If the list is empty, then ListHead is returned.
/// </returns>
FORCEINLINE
PLIST_ENTRY
RemoveTailList(
    IN PLIST_ENTRY ListHead)
{
    PLIST_ENTRY TailEntry = ListHead->Blink;
    ASSERT_LIST_ENTRY( ListHead, TRUE );
    RemoveEntryList( TailEntry );
    return TailEntry;
}


//
//  RemoveTailLockedList:
//
/// <summary>
///     Removes the last entry from the list specified by ListHead with a CRITICAL_SECTION taken.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <param name="CS">
///     The CRITICAL_SECTION that guards the doubly linked list
/// </param>
/// <returns>
///     A pointer to the entry removed from the list. If the list is empty, then ListHead is returned.
/// </returns>
FORCEINLINE
PLIST_ENTRY
RemoveTailLockedList(
    IN PLIST_ENTRY ListHead,
    IN LPCRITICAL_SECTION CS)
{
    PLIST_ENTRY TailEntry;

    EnterCriticalSection(CS);
    TailEntry = RemoveTailList( ListHead );
    LeaveCriticalSection(CS);

    return TailEntry;
}


//
//  InsertEntryList:
//
//      - inserts Entry into the doubly linked list
//      - insertion occurs between PrevEntry and NextEntry
//
FORCEINLINE
VOID
InsertEntryList(
    IN PLIST_ENTRY PrevEntry,
    IN PLIST_ENTRY Entry,
    IN PLIST_ENTRY NextEntry)
{
    ASSERT_LIST_ENTRY( PrevEntry, TRUE );
    ASSERT_LIST_ENTRY( Entry, FALSE );
    ASSERT_LIST_ENTRY( NextEntry, TRUE );

    Entry->Flink = NextEntry;
    Entry->Blink = PrevEntry;
    PrevEntry->Flink = Entry;
    NextEntry->Blink = Entry;

    ASSERT_LIST_ENTRY( PrevEntry, TRUE );
    ASSERT_LIST_ENTRY( NextEntry, TRUE );
    ASSERT_LIST_ENTRY( Entry, TRUE );
}


//
//  InsertTailList:
//
/// <summary>
///     Insert the LIST_ENTRY specified by Entry at the end of a doubly linked list.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <param name="Entry">
///     A pointer to the LIST_ENTRY to be inserted in the doubly linked list.
/// </param>
FORCEINLINE
VOID
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry)
{
    InsertEntryList( ListHead->Blink, Entry, ListHead );
}


//
//  InsertTailLockedList:
//
/// <summary>
///     Insert a LIST_ENTRY at the end of a doubly linked list with a CRITICAL_SECTION taken.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <param name="Entry">
///     A pointer to the LIST_ENTRY to be inserted in the doubly linked list.
/// </param>
/// <param name="CS">
///     The CRITICAL_SECTION that guards the doubly linked list
/// </param>
FORCEINLINE
VOID
InsertTailLockedList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry,
    IN LPCRITICAL_SECTION CS)
{
    EnterCriticalSection(CS);
    InsertTailList( ListHead, Entry );
    LeaveCriticalSection(CS);
}


//
//  InsertHeadList:
//
/// <summary>
///     Insert the LIST_ENTRY specified by Entry at the beginning of a doubly linked list.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <param name="Entry">
///     A pointer to the LIST_ENTRY to be inserted in the doubly linked list.
/// </param>
FORCEINLINE
VOID
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry)
{
    InsertEntryList( ListHead, Entry, ListHead->Flink );
}



//
//  InsertHeadLockedList:
//
/// <summary>
///     Insert a LIST_ENTRY at the beginning of a doubly linked list with a CRITICAL_SECTION taken.
/// </summary>
/// <param name="ListHead">
///     A pointer to the LIST_ENTRY that is the head of the list.
/// </param>
/// <param name="Entry">
///     A pointer to the LIST_ENTRY to be inserted in the doubly linked list.
/// </param>
/// <param name="CS">
///     The CRITICAL_SECTION that guards the doubly linked list
/// </param>
FORCEINLINE
VOID
InsertHeadLockedList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry,
    IN LPCRITICAL_SECTION CS)
{
    EnterCriticalSection (CS);
    InsertHeadList( ListHead, Entry );
    LeaveCriticalSection (CS);
}

///</topic_scope> //LIST_ENTRY

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\locale.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*locale.h - definitions/declarations for localization routines
*
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#include <crtdefs.h>

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapi.h ===
/*
 *	M A P I . H
 *
 *  Messaging Applications Programming Interface.
 *
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 *
 *  Purpose:
 *
 *    This file defines the structures and constants used by that
 *    subset of the Messaging Applications Programming Interface
 *    which is supported under Windows by Microsoft Mail for PC
 *    Networks version 3.x.
 */


#ifndef MAPI_H
#define MAPI_H

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *  Types.
 */


#ifdef __cplusplus
extern "C" {
#endif


#ifndef EXPORT
#ifdef WIN16
#define EXPORT __export
#else
/* Additional special definitions here */
#define EXPORT
#endif
#endif

typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR       LHANDLE, FAR * LPLHANDLE;
#endif

typedef unsigned char FAR * LPBYTE;

#define    lhSessionNull    ((LHANDLE)0)

typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPSTR lpszPathName;          /* Full path name of attachment file       */
    LPSTR lpszFileName;          /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDesc, FAR * lpMapiFileDesc;

#define MAPI_OLE                0x00000001
#define MAPI_OLE_STATIC         0x00000002


typedef struct
{
    ULONG ulReserved;           /* Reserved, must be zero.                  */
    ULONG cbTag;                /* Size (in bytes) of                       */
    LPBYTE lpTag;               /* X.400 OID for this attachment type       */
    ULONG cbEncoding;           /* Size (in bytes) of                       */
    LPBYTE lpEncoding;          /* X.400 OID for this attachment's encoding */
} MapiFileTagExt, FAR *lpMapiFileTagExt;


typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPSTR lpszName;             /* Recipient name                           */
    LPSTR lpszAddress;          /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDesc, FAR * lpMapiRecipDesc;

#ifndef MAPI_ORIG				/* also defined in mapix.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#endif

typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPSTR lpszSubject;            /* Message Subject                        */
    LPSTR lpszNoteText;           /* Message Text                           */
    LPSTR lpszMessageType;        /* Message Class                          */
    LPSTR lpszDateReceived;       /* in YYYY/MM/DD HH:MM format             */
    LPSTR lpszConversationID;     /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004


/*
 *  Entry points.
 */

/*
 *  flFlags values for Simple MAPI entry points. All documented flags are
 *  shown for each call. Duplicates are commented out but remain present
 *  for every call.
 */

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI             */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* prompt for password only     */
#endif
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session     */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return   */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon          */

/* MAPISendMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

#ifndef MAPI_DIALOG				/* also defined in property.h */
#define MAPI_DIALOG             0x00000008  /* Display a send note UI       */
#endif
/*# define MAPI_USE_DEFAULT		0x00000040	   Use default profile in logon */

/* MAPIFindNext() flags.    */

#define MAPI_UNREAD_ONLY        0x00000020  /* Only unread messages         */
#define MAPI_GUARANTEE_FIFO     0x00000100  /* use date order               */
#define MAPI_LONG_MSGID			0x00004000	/* allow 512 char returned ID	*/

/* MAPIReadMail() flags.    */

#define MAPI_PEEK               0x00000080  /* Do not mark as read.         */
#define MAPI_SUPPRESS_ATTACH    0x00000800  /* header + body, no files      */
#define MAPI_ENVELOPE_ONLY      0x00000040  /* Only header information      */
#define MAPI_BODY_AS_FILE       0x00000200

/* MAPISaveMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_LONG_MSGID		0x00004000	/* allow 512 char returned ID	*/

/* MAPIAddress() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

/* MAPIDetails() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
#define MAPI_AB_NOMODIFY        0x00000400  /* Don't allow mods of AB entries */

/* MAPIResolveName() flags. */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_DIALOG          0x00000008     Prompt for choices if ambiguous */
/* #define MAPI_AB_NOMODIFY     0x00000400     Don't allow mods of AB entries */

typedef ULONG (FAR PASCAL MAPILOGON)(
	ULONG_PTR ulUIParam,
	__in LPSTR lpszProfileName,
	__in LPSTR lpszPassword,
	FLAGS flFlags,
	ULONG ulReserved,
	LPLHANDLE lplhSession
);
typedef MAPILOGON FAR *LPMAPILOGON;
MAPILOGON MAPILogon;

typedef ULONG (FAR PASCAL MAPILOGOFF)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPILOGOFF FAR *LPMAPILOGOFF;
MAPILOGOFF MAPILogoff;


typedef ULONG (FAR PASCAL MAPISENDMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPISENDMAIL FAR *LPMAPISENDMAIL;
MAPISENDMAIL MAPISendMail;


typedef ULONG (FAR PASCAL MAPISENDDOCUMENTS)(
	ULONG_PTR ulUIParam,
	__in LPSTR lpszDelimChar,
	__in LPSTR lpszFilePaths,
	__in LPSTR lpszFileNames,
	ULONG ulReserved
);
typedef MAPISENDDOCUMENTS FAR *LPMAPISENDDOCUMENTS;
MAPISENDDOCUMENTS MAPISendDocuments;


typedef ULONG (FAR PASCAL MAPIFINDNEXT)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageType,
	__in LPSTR lpszSeedMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	__in LPSTR lpszMessageID
);
typedef MAPIFINDNEXT FAR *LPMAPIFINDNEXT;
MAPIFINDNEXT MAPIFindNext;

typedef ULONG (FAR PASCAL MAPIREADMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiMessage FAR *lppMessage
);
typedef MAPIREADMAIL FAR *LPMAPIREADMAIL;
MAPIREADMAIL MAPIReadMail;

typedef ULONG (FAR PASCAL MAPISAVEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved,
	__in LPSTR lpszMessageID
);
typedef MAPISAVEMAIL FAR *LPMAPISAVEMAIL;
MAPISAVEMAIL MAPISaveMail;

typedef ULONG (FAR PASCAL MAPIDELETEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDELETEMAIL FAR *LPMAPIDELETEMAIL;
MAPIDELETEMAIL MAPIDeleteMail;

typedef ULONG (EXPORT FAR PASCAL *LPMAPIFREEBUFFER)(LPVOID pv);

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID pv);

typedef ULONG (FAR PASCAL MAPIADDRESS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszCaption,
	ULONG nEditFields,
	__in LPSTR lpszLabels,
	ULONG nRecips,
	lpMapiRecipDesc lpRecips,
	FLAGS flFlags,
	ULONG ulReserved,
	LPULONG lpnNewRecips,
	lpMapiRecipDesc FAR *lppNewRecips
);
typedef MAPIADDRESS FAR *LPMAPIADDRESS;
MAPIADDRESS MAPIAddress;

typedef ULONG (FAR PASCAL MAPIDETAILS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiRecipDesc lpRecip,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDETAILS FAR *LPMAPIDETAILS;
MAPIDETAILS MAPIDetails;

typedef ULONG (FAR PASCAL MAPIRESOLVENAME)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszName,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiRecipDesc FAR *lppRecip
);
typedef MAPIRESOLVENAME FAR *LPMAPIRESOLVENAME;
MAPIRESOLVENAME MAPIResolveName;

#ifndef SUCCESS_SUCCESS
#define SUCCESS_SUCCESS                 0
#endif
#define MAPI_USER_ABORT                 1
#define MAPI_E_USER_ABORT               MAPI_USER_ABORT
#define MAPI_E_FAILURE                  2
#define MAPI_E_LOGON_FAILURE            3
#define MAPI_E_LOGIN_FAILURE            MAPI_E_LOGON_FAILURE
#define MAPI_E_DISK_FULL                4
#define MAPI_E_INSUFFICIENT_MEMORY      5
#define MAPI_E_ACCESS_DENIED            6
#define MAPI_E_TOO_MANY_SESSIONS        8
#define MAPI_E_TOO_MANY_FILES           9
#define MAPI_E_TOO_MANY_RECIPIENTS      10
#define MAPI_E_ATTACHMENT_NOT_FOUND     11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE  12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE 13
#define MAPI_E_UNKNOWN_RECIPIENT        14
#define MAPI_E_BAD_RECIPTYPE            15
#define MAPI_E_NO_MESSAGES              16
#define MAPI_E_INVALID_MESSAGE          17
#define MAPI_E_TEXT_TOO_LARGE           18
#define MAPI_E_INVALID_SESSION          19
#define MAPI_E_TYPE_NOT_SUPPORTED       20
#define MAPI_E_AMBIGUOUS_RECIPIENT      21
#define MAPI_E_AMBIG_RECIP              MAPI_E_AMBIGUOUS_RECIPIENT
#define MAPI_E_MESSAGE_IN_USE           22
#define MAPI_E_NETWORK_FAILURE          23
#define MAPI_E_INVALID_EDITFIELDS       24
#define MAPI_E_INVALID_RECIPS           25
#define MAPI_E_NOT_SUPPORTED            26



#ifdef MAPIX_H
/*  Maps from a simple mapi session to a MAPI 1.0 extended mapi session */

STDMETHODIMP_(SCODE)
ScMAPIXFromSMAPI(LHANDLE lhSimpleSession,
				ULONG ulFlags,
				LPCIID lpInterface,
				LPMAPISESSION FAR * lppMAPISession);
#endif /* MAPIX_H */


#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapicode.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I C O D E . H
 *
 *  Status Codes returned by MAPI routines
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef MAPICODE_H
#define MAPICODE_H

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/* Define S_OK and ITF_* */

#ifdef _WIN32
#include <winerror.h>
#endif

/*
 *  MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or winerror.h (Windows NT and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )  (MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn ) (MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one MAPI object) */

#define MAPI_E_CALL_FAILED                              E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY                        E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER                        E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED                  E_NOINTERFACE
#define MAPI_E_NO_ACCESS                                E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT                               MAKE_MAPI_E( 0x102 )
#define MAPI_E_BAD_CHARWIDTH                            MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG                          MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS                            MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID                          MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT                           MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED                           MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED                           MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY                                     MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK                          MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES                     MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND                                MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION                                  MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED                             MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT                            MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL                              MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT                          MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR                            MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR                               MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX                              MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN                               MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR                           MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED                                 MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA                             MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED                             MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER                          MAKE_MAPI_E( 0x11D )
#define MAPI_E_UNKNOWN_CPID                             MAKE_MAPI_E( 0x11E )
#define MAPI_E_UNKNOWN_LCID                             MAKE_MAPI_E( 0x11F )

/* Flavors of E_ACCESSDENIED, used at logon */

#define MAPI_E_PASSWORD_CHANGE_REQUIRED                 MAKE_MAPI_E( 0x120 )
#define MAPI_E_PASSWORD_EXPIRED                         MAKE_MAPI_E( 0x121 )
#define MAPI_E_INVALID_WORKSTATION_ACCOUNT              MAKE_MAPI_E( 0x122 )
#define MAPI_E_INVALID_ACCESS_TIME                      MAKE_MAPI_E( 0x123 )
#define MAPI_E_ACCOUNT_DISABLED                         MAKE_MAPI_E( 0x124 )

/* MAPI base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION                           MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID                          MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN                  MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE                               MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE                                MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE                             MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT                          MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE                          MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG                                  MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY                             MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID                            MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED                          MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE                       MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT                                  MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY                              MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG                            MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK                         MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED                         MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT                             MAKE_MAPI_S( 0x482 )

/* Transport specific errors and warnings */

#define MAPI_E_WAIT                                     MAKE_MAPI_E( 0x500 )
#define MAPI_E_CANCEL                                   MAKE_MAPI_E( 0x501 )
#define MAPI_E_NOT_ME                                   MAKE_MAPI_E( 0x502 )

#define MAPI_W_CANCEL_MESSAGE                           MAKE_MAPI_S( 0x580 )

/* Message Store, Folder, and Message specific errors and warnings */

#define MAPI_E_CORRUPT_STORE                            MAKE_MAPI_E( 0x600 )
#define MAPI_E_NOT_IN_QUEUE                             MAKE_MAPI_E( 0x601 )
#define MAPI_E_NO_SUPPRESS                              MAKE_MAPI_E( 0x602 )
#define MAPI_E_COLLISION                                MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED                          MAKE_MAPI_E( 0x605 )
#define MAPI_E_NON_STANDARD                             MAKE_MAPI_E( 0x606 )
#define MAPI_E_NO_RECIPIENTS                            MAKE_MAPI_E( 0x607 )
#define MAPI_E_SUBMITTED                                MAKE_MAPI_E( 0x608 )
#define MAPI_E_HAS_FOLDERS                              MAKE_MAPI_E( 0x609 )
#define MAPI_E_HAS_MESSAGES                             MAKE_MAPI_E( 0x60A )
#define MAPI_E_FOLDER_CYCLE                             MAKE_MAPI_E( 0x60B )
#define MAPI_E_STORE_FULL                               MAKE_MAPI_E( 0x60C )
#define MAPI_E_PARTIAL_ITEM                             MAKE_MAPI_E( 0x60D )
#define MAPI_E_CONNECTION_REQUIRED                      MAKE_MAPI_E( 0x60E )
#define MAPI_E_STORE_UNAVAILABLE                        MAKE_MAPI_E( 0x60F )

#define MAPI_W_PARTIAL_COMPLETION                       MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP                          MAKE_MAPI_E( 0x700 )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)  ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif  /* MAPICODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapiguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I G U I D . H
 *
 *  Master definitions of all GUID's for MAPI.
 *
 *  When included without INITGUID defined, this header file
 *  defines symbols that reference IIDs elsewhere.
 *
 *  When included with INITGUID defined and a "USES_IID_I..."
 *  statement for each IID used by the subsystem, it generates the
 *  bytes for those actual IIDs into the associated object file.
 *
 *  This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

/*
 *  List of GUIDS allocated by MAPI
 *  
 *  0x00020300  IID_IMAPISession
 *  0x00020301  IID_IMAPITable
 *  0x00020302  IID_IMAPIAdviseSink
 *  0x00020303  IID_IMAPIProp
 *  0x00020304  IID_IProfSect
 *  0x00020305  IID_IMAPIStatus
 *  0x00020306  IID_IMsgStore
 *  0x00020307  IID_IMessage
 *  0x00020308  IID_IAttachment
 *  0x00020309  IID_IAddrBook
 *  0x0002030A  IID_IMailUser
 *  0x0002030B  IID_IMAPIContainer
 *  0x0002030C  IID_IMAPIFolder
 *  0x0002030D  IID_IABContainer
 *  0x0002030E  IID_IDistList
 *  0x0002030F  IID_IMAPISup
 *  0x00020310  IID_IMSProvider
 *  0x00020311  IID_IABProvider
 *  0x00020312  IID_IXPProvider
 *  0x00020313  IID_IMSLogon
 *  0x00020314  IID_IABLogon
 *  0x00020315  IID_IXPLogon
 *  0x00020316  IID_IMAPITableData
 *  0x00020317  IID_IMAPISpoolerInit
 *  0x00020318  IID_IMAPISpoolerSession
 *  0x00020319  IID_ITNEF
 *  0x0002031A  IID_IMAPIPropData
 *  0x0002031B  IID_IMAPIControl
 *  0x0002031C  IID_IProfAdmin
 *  0x0002031D  IID_IMsgServiceAdmin
 *  0x0002031E  IID_IMAPISpoolerService
 *  0x0002031F  IID_IMAPIProgress
 *  0x00020320  IID_ISpoolerHook
 *  0x00020321  IID_IMAPIViewContext
 *  0x00020322  IID_IMAPIFormMgr
 *  0x00020323  IID_IEnumMAPIFormProp
 *  0x00020324  IID_IMAPIFormInfo
 *  0x00020325  IID_IProviderAdmin
 *  0x00020327  IID_IMAPIForm
 *  0x00020328  PS_MAPI
 *  0x00020329  PS_PUBLIC_STRINGS
 *  0x0002032A  IID_IPersistMessage
 *  0x0002032B  IID_IMAPIViewAdviseSink
 *  0x0002032C  IID_IStreamDocfile
 *  0x0002032D  IID_IMAPIFormProp
 *  0x0002032E  IID_IMAPIFormContainer
 *  0x0002032F  IID_IMAPIFormAdviseSink
 *  0x00020330  IID_IStreamTnef
 *  0x00020350  IID_IMAPIFormFactory
 *  0x00020370  IID_IMAPIMessageSite
 *  0x00020380  PS_ROUTING_EMAIL_ADDRESSES
 *  0x00020381  PS_ROUTING_ADDRTYPE
 *  0x00020382  PS_ROUTING_DISPLAY_NAME
 *  0x00020383  PS_ROUTING_ENTRYID
 *  0x00020384  PS_ROUTING_SEARCH_KEY
 *  0x00020385  MUID_PROFILE_INSTANCE
 *  
 *  The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *  MAPI for future use.  The current maximum used by MAPI is 0x00020385
 *
 */
#pragma once
#ifndef MAPIGUID_H
#define MAPIGUID_H


/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,    0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,      0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink, 0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,    0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,      0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,  0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,   0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,       0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,       0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,         0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,       0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,        0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,     0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,       0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,       0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,  0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,     0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,    0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,       0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,        0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,     0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,     0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,     0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,        0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,        0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,        0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,  0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,    0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession, 0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,           0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,   0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,    0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService, 0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,    0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,    0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,   0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,   0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,   0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI, 0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,   0x00020329, 0, 0);
#endif




/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage, 0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink, 0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,   0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIFormFactory */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormFactory)
DEFINE_OLEGUID(IID_IMAPIFormFactory, 0x00020350, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif



/* Well known guids routing property sets.
   Usefull when writing applications that route documents
   (i.e. Workflow) across gateways.  Gateways that speak MAPI
   should convert the properties found in the follow property
   sets appropriately. */

/*  PS_ROUTING_EMAIL_ADDRESSES:  Addresses that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_EMAIL_ADDRESSES)
DEFINE_OLEGUID(PS_ROUTING_EMAIL_ADDRESSES,  0x00020380, 0, 0);
#endif

/*  PS_ROUTING_ADDRTYPE:  Address types that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ADDRTYPE)
DEFINE_OLEGUID(PS_ROUTING_ADDRTYPE, 0x00020381, 0, 0);
#endif

/*  PS_ROUTING_DISPLAY_NAME:  Display Name that corresponds to the other props */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_DISPLAY_NAME)
DEFINE_OLEGUID(PS_ROUTING_DISPLAY_NAME, 0x00020382, 0, 0);
#endif

/*  PS_ROUTING_ENTRYID:  (optional) EntryIDs that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ENTRYID)
DEFINE_OLEGUID(PS_ROUTING_ENTRYID,  0x00020383, 0, 0);
#endif

/*  PS_ROUTING_SEARCH_KEY:  (optional) search keys that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_SEARCH_KEY)
DEFINE_OLEGUID(PS_ROUTING_SEARCH_KEY,   0x00020384, 0, 0);
#endif

/*  MUID_PROFILE_INSTANCE
    Well known section in a profile which contains a property (PR_SEARCH_KEY) which is unique
    for any given profile.  Applications and providers can depend on this value as being
    different for each unique profile. */
#if !defined(INITGUID) || defined(USES_MUID_PROFILE_INSTANCE)
DEFINE_OLEGUID(MUID_PROFILE_INSTANCE, 0x00020385, 0, 0);
#endif

#endif  /* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapidefs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I D E F S . H
 *
 *  Definitions used by MAPI clients and service providers.
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#if defined (_WIN32) /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <winerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (_WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif


#define MAPI_NT_SERVICE     ((ULONG) 0x00010000)  /* Provider is being loaded in an NT service */


#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined (MIDL_PASS) /* MIDL doesn't want to see these */

typedef wchar_t             WCHAR;

#ifdef UNICODE
typedef WCHAR               TCHAR;
#else
typedef char                TCHAR;
#endif

typedef WCHAR FAR *         LPWSTR;
typedef const WCHAR FAR *   LPCWSTR;
typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;
typedef BYTE FAR *          LPBYTE;
#endif /* defined MIDL_PASS */

typedef ULONG FAR *         LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long   LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))

/*
 * Constants for one-off entry ID:
 * The MAPIUID that identifies the one-off provider;
 * the flag that defines whether the embedded strings are Unicode;
 * the flag that specifies whether the recipient gets TNEF or not.
 */

#define MAPI_ONE_OFF_UID { 0x81, 0x2b, 0x1f, 0xa4, 0xbe, 0xa3, 0x10, 0x19, \
                           0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02 }
#define MAPI_ONE_OFF_UNICODE        0x8000
#define MAPI_ONE_OFF_NO_RICH_INFO   0x0001

/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */


/*
 *  Maximum length of profile names and passwords, not including
 *  the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax   64
#define cchProfilePassMax   64
#endif


/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#ifndef PT_BOOLEAN
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#endif
// Use PT_BOOLEAN_DESKTOP to be specific instead of using PT_BOOLEAN which is mapped to 2 in addrmapi.h
#define PT_BOOLEAN_DESKTOP ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (_WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
            /* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
    ULONG       cb;
    LPBYTE      lpb;
} SBinary, FAR *LPSBinary;

typedef struct _SShortArray
{
    ULONG       cValues;
    short int   FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG       cValues;
    GUID        FAR *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG       cValues;
    float       FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG       cValues;
    LONG        FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG       cValues;
    LARGE_INTEGER   FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME    FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG       cValues;
    double      FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG       cValues;
    CURRENCY    FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG       cValues;
    SBinary     FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG       cValues;
    double      FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG       cValues;
    LPWSTR      FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG       cValues;
    LPSTR       FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *  LPALLOCATEMORE;
typedef FREEBUFFER FAR *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified ?
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevNotifyAsynchronously    ((ULONG) 0x20000000)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)
#define STATUS_PRIMARY_STORE    ((ULONG) 0x00001000)
#define STATUS_SECONDARY_STORE  ((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK      ((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  LPTSTR                      lpOldPass,                  \
                LPTSTR                      lpNewPass,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS        ((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH        ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define SEARCH_RUNNING          ((ULONG) 0x00000001)
#define SEARCH_REBUILD          ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE        ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND       ((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH             ((ULONG) 0x00000001)
#define RESTART_SEARCH          ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH        ((ULONG) 0x00000004)
#define SHALLOW_SEARCH          ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH       ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH       ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)                              \
    MAPIMETHOD(GetContentsTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(GetHierarchyTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetSearchCriteria)                                       \
        (THIS_  LPSRestriction              lpRestriction,              \
                LPENTRYLIST                 lpContainerList,            \
                ULONG                       ulSearchFlags) IPURE;       \
    MAPIMETHOD(GetSearchCriteria)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRestriction FAR *        lppRestriction,             \
                LPENTRYLIST FAR *           lppContainerList,           \
                ULONG FAR *                 lpulSearchState)IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *  IABContainer PR_CONTAINER_FLAGS values
 *  If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *  doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *  If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS           ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS        ((ULONG) 0x00000002)
#define AB_MODIFIABLE           ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE         ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN         ((ULONG) 0x00000010)
#define AB_NOT_DEFAULT          ((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE  ((ULONG) 0x00000002)
#define CREATE_REPLACE          ((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED         ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS          ((ULONG) 0x00000001)
#define MAPI_RESOLVED           ((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)                                \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAdrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
    passing in the following flag in the ulFlags parameter.  Setting this flag
    indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO      ((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)    ((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC                     MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED              MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS                 MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED                     MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED                     MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE             MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED              MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED                  MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG                  MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT            MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT             MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED           MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID                MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR           MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD         MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD         MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED          MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS               MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT            MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED         MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB            MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG                     MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG                     MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST             MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST           MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST         MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES              MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED           MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED         MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED              MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED             MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED                  MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED             MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT            MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD         MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE           MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN            MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED           MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED         MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED                      MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED                    MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED              MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING         MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED           MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN          MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED          MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB            MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR            MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE            MAPI_DIAG( 47 )

/* Values of PR_DELIVERY_POINT (MH_T_DELIVERY_POINT) */

#define MAPI_MH_DP_PUBLIC_UA                        ((ULONG) 0)
#define MAPI_MH_DP_PRIVATE_UA                       ((ULONG) 1)
#define MAPI_MH_DP_MS                               ((ULONG) 2)
#define MAPI_MH_DP_ML                               ((ULONG) 3)
#define MAPI_MH_DP_PDAU                             ((ULONG) 4)
#define MAPI_MH_DP_PDS_PATRON                       ((ULONG) 5)
#define MAPI_MH_DP_OTHER_AU                         ((ULONG) 6)


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)                                   \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT             ((ULONG) 0x00000000)
#define FOLDER_GENERIC          ((ULONG) 0x00000001)
#define FOLDER_SEARCH           ((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE            ((ULONG) 0x00000001)
#define MESSAGE_DIALOG          ((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS          ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES            ((ULONG) 0x00000001)
#define FOLDER_DIALOG           ((ULONG) 0x00000002)
#define DEL_FOLDERS             ((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED          ((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE             ((ULONG) 0x00000001)
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS         ((ULONG) 0x00000010)
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT        ((ULONG) 0x00000001) below */
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG         ((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010) below */
/****** CLEAR_RN_PENDING        ((ULONG) 0x00000020) below */
/****** CLEAR_NRN_PENDING       ((ULONG) 0x00000040) below */


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED        ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED     ((ULONG) 0x00000008)

/* Bits for remote message status */

#define MSGSTATUS_REMOTE_DOWNLOAD   ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE     ((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT          ((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED        ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED     ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)                                 \
    MAPIMETHOD(CreateMessage)                                           \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMESSAGE FAR *             lppMessage) IPURE;          \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMessages)                                          \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateFolder)                                            \
        (THIS_  ULONG                       ulFolderType,               \
                LPTSTR                      lpszFolderName,             \
                LPTSTR                      lpszFolderComment,          \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMAPIFOLDER FAR *          lppFolder) IPURE;           \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lpszNewFolderName,          \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteFolder)                                            \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlags)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulMessageStatus) IPURE;   \
    MAPIMETHOD(SetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulNewStatus,                \
                ULONG                       ulNewStatusMask,            \
                ULONG FAR *                 lpulOldStatus) IPURE;       \
    MAPIMETHOD(SaveContentsSort)                                        \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(EmptyFolder)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE    ((ULONG) 0x00000001)
#define STORE_READONLY          ((ULONG) 0x00000002)
#define STORE_SEARCH_OK         ((ULONG) 0x00000004)
#define STORE_MODIFY_OK         ((ULONG) 0x00000008)
#define STORE_CREATE_OK         ((ULONG) 0x00000010)
#define STORE_ATTACH_OK         ((ULONG) 0x00000020)
#define STORE_OLE_OK            ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK         ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK         ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK       ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK     ((ULONG) 0x00000400)
#define STORE_RTF_OK            ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK    ((ULONG) 0x00001000)
#define STORE_SORT_OK           ((ULONG) 0x00002000)
#define STORE_PUBLIC_FOLDERS    ((ULONG) 0x00004000)
#define STORE_UNCOMPRESSED_RTF  ((ULONG) 0x00008000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES      ((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define LOGOFF_NO_WAIT          ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY          ((ULONG) 0x00000002)
#define LOGOFF_PURGE            ((ULONG) 0x00000004)
#define LOGOFF_ABORT            ((ULONG) 0x00000008)
#define LOGOFF_QUIET            ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE         ((ULONG) 0x00010000)
#define LOGOFF_INBOUND          ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND         ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE   ((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED              ((ULONG) 0x00000001)
#define MSG_UNLOCKED            ((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define FOLDER_IPM_SUBTREE_VALID        ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID          ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID         ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID    ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID       ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID              ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID       ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID             ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)                                   \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID,                 \
                LPTSTR FAR *                lppszExplicitClass) IPURE;  \
    MAPIMETHOD(GetReceiveFolderTable)                                   \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(StoreLogoff)                                             \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(AbortSubmit)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetOutgoingQueue)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(SetLockState)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG                       ulLockState) IPURE;         \
    MAPIMETHOD(FinishedMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(NotifyNewMail)                                           \
        (THIS_  LPNOTIFICATION              lpNotification) IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT                ((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ            ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED      ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT          ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT          ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH       ((ULONG) 0x00000010)
#define MSGFLAG_FROMME          ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED      ((ULONG) 0x00000040)
#define MSGFLAG_RESEND          ((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING      ((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING     ((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED       ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS   ((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD            ((ULONG) 0x00000002)
#define MODRECIP_MODIFY         ((ULONG) 0x00000004)
#define MODRECIP_REMOVE         ((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT        ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG         ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010)
#define CLEAR_RN_PENDING        ((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING       ((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG           ((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED         ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED      ((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT             ((long)  1)
#define PRIO_NORMAL             ((long)  0)
#define PRIO_NONURGENT          ((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE                    ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL                ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE                 ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL    ((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW          ((long) 0)
#define IMPORTANCE_NORMAL       ((long) 1)
#define IMPORTANCE_HIGH         ((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)                                    \
    MAPIMETHOD(GetAttachmentTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenAttach)                                              \
        (THIS_  ULONG                       ulAttachmentNum,            \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(CreateAttach)                                            \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulAttachmentNum,          \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(DeleteAttach)                                            \
        (THIS_  ULONG                       ulAttachmentNum,            \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetRecipientTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(ModifyRecipients)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPADRLIST                   lpMods) IPURE;              \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlag)                                             \
        (THIS_  ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT           ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE         ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE     ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE   ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY      ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG     ((ULONG) 0x00000005)
#define ATTACH_OLE              ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX        ((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL            ((ULONG) 0x00000001)
#define DIALOG_SDI              ((ULONG) 0x00000002)
#define DIALOG_OPTIONS          ((ULONG) 0x00000004)
#define ADDRESS_ONE             ((ULONG) 0x00000008)
#define AB_SELECTONLY           ((ULONG) 0x00000010)
#define AB_RESOLVE              ((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER         ((ULONG) 0x00000000)
#define DT_DISTLIST         ((ULONG) 0x00000001)
#define DT_FORUM            ((ULONG) 0x00000002)
#define DT_AGENT            ((ULONG) 0x00000003)
#define DT_ORGANIZATION     ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER  ((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE       ((ULONG) 0x00010000)
#define DT_GLOBAL           ((ULONG) 0x00020000)
#define DT_LOCAL            ((ULONG) 0x00030000)
#define DT_WAN              ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC     ((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER           ((ULONG) 0x01000000)
#define DT_FOLDER_LINK      ((ULONG) 0x02000000)
#define DT_FOLDER_SPECIAL   ((ULONG) 0x04000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
                                                LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
                                                LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
    ULONG               ulUIParam,
    LPVOID              lpvContext,
    ULONG               cbEntryID,
    LPENTRYID           lpSelection,
    ULONG               ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
    ULONG           cbABContEntryID;
    LPENTRYID       lpABContEntryID;
    ULONG           ulFlags;

    LPVOID          lpReserved;
    ULONG           ulHelpContext;
    LPTSTR          lpszHelpFileName;

    LPFNABSDI       lpfnABSDI;
    LPFNDISMISS     lpfnDismiss;
    LPVOID          lpvDismissContext;
    LPTSTR          lpszCaption;
    LPTSTR          lpszNewEntryTitle;
    LPTSTR          lpszDestWellsTitle;
    ULONG           cDestFields;
    ULONG           nDestFieldFocus;
    LPTSTR FAR *    lppszDestTitles;
    ULONG FAR *     lpulDestComps;
    LPSRestriction  lpContRestriction;
    LPSRestriction  lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED         ((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG           ((ULONG) 0x00000001)
#define MDB_WRITE               ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */
#define MDB_TEMPORARY           ((ULONG) 0x00000020)
#define MDB_NO_MAIL             ((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG            ((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED       ((ULONG) 0x00000000)
#define  MAPI_DISABLED      ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Activate)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulUIParam) IPURE;           \
    MAPIMETHOD(GetState)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulState) IPURE;           \

#undef       INTERFACE
#define      INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE        ((ULONG) 0x00000001)
#define DT_EDITABLE         ((ULONG) 0x00000002)
#define DT_REQUIRED         ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE    ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT    ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS      ((ULONG) 0x00000020)
#define DT_SET_SELECTION    ((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL          ((ULONG) 0x00000000)
#define DTCT_EDIT           ((ULONG) 0x00000001)
#define DTCT_LBX            ((ULONG) 0x00000002)
#define DTCT_COMBOBOX       ((ULONG) 0x00000003)
#define DTCT_DDLBX          ((ULONG) 0x00000004)
#define DTCT_CHECKBOX       ((ULONG) 0x00000005)
#define DTCT_GROUPBOX       ((ULONG) 0x00000006)
#define DTCT_BUTTON         ((ULONG) 0x00000007)
#define DTCT_PAGE           ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON    ((ULONG) 0x00000009)
#define DTCT_MVLISTBOX      ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX        ((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
    DTBLLABEL   dtbllabel; \
    TCHAR       lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
    DTBLEDIT    dtbledit; \
    TCHAR       lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR        ((ULONG) 0x00000001)
#define MAPI_NO_VBAR        ((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
    DTBLCOMBOBOX    dtblcombobox; \
    TCHAR           lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
    DTBLCHECKBOX    dtblcheckbox; \
    TCHAR       lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
    DTBLGROUPBOX    dtblgroupbox; \
    TCHAR           lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
    DTBLBUTTON  dtblbutton; \
    TCHAR       lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
    DTBLPAGE    dtblpage; \
    TCHAR       lpszLabel[n]; \
    TCHAR       lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
    DTBLRADIOBUTTON dtblradiobutton; \
    TCHAR           lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE                  0x00000002
#define SERVICE_UI_ALWAYS           0x00000002      /* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED          0x00000010
#define UI_CURRENT_PROVIDER_FIRST   0x00000004
/* MSG_SERVICE_UI_READ_ONLY         0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)                              \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProvider)                                          \
        (THIS_  LPTSTR                      lpszProvider,               \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps,                    \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                MAPIUID FAR *               lpUID) IPURE;               \
    MAPIMETHOD(DeleteProvider)                                          \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \


#undef       INTERFACE
#define      INTERFACE  IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* MAPIDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapispi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I S P I . H
 *
 *  Defines the calls and structures exchanged between MAPI or the spooler
 *  and the MAPI service providers
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef MAPISPI_H
#define MAPISPI_H
/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*  The MAPI SPI has a version number.  MAPIX.DLL knows and supports
 *  one or more versions of the SPI.  Each provider supports one or
 *  more versions of the SPI.  Checks are performed in both MAPIX.DLL
 *  and in the provider to ensure that they agree to use exactly one
 *  version of the MAPI SPI.
 *
 *  The SPI version number is composed of a major (8-bit) version,
 *  minor (8-bit) version, and micro (16-bit) version.  The first
 *  retail ship of MAPI 1.0 is expected to be version 1.0.0.
 *  The major version number changes rarely.
 *  The minor version number changes opon each retail ship of
 *  MAPI if the SPI has been modified.
 *  The micro version number changes internally at Microsoft
 *  during development of MAPI.
 *
 *  The version of the SPI documented by this set of header files
 *  is ALWAYS known as "CURRENT_SPI_VERSION".  If you write a
 *  service provider, and get a new set of header files, and update
 *  your code to the new interface, you'll be at the "current" version.
 */
#define CURRENT_SPI_VERSION 0x00010010L

/*  Here are some well-known SPI version numbers:
 *  (These will eventually be useful for provider-writers who
 *  might choose to make provider DLLs that support more than
 *  one version of the MAPI SPI.
 */
#define PDK1_SPI_VERSION    0x00010000L /* 0.1.0  MAPI PDK1 Spring 1993 */

#define PDK2_SPI_VERSION    0x00010008L /* 0.1.8  MAPI PDK2 Spring 1994 */

#define PDK3_SPI_VERSION    0x00010010L /* 0.1.16 MAPI PDK3 Fall 1994   */

/*
 * Forward declaration of interface pointers specific to the service
 * provider interface.
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISupport, LPMAPISUP);

/* IMAPISupport Interface -------------------------------------------------- */

/* Notification key structure for the MAPI notification engine */

typedef struct
{
    ULONG       cb;             /* How big the key is */
    BYTE        ab[MAPI_DIM];   /* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)      (offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)      (offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
    struct _NOTIFKEY_ ## _name \
{ \
    ULONG       cb; \
    BYTE        ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC             ((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED         ((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE    ((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL          ((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND      ((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED     ((ULONG) 0x00000004)
#define NOTIFY_CRITSEC          ((ULONG) 0x00001000)
#define NOTIFY_NONCRIT          ((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE    ((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR   ((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED ((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define STATUSROW_UPDATE        ((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET           ((ULONG) 0x00000000)
#define STGSTRM_CURRENT         ((ULONG) 0x10000000)
#define STGSTRM_MODIFY          ((ULONG) 0x00000002)
#define STGSTRM_CREATE          ((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO  ((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ           ((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/* Preprocessor calls: */

/* PreprocessMessage, first ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE PREPROCESSMESSAGE)(
                    LPVOID lpvSession,
                    LPMESSAGE lpMessage,
                    LPADRBOOK lpAdrBook,
                    LPMAPIFOLDER lpFolder,
                    LPALLOCATEBUFFER AllocateBuffer,
                    LPALLOCATEMORE AllocateMore,
                    LPFREEBUFFER FreeBuffer,
                    ULONG FAR *lpcOutbound,
                    LPMESSAGE FAR * FAR *lpppMessage,
                    LPADRLIST FAR *lppRecipList);

/* RemovePreprocessInfo, second ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE REMOVEPREPROCESSINFO)(LPMESSAGE lpMessage);

/* Function pointer for GetReleaseInfo */

#define MAPI_IMAPISUPPORT_METHODS1(IPURE)                               \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMemAllocRoutines)                                     \
        (THIS_  LPALLOCATEBUFFER FAR *      lpAllocateBuffer,           \
                LPALLOCATEMORE FAR *        lpAllocateMore,             \
                LPFREEBUFFER FAR *          lpFreeBuffer) IPURE;        \
    MAPIMETHOD(Subscribe)                                               \
        (THIS_  LPNOTIFKEY                  lpKey,                      \
                ULONG                       ulEventMask,                \
                ULONG                       ulFlags,                    \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unsubscribe)                                             \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(Notify)                                                  \
        (THIS_  LPNOTIFKEY                  lpKey,                      \
                ULONG                       cNotification,              \
                LPNOTIFICATION              lpNotifications,            \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(ModifyStatusRow)                                         \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpColumnVals,               \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUid,                      \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfileObj) IPURE;       \
    MAPIMETHOD(RegisterPreprocessor)                                    \
        (THIS_  LPMAPIUID                   lpMuid,                     \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszDLLName,                \
                LPSTR   /* String8! */      lpszPreprocess,             \
                LPSTR   /* String8! */      lpszRemovePreprocessInfo,   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(NewUID)                                                  \
        (THIS_  LPMAPIUID                   lpMuid) IPURE;              \
    MAPIMETHOD(MakeInvalid)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPVOID                      lpObject,                   \
                ULONG                       ulRefCount,                 \
                ULONG                       cMethods) IPURE;            \

#define MAPI_IMAPISUPPORT_METHODS2(IPURE)                               \
    MAPIMETHOD(SpoolerYield)                                            \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SpoolerNotify)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPVOID                      lpvData) IPURE;             \
    MAPIMETHOD(CreateOneOff)                                            \
        (THIS_  LPTSTR                      lpszName,                   \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszAddress,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetProviderUID)                                          \
        (THIS_  LPMAPIUID                   lpProviderID,               \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntry1,                   \
                LPENTRYID                   lpEntry1,                   \
                ULONG                       cbEntry2,                   \
                LPENTRYID                   lpEntry2,                   \
                ULONG                       ulCompareFlags,             \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                      lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulOpenFlags,                \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(Address)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPADRPARM                   lpAdrParms,                 \
                LPADRLIST FAR *             lppAdrList) IPURE;          \
    MAPIMETHOD(Details)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPFNDISMISS                 lpfnDismiss,                \
                LPVOID                      lpvDismissContext,          \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPFNBUTTON                  lpfButtonCallback,          \
                LPVOID                      lpvButtonContext,           \
                LPTSTR                      lpszButtonText,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(NewEntry)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cbEIDContainer,             \
                LPENTRYID                   lpEIDContainer,             \
                ULONG                       cbEIDNewEntryTpl,           \
                LPENTRYID                   lpEIDNewEntryTpl,           \
                ULONG FAR *                 lpcbEIDNewEntry,            \
                LPENTRYID FAR *             lppEIDNewEntry) IPURE;      \
    MAPIMETHOD(DoConfigPropsheet)                                       \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszTitle,                  \
                LPMAPITABLE                 lpDisplayTable,             \
                LPMAPIPROP                  lpCOnfigData,               \
                ULONG                       ulTopPage) IPURE;           \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcFolder,                \
                LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcFolder,                \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lszNewFolderName,           \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#define MAPI_IMAPISUPPORT_METHODS3(IPURE)                               \
    MAPIMETHOD(DoCopyTo)                                                \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcObj,                   \
                ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DoCopyProps)                                             \
        (THIS_  LPCIID                      lpSrcInterface,             \
                LPVOID                      lpSrcObj,                   \
                LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpDestInterface,            \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DoProgressDialog)                                        \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPMAPIPROGRESS FAR *        lppProgress) IPURE;         \
    MAPIMETHOD(ReadReceipt)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpReadMessage,              \
                LPMESSAGE FAR *             lppEmptyMessage) IPURE;     \
    MAPIMETHOD(PrepareSubmit)                                           \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(ExpandRecips)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(UpdatePAB)                                               \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(DoSentMail)                                              \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(OpenAddressBook)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPADRBOOK FAR *             lppAdrBook) IPURE;          \
    MAPIMETHOD(Preprocess)                                              \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(CompleteMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(StoreLogoffTransports)                                   \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(StatusRecips)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                LPADRLIST                   lpRecipList) IPURE;         \
    MAPIMETHOD(WrapStoreEntryID)                                        \
        (THIS_  ULONG                       cbOrigEntry,                \
                LPENTRYID                   lpOrigEntry,                \
                ULONG FAR *                 lpcbWrappedEntry,           \
                LPENTRYID FAR *             lppWrappedEntry) IPURE;     \
    MAPIMETHOD(ModifyProfile)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(IStorageFromStream)                                      \
        (THIS_  LPUNKNOWN                   lpUnkIn,                    \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPSTORAGE FAR *             lppStorageOut) IPURE;       \
    MAPIMETHOD(GetSvcConfigSupportObj)                                  \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPISUP FAR *             lppSvcSupport) IPURE;       \

#undef       INTERFACE
#define      INTERFACE  IMAPISupport
DECLARE_MAPI_INTERFACE_(IMAPISupport, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISUPPORT_METHODS1(PURE)
    MAPI_IMAPISUPPORT_METHODS2(PURE)
    MAPI_IMAPISUPPORT_METHODS3(PURE)
};


/********************************************************************/
/*                                                                  */
/*                          ADDRESS BOOK SPI                        */
/*                                                                  */
/********************************************************************/

/* Address Book Provider ------------------------------------------------- */

/* OpenTemplateID() */
#define FILL_ENTRY              ((ULONG) 0x00000001)

/* For Logon() */

/*#define AB_NO_DIALOG          ((ULONG) 0x00000001) in mapidefs.h */
/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */



DECLARE_MAPI_INTERFACE_PTR(IABProvider, LPABPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IABLogon,    LPABLOGON);

#define MAPI_IABPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulpcbSecurity,            \
                LPBYTE FAR *                lppbSecurity,               \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPABLOGON FAR *             lppABLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABProvider
DECLARE_MAPI_INTERFACE_(IABProvider, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABPROVIDER_METHODS(PURE)
};

/* For GetOneOffTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IABLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                       lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                       lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(PrepareRecips)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray             lpPropTagArray,             \
                LPADRLIST                   lpRecipList) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IABLogon
DECLARE_MAPI_INTERFACE_(IABLogon, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABLOGON_METHODS(PURE)
};

typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
    HINSTANCE           hInstance,
    LPMALLOC            lpMalloc,
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPALLOCATEMORE      lpAllocateMore,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    ULONG               ulMAPIVer,
    ULONG FAR *         lpulProviderVer,
    LPABPROVIDER FAR *  lppABProvider
);

ABPROVIDERINIT ABProviderInit;



/********************************************************************/
/*                                                                  */
/*                          TRANSPORT SPI                           */
/*                                                                  */
/********************************************************************/

/* For DeinitTransport */

#define DEINIT_NORMAL               ((ULONG) 0x00000001)
#define DEINIT_HURRY                ((ULONG) 0x80000000)

/* For TransportLogon */

/* Flags that the Spooler may pass to the transport: */

#define LOGON_NO_DIALOG             ((ULONG) 0x00000001)
#define LOGON_NO_CONNECT            ((ULONG) 0x00000004)
#define LOGON_NO_INBOUND            ((ULONG) 0x00000008)
#define LOGON_NO_OUTBOUND           ((ULONG) 0x00000010)
/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* Flags that the transport may pass to the Spooler: */

#define LOGON_SP_IDLE               ((ULONG) 0x00010000)
#define LOGON_SP_POLL               ((ULONG) 0x00020000)
#define LOGON_SP_RESOLVE            ((ULONG) 0x00040000)


DECLARE_MAPI_INTERFACE_PTR(IXPProvider, LPXPPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IXPLogon, LPXPLOGON);

#define MAPI_IXPPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(TransportLogon)                                          \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG FAR *                 lpulFlags,                  \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPXPLOGON FAR *             lppXPLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IXPProvider
DECLARE_MAPI_INTERFACE_(IXPProvider, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPPROVIDER_METHODS(PURE)
};

/* OptionData returned from call to RegisterOptions */

#define OPTION_TYPE_RECIPIENT       ((ULONG) 0x00000001)
#define OPTION_TYPE_MESSAGE         ((ULONG) 0x00000002)

typedef struct _OPTIONDATA
{
    ULONG           ulFlags;        /* MAPI_RECIPIENT, MAPI_MESSAGE */
    LPGUID          lpRecipGUID;    /* Same as returned by AddressTypes() */
    LPTSTR          lpszAdrType;    /* Same as returned by AddressTypes() */
    LPTSTR          lpszDLLName;    /* Options DLL */
    ULONG           ulOrdinal;      /* Ordinal in that DLL */
    ULONG           cbOptionsData;  /* Count of bytes in lpbOptionsData */
    LPBYTE          lpbOptionsData; /* Providers per [recip|message] option data */
    ULONG           cOptionsProps;  /* Count of Options default prop values */
    LPSPropValue    lpOptionsProps; /* Default Options property values */
} OPTIONDATA, FAR *LPOPTIONDATA;

typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
            HINSTANCE           hInst,
            LPMALLOC            lpMalloc,
            ULONG               ulFlags,
            ULONG               cbOptionData,
            LPBYTE              lpbOptionData,
            LPMAPISUP           lpMAPISup,
            LPMAPIPROP          lpDataSource,
            LPMAPIPROP FAR *    lppWrappedSource,
            LPMAPIERROR FAR *   lppMAPIError);

/* For XP_AddressTypes */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterRecipOptions */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterMessageOptions */

/*#define MAPI_UNICODE              ((ULONG) 0x80000000) in mapidefs.h */

/* For TransportNotify */

#define NOTIFY_ABORT_DEFERRED       ((ULONG) 0x40000000)
#define NOTIFY_CANCEL_MESSAGE       ((ULONG) 0x80000000)
#define NOTIFY_BEGIN_INBOUND        ((ULONG) 0x00000001)
#define NOTIFY_END_INBOUND          ((ULONG) 0x00010000)
#define NOTIFY_BEGIN_OUTBOUND       ((ULONG) 0x00000002)
#define NOTIFY_END_OUTBOUND         ((ULONG) 0x00020000)
#define NOTIFY_BEGIN_INBOUND_FLUSH  ((ULONG) 0x00000004)
#define NOTIFY_END_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define NOTIFY_BEGIN_OUTBOUND_FLUSH ((ULONG) 0x00000008)
#define NOTIFY_END_OUTBOUND_FLUSH   ((ULONG) 0x00080000)

/* For TransportLogoff */

#define LOGOFF_NORMAL               ((ULONG) 0x00000001)
#define LOGOFF_HURRY                ((ULONG) 0x80000000)

/* For SubmitMessage */

#define BEGIN_DEFERRED              ((ULONG) 0x00000001)

/* For EndMessage */

/* Flags that the Spooler may pass to the Transport: */

/* Flags that the transport may pass to the Spooler: */

#define END_RESEND_NOW              ((ULONG) 0x00010000)
#define END_RESEND_LATER            ((ULONG) 0x00020000)
#define END_DONT_RESEND             ((ULONG) 0x00040000)

#define MAPI_IXPLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(AddressTypes)                                            \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                ULONG FAR *                 lpcAdrType,                 \
                LPTSTR FAR * FAR *          lpppAdrTypeArray,           \
                ULONG FAR *                 lpcMAPIUID,                 \
                LPMAPIUID FAR * FAR *       lpppUIDArray) IPURE;        \
    MAPIMETHOD(RegisterOptions)                                         \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                ULONG FAR *                 lpcOptions,                 \
                LPOPTIONDATA FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(TransportNotify)                                         \
        (THIS_  ULONG FAR *                 lpulFlags,                  \
                LPVOID FAR *                lppvData) IPURE;            \
    MAPIMETHOD(Idle)                                                    \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(TransportLogoff)                                         \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMsgRef,                 \
                ULONG FAR *                 lpulReturnParm) IPURE;      \
    MAPIMETHOD(EndMessage)                                              \
        (THIS_  ULONG                       ulMsgRef,                   \
                ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Poll)                                                    \
        (THIS_  ULONG FAR *                 lpulIncoming) IPURE;        \
    MAPIMETHOD(StartMessage)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMsgRef) IPURE;          \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IXPLogon
DECLARE_MAPI_INTERFACE_(IXPLogon, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPLOGON_METHODS(PURE)
};


/* Transport Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
    HINSTANCE           hInstance,
    LPMALLOC            lpMalloc,
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPALLOCATEMORE      lpAllocateMore,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    ULONG               ulMAPIVer,
    ULONG FAR *         lpulProviderVer,
    LPXPPROVIDER FAR *  lppXPProvider);

XPPROVIDERINIT XPProviderInit;

/********************************************************************/
/*                                                                  */
/*                          MESSAGE STORE SPI                       */
/*                                                                  */
/********************************************************************/

/* Flags and enums */

/* For Logon() */

/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG         ((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE             ((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) in mapidefs.h */
/*#define MDB_TEMPORARY         ((ULONG) 0x00000020) in mapidefs.h */
/*#define MDB_NO_MAIL           ((ULONG) 0x00000080) in mapidefs.h */

/* For SpoolerLogon() */

/*#define MAPI_UNICODE          ((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG         ((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE             ((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) in mapidefs.h */

/* GetCredentials, SetCredentials */

#define LOGON_SP_TRANSPORT      ((ULONG) 0x00000001)
#define LOGON_SP_PROMPT         ((ULONG) 0x00000002)
#define LOGON_SP_NEWPW          ((ULONG) 0x00000004)
#define LOGON_CHANGED           ((ULONG) 0x00000008)

/* DoMCDialog */

#define DIALOG_FOLDER           ((ULONG) 0x00000001)
#define DIALOG_MESSAGE          ((ULONG) 0x00000002)
#define DIALOG_PROP             ((ULONG) 0x00000004)
#define DIALOG_ATTACH           ((ULONG) 0x00000008)

#define DIALOG_MOVE             ((ULONG) 0x00000010)
#define DIALOG_COPY             ((ULONG) 0x00000020)
#define DIALOG_DELETE           ((ULONG) 0x00000040)

#define DIALOG_ALLOW_CANCEL     ((ULONG) 0x00000080)
#define DIALOG_CONFIRM_CANCEL   ((ULONG) 0x00000100)

/* ExpandRecips */

#define NEEDS_PREPROCESSING     ((ULONG) 0x00000001)
#define NEEDS_SPOOLER           ((ULONG) 0x00000002)

/* PrepareSubmit */

#define CHECK_SENDER            ((ULONG) 0x00000001)
#define NON_STANDARD            ((ULONG) 0x00010000)


DECLARE_MAPI_INTERFACE_PTR(IMSLogon, LPMSLOGON);
DECLARE_MAPI_INTERFACE_PTR(IMSProvider, LPMSPROVIDER);

/* Message Store Provider Interface (IMSPROVIDER) */

#define MAPI_IMSPROVIDER_METHODS(IPURE)                                 \
    MAPIMETHOD(Shutdown)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                LPCIID                      lpInterface,                \
                ULONG FAR *                 lpcbSpoolSecurity,          \
                LPBYTE FAR *                lppbSpoolSecurity,          \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPMSLOGON FAR *             lppMSLogon,                 \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(SpoolerLogon)                                            \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                LPCIID                      lpInterface,                \
                ULONG                       cbSpoolSecurity,            \
                LPBYTE                      lpbSpoolSecurity,           \
                LPMAPIERROR FAR *           lppMAPIError,               \
                LPMSLOGON FAR *             lppMSLogon,                 \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(CompareStoreIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IMSProvider
DECLARE_MAPI_INTERFACE_(IMSProvider, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSPROVIDER_METHODS(PURE)
};

/* The MSLOGON object is returned by the Logon() method of the
 * MSPROVIDER interface.  This object is for use by MAPIX.DLL.
 */
#define MAPI_IMSLOGON_METHODS(IPURE)                                    \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPVOID FAR *                lppEntry) IPURE;            \

#undef       INTERFACE
#define      INTERFACE  IMSLogon
DECLARE_MAPI_INTERFACE_(IMSLogon, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSLOGON_METHODS(PURE)
};

/* Message Store Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
    HINSTANCE               hInstance,
    LPMALLOC                lpMalloc,           /* AddRef() if you keep it */
    LPALLOCATEBUFFER        lpAllocateBuffer,   /* -> AllocateBuffer */
    LPALLOCATEMORE          lpAllocateMore,     /* -> AllocateMore   */
    LPFREEBUFFER            lpFreeBuffer,       /* -> FreeBuffer     */
    ULONG                   ulFlags,
    ULONG                   ulMAPIVer,
    ULONG FAR *             lpulProviderVer,
    LPMSPROVIDER FAR *      lppMSProvider
);

MSPROVIDERINIT MSProviderInit;


/********************************************************************/
/*                                                                  */
/*                    MESSAGE SERVICE CONFIGURATION                 */
/*                                                                  */
/********************************************************************/

/* Flags for service configuration entry point */

/* #define MAPI_UNICODE              0x80000000 */
/* #define SERVICE_UI_ALWAYS         0x00000002 */
/* #define SERVICE_UI_ALLOWED        0x00000010 */
#define MSG_SERVICE_UI_READ_ONLY     0x00000008 /* display parameters only */
#define SERVICE_LOGON_FAILED         0x00000020 /* reconfigure provider */

/* Contexts for service configuration entry point */

#define MSG_SERVICE_INSTALL         0x00000001
#define MSG_SERVICE_CREATE          0x00000002
#define MSG_SERVICE_CONFIGURE       0x00000003
#define MSG_SERVICE_DELETE          0x00000004
#define MSG_SERVICE_UNINSTALL       0x00000005
#define MSG_SERVICE_PROVIDER_CREATE 0x00000006
#define MSG_SERVICE_PROVIDER_DELETE 0x00000007

/* Prototype for service configuration entry point */

typedef HRESULT (STDAPICALLTYPE MSGSERVICEENTRY)(
    HINSTANCE       hInstance,
    LPMALLOC        lpMalloc,
    LPMAPISUP       lpMAPISup,
    ULONG           ulUIParam,
    ULONG           ulFlags,
    ULONG           ulContext,
    ULONG           cValues,
    LPSPropValue    lpProps,
    LPPROVIDERADMIN lpProviderAdmin,
    LPMAPIERROR FAR *lppMapiError
);
typedef MSGSERVICEENTRY FAR *LPMSGSERVICEENTRY;


#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapiutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I U T I L . H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _MAPIUTIL_H_
#define _MAPIUTIL_H_

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIX_H
#include <mapix.h>
#endif

#ifdef WIN16
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
    ULONG       ulCallerData,
    LPTABLEDATA lpTblData,
    LPMAPITABLE lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)                                  \
    MAPIMETHOD(HrGetView)                                               \
        (THIS_  LPSSortOrderSet             lpSSortOrderSet,            \
                CALLERRELEASE FAR *         lpfCallerRelease,           \
                ULONG                       ulCallerData,               \
                LPMAPITABLE FAR *           lppMAPITable) IPURE;        \
    MAPIMETHOD(HrModifyRow)                                             \
        (THIS_  LPSRow) IPURE;                                          \
    MAPIMETHOD(HrDeleteRow)                                             \
        (THIS_  LPSPropValue                lpSPropValue) IPURE;        \
    MAPIMETHOD(HrQueryRow)                                              \
        (THIS_  LPSPropValue                lpsPropValue,               \
                LPSRow FAR *                lppSRow,                    \
                ULONG FAR *                 lpuliRow) IPURE;            \
    MAPIMETHOD(HrEnumRow)                                               \
        (THIS_  ULONG                       ulRowNumber,                \
                LPSRow FAR *                lppSRow) IPURE;             \
    MAPIMETHOD(HrNotify)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cValues,                    \
                LPSPropValue                lpSPropValue) IPURE;        \
    MAPIMETHOD(HrInsertRow)                                             \
        (THIS_  ULONG                       uliRow,                     \
                LPSRow                      lpSRow) IPURE;              \
    MAPIMETHOD(HrModifyRows)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lpSRowSet) IPURE;           \
    MAPIMETHOD(HrDeleteRows)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lprowsetToDelete,           \
                ULONG FAR *                 cRowsDeleted) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*  CreateTable()
 *      Creates the internal memory structures and object handle
 *      to bring a new table into existence.
 *
 *  lpInterface
 *      Interface ID of the TableData object (IID_IMAPITableData)
 *
 *  lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *      Function addresses are provided by the caller so that
 *      this DLL allocates/frees memory appropriately.
 *  lpvReserved
 *      Reserved.  Should be NULL.
 *  ulTableType
 *      TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *      as part of the GetStatus return data on its views
 *  ulPropTagIndexColumn
 *      Index column for use when changing the data
 *  lpSPropTagArrayColumns
 *      Column proptags for the minimum set of columns in the table
 *  lppTableData
 *      Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID                 lpInterface,
             ALLOCATEBUFFER FAR *   lpAllocateBuffer,
             ALLOCATEMORE FAR *     lpAllocateMore,
             FREEBUFFER FAR *       lpFreeBuffer,
             LPVOID                 lpvReserved,
             ULONG                  ulTableType,
             ULONG                  ulPropTagIndexColumn,
             LPSPropTagArray        lpSPropTagArrayColumns,
             LPTABLEDATA FAR *      lppTableData );

/*  HrGetView()
 *      This function obtains a new view on the underlying data
 *      which supports the IMAPITable interface.  All rows and columns
 *      of the underlying table data are initially visible
 *  lpSSortOrderSet
 *      if specified, results in the view being sorted
 *  lpfCallerRelease
 *      pointer to a routine to be called when the view is released, or
 *      NULL.
 *  ulCallerData
 *      arbitrary data the caller wants saved with this view and returned in
 *      the Release callback.
 */

/*  HrModifyRows()
 *      Add or modify a set of rows in the table data
 *  ulFlags
 *      Must be zero
 *  lpSRowSet
 *      Each row in the row set contains all the properties for one row
 *      in the table.  One of the properties must be the index column.  Any
 *      row in the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added.
 *      Each row in LPSRowSet MUST have a unique Index column!
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */

/*  HrModifyRow()
 *      Add or modify one row in the table
 *  lpSRow
 *      This row contains all the properties for one row in the table.
 *      One of the properties must be the index column.  Any row in
 *      the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */

/*  HrDeleteRows()
 *      Delete a row in the table.
 *  ulFlags
 *      TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *                     lpSRowSet is ignored in this case.
 *  lpSRowSet
 *      Each row in the row set contains all the properties for one row
 *      in the table.  One of the properties must be the index column.  Any
 *      row in the table with the same value for its index column is
 *      deleted.
 *      Each row in LPSRowSet MUST have a unique Index column!
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */
#define TAD_ALL_ROWS    1

/*  HrDeleteRow()
 *      Delete a row in the table.
 *  lpSPropValue
 *      This property value specifies the row which has this value
 *      for its index column
 */

/*  HrQueryRow()
 *      Returns the values of a specified row in the table
 *  lpSPropValue
 *      This property value specifies the row which has this value
 *      for its index column
 *  lppSRow
 *      Address of where to return a pointer to an SRow
 *  lpuliRow
 *    Address of where to return the row number. This can be NULL
 *    if the row number is not required.
 *
 */

/*  HrEnumRow()
 *      Returns the values of a specific (numbered) row in the table
 *  ulRowNumber
 *      Indicates row number 0 to n-1
 *  lppSRow
 *      Address of where to return a pointer to a SRow
 */

/*  HrInsertRow()
 *      Inserts a row into the table.
 *  uliRow
 *      The row number before which this row will be inserted into the table.
 *      Row numbers can be from 0 to n where o to n-1 result in row insertion
 *    a row number of n results in the row being appended to the table.
 *  lpSRow
 *      This row contains all the properties for one row in the table.
 *      One of the properties must be the index column.  Any row in
 *      the table with the same value for its index column is
 *      replaced, or if there is no current row with that value the
 *      row is added
 *      If any views are open, the view is updated as well.
 *      The properties do not have to be in the same order as the
 *      columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)                                   \
    MAPIMETHOD(HrSetObjAccess)                                          \
        (THIS_  ULONG                       ulAccess) IPURE;            \
    MAPIMETHOD(HrSetPropAccess)                                         \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG FAR *                 rgulAccess) IPURE;          \
    MAPIMETHOD(HrGetPropAccess)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTagArray,            \
                ULONG FAR * FAR *           lprgulAccess) IPURE;        \
    MAPIMETHOD(HrAddObjProps)                                           \
        (THIS_  LPSPropTagArray             lppPropTagArray,            \
                LPSPropProblemArray FAR *   lprgulAccess) IPURE;


#undef       INTERFACE
#define      INTERFACE  IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*  CreateIProp()
 *      Creates the internal memory structures and object handle
 *      to bring a new property interface into existance.
 *
 *  lpInterface
 *      Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *  lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *      Function addresses are provided by the caller so that
 *      this DLL allocates/frees memory appropriately.
 *  lppPropData
 *      Address of the pointer which will receive the IPropData object
 *  lpvReserved
 *      Reserved.  Should be NULL.
 */

STDAPI_(SCODE)
CreateIProp( LPCIID                 lpInterface,
             ALLOCATEBUFFER FAR *   lpAllocateBuffer,
             ALLOCATEMORE FAR *     lpAllocateMore,
             FREEBUFFER FAR *       lpFreeBuffer,
             LPVOID                 lpvReserved,
             LPPROPDATA FAR *       lppPropData );

/*
 *  Defines for prop/obj access
 */
#define IPROP_READONLY      ((ULONG) 0x00000001)
#define IPROP_READWRITE     ((ULONG) 0x00000002)
#define IPROP_CLEAN         ((ULONG) 0x00010000)
#define IPROP_DIRTY         ((ULONG) 0x00020000)

/*
 -  HrSetPropAccess
 -
 *  Sets access right attributes on a per-property basis.  By default,
 *  all properties are read/write.
 *
 */

/*
 -  HrSetObjAccess
 -
 *  Sets access rights for the object itself.  By default, the object has
 *  read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *  PRI
 *
 *  Priority of an idle task.
 *  The idle engine sorts tasks by priority, and the one with the higher
 *  value runs first. Within a priority level, the functions are called
 *  round-robin.
 */

#define PRILOWEST   -32768
#define PRIHIGHEST  32767
#define PRIUSER     0

/*
 *  IRO
 *
 *  Idle routine options.  This is a combined bit mask consisting of
 *  individual firo's.  Listed below are the possible bit flags.
 *
 *      FIROWAIT and FIROINTERVAL are mutually exclusive.
 *      If neither of the flags are specified, the default action
 *      is to ignore the time parameter of the idle function and
 *      call it as often as possible if firoPerBlock is not set;
 *      otherwise call it one time only during the idle block
 *      once the time constraint has been set. FIROINTERVAL
 *      is also incompatible with FIROPERBLOCK.
 *
 *      FIROWAIT        - time given is minimum idle time before calling
 *                        for the first time in the block of idle time,
 *                        afterwhich call as often as possible.
 *      FIROINTERVAL    - time given is minimum interval between each
 *                        successive call
 *      FIROPERBLOCK    - called only once per contiguous block of idle
 *                        time
 *      FIRODISABLED    - initially disabled when registered, the
 *                        default is to enable the function when registered.
 *      FIROONCEONLY    - called only one time by the scheduler and then
 *                        deregistered automatically.
 */

#define IRONULL         ((USHORT) 0x0000)
#define FIROWAIT        ((USHORT) 0x0001)
#define FIROINTERVAL    ((USHORT) 0x0002)
#define FIROPERBLOCK    ((USHORT) 0x0004)
#define FIRODISABLED    ((USHORT) 0x0020)
#define FIROONCEONLY    ((USHORT) 0x0040)

/*
 *  IRC
 *
 *  Idle routine change options. This is a combined bit mask consisting
 *  of individual firc's; each one identifies an aspect of the idle task
 *  that can be changed.
 *
 */

#define IRCNULL         ((USHORT) 0x0000)
#define FIRCPFN         ((USHORT) 0x0001)   /* change function pointer */
#define FIRCPV          ((USHORT) 0x0002)   /* change parameter block  */
#define FIRCPRI         ((USHORT) 0x0004)   /* change priority         */
#define FIRCCSEC        ((USHORT) 0x0008)   /* change time             */
#define FIRCIRO         ((USHORT) 0x0010)   /* change routine options  */

/*
 *  Type definition for idle functions.  An idle function takes one
 *  parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *  FTG
 *
 *  Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL         ((FTG) NULL)

/*
 -  MAPIInitIdle/MAPIDeinitIdle
 -
 *  Purpose:
 *      Initialises the idle engine
 *      If the initialisation succeded, returns 0, else returns -1
 *
 *  Arguments:
 *      lpvReserved     Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *  FtgRegisterIdleRoutine
 *
 *      Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *      as an idle function.
 *
 *      The idle function will be called with the parameter pv by the
 *      idle engine. The function has initial priority priIdle,
 *      associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
    short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *  DeregisterIdleRoutine
 *
 *      Removes the given routine from the list of idle routines.
 *      The routine will not be called again.  It is the responsibility
 *      of the caller to clean up any data structures pointed to by the
 *      pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *  EnableIdleRoutine
 *
 *      Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *  ChangeIdleRoutine
 *
 *      Changes some or all of the characteristics of the given idle
 *      function. The changes to make are indicated with flags in the
 *      ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
    short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif  /* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *  Methods and #define's for implementing an OLE 2.0 storage stream
 *  (as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME  ((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    LPTSTR              lpszFileName,
    LPTSTR              lpszPrefix,
    LPSTREAM FAR *      lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
    LPALLOCATEBUFFER    lpAllocateBuffer,
    LPFREEBUFFER        lpFreeBuffer,
    ULONG               ulFlags,
    LPTSTR              lpszFileName,
    LPTSTR              lpszPrefix,
    LPSTREAM FAR *      lppStream);

#ifdef  _WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef  WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *  Copies a single SPropValue from Src to Dest.  Handles all the various
 *  types of properties and will link its allocations given the master
 *  allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue      lpSPropValueDest,
              LPSPropValue      lpSPropValueSrc,
              ALLOCATEMORE *    lpfAllocMore,
              LPVOID            lpvObject );

/*
 *  Returns the size in bytes of structure at lpSPropValue, including the
 *  Value.
 */
STDAPI_(ULONG)
UlPropSize( LPSPropValue    lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern char rgchCsds[];
extern char rgchCids[];
extern char rgchCsdi[];
extern char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue lpSPropValueDst,
                   LPSPropValue lpSPropValueSrc,
                   ULONG        ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue  lpSPropValue1,
                  ULONG         ulRelOp,
                  LPSPropValue  lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue  lpSPropValueA,
                  LPSPropValue  lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(   LPMAPITABLE         lptbl,
                LPSPropTagArray     lpproptagColumnsNew,
                LPALLOCATEBUFFER    lpAllocateBuffer,
                LPFREEBUFFER        lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx( LPMAPITABLE         lptbl,
                LPSPropTagArray     lpproptagColumnsNew,
                LPALLOCATEBUFFER    lpAllocateBuffer,
                LPFREEBUFFER        lpFreeBuffer,
                void                (FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *  Function that creates an advise sink object given a notification
 *  callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
                   LPVOID lpvContext,
                   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *  Wraps an existing advise sink with another one which guarantees
 *  that the original advise sink will be called in the thread on
 *  which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
                        LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *  Allows a client and/or provider to force notifications
 *  which are currently queued in the MAPI notification engine
 *  to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *  Structures and utility function for building a display table
 *  from resources.
 */

typedef struct {
    ULONG           ulCtlType;          /* DTCT_LABEL, etc. */
    ULONG           ulCtlFlags;         /* DT_REQUIRED, etc. */
    LPBYTE          lpbNotif;           /*  pointer to notification data */
    ULONG           cbNotif;            /* count of bytes of notification data */
    LPTSTR          lpszFilter;         /* character filter for edit/combobox */
    ULONG           ulItemID;           /* to validate parallel dlg template entry */
    union {                             /* ulCtlType discriminates */
        LPVOID          lpv;            /* Initialize this to avoid warnings */
        LPDTBLLABEL     lplabel;
        LPDTBLEDIT      lpedit;
        LPDTBLLBX       lplbx;
        LPDTBLCOMBOBOX  lpcombobox;
        LPDTBLDDLBX     lpddlbx;
        LPDTBLCHECKBOX  lpcheckbox;
        LPDTBLGROUPBOX  lpgroupbox;
        LPDTBLBUTTON    lpbutton;
        LPDTBLRADIOBUTTON lpradiobutton;
        LPDTBLMVLISTBOX lpmvlbx;
        LPDTBLMVDDLBX   lpmvddlbx;
        LPDTBLPAGE      lppage;
    } ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
    ULONG           cctl;
    LPTSTR          lpszResourceName;   /* as usual, may be an integer ID */
    union {                             /* as usual, may be an integer ID */
        LPTSTR          lpszComponent;
        ULONG           ulItemID;
    };
    LPDTCTL         lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(  LPALLOCATEBUFFER    lpAllocateBuffer,
                    LPALLOCATEMORE      lpAllocateMore,
                    LPFREEBUFFER        lpFreeBuffer,
                    LPMALLOC            lpMalloc,
                    HINSTANCE           hInstance,
                    UINT                cPages,
                    LPDTPAGE            lpPage,
                    ULONG               ulFlags,
                    LPMAPITABLE *       lppTable,
                    LPTABLEDATA *       lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *  Validate, copy, and adjust pointers in MAPI structures:
 *      notification
 *      property value array
 *      option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
        ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
        LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
        LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
        ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
        LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
        LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)          UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)          UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI                  HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
                        LPSPropValue FAR *lppProp);
STDAPI                  HrSetOneProp(LPMAPIPROP lpMapiProp,
                        LPSPropValue lpProp);
STDAPI_(BOOL)           FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)   PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
                        ULONG ulPropTag);
STDAPI_(void)           FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)           FreeProws(LPSRowSet lpRows);
STDAPI                  HrQueryAllRows(LPMAPITABLE lpTable, 
                        LPSPropTagArray lpPropTags,
                        LPSRestriction lpRestriction,
                        LPSSortOrderSet lpSortOrderSet,
                        LONG crowsMax,
                        LPSRowSet FAR *lppRows);

/* Create or validate the IPM folder tree in a message store */

#define MAPI_FORCE_CREATE   1
#define MAPI_FULL_IPM_TREE  2

STDAPI                  HrValidateIPMSubtree(LPMDB lpMDB, ULONG ulFlags,
                        ULONG FAR *lpcValues, LPSPropValue FAR *lppValues,
                        LPMAPIERROR FAR *lpperr);

/* Encoding and decoding strings */

STDAPI_(BOOL)           FBinFromHex(LPTSTR lpsz, LPBYTE lpb);
STDAPI_(SCODE)          ScBinFromHexBounded(LPTSTR lpsz, LPBYTE lpb, ULONG cb);
STDAPI_(void)           HexFromBin(LPBYTE lpb, int cb, LPTSTR lpsz);
STDAPI_(ULONG)          UlFromSzHex(LPCTSTR lpsz);

/* Encoding and decoding entry IDs */
STDAPI                  HrEntryIDFromSz(LPTSTR lpsz, ULONG FAR *lpcb,
                        LPENTRYID FAR *lppEntryID);
STDAPI                  HrSzFromEntryID(ULONG cb, LPENTRYID lpEntryID,
                        LPTSTR FAR *lpsz);
STDAPI                  HrComposeEID(LPMAPISESSION lpSession,
                        ULONG cbStoreRecordKey, LPBYTE lpStoreRecordKey,
                        ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
                        ULONG FAR *lpcbEID, LPENTRYID FAR *lppEntryID);
STDAPI                  HrDecomposeEID(LPMAPISESSION lpSession,
                        ULONG cbEntryID, LPENTRYID lpEntryID,
                        ULONG FAR *lpcbStoreEntryID,
                        LPENTRYID FAR *lppStoreEntryID,
                        ULONG FAR *lpcbMsgEntryID,
                        LPENTRYID FAR *lppMsgEntryID);
STDAPI                  HrComposeMsgID(LPMAPISESSION lpSession,
                        ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
                        ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
                        LPTSTR FAR *lpszMsgID);
STDAPI                  HrDecomposeMsgID(LPMAPISESSION lpSession,
                        LPTSTR lpszMsgID,
                        ULONG FAR *lpcbStoreEntryID,
                        LPENTRYID FAR *lppStoreEntryID,
                        ULONG FAR *lppcbMsgEntryID,
                        LPENTRYID FAR *lppMsgEntryID);

/* C runtime substitutes */


STDAPI_(LPTSTR)         SzFindCh(LPCTSTR lpsz, USHORT ch);      /* strchr */
STDAPI_(LPTSTR)         SzFindLastCh(LPCTSTR lpsz, USHORT ch);  /* strrchr */
STDAPI_(LPTSTR)         SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)   UFromSz(LPCTSTR lpsz);                  /* atoi */

STDAPI_(SCODE)          ScUNCFromLocalPath(LPSTR lpszLocal, LPSTR lpszUNC,
                        UINT cchUNC);
STDAPI_(SCODE)          ScLocalPathFromUNC(LPSTR lpszUNC, LPSTR lpszLocal,
                        UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)       FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)       FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)       FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)       FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)       FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)          ScCreateConversationIndex (ULONG cbParent,
                            LPBYTE lpbParent,
                            ULONG FAR * lpcbConvIndex,
                            LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR lpszDLLName, ULONG cbOrigEntry,
    LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED    ((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED   ((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF  ((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
        ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
    LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup. 
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)          ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)           DeinitMapiUtil(VOID);


/*
 *  Entry point names.
 *  
 *  These are for new entry points defined since MAPI first shipped
 *  in Windows 95. Using these names in a GetProcAddress call makes
 *  it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
    LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _MAPIUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapival.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I V A L . H
 *  
 *  Macros used to validate parameters on standard MAPI object methods.
 *  Used in conjunction with routines found in MAPIU.DLL.
 *  
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _INC_VALIDATE
#define _INC_VALIDATE

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIUTIL_H
#include    <mapiutil.h>
#endif
#include    <stddef.h>
#include    <stdarg.h>


#define MAKE_ENUM(Method, Interface)    Interface##_##Method

typedef enum _tagMethods
{
/* IUnknown */
    MAKE_ENUM(QueryInterface, IUnknown) = 0,
    MAKE_ENUM(AddRef, IUnknown),            /* For completness */
    MAKE_ENUM(Release, IUnknown),           /* For completness */
    
/* IMAPIProps */
    MAKE_ENUM(GetLastError, IMAPIProp),
    MAKE_ENUM(SaveChanges, IMAPIProp),
    MAKE_ENUM(GetProps, IMAPIProp),
    MAKE_ENUM(GetPropList, IMAPIProp),
    MAKE_ENUM(OpenProperty, IMAPIProp),
    MAKE_ENUM(SetProps, IMAPIProp),
    MAKE_ENUM(DeleteProps, IMAPIProp),
    MAKE_ENUM(CopyTo, IMAPIProp),
    MAKE_ENUM(CopyProps, IMAPIProp),
    MAKE_ENUM(GetNamesFromIDs, IMAPIProp),
    MAKE_ENUM(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
    MAKE_ENUM(GetLastError, IMAPITable),
    MAKE_ENUM(Advise, IMAPITable),
    MAKE_ENUM(Unadvise, IMAPITable),
    MAKE_ENUM(GetStatus, IMAPITable),
    MAKE_ENUM(SetColumns, IMAPITable),
    MAKE_ENUM(QueryColumns, IMAPITable),
    MAKE_ENUM(GetRowCount, IMAPITable),
    MAKE_ENUM(SeekRow, IMAPITable),
    MAKE_ENUM(SeekRowApprox, IMAPITable),
    MAKE_ENUM(QueryPosition, IMAPITable),
    MAKE_ENUM(FindRow, IMAPITable),
    MAKE_ENUM(Restrict, IMAPITable),
    MAKE_ENUM(CreateBookmark, IMAPITable),
    MAKE_ENUM(FreeBookmark, IMAPITable),
    MAKE_ENUM(SortTable, IMAPITable),
    MAKE_ENUM(QuerySortOrder, IMAPITable),
    MAKE_ENUM(QueryRows, IMAPITable),
    MAKE_ENUM(Abort, IMAPITable),
    MAKE_ENUM(ExpandRow, IMAPITable),
    MAKE_ENUM(CollapseRow, IMAPITable),
    MAKE_ENUM(WaitForCompletion, IMAPITable),
    MAKE_ENUM(GetCollapseState, IMAPITable),
    MAKE_ENUM(SetCollapseState, IMAPITable),

/* IMAPIContainer */
    MAKE_ENUM(GetContentsTable, IMAPIContainer),
    MAKE_ENUM(GetHierarchyTable, IMAPIContainer),
    MAKE_ENUM(OpenEntry, IMAPIContainer),
    MAKE_ENUM(SetSearchCriteria, IMAPIContainer),
    MAKE_ENUM(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
    MAKE_ENUM(CreateEntry, IABContainer),
    MAKE_ENUM(CopyEntries, IABContainer),
    MAKE_ENUM(DeleteEntries, IABContainer),
    MAKE_ENUM(ResolveNames, IABContainer),

/* IDistList */
    MAKE_ENUM(CreateEntry, IDistList),
    MAKE_ENUM(CopyEntries, IDistList),
    MAKE_ENUM(DeleteEntries, IDistList),
    MAKE_ENUM(ResolveNames, IDistList),

/* IMAPIFolder */
    MAKE_ENUM(CreateMessage, IMAPIFolder),
    MAKE_ENUM(CopyMessages, IMAPIFolder),
    MAKE_ENUM(DeleteMessages, IMAPIFolder),
    MAKE_ENUM(CreateFolder, IMAPIFolder),
    MAKE_ENUM(CopyFolder, IMAPIFolder),
    MAKE_ENUM(DeleteFolder, IMAPIFolder),
    MAKE_ENUM(SetReadFlags, IMAPIFolder),
    MAKE_ENUM(GetMessageStatus, IMAPIFolder),
    MAKE_ENUM(SetMessageStatus, IMAPIFolder),
    MAKE_ENUM(SaveContentsSort, IMAPIFolder),
    MAKE_ENUM(EmptyFolder, IMAPIFolder),

/* IMsgStore */
    MAKE_ENUM(Advise, IMsgStore),
    MAKE_ENUM(Unadvise, IMsgStore),
    MAKE_ENUM(CompareEntryIDs, IMsgStore),
    MAKE_ENUM(OpenEntry, IMsgStore),
    MAKE_ENUM(SetReceiveFolder, IMsgStore),
    MAKE_ENUM(GetReceiveFolder, IMsgStore),
    MAKE_ENUM(GetReceiveFolderTable, IMsgStore),
    MAKE_ENUM(StoreLogoff, IMsgStore),
    MAKE_ENUM(AbortSubmit, IMsgStore),
    MAKE_ENUM(GetOutgoingQueue, IMsgStore),
    MAKE_ENUM(SetLockState, IMsgStore),
    MAKE_ENUM(FinishedMsg, IMsgStore),
    MAKE_ENUM(NotifyNewMail, IMsgStore),

/* IMessage */
    MAKE_ENUM(GetAttachmentTable, IMessage),
    MAKE_ENUM(OpenAttach, IMessage),
    MAKE_ENUM(CreateAttach, IMessage),
    MAKE_ENUM(DeleteAttach, IMessage),
    MAKE_ENUM(GetRecipientTable, IMessage),
    MAKE_ENUM(ModifyRecipients, IMessage),
    MAKE_ENUM(SubmitMessage, IMessage),
    MAKE_ENUM(SetReadFlag, IMessage),


/* IABProvider */
    MAKE_ENUM(Shutdown, IABProvider),
    MAKE_ENUM(Logon, IABProvider),

/* IABLogon */
    MAKE_ENUM(GetLastError, IABLogon),
    MAKE_ENUM(Logoff, IABLogon),
    MAKE_ENUM(OpenEntry, IABLogon),
    MAKE_ENUM(CompareEntryIDs, IABLogon),
    MAKE_ENUM(Advise, IABLogon),
    MAKE_ENUM(Unadvise, IABLogon),
    MAKE_ENUM(OpenStatusEntry, IABLogon),
    MAKE_ENUM(OpenTemplateID, IABLogon),
    MAKE_ENUM(GetOneOffTable, IABLogon),
    MAKE_ENUM(PrepareRecips, IABLogon),

/* IXPProvider */
    MAKE_ENUM(Shutdown, IXPProvider),
    MAKE_ENUM(TransportLogon, IXPProvider),

/* IXPLogon */
    MAKE_ENUM(AddressTypes, IXPLogon),
    MAKE_ENUM(RegisterOptions, IXPLogon),
    MAKE_ENUM(TransportNotify, IXPLogon),
    MAKE_ENUM(Idle, IXPLogon),
    MAKE_ENUM(TransportLogoff, IXPLogon),
    MAKE_ENUM(SubmitMessage, IXPLogon),
    MAKE_ENUM(EndMessage, IXPLogon),
    MAKE_ENUM(Poll, IXPLogon),
    MAKE_ENUM(StartMessage, IXPLogon),
    MAKE_ENUM(OpenStatusEntry, IXPLogon),
    MAKE_ENUM(ValidateState, IXPLogon),
    MAKE_ENUM(FlushQueues, IXPLogon),

/* IMSProvider */
    MAKE_ENUM(Shutdown, IMSProvider),
    MAKE_ENUM(Logon, IMSProvider),
    MAKE_ENUM(SpoolerLogon, IMSProvider),
    MAKE_ENUM(CompareStoreIDs, IMSProvider),

/* IMSLogon */
    MAKE_ENUM(GetLastError, IMSLogon),
    MAKE_ENUM(Logoff, IMSLogon),
    MAKE_ENUM(OpenEntry, IMSLogon),
    MAKE_ENUM(CompareEntryIDs, IMSLogon),
    MAKE_ENUM(Advise, IMSLogon),
    MAKE_ENUM(Unadvise, IMSLogon),
    MAKE_ENUM(OpenStatusEntry, IMSLogon),
    
/* IMAPIControl */
    MAKE_ENUM(GetLastError, IMAPIControl),
    MAKE_ENUM(Activate, IMAPIControl),
    MAKE_ENUM(GetState, IMAPIControl),
    
/* IMAPIStatus */
    MAKE_ENUM(ValidateState, IMAPIStatus),
    MAKE_ENUM(SettingsDialog, IMAPIStatus),
    MAKE_ENUM(ChangePassword, IMAPIStatus),
    MAKE_ENUM(FlushQueues, IMAPIStatus),

/* IStream */
    MAKE_ENUM(Read, IStream),
    MAKE_ENUM(Write, IStream),
    MAKE_ENUM(Seek, IStream),
    MAKE_ENUM(SetSize, IStream),
    MAKE_ENUM(CopyTo, IStream),
    MAKE_ENUM(Commit, IStream),
    MAKE_ENUM(Revert, IStream),
    MAKE_ENUM(LockRegion, IStream),
    MAKE_ENUM(UnlockRegion, IStream),
    MAKE_ENUM(Stat, IStream),
    MAKE_ENUM(Clone, IStream),

/* IMAPIAdviseSink */
    MAKE_ENUM(OnNotify, IMAPIAdviseSink),

} METHODS;


/* Macro wrappers to hide the Validate function return handling */
#if defined(_X86_) || defined( WIN16 )
#ifdef __cplusplus

/* C++ methods can't take the address of the This pointer, so we must
   use the first parameter instead */

#define ValidateParameters(eMethod, First)              \
        {   HRESULT   _hr_;                             \
            _hr_ = __CPPValidateParameters(eMethod, (LPVOID) &First);   \
            if (HR_FAILED(_hr_)) return (_hr_); }

#define UlValidateParameters(eMethod, First)                \
        {   HRESULT   _hr_;                             \
            _hr_ = __CPPValidateParameters(eMethod, &First);    \
            if (HR_FAILED(_hr_)) return (ULONG) (_hr_); }

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, First)             \
        AssertSz(HR_SUCCEEDED(__CPPValidateParameters(eMethod, &First)), "Parameter validation failed for method called by MAPI!")


#else /* __cplusplus */

/* For methods that will be called by clients 
   - validate always */
   
#define ValidateParameters(eMethod, ppThis)             \
        {   HRESULT   _hr_;                             \
            _hr_ = __ValidateParameters(eMethod, ppThis);   \
            if (HR_FAILED(_hr_)) return (_hr_); }

#define UlValidateParameters(eMethod, ppThis)               \
        {   HRESULT   _hr_;                             \
            _hr_ = __ValidateParameters(eMethod, ppThis);   \
            if (HR_FAILED(_hr_)) return (ULONG) (_hr_); }

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, ppThis)                \
        AssertSz(HR_SUCCEEDED(__ValidateParameters(eMethod, ppThis)), "Parameter validation failed for method called by MAPI!")

#endif /* __cplusplus */
#endif /* _X86_ || WIN16 */

/* Prototypes for functions used to validate complex parameters.
 */
#define FBadPropVal( lpPropVal) (FAILED(ScCountProps( 1, lpPropVal, NULL)))

#define FBadRgPropVal( lpPropVal, cValues) \
        (FAILED(ScCountProps( cValues, lpPropVal, NULL)))

#define FBadAdrList( lpAdrList) \
        (   AssertSz(   (   offsetof( ADRLIST, cEntries) \
                         == offsetof( SRowSet, cRows)) \
                     && (   offsetof( ADRLIST, aEntries) \
                         == offsetof( SRowSet, aRow)) \
                     && (   offsetof( ADRENTRY, cValues) \
                         == offsetof( SRow, cValues)) \
                     && (   offsetof( ADRENTRY, rgPropVals) \
                         == offsetof( SRow, lpProps)) \
                    , "ADRLIST doesn't match SRowSet") \
         || FBadRowSet( (LPSRowSet) lpAdrList))

STDAPI_(BOOL)
FBadRglpszW( LPWSTR FAR *lppszW,
             ULONG      cStrings);

STDAPI_(BOOL)
FBadRowSet( LPSRowSet   lpRowSet);

STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *  lppNameId,
                ULONG               cNames);

STDAPI_(BOOL)
FBadEntryList( LPENTRYLIST  lpEntryList);


/* BAD_STANDARD_OBJ
 *
 * This macro insures that the object is a writable object of the correct size
 * and that this method belongs to the object.
 *
 * NOTES ON USE!
 *  This depends upon using the standard method of declaring the object
 *  interface.
 *
 *  prefix is the method prefix you chose when declaring the object interface.
 *  method is the standard method name of the calling method.
 *  lpVtbl is the name of the lpVtbl element of your object.
 */
#define BAD_STANDARD_OBJ( lpObj, prefix, method, lpVtbl) \
    (   IsBadWritePtr( (lpObj), sizeof(*lpObj)) \
     || IsBadReadPtr( (void *) &(lpObj->lpVtbl->method), sizeof(LPVOID)) \
     ||( ( LPVOID) (lpObj->lpVtbl->method) != (LPVOID) (prefix##method)))


#define FBadUnknown( lpObj ) \
    (   IsBadReadPtr( (lpObj), sizeof(LPVOID) ) \
     || IsBadReadPtr( (lpObj)->lpVtbl, 3 * sizeof(LPUNKNOWN) ) \
     || IsBadCodePtr( (FARPROC)(lpObj)->lpVtbl->QueryInterface ))

/*
 * IUnknown
 */


/*
 * QueryInterface
 */
#define FBadQueryInterface( lpObj, riid, ppvObj)    \
    (   IsBadReadPtr( riid, sizeof(IID)) \
     || IsBadWritePtr( ppvObj, sizeof(LPVOID)))


/*
 * AddRef
 *  No parameter validation required.
 */
#define FBadAddRef( lpObj)  FALSE


/*
 * Release
 *  No parameter validation required.
 */
#define FBadRelease( lpObj) FALSE


/*
 * GetLastError
 */
#define FBadGetLastError( lpObj, hResult, ulFlags, lppMAPIError )\
    (IsBadWritePtr( lppMAPIError, sizeof(LPMAPIERROR)))

/*
 * IMAPIProp
 */


/*
 * SaveChanges
 *  No parameter validation required.
 */
#define FBadSaveChanges( lpObj, ulFlags)    FALSE


/*
 * GetProps
 */
#define FBadGetProps( lpObj, lpPTagA, lpcValues, lppPropArray) \
    (   (   lpPTagA \
         && (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
             || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
                                              * sizeof(ULONG))))) \
     || IsBadWritePtr( lpcValues, sizeof(ULONG)) \
     || IsBadWritePtr( lppPropArray, sizeof(LPSPropValue)))


/*
 * GetPropList
 */
#define FBadGetPropList( lpObj, lppPTagA) \
    (IsBadWritePtr( lppPTagA, sizeof(LPSPropTagArray FAR *)))


/*
 * OpenProperty
 */
#define FBadOpenProperty( lpObj, ulPropTag, lpiid, ulInterfaceOptions, ulFlags \
                        , lppUnk) \
    (   IsBadReadPtr( lpiid, sizeof(IID)) \
     || IsBadWritePtr( lppUnk, sizeof (LPUNKNOWN FAR *)))


/*
 * SetProps
 */
#define FBadSetProps( lpObj, cValues, lpPropArray, lppProblems) \
    (   FBadRgPropVal( lpPropArray, (UINT) cValues) \
     || (   lppProblems \
         && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * DeleteProps
 */
#define FBadDeleteProps( lpObj, lpPTagA, lppProblems) \
    (   (   !lpPTagA \
         || (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
             || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
                                              * sizeof(ULONG))))) \
     || (   lppProblems \
         && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyTo
 */
#define FBadCopyTo( lpIPDAT, ciidExclude, rgiidExclude, lpExcludeProps \
                  , ulUIParam, lpProgress, lpInterface, lpDestObj \
                  , ulFlags, lppProblems) \
    (   (   ciidExclude \
         && (  IsBadReadPtr( rgiidExclude, (UINT)(ciidExclude * sizeof(IID))))) \
     || (   lpExcludeProps \
         && (   IsBadReadPtr( lpExcludeProps, sizeof(ULONG)) \
             || IsBadReadPtr( lpExcludeProps \
                            , (UINT)(  (lpExcludeProps->cValues + 1) \
                                     * sizeof(ULONG))))) \
     || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
     || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
     || (   lppProblems \
         && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyProps
 */
#define FBadCopyProps( lpIPDAT, lpPropTagArray \
                     , ulUIParam, lpProgress, lpInterface, lpDestObj \
                     , ulFlags, lppProblems) \
    (   (   lpPropTagArray \
         && (   IsBadReadPtr( lpPropTagArray, sizeof(ULONG)) \
             || IsBadReadPtr( lpPropTagArray \
                            , (UINT)(  (lpPropTagArray->cValues + 1) \
                                     * sizeof(ULONG))))) \
     || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
     || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
     || (   lppProblems \
         && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))



/*
 * GetNamesFromIDs
 */
#define FBadGetNamesFromIDs( lpIPDAT, lppPropTags, lpPropSetGuid, ulFlags, \
                             lpcPropNames, lpppPropNames) \
    (   IsBadReadPtr( lppPropTags, sizeof(LPSPropTagArray)) \
     || ( lpPropSetGuid && IsBadReadPtr( lpPropSetGuid, sizeof(GUID))) \
     || (   *lppPropTags \
         && (   IsBadReadPtr( *lppPropTags, sizeof(ULONG)) \
             || IsBadReadPtr( *lppPropTags \
                            , (UINT)( ( ( *lppPropTags)->cValues + 1) \
                                     * sizeof(ULONG))))) \
     || IsBadWritePtr( lpcPropNames, sizeof (ULONG)) \
     || IsBadWritePtr( lpppPropNames, sizeof (LPVOID FAR *)))



/*
 * GetNamesFromIDs
 */
#define FBadGetIDsFromNames( lpIPDAT, cPropNames, lppPropNames, ulFlags \
                           , lppPropTags) \
    (   (cPropNames && FBadRglpNameID( lppPropNames, cPropNames)) \
     || IsBadWritePtr( lppPropTags, sizeof(LPULONG FAR *)))


STDAPI_(ULONG)
FBadRestriction( LPSRestriction lpres );

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag );

STDAPI_(ULONG)
FBadRow( LPSRow lprow );

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop );

STDAPI_(ULONG)
FBadSortOrderSet( LPSSortOrderSet lpsos );

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols );

/* Validation function

    The eMethod parameter tells us which internal validation to perform.
    
    The ppThis parameter tells us where the stack is, so we can access the other 
    parameters.  
    
    Becuase of this *magic* we MUST obtain the pointer to the This pointer in 
    the method function.
    
*/

#ifdef WIN16
#define BASED_STACK         __based(__segname("_STACK"))
#else
#define BASED_STACK
#endif


#ifdef WIN16
HRESULT  PASCAL
#else
HRESULT  STDAPICALLTYPE     
#endif
__CPPValidateParameters(METHODS eMethod, const LPVOID ppFirst);

#ifdef WIN16
HRESULT  PASCAL
#else
HRESULT  STDAPICALLTYPE     
#endif
__ValidateParameters(METHODS eMethod, LPVOID ppThis);

#ifdef _MAC
#define STDAPIVCALLTYPE         __cdecl
#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE
#endif /* _MAC */

/* Macro wrappers for platform independent validation */

#if defined(_X86_) || defined( WIN16 )
#define ValidateParms(x)    { HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)  { HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x)       AssertSz(HR_SUCCEEDED( HrValidateParameters x), "Parameter validation failed for method called by MAPI!")
#else
#define ValidateParms(x)    { HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)  { HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x)       AssertSz(HR_SUCCEEDED( HrValidateParametersV x ), "Parameter validation failed for method called by MAPI!")
#endif

#if defined(_X86_) || defined( WIN16 )

#define ValidateParameters1( m, a1 ) 
#define ValidateParameters2( m, a1, a2 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters3( m, a1, a2, a3 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
            ValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define UlValidateParameters1( m, a1 ) 
#define UlValidateParameters2( m, a1, a2 )  \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters3( m, a1, a2, a3 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
            UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define CheckParameters1( m, a1 ) 
#define CheckParameters2( m, a1, a2 )   \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters3( m, a1, a2, a3)    \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters4( m, a1, a2, a3, a4 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
            CheckParms( ( m, (LPVOID FAR *) &a2 ) )

#else /* !_X86_  && !WIN16 */

#define ValidateParameters1( m, a1 ) \
            ValidateParms( ( m, a1 ) )
#define ValidateParameters2( m, a1, a2 )    \
            ValidateParms( ( m, a1, a2 ))
#define ValidateParameters3( m, a1, a2, a3 )    \
            ValidateParms( ( m, a1, a2, a3 ))
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
            ValidateParms( ( m, a1, a2, a3, a4 ))
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
            ValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
            ValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
            ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
            ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
            ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
            ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define UlValidateParameters1( m, a1 ) \
            UlValidateParms( ( m, a1 ) )
#define UlValidateParameters2( m, a1, a2 )  \
            UlValidateParms( ( m, a1, a2 ))
#define UlValidateParameters3( m, a1, a2, a3 )  \
            UlValidateParms( ( m, a1, a2, a3 ))
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
            UlValidateParms( ( m, a1, a2, a3, a4 ))
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
            UlValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
            UlValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
            UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
            UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
            UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
            UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define CheckParameters1( m, a1 ) \
            CheckParms( ( m, a1 ) )
#define CheckParameters2( m, a1, a2 )   \
            CheckParms( ( m, a1, a2 ))
#define CheckParameters3( m, a1, a2, a3 )   \
            CheckParms( ( m, a1, a2, a3 ))
#define CheckParameters4( m, a1, a2, a3, a4 ) \
            CheckParms( ( m, a1, a2, a3, a4 ))
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
            CheckParms( ( m, a1, a2, a3, a4, a5 ))
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
            CheckParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
            CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
            CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
            CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
            CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#endif /* _X86_ || WIN16 */


/*
 *      M A P I    P A R A M E T E R   V A L I D A T I O N    M A C R O S
 */


/* IUnknown */

#define Validate_IUnknown_QueryInterface( a1, a2, a3 ) \
             ValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define UlValidate_IUnknown_QueryInterface( a1, a2, a3 ) \
             UlValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define CheckParameters_IUnknown_QueryInterface( a1, a2, a3 ) \
             CheckParameters3( IUnknown_QueryInterface, a1, a2, a3 )

#define Validate_IUnknown_AddRef( a1 ) \
             ValidateParameters1( IUnknown_AddRef, a1 )
#define UlValidate_IUnknown_AddRef( a1 ) \
             UlValidateParameters1( IUnknown_AddRef, a1 )
#define CheckParameters_IUnknown_AddRef( a1 ) \
             CheckParameters1( IUnknown_AddRef, a1 )

#define Validate_IUnknown_Release( a1 ) \
             ValidateParameters1( IUnknown_Release, a1 )
#define UlValidate_IUnknown_Release( a1 ) \
             UlValidateParameters1( IUnknown_Release, a1 )
#define CheckParameters_IUnknown_Release( a1 ) \
             CheckParameters1( IUnknown_Release, a1 )


/* IMAPIProp */

#define Validate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIProp_SaveChanges( a1, a2 ) \
             ValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define UlValidate_IMAPIProp_SaveChanges( a1, a2 ) \
             UlValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define CheckParameters_IMAPIProp_SaveChanges( a1, a2 ) \
             CheckParameters2( IMAPIProp_SaveChanges, a1, a2 )

#define Validate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )

#define Validate_IMAPIProp_GetPropList( a1, a2, a3 ) \
             ValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define UlValidate_IMAPIProp_GetPropList( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define CheckParameters_IMAPIProp_GetPropList( a1, a2, a3 ) \
             CheckParameters3( IMAPIProp_GetPropList, a1, a2, a3 )

#define Validate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )

#define Validate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
             ValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define UlValidate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define CheckParameters_IMAPIProp_DeleteProps( a1, a2, a3 ) \
             CheckParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )

#define Validate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
             ValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define UlValidate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
             UlValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
             CheckParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )

#define Validate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
             ValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
             UlValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
             CheckParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )


/* IMAPITable */

#define Validate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPITable_Advise( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_Advise( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_Advise( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_Advise, a1, a2, a3, a4 )

#define Validate_IMAPITable_Unadvise( a1, a2 ) \
             ValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define UlValidate_IMAPITable_Unadvise( a1, a2 ) \
             UlValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define CheckParameters_IMAPITable_Unadvise( a1, a2 ) \
             CheckParameters2( IMAPITable_Unadvise, a1, a2 )

#define Validate_IMAPITable_GetStatus( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define UlValidate_IMAPITable_GetStatus( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetStatus( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_GetStatus, a1, a2, a3 )

#define Validate_IMAPITable_SetColumns( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_SetColumns( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_SetColumns( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_SetColumns, a1, a2, a3 )

#define Validate_IMAPITable_QueryColumns( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_QueryColumns( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_QueryColumns( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_QueryColumns, a1, a2, a3 )

#define Validate_IMAPITable_GetRowCount( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define UlValidate_IMAPITable_GetRowCount( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetRowCount( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_GetRowCount, a1, a2, a3 )

#define Validate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define UlValidate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define CheckParameters_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )

#define Validate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )

#define Validate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_FindRow( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_Restrict( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define UlValidate_IMAPITable_Restrict( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define CheckParameters_IMAPITable_Restrict( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_Restrict, a1, a2, a3 )

#define Validate_IMAPITable_CreateBookmark( a1, a2 ) \
             ValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define UlValidate_IMAPITable_CreateBookmark( a1, a2 ) \
             UlValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define CheckParameters_IMAPITable_CreateBookmark( a1, a2 ) \
             CheckParameters2( IMAPITable_CreateBookmark, a1, a2 )

#define Validate_IMAPITable_FreeBookmark( a1, a2 ) \
             ValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define UlValidate_IMAPITable_FreeBookmark( a1, a2 ) \
             UlValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define CheckParameters_IMAPITable_FreeBookmark( a1, a2 ) \
             CheckParameters2( IMAPITable_FreeBookmark, a1, a2 )

#define Validate_IMAPITable_SortTable( a1, a2, a3 ) \
             ValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define UlValidate_IMAPITable_SortTable( a1, a2, a3 ) \
             UlValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define CheckParameters_IMAPITable_SortTable( a1, a2, a3 ) \
             CheckParameters3( IMAPITable_SortTable, a1, a2, a3 )

#define Validate_IMAPITable_QuerySortOrder( a1, a2 ) \
             ValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define UlValidate_IMAPITable_QuerySortOrder( a1, a2 ) \
             UlValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define CheckParameters_IMAPITable_QuerySortOrder( a1, a2 ) \
             CheckParameters2( IMAPITable_QuerySortOrder, a1, a2 )

#define Validate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )

#define Validate_IMAPITable_Abort( a1 ) \
             ValidateParameters1( IMAPITable_Abort, a1 )
#define UlValidate_IMAPITable_Abort( a1 ) \
             UlValidateParameters1( IMAPITable_Abort, a1 )
#define CheckParameters_IMAPITable_Abort( a1 ) \
             CheckParameters1( IMAPITable_Abort, a1 )

#define Validate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )

#define Validate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )

#define Validate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )


/* IMAPIContainer */

#define Validate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
             ValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
             CheckParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )

#define Validate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
             ValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
             CheckParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )

#define Validate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define UlValidate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define CheckParameters_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )

#define Validate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )


/* IABContainer */

#define Validate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_DeleteEntries( a1, a2, a3 ) \
             ValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define UlValidate_IABContainer_DeleteEntries( a1, a2, a3 ) \
             UlValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IABContainer_DeleteEntries( a1, a2, a3 ) \
             CheckParameters3( IABContainer_DeleteEntries, a1, a2, a3 )

#define Validate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )


/* IDistList */

#define Validate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IDistList_DeleteEntries( a1, a2, a3 ) \
             ValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define UlValidate_IDistList_DeleteEntries( a1, a2, a3 ) \
             UlValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IDistList_DeleteEntries( a1, a2, a3 ) \
             CheckParameters3( IDistList_DeleteEntries, a1, a2, a3 )

#define Validate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )


/* IMAPIFolder */

#define Validate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )

#define Validate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
             ValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
             UlValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
             CheckParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )

#define Validate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
             ValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define UlValidate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define CheckParameters_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
             CheckParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )

#define Validate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )


/* IMsgStore */

#define Validate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_Unadvise( a1, a2 ) \
             ValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define UlValidate_IMsgStore_Unadvise( a1, a2 ) \
             UlValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define CheckParameters_IMsgStore_Unadvise( a1, a2 ) \
             CheckParameters2( IMsgStore_Unadvise, a1, a2 )

#define Validate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define UlValidate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define CheckParameters_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )

#define Validate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
             ValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define UlValidate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
             UlValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
             CheckParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )

#define Validate_IMsgStore_StoreLogoff( a1, a2 ) \
             ValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define UlValidate_IMsgStore_StoreLogoff( a1, a2 ) \
             UlValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define CheckParameters_IMsgStore_StoreLogoff( a1, a2 ) \
             CheckParameters2( IMsgStore_StoreLogoff, a1, a2 )

#define Validate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
             ValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
             CheckParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )

#define Validate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
             ValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define UlValidate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
             UlValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
             CheckParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )

#define Validate_IMsgStore_SetLockState( a1, a2, a3 ) \
             ValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define UlValidate_IMsgStore_SetLockState( a1, a2, a3 ) \
             UlValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define CheckParameters_IMsgStore_SetLockState( a1, a2, a3 ) \
             CheckParameters3( IMsgStore_SetLockState, a1, a2, a3 )

#define Validate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
             ValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
             CheckParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )

#define Validate_IMsgStore_NotifyNewMail( a1, a2 ) \
             ValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define UlValidate_IMsgStore_NotifyNewMail( a1, a2 ) \
             UlValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define CheckParameters_IMsgStore_NotifyNewMail( a1, a2 ) \
             CheckParameters2( IMsgStore_NotifyNewMail, a1, a2 )


/* IMessage */

#define Validate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
             ValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define UlValidate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
             UlValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetAttachmentTable( a1, a2, a3 ) \
             CheckParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )

#define Validate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_GetRecipientTable( a1, a2, a3 ) \
             ValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define UlValidate_IMessage_GetRecipientTable( a1, a2, a3 ) \
             UlValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetRecipientTable( a1, a2, a3 ) \
             CheckParameters3( IMessage_GetRecipientTable, a1, a2, a3 )

#define Validate_IMessage_ModifyRecipients( a1, a2, a3 ) \
             ValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define UlValidate_IMessage_ModifyRecipients( a1, a2, a3 ) \
             UlValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define CheckParameters_IMessage_ModifyRecipients( a1, a2, a3 ) \
             CheckParameters3( IMessage_ModifyRecipients, a1, a2, a3 )

#define Validate_IMessage_SubmitMessage( a1, a2 ) \
             ValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define UlValidate_IMessage_SubmitMessage( a1, a2 ) \
             UlValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define CheckParameters_IMessage_SubmitMessage( a1, a2 ) \
             CheckParameters2( IMessage_SubmitMessage, a1, a2 )

#define Validate_IMessage_SetReadFlag( a1, a2 ) \
             ValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define UlValidate_IMessage_SetReadFlag( a1, a2 ) \
             UlValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define CheckParameters_IMessage_SetReadFlag( a1, a2 ) \
             CheckParameters2( IMessage_SetReadFlag, a1, a2 )


/* IABProvider */

#define Validate_IABProvider_Shutdown( a1, a2 ) \
             ValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define UlValidate_IABProvider_Shutdown( a1, a2 ) \
             UlValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define CheckParameters_IABProvider_Shutdown( a1, a2 ) \
             CheckParameters2( IABProvider_Shutdown, a1, a2 )

#define Validate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
             ValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
             UlValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
             CheckParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )


/* IABLogon */

#define Validate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
             ValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
             UlValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_GetLastError( a1, a2, a3, a4 ) \
             CheckParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IABLogon_Logoff( a1, a2 ) \
             ValidateParameters2( IABLogon_Logoff, a1, a2 )
#define UlValidate_IABLogon_Logoff( a1, a2 ) \
             UlValidateParameters2( IABLogon_Logoff, a1, a2 )
#define CheckParameters_IABLogon_Logoff( a1, a2 ) \
             CheckParameters2( IABLogon_Logoff, a1, a2 )

#define Validate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IABLogon_Unadvise( a1, a2 ) \
             ValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define UlValidate_IABLogon_Unadvise( a1, a2 ) \
             UlValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define CheckParameters_IABLogon_Unadvise( a1, a2 ) \
             CheckParameters2( IABLogon_Unadvise, a1, a2 )

#define Validate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
             ValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
             UlValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
             CheckParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
             ValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define UlValidate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
             UlValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define CheckParameters_IABLogon_GetOneOffTable( a1, a2, a3 ) \
             CheckParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )

#define Validate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
             ValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define UlValidate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
             UlValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
             CheckParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )


/* IXPProvider */

#define Validate_IXPProvider_Shutdown( a1, a2 ) \
             ValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define UlValidate_IXPProvider_Shutdown( a1, a2 ) \
             UlValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define CheckParameters_IXPProvider_Shutdown( a1, a2 ) \
             CheckParameters2( IXPProvider_Shutdown, a1, a2 )

#define Validate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )


/* IXPLogon */

#define Validate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )

#define Validate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
             ValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
             UlValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
             CheckParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )

#define Validate_IXPLogon_TransportNotify( a1, a2, a3 ) \
             ValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define UlValidate_IXPLogon_TransportNotify( a1, a2, a3 ) \
             UlValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define CheckParameters_IXPLogon_TransportNotify( a1, a2, a3 ) \
             CheckParameters3( IXPLogon_TransportNotify, a1, a2, a3 )

#define Validate_IXPLogon_Idle( a1, a2 ) \
             ValidateParameters2( IXPLogon_Idle, a1, a2 )
#define UlValidate_IXPLogon_Idle( a1, a2 ) \
             UlValidateParameters2( IXPLogon_Idle, a1, a2 )
#define CheckParameters_IXPLogon_Idle( a1, a2 ) \
             CheckParameters2( IXPLogon_Idle, a1, a2 )

#define Validate_IXPLogon_TransportLogoff( a1, a2 ) \
             ValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define UlValidate_IXPLogon_TransportLogoff( a1, a2 ) \
             UlValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define CheckParameters_IXPLogon_TransportLogoff( a1, a2 ) \
             CheckParameters2( IXPLogon_TransportLogoff, a1, a2 )

#define Validate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_EndMessage( a1, a2, a3 ) \
             ValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define UlValidate_IXPLogon_EndMessage( a1, a2, a3 ) \
             UlValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define CheckParameters_IXPLogon_EndMessage( a1, a2, a3 ) \
             CheckParameters3( IXPLogon_EndMessage, a1, a2, a3 )

#define Validate_IXPLogon_Poll( a1, a2 ) \
             ValidateParameters2( IXPLogon_Poll, a1, a2 )
#define UlValidate_IXPLogon_Poll( a1, a2 ) \
             UlValidateParameters2( IXPLogon_Poll, a1, a2 )
#define CheckParameters_IXPLogon_Poll( a1, a2 ) \
             CheckParameters2( IXPLogon_Poll, a1, a2 )

#define Validate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
             ValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
             UlValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
             CheckParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )

#define Validate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_ValidateState( a1, a2, a3 ) \
             ValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define UlValidate_IXPLogon_ValidateState( a1, a2, a3 ) \
             UlValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define CheckParameters_IXPLogon_ValidateState( a1, a2, a3 ) \
             CheckParameters3( IXPLogon_ValidateState, a1, a2, a3 )

#define Validate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )


/* IMSProvider */

#define Validate_IMSProvider_Shutdown( a1, a2 ) \
             ValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define UlValidate_IMSProvider_Shutdown( a1, a2 ) \
             UlValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define CheckParameters_IMSProvider_Shutdown( a1, a2 ) \
             CheckParameters2( IMSProvider_Shutdown, a1, a2 )

#define Validate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
             ValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
             UlValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
             CheckParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
             ValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
             UlValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
             CheckParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )


/* IMSLogon */

#define Validate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
             ValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
             CheckParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IMSLogon_Logoff( a1, a2 ) \
             ValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define UlValidate_IMSLogon_Logoff( a1, a2 ) \
             UlValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define CheckParameters_IMSLogon_Logoff( a1, a2 ) \
             CheckParameters2( IMSLogon_Logoff, a1, a2 )

#define Validate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             ValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             UlValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
             CheckParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
             ValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
             UlValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
             CheckParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMSLogon_Unadvise( a1, a2 ) \
             ValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define UlValidate_IMSLogon_Unadvise( a1, a2 ) \
             UlValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define CheckParameters_IMSLogon_Unadvise( a1, a2 ) \
             CheckParameters2( IMSLogon_Unadvise, a1, a2 )

#define Validate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )


/* IMAPIControl */

#define Validate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIControl_Activate( a1, a2, a3 ) \
             ValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define UlValidate_IMAPIControl_Activate( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define CheckParameters_IMAPIControl_Activate( a1, a2, a3 ) \
             CheckParameters3( IMAPIControl_Activate, a1, a2, a3 )

#define Validate_IMAPIControl_GetState( a1, a2, a3 ) \
             ValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define UlValidate_IMAPIControl_GetState( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define CheckParameters_IMAPIControl_GetState( a1, a2, a3 ) \
             CheckParameters3( IMAPIControl_GetState, a1, a2, a3 )


/* IMAPIStatus */

#define Validate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
             ValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define UlValidate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_ValidateState( a1, a2, a3 ) \
             CheckParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )

#define Validate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
             ValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define UlValidate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
             CheckParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )

#define Validate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
             ValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define UlValidate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
             UlValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define CheckParameters_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
             CheckParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )

#define Validate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )


/* IStream */

#define Validate_IStream_Read( a1, a2, a3, a4 ) \
             ValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define UlValidate_IStream_Read( a1, a2, a3, a4 ) \
             UlValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define CheckParameters_IStream_Read( a1, a2, a3, a4 ) \
             CheckParameters4( IStream_Read, a1, a2, a3, a4 )

#define Validate_IStream_Write( a1, a2, a3, a4 ) \
             ValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define UlValidate_IStream_Write( a1, a2, a3, a4 ) \
             UlValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define CheckParameters_IStream_Write( a1, a2, a3, a4 ) \
             CheckParameters4( IStream_Write, a1, a2, a3, a4 )

#define Validate_IStream_Seek( a1, a2, a3, a4 ) \
             ValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define UlValidate_IStream_Seek( a1, a2, a3, a4 ) \
             UlValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define CheckParameters_IStream_Seek( a1, a2, a3, a4 ) \
             CheckParameters4( IStream_Seek, a1, a2, a3, a4 )

#define Validate_IStream_SetSize( a1, a2 ) \
             ValidateParameters2( IStream_SetSize, a1, a2 )
#define UlValidate_IStream_SetSize( a1, a2 ) \
             UlValidateParameters2( IStream_SetSize, a1, a2 )
#define CheckParameters_IStream_SetSize( a1, a2 ) \
             CheckParameters2( IStream_SetSize, a1, a2 )

#define Validate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
             ValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define UlValidate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
             UlValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define CheckParameters_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
             CheckParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )

#define Validate_IStream_Commit( a1, a2 ) \
             ValidateParameters2( IStream_Commit, a1, a2 )
#define UlValidate_IStream_Commit( a1, a2 ) \
             UlValidateParameters2( IStream_Commit, a1, a2 )
#define CheckParameters_IStream_Commit( a1, a2 ) \
             CheckParameters2( IStream_Commit, a1, a2 )

#define Validate_IStream_Revert( a1 ) \
             ValidateParameters1( IStream_Revert, a1 )
#define UlValidate_IStream_Revert( a1 ) \
             UlValidateParameters1( IStream_Revert, a1 )
#define CheckParameters_IStream_Revert( a1 ) \
             CheckParameters1( IStream_Revert, a1 )

#define Validate_IStream_LockRegion( a1, a2, a3, a4 ) \
             ValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_LockRegion( a1, a2, a3, a4 ) \
             UlValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_LockRegion( a1, a2, a3, a4 ) \
             CheckParameters4( IStream_LockRegion, a1, a2, a3, a4 )

#define Validate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
             ValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
             UlValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_UnlockRegion( a1, a2, a3, a4 ) \
             CheckParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )

#define Validate_IStream_Stat( a1, a2, a3 ) \
             ValidateParameters3( IStream_Stat, a1, a2, a3 )
#define UlValidate_IStream_Stat( a1, a2, a3 ) \
             UlValidateParameters3( IStream_Stat, a1, a2, a3 )
#define CheckParameters_IStream_Stat( a1, a2, a3 ) \
             CheckParameters3( IStream_Stat, a1, a2, a3 )

#define Validate_IStream_Clone( a1, a2 ) \
             ValidateParameters2( IStream_Clone, a1, a2 )
#define UlValidate_IStream_Clone( a1, a2 ) \
             UlValidateParameters2( IStream_Clone, a1, a2 )
#define CheckParameters_IStream_Clone( a1, a2 ) \
             CheckParameters2( IStream_Clone, a1, a2 )


/* IMAPIAdviseSink */

#define Validate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
             ValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define UlValidate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
             UlValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define CheckParameters_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
             CheckParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )


#ifdef WIN16
HRESULT 
PASCAL  HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#elif defined(_X86_)
STDAPI  HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#else
STDAPIV HrValidateParametersV( METHODS eMethod, ... );
STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist );
#endif /* WIN16 */


#ifdef __cplusplus
}
#endif

#endif  /* _INC_VALIDATE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapix.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I X . H
 *  
 *  Definitions of objects/flags, etc used by Extended MAPI.
 *  
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef MAPIX_H
#define MAPIX_H

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#ifdef  __cplusplus
extern "C" {
#endif  

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Forward interface declarations */

DECLARE_MAPI_INTERFACE_PTR(IProfAdmin,          LPPROFADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMsgServiceAdmin,    LPSERVICEADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession,        LPMAPISESSION);

/* ------------------------------------------------------ */
/* shared with simple mapi */

typedef ULONG       FLAGS;

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI                 */
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session         */
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session       */
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile        */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon              */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return       */
#define MAPI_SERVICE_UI_ALWAYS  0x00002000  /* Do logon UI in all providers     */
#define MAPI_NO_MAIL            0x00008000  /* Do not activate transports       */
/* #define MAPI_NT_SERVICE          0x00010000  Allow logon from an NT service  */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI        0x00020000  /* Display password UI only         */
#endif
#define MAPI_TIMEOUT_SHORT      0x00100000  /* Minimal wait for logon resources */

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* Structure passed to MAPIInitialize(), and its ulFlags values */

typedef struct
{
    ULONG           ulVersion;
    ULONG           ulFlags;
} MAPIINIT_0, FAR *LPMAPIINIT_0;

typedef MAPIINIT_0 MAPIINIT;
typedef MAPIINIT FAR *LPMAPIINIT;

#define MAPI_INIT_VERSION               0

#define MAPI_MULTITHREAD_NOTIFICATIONS  0x00000001
/* Reserved for MAPI                    0x40000000 */
/* #define MAPI_NT_SERVICE              0x00010000  Use from NT service */

/* MAPI base functions */

typedef HRESULT (STDAPICALLTYPE MAPIINITIALIZE)(
    LPVOID          lpMapiInit
);
typedef MAPIINITIALIZE FAR *LPMAPIINITIALIZE;

typedef void (STDAPICALLTYPE MAPIUNINITIALIZE)(void);
typedef MAPIUNINITIALIZE FAR *LPMAPIUNINITIALIZE;

MAPIINITIALIZE      MAPIInitialize;
MAPIUNINITIALIZE    MAPIUninitialize;


/*  Extended MAPI Logon function */


typedef HRESULT (STDMETHODCALLTYPE MAPILOGONEX)(
    ULONG ulUIParam,
    LPTSTR lpszProfileName,
    LPTSTR lpszPassword,
    ULONG ulFlags,   /*  ulFlags takes all that SimpleMAPI does + MAPI_UNICODE */
    LPMAPISESSION FAR * lppSession
);
typedef MAPILOGONEX FAR *LPMAPILOGONEX;

MAPILOGONEX MAPILogonEx;


typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
    LPVOID          lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR  *LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR    *LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR      *LPMAPIFREEBUFFER;

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
MAPIFREEBUFFER MAPIFreeBuffer;

typedef HRESULT (STDMETHODCALLTYPE MAPIADMINPROFILES)(
    ULONG ulFlags,
    LPPROFADMIN FAR *lppProfAdmin
);

typedef MAPIADMINPROFILES FAR *LPMAPIADMINPROFILES;

MAPIADMINPROFILES MAPIAdminProfiles;

/* IMAPISession Interface -------------------------------------------------- */

/* Flags for OpenEntry and others */

/*#define MAPI_MODIFY               ((ULONG) 0x00000001) */

/* Flags for Logoff */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* Flags for SetDefaultStore. They are mutually exclusive. */

#define MAPI_DEFAULT_STORE          0x00000001  /* for incoming messages */
#define MAPI_SIMPLE_STORE_TEMPORARY 0x00000002  /* for simple MAPI and CMC */
#define MAPI_SIMPLE_STORE_PERMANENT 0x00000003  /* for simple MAPI and CMC */
#define MAPI_PRIMARY_STORE          0x00000004  /* Used by some clients */
#define MAPI_SECONDARY_STORE        0x00000005  /* Used by some clients */

/* Flags for ShowForm. */

#define MAPI_POST_MESSAGE       0x00000001  /* Selects post/send semantics */
#define MAPI_NEW_MESSAGE        0x00000002  /* Governs copying during submission */

/*  MessageOptions */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  QueryDefaultMessageOpt */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IMAPISESSION_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMsgStoresTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenMsgStore)                                            \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMDB FAR *                 lppMDB) IPURE;              \
    MAPIMETHOD(OpenAddressBook)                                         \
        (THIS_  ULONG                       ulUIParam,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPADRBOOK FAR *             lppAdrBook) IPURE;          \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \
    MAPIMETHOD(GetStatusTable)                                          \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;  \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(MessageOptions)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszAdrType,                \
                LPMESSAGE                   lpMessage) IPURE;           \
    MAPIMETHOD(QueryDefaultMessageOpt)                                  \
        (THIS_  LPTSTR                      lpszAdrType,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(EnumAdrTypes)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcAdrTypes,                \
                LPTSTR FAR * FAR *          lpppszAdrTypes) IPURE;      \
    MAPIMETHOD(QueryIdentity)                                           \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(Logoff)                                                  \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       ulReserved) IPURE;          \
    MAPIMETHOD(SetDefaultStore)                                         \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(AdminServices)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSERVICEADMIN FAR *        lppServiceAdmin) IPURE;     \
    MAPIMETHOD(ShowForm)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMDB                       lpMsgStore,                 \
                LPMAPIFOLDER                lpParentFolder,             \
                LPCIID                      lpInterface,                \
                ULONG                       ulMessageToken,             \
                LPMESSAGE                   lpMessageSent,              \
                ULONG                       ulFlags,                    \
                ULONG                       ulMessageStatus,            \
                ULONG                       ulMessageFlags,             \
                ULONG                       ulAccess,                   \
                LPSTR                       lpszMessageClass) IPURE;    \
    MAPIMETHOD(PrepareForm)                                             \
        (THIS_  LPCIID                      lpInterface,                \
                LPMESSAGE                   lpMessage,                  \
                ULONG FAR *                 lpulMessageToken) IPURE;    \


#undef       INTERFACE
#define      INTERFACE  IMAPISession
DECLARE_MAPI_INTERFACE_(IMAPISession, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPISESSION_METHODS(PURE)
};





/*DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);*/

/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO      ((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */


#define MAPI_IADDRBOOK_METHODS(IPURE)                                   \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;  \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CreateOneOff)                                            \
        (THIS_  LPTSTR                      lpszName,                   \
                LPTSTR                      lpszAdrType,                \
                LPTSTR                      lpszAddress,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(NewEntry)                                                \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cbEIDContainer,             \
                LPENTRYID                   lpEIDContainer,             \
                ULONG                       cbEIDNewEntryTpl,           \
                LPENTRYID                   lpEIDNewEntryTpl,           \
                ULONG FAR *                 lpcbEIDNewEntry,            \
                LPENTRYID FAR *             lppEIDNewEntry) IPURE;      \
    MAPIMETHOD(ResolveName)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszNewEntryTitle,          \
                LPADRLIST                   lpAdrList) IPURE;           \
    MAPIMETHOD(Address)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPADRPARM                   lpAdrParms,                 \
                LPADRLIST FAR *             lppAdrList) IPURE;          \
    MAPIMETHOD(Details)                                                 \
        (THIS_  ULONG FAR *                 lpulUIParam,                \
                LPFNDISMISS                 lpfnDismiss,                \
                LPVOID                      lpvDismissContext,          \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPFNBUTTON                  lpfButtonCallback,          \
                LPVOID                      lpvButtonContext,           \
                LPTSTR                      lpszButtonText,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RecipOptions)                                            \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPADRENTRY                  lpRecip) IPURE;             \
    MAPIMETHOD(QueryDefaultRecipOpt)                                    \
        (THIS_  LPTSTR                      lpszAdrType,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppOptions) IPURE;          \
    MAPIMETHOD(GetPAB)                                                  \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetPAB)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetDefaultDir)                                           \
        (THIS_  ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID) IPURE;          \
    MAPIMETHOD(SetDefaultDir)                                           \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetSearchPath)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppSearchPath) IPURE;       \
    MAPIMETHOD(SetSearchPath)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRowSet                   lpSearchPath) IPURE;        \
    MAPIMETHOD(PrepareRecips)                                           \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray             lpPropTagArray,             \
                LPADRLIST                   lpRecipList) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);

/* IProfAdmin Interface ---------------------------------------------------- */

/* Flags for CreateProfile */
#define MAPI_DEFAULT_SERVICES           0x00000001

/* GetProfileTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IPROFADMIN_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProfileTable)                                         \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProfile)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszPassword,               \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteProfile)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangeProfilePassword)                                   \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewPassword,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CopyProfile)                                             \
        (THIS_  LPTSTR                      lpszOldProfileName,         \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewProfileName,         \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RenameProfile)                                           \
        (THIS_  LPTSTR                      lpszOldProfileName,         \
                LPTSTR                      lpszOldPassword,            \
                LPTSTR                      lpszNewProfileName,         \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetDefaultProfile)                                       \
        (THIS_  LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(AdminServices)                                           \
        (THIS_  LPTSTR                      lpszProfileName,            \
                LPTSTR                      lpszPassword,               \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                LPSERVICEADMIN FAR *        lppServiceAdmin) IPURE;     \


#undef       INTERFACE
#define      INTERFACE  IProfAdmin
DECLARE_MAPI_INTERFACE_(IProfAdmin, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROFADMIN_METHODS(PURE)
};

/* IMsgServiceAdmin Interface ---------------------------------------------- */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define SERVICE_DEFAULT_STORE       0x00000001
#define SERVICE_SINGLE_COPY         0x00000002
#define SERVICE_CREATE_WITH_STORE   0x00000004
#define SERVICE_PRIMARY_IDENTITY    0x00000008
#define SERVICE_NO_PRIMARY_IDENTITY 0x00000020

/*  GetMsgServiceTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

/*  GetProviderTable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) */

#define MAPI_IMSGSERVICEADMIN_METHODS(IPURE)                            \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetMsgServiceTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateMsgService)                                        \
        (THIS_  LPTSTR                      lpszService,                \
                LPTSTR                      lpszDisplayName,            \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMsgService)                                        \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(CopyMsgService)                                          \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPTSTR                      lpszDisplayName,            \
                LPCIID                      lpInterfaceToCopy,          \
                LPCIID                      lpInterfaceDst,             \
                LPVOID                      lpObjectDst,                \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(RenameMsgService)                                        \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags,                    \
                LPTSTR                      lpszDisplayName) IPURE;     \
    MAPIMETHOD(ConfigureMsgService)                                     \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps) IPURE;             \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \
    MAPIMETHOD(MsgServiceTransportOrder)                                \
        (THIS_  ULONG                       cUID,                       \
                LPMAPIUID                   lpUIDList,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(AdminProviders)                                          \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags,                    \
                LPPROVIDERADMIN FAR *       lppProviderAdmin) IPURE;    \
    MAPIMETHOD(SetPrimaryIdentity)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \


#undef       INTERFACE
#define      INTERFACE  IMsgServiceAdmin
DECLARE_MAPI_INTERFACE_(IMsgServiceAdmin, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMSGSERVICEADMIN_METHODS(PURE)
};

#ifdef  __cplusplus
}       /*  extern "C" */
#endif  

#endif /* MAPIX_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mapitags.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *  M A P I T A G S . H
 *
 *  Property tag definitions for standard properties of MAPI
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  0E00    0FFF    MAPI_defined non-transmittable property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6000    65FF    User-defined non-transmittable property
 *  6600    67FF    Provider-defined internal non-transmittable property
 *  6800    7BFF    Message class-defined content property
 *  7C00    7FFF    Message class-defined non-transmittable
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef MAPITAGS_H
#define MAPITAGS_H

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
    ((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
    (PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

/*
 *  Message envelope properties
 */

#define PR_ACKNOWLEDGEMENT_MODE                     PROP_TAG( PT_LONG,      0x0001)
#define PR_ALTERNATE_RECIPIENT_ALLOWED              PROP_TAG( PT_BOOLEAN,   0x0002)
#define PR_AUTHORIZING_USERS                        PROP_TAG( PT_BINARY,    0x0003)
#define PR_AUTO_FORWARD_COMMENT                     PROP_TAG( PT_TSTRING,   0x0004)
#define PR_AUTO_FORWARD_COMMENT_W                   PROP_TAG( PT_UNICODE,   0x0004)
#define PR_AUTO_FORWARD_COMMENT_A                   PROP_TAG( PT_STRING8,   0x0004)
#define PR_AUTO_FORWARDED                           PROP_TAG( PT_BOOLEAN,   0x0005)
#define PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID     PROP_TAG( PT_BINARY,    0x0006)
#define PR_CONTENT_CORRELATOR                       PROP_TAG( PT_BINARY,    0x0007)
#define PR_CONTENT_IDENTIFIER                       PROP_TAG( PT_TSTRING,   0x0008)
#define PR_CONTENT_IDENTIFIER_W                     PROP_TAG( PT_UNICODE,   0x0008)
#define PR_CONTENT_IDENTIFIER_A                     PROP_TAG( PT_STRING8,   0x0008)
#define PR_CONTENT_LENGTH                           PROP_TAG( PT_LONG,      0x0009)
#define PR_CONTENT_RETURN_REQUESTED                 PROP_TAG( PT_BOOLEAN,   0x000A)



#define PR_CONVERSATION_KEY                         PROP_TAG( PT_BINARY,    0x000B)

#define PR_CONVERSION_EITS                          PROP_TAG( PT_BINARY,    0x000C)
#define PR_CONVERSION_WITH_LOSS_PROHIBITED          PROP_TAG( PT_BOOLEAN,   0x000D)
#define PR_CONVERTED_EITS                           PROP_TAG( PT_BINARY,    0x000E)
#define PR_DEFERRED_DELIVERY_TIME                   PROP_TAG( PT_SYSTIME,   0x000F)
#define PR_DELIVER_TIME                             PROP_TAG( PT_SYSTIME,   0x0010)
#define PR_DISCARD_REASON                           PROP_TAG( PT_LONG,      0x0011)
#define PR_DISCLOSURE_OF_RECIPIENTS                 PROP_TAG( PT_BOOLEAN,   0x0012)
#define PR_DL_EXPANSION_HISTORY                     PROP_TAG( PT_BINARY,    0x0013)
#define PR_DL_EXPANSION_PROHIBITED                  PROP_TAG( PT_BOOLEAN,   0x0014)
#define PR_EXPIRY_TIME                              PROP_TAG( PT_SYSTIME,   0x0015)
#define PR_IMPLICIT_CONVERSION_PROHIBITED           PROP_TAG( PT_BOOLEAN,   0x0016)
#define PR_IMPORTANCE                               PROP_TAG( PT_LONG,      0x0017)
#define PR_IPM_ID                                   PROP_TAG( PT_BINARY,    0x0018)
#define PR_LATEST_DELIVERY_TIME                     PROP_TAG( PT_SYSTIME,   0x0019)
#define PR_MESSAGE_CLASS                            PROP_TAG( PT_TSTRING,   0x001A)
#define PR_MESSAGE_CLASS_W                          PROP_TAG( PT_UNICODE,   0x001A)
#define PR_MESSAGE_CLASS_A                          PROP_TAG( PT_STRING8,   0x001A)
#define PR_MESSAGE_DELIVERY_ID                      PROP_TAG( PT_BINARY,    0x001B)





#define PR_MESSAGE_SECURITY_LABEL                   PROP_TAG( PT_BINARY,    0x001E)
#define PR_OBSOLETED_IPMS                           PROP_TAG( PT_BINARY,    0x001F)
#define PR_ORIGINALLY_INTENDED_RECIPIENT_NAME       PROP_TAG( PT_BINARY,    0x0020)
#define PR_ORIGINAL_EITS                            PROP_TAG( PT_BINARY,    0x0021)
#define PR_ORIGINATOR_CERTIFICATE                   PROP_TAG( PT_BINARY,    0x0022)
#define PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED     PROP_TAG( PT_BOOLEAN,   0x0023)
#define PR_ORIGINATOR_RETURN_ADDRESS                PROP_TAG( PT_BINARY,    0x0024)



#define PR_PARENT_KEY                               PROP_TAG( PT_BINARY,    0x0025)
#define PR_PRIORITY                                 PROP_TAG( PT_LONG,      0x0026)



#define PR_ORIGIN_CHECK                             PROP_TAG( PT_BINARY,    0x0027)
#define PR_PROOF_OF_SUBMISSION_REQUESTED            PROP_TAG( PT_BOOLEAN,   0x0028)
#define PR_READ_RECEIPT_REQUESTED                   PROP_TAG( PT_BOOLEAN,   0x0029)
#define PR_RECEIPT_TIME                             PROP_TAG( PT_SYSTIME,   0x002A)
#define PR_RECIPIENT_REASSIGNMENT_PROHIBITED        PROP_TAG( PT_BOOLEAN,   0x002B)
#define PR_REDIRECTION_HISTORY                      PROP_TAG( PT_BINARY,    0x002C)
#define PR_RELATED_IPMS                             PROP_TAG( PT_BINARY,    0x002D)
#define PR_ORIGINAL_SENSITIVITY                     PROP_TAG( PT_LONG,      0x002E)
#define PR_LANGUAGES                                PROP_TAG( PT_TSTRING,   0x002F)
#define PR_LANGUAGES_W                              PROP_TAG( PT_UNICODE,   0x002F)
#define PR_LANGUAGES_A                              PROP_TAG( PT_STRING8,   0x002F)
#define PR_REPLY_TIME                               PROP_TAG( PT_SYSTIME,   0x0030)
#define PR_REPORT_TAG                               PROP_TAG( PT_BINARY,    0x0031)
#define PR_REPORT_TIME                              PROP_TAG( PT_SYSTIME,   0x0032)
#define PR_RETURNED_IPM                             PROP_TAG( PT_BOOLEAN,   0x0033)
#define PR_SECURITY                                 PROP_TAG( PT_LONG,      0x0034)
#define PR_INCOMPLETE_COPY                          PROP_TAG( PT_BOOLEAN,   0x0035)
#define PR_SENSITIVITY                              PROP_TAG( PT_LONG,      0x0036)
#define PR_SUBJECT                                  PROP_TAG( PT_TSTRING,   0x0037)
#define PR_SUBJECT_W                                PROP_TAG( PT_UNICODE,   0x0037)
#define PR_SUBJECT_A                                PROP_TAG( PT_STRING8,   0x0037)
#define PR_SUBJECT_IPM                              PROP_TAG( PT_BINARY,    0x0038)
#define PR_CLIENT_SUBMIT_TIME                       PROP_TAG( PT_SYSTIME,   0x0039)
#define PR_REPORT_NAME                              PROP_TAG( PT_TSTRING,   0x003A)
#define PR_REPORT_NAME_W                            PROP_TAG( PT_UNICODE,   0x003A)
#define PR_REPORT_NAME_A                            PROP_TAG( PT_STRING8,   0x003A)
#define PR_SENT_REPRESENTING_SEARCH_KEY             PROP_TAG( PT_BINARY,    0x003B)
#define PR_X400_CONTENT_TYPE                        PROP_TAG( PT_BINARY,    0x003C)
#define PR_SUBJECT_PREFIX                           PROP_TAG( PT_TSTRING,   0x003D)
#define PR_SUBJECT_PREFIX_W                         PROP_TAG( PT_UNICODE,   0x003D)
#define PR_SUBJECT_PREFIX_A                         PROP_TAG( PT_STRING8,   0x003D)
#define PR_NON_RECEIPT_REASON                       PROP_TAG( PT_LONG,      0x003E)
#define PR_RECEIVED_BY_ENTRYID                      PROP_TAG( PT_BINARY,    0x003F)
#define PR_RECEIVED_BY_NAME                         PROP_TAG( PT_TSTRING,   0x0040)
#define PR_RECEIVED_BY_NAME_W                       PROP_TAG( PT_UNICODE,   0x0040)
#define PR_RECEIVED_BY_NAME_A                       PROP_TAG( PT_STRING8,   0x0040)
#define PR_SENT_REPRESENTING_ENTRYID                PROP_TAG( PT_BINARY,    0x0041)
#define PR_SENT_REPRESENTING_NAME                   PROP_TAG( PT_TSTRING,   0x0042)
#define PR_SENT_REPRESENTING_NAME_W                 PROP_TAG( PT_UNICODE,   0x0042)
#define PR_SENT_REPRESENTING_NAME_A                 PROP_TAG( PT_STRING8,   0x0042)
#define PR_RCVD_REPRESENTING_ENTRYID                PROP_TAG( PT_BINARY,    0x0043)
#define PR_RCVD_REPRESENTING_NAME                   PROP_TAG( PT_TSTRING,   0x0044)
#define PR_RCVD_REPRESENTING_NAME_W                 PROP_TAG( PT_UNICODE,   0x0044)
#define PR_RCVD_REPRESENTING_NAME_A                 PROP_TAG( PT_STRING8,   0x0044)
#define PR_REPORT_ENTRYID                           PROP_TAG( PT_BINARY,    0x0045)
#define PR_READ_RECEIPT_ENTRYID                     PROP_TAG( PT_BINARY,    0x0046)
#define PR_MESSAGE_SUBMISSION_ID                    PROP_TAG( PT_BINARY,    0x0047)
#define PR_PROVIDER_SUBMIT_TIME                     PROP_TAG( PT_SYSTIME,   0x0048)
#define PR_ORIGINAL_SUBJECT                         PROP_TAG( PT_TSTRING,   0x0049)
#define PR_ORIGINAL_SUBJECT_W                       PROP_TAG( PT_UNICODE,   0x0049)
#define PR_ORIGINAL_SUBJECT_A                       PROP_TAG( PT_STRING8,   0x0049)
#define PR_DISC_VAL                                 PROP_TAG( PT_BOOLEAN,   0x004A)
#define PR_ORIG_MESSAGE_CLASS                       PROP_TAG( PT_TSTRING,   0x004B)
#define PR_ORIG_MESSAGE_CLASS_W                     PROP_TAG( PT_UNICODE,   0x004B)
#define PR_ORIG_MESSAGE_CLASS_A                     PROP_TAG( PT_STRING8,   0x004B)
#define PR_ORIGINAL_AUTHOR_ENTRYID                  PROP_TAG( PT_BINARY,    0x004C)
#define PR_ORIGINAL_AUTHOR_NAME                     PROP_TAG( PT_TSTRING,   0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_W                   PROP_TAG( PT_UNICODE,   0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_A                   PROP_TAG( PT_STRING8,   0x004D)
#define PR_ORIGINAL_SUBMIT_TIME                     PROP_TAG( PT_SYSTIME,   0x004E)
#define PR_REPLY_RECIPIENT_ENTRIES                  PROP_TAG( PT_BINARY,    0x004F)
#define PR_REPLY_RECIPIENT_NAMES                    PROP_TAG( PT_TSTRING,   0x0050)
#define PR_REPLY_RECIPIENT_NAMES_W                  PROP_TAG( PT_UNICODE,   0x0050)
#define PR_REPLY_RECIPIENT_NAMES_A                  PROP_TAG( PT_STRING8,   0x0050)

#define PR_RECEIVED_BY_SEARCH_KEY                   PROP_TAG( PT_BINARY,    0x0051)
#define PR_RCVD_REPRESENTING_SEARCH_KEY             PROP_TAG( PT_BINARY,    0x0052)
#define PR_READ_RECEIPT_SEARCH_KEY                  PROP_TAG( PT_BINARY,    0x0053)
#define PR_REPORT_SEARCH_KEY                        PROP_TAG( PT_BINARY,    0x0054)
#define PR_ORIGINAL_DELIVERY_TIME                   PROP_TAG( PT_SYSTIME,   0x0055)
#define PR_ORIGINAL_AUTHOR_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x0056)

#define PR_MESSAGE_TO_ME                            PROP_TAG( PT_BOOLEAN,   0x0057)
#define PR_MESSAGE_CC_ME                            PROP_TAG( PT_BOOLEAN,   0x0058)
#define PR_MESSAGE_RECIP_ME                         PROP_TAG( PT_BOOLEAN,   0x0059)

#define PR_ORIGINAL_SENDER_NAME                     PROP_TAG( PT_TSTRING,   0x005A)
#define PR_ORIGINAL_SENDER_NAME_W                   PROP_TAG( PT_UNICODE,   0x005A)
#define PR_ORIGINAL_SENDER_NAME_A                   PROP_TAG( PT_STRING8,   0x005A)
#define PR_ORIGINAL_SENDER_ENTRYID                  PROP_TAG( PT_BINARY,    0x005B)
#define PR_ORIGINAL_SENDER_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x005C)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME          PROP_TAG( PT_TSTRING,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_W        PROP_TAG( PT_UNICODE,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_A        PROP_TAG( PT_STRING8,   0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_ENTRYID       PROP_TAG( PT_BINARY,    0x005E)
#define PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY    PROP_TAG( PT_BINARY,    0x005F)

#define PR_START_DATE                               PROP_TAG( PT_SYSTIME,   0x0060)
#define PR_END_DATE                                 PROP_TAG( PT_SYSTIME,   0x0061)
#define PR_OWNER_APPT_ID                            PROP_TAG( PT_LONG,      0x0062)
#ifndef PR_RESPONSE_REQUESTED
#define PR_RESPONSE_REQUESTED                       PROP_TAG( PT_BOOLEAN,   0x0063)
#endif

#define PR_SENT_REPRESENTING_ADDRTYPE               PROP_TAG( PT_TSTRING,   0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_W             PROP_TAG( PT_UNICODE,   0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_A             PROP_TAG( PT_STRING8,   0x0064)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS          PROP_TAG( PT_TSTRING,   0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_W        PROP_TAG( PT_UNICODE,   0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_A        PROP_TAG( PT_STRING8,   0x0065)

#define PR_ORIGINAL_SENDER_ADDRTYPE                 PROP_TAG( PT_TSTRING,   0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_W               PROP_TAG( PT_UNICODE,   0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_A               PROP_TAG( PT_STRING8,   0x0066)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS            PROP_TAG( PT_TSTRING,   0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W          PROP_TAG( PT_UNICODE,   0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A          PROP_TAG( PT_STRING8,   0x0067)

#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE      PROP_TAG( PT_TSTRING,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W    PROP_TAG( PT_UNICODE,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A    PROP_TAG( PT_STRING8,   0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS PROP_TAG( PT_TSTRING,   0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W   PROP_TAG( PT_UNICODE,   0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A   PROP_TAG( PT_STRING8,   0x0069)

#define PR_CONVERSATION_TOPIC                       PROP_TAG( PT_TSTRING,   0x0070)
#define PR_CONVERSATION_TOPIC_W                     PROP_TAG( PT_UNICODE,   0x0070)
#define PR_CONVERSATION_TOPIC_A                     PROP_TAG( PT_STRING8,   0x0070)
#define PR_CONVERSATION_INDEX                       PROP_TAG( PT_BINARY,    0x0071)

#define PR_ORIGINAL_DISPLAY_BCC                     PROP_TAG( PT_TSTRING,   0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_W                   PROP_TAG( PT_UNICODE,   0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_A                   PROP_TAG( PT_STRING8,   0x0072)
#define PR_ORIGINAL_DISPLAY_CC                      PROP_TAG( PT_TSTRING,   0x0073)
#define PR_ORIGINAL_DISPLAY_CC_W                    PROP_TAG( PT_UNICODE,   0x0073)
#define PR_ORIGINAL_DISPLAY_CC_A                    PROP_TAG( PT_STRING8,   0x0073)
#define PR_ORIGINAL_DISPLAY_TO                      PROP_TAG( PT_TSTRING,   0x0074)
#define PR_ORIGINAL_DISPLAY_TO_W                    PROP_TAG( PT_UNICODE,   0x0074)
#define PR_ORIGINAL_DISPLAY_TO_A                    PROP_TAG( PT_STRING8,   0x0074)

#define PR_RECEIVED_BY_ADDRTYPE                     PROP_TAG( PT_TSTRING,   0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_W                   PROP_TAG( PT_UNICODE,   0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_A                   PROP_TAG( PT_STRING8,   0x0075)
#define PR_RECEIVED_BY_EMAIL_ADDRESS                PROP_TAG( PT_TSTRING,   0x0076)
#define PR_RECEIVED_BY_EMAIL_ADDRESS_W              PROP_TAG( PT_UNICODE,   0x0076)
#define PR_RECEIVED_BY_EMAIL_ADDRESS_A              PROP_TAG( PT_STRING8,   0x0076)

#define PR_RCVD_REPRESENTING_ADDRTYPE               PROP_TAG( PT_TSTRING,   0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_W             PROP_TAG( PT_UNICODE,   0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_A             PROP_TAG( PT_STRING8,   0x0077)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS          PROP_TAG( PT_TSTRING,   0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W        PROP_TAG( PT_UNICODE,   0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A        PROP_TAG( PT_STRING8,   0x0078)

#define PR_ORIGINAL_AUTHOR_ADDRTYPE                 PROP_TAG( PT_TSTRING,   0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_W               PROP_TAG( PT_UNICODE,   0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_A               PROP_TAG( PT_STRING8,   0x0079)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS            PROP_TAG( PT_TSTRING,   0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W          PROP_TAG( PT_UNICODE,   0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A          PROP_TAG( PT_STRING8,   0x007A)

#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE       PROP_TAG( PT_TSTRING,   0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W     PROP_TAG( PT_UNICODE,   0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A     PROP_TAG( PT_STRING8,   0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS  PROP_TAG( PT_TSTRING,   0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W    PROP_TAG( PT_UNICODE,   0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A    PROP_TAG( PT_STRING8,   0x007C)

#define PR_TRANSPORT_MESSAGE_HEADERS                PROP_TAG(PT_TSTRING,    0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_W              PROP_TAG(PT_UNICODE,    0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_A              PROP_TAG(PT_STRING8,    0x007D)

#define PR_DELEGATION                               PROP_TAG(PT_BINARY,     0x007E)

#define PR_TNEF_CORRELATION_KEY                     PROP_TAG(PT_BINARY,     0x007F)



/*
 *  Message content properties
 */

#define PR_BODY                                     PROP_TAG( PT_TSTRING,   0x1000)
#define PR_BODY_W                                   PROP_TAG( PT_UNICODE,   0x1000)
#define PR_BODY_A                                   PROP_TAG( PT_STRING8,   0x1000)
#define PR_REPORT_TEXT                              PROP_TAG( PT_TSTRING,   0x1001)
#define PR_REPORT_TEXT_W                            PROP_TAG( PT_UNICODE,   0x1001)
#define PR_REPORT_TEXT_A                            PROP_TAG( PT_STRING8,   0x1001)
#define PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY      PROP_TAG( PT_BINARY,    0x1002)
#define PR_REPORTING_DL_NAME                        PROP_TAG( PT_BINARY,    0x1003)
#define PR_REPORTING_MTA_CERTIFICATE                PROP_TAG( PT_BINARY,    0x1004)

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

#define PR_RTF_SYNC_BODY_CRC                        PROP_TAG( PT_LONG,      0x1006)
#define PR_RTF_SYNC_BODY_COUNT                      PROP_TAG( PT_LONG,      0x1007)
#define PR_RTF_SYNC_BODY_TAG                        PROP_TAG( PT_TSTRING,   0x1008)
#define PR_RTF_SYNC_BODY_TAG_W                      PROP_TAG( PT_UNICODE,   0x1008)
#define PR_RTF_SYNC_BODY_TAG_A                      PROP_TAG( PT_STRING8,   0x1008)
#define PR_RTF_COMPRESSED                           PROP_TAG( PT_BINARY,    0x1009)
#define PR_RTF_SYNC_PREFIX_COUNT                    PROP_TAG( PT_LONG,      0x1010)
#define PR_RTF_SYNC_TRAILING_COUNT                  PROP_TAG( PT_LONG,      0x1011)
#define PR_ORIGINALLY_INTENDED_RECIP_ENTRYID        PROP_TAG( PT_BINARY,    0x1012)
#define PR_BODY_HTML                                PROP_TAG( PT_TSTRING,   0x1013)
#define PR_BODY_HTML_W                              PROP_TAG( PT_UNICODE,   0x1013)
#define PR_BODY_HTML_A                              PROP_TAG( PT_STRING8,   0x1013)
#define PR_FLAG_STATUS                              PROP_TAG( PT_LONG,      0x1090)
#define PR_FLAG_COMPLETE_TIME                       PROP_TAG( PT_SYSTIME,   0x1091)

/*
 *  Reserved 0x1100-0x1200
 */


/*
 *  Message recipient properties
 */

#define PR_CONTENT_INTEGRITY_CHECK                  PROP_TAG( PT_BINARY,    0x0C00)
#define PR_EXPLICIT_CONVERSION                      PROP_TAG( PT_LONG,      0x0C01)
#define PR_IPM_RETURN_REQUESTED                     PROP_TAG( PT_BOOLEAN,   0x0C02)
#define PR_MESSAGE_TOKEN                            PROP_TAG( PT_BINARY,    0x0C03)
#define PR_NDR_REASON_CODE                          PROP_TAG( PT_LONG,      0x0C04)
#define PR_NDR_DIAG_CODE                            PROP_TAG( PT_LONG,      0x0C05)
#define PR_NON_RECEIPT_NOTIFICATION_REQUESTED       PROP_TAG( PT_BOOLEAN,   0x0C06)
#define PR_DELIVERY_POINT                           PROP_TAG( PT_LONG,      0x0C07)

#define PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED PROP_TAG( PT_BOOLEAN,   0x0C08)
#define PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT PROP_TAG( PT_BINARY,    0x0C09)
#define PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY    PROP_TAG( PT_BOOLEAN,   0x0C0A)
#define PR_PHYSICAL_DELIVERY_MODE                   PROP_TAG( PT_LONG,      0x0C0B)
#define PR_PHYSICAL_DELIVERY_REPORT_REQUEST         PROP_TAG( PT_LONG,      0x0C0C)
#define PR_PHYSICAL_FORWARDING_ADDRESS              PROP_TAG( PT_BINARY,    0x0C0D)
#define PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED    PROP_TAG( PT_BOOLEAN,   0x0C0E)
#define PR_PHYSICAL_FORWARDING_PROHIBITED           PROP_TAG( PT_BOOLEAN,   0x0C0F)
#define PR_PHYSICAL_RENDITION_ATTRIBUTES            PROP_TAG( PT_BINARY,    0x0C10)
#define PR_PROOF_OF_DELIVERY                        PROP_TAG( PT_BINARY,    0x0C11)
#define PR_PROOF_OF_DELIVERY_REQUESTED              PROP_TAG( PT_BOOLEAN,   0x0C12)
#define PR_RECIPIENT_CERTIFICATE                    PROP_TAG( PT_BINARY,    0x0C13)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE              PROP_TAG( PT_TSTRING,   0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_W            PROP_TAG( PT_UNICODE,   0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_A            PROP_TAG( PT_STRING8,   0x0C14)
#define PR_RECIPIENT_TYPE                           PROP_TAG( PT_LONG,      0x0C15)
#define PR_REGISTERED_MAIL_TYPE                     PROP_TAG( PT_LONG,      0x0C16)
#ifndef PR_REPLY_REQUESTED
#define PR_REPLY_REQUESTED                          PROP_TAG( PT_BOOLEAN,   0x0C17)
#endif
#define PR_REQUESTED_DELIVERY_METHOD                PROP_TAG( PT_LONG,      0x0C18)
#define PR_SENDER_ENTRYID                           PROP_TAG( PT_BINARY,    0x0C19)
#define PR_SENDER_NAME                              PROP_TAG( PT_TSTRING,   0x0C1A)
#define PR_SENDER_NAME_W                            PROP_TAG( PT_UNICODE,   0x0C1A)
#define PR_SENDER_NAME_A                            PROP_TAG( PT_STRING8,   0x0C1A)
#define PR_SUPPLEMENTARY_INFO                       PROP_TAG( PT_TSTRING,   0x0C1B)
#define PR_SUPPLEMENTARY_INFO_W                     PROP_TAG( PT_UNICODE,   0x0C1B)
#define PR_SUPPLEMENTARY_INFO_A                     PROP_TAG( PT_STRING8,   0x0C1B)
#define PR_TYPE_OF_MTS_USER                         PROP_TAG( PT_LONG,      0x0C1C)
#define PR_SENDER_SEARCH_KEY                        PROP_TAG( PT_BINARY,    0x0C1D)
#define PR_SENDER_ADDRTYPE                          PROP_TAG( PT_TSTRING,   0x0C1E)
#define PR_SENDER_ADDRTYPE_W                        PROP_TAG( PT_UNICODE,   0x0C1E)
#define PR_SENDER_ADDRTYPE_A                        PROP_TAG( PT_STRING8,   0x0C1E)
#define PR_SENDER_EMAIL_ADDRESS                     PROP_TAG( PT_TSTRING,   0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_W                   PROP_TAG( PT_UNICODE,   0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_A                   PROP_TAG( PT_STRING8,   0x0C1F)

/*
 *  Message non-transmittable properties
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

#define PR_CURRENT_VERSION                          PROP_TAG( PT_I8,        0x0E00)
#define PR_DELETE_AFTER_SUBMIT                      PROP_TAG( PT_BOOLEAN,   0x0E01)
#define PR_DISPLAY_BCC                              PROP_TAG( PT_TSTRING,   0x0E02)
#define PR_DISPLAY_BCC_W                            PROP_TAG( PT_UNICODE,   0x0E02)
#define PR_DISPLAY_BCC_A                            PROP_TAG( PT_STRING8,   0x0E02)
#define PR_DISPLAY_CC                               PROP_TAG( PT_TSTRING,   0x0E03)
#define PR_DISPLAY_CC_W                             PROP_TAG( PT_UNICODE,   0x0E03)
#define PR_DISPLAY_CC_A                             PROP_TAG( PT_STRING8,   0x0E03)
#define PR_DISPLAY_TO                               PROP_TAG( PT_TSTRING,   0x0E04)
#define PR_DISPLAY_TO_W                             PROP_TAG( PT_UNICODE,   0x0E04)
#define PR_DISPLAY_TO_A                             PROP_TAG( PT_STRING8,   0x0E04)
#define PR_PARENT_DISPLAY                           PROP_TAG( PT_TSTRING,   0x0E05)
#define PR_PARENT_DISPLAY_W                         PROP_TAG( PT_UNICODE,   0x0E05)
#define PR_PARENT_DISPLAY_A                         PROP_TAG( PT_STRING8,   0x0E05)
#define PR_MESSAGE_DELIVERY_TIME                    PROP_TAG( PT_SYSTIME,   0x0E06)
#define PR_MESSAGE_FLAGS                            PROP_TAG( PT_LONG,      0x0E07)
#define PR_MESSAGE_SIZE                             PROP_TAG( PT_LONG,      0x0E08)
#define PR_PARENT_ENTRYID                           PROP_TAG( PT_BINARY,    0x0E09)
#define PR_SENTMAIL_ENTRYID                         PROP_TAG( PT_BINARY,    0x0E0A)
#define PR_CORRELATE                                PROP_TAG( PT_BOOLEAN,   0x0E0C)
#define PR_CORRELATE_MTSID                          PROP_TAG( PT_BINARY,    0x0E0D)
#define PR_DISCRETE_VALUES                          PROP_TAG( PT_BOOLEAN,   0x0E0E)
#define PR_RESPONSIBILITY                           PROP_TAG( PT_BOOLEAN,   0x0E0F)
#define PR_SPOOLER_STATUS                           PROP_TAG( PT_LONG,      0x0E10)
#define PR_TRANSPORT_STATUS                         PROP_TAG( PT_LONG,      0x0E11)
#define PR_MESSAGE_RECIPIENTS                       PROP_TAG( PT_OBJECT,    0x0E12)
#define PR_MESSAGE_ATTACHMENTS                      PROP_TAG( PT_OBJECT,    0x0E13)
#define PR_SUBMIT_FLAGS                             PROP_TAG( PT_LONG,      0x0E14)
#define PR_RECIPIENT_STATUS                         PROP_TAG( PT_LONG,      0x0E15)
#define PR_TRANSPORT_KEY                            PROP_TAG( PT_LONG,      0x0E16)
#define PR_MSG_STATUS                               PROP_TAG( PT_LONG,      0x0E17)
#define PR_MESSAGE_DOWNLOAD_TIME                    PROP_TAG( PT_LONG,      0x0E18)
#define PR_CREATION_VERSION                         PROP_TAG( PT_I8,        0x0E19)
#define PR_MODIFY_VERSION                           PROP_TAG( PT_I8,        0x0E1A)
#define PR_HASATTACH                                PROP_TAG( PT_BOOLEAN,   0x0E1B)
#define PR_BODY_CRC                                 PROP_TAG( PT_LONG,      0x0E1C)
#define PR_NORMALIZED_SUBJECT                       PROP_TAG( PT_TSTRING,   0x0E1D)
#define PR_NORMALIZED_SUBJECT_W                     PROP_TAG( PT_UNICODE,   0x0E1D)
#define PR_NORMALIZED_SUBJECT_A                     PROP_TAG( PT_STRING8,   0x0E1D)
#define PR_RTF_IN_SYNC                              PROP_TAG( PT_BOOLEAN,   0x0E1F)
#define PR_ATTACH_SIZE                              PROP_TAG( PT_LONG,      0x0E20)
#define PR_ATTACH_NUM                               PROP_TAG( PT_LONG,      0x0E21)
#define PR_PREPROCESS                               PROP_TAG( PT_BOOLEAN,   0x0E22)

/* PR_ORIGINAL_DISPLAY_TO, _CC, and _BCC moved to transmittible range 03/09/95 */

#define PR_ORIGINATING_MTA_CERTIFICATE              PROP_TAG( PT_BINARY,    0x0E25)
#define PR_PROOF_OF_SUBMISSION                      PROP_TAG( PT_BINARY,    0x0E26)


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  non-transmittable range for messages. They start at the high
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID                                  PROP_TAG( PT_BINARY,    0x0FFF)
#define PR_OBJECT_TYPE                              PROP_TAG( PT_LONG,      0x0FFE)
#define PR_ICON                                     PROP_TAG( PT_BINARY,    0x0FFD)
#define PR_MINI_ICON                                PROP_TAG( PT_BINARY,    0x0FFC)
#define PR_STORE_ENTRYID                            PROP_TAG( PT_BINARY,    0x0FFB)
#define PR_STORE_RECORD_KEY                         PROP_TAG( PT_BINARY,    0x0FFA)
#define PR_RECORD_KEY                               PROP_TAG( PT_BINARY,    0x0FF9)
#define PR_MAPPING_SIGNATURE                        PROP_TAG( PT_BINARY,    0x0FF8)
#define PR_ACCESS_LEVEL                             PROP_TAG( PT_LONG,      0x0FF7)
#define PR_INSTANCE_KEY                             PROP_TAG( PT_BINARY,    0x0FF6)
#define PR_ROW_TYPE                                 PROP_TAG( PT_LONG,      0x0FF5)
#define PR_ACCESS                                   PROP_TAG( PT_LONG,      0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID                                    PROP_TAG( PT_LONG,      0x3000)
#define PR_DISPLAY_NAME                             PROP_TAG( PT_TSTRING,   0x3001)
#define PR_DISPLAY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3001)
#define PR_DISPLAY_NAME_A                           PROP_TAG( PT_STRING8,   0x3001)
#define PR_ADDRTYPE                                 PROP_TAG( PT_TSTRING,   0x3002)
#define PR_ADDRTYPE_W                               PROP_TAG( PT_UNICODE,   0x3002)
#define PR_ADDRTYPE_A                               PROP_TAG( PT_STRING8,   0x3002)
#define PR_EMAIL_ADDRESS                            PROP_TAG( PT_TSTRING,   0x3003)
#define PR_EMAIL_ADDRESS_W                          PROP_TAG( PT_UNICODE,   0x3003)
#define PR_EMAIL_ADDRESS_A                          PROP_TAG( PT_STRING8,   0x3003)
#define PR_COMMENT                                  PROP_TAG( PT_TSTRING,   0x3004)
#define PR_COMMENT_W                                PROP_TAG( PT_UNICODE,   0x3004)
#define PR_COMMENT_A                                PROP_TAG( PT_STRING8,   0x3004)
#define PR_DEPTH                                    PROP_TAG( PT_LONG,      0x3005)
#define PR_PROVIDER_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3006)
#define PR_PROVIDER_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3006)
#define PR_PROVIDER_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3006)
#define PR_CREATION_TIME                            PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_LAST_MODIFICATION_TIME                   PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_RESOURCE_FLAGS                           PROP_TAG( PT_LONG,      0x3009)
#define PR_PROVIDER_DLL_NAME                        PROP_TAG( PT_TSTRING,   0x300A)
#define PR_PROVIDER_DLL_NAME_W                      PROP_TAG( PT_UNICODE,   0x300A)
#define PR_PROVIDER_DLL_NAME_A                      PROP_TAG( PT_STRING8,   0x300A)
#define PR_SEARCH_KEY                               PROP_TAG( PT_BINARY,    0x300B)
#define PR_PROVIDER_UID                             PROP_TAG( PT_BINARY,    0x300C)
#define PR_PROVIDER_ORDINAL                         PROP_TAG( PT_LONG,      0x300D)

/*
 *  MAPI Form properties
 */
#define PR_FORM_VERSION                             PROP_TAG(PT_TSTRING,    0x3301)
#define PR_FORM_VERSION_W                           PROP_TAG(PT_UNICODE,    0x3301)
#define PR_FORM_VERSION_A                           PROP_TAG(PT_STRING8,    0x3301)
#define PR_FORM_CLSID                               PROP_TAG(PT_CLSID,      0x3302)
#define PR_FORM_CONTACT_NAME                        PROP_TAG(PT_TSTRING,    0x3303)
#define PR_FORM_CONTACT_NAME_W                      PROP_TAG(PT_UNICODE,    0x3303)
#define PR_FORM_CONTACT_NAME_A                      PROP_TAG(PT_STRING8,    0x3303)
#define PR_FORM_CATEGORY                            PROP_TAG(PT_TSTRING,    0x3304)
#define PR_FORM_CATEGORY_W                          PROP_TAG(PT_UNICODE,    0x3304)
#define PR_FORM_CATEGORY_A                          PROP_TAG(PT_STRING8,    0x3304)
#define PR_FORM_CATEGORY_SUB                        PROP_TAG(PT_TSTRING,    0x3305)
#define PR_FORM_CATEGORY_SUB_W                      PROP_TAG(PT_UNICODE,    0x3305)
#define PR_FORM_CATEGORY_SUB_A                      PROP_TAG(PT_STRING8,    0x3305)
#define PR_FORM_HOST_MAP                            PROP_TAG(PT_MV_LONG,    0x3306)
#define PR_FORM_HIDDEN                              PROP_TAG(PT_BOOLEAN,    0x3307)
#define PR_FORM_DESIGNER_NAME                       PROP_TAG(PT_TSTRING,    0x3308)
#define PR_FORM_DESIGNER_NAME_W                     PROP_TAG(PT_UNICODE,    0x3308)
#define PR_FORM_DESIGNER_NAME_A                     PROP_TAG(PT_STRING8,    0x3308)
#define PR_FORM_DESIGNER_GUID                       PROP_TAG(PT_CLSID,      0x3309)
#define PR_FORM_MESSAGE_BEHAVIOR                    PROP_TAG(PT_LONG,       0x330A)

/*
 *  Message store properties
 */

#define PR_DEFAULT_STORE                            PROP_TAG( PT_BOOLEAN,   0x3400)
#define PR_STORE_SUPPORT_MASK                       PROP_TAG( PT_LONG,      0x340D)
#define PR_STORE_STATE                              PROP_TAG( PT_LONG,      0x340E)

#define PR_IPM_SUBTREE_SEARCH_KEY                   PROP_TAG( PT_BINARY,    0x3410)
#define PR_IPM_OUTBOX_SEARCH_KEY                    PROP_TAG( PT_BINARY,    0x3411)
#define PR_IPM_WASTEBASKET_SEARCH_KEY               PROP_TAG( PT_BINARY,    0x3412)
#define PR_IPM_SENTMAIL_SEARCH_KEY                  PROP_TAG( PT_BINARY,    0x3413)
#define PR_MDB_PROVIDER                             PROP_TAG( PT_BINARY,    0x3414)
#define PR_RECEIVE_FOLDER_SETTINGS                  PROP_TAG( PT_OBJECT,    0x3415)

#define PR_VALID_FOLDER_MASK                        PROP_TAG( PT_LONG,      0x35DF)
#define PR_IPM_SUBTREE_ENTRYID                      PROP_TAG( PT_BINARY,    0x35E0)

#define PR_IPM_OUTBOX_ENTRYID                       PROP_TAG( PT_BINARY,    0x35E2)
#define PR_IPM_WASTEBASKET_ENTRYID                  PROP_TAG( PT_BINARY,    0x35E3)
#define PR_IPM_SENTMAIL_ENTRYID                     PROP_TAG( PT_BINARY,    0x35E4)
#define PR_VIEWS_ENTRYID                            PROP_TAG( PT_BINARY,    0x35E5)
#define PR_COMMON_VIEWS_ENTRYID                     PROP_TAG( PT_BINARY,    0x35E6)
#define PR_FINDER_ENTRYID                           PROP_TAG( PT_BINARY,    0x35E7)

/* Proptags 0x35E8-0x35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS                          PROP_TAG( PT_LONG,      0x3600)
#define PR_FOLDER_TYPE                              PROP_TAG( PT_LONG,      0x3601)
#define PR_CONTENT_COUNT                            PROP_TAG( PT_LONG,      0x3602)
#define PR_CONTENT_UNREAD                           PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATE_TEMPLATES                         PROP_TAG( PT_OBJECT,    0x3604)
#define PR_DETAILS_TABLE                            PROP_TAG( PT_OBJECT,    0x3605)
#define PR_SEARCH                                   PROP_TAG( PT_OBJECT,    0x3607)
#define PR_SELECTABLE                               PROP_TAG( PT_BOOLEAN,   0x3609)
#define PR_SUBFOLDERS                               PROP_TAG( PT_BOOLEAN,   0x360A)
#define PR_STATUS                                   PROP_TAG( PT_LONG,      0x360B)
#define PR_ANR                                      PROP_TAG( PT_TSTRING,   0x360C)
#define PR_ANR_W                                    PROP_TAG( PT_UNICODE,   0x360C)
#define PR_ANR_A                                    PROP_TAG( PT_STRING8,   0x360C)
#define PR_CONTENTS_SORT_ORDER                      PROP_TAG( PT_MV_LONG,   0x360D)
#define PR_CONTAINER_HIERARCHY                      PROP_TAG( PT_OBJECT,    0x360E)
#define PR_CONTAINER_CONTENTS                       PROP_TAG( PT_OBJECT,    0x360F)
#define PR_FOLDER_ASSOCIATED_CONTENTS               PROP_TAG( PT_OBJECT,    0x3610)
#define PR_DEF_CREATE_DL                            PROP_TAG( PT_BINARY,    0x3611)
#define PR_DEF_CREATE_MAILUSER                      PROP_TAG( PT_BINARY,    0x3612)
#define PR_CONTAINER_CLASS                          PROP_TAG( PT_TSTRING,   0x3613)
#define PR_CONTAINER_CLASS_W                        PROP_TAG( PT_UNICODE,   0x3613)
#define PR_CONTAINER_CLASS_A                        PROP_TAG( PT_STRING8,   0x3613)
#define PR_CONTAINER_MODIFY_VERSION                 PROP_TAG( PT_I8,        0x3614)
#define PR_AB_PROVIDER_ID                           PROP_TAG( PT_BINARY,    0x3615)
#define PR_DEFAULT_VIEW_ENTRYID                     PROP_TAG( PT_BINARY,    0x3616)
#define PR_ASSOC_CONTENT_COUNT                      PROP_TAG( PT_LONG,      0x3617)

/* Reserved 0x36C0-0x36FF */

/*
 *  Attachment properties
 */

#define PR_ATTACHMENT_X400_PARAMETERS               PROP_TAG( PT_BINARY,    0x3700)
#define PR_ATTACH_DATA_OBJ                          PROP_TAG( PT_OBJECT,    0x3701)
#define PR_ATTACH_DATA_BIN                          PROP_TAG( PT_BINARY,    0x3701)
#define PR_ATTACH_ENCODING                          PROP_TAG( PT_BINARY,    0x3702)
#define PR_ATTACH_EXTENSION                         PROP_TAG( PT_TSTRING,   0x3703)
#define PR_ATTACH_EXTENSION_W                       PROP_TAG( PT_UNICODE,   0x3703)
#define PR_ATTACH_EXTENSION_A                       PROP_TAG( PT_STRING8,   0x3703)
#define PR_ATTACH_FILENAME                          PROP_TAG( PT_TSTRING,   0x3704)
#define PR_ATTACH_FILENAME_W                        PROP_TAG( PT_UNICODE,   0x3704)
#define PR_ATTACH_FILENAME_A                        PROP_TAG( PT_STRING8,   0x3704)
#define PR_ATTACH_METHOD                            PROP_TAG( PT_LONG,      0x3705)
#define PR_ATTACH_LONG_FILENAME                     PROP_TAG( PT_TSTRING,   0x3707)
#define PR_ATTACH_LONG_FILENAME_W                   PROP_TAG( PT_UNICODE,   0x3707)
#define PR_ATTACH_LONG_FILENAME_A                   PROP_TAG( PT_STRING8,   0x3707)
#define PR_ATTACH_PATHNAME                          PROP_TAG( PT_TSTRING,   0x3708)
#define PR_ATTACH_PATHNAME_W                        PROP_TAG( PT_UNICODE,   0x3708)
#define PR_ATTACH_PATHNAME_A                        PROP_TAG( PT_STRING8,   0x3708)
#define PR_ATTACH_RENDERING                         PROP_TAG( PT_BINARY,    0x3709)
#define PR_ATTACH_TAG                               PROP_TAG( PT_BINARY,    0x370A)
#define PR_RENDERING_POSITION                       PROP_TAG( PT_LONG,      0x370B)
#define PR_ATTACH_TRANSPORT_NAME                    PROP_TAG( PT_TSTRING,   0x370C)
#define PR_ATTACH_TRANSPORT_NAME_W                  PROP_TAG( PT_UNICODE,   0x370C)
#define PR_ATTACH_TRANSPORT_NAME_A                  PROP_TAG( PT_STRING8,   0x370C)
#define PR_ATTACH_LONG_PATHNAME                     PROP_TAG( PT_TSTRING,   0x370D)
#define PR_ATTACH_LONG_PATHNAME_W                   PROP_TAG( PT_UNICODE,   0x370D)
#define PR_ATTACH_LONG_PATHNAME_A                   PROP_TAG( PT_STRING8,   0x370D)
#define PR_ATTACH_MIME_TAG                          PROP_TAG( PT_TSTRING,   0x370E)
#define PR_ATTACH_MIME_TAG_W                        PROP_TAG( PT_UNICODE,   0x370E)
#define PR_ATTACH_MIME_TAG_A                        PROP_TAG( PT_STRING8,   0x370E)
#define PR_ATTACH_ADDITIONAL_INFO                   PROP_TAG( PT_BINARY,    0x370F)
#define PR_ATTACH_CONTENT_ID                        PROP_TAG( PT_TSTRING,   0x3712)
#define PR_ATTACH_CONTENT_ID_W                      PROP_TAG( PT_UNICODE,   0x3712)
#define PR_ATTACH_CONTENT_ID_A                      PROP_TAG( PT_STRING8,   0x3712)
#define PR_ATTACH_CONTENT_LOCATION                  PROP_TAG( PT_TSTRING,   0x3713)
#define PR_ATTACH_CONTENT_LOCATION_W                PROP_TAG( PT_UNICODE,   0x3713)
#define PR_ATTACH_CONTENT_LOCATION_A                PROP_TAG( PT_STRING8,   0x3713)


/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE                             PROP_TAG( PT_LONG,      0x3900)
#define PR_TEMPLATEID                               PROP_TAG( PT_BINARY,    0x3902)
#define PR_PRIMARY_CAPABILITY                       PROP_TAG( PT_BINARY,    0x3904)


/*
 *  Mail user properties
 */
#define PR_7BIT_DISPLAY_NAME                        PROP_TAG( PT_STRING8,   0x39FF)
#define PR_ACCOUNT                                  PROP_TAG( PT_TSTRING,   0x3A00)
#define PR_ACCOUNT_W                                PROP_TAG( PT_UNICODE,   0x3A00)
#define PR_ACCOUNT_A                                PROP_TAG( PT_STRING8,   0x3A00)
#define PR_ALTERNATE_RECIPIENT                      PROP_TAG( PT_BINARY,    0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A02)
#define PR_CONVERSION_PROHIBITED                    PROP_TAG( PT_BOOLEAN,   0x3A03)
#define PR_DISCLOSE_RECIPIENTS                      PROP_TAG( PT_BOOLEAN,   0x3A04)
#define PR_GENERATION                               PROP_TAG( PT_TSTRING,   0x3A05)
#define PR_GENERATION_W                             PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GENERATION_A                             PROP_TAG( PT_STRING8,   0x3A05)
#define PR_GIVEN_NAME                               PROP_TAG( PT_TSTRING,   0x3A06)
#define PR_GIVEN_NAME_W                             PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GIVEN_NAME_A                             PROP_TAG( PT_STRING8,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER                  PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W                PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A                PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER                    PROP_TAG( PT_TSTRING,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A                  PROP_TAG( PT_STRING8,   0x3A09)
#define PR_INITIALS                                 PROP_TAG( PT_TSTRING,   0x3A0A)
#define PR_INITIALS_W                               PROP_TAG( PT_UNICODE,   0x3A0A)
#define PR_INITIALS_A                               PROP_TAG( PT_STRING8,   0x3A0A)
#define PR_KEYWORD                                  PROP_TAG( PT_TSTRING,   0x3A0B)
#define PR_KEYWORD_W                                PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_KEYWORD_A                                PROP_TAG( PT_STRING8,   0x3A0B)
#define PR_LANGUAGE                                 PROP_TAG( PT_TSTRING,   0x3A0C)
#define PR_LANGUAGE_W                               PROP_TAG( PT_UNICODE,   0x3A0C)
#define PR_LANGUAGE_A                               PROP_TAG( PT_STRING8,   0x3A0C)
#define PR_LOCATION                                 PROP_TAG( PT_TSTRING,   0x3A0D)
#define PR_LOCATION_W                               PROP_TAG( PT_UNICODE,   0x3A0D)
#define PR_LOCATION_A                               PROP_TAG( PT_STRING8,   0x3A0D)
#define PR_MAIL_PERMISSION                          PROP_TAG( PT_BOOLEAN,   0x3A0E)
#define PR_MHS_COMMON_NAME                          PROP_TAG( PT_TSTRING,   0x3A0F)
#define PR_MHS_COMMON_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A0F)
#define PR_MHS_COMMON_NAME_A                        PROP_TAG( PT_STRING8,   0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A10)
#define PR_SURNAME                                  PROP_TAG( PT_TSTRING,   0x3A11)
#define PR_SURNAME_W                                PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_SURNAME_A                                PROP_TAG( PT_STRING8,   0x3A11)
#define PR_ORIGINAL_ENTRYID                         PROP_TAG( PT_BINARY,    0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME                    PROP_TAG( PT_TSTRING,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A                  PROP_TAG( PT_STRING8,   0x3A13)
#define PR_ORIGINAL_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3A14)
#define PR_POSTAL_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A15)
#define PR_POSTAL_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A15)
#define PR_POSTAL_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A15)
#define PR_COMPANY_NAME                             PROP_TAG( PT_TSTRING,   0x3A16)
#define PR_COMPANY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_COMPANY_NAME_A                           PROP_TAG( PT_STRING8,   0x3A16)
#define PR_TITLE                                    PROP_TAG( PT_TSTRING,   0x3A17)
#define PR_TITLE_W                                  PROP_TAG( PT_UNICODE,   0x3A17)
#define PR_TITLE_A                                  PROP_TAG( PT_STRING8,   0x3A17)
#define PR_DEPARTMENT_NAME                          PROP_TAG( PT_TSTRING,   0x3A18)
#define PR_DEPARTMENT_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DEPARTMENT_NAME_A                        PROP_TAG( PT_STRING8,   0x3A18)
#define PR_OFFICE_LOCATION                          PROP_TAG( PT_TSTRING,   0x3A19)
#define PR_OFFICE_LOCATION_W                        PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_LOCATION_A                        PROP_TAG( PT_STRING8,   0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER                 PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W               PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A               PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER                  PROP_TAG( PT_TSTRING,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W                PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A                PROP_TAG( PT_STRING8,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER                PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W              PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A              PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME                PROP_TAG( PT_TSTRING,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W              PROP_TAG( PT_UNICODE,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A              PROP_TAG( PT_STRING8,   0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER                  PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W                PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A                PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE                         PROP_TAG( PT_BINARY,    0x3A22)
#define PR_PRIMARY_FAX_NUMBER                       PROP_TAG( PT_TSTRING,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A                     PROP_TAG( PT_STRING8,   0x3A23)
#define PR_BUSINESS_FAX_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A24)
#define PR_HOME_FAX_NUMBER                          PROP_TAG( PT_TSTRING,   0x3A25)
#define PR_HOME_FAX_NUMBER_W                        PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_FAX_NUMBER_A                        PROP_TAG( PT_STRING8,   0x3A25)
#define PR_COUNTRY                                  PROP_TAG( PT_TSTRING,   0x3A26)
#define PR_COUNTRY_W                                PROP_TAG( PT_UNICODE,   0x3A26)
#define PR_COUNTRY_A                                PROP_TAG( PT_STRING8,   0x3A26)
#define PR_BUSINESS_ADDRESS_COUNTRY                 PR_COUNTRY
#define PR_BUSINESS_ADDRESS_COUNTRY_W               PR_COUNTRY_W
#define PR_BUSINESS_ADDRESS_COUNTRY_A               PR_COUNTRY_A

#define PR_LOCALITY                                 PROP_TAG( PT_TSTRING,   0x3A27)
#define PR_LOCALITY_W                               PROP_TAG( PT_UNICODE,   0x3A27)
#define PR_LOCALITY_A                               PROP_TAG( PT_STRING8,   0x3A27)
#define PR_BUSINESS_ADDRESS_CITY                    PR_LOCALITY
#define PR_BUSINESS_ADDRESS_CITY_W                  PR_LOCALITY_W
#define PR_BUSINESS_ADDRESS_CITY_A                  PR_LOCALITY_A

#define PR_STATE_OR_PROVINCE                        PROP_TAG( PT_TSTRING,   0x3A28)
#define PR_STATE_OR_PROVINCE_W                      PROP_TAG( PT_UNICODE,   0x3A28)
#define PR_STATE_OR_PROVINCE_A                      PROP_TAG( PT_STRING8,   0x3A28)
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE       PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W     PR_STATE_OR_PROVINCE_W
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A     PR_STATE_OR_PROVINCE_A

#define PR_STREET_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A29)
#define PR_STREET_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A29)
#define PR_STREET_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A29)
#define PR_BUSINESS_ADDRESS_STREET                  PR_STREET_ADDRESS
#define PR_BUSINESS_ADDRESS_STREET_W                PR_STREET_ADDRESS_W
#define PR_BUSINESS_ADDRESS_STREET_A                PR_STREET_ADDRESS_A

#define PR_POSTAL_CODE                              PROP_TAG( PT_TSTRING,   0x3A2A)
#define PR_POSTAL_CODE_W                            PROP_TAG( PT_UNICODE,   0x3A2A)
#define PR_POSTAL_CODE_A                            PROP_TAG( PT_STRING8,   0x3A2A)
#define PR_BUSINESS_ADDRESS_POSTAL_CODE             PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_W           PR_POSTAL_CODE_W
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_A           PR_POSTAL_CODE_A


#define PR_POST_OFFICE_BOX                          PROP_TAG( PT_TSTRING,   0x3A2B)
#define PR_POST_OFFICE_BOX_W                        PROP_TAG( PT_UNICODE,   0x3A2B)
#define PR_POST_OFFICE_BOX_A                        PROP_TAG( PT_STRING8,   0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX         PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W       PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A       PR_POST_OFFICE_BOX_A


#define PR_TELEX_NUMBER                             PROP_TAG( PT_TSTRING,   0x3A2C)
#define PR_TELEX_NUMBER_W                           PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TELEX_NUMBER_A                           PROP_TAG( PT_STRING8,   0x3A2C)
#define PR_ISDN_NUMBER                              PROP_TAG( PT_TSTRING,   0x3A2D)
#define PR_ISDN_NUMBER_W                            PROP_TAG( PT_UNICODE,   0x3A2D)
#define PR_ISDN_NUMBER_A                            PROP_TAG( PT_STRING8,   0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A2F)
#define PR_ASSISTANT                                PROP_TAG( PT_TSTRING,   0x3A30)
#define PR_ASSISTANT_W                              PROP_TAG( PT_UNICODE,   0x3A30)
#define PR_ASSISTANT_A                              PROP_TAG( PT_STRING8,   0x3A30)
#define PR_SEND_RICH_INFO                           PROP_TAG( PT_BOOLEAN,   0x3A40)

#define PR_WEDDING_ANNIVERSARY                      PROP_TAG( PT_SYSTIME, 0x3A41)
#define PR_BIRTHDAY                                 PROP_TAG( PT_SYSTIME, 0x3A42)


#define PR_HOBBIES                                  PROP_TAG( PT_TSTRING, 0x3A43)
#define PR_HOBBIES_W                                PROP_TAG( PT_UNICODE, 0x3A43)
#define PR_HOBBIES_A                                PROP_TAG( PT_STRING8, 0x3A43)

#define PR_MIDDLE_NAME                              PROP_TAG( PT_TSTRING, 0x3A44)
#define PR_MIDDLE_NAME_W                            PROP_TAG( PT_UNICODE, 0x3A44)
#define PR_MIDDLE_NAME_A                            PROP_TAG( PT_STRING8, 0x3A44)

#define PR_DISPLAY_NAME_PREFIX                      PROP_TAG( PT_TSTRING, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W                    PROP_TAG( PT_UNICODE, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A                    PROP_TAG( PT_STRING8, 0x3A45)

#define PR_PROFESSION                               PROP_TAG( PT_TSTRING, 0x3A46)
#define PR_PROFESSION_W                             PROP_TAG( PT_UNICODE, 0x3A46)
#define PR_PROFESSION_A                             PROP_TAG( PT_STRING8, 0x3A46)

#define PR_PREFERRED_BY_NAME                        PROP_TAG( PT_TSTRING, 0x3A47)
#define PR_PREFERRED_BY_NAME_W                      PROP_TAG( PT_UNICODE, 0x3A47)
#define PR_PREFERRED_BY_NAME_A                      PROP_TAG( PT_STRING8, 0x3A47)

#define PR_SPOUSE_NAME                              PROP_TAG( PT_TSTRING, 0x3A48)
#define PR_SPOUSE_NAME_W                            PROP_TAG( PT_UNICODE, 0x3A48)
#define PR_SPOUSE_NAME_A                            PROP_TAG( PT_STRING8, 0x3A48)

#define PR_COMPUTER_NETWORK_NAME                    PROP_TAG( PT_TSTRING, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W                  PROP_TAG( PT_UNICODE, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A                  PROP_TAG( PT_STRING8, 0x3A49)

#define PR_CUSTOMER_ID                              PROP_TAG( PT_TSTRING, 0x3A4A)
#define PR_CUSTOMER_ID_W                            PROP_TAG( PT_UNICODE, 0x3A4A)
#define PR_CUSTOMER_ID_A                            PROP_TAG( PT_STRING8, 0x3A4A)

#define PR_TTYTDD_PHONE_NUMBER                      PROP_TAG( PT_TSTRING, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W                    PROP_TAG( PT_UNICODE, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A                    PROP_TAG( PT_STRING8, 0x3A4B)

#define PR_FTP_SITE                                 PROP_TAG( PT_TSTRING, 0x3A4C)
#define PR_FTP_SITE_W                               PROP_TAG( PT_UNICODE, 0x3A4C)
#define PR_FTP_SITE_A                               PROP_TAG( PT_STRING8, 0x3A4C)

#define PR_GENDER                                   PROP_TAG( PT_SHORT, 0x3A4D)

#define PR_MANAGER_NAME                             PROP_TAG( PT_TSTRING, 0x3A4E)
#define PR_MANAGER_NAME_W                           PROP_TAG( PT_UNICODE, 0x3A4E)
#define PR_MANAGER_NAME_A                           PROP_TAG( PT_STRING8, 0x3A4E)

#define PR_NICKNAME                                 PROP_TAG( PT_TSTRING, 0x3A4F)
#define PR_NICKNAME_W                               PROP_TAG( PT_UNICODE, 0x3A4F)
#define PR_NICKNAME_A                               PROP_TAG( PT_STRING8, 0x3A4F)

#define PR_PERSONAL_HOME_PAGE                       PROP_TAG( PT_TSTRING, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_W                     PROP_TAG( PT_UNICODE, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_A                     PROP_TAG( PT_STRING8, 0x3A50)


#define PR_BUSINESS_HOME_PAGE                       PROP_TAG( PT_TSTRING, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_W                     PROP_TAG( PT_UNICODE, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_A                     PROP_TAG( PT_STRING8, 0x3A51)

#define PR_CONTACT_VERSION                          PROP_TAG( PT_CLSID, 0x3A52)
#define PR_CONTACT_ENTRYIDS                         PROP_TAG( PT_MV_BINARY, 0x3A53)

#define PR_CONTACT_ADDRTYPES                        PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W                      PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A                      PROP_TAG( PT_MV_STRING8, 0x3A54)

#define PR_CONTACT_DEFAULT_ADDRESS_INDEX            PROP_TAG( PT_LONG, 0x3A55)

#define PR_CONTACT_EMAIL_ADDRESSES                  PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W                PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A                PROP_TAG( PT_MV_STRING8, 0x3A56)


#define PR_COMPANY_MAIN_PHONE_NUMBER                PROP_TAG( PT_TSTRING, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W              PROP_TAG( PT_UNICODE, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A              PROP_TAG( PT_STRING8, 0x3A57)

#define PR_CHILDRENS_NAMES                          PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W                        PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A                        PROP_TAG( PT_MV_STRING8, 0x3A58)



#define PR_HOME_ADDRESS_CITY                        PROP_TAG( PT_TSTRING, 0x3A59)
#define PR_HOME_ADDRESS_CITY_W                      PROP_TAG( PT_UNICODE, 0x3A59)
#define PR_HOME_ADDRESS_CITY_A                      PROP_TAG( PT_STRING8, 0x3A59)

#define PR_HOME_ADDRESS_COUNTRY                     PROP_TAG( PT_TSTRING, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W                   PROP_TAG( PT_UNICODE, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A                   PROP_TAG( PT_STRING8, 0x3A5A)

#define PR_HOME_ADDRESS_POSTAL_CODE                 PROP_TAG( PT_TSTRING, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W               PROP_TAG( PT_UNICODE, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A               PROP_TAG( PT_STRING8, 0x3A5B)

#define PR_HOME_ADDRESS_STATE_OR_PROVINCE           PROP_TAG( PT_TSTRING, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W         PROP_TAG( PT_UNICODE, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A         PROP_TAG( PT_STRING8, 0x3A5C)

#define PR_HOME_ADDRESS_STREET                      PROP_TAG( PT_TSTRING, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_W                    PROP_TAG( PT_UNICODE, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_A                    PROP_TAG( PT_STRING8, 0x3A5D)

#define PR_HOME_ADDRESS_POST_OFFICE_BOX             PROP_TAG( PT_TSTRING, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W           PROP_TAG( PT_UNICODE, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A           PROP_TAG( PT_STRING8, 0x3A5E)

#define PR_OTHER_ADDRESS_CITY                       PROP_TAG( PT_TSTRING, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W                     PROP_TAG( PT_UNICODE, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A                     PROP_TAG( PT_STRING8, 0x3A5F)

#define PR_OTHER_ADDRESS_COUNTRY                    PROP_TAG( PT_TSTRING, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W                  PROP_TAG( PT_UNICODE, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A                  PROP_TAG( PT_STRING8, 0x3A60)

#define PR_OTHER_ADDRESS_POSTAL_CODE                PROP_TAG( PT_TSTRING, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W              PROP_TAG( PT_UNICODE, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A              PROP_TAG( PT_STRING8, 0x3A61)

#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE          PROP_TAG( PT_TSTRING, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W        PROP_TAG( PT_UNICODE, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A        PROP_TAG( PT_STRING8, 0x3A62)

#define PR_OTHER_ADDRESS_STREET                     PROP_TAG( PT_TSTRING, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_W                   PROP_TAG( PT_UNICODE, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_A                   PROP_TAG( PT_STRING8, 0x3A63)

#define PR_OTHER_ADDRESS_POST_OFFICE_BOX            PROP_TAG( PT_TSTRING, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W          PROP_TAG( PT_UNICODE, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A          PROP_TAG( PT_STRING8, 0x3A64)


/*
 *  Profile section properties
 */

#define PR_STORE_PROVIDERS                          PROP_TAG( PT_BINARY,    0x3D00)
#define PR_AB_PROVIDERS                             PROP_TAG( PT_BINARY,    0x3D01)
#define PR_TRANSPORT_PROVIDERS                      PROP_TAG( PT_BINARY,    0x3D02)

#define PR_DEFAULT_PROFILE                          PROP_TAG( PT_BOOLEAN,   0x3D04)
#define PR_AB_SEARCH_PATH                           PROP_TAG( PT_MV_BINARY, 0x3D05)
#define PR_AB_DEFAULT_DIR                           PROP_TAG( PT_BINARY,    0x3D06)
#define PR_AB_DEFAULT_PAB                           PROP_TAG( PT_BINARY,    0x3D07)

#define PR_FILTERING_HOOKS                          PROP_TAG( PT_BINARY,    0x3D08)
#define PR_SERVICE_NAME                             PROP_TAG( PT_TSTRING,   0x3D09)
#define PR_SERVICE_NAME_W                           PROP_TAG( PT_UNICODE,   0x3D09)
#define PR_SERVICE_NAME_A                           PROP_TAG( PT_STRING8,   0x3D09)
#define PR_SERVICE_DLL_NAME                         PROP_TAG( PT_TSTRING,   0x3D0A)
#define PR_SERVICE_DLL_NAME_W                       PROP_TAG( PT_UNICODE,   0x3D0A)
#define PR_SERVICE_DLL_NAME_A                       PROP_TAG( PT_STRING8,   0x3D0A)
#define PR_SERVICE_ENTRY_NAME                       PROP_TAG( PT_STRING8,   0x3D0B)
#define PR_SERVICE_UID                              PROP_TAG( PT_BINARY,    0x3D0C)
#define PR_SERVICE_EXTRA_UIDS                       PROP_TAG( PT_BINARY,    0x3D0D)
#define PR_SERVICES                                 PROP_TAG( PT_BINARY,    0x3D0E)
#define PR_SERVICE_SUPPORT_FILES                    PROP_TAG( PT_MV_TSTRING, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_W                  PROP_TAG( PT_MV_UNICODE, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_A                  PROP_TAG( PT_MV_STRING8, 0x3D0F)
#define PR_SERVICE_DELETE_FILES                     PROP_TAG( PT_MV_TSTRING, 0x3D10)
#define PR_SERVICE_DELETE_FILES_W                   PROP_TAG( PT_MV_UNICODE, 0x3D10)
#define PR_SERVICE_DELETE_FILES_A                   PROP_TAG( PT_MV_STRING8, 0x3D10)
#define PR_AB_SEARCH_PATH_UPDATE                    PROP_TAG( PT_BINARY,     0x3D11)
#define PR_PROFILE_NAME                             PROP_TAG( PT_TSTRING,   0x3D12)
#define PR_PROFILE_NAME_A                           PROP_TAG( PT_STRING8,   0x3D12)
#define PR_PROFILE_NAME_W                           PROP_TAG( PT_UNICODE,   0x3D12)

/*
 *  Status object properties
 */

#define PR_IDENTITY_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3E00)
#define PR_IDENTITY_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3E00)
#define PR_IDENTITY_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3E00)
#define PR_IDENTITY_ENTRYID                         PROP_TAG( PT_BINARY,    0x3E01)
#define PR_RESOURCE_METHODS                         PROP_TAG( PT_LONG,      0x3E02)
#define PR_RESOURCE_TYPE                            PROP_TAG( PT_LONG,      0x3E03)
#define PR_STATUS_CODE                              PROP_TAG( PT_LONG,      0x3E04)
#define PR_IDENTITY_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3E05)
#define PR_OWN_STORE_ENTRYID                        PROP_TAG( PT_BINARY,    0x3E06)
#define PR_RESOURCE_PATH                            PROP_TAG( PT_TSTRING,   0x3E07)
#define PR_RESOURCE_PATH_W                          PROP_TAG( PT_UNICODE,   0x3E07)
#define PR_RESOURCE_PATH_A                          PROP_TAG( PT_STRING8,   0x3E07)
#define PR_STATUS_STRING                            PROP_TAG( PT_TSTRING,   0x3E08)
#define PR_STATUS_STRING_W                          PROP_TAG( PT_UNICODE,   0x3E08)
#define PR_STATUS_STRING_A                          PROP_TAG( PT_STRING8,   0x3E08)
#define PR_X400_DEFERRED_DELIVERY_CANCEL            PROP_TAG( PT_BOOLEAN,   0x3E09)
#define PR_HEADER_FOLDER_ENTRYID                    PROP_TAG( PT_BINARY,    0x3E0A)
#define PR_REMOTE_PROGRESS                          PROP_TAG( PT_LONG,      0x3E0B)
#define PR_REMOTE_PROGRESS_TEXT                     PROP_TAG( PT_TSTRING,   0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_W                   PROP_TAG( PT_UNICODE,   0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_A                   PROP_TAG( PT_STRING8,   0x3E0C)
#define PR_REMOTE_VALIDATE_OK                       PROP_TAG( PT_BOOLEAN,   0x3E0D)

/*
 * Display table properties
 */

#define PR_CONTROL_FLAGS                            PROP_TAG( PT_LONG,      0x3F00)
#define PR_CONTROL_STRUCTURE                        PROP_TAG( PT_BINARY,    0x3F01)
#define PR_CONTROL_TYPE                             PROP_TAG( PT_LONG,      0x3F02)
#define PR_DELTAX                                   PROP_TAG( PT_LONG,      0x3F03)
#define PR_DELTAY                                   PROP_TAG( PT_LONG,      0x3F04)
#define PR_XPOS                                     PROP_TAG( PT_LONG,      0x3F05)
#define PR_YPOS                                     PROP_TAG( PT_LONG,      0x3F06)
#define PR_CONTROL_ID                               PROP_TAG( PT_BINARY,    0x3F07)
#define PR_INITIAL_DETAILS_PANE                     PROP_TAG( PT_LONG,      0x3F08)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN                          0x67F0
#define PROP_ID_SECURE_MAX                          0x67FF


#endif  /* MAPITAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\marqinfo.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Thu Mar 28 23:04:03 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __marqinfo_h__
#define __marqinfo_h__

#ifdef __cplusplus
extern "C"{
#endif

extern const __declspec(selectany) IID IID_IMarqueeInfo = {0x0bdc6ae0,0x6d11,0x11cf,{0xbe,0x62,0x00,0x80,0xc7,0x2e,0xdd,0x2d}};
/* Forward Declarations */

#ifndef __IMarqueeInfo_FWD_DEFINED__
#define __IMarqueeInfo_FWD_DEFINED__
typedef interface IMarqueeInfo IMarqueeInfo;
#endif 	/* __IMarqueeInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Mar 28 23:04:03 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */


			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMarqueeInfo_INTERFACE_DEFINED__
#define __IMarqueeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMarqueeInfo
 * at Thu Mar 28 23:04:03 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */


#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMarqueeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetDocCoords(
            /* [out] */ LPRECT prcView,
            /* [in] */ BOOL bGetOnlyIfFullyLoaded,
            /* [out] */ BOOL __RPC_FAR *pfFullyLoaded,
            /* [in] */ int WidthToFormatPageTo) = 0;

    };

#else 	/* C style interface */

    typedef struct IMarqueeInfoVtbl
    {

        HRESULT ( __stdcall __RPC_FAR *QueryInterface )(
            IMarqueeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( __stdcall __RPC_FAR *AddRef )(
            IMarqueeInfo __RPC_FAR * This);

        ULONG ( __stdcall __RPC_FAR *Release )(
            IMarqueeInfo __RPC_FAR * This);

        HRESULT ( __stdcall __RPC_FAR *GetDocCoords )(
            IMarqueeInfo __RPC_FAR * This,
            /* [out] */ LPRECT prcView,
            /* [in] */ BOOL bGetOnlyIfFullyLoaded,
            /* [out] */ BOOL __RPC_FAR *pfFullyLoaded,
            /* [in] */ int WidthToFormatPageTo);

    } IMarqueeInfoVtbl;

    interface IMarqueeInfo
    {
        CONST_VTBL struct IMarqueeInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMarqueeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarqueeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarqueeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarqueeInfo_GetDocCoords(This,prcView,bGetOnlyIfFullyLoaded,pfFullyLoaded,WidthToFormatPageTo)	\
    (This)->lpVtbl -> GetDocCoords(This,prcView,bGetOnlyIfFullyLoaded,pfFullyLoaded,WidthToFormatPageTo)

#endif /* COBJMACROS */


#endif 	/* C style interface */

#endif 	/* __IMarqueeInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\math.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _MATH_H_
#define _MATH_H_

#include "stdlib.h"

#endif // _MATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mediabuf.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __MEDIABUF_H__
#define __MEDIABUF_H__

class CBaseMediaBuffer : public IMediaBuffer {
public:
   CBaseMediaBuffer() {}
   CBaseMediaBuffer(BYTE *pData, ULONG ulSize, ULONG ulData) :
      m_pData(pData), m_ulSize(ulSize), m_ulData(ulData), m_cRef(1) {}
   STDMETHODIMP_(ULONG) AddRef() {
      return InterlockedIncrement((long*)&m_cRef);
   }
   STDMETHODIMP_(ULONG) Release() {
      long l = InterlockedDecrement((long*)&m_cRef);
      if (l == 0)
         delete this;
      return l;
   }
   STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {
      if (riid == IID_IUnknown) {
         AddRef();
         *ppv = (IUnknown*)this;
         return NOERROR;
      }
      else if (riid == IID_IMediaBuffer) {
         AddRef();
         *ppv = (IMediaBuffer*)this;
         return NOERROR;
      }
      else
         return E_NOINTERFACE;
   }
   STDMETHODIMP SetLength(DWORD ulLength) {m_ulData = ulLength; return NOERROR;}
   STDMETHODIMP GetMaxLength(DWORD *pcbMaxLength) {*pcbMaxLength = m_ulSize; return NOERROR;}
   STDMETHODIMP GetBufferAndLength(BYTE **ppBuffer, DWORD *pcbLength) {
      if (ppBuffer) *ppBuffer = m_pData;
      if (pcbLength) *pcbLength = m_ulData;
      return NOERROR;
   }
protected:
   BYTE *m_pData;
   ULONG m_ulSize;
   ULONG m_ulData;
   ULONG m_cRef;
};

#endif __MEDIABUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mediaerr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*  Shell error codes - should this be a .mc file? */

#ifndef _MEDIAERR_H_
#define _MEDIAERR_H_

#define DMO_E_INVALIDSTREAMINDEX 0x80040201
#define DMO_E_INVALIDTYPE        0x80040202
#define DMO_E_TYPE_NOT_SET       0x80040203
#define DMO_E_NOTACCEPTING       0x80040204
#define DMO_E_TYPE_NOT_ACCEPTED  0x80040205
#define DMO_E_NO_MORE_ITEMS      0x80040206

#endif _MEDIAERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\marshal.hpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _MARSHAL_HPP_INCLUDED_
#define _MARSHAL_HPP_INCLUDED_


// This class is a wrapper for CeOpenCallerBuffer / CeCloseCallerBuffer and
// CeAllocAsynchronousBuffer / CeFreeAsynchronousBuffer.
// You should only use it with embedded pointers that have NOT already been
// access-checked or marshalled by the kernel.  To duplicate a buffer that has
// already been marshalled, use DuplicatedBuffer_t.  To gain asynchronous
// access to a buffer that has already been marshalled, use AsynchronousBuffer_t.
class MarshalledBuffer_t {
private:
    PVOID  m_pLocalAsync;
    PVOID  m_pLocalSyncMarshalled;
    PVOID  m_pCallerUnmarshalled;
    DWORD  m_cbSize;
    DWORD  m_ArgumentDescriptor;
    
    void Reset() {
        m_pLocalSyncMarshalled = NULL;
        m_pLocalAsync = NULL;
        m_cbSize = 0;
    }

public:

    //
    // Access-checks and marshals a buffer pointer from the source process, so
    // that it may be accessed by the current process.  Exposes the marshalled
    // pointer via the ptr() accessor.  Any allocated resources related to the
    // marshalling are freed only by a subsequent call to Unmarshal(), or by the
    // destructor.
    //
    // Typically, you would either use the default constructor plus Marshal()
    // to marshal the buffer, or you would use the marshalling constructor to
    // accomplish the same task.  Use the former method if you require an
    // HRESULT.  Similarly, you can allow the destructor to release marshalling
    // resources, or use Unmarshal().  If an HRESULT is required, use the 
    // Unmarshal function.
    //

    MarshalledBuffer_t() {
        Reset();
    }

    ~MarshalledBuffer_t() {
        Unmarshal();
    }

    // Please see the description of CeOpenCallerBuffer and
    // CeAllocAsynchronousBuffer for more information about the operation of
    // this function.
    //
    // If marshalling fails, ptr() will return NULL and size() will return zero.
    // Otherwise the marshalled buffer will be accessible via ptr() and size().
    MarshalledBuffer_t(
        PVOID pSrcUnmarshalled,
        DWORD cbSrc,
        DWORD ArgumentDescriptor,
        BOOL  ForceDuplicate = TRUE,
        BOOL  Asynchronous = FALSE
        )
    {
        Reset();
        Marshal(pSrcUnmarshalled, cbSrc, ArgumentDescriptor, ForceDuplicate,
                Asynchronous);
    }

    // Takes a const pSrcUnmarshalled, can only be used with ARG_I_* types
    MarshalledBuffer_t(
        PCVOID pSrcUnmarshalled,
        DWORD cbSrc,
        DWORD ArgumentDescriptor,
        BOOL  ForceDuplicate = TRUE,
        BOOL  Asynchronous = FALSE
        )
    {
        Reset();
        Marshal(pSrcUnmarshalled, cbSrc, ArgumentDescriptor, ForceDuplicate,
                Asynchronous);
    }

    
    // Please see the description of CeOpenCallerBuffer and
    // CeAllocAsynchronousBuffer for more information about the operation of
    // this function.
    //
    // Once a MarshalledBuffer is marshalled (using the marshalling constructor
    // or the Marshal() method, it cannot be re-used by calling Marshal(), until
    // after Unmarshal() is called.  An attempt to do so will return
    // ERROR_ALREADY_EXISTS.
    //
    // If Marshal() fails, ptr() will return NULL and size() will return zero.
    // Otherwise the marshalled buffer will be accessible via ptr() and size().
    HRESULT
    Marshal(
        PVOID pSrcUnmarshalled,
        DWORD cbSrc,
        DWORD ArgumentDescriptor,
        BOOL  ForceDuplicate = TRUE,
        BOOL  Asynchronous = FALSE
        )
    {
        HRESULT result = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);

        if (!m_pLocalSyncMarshalled) {
            // First do the synchronous marshalling
            result = CeOpenCallerBuffer(&m_pLocalSyncMarshalled,
                                        pSrcUnmarshalled, cbSrc,
                                        ArgumentDescriptor, ForceDuplicate);
            if (SUCCEEDED(result)) {
                // These values will now be required in order to clean up
                m_pLocalAsync = NULL;
                m_pCallerUnmarshalled = pSrcUnmarshalled;
                m_cbSize = cbSrc;
                m_ArgumentDescriptor = ArgumentDescriptor;

                if (Asynchronous) {
                    result = CeAllocAsynchronousBuffer(&m_pLocalAsync,
                                                       m_pLocalSyncMarshalled,
                                                       cbSrc, ArgumentDescriptor);
                    if (!SUCCEEDED(result)) {
                        Unmarshal();
                    }
                }
            }
        }
        return result;
    }

    // Takes a const pSrcUnmarshalled, can only be used with ARG_I_* types
    HRESULT
    Marshal(
        PCVOID pSrcUnmarshalled,
        DWORD cbSrc,
        DWORD ArgumentDescriptor,
        BOOL  ForceDuplicate = TRUE,
        BOOL  Asynchronous = FALSE
        )
    {
        if (ArgumentDescriptor & ARG_O_BIT)
        {
            // Failure here means you are trying to marshal a const pointer as
            // an output parameter.

            return E_ACCESSDENIED;
        }

        return Marshal(const_cast<PVOID>(pSrcUnmarshalled),cbSrc,ArgumentDescriptor,ForceDuplicate,Asynchronous);
    }

    
    // Please see the description of CeFlushAsynchronousBuffer for more
    // information about the operation of this function.
    //
    // If the buffer has already been unmarshalled, or if it is not an
    // asynchronous buffer, Flush will fail with ERROR_INVALID_PARAMETER.
    HRESULT
    Flush()
    {
        HRESULT result = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        if (m_pLocalSyncMarshalled) {
            if (m_pLocalAsync) {
                result = CeFlushAsynchronousBuffer(m_pLocalAsync,
                                                   m_pLocalSyncMarshalled,
                                                   m_pCallerUnmarshalled,
                                                   m_cbSize, m_ArgumentDescriptor);
            }
        }
        return result;
    }


    // Please see the description of CeCloseCallerBuffer for more information
    // about the operation of this function.
    //
    // If the buffer has already been unmarshalled, Unmarshal will fail with
    // ERROR_ALREADY_EXISTS.
    HRESULT
    Unmarshal()
    {
        HRESULT result = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        BOOL fRet = FALSE;

        if (m_pLocalSyncMarshalled) {
            if (m_pLocalAsync) {
                CeFreeAsynchronousBuffer(m_pLocalAsync, m_pLocalSyncMarshalled,
                                         m_cbSize, m_ArgumentDescriptor);
            }

            fRet = CeImpersonateCurrentProcess();
            if (fRet)
            {
                result = CeCloseCallerBuffer(m_pLocalSyncMarshalled,
                                             m_pCallerUnmarshalled, m_cbSize,
                                             m_ArgumentDescriptor);
                CeRevertToSelf();
            }
            else
            {
                result = HRESULT_FROM_WIN32(GetLastError());
            }
            
            Reset();
        }
        return result;
    }

    // Returns a pointer to the marshalled buffer, or NULL if the buffer 
    // has not been marshalled or has already been unmarshalled.
    LPVOID ptr() const {
        if (m_pLocalAsync) {
            return m_pLocalAsync;
        }
        return m_pLocalSyncMarshalled;
    }

    // Returns the size of the marshalled buffer, or zero if the buffer 
    // has not been marshalled or has already been unmarshalled.
    DWORD size() const {
        return m_cbSize;
    }
};



namespace ce {
namespace marshal { 
namespace detail {

template <typename  alloc_traits>
class Buffer_t
{
private:
    PVOID  m_pLocal;
    PVOID  m_pCallerMarshalled;
    DWORD  m_cbSize;
    DWORD  m_ArgumentDescriptor;
    const alloc_traits m_Allocator;

    void Reset() {
        m_pLocal = NULL;
        m_pCallerMarshalled = NULL;
        m_cbSize = 0;
    }

public:

    Buffer_t()
    {
        Reset();
    }

    Buffer_t(
        PVOID  pSrcMarshalled,
        DWORD  cbSrc,
        DWORD  ArgumentDescriptor
        )
    {
        Reset();
        Allocate(pSrcMarshalled,cbSrc,ArgumentDescriptor);
    }

    // const version
    Buffer_t(
        PCVOID  pSrcMarshalled,
        DWORD  cbSrc,
        DWORD  ArgumentDescriptor
        )
    {
        Reset();
        Allocate(pSrcMarshalled,cbSrc,ArgumentDescriptor);
    }

    // Returns a pointer to the buffer, or NULL if the buffer has not
    // been allocated.
    LPVOID ptr() const {
        return m_pLocal;
    }

    // Returns the size of the buffer, or zero if the buffer has not
    // been allocated.
    DWORD size() const {
        return m_cbSize;
    }

    virtual ~Buffer_t() {
        Free();
        return;
    }

    HRESULT Free()
    {
        HRESULT result = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);

        if (m_pLocal) {
            result = m_Allocator.free(m_pLocal, 
                    m_pCallerMarshalled, m_cbSize, 
                    m_ArgumentDescriptor);
            Reset();
        }
        return result;

    }

    HRESULT Allocate(
        PVOID  pSrcMarshalled,
        DWORD  cbSrc,
        DWORD  ArgumentDescriptor
        )
    {
        HRESULT result = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        if (!m_pLocal) {
            result = m_Allocator.alloc(&m_pLocal, pSrcMarshalled, cbSrc, ArgumentDescriptor);
            if (SUCCEEDED(result)) {
                m_pCallerMarshalled = pSrcMarshalled;
                m_cbSize = cbSrc;
                m_ArgumentDescriptor = ArgumentDescriptor;
            }
        }
        return result;
    }

    HRESULT Allocate(
        PCVOID pSrcMarshalled,
        DWORD  cbSrc,
        DWORD  ArgumentDescriptor
        )
    {
        if (ArgumentDescriptor & ARG_O_BIT) {
            // Failure here means you are trying to marshal a const pointer as
            // an output parameter.
            return E_ACCESSDENIED;
        }

        return Allocate(const_cast<PVOID> (pSrcMarshalled),cbSrc,ArgumentDescriptor);
    }

    HRESULT Flush()
    {
        HRESULT result = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        if (m_pLocal) {
            result = m_Allocator.flush(m_pLocal, m_pCallerMarshalled, m_cbSize, 
                                       m_ArgumentDescriptor);
        }
        return result;
    }
};


class DuplicateTraits_t
{
public:
    HRESULT alloc(
            PVOID* ppDest,   
            PVOID  pSrc,      
            DWORD  cbSrc,                   
            DWORD  ArgumentDescriptor       
            ) const 
    {
        return CeAllocDuplicateBuffer(ppDest,pSrc,cbSrc,ArgumentDescriptor);
    }

    HRESULT free(
            PVOID  pDest,
            PVOID  pSrc, 
            DWORD  cbSrc,               
            DWORD  ArgumentDescriptor) const 
    {
        return CeFreeDuplicateBuffer(pDest,pSrc,cbSrc,ArgumentDescriptor);
    }

    HRESULT flush(
            PVOID  pDest,
            PVOID  pSrc, 
            DWORD  cbSrc,               
            DWORD  ArgumentDescriptor) const 
    {
        UNREFERENCED_PARAMETER (pDest);
        UNREFERENCED_PARAMETER (pSrc);
        UNREFERENCED_PARAMETER (cbSrc);
        UNREFERENCED_PARAMETER (ArgumentDescriptor);
        
        // Technically we should probably memcpy between src and dest here.
        return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }
};


class AsyncTraits_t
{
    public:
    HRESULT alloc(
            PVOID* ppDest,   
            PVOID  pSrc,      
            DWORD  cbSrc,                   
            DWORD  ArgumentDescriptor       
            ) const 
    {
        return CeAllocAsynchronousBuffer(ppDest,pSrc,cbSrc,ArgumentDescriptor);
    }

    HRESULT free(
            PVOID  pDest,
            PVOID  pSrc, 
            DWORD  cbSrc,               
            DWORD  ArgumentDescriptor) const 
    {
        return CeFreeAsynchronousBuffer(pDest,pSrc,cbSrc,ArgumentDescriptor);
    }
    
    HRESULT flush(
            PVOID  pDest,
            PVOID  pSrc, 
            DWORD  cbSrc,               
            DWORD  ArgumentDescriptor) const 
    {
        return CeFlushAsynchronousBuffer(pDest,pSrc,NULL,cbSrc,ArgumentDescriptor);
    }
};

};
};
};


// This class is a wrapper for CeAllocDuplicateBuffer / CeFreeDuplicateBuffer.
// It should only be called with API arguments that have already been
// access-checked and automatically marshalled (if necessary) by the kernel.
// All other duplication can be done by MarshalledBuffer_t.
//
// You can either call the constructor to do the duplication, or use
// the default constructor and then duplicate using the Allocate() method.
// If an HRESULT is required, use Allocate().  Similarly, you can allow the
// destructor to release the duplicate memory, or use the Free() method.  If
// an HRESULT is required, use Free().
//
// If Allocate() fails, ptr() will return NULL and size() will return zero.
// Otherwise the duplicated buffer will be accessible via ptr() and size().
//
// Once a DuplicatedBuffer is allocated (using the constructor or the
// Allocate() method), it cannot be re-used by calling Allocate(), until
// after Free() is called.  An attempt to do so will return
// ERROR_ALREADY_EXISTS.
//
// If the buffer is not currently allocated, Free() will fail with
// ERROR_ALREADY_EXISTS.
//
// Please see the description of CeAllocDuplicateBuffer and
// CeFreeDuplicateBuffer for more information about the operation of
// the Allocate() and Free() methods.
//
// Public methods are:
//      DuplicatedBuffer_t();
//      DuplicatedBuffer_t(PVOID  pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      DuplicatedBuffer_t(PCVOID pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      ~DuplicatedBuffer_t();
// 
//      HRESULT Free();
//      HRESULT Allocate(PVOID  pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      HRESULT Allocate(PCVOID pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
// 
//      LPVOID ptr() const;
//      DWORD size() const;

typedef ce::marshal::detail::Buffer_t<ce::marshal::detail::DuplicateTraits_t> DuplicatedBuffer_t;



// This class is a wrapper for CeAllocAsynchronousBuffer / 
// CeFreeAsynchronousBuffer.  It is meant to be used with pointers
// already access-checked or marshalled by the kernel that require
// asynchronous buffer access.  It should ONLY be used in kernel mode!
// See the description of CeAllocAsynchronousBuffer for information on how to
// access a buffer asynchronously in user mode.
//
// You can either call the constructor to allocate the async buffer, or use 
// the default constructor and then use the Allocate() method.
// If an HRESULT is required, use Allocate().  Similarly, you can allow the
// destructor to release the async buffer, or use the Free() method.  If
// an HRESULT is required, use Free().
//
// If Allocate() fails, ptr() will return NULL and size() will return zero.
// Otherwise the async buffer will be accessible via ptr() and size().
//
// Once an AsynchronousBuffer is allocated (using the constructor or the
// Allocate() method), it cannot be re-used by calling Allocate(), until
// after Free() is called.  An attempt to do so will return
// ERROR_ALREADY_EXISTS.
//
// If the buffer is not currently allocated, Free() will fail with
// ERROR_ALREADY_EXISTS.
//
// Please see the description of CeAllocAsynchronousBuffer and
// CeFreeAsynchronousBuffer for more information about the operation of
// the Allocate() and Free() methods.
//
// Public methods are:
//      AsynchronousBuffer_t();
//      AsynchronousBuffer_t(PVOID  pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      AsynchronousBuffer_t(PCVOID pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      ~AsynchronousBuffer_t();
// 
//      HRESULT Free();
//      HRESULT Allocate(PVOID  pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      HRESULT Allocate(PCVOID pSrcMarshalled, DWORD cbSrc, DWORD ArgumentDescriptor);
//      HRESULT Flush();
// 
//      LPVOID ptr() const;
//      DWORD size() const;
typedef ce::marshal::detail::Buffer_t<ce::marshal::detail::AsyncTraits_t> AsynchronousBuffer_t;


#endif  // _MARSHAL_HPP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\medialibraryconstants.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once


//string constants for known subtypes
//NOTE:: These strings have to be GUIDS in standard format.
#define MEDIA_LIBRARY_MEDIA_SUB_TYPE_MUSIC                          L"{825FACDF-114F-405f-8759-F67B537966B9}"
#define MEDIA_LIBRARY_MEDIA_SUB_TYPE_RECORDED_TV                    L"{64C98687-31CD-454f-B0C5-86100231B8F9}"
#define MEDIA_LIBRARY_MEDIA_SUB_TYPE_CAPTURED_VIDEO                 L"{DB62BAAA-7F9B-4a34-ABF8-9AE689940F51}"
#define MEDIA_LIBRARY_MEDIA_SUB_TYPE_PODCAST                        L"{03721E81-EB3F-41cd-AE9E-0E26036462F7}"
#define MEDIA_LIBRARY_MEDIA_SUB_TYPE_CAPTURED_PHOTOS                L"{8D580213-AB09-4821-A122-C79F565E4459}"
#define MEDIA_LIBRARY_MEDIA_SUB_TYPE_MUSIC_VIDEO                    L"{789250FB-057C-430f-B48C-92B3B1FAF21D}"

#define MEDIA_LIBRARY_MAXIMUM_METATADATA_LENGTH 100
#define MEDIA_LIBRARY_MAXIMUM_CONTAINER_METADATA_LENGTH MAX_PATH
#define MEDIA_LIBRARY_MAXIMUM_GUID_METATADATA_LENGTH 40


#define MEDIA_LIBRARY_METATADATA_VALUE_UNKNOWN L"MediaLibrary_Keyword_Unknown"


//THIS ENUM IS DEPRECATED
enum MediaLibraryQueries
{
    MEDIA_LIBRARY_QUERY_UNKNOWN = -1,
    MEDIA_LIBRARY_QUERY_MINIMUM  =0,    
    MEDIA_LIBRARY_QUERY_ITEM  =   MEDIA_LIBRARY_QUERY_MINIMUM,
    MEDIA_LIBRARY_QUERY_SERIES ,
    MEDIA_LIBRARY_QUERY_AUTHOR,
    MEDIA_LIBRARY_QUERY_TAG ,
    MEDIA_LIBRARY_QUERY_GENRE,
    MEDIA_LIBRARY_QUERY_MAXIMUM = MEDIA_LIBRARY_QUERY_GENRE
};

static const WCHAR * MediaLibraryOperationStrings [] = 
{
// the operations with 'like' take special handling
// but I think I need the place holders
    L" = ",
    L" > ",
    L" >= ",
    L" < " ,       
    L" <= " ,      
    L" != ",
    L" LIKE ",
    L" LIKE ",
    L" LIKE ",
    L" LIKE ",
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\medialibrary.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for MediaLibrary.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __MediaLibrary_h__
#define __MediaLibrary_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMediaObject_FWD_DEFINED__
#define __IMediaObject_FWD_DEFINED__
typedef interface IMediaObject IMediaObject;
#endif 	/* __IMediaObject_FWD_DEFINED__ */


#ifndef __IMediaObjectEnumerator_FWD_DEFINED__
#define __IMediaObjectEnumerator_FWD_DEFINED__
typedef interface IMediaObjectEnumerator IMediaObjectEnumerator;
#endif 	/* __IMediaObjectEnumerator_FWD_DEFINED__ */


#ifndef __IMediaVolume_FWD_DEFINED__
#define __IMediaVolume_FWD_DEFINED__
typedef interface IMediaVolume IMediaVolume;
#endif 	/* __IMediaVolume_FWD_DEFINED__ */


#ifndef __IMediaQuery_FWD_DEFINED__
#define __IMediaQuery_FWD_DEFINED__
typedef interface IMediaQuery IMediaQuery;
#endif 	/* __IMediaQuery_FWD_DEFINED__ */


#ifndef __ILibraryHandler_FWD_DEFINED__
#define __ILibraryHandler_FWD_DEFINED__
typedef interface ILibraryHandler ILibraryHandler;
#endif 	/* __ILibraryHandler_FWD_DEFINED__ */


#ifndef __LibraryHandler_FWD_DEFINED__
#define __LibraryHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class LibraryHandler LibraryHandler;
#else
typedef struct LibraryHandler LibraryHandler;
#endif /* __cplusplus */

#endif 	/* __LibraryHandler_FWD_DEFINED__ */


#ifndef __IMediaLibraryNotification_FWD_DEFINED__
#define __IMediaLibraryNotification_FWD_DEFINED__
typedef interface IMediaLibraryNotification IMediaLibraryNotification;
#endif 	/* __IMediaLibraryNotification_FWD_DEFINED__ */


#ifndef __IMediaLibraryNotificationListener_FWD_DEFINED__
#define __IMediaLibraryNotificationListener_FWD_DEFINED__
typedef interface IMediaLibraryNotificationListener IMediaLibraryNotificationListener;
#endif 	/* __IMediaLibraryNotificationListener_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_MediaLibrary_0000_0000 */
/* [local] */ 

typedef 
enum MediaLibraryObjects
    {	MEDIA_LIBRARY_OBJECT_TYPE_UNKNOWN	= 0,
	MEDIA_LIBRARY_OBJECT_TYPE_ITEM	= 0x10,
	MEDIA_LIBRARY_OBJECT_TYPE_SERIES	= 0x20,
	MEDIA_LIBRARY_OBJECT_TYPE_AUTHOR	= 0x40,
	MEDIA_LIBRARY_OBJECT_TYPE_TAG	= 0x80,
	MEDIA_LIBRARY_OBJECT_TYPE_GENRE	= 0x100,
	MEDIA_LIBRARY_OBJECT_TYPE_PLAYLIST	= 0x200,
	MEDIA_LIBRARY_OBJECT_TYPE_PLAYLIST_ITEM	= 0x400,
	MEDIA_LIBRARY_OBJECT_TYPE_MAX	= MEDIA_LIBRARY_OBJECT_TYPE_PLAYLIST_ITEM
    } 	MediaLibraryObjects;

typedef 
enum MediaLibraryEnumeratorType
    {	MEDIA_LIBRARY_ENUMERATOR_TYPE_UNKNOWN	= 0,
	MEDIA_LIBRARY_ENUMERATOR_TYPE_CACHED	= ( MEDIA_LIBRARY_ENUMERATOR_TYPE_UNKNOWN + 1 ) ,
	MEDIA_LIBRARY_ENUMERATOR_TYPE_NON_CACHED	= ( MEDIA_LIBRARY_ENUMERATOR_TYPE_CACHED + 1 ) 
    } 	MediaLibraryEnumeratorType;

typedef 
enum MediaLibraryMediaTypes
    {	MEDIA_LIBRARY_MEDIA_TYPE_UNKNOWN	= 0,
	MEDIA_LIBRARY_MEDIA_TYPE_AUDIO	= 1,
	MEDIA_LIBRARY_MEDIA_TYPE_VIDEO	= ( MEDIA_LIBRARY_MEDIA_TYPE_AUDIO + 1 ) ,
	MEDIA_LIBRARY_MEDIA_TYPE_IMAGE	= ( MEDIA_LIBRARY_MEDIA_TYPE_VIDEO + 1 ) 
    } 	MediaLibraryMediaTypes;

typedef 
enum MediaLibrarySeriesTypes
    {	MEDIA_LIBRARY_SERIES_TYPE_UNKNOWN	= 0,
	MEDIA_LIBRARY_SERIES_TYPE_AUDIOALBUM	= 1,
	MEDIA_LIBRARY_SERIES_TYPE_VIDEOALBUM	= ( MEDIA_LIBRARY_SERIES_TYPE_AUDIOALBUM + 1 ) ,
	MEDIA_LIBRARY_SERIES_TYPE_IMAGEALBUM	= ( MEDIA_LIBRARY_SERIES_TYPE_VIDEOALBUM + 1 ) ,
	MEDIA_LIBRARY_SERIES_TYPE_FILEFOLDER	= ( MEDIA_LIBRARY_SERIES_TYPE_IMAGEALBUM + 1 ) 
    } 	MediaLibrarySeriesTypes;

typedef 
enum MediaLibraryMethods
    {	MEDIA_LIBRARY_METHOD_TYPE_GET_PROPERTY	= 0,
	MEDIA_LIBRARY_METHOD_TYPE_SET_PROPERTY	= ( MEDIA_LIBRARY_METHOD_TYPE_GET_PROPERTY + 1 ) ,
	MEDIA_LIBRARY_METHOD_TYPE_ADD_PROPERTY	= ( MEDIA_LIBRARY_METHOD_TYPE_SET_PROPERTY + 1 ) ,
	MEDIA_LIBRARY_METHOD_TYPE_ADD_CONDITION	= ( MEDIA_LIBRARY_METHOD_TYPE_ADD_PROPERTY + 1 ) ,
	MEDIA_LIBRARY_METHOD_TYPE_MAX	= ( MEDIA_LIBRARY_METHOD_TYPE_ADD_CONDITION + 1 ) 
    } 	MediaLibraryMethods;

typedef 
enum MediaLibraryOperations
    {	MEDIA_LIBRARY_OPERATION_UNKNOWN	= -1,
	EQUALS	= 0,
	MEDIA_LIBRARY_OPS_MIN	= EQUALS,
	GREATER_THAN	= ( MEDIA_LIBRARY_OPS_MIN + 1 ) ,
	GREATER_THAN_OR_EQUALS	= ( GREATER_THAN + 1 ) ,
	LESS_THAN	= ( GREATER_THAN_OR_EQUALS + 1 ) ,
	LESS_THAN_OR_EQUALS	= ( LESS_THAN + 1 ) ,
	NOT_EQUALS	= ( LESS_THAN_OR_EQUALS + 1 ) ,
	MEDIA_LIBRARY_OPS_NON_STRING_MAX	= NOT_EQUALS,
	BEGINS_WITH	= ( MEDIA_LIBRARY_OPS_NON_STRING_MAX + 1 ) ,
	CONTAINS	= ( BEGINS_WITH + 1 ) ,
	NOT_BEGINS_WITH	= ( CONTAINS + 1 ) ,
	NOT_CONTAINS	= ( NOT_BEGINS_WITH + 1 ) ,
	MEDIA_LIBRARY_OPS_MAX	= NOT_CONTAINS
    } 	MediaLibraryOperations;

typedef 
enum MediaLibraryProperties
    {	MEDIA_LIBRARY_PROPERTY_UNKNOWN	= 0,
	MEDIA_LIBRARY_MEDIA_ITEM_ID	= ( MEDIA_LIBRARY_PROPERTY_UNKNOWN + 1 ) ,
	MEDIA_LIBRARY_PROPERTIES_MINIMUM	= MEDIA_LIBRARY_MEDIA_ITEM_ID,
	MEDIA_LIBRARY_MEDIA_ITEM_MEDIA_TYPE	= ( MEDIA_LIBRARY_PROPERTIES_MINIMUM + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_MEDIA_SUB_TYPE	= ( MEDIA_LIBRARY_MEDIA_ITEM_MEDIA_TYPE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_NAME	= ( MEDIA_LIBRARY_MEDIA_ITEM_MEDIA_SUB_TYPE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_SORT_NAME	= ( MEDIA_LIBRARY_MEDIA_ITEM_NAME + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_DESCRIPTION	= ( MEDIA_LIBRARY_MEDIA_ITEM_SORT_NAME + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_SERIES_ID	= ( MEDIA_LIBRARY_MEDIA_ITEM_DESCRIPTION + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_SEQUENCE_NUMBER	= ( MEDIA_LIBRARY_MEDIA_ITEM_SERIES_ID + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_DURATION	= ( MEDIA_LIBRARY_MEDIA_ITEM_SEQUENCE_NUMBER + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_UPDATETICKCOUNT	= ( MEDIA_LIBRARY_MEDIA_ITEM_DURATION + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_URL	= ( MEDIA_LIBRARY_MEDIA_ITEM_UPDATETICKCOUNT + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_FILE_SIZE	= ( MEDIA_LIBRARY_MEDIA_ITEM_URL + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_FILE_CREATION_TIME	= ( MEDIA_LIBRARY_MEDIA_ITEM_FILE_SIZE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_WIDTH	= ( MEDIA_LIBRARY_MEDIA_ITEM_FILE_CREATION_TIME + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_HEIGHT	= ( MEDIA_LIBRARY_MEDIA_ITEM_WIDTH + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_ORIENTATION	= ( MEDIA_LIBRARY_MEDIA_ITEM_HEIGHT + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_OBJECT_FORMAT	= ( MEDIA_LIBRARY_MEDIA_ITEM_ORIENTATION + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_RELEASE_DATE	= ( MEDIA_LIBRARY_MEDIA_ITEM_OBJECT_FORMAT + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_THUMBNAIL_URL	= ( MEDIA_LIBRARY_MEDIA_ITEM_RELEASE_DATE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_THUMBNAIL	= ( MEDIA_LIBRARY_MEDIA_ITEM_THUMBNAIL_URL + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_USER_RATING	= ( MEDIA_LIBRARY_MEDIA_ITEM_THUMBNAIL + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_PROVIDER_RATING	= ( MEDIA_LIBRARY_MEDIA_ITEM_USER_RATING + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_PARENTAL_RATING	= ( MEDIA_LIBRARY_MEDIA_ITEM_PROVIDER_RATING + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_IS_DRM_PROTECTED	= ( MEDIA_LIBRARY_MEDIA_ITEM_PARENTAL_RATING + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_PROTECTION_STATUS	= ( MEDIA_LIBRARY_MEDIA_ITEM_IS_DRM_PROTECTED + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_PURCHASED_FLAG	= ( MEDIA_LIBRARY_MEDIA_ITEM_PROTECTION_STATUS + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_CONTENT_PROVIDER	= ( MEDIA_LIBRARY_MEDIA_ITEM_PURCHASED_FLAG + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_CONTENT_ID	= ( MEDIA_LIBRARY_MEDIA_ITEM_CONTENT_PROVIDER + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_IS_LOCAL	= ( MEDIA_LIBRARY_MEDIA_ITEM_CONTENT_ID + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_CAN_STREAM	= ( MEDIA_LIBRARY_MEDIA_ITEM_IS_LOCAL + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_MARKED_FOR_DOWNLOAD	= ( MEDIA_LIBRARY_MEDIA_ITEM_CAN_STREAM + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_SYNC_TIME	= ( MEDIA_LIBRARY_MEDIA_ITEM_MARKED_FOR_DOWNLOAD + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_USE_COUNT	= ( MEDIA_LIBRARY_MEDIA_ITEM_SYNC_TIME + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LAST_MODIFIED	= ( MEDIA_LIBRARY_MEDIA_ITEM_USE_COUNT + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LAST_POSITION	= ( MEDIA_LIBRARY_MEDIA_ITEM_LAST_MODIFIED + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LAST_TIME_CHECKED	= ( MEDIA_LIBRARY_MEDIA_ITEM_LAST_POSITION + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_ERROR_STATE	= ( MEDIA_LIBRARY_MEDIA_ITEM_LAST_TIME_CHECKED + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_USER_DEF_1	= ( MEDIA_LIBRARY_MEDIA_ITEM_ERROR_STATE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_USER_DEF_2	= ( MEDIA_LIBRARY_MEDIA_ITEM_USER_DEF_1 + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_USER_DEF_3	= ( MEDIA_LIBRARY_MEDIA_ITEM_USER_DEF_2 + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_SAMPLE_RATE	= ( MEDIA_LIBRARY_MEDIA_ITEM_USER_DEF_3 + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_NUMBER_OF_CHANNELS	= ( MEDIA_LIBRARY_MEDIA_ITEM_SAMPLE_RATE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_AUDIO_WAVE_CODEC	= ( MEDIA_LIBRARY_MEDIA_ITEM_NUMBER_OF_CHANNELS + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_AUDIO_BIT_RATE	= ( MEDIA_LIBRARY_MEDIA_ITEM_AUDIO_WAVE_CODEC + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LONGITUDE_DEGREES	= ( MEDIA_LIBRARY_MEDIA_ITEM_AUDIO_BIT_RATE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LONGITUDE_MINUTES	= ( MEDIA_LIBRARY_MEDIA_ITEM_LONGITUDE_DEGREES + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LONGITUDE_SECONDS	= ( MEDIA_LIBRARY_MEDIA_ITEM_LONGITUDE_MINUTES + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LATITUDE_DEGREES	= ( MEDIA_LIBRARY_MEDIA_ITEM_LONGITUDE_SECONDS + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LATITUDE_MINUTES	= ( MEDIA_LIBRARY_MEDIA_ITEM_LATITUDE_DEGREES + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_LATITUDE_SECONDS	= ( MEDIA_LIBRARY_MEDIA_ITEM_LATITUDE_MINUTES + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_ALTITUDE	= ( MEDIA_LIBRARY_MEDIA_ITEM_LATITUDE_SECONDS + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_HEADING	= ( MEDIA_LIBRARY_MEDIA_ITEM_ALTITUDE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_SCAN_TYPE	= ( MEDIA_LIBRARY_MEDIA_ITEM_HEADING + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_FOUR_CC_CODEC	= ( MEDIA_LIBRARY_MEDIA_ITEM_SCAN_TYPE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_VIDEO_BIT_RATE	= ( MEDIA_LIBRARY_MEDIA_ITEM_FOUR_CC_CODEC + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_FRAME_RATE	= ( MEDIA_LIBRARY_MEDIA_ITEM_VIDEO_BIT_RATE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_KEY_FRAME_DISTANCE	= ( MEDIA_LIBRARY_MEDIA_ITEM_FRAME_RATE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_REC_TV_CHANNEL	= ( MEDIA_LIBRARY_MEDIA_ITEM_KEY_FRAME_DISTANCE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_REC_TIME	= ( MEDIA_LIBRARY_MEDIA_ITEM_REC_TV_CHANNEL + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_KEYBOARD_NAME_MAPPING1	= ( MEDIA_LIBRARY_MEDIA_ITEM_REC_TIME + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_KEYBOARD_NAME_MAPPING2	= ( MEDIA_LIBRARY_MEDIA_ITEM_KEYBOARD_NAME_MAPPING1 + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_UPLOAD_REFCOUNT	= ( MEDIA_LIBRARY_MEDIA_ITEM_KEYBOARD_NAME_MAPPING2 + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_UPLOAD_EXPIRATION	= ( MEDIA_LIBRARY_MEDIA_ITEM_UPLOAD_REFCOUNT + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_PUOID	= ( MEDIA_LIBRARY_MEDIA_ITEM_UPLOAD_EXPIRATION + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_AUTHOR	= ( MEDIA_LIBRARY_MEDIA_ITEM_PUOID + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_ENCODINGPROFILE	= ( MEDIA_LIBRARY_MEDIA_ITEM_AUTHOR + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_BITRATETYPE	= ( MEDIA_LIBRARY_MEDIA_ITEM_ENCODINGPROFILE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_PARENT_SERIES_ID	= ( MEDIA_LIBRARY_MEDIA_ITEM_BITRATETYPE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_NON_CONSUMABLE	= ( MEDIA_LIBRARY_MEDIA_ITEM_PARENT_SERIES_ID + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_ISPUBLIC	= ( MEDIA_LIBRARY_MEDIA_ITEM_NON_CONSUMABLE + 1 ) ,
	MEDIA_LIBRARY_MEDIA_ITEM_IS_CAPTURED	= ( MEDIA_LIBRARY_MEDIA_ITEM_ISPUBLIC + 1 ) ,
	MEDIA_LIBRARY_SERIES_ID	= ( MEDIA_LIBRARY_MEDIA_ITEM_IS_CAPTURED + 1 ) ,
	MEDIA_LIBRARY_SERIES_NAME	= ( MEDIA_LIBRARY_SERIES_ID + 1 ) ,
	MEDIA_LIBRARY_SERIES_SORT_NAME	= ( MEDIA_LIBRARY_SERIES_NAME + 1 ) ,
	MEDIA_LIBRARY_SERIES_PARENT_SERIES_ID	= ( MEDIA_LIBRARY_SERIES_SORT_NAME + 1 ) ,
	MEDIA_LIBRARY_SERIES_RELEASE_DATE	= ( MEDIA_LIBRARY_SERIES_PARENT_SERIES_ID + 1 ) ,
	MEDIA_LIBRARY_SERIES_THUMBNAIL_URL	= ( MEDIA_LIBRARY_SERIES_RELEASE_DATE + 1 ) ,
	MEDIA_LIBRARY_SERIES_THUMBNAIL	= ( MEDIA_LIBRARY_SERIES_THUMBNAIL_URL + 1 ) ,
	MEDIA_LIBRARY_SERIES_LAST_USE_TIME	= ( MEDIA_LIBRARY_SERIES_THUMBNAIL + 1 ) ,
	MEDIA_LIBRARY_SERIES_USER_DEF_1	= ( MEDIA_LIBRARY_SERIES_LAST_USE_TIME + 1 ) ,
	MEDIA_LIBRARY_SERIES_USER_DEF_2	= ( MEDIA_LIBRARY_SERIES_USER_DEF_1 + 1 ) ,
	MEDIA_LIBRARY_SERIES_USER_DEF_3	= ( MEDIA_LIBRARY_SERIES_USER_DEF_2 + 1 ) ,
	MEDIA_LIBRARY_SERIES_SERIES_AUTHOR	= ( MEDIA_LIBRARY_SERIES_USER_DEF_3 + 1 ) ,
	MEDIA_LIBRARY_SERIES_SERIES_AUTHOR_ID	= ( MEDIA_LIBRARY_SERIES_SERIES_AUTHOR + 1 ) ,
	MEDIA_LIBRARY_SERIES_KEYBOARD_NAME_MAPPING1	= ( MEDIA_LIBRARY_SERIES_SERIES_AUTHOR_ID + 1 ) ,
	MEDIA_LIBRARY_SERIES_KEYBOARD_NAME_MAPPING2	= ( MEDIA_LIBRARY_SERIES_KEYBOARD_NAME_MAPPING1 + 1 ) ,
	MEDIA_LIBRARY_SERIES_MTP_PUOID	= ( MEDIA_LIBRARY_SERIES_KEYBOARD_NAME_MAPPING2 + 1 ) ,
	MEDIA_LIBRARY_SERIES_FULLPATH	= ( MEDIA_LIBRARY_SERIES_MTP_PUOID + 1 ) ,
	MEDIA_LIBRARY_SERIES_SERIESTYPE	= ( MEDIA_LIBRARY_SERIES_FULLPATH + 1 ) ,
	MEDIA_LIBRARY_SERIES_CHILDREN_COUNT	= ( MEDIA_LIBRARY_SERIES_SERIESTYPE + 1 ) ,
	MEDIA_LIBRARY_SERIES_LINKEDITEM_COUNT	= ( MEDIA_LIBRARY_SERIES_CHILDREN_COUNT + 1 ) ,
	MEDIA_LIBRARY_GENRE_ID	= ( MEDIA_LIBRARY_SERIES_LINKEDITEM_COUNT + 1 ) ,
	MEDIA_LIBRARY_GENRE_NAME	= ( MEDIA_LIBRARY_GENRE_ID + 1 ) ,
	MEDIA_LIBRARY_GENRE_LINKEDSERIES_COUNT	= ( MEDIA_LIBRARY_GENRE_NAME + 1 ) ,
	MEDIA_LIBRARY_GENRE_LINKEDITEM_COUNT	= ( MEDIA_LIBRARY_GENRE_LINKEDSERIES_COUNT + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_ID	= ( MEDIA_LIBRARY_GENRE_LINKEDITEM_COUNT + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_NAME	= ( MEDIA_LIBRARY_AUTHOR_ID + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_SORT_NAME	= ( MEDIA_LIBRARY_AUTHOR_NAME + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_USER_DEF	= ( MEDIA_LIBRARY_AUTHOR_SORT_NAME + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_REPRESENTATIVE_THUMBNAIL	= ( MEDIA_LIBRARY_AUTHOR_USER_DEF + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_KEYBOARD_NAME_MAPPING1	= ( MEDIA_LIBRARY_AUTHOR_REPRESENTATIVE_THUMBNAIL + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_KEYBOARD_NAME_MAPPING2	= ( MEDIA_LIBRARY_AUTHOR_KEYBOARD_NAME_MAPPING1 + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_LINKEDSERIES_COUNT	= ( MEDIA_LIBRARY_AUTHOR_KEYBOARD_NAME_MAPPING2 + 1 ) ,
	MEDIA_LIBRARY_AUTHOR_LINKEDITEM_COUNT	= ( MEDIA_LIBRARY_AUTHOR_LINKEDSERIES_COUNT + 1 ) ,
	MEDIA_LIBRARY_TAG_ID	= ( MEDIA_LIBRARY_AUTHOR_LINKEDITEM_COUNT + 1 ) ,
	MEDIA_LIBRARY_TAG_NAME	= ( MEDIA_LIBRARY_TAG_ID + 1 ) ,
	MEDIA_LIBRARY_TAG_KEYBOARD_NAME_MAPPING1	= ( MEDIA_LIBRARY_TAG_NAME + 1 ) ,
	MEDIA_LIBRARY_TAG_KEYBOARD_NAME_MAPPING2	= ( MEDIA_LIBRARY_TAG_KEYBOARD_NAME_MAPPING1 + 1 ) ,
	MEDIA_LIBRARY_TAG_LINKEDITEM_COUNT	= ( MEDIA_LIBRARY_TAG_KEYBOARD_NAME_MAPPING2 + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ID	= ( MEDIA_LIBRARY_TAG_LINKEDITEM_COUNT + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_NAME	= ( MEDIA_LIBRARY_PLAYLIST_ID + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_DURATION	= ( MEDIA_LIBRARY_PLAYLIST_NAME + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_LAST_PLAYLIST_ITEM_ID	= ( MEDIA_LIBRARY_PLAYLIST_DURATION + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_MTP_PUOID	= ( MEDIA_LIBRARY_PLAYLIST_LAST_PLAYLIST_ITEM_ID + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_PARENT_SERIES_ID	= ( MEDIA_LIBRARY_PLAYLIST_MTP_PUOID + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_IS_PUBLIC	= ( MEDIA_LIBRARY_PLAYLIST_PARENT_SERIES_ID + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_COUNT	= ( MEDIA_LIBRARY_PLAYLIST_IS_PUBLIC + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_ID	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_COUNT + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_MEDIA_TYPE	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_ID + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_NAME	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_MEDIA_TYPE + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_PRIMARY_AUTHOR	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_NAME + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_DURATION	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_PRIMARY_AUTHOR + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_VOLUME_ID	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_DURATION + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_MEDIA_ITEM_ID	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_VOLUME_ID + 1 ) ,
	MEDIA_LIBRARY_PLAYLIST_ITEM_MEDIA_ITEM_LAST_POSITION	= ( MEDIA_LIBRARY_PLAYLIST_ITEM_MEDIA_ITEM_ID + 1 ) ,
	MEDIA_LIBRARY_OBJECT_PROPERTIES_MAXIMUM	= MEDIA_LIBRARY_PLAYLIST_ITEM_MEDIA_ITEM_LAST_POSITION,
	MEDIA_LIBRARY_VOLUME_VOLUME_ID	= ( MEDIA_LIBRARY_OBJECT_PROPERTIES_MAXIMUM + 1 ) ,
	MEDIA_LIBRARY_VOLUME_IS_READ_ONLY	= ( MEDIA_LIBRARY_VOLUME_VOLUME_ID + 1 ) ,
	MEDIA_LIBRARY_VOLUME_SYSTEM_LOCALE_ID	= ( MEDIA_LIBRARY_VOLUME_IS_READ_ONLY + 1 ) ,
	MEDIA_LIBRARY_VOLUME_USER_LOCALE_ID	= ( MEDIA_LIBRARY_VOLUME_SYSTEM_LOCALE_ID + 1 ) ,
	MEDIA_LIBRARY_VOLUME_LOCALE_ID	= ( MEDIA_LIBRARY_VOLUME_USER_LOCALE_ID + 1 ) ,
	MEDIA_LIBRARY_VOLUME_AUDIO_COUNT	= ( MEDIA_LIBRARY_VOLUME_LOCALE_ID + 1 ) ,
	MEDIA_LIBRARY_VOLUME_VIDEO_COUNT	= ( MEDIA_LIBRARY_VOLUME_AUDIO_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_IMAGE_COUNT	= ( MEDIA_LIBRARY_VOLUME_VIDEO_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_SERIES_COUNT	= ( MEDIA_LIBRARY_VOLUME_IMAGE_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_TAG_COUNT	= ( MEDIA_LIBRARY_VOLUME_SERIES_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_GENRE_COUNT	= ( MEDIA_LIBRARY_VOLUME_TAG_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_PLAYLIST_COUNT	= ( MEDIA_LIBRARY_VOLUME_GENRE_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_AUTHOR_COUNT	= ( MEDIA_LIBRARY_VOLUME_PLAYLIST_COUNT + 1 ) ,
	MEDIA_LIBRARY_VOLUME_UPDATE_PROCESS_ID	= ( MEDIA_LIBRARY_VOLUME_AUTHOR_COUNT + 1 ) 
    } 	MediaLibraryProperties;

typedef 
enum MediaLibraryProperties_DeprecatedConstants
    {	MEDIA_LIBRARY_PROPERTIES_MAXIMUM	= MEDIA_LIBRARY_OBJECT_PROPERTIES_MAXIMUM,
	MEDIA_LIBRARY_MEDIA_ITEM_LAST_USE_TIME	= MEDIA_LIBRARY_MEDIA_ITEM_LAST_MODIFIED,
	MEDIA_LIBRARY_MEDIA_ITEM_MAX_ENUMVAL	= MEDIA_LIBRARY_MEDIA_ITEM_KEYBOARD_NAME_MAPPING2
    } 	MediaLibraryProperties_DeprecatedConstants;

typedef 
enum MediaLibraryNotifications
    {	MEDIA_LIBRARY_NOTIFICATION_TYPE_UNKNOWN	= 0,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_OBJECT_ADDED	= 0x1,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_OBJECT_CHANGED	= 0x2,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_OBJECT_DELETED	= 0x4,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_REFERENCE_ADDED	= 0x8,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_REFERENCE_DELETED	= 0x10,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_PARTITION_MOUNTED	= 0x20,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_PARTITION_UNMOUNTED	= 0x40,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_UPDATE_STARTED	= 0x80,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_UPDATE_CANCELED	= 0x100,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_UPDATE_HALTED	= 0x200,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_UPDATE_FINISHED	= 0x400,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_DIRECTORY_FOUND	= 0x800,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_FILE_FOUND	= 0x1000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_FILE_SCANNED	= 0x2000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_UPDATE_ERROR	= 0x4000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_VOLUME_CORRUPTED	= 0x8000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_VOLUME_AVAILABLE	= 0x10000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_VOLUME_UNAVAILABLE	= 0x20000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_SYNC_STARTED	= 0x40000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_SYNC_FINISHED	= 0x80000,
	MEDIA_LIBRARY_NOTIFICATION_TYPE_REFERENCE_UPDATED	= 0x100000
    } 	MediaLibraryNotifications;



typedef 
enum MediaLibraryOptions
    {	MEDIA_LIBRARY_SKIP_NOTIFICATIONS	= 0x10,
	MEDIA_LIBRARY_SKIP_COMPUTEDPROPERTY_UPDATE	= 0x20,
	MEDIA_LIBRARY_SKIP_DUPLICATE_CHECK	= 0x40,
	MEDIA_LIBRARY_SKIP_URL_VALIDATION	= 0x80,
	MEDIA_LIBRARY_TRUNCATE_PROPERTY_STRINGS	= 0x100,
	MEDIA_LIBRARY_IGNORE_DUPLICATELINKS	= 0x200,
	MEDIA_LIBRARY_SKIP_AGGREGATEPROPERTYUPDATE	= 0x400
    } 	MediaLibraryOptions;



extern RPC_IF_HANDLE __MIDL_itf_MediaLibrary_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_MediaLibrary_0000_0000_v0_0_s_ifspec;

#ifndef __IMediaObject_INTERFACE_DEFINED__
#define __IMediaObject_INTERFACE_DEFINED__

/* interface IMediaObject */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D87444A-7DC9-481C-9B72-677DD65FCF92")
    IMediaObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMediaObjectOptions( 
            /* [in] */ DWORD dwOptionsBitMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [in] */ VARIANT vValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [ref][out] */ VARIANT *pvValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedMetaData( 
            /* [in] */ BSTR bstrMetaDataKey,
            /* [ref][out] */ VARIANT *pvValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtendedMetaData( 
            /* [in] */ BSTR bstrMetaDataKey,
            /* [in] */ VARIANT vValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtendedMetaData( 
            /* [in] */ BSTR bstrMetaDataKey,
            /* [in] */ VARIANT vValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearExtendedMetaData( 
            /* [in] */ BSTR bstrMetaDataKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddProperty( 
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [in] */ VARIANT vValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [in] */ VARIANT vValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolume( 
            /* [retval][out] */ IMediaVolume **ppIMediaVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearProperty( 
            /* [in] */ MediaLibraryProperties mlProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaObjectType( 
            /* [ref][out] */ MediaLibraryObjects *pObjectType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaObjectOptions )( 
            IMediaObject * This,
            /* [in] */ DWORD dwOptionsBitMask);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IMediaObject * This,
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [in] */ VARIANT vValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IMediaObject * This,
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [ref][out] */ VARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedMetaData )( 
            IMediaObject * This,
            /* [in] */ BSTR bstrMetaDataKey,
            /* [ref][out] */ VARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtendedMetaData )( 
            IMediaObject * This,
            /* [in] */ BSTR bstrMetaDataKey,
            /* [in] */ VARIANT vValue);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtendedMetaData )( 
            IMediaObject * This,
            /* [in] */ BSTR bstrMetaDataKey,
            /* [in] */ VARIANT vValue);
        
        HRESULT ( STDMETHODCALLTYPE *ClearExtendedMetaData )( 
            IMediaObject * This,
            /* [in] */ BSTR bstrMetaDataKey);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddProperty )( 
            IMediaObject * This,
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [in] */ VARIANT vValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProperty )( 
            IMediaObject * This,
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [in] */ VARIANT vValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            IMediaObject * This,
            /* [retval][out] */ IMediaVolume **ppIMediaVolume);
        
        HRESULT ( STDMETHODCALLTYPE *ClearProperty )( 
            IMediaObject * This,
            /* [in] */ MediaLibraryProperties mlProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaObjectType )( 
            IMediaObject * This,
            /* [ref][out] */ MediaLibraryObjects *pObjectType);
        
        END_INTERFACE
    } IMediaObjectVtbl;

    interface IMediaObject
    {
        CONST_VTBL struct IMediaObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaObject_SetMediaObjectOptions(This,dwOptionsBitMask)	\
    ( (This)->lpVtbl -> SetMediaObjectOptions(This,dwOptionsBitMask) ) 

#define IMediaObject_SetProperty(This,mlProperty,vValue)	\
    ( (This)->lpVtbl -> SetProperty(This,mlProperty,vValue) ) 

#define IMediaObject_GetProperty(This,mlProperty,pvValue)	\
    ( (This)->lpVtbl -> GetProperty(This,mlProperty,pvValue) ) 

#define IMediaObject_GetExtendedMetaData(This,bstrMetaDataKey,pvValue)	\
    ( (This)->lpVtbl -> GetExtendedMetaData(This,bstrMetaDataKey,pvValue) ) 

#define IMediaObject_SetExtendedMetaData(This,bstrMetaDataKey,vValue)	\
    ( (This)->lpVtbl -> SetExtendedMetaData(This,bstrMetaDataKey,vValue) ) 

#define IMediaObject_AddExtendedMetaData(This,bstrMetaDataKey,vValue)	\
    ( (This)->lpVtbl -> AddExtendedMetaData(This,bstrMetaDataKey,vValue) ) 

#define IMediaObject_ClearExtendedMetaData(This,bstrMetaDataKey)	\
    ( (This)->lpVtbl -> ClearExtendedMetaData(This,bstrMetaDataKey) ) 

#define IMediaObject_Save(This)	\
    ( (This)->lpVtbl -> Save(This) ) 

#define IMediaObject_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IMediaObject_AddProperty(This,mlProperty,vValue)	\
    ( (This)->lpVtbl -> AddProperty(This,mlProperty,vValue) ) 

#define IMediaObject_RemoveProperty(This,mlProperty,vValue)	\
    ( (This)->lpVtbl -> RemoveProperty(This,mlProperty,vValue) ) 

#define IMediaObject_GetVolume(This,ppIMediaVolume)	\
    ( (This)->lpVtbl -> GetVolume(This,ppIMediaVolume) ) 

#define IMediaObject_ClearProperty(This,mlProperty)	\
    ( (This)->lpVtbl -> ClearProperty(This,mlProperty) ) 

#define IMediaObject_GetMediaObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> GetMediaObjectType(This,pObjectType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaObject_INTERFACE_DEFINED__ */


#ifndef __IMediaObjectEnumerator_INTERFACE_DEFINED__
#define __IMediaObjectEnumerator_INTERFACE_DEFINED__

/* interface IMediaObjectEnumerator */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaObjectEnumerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19764BCB-92BB-49FC-9468-D1B3523F7239")
    IMediaObjectEnumerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ IMediaObject **ppIMediaObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [ref][out] */ DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SkipCount( 
            /* [in] */ DWORD dwSkipCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaObjectType( 
            /* [ref][out] */ MediaLibraryObjects *pObjectType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaObjectEnumeratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaObjectEnumerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaObjectEnumerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaObjectEnumerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IMediaObjectEnumerator * This,
            /* [retval][out] */ IMediaObject **ppIMediaObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMediaObjectEnumerator * This,
            /* [ref][out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMediaObjectEnumerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *SkipCount )( 
            IMediaObjectEnumerator * This,
            /* [in] */ DWORD dwSkipCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaObjectType )( 
            IMediaObjectEnumerator * This,
            /* [ref][out] */ MediaLibraryObjects *pObjectType);
        
        END_INTERFACE
    } IMediaObjectEnumeratorVtbl;

    interface IMediaObjectEnumerator
    {
        CONST_VTBL struct IMediaObjectEnumeratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaObjectEnumerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaObjectEnumerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaObjectEnumerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaObjectEnumerator_Next(This,ppIMediaObject)	\
    ( (This)->lpVtbl -> Next(This,ppIMediaObject) ) 

#define IMediaObjectEnumerator_GetCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetCount(This,pdwCount) ) 

#define IMediaObjectEnumerator_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IMediaObjectEnumerator_SkipCount(This,dwSkipCount)	\
    ( (This)->lpVtbl -> SkipCount(This,dwSkipCount) ) 

#define IMediaObjectEnumerator_GetMediaObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> GetMediaObjectType(This,pObjectType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaObjectEnumerator_INTERFACE_DEFINED__ */


#ifndef __IMediaVolume_INTERFACE_DEFINED__
#define __IMediaVolume_INTERFACE_DEFINED__

/* interface IMediaVolume */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("889F4E2C-026A-4EEE-ACE2-59FC0CA89B08")
    IMediaVolume : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR *pbstrVolumeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [retval][out] */ BSTR *pbstrVolumePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMediaObject( 
            /* [in] */ MediaLibraryObjects ObjectType,
            /* [retval][out] */ IMediaObject **ppIMediaObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ MediaLibraryProperties mlPropertyId,
            /* [ref][out] */ VARIANT *pvValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IMediaVolume * This,
            /* [retval][out] */ BSTR *pbstrVolumeName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IMediaVolume * This,
            /* [retval][out] */ BSTR *pbstrVolumePath);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMediaObject )( 
            IMediaVolume * This,
            /* [in] */ MediaLibraryObjects ObjectType,
            /* [retval][out] */ IMediaObject **ppIMediaObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IMediaVolume * This,
            /* [in] */ MediaLibraryProperties mlPropertyId,
            /* [ref][out] */ VARIANT *pvValue);
        
        END_INTERFACE
    } IMediaVolumeVtbl;

    interface IMediaVolume
    {
        CONST_VTBL struct IMediaVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaVolume_GetName(This,pbstrVolumeName)	\
    ( (This)->lpVtbl -> GetName(This,pbstrVolumeName) ) 

#define IMediaVolume_GetPath(This,pbstrVolumePath)	\
    ( (This)->lpVtbl -> GetPath(This,pbstrVolumePath) ) 

#define IMediaVolume_CreateMediaObject(This,ObjectType,ppIMediaObject)	\
    ( (This)->lpVtbl -> CreateMediaObject(This,ObjectType,ppIMediaObject) ) 

#define IMediaVolume_GetProperty(This,mlPropertyId,pvValue)	\
    ( (This)->lpVtbl -> GetProperty(This,mlPropertyId,pvValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaVolume_INTERFACE_DEFINED__ */


#ifndef __IMediaQuery_INTERFACE_DEFINED__
#define __IMediaQuery_INTERFACE_DEFINED__

/* interface IMediaQuery */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92BEFE18-522A-403A-9736-608B8C2FA57A")
    IMediaQuery : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertySet( 
            /* [in] */ long cnPropertCount,
            /* [size_is][in] */ const MediaLibraryProperties *pPropertySet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCondition( 
            /* [in] */ MediaLibraryProperties mlPropertyFilter,
            /* [in] */ MediaLibraryOperations mlOperation,
            /* [in] */ VARIANT vFilterValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSort( 
            /* [in] */ MediaLibraryProperties mlPropertyFilter,
            /* [in] */ BOOL IsAscending) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearSort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ long cnVolumeCount,
            /* [size_is][in] */ IMediaVolume **pMediaVolumes,
            /* [retval][out] */ IMediaObjectEnumerator **ppIMediaObjectEnumerator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaObjectType( 
            /* [ref][out] */ MediaLibraryObjects *pObjectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnumeratorType( 
            /* [ref][in] */ MediaLibraryEnumeratorType *pEnumeratorType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaQuery * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaQuery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertySet )( 
            IMediaQuery * This,
            /* [in] */ long cnPropertCount,
            /* [size_is][in] */ const MediaLibraryProperties *pPropertySet);
        
        HRESULT ( STDMETHODCALLTYPE *AddCondition )( 
            IMediaQuery * This,
            /* [in] */ MediaLibraryProperties mlPropertyFilter,
            /* [in] */ MediaLibraryOperations mlOperation,
            /* [in] */ VARIANT vFilterValue);
        
        HRESULT ( STDMETHODCALLTYPE *AddGroup )( 
            IMediaQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddSort )( 
            IMediaQuery * This,
            /* [in] */ MediaLibraryProperties mlPropertyFilter,
            /* [in] */ BOOL IsAscending);
        
        HRESULT ( STDMETHODCALLTYPE *ClearSort )( 
            IMediaQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IMediaQuery * This,
            /* [in] */ long cnVolumeCount,
            /* [size_is][in] */ IMediaVolume **pMediaVolumes,
            /* [retval][out] */ IMediaObjectEnumerator **ppIMediaObjectEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaObjectType )( 
            IMediaQuery * This,
            /* [ref][out] */ MediaLibraryObjects *pObjectType);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnumeratorType )( 
            IMediaQuery * This,
            /* [ref][in] */ MediaLibraryEnumeratorType *pEnumeratorType);
        
        END_INTERFACE
    } IMediaQueryVtbl;

    interface IMediaQuery
    {
        CONST_VTBL struct IMediaQueryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaQuery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaQuery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaQuery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaQuery_SetPropertySet(This,cnPropertCount,pPropertySet)	\
    ( (This)->lpVtbl -> SetPropertySet(This,cnPropertCount,pPropertySet) ) 

#define IMediaQuery_AddCondition(This,mlPropertyFilter,mlOperation,vFilterValue)	\
    ( (This)->lpVtbl -> AddCondition(This,mlPropertyFilter,mlOperation,vFilterValue) ) 

#define IMediaQuery_AddGroup(This)	\
    ( (This)->lpVtbl -> AddGroup(This) ) 

#define IMediaQuery_AddSort(This,mlPropertyFilter,IsAscending)	\
    ( (This)->lpVtbl -> AddSort(This,mlPropertyFilter,IsAscending) ) 

#define IMediaQuery_ClearSort(This)	\
    ( (This)->lpVtbl -> ClearSort(This) ) 

#define IMediaQuery_Execute(This,cnVolumeCount,pMediaVolumes,ppIMediaObjectEnumerator)	\
    ( (This)->lpVtbl -> Execute(This,cnVolumeCount,pMediaVolumes,ppIMediaObjectEnumerator) ) 

#define IMediaQuery_GetMediaObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> GetMediaObjectType(This,pObjectType) ) 

#define IMediaQuery_SetEnumeratorType(This,pEnumeratorType)	\
    ( (This)->lpVtbl -> SetEnumeratorType(This,pEnumeratorType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaQuery_INTERFACE_DEFINED__ */


#ifndef __ILibraryHandler_INTERFACE_DEFINED__
#define __ILibraryHandler_INTERFACE_DEFINED__

/* interface ILibraryHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_ILibraryHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A648784-14DC-48CD-868D-DEC26C0A5132")
    ILibraryHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLibraryHandlerOptions( 
            /* [in] */ DWORD dwOptionsBitMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFile( 
            /* [in] */ BSTR bstrFileURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFileEx( 
            /* [in] */ BSTR bstrFileURL,
            /* [retval][out] */ IMediaObject **ppIMediaObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsFileInLibrary( 
            /* [in] */ BSTR bstrFileURL,
            /* [ref][out] */ BOOL *fFileInLibrary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateQuery( 
            /* [in] */ MediaLibraryObjects QueryType,
            /* [retval][out] */ IMediaQuery **ppIMediaQueryQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstVolume( 
            /* [retval][out] */ IMediaVolume **ppIMediaVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextVolume( 
            /* [retval][out] */ IMediaVolume **ppIMediaVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNotification( 
            /* [in] */ IMediaLibraryNotificationListener *pListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterForNotification( 
            /* [in] */ IMediaLibraryNotificationListener *pListener) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UploadObjectAddRef( 
            /* [in] */ BSTR bstrFileURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UploadObjectRelease( 
            /* [in] */ BSTR bstrFileURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UploadObjectExtendExpiration( 
            /* [in] */ BSTR bstrFileURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessExpiredUploadObjects( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolumeByFilePath( 
            /* [in] */ BSTR bstrFilePath,
            /* [retval][out] */ IMediaVolume **ppIMediaVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaItemFromFilePath( 
            /* [in] */ BSTR bstrFilePath,
            /* [in] */ DWORD dwIdPropSetCount,
            /* [size_is][in] */ const MediaLibraryProperties *pPropSet,
            /* [retval][out] */ IMediaObject **ppIMediaObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRecord( 
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RelocateRecord( 
            /* [in] */ BSTR bstrFilePathSource,
            /* [in] */ BSTR bstrFilePathDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILibraryHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILibraryHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILibraryHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILibraryHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLibraryHandlerOptions )( 
            ILibraryHandler * This,
            /* [in] */ DWORD dwOptionsBitMask);
        
        HRESULT ( STDMETHODCALLTYPE *AddFile )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFileURL);
        
        HRESULT ( STDMETHODCALLTYPE *AddFileEx )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFileURL,
            /* [retval][out] */ IMediaObject **ppIMediaObject);
        
        HRESULT ( STDMETHODCALLTYPE *IsFileInLibrary )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFileURL,
            /* [ref][out] */ BOOL *fFileInLibrary);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQuery )( 
            ILibraryHandler * This,
            /* [in] */ MediaLibraryObjects QueryType,
            /* [retval][out] */ IMediaQuery **ppIMediaQueryQuery);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstVolume )( 
            ILibraryHandler * This,
            /* [retval][out] */ IMediaVolume **ppIMediaVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextVolume )( 
            ILibraryHandler * This,
            /* [retval][out] */ IMediaVolume **ppIMediaVolume);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNotification )( 
            ILibraryHandler * This,
            /* [in] */ IMediaLibraryNotificationListener *pListener);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterForNotification )( 
            ILibraryHandler * This,
            /* [in] */ IMediaLibraryNotificationListener *pListener);
        
        HRESULT ( STDMETHODCALLTYPE *UploadObjectAddRef )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFileURL);
        
        HRESULT ( STDMETHODCALLTYPE *UploadObjectRelease )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFileURL);
        
        HRESULT ( STDMETHODCALLTYPE *UploadObjectExtendExpiration )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFileURL);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessExpiredUploadObjects )( 
            ILibraryHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolumeByFilePath )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFilePath,
            /* [retval][out] */ IMediaVolume **ppIMediaVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaItemFromFilePath )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFilePath,
            /* [in] */ DWORD dwIdPropSetCount,
            /* [size_is][in] */ const MediaLibraryProperties *pPropSet,
            /* [retval][out] */ IMediaObject **ppIMediaObject);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRecord )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *RelocateRecord )( 
            ILibraryHandler * This,
            /* [in] */ BSTR bstrFilePathSource,
            /* [in] */ BSTR bstrFilePathDestination);
        
        END_INTERFACE
    } ILibraryHandlerVtbl;

    interface ILibraryHandler
    {
        CONST_VTBL struct ILibraryHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILibraryHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILibraryHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILibraryHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILibraryHandler_SetLibraryHandlerOptions(This,dwOptionsBitMask)	\
    ( (This)->lpVtbl -> SetLibraryHandlerOptions(This,dwOptionsBitMask) ) 

#define ILibraryHandler_AddFile(This,bstrFileURL)	\
    ( (This)->lpVtbl -> AddFile(This,bstrFileURL) ) 

#define ILibraryHandler_AddFileEx(This,bstrFileURL,ppIMediaObject)	\
    ( (This)->lpVtbl -> AddFileEx(This,bstrFileURL,ppIMediaObject) ) 

#define ILibraryHandler_IsFileInLibrary(This,bstrFileURL,fFileInLibrary)	\
    ( (This)->lpVtbl -> IsFileInLibrary(This,bstrFileURL,fFileInLibrary) ) 

#define ILibraryHandler_CreateQuery(This,QueryType,ppIMediaQueryQuery)	\
    ( (This)->lpVtbl -> CreateQuery(This,QueryType,ppIMediaQueryQuery) ) 

#define ILibraryHandler_GetFirstVolume(This,ppIMediaVolume)	\
    ( (This)->lpVtbl -> GetFirstVolume(This,ppIMediaVolume) ) 

#define ILibraryHandler_GetNextVolume(This,ppIMediaVolume)	\
    ( (This)->lpVtbl -> GetNextVolume(This,ppIMediaVolume) ) 

#define ILibraryHandler_RegisterForNotification(This,pListener)	\
    ( (This)->lpVtbl -> RegisterForNotification(This,pListener) ) 

#define ILibraryHandler_UnRegisterForNotification(This,pListener)	\
    ( (This)->lpVtbl -> UnRegisterForNotification(This,pListener) ) 

#define ILibraryHandler_UploadObjectAddRef(This,bstrFileURL)	\
    ( (This)->lpVtbl -> UploadObjectAddRef(This,bstrFileURL) ) 

#define ILibraryHandler_UploadObjectRelease(This,bstrFileURL)	\
    ( (This)->lpVtbl -> UploadObjectRelease(This,bstrFileURL) ) 

#define ILibraryHandler_UploadObjectExtendExpiration(This,bstrFileURL)	\
    ( (This)->lpVtbl -> UploadObjectExtendExpiration(This,bstrFileURL) ) 

#define ILibraryHandler_ProcessExpiredUploadObjects(This)	\
    ( (This)->lpVtbl -> ProcessExpiredUploadObjects(This) ) 

#define ILibraryHandler_GetVolumeByFilePath(This,bstrFilePath,ppIMediaVolume)	\
    ( (This)->lpVtbl -> GetVolumeByFilePath(This,bstrFilePath,ppIMediaVolume) ) 

#define ILibraryHandler_GetMediaItemFromFilePath(This,bstrFilePath,dwIdPropSetCount,pPropSet,ppIMediaObject)	\
    ( (This)->lpVtbl -> GetMediaItemFromFilePath(This,bstrFilePath,dwIdPropSetCount,pPropSet,ppIMediaObject) ) 

#define ILibraryHandler_RemoveRecord(This,bstrFilePath)	\
    ( (This)->lpVtbl -> RemoveRecord(This,bstrFilePath) ) 

#define ILibraryHandler_RelocateRecord(This,bstrFilePathSource,bstrFilePathDestination)	\
    ( (This)->lpVtbl -> RelocateRecord(This,bstrFilePathSource,bstrFilePathDestination) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILibraryHandler_INTERFACE_DEFINED__ */



#ifndef __LibraryHandlerLib_LIBRARY_DEFINED__
#define __LibraryHandlerLib_LIBRARY_DEFINED__

/* library LibraryHandlerLib */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_LibraryHandlerLib;

EXTERN_C const CLSID CLSID_LibraryHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("AE16151A-2271-4669-B7A9-77E73FAD8D9F")
LibraryHandler;
#endif
#endif /* __LibraryHandlerLib_LIBRARY_DEFINED__ */

#ifndef __IMediaLibraryNotification_INTERFACE_DEFINED__
#define __IMediaLibraryNotification_INTERFACE_DEFINED__

/* interface IMediaLibraryNotification */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaLibraryNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6453270-C16F-4156-A1C2-7A8FC0E90148")
    IMediaLibraryNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [ref][out] */ VARIANT *pvValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaObjectType( 
            /* [ref][out] */ MediaLibraryObjects *pObjectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrimaryMediaObjectType( 
            /* [ref][out] */ MediaLibraryObjects *pObjectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecondaryMediaObjectType( 
            /* [ref][out] */ MediaLibraryObjects *pObjectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaNotificationType( 
            /* [ref][out] */ MediaLibraryNotifications *pNotificationType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaObjectSubType( 
            /* [ref][out] */ MediaLibraryMediaTypes *pObjectSubType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaLibraryNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaLibraryNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaLibraryNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaLibraryNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IMediaLibraryNotification * This,
            /* [in] */ MediaLibraryProperties mlProperty,
            /* [ref][out] */ VARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaObjectType )( 
            IMediaLibraryNotification * This,
            /* [ref][out] */ MediaLibraryObjects *pObjectType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrimaryMediaObjectType )( 
            IMediaLibraryNotification * This,
            /* [ref][out] */ MediaLibraryObjects *pObjectType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecondaryMediaObjectType )( 
            IMediaLibraryNotification * This,
            /* [ref][out] */ MediaLibraryObjects *pObjectType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaNotificationType )( 
            IMediaLibraryNotification * This,
            /* [ref][out] */ MediaLibraryNotifications *pNotificationType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaObjectSubType )( 
            IMediaLibraryNotification * This,
            /* [ref][out] */ MediaLibraryMediaTypes *pObjectSubType);
        
        END_INTERFACE
    } IMediaLibraryNotificationVtbl;

    interface IMediaLibraryNotification
    {
        CONST_VTBL struct IMediaLibraryNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaLibraryNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaLibraryNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaLibraryNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaLibraryNotification_GetProperty(This,mlProperty,pvValue)	\
    ( (This)->lpVtbl -> GetProperty(This,mlProperty,pvValue) ) 

#define IMediaLibraryNotification_GetMediaObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> GetMediaObjectType(This,pObjectType) ) 

#define IMediaLibraryNotification_GetPrimaryMediaObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> GetPrimaryMediaObjectType(This,pObjectType) ) 

#define IMediaLibraryNotification_GetSecondaryMediaObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> GetSecondaryMediaObjectType(This,pObjectType) ) 

#define IMediaLibraryNotification_GetMediaNotificationType(This,pNotificationType)	\
    ( (This)->lpVtbl -> GetMediaNotificationType(This,pNotificationType) ) 

#define IMediaLibraryNotification_GetMediaObjectSubType(This,pObjectSubType)	\
    ( (This)->lpVtbl -> GetMediaObjectSubType(This,pObjectSubType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaLibraryNotification_INTERFACE_DEFINED__ */


#ifndef __IMediaLibraryNotificationListener_INTERFACE_DEFINED__
#define __IMediaLibraryNotificationListener_INTERFACE_DEFINED__

/* interface IMediaLibraryNotificationListener */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaLibraryNotificationListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6AA79640-A1BF-472a-8DBE-6B2008CF9C0A")
    IMediaLibraryNotificationListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessNotification( 
            /* [in] */ IMediaLibraryNotification *pNotification) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaLibraryNotificationListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaLibraryNotificationListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaLibraryNotificationListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaLibraryNotificationListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessNotification )( 
            IMediaLibraryNotificationListener * This,
            /* [in] */ IMediaLibraryNotification *pNotification);
        
        END_INTERFACE
    } IMediaLibraryNotificationListenerVtbl;

    interface IMediaLibraryNotificationListener
    {
        CONST_VTBL struct IMediaLibraryNotificationListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaLibraryNotificationListener_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaLibraryNotificationListener_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaLibraryNotificationListener_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaLibraryNotificationListener_ProcessNotification(This,pNotification)	\
    ( (This)->lpVtbl -> ProcessNotification(This,pNotification) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaLibraryNotificationListener_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\measure.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

/*
   The idea is to pepper the source code with interesting measurements and
   have the last few thousand of these recorded in a circular buffer that
   can be post-processed to give interesting numbers.

   WHAT THE LOG LOOKS LIKE:

  Time (sec)   Type        Delta  Incident_Name
    0.055,41  NOTE      -.       Incident Nine  - Another note
    0.055,42  NOTE      0.000,01 Incident Nine  - Another note
    0.055,44  NOTE      0.000,02 Incident Nine  - Another note
    0.055,45  STOP      -.       Incident Eight - Also random
    0.055,47  START     -.       Incident Seven - Random
    0.055,49  NOTE      0.000,05 Incident Nine  - Another note
    ------- <etc.  there is a lot of this> ----------------
    0.125,60  STOP      0.000,03 Msr_Stop
    0.125,62  START     -.       Msr_Start
    0.125,63  START     -.       Incident Two   - Start/Stop
    0.125,65  STOP      0.000,03 Msr_Start
    0.125,66  START     -.       Msr_Stop
    0.125,68  STOP      0.000,05 Incident Two   - Start/Stop
    0.125,70  STOP      0.000,04 Msr_Stop
    0.125,72  START     -.       Msr_Start
    0.125,73  START     -.       Incident Two   - Start/Stop
    0.125,75  STOP      0.000,03 Msr_Start
    0.125,77  START     -.       Msr_Stop
    0.125,78  STOP      0.000,05 Incident Two   - Start/Stop
    0.125,80  STOP      0.000,03 Msr_Stop
    0.125,81  NOTE      -.       Incident Three - single Note
    0.125,83  START     -.       Incident Four  - Start, no stop
    0.125,85  START     -.       Incident Five  - Single Start/Stop
    0.125,87  STOP      0.000,02 Incident Five  - Single Start/Stop

Number      Average       StdDev     Smallest      Largest Incident_Name
    10     0.000,58     0.000,10     0.000,55     0.000,85 Incident One   - Note
    50     0.000,05     0.000,00     0.000,05     0.000,05 Incident Two   - Start/Stop
     1     -.           -.           -.           -.       Incident Three - single Note
     0     -.           -.           -.           -.       Incident Four  - Start, no stop
     1     0.000,02     -.           0.000,02     0.000,02 Incident Five  - Single Start/Stop
     0     -.           -.           -.           -.       Incident Six   - zero occurrences
   100     0.000,25     0.000,12     0.000,02     0.000,62 Incident Seven - Random
   100     0.000,79     0.000,48     0.000,02     0.001,92 Incident Eight - Also random
  5895     0.000,01     0.000,01     0.000,01     0.000,56 Incident Nine  - Another note
    10     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Note
    50     0.000,03     0.000,00     0.000,03     0.000,04 Msr_Start
    50     0.000,04     0.000,03     0.000,03     0.000,31 Msr_Stop

  WHAT IT MEANS:
    The log shows what happened and when.  Each line shows the time at which
    something happened (see WHAT YOU CODE below) what it was that happened
    and (if approporate) the time since the corresponding previous event
    (that's the delta column).

    The statistics show how many times each event occurred, what the average
    delta time was, also the standard deviation, largest and smalles delta.

   WHAT YOU CODE:

   Before anything else executes: - register your ids

    int id1     = Msr_Register("Incident One   - Note");
    int id2     = Msr_Register("Incident Two   - Start/Stop");
    int id3     = Msr_Register("Incident Three - single Note");
    etc.

   At interesting moments:

       // To measure a repetitive event - e.g. end of bitblt to screen
       Msr_Note(Id9);             // e.g. "video frame hiting the screen NOW!"

           or

       // To measure an elapsed time e.g. time taken to decode an MPEG B-frame
       Msr_Start(Id2);            // e.g. "Starting to decode MPEG B-frame"
         . . .
       MsrStop(Id2);              //      "Finished MPEG decode"

   At the end:

       HANDLE hFile;
       hFile = CreateFile("Perf.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
       Msr_Dump(hFile);           // This writes the log out to the file
       CloseHandle(hFile);

           or

       Msr_Dump(NULL);            // This writes it to DbgLog((LOG_TRACE,0, ... ));
                                  // but if you are writing it out to the debugger
                                  // then the times are probably all garbage because
                                  // the debugger can make things run awfully slow.

    A given id should be used either for start / stop or Note calls.  If Notes
    are mixed in with Starts and Stops their statistics will be gibberish.

    If you code the calls in upper case i.e. MSR_START(idMunge); then you get
    macros which will turn into nothing unless PERF is defined.

    You can reset the statistical counts for a given id by calling Reset(Id).
    They are reset by default at the start.
    It logs Reset as a special incident, so you can see it in the log.

    The log is a circular buffer in storage (to try to minimise disk I/O).
    It overwrites the oldest entries once full.  The statistics include ALL
    incidents since the last Reset, whether still visible in the log or not.
*/

#ifndef __MEASURE__
#define __MEASURE__

#if defined(PERF2) || defined(PERF)
#define MSR_INIT() Msr_Init()
#define MSR_TERMINATE() Msr_Terminate()
#define MSR_REGISTER(a) Msr_Register(a)
#define MSR_RESET(a) Msr_Reset(a)
#define MSR_CONTROL(a) Msr_Control(a)
#define MSR_START(a) Msr_Start(a)
#define MSR_STOP(a) Msr_Stop(a)
#define MSR_NOTE(a) Msr_Note(a)
#define MSR_INTEGER(a,b) Msr_Integer(a,b)
#define MSR_FLOAT(a,b) Msr_Float(a,b)
#define MSR_DUMP(a) Msr_Dump(a)
#define MSR_DUMPSTATS(a) Msr_DumpStats(a)
#else
#define MSR_INIT()
#define MSR_TERMINATE()
#define MSR_REGISTER(a) 0
#define MSR_RESET(a)
#define MSR_CONTROL(a)
#define MSR_START(a)
#define MSR_STOP(a)
#define MSR_NOTE(a)
#define MSR_INTEGER(a,b)
#define MSR_FLOAT(a,b)
#define MSR_DUMP(a)
#define MSR_DUMPSTATS(a)
#endif

#ifdef __cplusplus
extern "C" {
#endif

// This must be called first - (called by the DllEntry)

void WINAPI Msr_Init(void);


// Call this last to clean up (or just let it fall off the end - who cares?)

void WINAPI Msr_Terminate(void);


// Call this to get an Id for an "incident" that you can pass to Start, Stop or Note
// everything that's logged is called an "incident".

int  WINAPI Msr_Register(LPTSTR Incident);


// Reset the statistical counts for an incident

void WINAPI Msr_Reset(int Id);


// Reset all the counts for all incidents
#define MSR_RESET_ALL 0
#define MSR_PAUSE 1
#define MSR_RUN 2
#define MSR_CLEAR_ALL 3

void WINAPI Msr_Control(int iAction);


// log the start of an operation

void WINAPI Msr_Start(int Id);


// log the end of an operation

void WINAPI Msr_Stop(int Id);


// log a one-off or repetitive operation

void WINAPI Msr_Note(int Id);


// log an integer (on which we can see statistics later)
void WINAPI Msr_Integer(int Id, int n);

// log an double (on which we can see statistics later)
void WINAPI Msr_Float(int Id, float n);

// print out all the vaialable log (it may have wrapped) and then the statistics.
// When the log wraps you lose log but the statistics are still complete.
// hFIle==NULL => use DbgLog
// otherwise hFile must have come from CreateFile or OpenFile.

void WINAPI Msr_Dump(HANDLE hFile);


// just dump the statistics - never mind the log

void WINAPI Msr_DumpStats(HANDLE hFile);

// Type definitions in case you want to declare a pointer to the dump functions
// (makes it a trifle easier to do dynamic linking
// i.e. LoadModule, GetProcAddress and call that)

// Typedefs so can declare MSR_DUMPPROC *MsrDumpStats; or whatever
typedef void WINAPI MSR_DUMPPROC(HANDLE hFile);
typedef void WINAPI MSR_CONTROLPROC(int iAction);


#ifdef __cplusplus
}
#endif

#endif // __MEASURE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mediaobj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for mediaobj.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mediaobj_h__
#define __mediaobj_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMediaBuffer_FWD_DEFINED__
#define __IMediaBuffer_FWD_DEFINED__
typedef interface IMediaBuffer IMediaBuffer;
#endif 	/* __IMediaBuffer_FWD_DEFINED__ */


#ifndef __IMediaObject_FWD_DEFINED__
#define __IMediaObject_FWD_DEFINED__
typedef interface IMediaObject IMediaObject;
#endif 	/* __IMediaObject_FWD_DEFINED__ */


#ifndef __IEnumDMO_FWD_DEFINED__
#define __IEnumDMO_FWD_DEFINED__
typedef interface IEnumDMO IEnumDMO;
#endif 	/* __IEnumDMO_FWD_DEFINED__ */


#ifndef __IMediaObjectInPlace_FWD_DEFINED__
#define __IMediaObjectInPlace_FWD_DEFINED__
typedef interface IMediaObjectInPlace IMediaObjectInPlace;
#endif 	/* __IMediaObjectInPlace_FWD_DEFINED__ */


#ifndef __IDMOQualityControl_FWD_DEFINED__
#define __IDMOQualityControl_FWD_DEFINED__
typedef interface IDMOQualityControl IDMOQualityControl;
#endif 	/* __IDMOQualityControl_FWD_DEFINED__ */


#ifndef __IDMOVideoOutputOptimizations_FWD_DEFINED__
#define __IDMOVideoOutputOptimizations_FWD_DEFINED__
typedef interface IDMOVideoOutputOptimizations IDMOVideoOutputOptimizations;
#endif 	/* __IDMOVideoOutputOptimizations_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mediaobj_0000_0000 */
/* [local] */ 

#ifdef __strmif_h__
typedef AM_MEDIA_TYPE DMO_MEDIA_TYPE;
#else
typedef struct _DMOMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    BYTE *pbFormat;
    } 	DMO_MEDIA_TYPE;

typedef LONGLONG REFERENCE_TIME;

#endif

enum _DMO_INPUT_DATA_BUFFER_FLAGS
    {	DMO_INPUT_DATA_BUFFERF_SYNCPOINT	= 0x1,
	DMO_INPUT_DATA_BUFFERF_TIME	= 0x2,
	DMO_INPUT_DATA_BUFFERF_TIMELENGTH	= 0x4
    } ;

enum _DMO_OUTPUT_DATA_BUFFER_FLAGS
    {	DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT	= 0x1,
	DMO_OUTPUT_DATA_BUFFERF_TIME	= 0x2,
	DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH	= 0x4,
	DMO_OUTPUT_DATA_BUFFERF_FIELD1	= 0x8,
	DMO_OUTPUT_DATA_BUFFERF_FIELD2	= 0x10,
	DMO_OUTPUT_DATA_BUFFERF_INTERLEAVED_FRAME	= 0x20,
	DMO_OUTPUT_DATA_BUFFERF_FIELD1_FIRST	= 0x40,
	DMO_OUTPUT_DATA_BUFFERF_REPEAT_FIRST_FIELD	= 0x80,
	DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE	= 0x1000000
    } ;

enum _DMO_INPUT_STATUS_FLAGS
    {	DMO_INPUT_STATUSF_ACCEPT_DATA	= 0x1
    } ;

enum _DMO_INPUT_STREAM_INFO_FLAGS
    {	DMO_INPUT_STREAMF_WHOLE_SAMPLES	= 0x1,
	DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER	= 0x2,
	DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE	= 0x4,
	DMO_INPUT_STREAMF_HOLDS_BUFFERS	= 0x8
    } ;

enum _DMO_OUTPUT_STREAM_INFO_FLAGS
    {	DMO_OUTPUT_STREAMF_WHOLE_SAMPLES	= 0x1,
	DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER	= 0x2,
	DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE	= 0x4,
	DMO_OUTPUT_STREAMF_DISCARDABLE	= 0x8,
	DMO_OUTPUT_STREAMF_OPTIONAL	= 0x10
    } ;

enum _DMO_SET_TYPE_FLAGS
    {	DMO_SET_TYPEF_TEST_ONLY	= 0x1,
	DMO_SET_TYPEF_CLEAR	= 0x2
    } ;

enum _DMO_PROCESS_OUTPUT_FLAGS
    {	DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER	= 0x1,
	DMO_PROCESS_OUTPUT_FLUSH_SAMPLES	= 0x2,
	DMO_PROCESS_OUTPUT_HIDDEN_VIDEOWINDOW	= 0x20000000
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0000_v0_0_s_ifspec;

#ifndef __IMediaBuffer_INTERFACE_DEFINED__
#define __IMediaBuffer_INTERFACE_DEFINED__

/* interface IMediaBuffer */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59eff8b9-938c-4a26-82f2-95cb84cdc837")
    IMediaBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            DWORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD *pcbMaxLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE **ppBuffer,
            /* [out] */ DWORD *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaBuffer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaBuffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaBuffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            IMediaBuffer * This,
            DWORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            IMediaBuffer * This,
            /* [out] */ DWORD *pcbMaxLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            IMediaBuffer * This,
            /* [out] */ BYTE **ppBuffer,
            /* [out] */ DWORD *pcbLength);
        
        END_INTERFACE
    } IMediaBufferVtbl;

    interface IMediaBuffer
    {
        CONST_VTBL struct IMediaBufferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaBuffer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaBuffer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaBuffer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaBuffer_SetLength(This,cbLength)	\
    ( (This)->lpVtbl -> SetLength(This,cbLength) ) 

#define IMediaBuffer_GetMaxLength(This,pcbMaxLength)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pcbMaxLength) ) 

#define IMediaBuffer_GetBufferAndLength(This,ppBuffer,pcbLength)	\
    ( (This)->lpVtbl -> GetBufferAndLength(This,ppBuffer,pcbLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaBuffer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0001 */
/* [local] */ 

typedef struct _DMO_OUTPUT_DATA_BUFFER
    {
    IMediaBuffer *pBuffer;
    DWORD dwStatus;
    REFERENCE_TIME rtTimestamp;
    REFERENCE_TIME rtTimelength;
    } 	DMO_OUTPUT_DATA_BUFFER;

typedef struct _DMO_OUTPUT_DATA_BUFFER *PDMO_OUTPUT_DATA_BUFFER;



extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0001_v0_0_s_ifspec;

#ifndef __IMediaObject_INTERFACE_DEFINED__
#define __IMediaObject_INTERFACE_DEFINED__

/* interface IMediaObject */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8ad0f58-5494-4102-97c5-ec798e59bcf4")
    IMediaObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pcInputStreams,
            /* [out] */ DWORD *pcOutputStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputStreamInfo( 
            DWORD dwInputStreamIndex,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputStreamInfo( 
            DWORD dwOutputStreamIndex,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputType( 
            DWORD dwInputStreamIndex,
            DWORD dwTypeIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputType( 
            DWORD dwOutputStreamIndex,
            DWORD dwTypeIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputType( 
            DWORD dwInputStreamIndex,
            /* [in] */ const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputType( 
            DWORD dwOutputStreamIndex,
            /* [in] */ const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCurrentType( 
            DWORD dwInputStreamIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCurrentType( 
            DWORD dwOutputStreamIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputSizeInfo( 
            DWORD dwInputStreamIndex,
            /* [out] */ DWORD *pcbSize,
            /* [out] */ DWORD *pcbMaxLookahead,
            /* [out] */ DWORD *pcbAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSizeInfo( 
            DWORD dwOutputStreamIndex,
            /* [out] */ DWORD *pcbSize,
            /* [out] */ DWORD *pcbAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputMaxLatency( 
            DWORD dwInputStreamIndex,
            /* [out] */ REFERENCE_TIME *prtMaxLatency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputMaxLatency( 
            DWORD dwInputStreamIndex,
            REFERENCE_TIME rtMaxLatency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Discontinuity( 
            DWORD dwInputStreamIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateStreamingResources( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeStreamingResources( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputStatus( 
            DWORD dwInputStreamIndex,
            /* [out] */ DWORD *dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessInput( 
            DWORD dwInputStreamIndex,
            IMediaBuffer *pBuffer,
            DWORD dwFlags,
            REFERENCE_TIME rtTimestamp,
            REFERENCE_TIME rtTimelength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessOutput( 
            DWORD dwFlags,
            DWORD cOutputBufferCount,
            /* [size_is][out][in] */ DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            LONG bLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMediaObject * This,
            /* [out] */ DWORD *pcInputStreams,
            /* [out] */ DWORD *pcOutputStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputStreamInfo )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputStreamInfo )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputType )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            DWORD dwTypeIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputType )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            DWORD dwTypeIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputType )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [in] */ const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputType )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [in] */ const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputCurrentType )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCurrentType )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [out] */ DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputSizeInfo )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [out] */ DWORD *pcbSize,
            /* [out] */ DWORD *pcbMaxLookahead,
            /* [out] */ DWORD *pcbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSizeInfo )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [out] */ DWORD *pcbSize,
            /* [out] */ DWORD *pcbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputMaxLatency )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [out] */ REFERENCE_TIME *prtMaxLatency);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputMaxLatency )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            REFERENCE_TIME rtMaxLatency);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Discontinuity )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateStreamingResources )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *FreeStreamingResources )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputStatus )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [out] */ DWORD *dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessInput )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            IMediaBuffer *pBuffer,
            DWORD dwFlags,
            REFERENCE_TIME rtTimestamp,
            REFERENCE_TIME rtTimelength);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessOutput )( 
            IMediaObject * This,
            DWORD dwFlags,
            DWORD cOutputBufferCount,
            /* [size_is][out][in] */ DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IMediaObject * This,
            LONG bLock);
        
        END_INTERFACE
    } IMediaObjectVtbl;

    interface IMediaObject
    {
        CONST_VTBL struct IMediaObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaObject_GetStreamCount(This,pcInputStreams,pcOutputStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcInputStreams,pcOutputStreams) ) 

#define IMediaObject_GetInputStreamInfo(This,dwInputStreamIndex,pdwFlags)	\
    ( (This)->lpVtbl -> GetInputStreamInfo(This,dwInputStreamIndex,pdwFlags) ) 

#define IMediaObject_GetOutputStreamInfo(This,dwOutputStreamIndex,pdwFlags)	\
    ( (This)->lpVtbl -> GetOutputStreamInfo(This,dwOutputStreamIndex,pdwFlags) ) 

#define IMediaObject_GetInputType(This,dwInputStreamIndex,dwTypeIndex,pmt)	\
    ( (This)->lpVtbl -> GetInputType(This,dwInputStreamIndex,dwTypeIndex,pmt) ) 

#define IMediaObject_GetOutputType(This,dwOutputStreamIndex,dwTypeIndex,pmt)	\
    ( (This)->lpVtbl -> GetOutputType(This,dwOutputStreamIndex,dwTypeIndex,pmt) ) 

#define IMediaObject_SetInputType(This,dwInputStreamIndex,pmt,dwFlags)	\
    ( (This)->lpVtbl -> SetInputType(This,dwInputStreamIndex,pmt,dwFlags) ) 

#define IMediaObject_SetOutputType(This,dwOutputStreamIndex,pmt,dwFlags)	\
    ( (This)->lpVtbl -> SetOutputType(This,dwOutputStreamIndex,pmt,dwFlags) ) 

#define IMediaObject_GetInputCurrentType(This,dwInputStreamIndex,pmt)	\
    ( (This)->lpVtbl -> GetInputCurrentType(This,dwInputStreamIndex,pmt) ) 

#define IMediaObject_GetOutputCurrentType(This,dwOutputStreamIndex,pmt)	\
    ( (This)->lpVtbl -> GetOutputCurrentType(This,dwOutputStreamIndex,pmt) ) 

#define IMediaObject_GetInputSizeInfo(This,dwInputStreamIndex,pcbSize,pcbMaxLookahead,pcbAlignment)	\
    ( (This)->lpVtbl -> GetInputSizeInfo(This,dwInputStreamIndex,pcbSize,pcbMaxLookahead,pcbAlignment) ) 

#define IMediaObject_GetOutputSizeInfo(This,dwOutputStreamIndex,pcbSize,pcbAlignment)	\
    ( (This)->lpVtbl -> GetOutputSizeInfo(This,dwOutputStreamIndex,pcbSize,pcbAlignment) ) 

#define IMediaObject_GetInputMaxLatency(This,dwInputStreamIndex,prtMaxLatency)	\
    ( (This)->lpVtbl -> GetInputMaxLatency(This,dwInputStreamIndex,prtMaxLatency) ) 

#define IMediaObject_SetInputMaxLatency(This,dwInputStreamIndex,rtMaxLatency)	\
    ( (This)->lpVtbl -> SetInputMaxLatency(This,dwInputStreamIndex,rtMaxLatency) ) 

#define IMediaObject_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#define IMediaObject_Discontinuity(This,dwInputStreamIndex)	\
    ( (This)->lpVtbl -> Discontinuity(This,dwInputStreamIndex) ) 

#define IMediaObject_AllocateStreamingResources(This)	\
    ( (This)->lpVtbl -> AllocateStreamingResources(This) ) 

#define IMediaObject_FreeStreamingResources(This)	\
    ( (This)->lpVtbl -> FreeStreamingResources(This) ) 

#define IMediaObject_GetInputStatus(This,dwInputStreamIndex,dwFlags)	\
    ( (This)->lpVtbl -> GetInputStatus(This,dwInputStreamIndex,dwFlags) ) 

#define IMediaObject_ProcessInput(This,dwInputStreamIndex,pBuffer,dwFlags,rtTimestamp,rtTimelength)	\
    ( (This)->lpVtbl -> ProcessInput(This,dwInputStreamIndex,pBuffer,dwFlags,rtTimestamp,rtTimelength) ) 

#define IMediaObject_ProcessOutput(This,dwFlags,cOutputBufferCount,pOutputBuffers,pdwStatus)	\
    ( (This)->lpVtbl -> ProcessOutput(This,dwFlags,cOutputBufferCount,pOutputBuffers,pdwStatus) ) 

#define IMediaObject_Lock(This,bLock)	\
    ( (This)->lpVtbl -> Lock(This,bLock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaObject_INTERFACE_DEFINED__ */


#ifndef __IEnumDMO_INTERFACE_DEFINED__
#define __IEnumDMO_INTERFACE_DEFINED__

/* interface IEnumDMO */
/* [uuid][object] */ 


EXTERN_C const IID IID_IEnumDMO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c3cd98a-2bfa-4a53-9c27-5249ba64ba0f")
    IEnumDMO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            DWORD cItemsToFetch,
            /* [length_is][size_is][out] */ CLSID *pCLSID,
            /* [string][length_is][size_is][out] */ WCHAR **Names,
            /* [out] */ DWORD *pcItemsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            DWORD cItemsToSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDMO **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDMOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDMO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDMO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDMO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDMO * This,
            DWORD cItemsToFetch,
            /* [length_is][size_is][out] */ CLSID *pCLSID,
            /* [string][length_is][size_is][out] */ WCHAR **Names,
            /* [out] */ DWORD *pcItemsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDMO * This,
            DWORD cItemsToSkip);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDMO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDMO * This,
            /* [out] */ IEnumDMO **ppEnum);
        
        END_INTERFACE
    } IEnumDMOVtbl;

    interface IEnumDMO
    {
        CONST_VTBL struct IEnumDMOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDMO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDMO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDMO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDMO_Next(This,cItemsToFetch,pCLSID,Names,pcItemsFetched)	\
    ( (This)->lpVtbl -> Next(This,cItemsToFetch,pCLSID,Names,pcItemsFetched) ) 

#define IEnumDMO_Skip(This,cItemsToSkip)	\
    ( (This)->lpVtbl -> Skip(This,cItemsToSkip) ) 

#define IEnumDMO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDMO_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDMO_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0003 */
/* [local] */ 


enum _DMO_INPLACE_PROCESS_FLAGS
    {	DMO_INPLACE_NORMAL	= 0,
	DMO_INPLACE_ZERO	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0003_v0_0_s_ifspec;

#ifndef __IMediaObjectInPlace_INTERFACE_DEFINED__
#define __IMediaObjectInPlace_INTERFACE_DEFINED__

/* interface IMediaObjectInPlace */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMediaObjectInPlace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("651b9ad0-0fc7-4aa9-9538-d89931010741")
    IMediaObjectInPlace : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Process( 
            /* [in] */ ULONG ulSize,
            /* [size_is][out][in] */ BYTE *pData,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMediaObjectInPlace **ppMediaObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLatency( 
            /* [out] */ REFERENCE_TIME *pLatencyTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaObjectInPlaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaObjectInPlace * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaObjectInPlace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaObjectInPlace * This);
        
        HRESULT ( STDMETHODCALLTYPE *Process )( 
            IMediaObjectInPlace * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][out][in] */ BYTE *pData,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMediaObjectInPlace * This,
            /* [out] */ IMediaObjectInPlace **ppMediaObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatency )( 
            IMediaObjectInPlace * This,
            /* [out] */ REFERENCE_TIME *pLatencyTime);
        
        END_INTERFACE
    } IMediaObjectInPlaceVtbl;

    interface IMediaObjectInPlace
    {
        CONST_VTBL struct IMediaObjectInPlaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaObjectInPlace_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaObjectInPlace_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaObjectInPlace_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaObjectInPlace_Process(This,ulSize,pData,refTimeStart,dwFlags)	\
    ( (This)->lpVtbl -> Process(This,ulSize,pData,refTimeStart,dwFlags) ) 

#define IMediaObjectInPlace_Clone(This,ppMediaObject)	\
    ( (This)->lpVtbl -> Clone(This,ppMediaObject) ) 

#define IMediaObjectInPlace_GetLatency(This,pLatencyTime)	\
    ( (This)->lpVtbl -> GetLatency(This,pLatencyTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaObjectInPlace_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0004 */
/* [local] */ 


enum _DMO_QUALITY_STATUS_FLAGS
    {	DMO_QUALITY_STATUS_ENABLED	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0004_v0_0_s_ifspec;

#ifndef __IDMOQualityControl_INTERFACE_DEFINED__
#define __IDMOQualityControl_INTERFACE_DEFINED__

/* interface IDMOQualityControl */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOQualityControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65abea96-cf36-453f-af8a-705e98f16260")
    IDMOQualityControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNow( 
            /* [in] */ REFERENCE_TIME rtNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOQualityControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOQualityControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOQualityControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOQualityControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNow )( 
            IDMOQualityControl * This,
            /* [in] */ REFERENCE_TIME rtNow);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IDMOQualityControl * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IDMOQualityControl * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IDMOQualityControlVtbl;

    interface IDMOQualityControl
    {
        CONST_VTBL struct IDMOQualityControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOQualityControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOQualityControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOQualityControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOQualityControl_SetNow(This,rtNow)	\
    ( (This)->lpVtbl -> SetNow(This,rtNow) ) 

#define IDMOQualityControl_SetStatus(This,dwFlags)	\
    ( (This)->lpVtbl -> SetStatus(This,dwFlags) ) 

#define IDMOQualityControl_GetStatus(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOQualityControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0005 */
/* [local] */ 


enum _DMO_VIDEO_OUTPUT_STREAM_FLAGS
    {	DMO_VOSF_NEEDS_PREVIOUS_SAMPLE	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0005_v0_0_s_ifspec;

#ifndef __IDMOVideoOutputOptimizations_INTERFACE_DEFINED__
#define __IDMOVideoOutputOptimizations_INTERFACE_DEFINED__

/* interface IDMOVideoOutputOptimizations */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOVideoOutputOptimizations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be8f4f4e-5b16-4d29-b350-7f6b5d9298ac")
    IDMOVideoOutputOptimizations : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryOperationModePreferences( 
            ULONG ulOutputStreamIndex,
            DWORD *pdwRequestedCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOperationMode( 
            ULONG ulOutputStreamIndex,
            DWORD dwEnabledFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentOperationMode( 
            ULONG ulOutputStreamIndex,
            DWORD *pdwEnabledFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSampleRequirements( 
            ULONG ulOutputStreamIndex,
            DWORD *pdwRequestedFeatures) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOVideoOutputOptimizationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOVideoOutputOptimizations * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOVideoOutputOptimizations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOVideoOutputOptimizations * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryOperationModePreferences )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            DWORD *pdwRequestedCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *SetOperationMode )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            DWORD dwEnabledFeatures);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentOperationMode )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            DWORD *pdwEnabledFeatures);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSampleRequirements )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            DWORD *pdwRequestedFeatures);
        
        END_INTERFACE
    } IDMOVideoOutputOptimizationsVtbl;

    interface IDMOVideoOutputOptimizations
    {
        CONST_VTBL struct IDMOVideoOutputOptimizationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOVideoOutputOptimizations_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOVideoOutputOptimizations_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOVideoOutputOptimizations_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOVideoOutputOptimizations_QueryOperationModePreferences(This,ulOutputStreamIndex,pdwRequestedCapabilities)	\
    ( (This)->lpVtbl -> QueryOperationModePreferences(This,ulOutputStreamIndex,pdwRequestedCapabilities) ) 

#define IDMOVideoOutputOptimizations_SetOperationMode(This,ulOutputStreamIndex,dwEnabledFeatures)	\
    ( (This)->lpVtbl -> SetOperationMode(This,ulOutputStreamIndex,dwEnabledFeatures) ) 

#define IDMOVideoOutputOptimizations_GetCurrentOperationMode(This,ulOutputStreamIndex,pdwEnabledFeatures)	\
    ( (This)->lpVtbl -> GetCurrentOperationMode(This,ulOutputStreamIndex,pdwEnabledFeatures) ) 

#define IDMOVideoOutputOptimizations_GetCurrentSampleRequirements(This,ulOutputStreamIndex,pdwRequestedFeatures)	\
    ( (This)->lpVtbl -> GetCurrentSampleRequirements(This,ulOutputStreamIndex,pdwRequestedFeatures) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOVideoOutputOptimizations_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\menumanager.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for MenuManager.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __MenuManager_h__
#define __MenuManager_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMenuSnapshot_FWD_DEFINED__
#define __IMenuSnapshot_FWD_DEFINED__
typedef interface IMenuSnapshot IMenuSnapshot;
#endif 	/* __IMenuSnapshot_FWD_DEFINED__ */


#ifndef __IVerbManager_FWD_DEFINED__
#define __IVerbManager_FWD_DEFINED__
typedef interface IVerbManager IVerbManager;
#endif 	/* __IVerbManager_FWD_DEFINED__ */


#ifndef __IMenuManager_FWD_DEFINED__
#define __IMenuManager_FWD_DEFINED__
typedef interface IMenuManager IMenuManager;
#endif 	/* __IMenuManager_FWD_DEFINED__ */


/* header files for imported files */
#include "vrtldata.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_MenuManager_0000_0000 */
/* [local] */ 

// Class Id for the default Menu Manager implementation.
// {C3B38A3C-F519-4e7e-92D8-8E911E7EDD1F}
DEFINE_GUID(CLSID_MenuManager, 0xc3b38a3c, 0xf519, 0x4e7e, 0x92, 0xd8, 0x8e, 0x91, 0x1e, 0x7e, 0xdd, 0x1f);

// Class Id for the default Verb Manager implementation.
// {376AD044-55AF-4da1-897C-F8A78A59999A}
DEFINE_GUID(CLSID_VerbManager, 0x376ad044, 0x55af, 0x4da1, 0x89, 0x7c, 0xf8, 0xa7, 0x8a, 0x59, 0x99, 0x9a);

// Failure code meaning that the object is not ready.
#define E_NOTREADY            HRESULT_FROM_WIN32(ERROR_NOT_READY)

// Event indicating that the softkeys have been updated.
#define VERBMANAGEREVENT_SOFTKEYSUPDATED   0x00000001

// Flags for InsertVerbSource.
#define VERBSOURCE_BEGINNING    ((IVerbSource*)0)
#define VERBSOURCE_END          ((IVerbSource*)1)

// Flags for group preference. All flags can be combined.
#define VERBMANAGER_GROUPPREFERENCE_USEGROUPSASSUBMENUS      0x01
#define VERBMANAGER_GROUPPREFERENCE_SORTBYGROUP              0x02

// ID for the Menu Manager's central menu button.
// Applications that need to perform custom menu enhancements
// may use this ID to identify the central menu during
// WM_INITMENUPOPUP handling.
#define MENUMANAGER_CENTRALMENU 100

typedef 
enum _VERBMANAGER_MENUACTIONSTATE
    {	VERBMANAGER_MENUACTIONSTATE_NORMAL	= 0,
	VERBMANAGER_MENUACTIONSTATE_DISABLED	= ( VERBMANAGER_MENUACTIONSTATE_NORMAL + 1 ) ,
	VERBMANAGER_MENUACTIONSTATE_REMOVED	= ( VERBMANAGER_MENUACTIONSTATE_DISABLED + 1 ) 
    } 	VERBMANAGER_MENUACTIONSTATE;

typedef 
enum _VERBMANAGER_MENUITEMTYPE
    {	VERBMANAGER_MENUITEMTYPE_NORMAL	= 0,
	VERBMANAGER_MENUITEMTYPE_SUBMENU	= ( VERBMANAGER_MENUITEMTYPE_NORMAL + 1 ) ,
	VERBMANAGER_MENUITEMTYPE_SEPARATOR	= ( VERBMANAGER_MENUITEMTYPE_SUBMENU + 1 ) 
    } 	VERBMANAGER_MENUITEMTYPE;

typedef struct _SOFTKEYVERB
    {
    IVerbSource *pVerbSource;
    VERBDESC *pVerbDesc;
    } 	SOFTKEYVERB;



extern RPC_IF_HANDLE __MIDL_itf_MenuManager_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_MenuManager_0000_0000_v0_0_s_ifspec;

#ifndef __IMenuSnapshot_INTERFACE_DEFINED__
#define __IMenuSnapshot_INTERFACE_DEFINED__

/* interface IMenuSnapshot */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMenuSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("629ad5bb-4862-430c-a4f8-c7476ef75414")
    IMenuSnapshot : public IVerbSnapshot
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMenuItemType( 
            /* [in] */ UINT uiVerb,
            /* [out] */ VERBMANAGER_MENUITEMTYPE *pMenuItemType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMenuSnapshot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMenuSnapshot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMenuSnapshot * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMenuSnapshot * This,
            /* [out] */ UINT *pcVerbCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbDescriptorRef )( 
            IMenuSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [out] */ VERBDESC **ppVerbDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtendedVerbProperty )( 
            IMenuSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [in] */ DWORD dwVerbPropertyID,
            /* [in] */ PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedVerbProperty )( 
            IMenuSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [in] */ DWORD dwVerbPropertyID,
            /* [out] */ PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSort )( 
            IMenuSnapshot * This,
            /* [in] */ VERBSNAPSHOTSORTBY sortbyNew);
        
        HRESULT ( STDMETHODCALLTYPE *GetSort )( 
            IMenuSnapshot * This,
            /* [out] */ VERBSNAPSHOTSORTBY *psortbyCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeVerb )( 
            IMenuSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [optional][in] */ HWND hwndOwner,
            /* [optional][in] */ PROPVARIANT *pVerbParam);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuItemType )( 
            IMenuSnapshot * This,
            /* [in] */ UINT uiVerb,
            /* [out] */ VERBMANAGER_MENUITEMTYPE *pMenuItemType);
        
        END_INTERFACE
    } IMenuSnapshotVtbl;

    interface IMenuSnapshot
    {
        CONST_VTBL struct IMenuSnapshotVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuSnapshot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMenuSnapshot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMenuSnapshot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMenuSnapshot_GetCount(This,pcVerbCount)	\
    ( (This)->lpVtbl -> GetCount(This,pcVerbCount) ) 

#define IMenuSnapshot_GetVerbDescriptorRef(This,uiVerb,ppVerbDesc)	\
    ( (This)->lpVtbl -> GetVerbDescriptorRef(This,uiVerb,ppVerbDesc) ) 

#define IMenuSnapshot_SetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue)	\
    ( (This)->lpVtbl -> SetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue) ) 

#define IMenuSnapshot_GetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue)	\
    ( (This)->lpVtbl -> GetExtendedVerbProperty(This,uiVerb,dwVerbPropertyID,pvarValue) ) 

#define IMenuSnapshot_SetSort(This,sortbyNew)	\
    ( (This)->lpVtbl -> SetSort(This,sortbyNew) ) 

#define IMenuSnapshot_GetSort(This,psortbyCurrent)	\
    ( (This)->lpVtbl -> GetSort(This,psortbyCurrent) ) 

#define IMenuSnapshot_InvokeVerb(This,uiVerb,hwndOwner,pVerbParam)	\
    ( (This)->lpVtbl -> InvokeVerb(This,uiVerb,hwndOwner,pVerbParam) ) 


#define IMenuSnapshot_GetMenuItemType(This,uiVerb,pMenuItemType)	\
    ( (This)->lpVtbl -> GetMenuItemType(This,uiVerb,pMenuItemType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuSnapshot_INTERFACE_DEFINED__ */


#ifndef __IVerbManager_INTERFACE_DEFINED__
#define __IVerbManager_INTERFACE_DEFINED__

/* interface IVerbManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IVerbManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79cdb1d8-9445-4ef9-958e-1ebf14e05a6a")
    IVerbManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertVerbSource( 
            /* [in] */ IVerbSource *pVerbSource,
            /* [in] */ IVerbSource *pInsertAfter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveVerbSource( 
            /* [in] */ IVerbSource *pVerbSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbSourceCount( 
            /* [retval][out] */ UINT *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbSource( 
            /* [in] */ UINT nIndex,
            /* [out] */ IVerbSource **ppVerbSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuActionState( 
            /* [in] */ VERBMANAGER_MENUACTIONSTATE MenuActionState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuActionState( 
            /* [retval][out] */ VERBMANAGER_MENUACTIONSTATE *pMenuActionState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGroupPreference( 
            /* [in] */ DWORD dwGroupPreference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupPreference( 
            /* [out] */ DWORD *pdwGroupPreference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSoftkeyVerb( 
            /* [in] */ UINT iSoftkey,
            /* [optional][in] */ const SOFTKEYVERB *pSoftkeyVerb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSoftkeyVerbs( 
            /* [max_is][in] */ const SOFTKEYVERB *rgSoftkeyVerbs,
            /* [in] */ UINT cSoftkeyVerbs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoftkeyVerbs( 
            /* [out] */ IVerbSnapshot **ppVerbSnapshot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeNotificationEvent( 
            /* [out] */ IEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuVerbs( 
            /* [in] */ LPCOLESTR pszMenuName,
            /* [out] */ IMenuSnapshot **ppSnapshot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVerbManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVerbManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVerbManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVerbManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertVerbSource )( 
            IVerbManager * This,
            /* [in] */ IVerbSource *pVerbSource,
            /* [in] */ IVerbSource *pInsertAfter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveVerbSource )( 
            IVerbManager * This,
            /* [in] */ IVerbSource *pVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSourceCount )( 
            IVerbManager * This,
            /* [retval][out] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbSource )( 
            IVerbManager * This,
            /* [in] */ UINT nIndex,
            /* [out] */ IVerbSource **ppVerbSource);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuActionState )( 
            IVerbManager * This,
            /* [in] */ VERBMANAGER_MENUACTIONSTATE MenuActionState);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuActionState )( 
            IVerbManager * This,
            /* [retval][out] */ VERBMANAGER_MENUACTIONSTATE *pMenuActionState);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupPreference )( 
            IVerbManager * This,
            /* [in] */ DWORD dwGroupPreference);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupPreference )( 
            IVerbManager * This,
            /* [out] */ DWORD *pdwGroupPreference);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoftkeyVerb )( 
            IVerbManager * This,
            /* [in] */ UINT iSoftkey,
            /* [optional][in] */ const SOFTKEYVERB *pSoftkeyVerb);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoftkeyVerbs )( 
            IVerbManager * This,
            /* [max_is][in] */ const SOFTKEYVERB *rgSoftkeyVerbs,
            /* [in] */ UINT cSoftkeyVerbs);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoftkeyVerbs )( 
            IVerbManager * This,
            /* [out] */ IVerbSnapshot **ppVerbSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeNotificationEvent )( 
            IVerbManager * This,
            /* [out] */ IEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuVerbs )( 
            IVerbManager * This,
            /* [in] */ LPCOLESTR pszMenuName,
            /* [out] */ IMenuSnapshot **ppSnapshot);
        
        END_INTERFACE
    } IVerbManagerVtbl;

    interface IVerbManager
    {
        CONST_VTBL struct IVerbManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVerbManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVerbManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVerbManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVerbManager_InsertVerbSource(This,pVerbSource,pInsertAfter)	\
    ( (This)->lpVtbl -> InsertVerbSource(This,pVerbSource,pInsertAfter) ) 

#define IVerbManager_RemoveVerbSource(This,pVerbSource)	\
    ( (This)->lpVtbl -> RemoveVerbSource(This,pVerbSource) ) 

#define IVerbManager_GetVerbSourceCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetVerbSourceCount(This,pcItems) ) 

#define IVerbManager_GetVerbSource(This,nIndex,ppVerbSource)	\
    ( (This)->lpVtbl -> GetVerbSource(This,nIndex,ppVerbSource) ) 

#define IVerbManager_SetMenuActionState(This,MenuActionState)	\
    ( (This)->lpVtbl -> SetMenuActionState(This,MenuActionState) ) 

#define IVerbManager_GetMenuActionState(This,pMenuActionState)	\
    ( (This)->lpVtbl -> GetMenuActionState(This,pMenuActionState) ) 

#define IVerbManager_SetGroupPreference(This,dwGroupPreference)	\
    ( (This)->lpVtbl -> SetGroupPreference(This,dwGroupPreference) ) 

#define IVerbManager_GetGroupPreference(This,pdwGroupPreference)	\
    ( (This)->lpVtbl -> GetGroupPreference(This,pdwGroupPreference) ) 

#define IVerbManager_SetSoftkeyVerb(This,iSoftkey,pSoftkeyVerb)	\
    ( (This)->lpVtbl -> SetSoftkeyVerb(This,iSoftkey,pSoftkeyVerb) ) 

#define IVerbManager_SetSoftkeyVerbs(This,rgSoftkeyVerbs,cSoftkeyVerbs)	\
    ( (This)->lpVtbl -> SetSoftkeyVerbs(This,rgSoftkeyVerbs,cSoftkeyVerbs) ) 

#define IVerbManager_GetSoftkeyVerbs(This,ppVerbSnapshot)	\
    ( (This)->lpVtbl -> GetSoftkeyVerbs(This,ppVerbSnapshot) ) 

#define IVerbManager_GetChangeNotificationEvent(This,ppEvent)	\
    ( (This)->lpVtbl -> GetChangeNotificationEvent(This,ppEvent) ) 

#define IVerbManager_GetMenuVerbs(This,pszMenuName,ppSnapshot)	\
    ( (This)->lpVtbl -> GetMenuVerbs(This,pszMenuName,ppSnapshot) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVerbManager_INTERFACE_DEFINED__ */


#ifndef __IMenuManager_INTERFACE_DEFINED__
#define __IMenuManager_INTERFACE_DEFINED__

/* interface IMenuManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMenuManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0f42d068-f9fe-4ec7-9c13-7130b7179232")
    IMenuManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVerbManager( 
            /* [in] */ IVerbManager *pVerbManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbManager( 
            /* [out] */ IVerbManager **ppVerbManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessWindowMessage( 
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult,
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDynamicIDRange( 
            /* [in] */ UINT idFirst,
            /* [in] */ UINT idLast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuBarWindow( 
            /* [out] */ HWND *phwndMenuBar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuPosition( 
            /* [in] */ const VERBDESC *pVerbDesc,
            /* [out] */ HMENU *phMenu,
            /* [out] */ UINT *puiPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVerbDesc( 
            /* [in] */ HMENU hMenu,
            /* [in] */ UINT uiPos,
            /* [out] */ VERBDESC **ppVerbDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMenuManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMenuManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMenuManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMenuManager * This,
            /* [in] */ HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *SetVerbManager )( 
            IMenuManager * This,
            /* [in] */ IVerbManager *pVerbManager);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbManager )( 
            IMenuManager * This,
            /* [out] */ IVerbManager **ppVerbManager);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessWindowMessage )( 
            IMenuManager * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetDynamicIDRange )( 
            IMenuManager * This,
            /* [in] */ UINT idFirst,
            /* [in] */ UINT idLast);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuBarWindow )( 
            IMenuManager * This,
            /* [out] */ HWND *phwndMenuBar);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuPosition )( 
            IMenuManager * This,
            /* [in] */ const VERBDESC *pVerbDesc,
            /* [out] */ HMENU *phMenu,
            /* [out] */ UINT *puiPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVerbDesc )( 
            IMenuManager * This,
            /* [in] */ HMENU hMenu,
            /* [in] */ UINT uiPos,
            /* [out] */ VERBDESC **ppVerbDesc);
        
        END_INTERFACE
    } IMenuManagerVtbl;

    interface IMenuManager
    {
        CONST_VTBL struct IMenuManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMenuManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMenuManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMenuManager_Initialize(This,hwndParent)	\
    ( (This)->lpVtbl -> Initialize(This,hwndParent) ) 

#define IMenuManager_SetVerbManager(This,pVerbManager)	\
    ( (This)->lpVtbl -> SetVerbManager(This,pVerbManager) ) 

#define IMenuManager_GetVerbManager(This,ppVerbManager)	\
    ( (This)->lpVtbl -> GetVerbManager(This,ppVerbManager) ) 

#define IMenuManager_ProcessWindowMessage(This,uMsg,wParam,lParam,plResult,hwnd)	\
    ( (This)->lpVtbl -> ProcessWindowMessage(This,uMsg,wParam,lParam,plResult,hwnd) ) 

#define IMenuManager_SetDynamicIDRange(This,idFirst,idLast)	\
    ( (This)->lpVtbl -> SetDynamicIDRange(This,idFirst,idLast) ) 

#define IMenuManager_GetMenuBarWindow(This,phwndMenuBar)	\
    ( (This)->lpVtbl -> GetMenuBarWindow(This,phwndMenuBar) ) 

#define IMenuManager_GetMenuPosition(This,pVerbDesc,phMenu,puiPos)	\
    ( (This)->lpVtbl -> GetMenuPosition(This,pVerbDesc,phMenu,puiPos) ) 

#define IMenuManager_GetVerbDesc(This,hMenu,uiPos,ppVerbDesc)	\
    ( (This)->lpVtbl -> GetVerbDesc(This,hMenu,uiPos,ppVerbDesc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMenuManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HMENU_UserSize(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\memory.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#pragma once
#include "stdlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\medparam.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for medparam.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __medparam_h__
#define __medparam_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMediaParamInfo_FWD_DEFINED__
#define __IMediaParamInfo_FWD_DEFINED__
typedef interface IMediaParamInfo IMediaParamInfo;
#endif 	/* __IMediaParamInfo_FWD_DEFINED__ */


#ifndef __IMediaParams_FWD_DEFINED__
#define __IMediaParams_FWD_DEFINED__
typedef interface IMediaParams IMediaParams;
#endif 	/* __IMediaParams_FWD_DEFINED__ */


#ifndef __IMediaParamsRecordNotify_FWD_DEFINED__
#define __IMediaParamsRecordNotify_FWD_DEFINED__
typedef interface IMediaParamsRecordNotify IMediaParamsRecordNotify;
#endif 	/* __IMediaParamsRecordNotify_FWD_DEFINED__ */


#ifndef __IMediaParamsRecord_FWD_DEFINED__
#define __IMediaParamsRecord_FWD_DEFINED__
typedef interface IMediaParamsRecord IMediaParamsRecord;
#endif 	/* __IMediaParamsRecord_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_medparam_0000_0000 */
/* [local] */ 

typedef float MP_DATA;

typedef 
enum _MP_Type
    {	MPT_INT	= 0,
	MPT_FLOAT	= ( MPT_INT + 1 ) ,
	MPT_BOOL	= ( MPT_FLOAT + 1 ) ,
	MPT_ENUM	= ( MPT_BOOL + 1 ) ,
	MPT_MAX	= ( MPT_ENUM + 1 ) 
    } 	MP_TYPE;

#define	MPBOOL_TRUE	( 1 )

#define	MPBOOL_FALSE	( 0 )

typedef 
enum _MP_CURVE_TYPE
    {	MP_CURVE_JUMP	= 0x1,
	MP_CURVE_LINEAR	= 0x2,
	MP_CURVE_SQUARE	= 0x4,
	MP_CURVE_INVSQUARE	= 0x8,
	MP_CURVE_SINE	= 0x10
    } 	MP_CURVE_TYPE;

typedef DWORD MP_CAPS;

#define	MP_CAPS_CURVE_JUMP	( MP_CURVE_JUMP )

#define	MP_CAPS_CURVE_LINEAR	( MP_CURVE_LINEAR )

#define	MP_CAPS_CURVE_SQUARE	( MP_CURVE_SQUARE )

#define	MP_CAPS_CURVE_INVSQUARE	( MP_CURVE_INVSQUARE )

#define	MP_CAPS_CURVE_SINE	( MP_CURVE_SINE )

typedef struct _MP_PARAMINFO
    {
    MP_TYPE mpType;
    MP_CAPS mopCaps;
    MP_DATA mpdMinValue;
    MP_DATA mpdMaxValue;
    MP_DATA mpdNeutralValue;
    WCHAR szUnitText[ 32 ];
    WCHAR szLabel[ 32 ];
    } 	MP_PARAMINFO;

typedef DWORD DWORD;

#define	DWORD_ALLPARAMS	( -1 )

typedef DWORD MP_TIMEDATA;

DEFINE_GUID(GUID_TIME_REFERENCE,
0x93ad712b, 0xdaa0, 0x4ffe, 0xbc, 0x81, 0xb0, 0xce, 0x50, 0xf, 0xcd, 0xd9);
DEFINE_GUID(GUID_TIME_MUSIC,
0x574c49d, 0x5b04, 0x4b15, 0xa5, 0x42, 0xae, 0x28, 0x20, 0x30, 0x11, 0x7b);
DEFINE_GUID(GUID_TIME_SAMPLES,
0xa8593d05, 0xc43, 0x4984, 0x9a, 0x63, 0x97, 0xaf, 0x9e, 0x2, 0xc4, 0xc0);
typedef DWORD MP_FLAGS;

#define	MPF_ENVLP_STANDARD	( 0 )

#define	MPF_ENVLP_BEGIN_CURRENTVAL	( 0x1 )

#define	MPF_ENVLP_BEGIN_NEUTRALVAL	( 0x2 )

typedef struct _MP_ENVELOPE_SEGMENT
    {
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    MP_DATA valStart;
    MP_DATA valEnd;
    MP_CURVE_TYPE iCurve;
    MP_FLAGS flags;
    } 	MP_ENVELOPE_SEGMENT;

#define	MPF_PUNCHIN_REFTIME	( 0 )

#define	MPF_PUNCHIN_NOW	( 0x1 )

#define	MPF_PUNCHIN_STOPPED	( 0x2 )



extern RPC_IF_HANDLE __MIDL_itf_medparam_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_medparam_0000_0000_v0_0_s_ifspec;

#ifndef __IMediaParamInfo_INTERFACE_DEFINED__
#define __IMediaParamInfo_INTERFACE_DEFINED__

/* interface IMediaParamInfo */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d6cbb60-a223-44aa-842f-a2f06750be6d")
    IMediaParamInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParamCount( 
            /* [out] */ DWORD *pdwParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamInfo( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_PARAMINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamText( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ WCHAR **ppwchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumTimeFormats( 
            /* [out] */ DWORD *pdwNumTimeFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedTimeFormat( 
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ GUID *pguidTimeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTimeFormat( 
            /* [out] */ GUID *pguidTimeFormat,
            /* [out] */ MP_TIMEDATA *pTimeData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaParamInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaParamInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaParamInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParamCount )( 
            IMediaParamInfo * This,
            /* [out] */ DWORD *pdwParams);
        
        HRESULT ( STDMETHODCALLTYPE *GetParamInfo )( 
            IMediaParamInfo * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_PARAMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetParamText )( 
            IMediaParamInfo * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ WCHAR **ppwchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumTimeFormats )( 
            IMediaParamInfo * This,
            /* [out] */ DWORD *pdwNumTimeFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedTimeFormat )( 
            IMediaParamInfo * This,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ GUID *pguidTimeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentTimeFormat )( 
            IMediaParamInfo * This,
            /* [out] */ GUID *pguidTimeFormat,
            /* [out] */ MP_TIMEDATA *pTimeData);
        
        END_INTERFACE
    } IMediaParamInfoVtbl;

    interface IMediaParamInfo
    {
        CONST_VTBL struct IMediaParamInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaParamInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaParamInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaParamInfo_GetParamCount(This,pdwParams)	\
    ( (This)->lpVtbl -> GetParamCount(This,pdwParams) ) 

#define IMediaParamInfo_GetParamInfo(This,dwParamIndex,pInfo)	\
    ( (This)->lpVtbl -> GetParamInfo(This,dwParamIndex,pInfo) ) 

#define IMediaParamInfo_GetParamText(This,dwParamIndex,ppwchText)	\
    ( (This)->lpVtbl -> GetParamText(This,dwParamIndex,ppwchText) ) 

#define IMediaParamInfo_GetNumTimeFormats(This,pdwNumTimeFormats)	\
    ( (This)->lpVtbl -> GetNumTimeFormats(This,pdwNumTimeFormats) ) 

#define IMediaParamInfo_GetSupportedTimeFormat(This,dwFormatIndex,pguidTimeFormat)	\
    ( (This)->lpVtbl -> GetSupportedTimeFormat(This,dwFormatIndex,pguidTimeFormat) ) 

#define IMediaParamInfo_GetCurrentTimeFormat(This,pguidTimeFormat,pTimeData)	\
    ( (This)->lpVtbl -> GetCurrentTimeFormat(This,pguidTimeFormat,pTimeData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaParamInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaParams_INTERFACE_DEFINED__
#define __IMediaParams_INTERFACE_DEFINED__

/* interface IMediaParams */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d6cbb61-a223-44aa-842f-a2f06750be6e")
    IMediaParams : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParam( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_DATA *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParam( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ MP_DATA value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnvelope( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ DWORD cSegments,
            /* [in] */ MP_ENVELOPE_SEGMENT *pEnvelopeSegments) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushEnvelope( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ REFERENCE_TIME refTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeFormat( 
            /* [in] */ GUID guidTimeFormat,
            /* [in] */ MP_TIMEDATA mpTimeData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaParams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaParams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaParams * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParam )( 
            IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ MP_DATA *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetParam )( 
            IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ MP_DATA value);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnvelope )( 
            IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ DWORD cSegments,
            /* [in] */ MP_ENVELOPE_SEGMENT *pEnvelopeSegments);
        
        HRESULT ( STDMETHODCALLTYPE *FlushEnvelope )( 
            IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ REFERENCE_TIME refTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            IMediaParams * This,
            /* [in] */ GUID guidTimeFormat,
            /* [in] */ MP_TIMEDATA mpTimeData);
        
        END_INTERFACE
    } IMediaParamsVtbl;

    interface IMediaParams
    {
        CONST_VTBL struct IMediaParamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParams_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaParams_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaParams_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaParams_GetParam(This,dwParamIndex,pValue)	\
    ( (This)->lpVtbl -> GetParam(This,dwParamIndex,pValue) ) 

#define IMediaParams_SetParam(This,dwParamIndex,value)	\
    ( (This)->lpVtbl -> SetParam(This,dwParamIndex,value) ) 

#define IMediaParams_AddEnvelope(This,dwParamIndex,cSegments,pEnvelopeSegments)	\
    ( (This)->lpVtbl -> AddEnvelope(This,dwParamIndex,cSegments,pEnvelopeSegments) ) 

#define IMediaParams_FlushEnvelope(This,dwParamIndex,refTimeStart,refTimeEnd)	\
    ( (This)->lpVtbl -> FlushEnvelope(This,dwParamIndex,refTimeStart,refTimeEnd) ) 

#define IMediaParams_SetTimeFormat(This,guidTimeFormat,mpTimeData)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,guidTimeFormat,mpTimeData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaParams_INTERFACE_DEFINED__ */


#ifndef __IMediaParamsRecordNotify_INTERFACE_DEFINED__
#define __IMediaParamsRecordNotify_INTERFACE_DEFINED__

/* interface IMediaParamsRecordNotify */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamsRecordNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fea74878-4e39-4267-8a17-6aaf0536ff7c")
    IMediaParamsRecordNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchedIn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParamChanged( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD cNumSegments,
            /* [in] */ MP_ENVELOPE_SEGMENT *pEnvelopeSegments) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsRecordNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaParamsRecordNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaParamsRecordNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaParamsRecordNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitRecording )( 
            IMediaParamsRecordNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *PunchedIn )( 
            IMediaParamsRecordNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *PunchedOut )( 
            IMediaParamsRecordNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndRecording )( 
            IMediaParamsRecordNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParamChanged )( 
            IMediaParamsRecordNotify * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD cNumSegments,
            /* [in] */ MP_ENVELOPE_SEGMENT *pEnvelopeSegments);
        
        END_INTERFACE
    } IMediaParamsRecordNotifyVtbl;

    interface IMediaParamsRecordNotify
    {
        CONST_VTBL struct IMediaParamsRecordNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamsRecordNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaParamsRecordNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaParamsRecordNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaParamsRecordNotify_InitRecording(This)	\
    ( (This)->lpVtbl -> InitRecording(This) ) 

#define IMediaParamsRecordNotify_PunchedIn(This)	\
    ( (This)->lpVtbl -> PunchedIn(This) ) 

#define IMediaParamsRecordNotify_PunchedOut(This)	\
    ( (This)->lpVtbl -> PunchedOut(This) ) 

#define IMediaParamsRecordNotify_EndRecording(This)	\
    ( (This)->lpVtbl -> EndRecording(This) ) 

#define IMediaParamsRecordNotify_ParamChanged(This,dwIndex,cNumSegments,pEnvelopeSegments)	\
    ( (This)->lpVtbl -> ParamChanged(This,dwIndex,cNumSegments,pEnvelopeSegments) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaParamsRecordNotify_INTERFACE_DEFINED__ */


#ifndef __IMediaParamsRecord_INTERFACE_DEFINED__
#define __IMediaParamsRecord_INTERFACE_DEFINED__

/* interface IMediaParamsRecord */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamsRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b64d1a-8e24-40f6-8797-44cc021b2a0a")
    IMediaParamsRecord : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitRecording( 
            /* [in] */ IMediaParamsRecordNotify *pINotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchIn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PunchOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRecording( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaParamsRecord * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaParamsRecord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaParamsRecord * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitRecording )( 
            IMediaParamsRecord * This,
            /* [in] */ IMediaParamsRecordNotify *pINotify);
        
        HRESULT ( STDMETHODCALLTYPE *PunchIn )( 
            IMediaParamsRecord * This);
        
        HRESULT ( STDMETHODCALLTYPE *PunchOut )( 
            IMediaParamsRecord * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndRecording )( 
            IMediaParamsRecord * This);
        
        END_INTERFACE
    } IMediaParamsRecordVtbl;

    interface IMediaParamsRecord
    {
        CONST_VTBL struct IMediaParamsRecordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamsRecord_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaParamsRecord_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaParamsRecord_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaParamsRecord_InitRecording(This,pINotify)	\
    ( (This)->lpVtbl -> InitRecording(This,pINotify) ) 

#define IMediaParamsRecord_PunchIn(This)	\
    ( (This)->lpVtbl -> PunchIn(This) ) 

#define IMediaParamsRecord_PunchOut(This)	\
    ( (This)->lpVtbl -> PunchOut(This) ) 

#define IMediaParamsRecord_EndRecording(This)	\
    ( (This)->lpVtbl -> EndRecording(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaParamsRecord_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mfinternal.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for mfinternal.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mfinternal_h__
#define __mfinternal_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMDEOpCenter_FWD_DEFINED__
#define __IMDEOpCenter_FWD_DEFINED__
typedef interface IMDEOpCenter IMDEOpCenter;
#endif 	/* __IMDEOpCenter_FWD_DEFINED__ */


#ifndef __IMDEOutputProfileManager_FWD_DEFINED__
#define __IMDEOutputProfileManager_FWD_DEFINED__
typedef interface IMDEOutputProfileManager IMDEOutputProfileManager;
#endif 	/* __IMDEOutputProfileManager_FWD_DEFINED__ */


#ifndef __IMDEDatapath_FWD_DEFINED__
#define __IMDEDatapath_FWD_DEFINED__
typedef interface IMDEDatapath IMDEDatapath;
#endif 	/* __IMDEDatapath_FWD_DEFINED__ */


#ifndef __IMDETranscodeManager_FWD_DEFINED__
#define __IMDETranscodeManager_FWD_DEFINED__
typedef interface IMDETranscodeManager IMDETranscodeManager;
#endif 	/* __IMDETranscodeManager_FWD_DEFINED__ */


#ifndef __IMFByteStreamTimeSeek_FWD_DEFINED__
#define __IMFByteStreamTimeSeek_FWD_DEFINED__
typedef interface IMFByteStreamTimeSeek IMFByteStreamTimeSeek;
#endif 	/* __IMFByteStreamTimeSeek_FWD_DEFINED__ */


#ifndef __IMFByteStreamCacheControl_FWD_DEFINED__
#define __IMFByteStreamCacheControl_FWD_DEFINED__
typedef interface IMFByteStreamCacheControl IMFByteStreamCacheControl;
#endif 	/* __IMFByteStreamCacheControl_FWD_DEFINED__ */


#ifndef __IMFByteStreamProgressiveDownload_FWD_DEFINED__
#define __IMFByteStreamProgressiveDownload_FWD_DEFINED__
typedef interface IMFByteStreamProgressiveDownload IMFByteStreamProgressiveDownload;
#endif 	/* __IMFByteStreamProgressiveDownload_FWD_DEFINED__ */


#ifndef __IMFMediaProcessor_FWD_DEFINED__
#define __IMFMediaProcessor_FWD_DEFINED__
typedef interface IMFMediaProcessor IMFMediaProcessor;
#endif 	/* __IMFMediaProcessor_FWD_DEFINED__ */


#ifndef __IMFMediaProcessorStream_FWD_DEFINED__
#define __IMFMediaProcessorStream_FWD_DEFINED__
typedef interface IMFMediaProcessorStream IMFMediaProcessorStream;
#endif 	/* __IMFMediaProcessorStream_FWD_DEFINED__ */


#ifndef __IMFStallableTimeSource_FWD_DEFINED__
#define __IMFStallableTimeSource_FWD_DEFINED__
typedef interface IMFStallableTimeSource IMFStallableTimeSource;
#endif 	/* __IMFStallableTimeSource_FWD_DEFINED__ */


#ifndef __IMFRatelessTimeSource_FWD_DEFINED__
#define __IMFRatelessTimeSource_FWD_DEFINED__
typedef interface IMFRatelessTimeSource IMFRatelessTimeSource;
#endif 	/* __IMFRatelessTimeSource_FWD_DEFINED__ */


#ifndef __IMFClockRateMatch_FWD_DEFINED__
#define __IMFClockRateMatch_FWD_DEFINED__
typedef interface IMFClockRateMatch IMFClockRateMatch;
#endif 	/* __IMFClockRateMatch_FWD_DEFINED__ */


#ifndef __IMFPMPHostInternal_FWD_DEFINED__
#define __IMFPMPHostInternal_FWD_DEFINED__
typedef interface IMFPMPHostInternal IMFPMPHostInternal;
#endif 	/* __IMFPMPHostInternal_FWD_DEFINED__ */


#ifndef __IMFPMPServerInternal_FWD_DEFINED__
#define __IMFPMPServerInternal_FWD_DEFINED__
typedef interface IMFPMPServerInternal IMFPMPServerInternal;
#endif 	/* __IMFPMPServerInternal_FWD_DEFINED__ */


#ifndef __IMFPMPServerLock_FWD_DEFINED__
#define __IMFPMPServerLock_FWD_DEFINED__
typedef interface IMFPMPServerLock IMFPMPServerLock;
#endif 	/* __IMFPMPServerLock_FWD_DEFINED__ */


#ifndef __IMFComponentCreator_FWD_DEFINED__
#define __IMFComponentCreator_FWD_DEFINED__
typedef interface IMFComponentCreator IMFComponentCreator;
#endif 	/* __IMFComponentCreator_FWD_DEFINED__ */


#ifndef __IMFSequencerRemoteStreamCallback_FWD_DEFINED__
#define __IMFSequencerRemoteStreamCallback_FWD_DEFINED__
typedef interface IMFSequencerRemoteStreamCallback IMFSequencerRemoteStreamCallback;
#endif 	/* __IMFSequencerRemoteStreamCallback_FWD_DEFINED__ */


#ifndef __IMFDebugPMPSession_FWD_DEFINED__
#define __IMFDebugPMPSession_FWD_DEFINED__
typedef interface IMFDebugPMPSession IMFDebugPMPSession;
#endif 	/* __IMFDebugPMPSession_FWD_DEFINED__ */


#ifndef __IMFNetworkCongestionControl_FWD_DEFINED__
#define __IMFNetworkCongestionControl_FWD_DEFINED__
typedef interface IMFNetworkCongestionControl IMFNetworkCongestionControl;
#endif 	/* __IMFNetworkCongestionControl_FWD_DEFINED__ */


#ifndef __IMFCongestionHandler_FWD_DEFINED__
#define __IMFCongestionHandler_FWD_DEFINED__
typedef interface IMFCongestionHandler IMFCongestionHandler;
#endif 	/* __IMFCongestionHandler_FWD_DEFINED__ */


#ifndef __CMFNetworkCongestionControl_FWD_DEFINED__
#define __CMFNetworkCongestionControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMFNetworkCongestionControl CMFNetworkCongestionControl;
#else
typedef struct CMFNetworkCongestionControl CMFNetworkCongestionControl;
#endif /* __cplusplus */

#endif 	/* __CMFNetworkCongestionControl_FWD_DEFINED__ */


#ifndef __IMFDebugNetSource_FWD_DEFINED__
#define __IMFDebugNetSource_FWD_DEFINED__
typedef interface IMFDebugNetSource IMFDebugNetSource;
#endif 	/* __IMFDebugNetSource_FWD_DEFINED__ */


#ifndef __IMFNetMessageTransfer_FWD_DEFINED__
#define __IMFNetMessageTransfer_FWD_DEFINED__
typedef interface IMFNetMessageTransfer IMFNetMessageTransfer;
#endif 	/* __IMFNetMessageTransfer_FWD_DEFINED__ */


#ifndef __IMFNetConnection_FWD_DEFINED__
#define __IMFNetConnection_FWD_DEFINED__
typedef interface IMFNetConnection IMFNetConnection;
#endif 	/* __IMFNetConnection_FWD_DEFINED__ */


#ifndef __IMFNetChannelFactory_FWD_DEFINED__
#define __IMFNetChannelFactory_FWD_DEFINED__
typedef interface IMFNetChannelFactory IMFNetChannelFactory;
#endif 	/* __IMFNetChannelFactory_FWD_DEFINED__ */


#ifndef __IMFAuthenticationContext_FWD_DEFINED__
#define __IMFAuthenticationContext_FWD_DEFINED__
typedef interface IMFAuthenticationContext IMFAuthenticationContext;
#endif 	/* __IMFAuthenticationContext_FWD_DEFINED__ */


#ifndef __IMFChannelAccelerator_FWD_DEFINED__
#define __IMFChannelAccelerator_FWD_DEFINED__
typedef interface IMFChannelAccelerator IMFChannelAccelerator;
#endif 	/* __IMFChannelAccelerator_FWD_DEFINED__ */


#ifndef __IMFMediaCacheStream_FWD_DEFINED__
#define __IMFMediaCacheStream_FWD_DEFINED__
typedef interface IMFMediaCacheStream IMFMediaCacheStream;
#endif 	/* __IMFMediaCacheStream_FWD_DEFINED__ */


#ifndef __IMFMediaCache_FWD_DEFINED__
#define __IMFMediaCache_FWD_DEFINED__
typedef interface IMFMediaCache IMFMediaCache;
#endif 	/* __IMFMediaCache_FWD_DEFINED__ */


#ifndef __IMFMediaCacheManager_FWD_DEFINED__
#define __IMFMediaCacheManager_FWD_DEFINED__
typedef interface IMFMediaCacheManager IMFMediaCacheManager;
#endif 	/* __IMFMediaCacheManager_FWD_DEFINED__ */


#ifndef __IMFRecordQueue_FWD_DEFINED__
#define __IMFRecordQueue_FWD_DEFINED__
typedef interface IMFRecordQueue IMFRecordQueue;
#endif 	/* __IMFRecordQueue_FWD_DEFINED__ */


#ifndef __IMFNetBufferControl_FWD_DEFINED__
#define __IMFNetBufferControl_FWD_DEFINED__
typedef interface IMFNetBufferControl IMFNetBufferControl;
#endif 	/* __IMFNetBufferControl_FWD_DEFINED__ */


#ifndef __IMFNetEvent_FWD_DEFINED__
#define __IMFNetEvent_FWD_DEFINED__
typedef interface IMFNetEvent IMFNetEvent;
#endif 	/* __IMFNetEvent_FWD_DEFINED__ */


#ifndef __IMFNetRawEvent_FWD_DEFINED__
#define __IMFNetRawEvent_FWD_DEFINED__
typedef interface IMFNetRawEvent IMFNetRawEvent;
#endif 	/* __IMFNetRawEvent_FWD_DEFINED__ */


#ifndef __IMFNetCardeaLicenseRequestEvent_FWD_DEFINED__
#define __IMFNetCardeaLicenseRequestEvent_FWD_DEFINED__
typedef interface IMFNetCardeaLicenseRequestEvent IMFNetCardeaLicenseRequestEvent;
#endif 	/* __IMFNetCardeaLicenseRequestEvent_FWD_DEFINED__ */


#ifndef __IMFNetDownloadEvent_FWD_DEFINED__
#define __IMFNetDownloadEvent_FWD_DEFINED__
typedef interface IMFNetDownloadEvent IMFNetDownloadEvent;
#endif 	/* __IMFNetDownloadEvent_FWD_DEFINED__ */


#ifndef __IMFNetDescribeEvent_FWD_DEFINED__
#define __IMFNetDescribeEvent_FWD_DEFINED__
typedef interface IMFNetDescribeEvent IMFNetDescribeEvent;
#endif 	/* __IMFNetDescribeEvent_FWD_DEFINED__ */


#ifndef __IMFNetSelectStreamsEvent_FWD_DEFINED__
#define __IMFNetSelectStreamsEvent_FWD_DEFINED__
typedef interface IMFNetSelectStreamsEvent IMFNetSelectStreamsEvent;
#endif 	/* __IMFNetSelectStreamsEvent_FWD_DEFINED__ */


#ifndef __IMFNetPlayEvent_FWD_DEFINED__
#define __IMFNetPlayEvent_FWD_DEFINED__
typedef interface IMFNetPlayEvent IMFNetPlayEvent;
#endif 	/* __IMFNetPlayEvent_FWD_DEFINED__ */


#ifndef __IMFNetEosEvent_FWD_DEFINED__
#define __IMFNetEosEvent_FWD_DEFINED__
typedef interface IMFNetEosEvent IMFNetEosEvent;
#endif 	/* __IMFNetEosEvent_FWD_DEFINED__ */


#ifndef __IMFNetCloseEvent_FWD_DEFINED__
#define __IMFNetCloseEvent_FWD_DEFINED__
typedef interface IMFNetCloseEvent IMFNetCloseEvent;
#endif 	/* __IMFNetCloseEvent_FWD_DEFINED__ */


#ifndef __IMFNackHandler_FWD_DEFINED__
#define __IMFNackHandler_FWD_DEFINED__
typedef interface IMFNackHandler IMFNackHandler;
#endif 	/* __IMFNackHandler_FWD_DEFINED__ */


#ifndef __IMFRrHandler_FWD_DEFINED__
#define __IMFRrHandler_FWD_DEFINED__
typedef interface IMFRrHandler IMFRrHandler;
#endif 	/* __IMFRrHandler_FWD_DEFINED__ */


#ifndef __IMFBfrHandler_FWD_DEFINED__
#define __IMFBfrHandler_FWD_DEFINED__
typedef interface IMFBfrHandler IMFBfrHandler;
#endif 	/* __IMFBfrHandler_FWD_DEFINED__ */


#ifndef __IMFRtspSinkActivate_FWD_DEFINED__
#define __IMFRtspSinkActivate_FWD_DEFINED__
typedef interface IMFRtspSinkActivate IMFRtspSinkActivate;
#endif 	/* __IMFRtspSinkActivate_FWD_DEFINED__ */


#ifndef __IMFNetSinkConfig_FWD_DEFINED__
#define __IMFNetSinkConfig_FWD_DEFINED__
typedef interface IMFNetSinkConfig IMFNetSinkConfig;
#endif 	/* __IMFNetSinkConfig_FWD_DEFINED__ */


#ifndef __IMFNetLogEvent_FWD_DEFINED__
#define __IMFNetLogEvent_FWD_DEFINED__
typedef interface IMFNetLogEvent IMFNetLogEvent;
#endif 	/* __IMFNetLogEvent_FWD_DEFINED__ */


#ifndef __IMFSdpTemplate_FWD_DEFINED__
#define __IMFSdpTemplate_FWD_DEFINED__
typedef interface IMFSdpTemplate IMFSdpTemplate;
#endif 	/* __IMFSdpTemplate_FWD_DEFINED__ */


#ifndef __IMFNetPresentationTarget_FWD_DEFINED__
#define __IMFNetPresentationTarget_FWD_DEFINED__
typedef interface IMFNetPresentationTarget IMFNetPresentationTarget;
#endif 	/* __IMFNetPresentationTarget_FWD_DEFINED__ */


#ifndef __IMFMcastConfig_FWD_DEFINED__
#define __IMFMcastConfig_FWD_DEFINED__
typedef interface IMFMcastConfig IMFMcastConfig;
#endif 	/* __IMFMcastConfig_FWD_DEFINED__ */


#ifndef __IMFStreamSignalHandler_FWD_DEFINED__
#define __IMFStreamSignalHandler_FWD_DEFINED__
typedef interface IMFStreamSignalHandler IMFStreamSignalHandler;
#endif 	/* __IMFStreamSignalHandler_FWD_DEFINED__ */


#ifndef __IMFNetHttpPushSetup_FWD_DEFINED__
#define __IMFNetHttpPushSetup_FWD_DEFINED__
typedef interface IMFNetHttpPushSetup IMFNetHttpPushSetup;
#endif 	/* __IMFNetHttpPushSetup_FWD_DEFINED__ */


#ifndef __IMFLPCMSinkActivate_FWD_DEFINED__
#define __IMFLPCMSinkActivate_FWD_DEFINED__
typedef interface IMFLPCMSinkActivate IMFLPCMSinkActivate;
#endif 	/* __IMFLPCMSinkActivate_FWD_DEFINED__ */


#ifndef __IMFMPEG2SinkActivate_FWD_DEFINED__
#define __IMFMPEG2SinkActivate_FWD_DEFINED__
typedef interface IMFMPEG2SinkActivate IMFMPEG2SinkActivate;
#endif 	/* __IMFMPEG2SinkActivate_FWD_DEFINED__ */


#ifndef __IMFNetChannelActivate_FWD_DEFINED__
#define __IMFNetChannelActivate_FWD_DEFINED__
typedef interface IMFNetChannelActivate IMFNetChannelActivate;
#endif 	/* __IMFNetChannelActivate_FWD_DEFINED__ */


#ifndef __IMFPersistStreamMap_FWD_DEFINED__
#define __IMFPersistStreamMap_FWD_DEFINED__
typedef interface IMFPersistStreamMap IMFPersistStreamMap;
#endif 	/* __IMFPersistStreamMap_FWD_DEFINED__ */


#ifndef __IMFLock_FWD_DEFINED__
#define __IMFLock_FWD_DEFINED__
typedef interface IMFLock IMFLock;
#endif 	/* __IMFLock_FWD_DEFINED__ */


#ifndef __IMFWMDRMITACreator_FWD_DEFINED__
#define __IMFWMDRMITACreator_FWD_DEFINED__
typedef interface IMFWMDRMITACreator IMFWMDRMITACreator;
#endif 	/* __IMFWMDRMITACreator_FWD_DEFINED__ */


#ifndef __IMFTopologyPriv_FWD_DEFINED__
#define __IMFTopologyPriv_FWD_DEFINED__
typedef interface IMFTopologyPriv IMFTopologyPriv;
#endif 	/* __IMFTopologyPriv_FWD_DEFINED__ */


#ifndef __IMFTopoConnector_FWD_DEFINED__
#define __IMFTopoConnector_FWD_DEFINED__
typedef interface IMFTopoConnector IMFTopoConnector;
#endif 	/* __IMFTopoConnector_FWD_DEFINED__ */


#ifndef __IMFPersistMetadata_FWD_DEFINED__
#define __IMFPersistMetadata_FWD_DEFINED__
typedef interface IMFPersistMetadata IMFPersistMetadata;
#endif 	/* __IMFPersistMetadata_FWD_DEFINED__ */


#ifndef __IPropertyStoreLanguage_FWD_DEFINED__
#define __IPropertyStoreLanguage_FWD_DEFINED__
typedef interface IPropertyStoreLanguage IPropertyStoreLanguage;
#endif 	/* __IPropertyStoreLanguage_FWD_DEFINED__ */


#ifndef __IPropertyAdvanced_FWD_DEFINED__
#define __IPropertyAdvanced_FWD_DEFINED__
typedef interface IPropertyAdvanced IPropertyAdvanced;
#endif 	/* __IPropertyAdvanced_FWD_DEFINED__ */


#ifndef __IEnumProperty_FWD_DEFINED__
#define __IEnumProperty_FWD_DEFINED__
typedef interface IEnumProperty IEnumProperty;
#endif 	/* __IEnumProperty_FWD_DEFINED__ */


#ifndef __IPropertyStoreAdvanced_FWD_DEFINED__
#define __IPropertyStoreAdvanced_FWD_DEFINED__
typedef interface IPropertyStoreAdvanced IPropertyStoreAdvanced;
#endif 	/* __IPropertyStoreAdvanced_FWD_DEFINED__ */


#ifndef __IMFNetChannel_FWD_DEFINED__
#define __IMFNetChannel_FWD_DEFINED__
typedef interface IMFNetChannel IMFNetChannel;
#endif 	/* __IMFNetChannel_FWD_DEFINED__ */


#ifndef __IMFNetHeaderCollection_FWD_DEFINED__
#define __IMFNetHeaderCollection_FWD_DEFINED__
typedef interface IMFNetHeaderCollection IMFNetHeaderCollection;
#endif 	/* __IMFNetHeaderCollection_FWD_DEFINED__ */


#ifndef __IMFNetListener_FWD_DEFINED__
#define __IMFNetListener_FWD_DEFINED__
typedef interface IMFNetListener IMFNetListener;
#endif 	/* __IMFNetListener_FWD_DEFINED__ */


#ifndef __IMFNetSessionFactory_FWD_DEFINED__
#define __IMFNetSessionFactory_FWD_DEFINED__
typedef interface IMFNetSessionFactory IMFNetSessionFactory;
#endif 	/* __IMFNetSessionFactory_FWD_DEFINED__ */


#ifndef __IMFNetVRoot_FWD_DEFINED__
#define __IMFNetVRoot_FWD_DEFINED__
typedef interface IMFNetVRoot IMFNetVRoot;
#endif 	/* __IMFNetVRoot_FWD_DEFINED__ */


#ifndef __IMFNetUrlTransformEvent_FWD_DEFINED__
#define __IMFNetUrlTransformEvent_FWD_DEFINED__
typedef interface IMFNetUrlTransformEvent IMFNetUrlTransformEvent;
#endif 	/* __IMFNetUrlTransformEvent_FWD_DEFINED__ */


#ifndef __IMFNetProfilesEvent_FWD_DEFINED__
#define __IMFNetProfilesEvent_FWD_DEFINED__
typedef interface IMFNetProfilesEvent IMFNetProfilesEvent;
#endif 	/* __IMFNetProfilesEvent_FWD_DEFINED__ */


#ifndef __IMFNetEventHandler_FWD_DEFINED__
#define __IMFNetEventHandler_FWD_DEFINED__
typedef interface IMFNetEventHandler IMFNetEventHandler;
#endif 	/* __IMFNetEventHandler_FWD_DEFINED__ */


#ifndef __IMFNetSinkControlConnection_FWD_DEFINED__
#define __IMFNetSinkControlConnection_FWD_DEFINED__
typedef interface IMFNetSinkControlConnection IMFNetSinkControlConnection;
#endif 	/* __IMFNetSinkControlConnection_FWD_DEFINED__ */


#ifndef __IMFNetSession_FWD_DEFINED__
#define __IMFNetSession_FWD_DEFINED__
typedef interface IMFNetSession IMFNetSession;
#endif 	/* __IMFNetSession_FWD_DEFINED__ */


#ifndef __IMFLine21Decoder_FWD_DEFINED__
#define __IMFLine21Decoder_FWD_DEFINED__
typedef interface IMFLine21Decoder IMFLine21Decoder;
#endif 	/* __IMFLine21Decoder_FWD_DEFINED__ */


#ifndef __IMFStatistics_FWD_DEFINED__
#define __IMFStatistics_FWD_DEFINED__
typedef interface IMFStatistics IMFStatistics;
#endif 	/* __IMFStatistics_FWD_DEFINED__ */


#ifndef __IMFStatisticsCollection_FWD_DEFINED__
#define __IMFStatisticsCollection_FWD_DEFINED__
typedef interface IMFStatisticsCollection IMFStatisticsCollection;
#endif 	/* __IMFStatisticsCollection_FWD_DEFINED__ */


#ifndef __IMFStatisticsSite_FWD_DEFINED__
#define __IMFStatisticsSite_FWD_DEFINED__
typedef interface IMFStatisticsSite IMFStatisticsSite;
#endif 	/* __IMFStatisticsSite_FWD_DEFINED__ */


#ifndef __IMFDescriptorInterpreter_FWD_DEFINED__
#define __IMFDescriptorInterpreter_FWD_DEFINED__
typedef interface IMFDescriptorInterpreter IMFDescriptorInterpreter;
#endif 	/* __IMFDescriptorInterpreter_FWD_DEFINED__ */


#ifndef __IMFGetMultipleServiceProviders_FWD_DEFINED__
#define __IMFGetMultipleServiceProviders_FWD_DEFINED__
typedef interface IMFGetMultipleServiceProviders IMFGetMultipleServiceProviders;
#endif 	/* __IMFGetMultipleServiceProviders_FWD_DEFINED__ */


#ifndef __IMFPMPSessionHost_FWD_DEFINED__
#define __IMFPMPSessionHost_FWD_DEFINED__
typedef interface IMFPMPSessionHost IMFPMPSessionHost;
#endif 	/* __IMFPMPSessionHost_FWD_DEFINED__ */


#ifndef __IMFByteStreamReservation_FWD_DEFINED__
#define __IMFByteStreamReservation_FWD_DEFINED__
typedef interface IMFByteStreamReservation IMFByteStreamReservation;
#endif 	/* __IMFByteStreamReservation_FWD_DEFINED__ */


#ifndef __IMFSourceHeaderParserPlugin_FWD_DEFINED__
#define __IMFSourceHeaderParserPlugin_FWD_DEFINED__
typedef interface IMFSourceHeaderParserPlugin IMFSourceHeaderParserPlugin;
#endif 	/* __IMFSourceHeaderParserPlugin_FWD_DEFINED__ */


#ifndef __IMFSourceIndexParserPlugin_FWD_DEFINED__
#define __IMFSourceIndexParserPlugin_FWD_DEFINED__
typedef interface IMFSourceIndexParserPlugin IMFSourceIndexParserPlugin;
#endif 	/* __IMFSourceIndexParserPlugin_FWD_DEFINED__ */


#ifndef __IMFSourceDataParserPlugin_FWD_DEFINED__
#define __IMFSourceDataParserPlugin_FWD_DEFINED__
typedef interface IMFSourceDataParserPlugin IMFSourceDataParserPlugin;
#endif 	/* __IMFSourceDataParserPlugin_FWD_DEFINED__ */


#ifndef __IMFMP3ContentInfo_FWD_DEFINED__
#define __IMFMP3ContentInfo_FWD_DEFINED__
typedef interface IMFMP3ContentInfo IMFMP3ContentInfo;
#endif 	/* __IMFMP3ContentInfo_FWD_DEFINED__ */


#ifndef __WMDRMContext_FWD_DEFINED__
#define __WMDRMContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMDRMContext WMDRMContext;
#else
typedef struct WMDRMContext WMDRMContext;
#endif /* __cplusplus */

#endif 	/* __WMDRMContext_FWD_DEFINED__ */


#ifndef __MFContentProtectionManager_FWD_DEFINED__
#define __MFContentProtectionManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MFContentProtectionManager MFContentProtectionManager;
#else
typedef struct MFContentProtectionManager MFContentProtectionManager;
#endif /* __cplusplus */

#endif 	/* __MFContentProtectionManager_FWD_DEFINED__ */


#ifndef __MFContentEnabler_FWD_DEFINED__
#define __MFContentEnabler_FWD_DEFINED__

#ifdef __cplusplus
typedef class MFContentEnabler MFContentEnabler;
#else
typedef struct MFContentEnabler MFContentEnabler;
#endif /* __cplusplus */

#endif 	/* __MFContentEnabler_FWD_DEFINED__ */


#ifndef __COutputProfileMgr_FWD_DEFINED__
#define __COutputProfileMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class COutputProfileMgr COutputProfileMgr;
#else
typedef struct COutputProfileMgr COutputProfileMgr;
#endif /* __cplusplus */

#endif 	/* __COutputProfileMgr_FWD_DEFINED__ */


#ifndef __CDevProxy_FWD_DEFINED__
#define __CDevProxy_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDevProxy CDevProxy;
#else
typedef struct CDevProxy CDevProxy;
#endif /* __cplusplus */

#endif 	/* __CDevProxy_FWD_DEFINED__ */


#ifndef __IMFTransformFieldOfUse_FWD_DEFINED__
#define __IMFTransformFieldOfUse_FWD_DEFINED__
typedef interface IMFTransformFieldOfUse IMFTransformFieldOfUse;
#endif 	/* __IMFTransformFieldOfUse_FWD_DEFINED__ */


/* header files for imported files */
#include "mfidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mfinternal_0000_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0000_v0_0_s_ifspec;

#ifndef __IMDEOpCenter_INTERFACE_DEFINED__
#define __IMDEOpCenter_INTERFACE_DEFINED__

/* interface IMDEOpCenter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMDEOpCenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("797775F0-F123-4041-AEEB-0C09357CB32E")
    IMDEOpCenter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddURL( 
            /* [in] */ LPCWSTR wszURL,
            /* [in] */ IMFNetVRoot *pVroot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveURL( 
            /* [in] */ LPCWSTR wszURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProfiles( 
            /* [out] */ IMFCollection **ppProfileCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDecoderAvailable( 
            /* [in] */ LPCWSTR pwszContainerMIMEType,
            /* [in] */ GUID guidMajorType,
            /* [in] */ GUID guidSubType,
            /* [out] */ BOOL *pfIsAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDEOpCenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMDEOpCenter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMDEOpCenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMDEOpCenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddURL )( 
            IMDEOpCenter * This,
            /* [in] */ LPCWSTR wszURL,
            /* [in] */ IMFNetVRoot *pVroot);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveURL )( 
            IMDEOpCenter * This,
            /* [in] */ LPCWSTR wszURL);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProfiles )( 
            IMDEOpCenter * This,
            /* [out] */ IMFCollection **ppProfileCollection);
        
        HRESULT ( STDMETHODCALLTYPE *IsDecoderAvailable )( 
            IMDEOpCenter * This,
            /* [in] */ LPCWSTR pwszContainerMIMEType,
            /* [in] */ GUID guidMajorType,
            /* [in] */ GUID guidSubType,
            /* [out] */ BOOL *pfIsAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMDEOpCenter * This);
        
        END_INTERFACE
    } IMDEOpCenterVtbl;

    interface IMDEOpCenter
    {
        CONST_VTBL struct IMDEOpCenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDEOpCenter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMDEOpCenter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMDEOpCenter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMDEOpCenter_AddURL(This,wszURL,pVroot)	\
    ( (This)->lpVtbl -> AddURL(This,wszURL,pVroot) ) 

#define IMDEOpCenter_RemoveURL(This,wszURL)	\
    ( (This)->lpVtbl -> RemoveURL(This,wszURL) ) 

#define IMDEOpCenter_GetSupportedProfiles(This,ppProfileCollection)	\
    ( (This)->lpVtbl -> GetSupportedProfiles(This,ppProfileCollection) ) 

#define IMDEOpCenter_IsDecoderAvailable(This,pwszContainerMIMEType,guidMajorType,guidSubType,pfIsAvailable)	\
    ( (This)->lpVtbl -> IsDecoderAvailable(This,pwszContainerMIMEType,guidMajorType,guidSubType,pfIsAvailable) ) 

#define IMDEOpCenter_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMDEOpCenter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0001 */
/* [local] */ 

STDAPI MFCreateMDEOpCenter(
    LPCWSTR wszProfileDirPath,
    __out IMDEOpCenter **ppMDEOpCenter);
STDAPI MFCreateWMPMDEOpCenter(
    LPCWSTR wszProfileDirPath,
    __out IMDEOpCenter **ppMDEOpCenter);
typedef 
enum _OUTPUT_PROFILE_TYPE
    {	FILE_DOWNLOAD	= 0,
	IMAGE_DOWNLOAD	= 1,
	AUDIO_VIDEO_STREAMING	= 2
    } 	OUTPUT_PROFILE_TYPE;




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0001_v0_0_s_ifspec;

#ifndef __IMDEOutputProfileManager_INTERFACE_DEFINED__
#define __IMDEOutputProfileManager_INTERFACE_DEFINED__

/* interface IMDEOutputProfileManager */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMDEOutputProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DA03F4A9-D4D8-4769-A0E3-3591BA6ADFB9")
    IMDEOutputProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ LPCWSTR wszXMLFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProfiles( 
            /* [annotation][out] */ 
            __out  IMFCollection **ppProfileCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginGetSupportedProfiles( 
            /* [in] */ LPCWSTR wszFilePath,
            /* [in] */ IPropertyStore *pPropertyStore,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndGetSupportedProfiles( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFCollection **ppCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContainsProfile( 
            /* [in] */ GUID profileGUID,
            /* [annotation][out] */ 
            __out  BOOL *pfContainsProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMDEDatapath( 
            /* [in] */ LPCWSTR wszFilePath,
            /* [in] */ LPCWSTR wszSelectedProtocol,
            /* [in] */ IPropertyStore *pSelectedProfile,
            /* [annotation][out] */ 
            __out  IMDEDatapath **ppMDEDatapath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDEOutputProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMDEOutputProfileManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMDEOutputProfileManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMDEOutputProfileManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IMDEOutputProfileManager * This,
            /* [in] */ LPCWSTR wszXMLFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProfiles )( 
            IMDEOutputProfileManager * This,
            /* [annotation][out] */ 
            __out  IMFCollection **ppProfileCollection);
        
        HRESULT ( STDMETHODCALLTYPE *BeginGetSupportedProfiles )( 
            IMDEOutputProfileManager * This,
            /* [in] */ LPCWSTR wszFilePath,
            /* [in] */ IPropertyStore *pPropertyStore,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndGetSupportedProfiles )( 
            IMDEOutputProfileManager * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFCollection **ppCollection);
        
        HRESULT ( STDMETHODCALLTYPE *ContainsProfile )( 
            IMDEOutputProfileManager * This,
            /* [in] */ GUID profileGUID,
            /* [annotation][out] */ 
            __out  BOOL *pfContainsProfile);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMDEDatapath )( 
            IMDEOutputProfileManager * This,
            /* [in] */ LPCWSTR wszFilePath,
            /* [in] */ LPCWSTR wszSelectedProtocol,
            /* [in] */ IPropertyStore *pSelectedProfile,
            /* [annotation][out] */ 
            __out  IMDEDatapath **ppMDEDatapath);
        
        END_INTERFACE
    } IMDEOutputProfileManagerVtbl;

    interface IMDEOutputProfileManager
    {
        CONST_VTBL struct IMDEOutputProfileManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDEOutputProfileManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMDEOutputProfileManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMDEOutputProfileManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMDEOutputProfileManager_Load(This,wszXMLFile)	\
    ( (This)->lpVtbl -> Load(This,wszXMLFile) ) 

#define IMDEOutputProfileManager_GetSupportedProfiles(This,ppProfileCollection)	\
    ( (This)->lpVtbl -> GetSupportedProfiles(This,ppProfileCollection) ) 

#define IMDEOutputProfileManager_BeginGetSupportedProfiles(This,wszFilePath,pPropertyStore,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginGetSupportedProfiles(This,wszFilePath,pPropertyStore,pCallback,pState) ) 

#define IMDEOutputProfileManager_EndGetSupportedProfiles(This,pResult,ppCollection)	\
    ( (This)->lpVtbl -> EndGetSupportedProfiles(This,pResult,ppCollection) ) 

#define IMDEOutputProfileManager_ContainsProfile(This,profileGUID,pfContainsProfile)	\
    ( (This)->lpVtbl -> ContainsProfile(This,profileGUID,pfContainsProfile) ) 

#define IMDEOutputProfileManager_CreateMDEDatapath(This,wszFilePath,wszSelectedProtocol,pSelectedProfile,ppMDEDatapath)	\
    ( (This)->lpVtbl -> CreateMDEDatapath(This,wszFilePath,wszSelectedProtocol,pSelectedProfile,ppMDEDatapath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMDEOutputProfileManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0002 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0002_v0_0_s_ifspec;

#ifndef __IMDEDatapath_INTERFACE_DEFINED__
#define __IMDEDatapath_INTERFACE_DEFINED__

/* interface IMDEDatapath */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMDEDatapath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("479AF05B-FFB9-4227-BC12-CB5D601BA5F2")
    IMDEDatapath : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDelegate( 
            /* [in] */ MediaEventType NetControlEventType,
            /* [annotation][out] */ 
            __out  IMFNetEventHandler **ppDelegate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDEDatapathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMDEDatapath * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMDEDatapath * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMDEDatapath * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelegate )( 
            IMDEDatapath * This,
            /* [in] */ MediaEventType NetControlEventType,
            /* [annotation][out] */ 
            __out  IMFNetEventHandler **ppDelegate);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMDEDatapath * This);
        
        END_INTERFACE
    } IMDEDatapathVtbl;

    interface IMDEDatapath
    {
        CONST_VTBL struct IMDEDatapathVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDEDatapath_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMDEDatapath_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMDEDatapath_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMDEDatapath_GetDelegate(This,NetControlEventType,ppDelegate)	\
    ( (This)->lpVtbl -> GetDelegate(This,NetControlEventType,ppDelegate) ) 

#define IMDEDatapath_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMDEDatapath_INTERFACE_DEFINED__ */


#ifndef __IMDETranscodeManager_INTERFACE_DEFINED__
#define __IMDETranscodeManager_INTERFACE_DEFINED__

/* interface IMDETranscodeManager */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMDETranscodeManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d9effea-35ce-4d76-96df-0706bc7a6967")
    IMDETranscodeManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterTranscodeOperation( 
            /* [in] */ DWORD cSoftwareAudioStreams,
            /* [in] */ DWORD cHardwareAudioStreams,
            /* [in] */ DWORD cSoftwareVideoStreams,
            /* [in] */ DWORD cHardwareVideoStreams,
            /* [annotation][out] */ 
            __out  IUnknown **ppRegistrationState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDETranscodeManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMDETranscodeManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMDETranscodeManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMDETranscodeManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterTranscodeOperation )( 
            IMDETranscodeManager * This,
            /* [in] */ DWORD cSoftwareAudioStreams,
            /* [in] */ DWORD cHardwareAudioStreams,
            /* [in] */ DWORD cSoftwareVideoStreams,
            /* [in] */ DWORD cHardwareVideoStreams,
            /* [annotation][out] */ 
            __out  IUnknown **ppRegistrationState);
        
        END_INTERFACE
    } IMDETranscodeManagerVtbl;

    interface IMDETranscodeManager
    {
        CONST_VTBL struct IMDETranscodeManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDETranscodeManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMDETranscodeManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMDETranscodeManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMDETranscodeManager_RegisterTranscodeOperation(This,cSoftwareAudioStreams,cHardwareAudioStreams,cSoftwareVideoStreams,cHardwareVideoStreams,ppRegistrationState)	\
    ( (This)->lpVtbl -> RegisterTranscodeOperation(This,cSoftwareAudioStreams,cHardwareAudioStreams,cSoftwareVideoStreams,cHardwareVideoStreams,ppRegistrationState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMDETranscodeManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0004 */
/* [local] */ 

EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_UNIQUE_PROFILEID;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_UNIQUE_GROUPID;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_TRANSCODING_PROFILE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_INPUTMIMETYPE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_OUTPUTMIMETYPE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_DLNA_LABEL;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_RTSP_ENABLED;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_RTSP_RTPPACKETIZER;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_RTSP_SDPGENERATOR;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_HTTP_ENABLED;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_CARDEA_ENABLED;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_DTCP_ENABLED;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_PMPUSAGE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_BYTESEEK_SUPPORTED;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_TIMESEEK_SUPPORTED;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_PLAYSPEEDS;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_SAMPLESPERSEC;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_BITSPERSAMPLE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_AVGBYTESPERSECOND;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_NUMBEROFCHANNELS;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_DEVICECONFORMANCETEMPLATE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_DEVICECONFORMANCETEMPLATE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_MIMETYPE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_WIDTH;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_HEIGHT;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_BITRATE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_BUFFERWINDOW;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_FRAMESPERSECOND;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_KEYFRAMESINTERVAL;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_ENCODERCOMPLEXITY;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_IMAGE_WIDTH;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_IMAGE_HEIGHT;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_IMAGE_ASPECT_RATIO_X;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_IMAGE_ASPECT_RATIO_Y;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_BACKGROUND_COLOR_R;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_BACKGROUND_COLOR_G;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_BACKGROUND_COLOR_B;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_THUMBNAIL;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_BACKGROUNDTRANSFER;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_WINSAT_CPU;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_WINSAT_MEMORY;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_SOURCE_PRESENTATION;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_RTP_PAYLOAD_FORMAT;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_IFOFILEURI;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_WINSAT_ENCODE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_SUBTYPE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_SUBTYPE;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_AUDIO_PASSTHROUGH;
EXTERN_C const PROPERTYKEY PKEY_MDEPROFILE_VIDEO_PASSTHROUGH;
EXTERN_C const GUID MDE_DEFAULT_DOWNLOADPROFILE;
EXTERN_C const GUID MDE_DEFAULT_WMAUDIOVIDEOPROFILE;
EXTERN_C const GUID MDE_DEFAULT_PCMPROFILE;
EXTERN_C const GUID MDE_DEFAULT_JPEGPROFILE;
EXTERN_C const GUID MDE_DEFAULT_YUVPROFILE;
EXTERN_C const PROPERTYKEY PKEY_MFNETCONNECTION_DOWNLOADREQUEST;
EXTERN_C const GUID CLSID_TV_PROFILEMGR;
EXTERN_C const GUID MFNETSOURCE_AUTHENTICATION_MANAGER;
EXTERN_GUID( MFNETSOURCE_ENABLE_MSB, 0x3cb1f296, 0x0505, 0x4c5d, 0xae, 0x71, 0x0a, 0x55, 0x63, 0x44, 0xef, 0xa1 );
EXTERN_GUID( MFNETSOURCE_ENABLE_RTPM, 0x3cb1f297, 0x0505, 0x4c5d, 0xae, 0x71, 0x0a, 0x55, 0x63, 0x44, 0xef, 0xa1 );
EXTERN_C const GUID MFSAMPLE_NetSequenceNumber;
EXTERN_C const GUID MF_MT_NODRM_RTP_PT;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0004_v0_0_s_ifspec;

#ifndef __IMFByteStreamTimeSeek_INTERFACE_DEFINED__
#define __IMFByteStreamTimeSeek_INTERFACE_DEFINED__

/* interface IMFByteStreamTimeSeek */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFByteStreamTimeSeek;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64976BFA-FB61-4041-9069-8C9A5F659BEB")
    IMFByteStreamTimeSeek : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsTimeSeekSupported( 
            /* [annotation][out] */ 
            __out  BOOL *pfTimeSeekIsSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeSeek( 
            /* [in] */ QWORD qwTimePosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeSeekResult( 
            /* [out] */ QWORD *pqwStartTime,
            /* [out] */ QWORD *pqwStopTime,
            /* [out] */ QWORD *pqwDuration) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFByteStreamTimeSeekVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFByteStreamTimeSeek * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFByteStreamTimeSeek * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFByteStreamTimeSeek * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTimeSeekSupported )( 
            IMFByteStreamTimeSeek * This,
            /* [annotation][out] */ 
            __out  BOOL *pfTimeSeekIsSupported);
        
        HRESULT ( STDMETHODCALLTYPE *TimeSeek )( 
            IMFByteStreamTimeSeek * This,
            /* [in] */ QWORD qwTimePosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeSeekResult )( 
            IMFByteStreamTimeSeek * This,
            /* [out] */ QWORD *pqwStartTime,
            /* [out] */ QWORD *pqwStopTime,
            /* [out] */ QWORD *pqwDuration);
        
        END_INTERFACE
    } IMFByteStreamTimeSeekVtbl;

    interface IMFByteStreamTimeSeek
    {
        CONST_VTBL struct IMFByteStreamTimeSeekVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFByteStreamTimeSeek_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFByteStreamTimeSeek_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFByteStreamTimeSeek_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFByteStreamTimeSeek_IsTimeSeekSupported(This,pfTimeSeekIsSupported)	\
    ( (This)->lpVtbl -> IsTimeSeekSupported(This,pfTimeSeekIsSupported) ) 

#define IMFByteStreamTimeSeek_TimeSeek(This,qwTimePosition)	\
    ( (This)->lpVtbl -> TimeSeek(This,qwTimePosition) ) 

#define IMFByteStreamTimeSeek_GetTimeSeekResult(This,pqwStartTime,pqwStopTime,pqwDuration)	\
    ( (This)->lpVtbl -> GetTimeSeekResult(This,pqwStartTime,pqwStopTime,pqwDuration) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFByteStreamTimeSeek_INTERFACE_DEFINED__ */


#ifndef __IMFByteStreamCacheControl_INTERFACE_DEFINED__
#define __IMFByteStreamCacheControl_INTERFACE_DEFINED__

/* interface IMFByteStreamCacheControl */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFByteStreamCacheControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5042EA4-7A96-4a75-AA7B-2BE1EF7F88D5")
    IMFByteStreamCacheControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StopBackgroundTransfer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFByteStreamCacheControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFByteStreamCacheControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFByteStreamCacheControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFByteStreamCacheControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopBackgroundTransfer )( 
            IMFByteStreamCacheControl * This);
        
        END_INTERFACE
    } IMFByteStreamCacheControlVtbl;

    interface IMFByteStreamCacheControl
    {
        CONST_VTBL struct IMFByteStreamCacheControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFByteStreamCacheControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFByteStreamCacheControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFByteStreamCacheControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFByteStreamCacheControl_StopBackgroundTransfer(This)	\
    ( (This)->lpVtbl -> StopBackgroundTransfer(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFByteStreamCacheControl_INTERFACE_DEFINED__ */


#ifndef __IMFByteStreamProgressiveDownload_INTERFACE_DEFINED__
#define __IMFByteStreamProgressiveDownload_INTERFACE_DEFINED__

/* interface IMFByteStreamProgressiveDownload */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFByteStreamProgressiveDownload;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF92650A-D0E5-40a4-8EA2-1FE69E8AD6AC")
    IMFByteStreamProgressiveDownload : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDownloadedLength( 
            /* [annotation][out] */ 
            __out  QWORD *pqwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFByteStreamProgressiveDownloadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFByteStreamProgressiveDownload * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFByteStreamProgressiveDownload * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFByteStreamProgressiveDownload * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadedLength )( 
            IMFByteStreamProgressiveDownload * This,
            /* [annotation][out] */ 
            __out  QWORD *pqwLength);
        
        END_INTERFACE
    } IMFByteStreamProgressiveDownloadVtbl;

    interface IMFByteStreamProgressiveDownload
    {
        CONST_VTBL struct IMFByteStreamProgressiveDownloadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFByteStreamProgressiveDownload_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFByteStreamProgressiveDownload_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFByteStreamProgressiveDownload_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFByteStreamProgressiveDownload_GetDownloadedLength(This,pqwLength)	\
    ( (This)->lpVtbl -> GetDownloadedLength(This,pqwLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFByteStreamProgressiveDownload_INTERFACE_DEFINED__ */


#ifndef __IMFMediaProcessor_INTERFACE_DEFINED__
#define __IMFMediaProcessor_INTERFACE_DEFINED__

/* interface IMFMediaProcessor */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMediaProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7bc6644e-2146-4122-833c-27d74d37121f")
    IMFMediaProcessor : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [annotation][out] */ 
            __out  DWORD *pdwCharacteristics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [annotation][unique][in] */ 
            __in_opt  const GUID *pguidTimeFormat,
            /* [annotation][unique][in] */ 
            __in  const PROPVARIANT *pvarStartPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTopology( 
            /* [in] */ IMFTopology *pTopology,
            /* [in] */ BOOL fParameterIsIgnoredAndWillBeRemoved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceEndTopology( 
            /* [in] */ IMFTopology *pTopology) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQualityManager( 
            /* [in] */ IMFQualityManager *pQualityManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMFMediaProcessor * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaProcessor * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaProcessor * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            IMFMediaProcessor * This,
            /* [in] */ MediaEventType met,
            /* [in] */ REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            IMFMediaProcessor * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IMFMediaProcessor * This,
            /* [annotation][unique][in] */ 
            __in_opt  const GUID *pguidTimeFormat,
            /* [annotation][unique][in] */ 
            __in  const PROPVARIANT *pvarStartPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMFMediaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMFMediaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFMediaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTopology )( 
            IMFMediaProcessor * This,
            /* [in] */ IMFTopology *pTopology,
            /* [in] */ BOOL fParameterIsIgnoredAndWillBeRemoved);
        
        HRESULT ( STDMETHODCALLTYPE *ForceEndTopology )( 
            IMFMediaProcessor * This,
            /* [in] */ IMFTopology *pTopology);
        
        HRESULT ( STDMETHODCALLTYPE *SetQualityManager )( 
            IMFMediaProcessor * This,
            /* [in] */ IMFQualityManager *pQualityManager);
        
        END_INTERFACE
    } IMFMediaProcessorVtbl;

    interface IMFMediaProcessor
    {
        CONST_VTBL struct IMFMediaProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaProcessor_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaProcessor_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaProcessor_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaProcessor_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaProcessor_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#define IMFMediaProcessor_Start(This,pguidTimeFormat,pvarStartPosition)	\
    ( (This)->lpVtbl -> Start(This,pguidTimeFormat,pvarStartPosition) ) 

#define IMFMediaProcessor_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMFMediaProcessor_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMFMediaProcessor_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IMFMediaProcessor_SetTopology(This,pTopology,fParameterIsIgnoredAndWillBeRemoved)	\
    ( (This)->lpVtbl -> SetTopology(This,pTopology,fParameterIsIgnoredAndWillBeRemoved) ) 

#define IMFMediaProcessor_ForceEndTopology(This,pTopology)	\
    ( (This)->lpVtbl -> ForceEndTopology(This,pTopology) ) 

#define IMFMediaProcessor_SetQualityManager(This,pQualityManager)	\
    ( (This)->lpVtbl -> SetQualityManager(This,pQualityManager) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaProcessor_INTERFACE_DEFINED__ */


#ifndef __IMFMediaProcessorStream_INTERFACE_DEFINED__
#define __IMFMediaProcessorStream_INTERFACE_DEFINED__

/* interface IMFMediaProcessorStream */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMediaProcessorStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7bc6644f-2146-4122-833c-27d74d37121f")
    IMFMediaProcessorStream : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNodeId( 
            /* [annotation][out] */ 
            __out  TOPOID *pTopoId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestSample( 
            /* [in] */ IUnknown *pToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaProcessorStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaProcessorStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaProcessorStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaProcessorStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMFMediaProcessorStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaProcessorStream * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaProcessorStream * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            IMFMediaProcessorStream * This,
            /* [in] */ MediaEventType met,
            /* [in] */ REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeId )( 
            IMFMediaProcessorStream * This,
            /* [annotation][out] */ 
            __out  TOPOID *pTopoId);
        
        HRESULT ( STDMETHODCALLTYPE *RequestSample )( 
            IMFMediaProcessorStream * This,
            /* [in] */ IUnknown *pToken);
        
        END_INTERFACE
    } IMFMediaProcessorStreamVtbl;

    interface IMFMediaProcessorStream
    {
        CONST_VTBL struct IMFMediaProcessorStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaProcessorStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaProcessorStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaProcessorStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaProcessorStream_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaProcessorStream_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaProcessorStream_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaProcessorStream_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaProcessorStream_GetNodeId(This,pTopoId)	\
    ( (This)->lpVtbl -> GetNodeId(This,pTopoId) ) 

#define IMFMediaProcessorStream_RequestSample(This,pToken)	\
    ( (This)->lpVtbl -> RequestSample(This,pToken) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaProcessorStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0009 */
/* [local] */ 

STDAPI MFCreateDShowGraphSource(
	__in LPCWSTR pszName, 
    __out IMFMediaSource** ppMediaSource
    );
STDAPI MFCreateDShowGraphSourceByByteStream(
	__in IMFByteStream * pByteStream, 
    __out IMFMediaSource** ppMediaSource
    );
STDAPI MFCreateMediaProcessor(
    __out IMFMediaProcessor** ppMP
    );


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0009_v0_0_s_ifspec;

#ifndef __IMFStallableTimeSource_INTERFACE_DEFINED__
#define __IMFStallableTimeSource_INTERFACE_DEFINED__

/* interface IMFStallableTimeSource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFStallableTimeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3215D3AA-D9BD-4c96-8119-ED089594AF2A")
    IMFStallableTimeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stall( 
            /* [in] */ LONGLONG llClockTimeStallAmount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStallableTimeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStallableTimeSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStallableTimeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStallableTimeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stall )( 
            IMFStallableTimeSource * This,
            /* [in] */ LONGLONG llClockTimeStallAmount);
        
        END_INTERFACE
    } IMFStallableTimeSourceVtbl;

    interface IMFStallableTimeSource
    {
        CONST_VTBL struct IMFStallableTimeSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStallableTimeSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStallableTimeSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStallableTimeSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStallableTimeSource_Stall(This,llClockTimeStallAmount)	\
    ( (This)->lpVtbl -> Stall(This,llClockTimeStallAmount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStallableTimeSource_INTERFACE_DEFINED__ */


#ifndef __IMFRatelessTimeSource_INTERFACE_DEFINED__
#define __IMFRatelessTimeSource_INTERFACE_DEFINED__

/* interface IMFRatelessTimeSource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFRatelessTimeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ab8dbcbe-2eb8-4080-a6d0-cfa3b846efd4")
    IMFRatelessTimeSource : public IMFPresentationTimeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PokeTimeSource( 
            /* [in] */ MFTIME hnsNewTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFRatelessTimeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFRatelessTimeSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFRatelessTimeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFRatelessTimeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockCharacteristics )( 
            IMFRatelessTimeSource * This,
            /* [out] */ DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelatedTime )( 
            IMFRatelessTimeSource * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LONGLONG *pllClockTime,
            /* [out] */ MFTIME *phnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetContinuityKey )( 
            IMFRatelessTimeSource * This,
            /* [out] */ DWORD *pdwContinuityKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMFRatelessTimeSource * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ MFCLOCK_STATE *peClockState);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMFRatelessTimeSource * This,
            /* [out] */ MFCLOCK_PROPERTIES *pClockProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnderlyingClock )( 
            IMFRatelessTimeSource * This,
            /* [out] */ IMFClock **ppClock);
        
        HRESULT ( STDMETHODCALLTYPE *PokeTimeSource )( 
            IMFRatelessTimeSource * This,
            /* [in] */ MFTIME hnsNewTime);
        
        END_INTERFACE
    } IMFRatelessTimeSourceVtbl;

    interface IMFRatelessTimeSource
    {
        CONST_VTBL struct IMFRatelessTimeSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFRatelessTimeSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFRatelessTimeSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFRatelessTimeSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFRatelessTimeSource_GetClockCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetClockCharacteristics(This,pdwCharacteristics) ) 

#define IMFRatelessTimeSource_GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime)	\
    ( (This)->lpVtbl -> GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime) ) 

#define IMFRatelessTimeSource_GetContinuityKey(This,pdwContinuityKey)	\
    ( (This)->lpVtbl -> GetContinuityKey(This,pdwContinuityKey) ) 

#define IMFRatelessTimeSource_GetState(This,dwReserved,peClockState)	\
    ( (This)->lpVtbl -> GetState(This,dwReserved,peClockState) ) 

#define IMFRatelessTimeSource_GetProperties(This,pClockProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pClockProperties) ) 


#define IMFRatelessTimeSource_GetUnderlyingClock(This,ppClock)	\
    ( (This)->lpVtbl -> GetUnderlyingClock(This,ppClock) ) 


#define IMFRatelessTimeSource_PokeTimeSource(This,hnsNewTime)	\
    ( (This)->lpVtbl -> PokeTimeSource(This,hnsNewTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFRatelessTimeSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0011 */
/* [local] */ 

STDAPI MFCreateRatelessTimeSource(
            IMFRatelessTimeSource **ppRatelessTimeSource );
EXTERN_GUID( MF_CLOCK_RATE_MATCH_SERVICE, 0xd074e429, 0x3094, 0x4f20, 0xaf, 0x4a, 0xdc, 0x4b, 0xc2, 0x6c, 0x65, 0x0);


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0011_v0_0_s_ifspec;

#ifndef __IMFClockRateMatch_INTERFACE_DEFINED__
#define __IMFClockRateMatch_INTERFACE_DEFINED__

/* interface IMFClockRateMatch */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFClockRateMatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("828E7C7E-84F2-4b45-8CEE-5BB3D827FCF5")
    IMFClockRateMatch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdjustSpeed( 
            /* [in] */ double dblObservedSpeedRatio,
            /* [in] */ MFTIME hnsQuickAdjust) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFClockRateMatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFClockRateMatch * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFClockRateMatch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFClockRateMatch * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustSpeed )( 
            IMFClockRateMatch * This,
            /* [in] */ double dblObservedSpeedRatio,
            /* [in] */ MFTIME hnsQuickAdjust);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMFClockRateMatch * This);
        
        END_INTERFACE
    } IMFClockRateMatchVtbl;

    interface IMFClockRateMatch
    {
        CONST_VTBL struct IMFClockRateMatchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFClockRateMatch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFClockRateMatch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFClockRateMatch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFClockRateMatch_AdjustSpeed(This,dblObservedSpeedRatio,hnsQuickAdjust)	\
    ( (This)->lpVtbl -> AdjustSpeed(This,dblObservedSpeedRatio,hnsQuickAdjust) ) 

#define IMFClockRateMatch_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFClockRateMatch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0012 */
/* [local] */ 

EXTERN_C const GUID MF_CLOCK_SERVICE;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0012_v0_0_s_ifspec;

#ifndef __IMFPMPHostInternal_INTERFACE_DEFINED__
#define __IMFPMPHostInternal_INTERFACE_DEFINED__

/* interface IMFPMPHostInternal */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFPMPHostInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("994e23aa-1cc2-493c-b9fa-46f1cb040fa4")
    IMFPMPHostInternal : public IMFPMPHost
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [in] */ IMFPresentationClock *pPresentationClock,
            /* [out] */ IMFMediaSession **phpSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSession( 
            /* [out] */ IMFMediaSession **phpSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSource( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ IMFMediaSource *pAppSource,
            /* [in] */ DWORD dwProcessSampleQueue,
            /* [out] */ IMFMediaSource **pphpSource,
            /* [out] */ DWORD *pdwRemoteQueueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTopology( 
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [out] */ IMFTopology **ppTopology) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePresentationDescriptor( 
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [in] */ IMFPresentationDescriptor *pPD,
            /* [out] */ IMFPresentationDescriptor **pphpPD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateActivate( 
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [size_is][unique][in] */ const BYTE *pbObjectReferenceData,
            /* [in] */ DWORD cbObjectReferenceData,
            /* [out] */ BOOL *pfDataReceived,
            /* [out] */ IUnknown **ppUnkActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFileByteStream( 
            /* [in] */ MF_FILE_ACCESSMODE AccessMode,
            /* [in] */ MF_FILE_OPENMODE OpenMode,
            /* [in] */ MF_FILE_FLAGS fFlags,
            /* [in] */ LPCWSTR pwszFileURL,
            /* [out] */ IMFByteStream **ppFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPMPHostInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPMPHostInternal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPMPHostInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPMPHostInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockProcess )( 
            IMFPMPHostInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockProcess )( 
            IMFPMPHostInternal * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateObjectByCLSID )( 
            IMFPMPHostInternal * This,
            /* [in] */ REFCLSID clsid,
            /* [unique][in] */ IStream *pStream,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFPMPHostInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            IMFPMPHostInternal * This,
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [in] */ IMFPresentationClock *pPresentationClock,
            /* [out] */ IMFMediaSession **phpSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFPMPHostInternal * This,
            /* [out] */ IMFMediaSession **phpSession);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSource )( 
            IMFPMPHostInternal * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ IMFMediaSource *pAppSource,
            /* [in] */ DWORD dwProcessSampleQueue,
            /* [out] */ IMFMediaSource **pphpSource,
            /* [out] */ DWORD *pdwRemoteQueueID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTopology )( 
            IMFPMPHostInternal * This,
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [out] */ IMFTopology **ppTopology);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePresentationDescriptor )( 
            IMFPMPHostInternal * This,
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [in] */ IMFPresentationDescriptor *pPD,
            /* [out] */ IMFPresentationDescriptor **pphpPD);
        
        HRESULT ( STDMETHODCALLTYPE *CreateActivate )( 
            IMFPMPHostInternal * This,
            /* [size_is][in] */ const BYTE *pbData,
            /* [in] */ DWORD cbData,
            /* [size_is][unique][in] */ const BYTE *pbObjectReferenceData,
            /* [in] */ DWORD cbObjectReferenceData,
            /* [out] */ BOOL *pfDataReceived,
            /* [out] */ IUnknown **ppUnkActivate);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFileByteStream )( 
            IMFPMPHostInternal * This,
            /* [in] */ MF_FILE_ACCESSMODE AccessMode,
            /* [in] */ MF_FILE_OPENMODE OpenMode,
            /* [in] */ MF_FILE_FLAGS fFlags,
            /* [in] */ LPCWSTR pwszFileURL,
            /* [out] */ IMFByteStream **ppFile);
        
        END_INTERFACE
    } IMFPMPHostInternalVtbl;

    interface IMFPMPHostInternal
    {
        CONST_VTBL struct IMFPMPHostInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPMPHostInternal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPMPHostInternal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPMPHostInternal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPMPHostInternal_LockProcess(This)	\
    ( (This)->lpVtbl -> LockProcess(This) ) 

#define IMFPMPHostInternal_UnlockProcess(This)	\
    ( (This)->lpVtbl -> UnlockProcess(This) ) 

#define IMFPMPHostInternal_CreateObjectByCLSID(This,clsid,pStream,riid,ppv)	\
    ( (This)->lpVtbl -> CreateObjectByCLSID(This,clsid,pStream,riid,ppv) ) 


#define IMFPMPHostInternal_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IMFPMPHostInternal_CreateSession(This,pbData,cbData,pPresentationClock,phpSession)	\
    ( (This)->lpVtbl -> CreateSession(This,pbData,cbData,pPresentationClock,phpSession) ) 

#define IMFPMPHostInternal_GetSession(This,phpSession)	\
    ( (This)->lpVtbl -> GetSession(This,phpSession) ) 

#define IMFPMPHostInternal_CreateSource(This,pwstrName,pAppSource,dwProcessSampleQueue,pphpSource,pdwRemoteQueueID)	\
    ( (This)->lpVtbl -> CreateSource(This,pwstrName,pAppSource,dwProcessSampleQueue,pphpSource,pdwRemoteQueueID) ) 

#define IMFPMPHostInternal_CreateTopology(This,pbData,cbData,ppTopology)	\
    ( (This)->lpVtbl -> CreateTopology(This,pbData,cbData,ppTopology) ) 

#define IMFPMPHostInternal_CreatePresentationDescriptor(This,pbData,cbData,pPD,pphpPD)	\
    ( (This)->lpVtbl -> CreatePresentationDescriptor(This,pbData,cbData,pPD,pphpPD) ) 

#define IMFPMPHostInternal_CreateActivate(This,pbData,cbData,pbObjectReferenceData,cbObjectReferenceData,pfDataReceived,ppUnkActivate)	\
    ( (This)->lpVtbl -> CreateActivate(This,pbData,cbData,pbObjectReferenceData,cbObjectReferenceData,pfDataReceived,ppUnkActivate) ) 

#define IMFPMPHostInternal_CreateFileByteStream(This,AccessMode,OpenMode,fFlags,pwszFileURL,ppFile)	\
    ( (This)->lpVtbl -> CreateFileByteStream(This,AccessMode,OpenMode,fFlags,pwszFileURL,ppFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPMPHostInternal_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0013 */
/* [local] */ 

EXTERN_C const GUID MF_PMP_SERVER_CONTEXT;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0013_v0_0_s_ifspec;

#ifndef __IMFPMPServerInternal_INTERFACE_DEFINED__
#define __IMFPMPServerInternal_INTERFACE_DEFINED__

/* interface IMFPMPServerInternal */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFPMPServerInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("772ff18d-138b-4257-873c-1b8e0ce1d183")
    IMFPMPServerInternal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateHost( 
            /* [string][in] */ LPCWSTR pszName,
            /* [out] */ IMFPMPHost **ppHost) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPMPServerInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPMPServerInternal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPMPServerInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPMPServerInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateHost )( 
            IMFPMPServerInternal * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [out] */ IMFPMPHost **ppHost);
        
        END_INTERFACE
    } IMFPMPServerInternalVtbl;

    interface IMFPMPServerInternal
    {
        CONST_VTBL struct IMFPMPServerInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPMPServerInternal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPMPServerInternal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPMPServerInternal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPMPServerInternal_CreateHost(This,pszName,ppHost)	\
    ( (This)->lpVtbl -> CreateHost(This,pszName,ppHost) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPMPServerInternal_INTERFACE_DEFINED__ */


#ifndef __IMFPMPServerLock_INTERFACE_DEFINED__
#define __IMFPMPServerLock_INTERFACE_DEFINED__

/* interface IMFPMPServerLock */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFPMPServerLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("994e23b0-1cc2-493c-b9fa-46f1cb040fa4")
    IMFPMPServerLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LockProcess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockProcess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPMPServerLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPMPServerLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPMPServerLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPMPServerLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockProcess )( 
            IMFPMPServerLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockProcess )( 
            IMFPMPServerLock * This);
        
        END_INTERFACE
    } IMFPMPServerLockVtbl;

    interface IMFPMPServerLock
    {
        CONST_VTBL struct IMFPMPServerLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPMPServerLock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPMPServerLock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPMPServerLock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPMPServerLock_LockProcess(This)	\
    ( (This)->lpVtbl -> LockProcess(This) ) 

#define IMFPMPServerLock_UnlockProcess(This)	\
    ( (This)->lpVtbl -> UnlockProcess(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPMPServerLock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0015 */
/* [local] */ 

STDAPI MFCreatePMPHost(   
        /* in */      IMFPMPServerLock * pServerLock,
        /* in */      LPCWSTR wszName,
        /* out */    IMFPMPHost **ppHost ); 


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0015_v0_0_s_ifspec;

#ifndef __IMFComponentCreator_INTERFACE_DEFINED__
#define __IMFComponentCreator_INTERFACE_DEFINED__

/* interface IMFComponentCreator */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFComponentCreator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97ec2ea2-0e42-4937-97ac-9d6d328824e1")
    IMFComponentCreator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFComponentCreatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFComponentCreator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFComponentCreator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFComponentCreator * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
            IMFComponentCreator * This,
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IMFComponentCreatorVtbl;

    interface IMFComponentCreator
    {
        CONST_VTBL struct IMFComponentCreatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFComponentCreator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFComponentCreator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFComponentCreator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFComponentCreator_CreateObject(This,clsid,riid,ppv)	\
    ( (This)->lpVtbl -> CreateObject(This,clsid,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFComponentCreator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0016 */
/* [local] */ 


EXTERN_GUID( MFOUTPUT_COMPRESSEDDIGITALVIDEO, 0x6c6827b9, 0xe708, 0x4f46, 0xb8, 0xf6, 0x76, 0x65, 0x87, 0x91, 0xed, 0xcb);
EXTERN_GUID( MFOUTPUT_UNCOMPRESSEDDIGITALVIDEO, 0xb7974e47, 0xc88b, 0x45a7, 0x93, 0xb7, 0xe4, 0x6a, 0xd4, 0xb2, 0xbe, 0xb5);
EXTERN_GUID( MFOUTPUT_ANALOGVIDEO, 0x4e9e809c, 0xc2f4, 0x402a, 0x87, 0x66, 0xed, 0x91, 0xd3, 0xf7, 0x16, 0x0f);
EXTERN_GUID( MFOUTPUT_COMPRESSEDDIGITALAUDIO, 0x5e4f98b6, 0x4c70, 0x453c, 0x95, 0x42, 0x54, 0xaa, 0x35, 0x80, 0xb5, 0x6f);
EXTERN_GUID( MFOUTPUT_UNCOMPRESSEDDIGITALAUDIO, 0x009ba252, 0xd1d6, 0x4782, 0xb5, 0x95, 0xa9, 0x92, 0x56, 0xdf, 0x94, 0x6d);
EXTERN_GUID( MFOUTPUT_ANALOGAUDIO, 0x2547b877, 0xb5ea, 0x4533, 0xb6, 0xde, 0x82, 0x1b, 0xc4, 0x82, 0xbe, 0xef);

typedef 
enum MF_SEQUENCER_TRANSLATEEVENT_STATUS
    {	MF_SEQUENCER_TRANSLATEEVENT_PROCESS	= 0x1,
	MF_SEQUENCER_TRANSLATEEVENT_HIDE	= 0x2,
	MF_SEQUENCER_TRANSLATEEVENT_REPLACE	= 0x3
    } 	MF_SEQUENCER_TRANSLATEEVENT_STATUS;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0016_v0_0_s_ifspec;

#ifndef __IMFSequencerRemoteStreamCallback_INTERFACE_DEFINED__
#define __IMFSequencerRemoteStreamCallback_INTERFACE_DEFINED__

/* interface IMFSequencerRemoteStreamCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFSequencerRemoteStreamCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("994e23ae-19CB-4de1-A64C-ACF2EDCBE59E")
    IMFSequencerRemoteStreamCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranslateEvent( 
            /* [in] */ IMFMediaEvent *pOrigEvent,
            /* [out] */ MF_SEQUENCER_TRANSLATEEVENT_STATUS *pStatus,
            /* [unique][out][in] */ IMFMediaEvent **ppNewEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSequencerRemoteStreamCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFSequencerRemoteStreamCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFSequencerRemoteStreamCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFSequencerRemoteStreamCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateEvent )( 
            IMFSequencerRemoteStreamCallback * This,
            /* [in] */ IMFMediaEvent *pOrigEvent,
            /* [out] */ MF_SEQUENCER_TRANSLATEEVENT_STATUS *pStatus,
            /* [unique][out][in] */ IMFMediaEvent **ppNewEvent);
        
        END_INTERFACE
    } IMFSequencerRemoteStreamCallbackVtbl;

    interface IMFSequencerRemoteStreamCallback
    {
        CONST_VTBL struct IMFSequencerRemoteStreamCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSequencerRemoteStreamCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSequencerRemoteStreamCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSequencerRemoteStreamCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSequencerRemoteStreamCallback_TranslateEvent(This,pOrigEvent,pStatus,ppNewEvent)	\
    ( (This)->lpVtbl -> TranslateEvent(This,pOrigEvent,pStatus,ppNewEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFSequencerRemoteStreamCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0017 */
/* [local] */ 

STDAPI MFCreateAppSourceProxy( 
    IMFMediaSource * pSource,
    IMFPMPHost * pHost,
    __out IMFMediaSource ** ppAppSourceProxy);
STDAPI MFCreateSequencerSourceRemoteStream(
    IMFMediaStream* pStream, 
    IMFSequencerRemoteStreamCallback * pCallback, 
    __out IMFMediaStream ** ppRemoteStream );


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0017_v0_0_s_ifspec;

#ifndef __IMFDebugPMPSession_INTERFACE_DEFINED__
#define __IMFDebugPMPSession_INTERFACE_DEFINED__

/* interface IMFDebugPMPSession */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFDebugPMPSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED597033-A68B-4522-999F-44D4F9DEA2F5")
    IMFDebugPMPSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPMPProcessId( 
            /* [annotation] */ 
            __out  DWORD *pdwProcessId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFDebugPMPSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFDebugPMPSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFDebugPMPSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFDebugPMPSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPMPProcessId )( 
            IMFDebugPMPSession * This,
            /* [annotation] */ 
            __out  DWORD *pdwProcessId);
        
        END_INTERFACE
    } IMFDebugPMPSessionVtbl;

    interface IMFDebugPMPSession
    {
        CONST_VTBL struct IMFDebugPMPSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFDebugPMPSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFDebugPMPSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFDebugPMPSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFDebugPMPSession_GetPMPProcessId(This,pdwProcessId)	\
    ( (This)->lpVtbl -> GetPMPProcessId(This,pdwProcessId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFDebugPMPSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0018 */
/* [local] */ 


typedef /* [public] */ struct _ReceiverBufferConfig
    {
    DWORD cbNetworkDeJitterBuffer;
    DWORD cbDecoderBuffer;
    DWORD dwMsTargetBufferDuration;
    } 	ReceiverBufferConfig;

typedef /* [public] */ struct _StreamInfo
    {
    DWORD dwStreamId;
    GUID guidMediaType;
    BOOL fEnabled;
    DWORD dwAvgBitrate;
    DWORD dwMsBufferWindow;
    DWORD dwPeakBitrate;
    DWORD dwMsPeakBufferWindow;
    ReceiverBufferConfig InitialBufferConfig;
    HANDLE socketHandle;
    } 	StreamInfo;

typedef /* [public] */ struct _MFStreamBufferStatusReport
    {
    DWORD cbFreeNetworkDeJitterBuffer;
    WORD wMsCurrentNetworkDeJitterBuffer;
    DWORD cbFreeDecoderBuffer;
    WORD wMsCurrentDecoderBuffer;
    ReceiverBufferConfig CurrentBufferConfig;
    } 	MFStreamBufferStatusReport;

typedef /* [public] */ struct _MFPacketStatusReport
    {
    DWORD dwUnacknowledgedRTPPackets;
    LONG lRTPPacketsLost;
    WORD wNackRequests;
    DWORD cbNackDataSent;
    } 	MFPacketStatusReport;

typedef 
enum _DATA_PACER_EVENT
    {	Start	= 0,
	Pause	= ( Start + 1 ) ,
	Resume	= ( Pause + 1 ) 
    } 	DATA_PACER_EVENT;

typedef 
enum _MF_RATE_CHANGE_REASON
    {	MF_RCR_StreamChange	= 0,
	MF_RCR_Transrate	= ( MF_RCR_StreamChange + 1 ) ,
	MF_RCR_Trickplay	= ( MF_RCR_Transrate + 1 ) ,
	MF_RCR_Normal	= ( MF_RCR_Trickplay + 1 ) 
    } 	MF_RATE_CHANGE_REASON;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0018_v0_0_s_ifspec;

#ifndef __IMFNetworkCongestionControl_INTERFACE_DEFINED__
#define __IMFNetworkCongestionControl_INTERFACE_DEFINED__

/* interface IMFNetworkCongestionControl */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetworkCongestionControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0db51ba-d166-4ee8-b68f-0083304c88d6")
    IMFNetworkCongestionControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFCongestionHandler *pCongestionHandler,
            /* [in] */ BOOL fLiveStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBfrReportInterval( 
            /* [in] */ GUID guidMediaType,
            /* [in] */ DWORD dwBitrate,
            /* [annotation][out] */ 
            __out  DWORD *pdwMsReportInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkBandwidth( 
            /* [in] */ DWORD dwLinkBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreams( 
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  StreamInfo *pStreamInfo,
            /* [in] */ DWORD dwStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateStreams( 
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  StreamInfo *pStreamInfo,
            /* [in] */ DWORD dwStreamCount,
            /* [in] */ MF_RATE_CHANGE_REASON eRateChangeReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreams( 
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pdwStreamId,
            /* [in] */ DWORD dwStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataPacerEvent( 
            DATA_PACER_EVENT event) = 0;
        
        virtual void STDMETHODCALLTYPE OnRR( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][in] */ 
            __in  MFPacketStatusReport *pPacketReport,
            /* [in] */ QWORD qwMsRecvTimestamp) = 0;
        
        virtual void STDMETHODCALLTYPE OnBFR( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][in] */ 
            __in  MFStreamBufferStatusReport *pBufferReport,
            /* [in] */ QWORD qwMsRecvTimestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetworkCongestionControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetworkCongestionControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetworkCongestionControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetworkCongestionControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFNetworkCongestionControl * This,
            /* [in] */ IMFCongestionHandler *pCongestionHandler,
            /* [in] */ BOOL fLiveStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetBfrReportInterval )( 
            IMFNetworkCongestionControl * This,
            /* [in] */ GUID guidMediaType,
            /* [in] */ DWORD dwBitrate,
            /* [annotation][out] */ 
            __out  DWORD *pdwMsReportInterval);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkBandwidth )( 
            IMFNetworkCongestionControl * This,
            /* [in] */ DWORD dwLinkBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreams )( 
            IMFNetworkCongestionControl * This,
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  StreamInfo *pStreamInfo,
            /* [in] */ DWORD dwStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateStreams )( 
            IMFNetworkCongestionControl * This,
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  StreamInfo *pStreamInfo,
            /* [in] */ DWORD dwStreamCount,
            /* [in] */ MF_RATE_CHANGE_REASON eRateChangeReason);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreams )( 
            IMFNetworkCongestionControl * This,
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pdwStreamId,
            /* [in] */ DWORD dwStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataPacerEvent )( 
            IMFNetworkCongestionControl * This,
            DATA_PACER_EVENT event);
        
        void ( STDMETHODCALLTYPE *OnRR )( 
            IMFNetworkCongestionControl * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][in] */ 
            __in  MFPacketStatusReport *pPacketReport,
            /* [in] */ QWORD qwMsRecvTimestamp);
        
        void ( STDMETHODCALLTYPE *OnBFR )( 
            IMFNetworkCongestionControl * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][in] */ 
            __in  MFStreamBufferStatusReport *pBufferReport,
            /* [in] */ QWORD qwMsRecvTimestamp);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFNetworkCongestionControl * This);
        
        END_INTERFACE
    } IMFNetworkCongestionControlVtbl;

    interface IMFNetworkCongestionControl
    {
        CONST_VTBL struct IMFNetworkCongestionControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetworkCongestionControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetworkCongestionControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetworkCongestionControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetworkCongestionControl_Initialize(This,pCongestionHandler,fLiveStream)	\
    ( (This)->lpVtbl -> Initialize(This,pCongestionHandler,fLiveStream) ) 

#define IMFNetworkCongestionControl_GetBfrReportInterval(This,guidMediaType,dwBitrate,pdwMsReportInterval)	\
    ( (This)->lpVtbl -> GetBfrReportInterval(This,guidMediaType,dwBitrate,pdwMsReportInterval) ) 

#define IMFNetworkCongestionControl_SetLinkBandwidth(This,dwLinkBandwidth)	\
    ( (This)->lpVtbl -> SetLinkBandwidth(This,dwLinkBandwidth) ) 

#define IMFNetworkCongestionControl_AddStreams(This,pStreamInfo,dwStreamCount)	\
    ( (This)->lpVtbl -> AddStreams(This,pStreamInfo,dwStreamCount) ) 

#define IMFNetworkCongestionControl_UpdateStreams(This,pStreamInfo,dwStreamCount,eRateChangeReason)	\
    ( (This)->lpVtbl -> UpdateStreams(This,pStreamInfo,dwStreamCount,eRateChangeReason) ) 

#define IMFNetworkCongestionControl_RemoveStreams(This,pdwStreamId,dwStreamCount)	\
    ( (This)->lpVtbl -> RemoveStreams(This,pdwStreamId,dwStreamCount) ) 

#define IMFNetworkCongestionControl_OnDataPacerEvent(This,event)	\
    ( (This)->lpVtbl -> OnDataPacerEvent(This,event) ) 

#define IMFNetworkCongestionControl_OnRR(This,dwStreamId,pPacketReport,qwMsRecvTimestamp)	\
    ( (This)->lpVtbl -> OnRR(This,dwStreamId,pPacketReport,qwMsRecvTimestamp) ) 

#define IMFNetworkCongestionControl_OnBFR(This,dwStreamId,pBufferReport,qwMsRecvTimestamp)	\
    ( (This)->lpVtbl -> OnBFR(This,dwStreamId,pBufferReport,qwMsRecvTimestamp) ) 

#define IMFNetworkCongestionControl_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetworkCongestionControl_INTERFACE_DEFINED__ */


#ifndef __IMFCongestionHandler_INTERFACE_DEFINED__
#define __IMFCongestionHandler_INTERFACE_DEFINED__

/* interface IMFCongestionHandler */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFCongestionHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("051268b6-eba3-4123-973d-6cb63fb4cc75")
    IMFCongestionHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCongestion( 
            /* [in] */ DWORD dwSuggestedLinkBandwidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFCongestionHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFCongestionHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFCongestionHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFCongestionHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCongestion )( 
            IMFCongestionHandler * This,
            /* [in] */ DWORD dwSuggestedLinkBandwidth);
        
        END_INTERFACE
    } IMFCongestionHandlerVtbl;

    interface IMFCongestionHandler
    {
        CONST_VTBL struct IMFCongestionHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFCongestionHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFCongestionHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFCongestionHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFCongestionHandler_OnCongestion(This,dwSuggestedLinkBandwidth)	\
    ( (This)->lpVtbl -> OnCongestion(This,dwSuggestedLinkBandwidth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFCongestionHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0020 */
/* [local] */ 

EXTERN_C const CLSID CLSID_CMFNetworkCongestionControl;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0020_v0_0_s_ifspec;

#ifndef __IMFDebugNetSource_INTERFACE_DEFINED__
#define __IMFDebugNetSource_INTERFACE_DEFINED__

/* interface IMFDebugNetSource */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFDebugNetSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e9cd0380-a268-4bb4-82de-658d53574d41")
    IMFDebugNetSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLinkBandwidth( 
            /* [in] */ DWORD dwBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ DWORD nFailRerty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfiguration( 
            /* [in] */ IPropertyStore *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetSampleTime( 
            /* [annotation][out] */ 
            __out  DWORD *pmsTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFDebugNetSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFDebugNetSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFDebugNetSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFDebugNetSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkBandwidth )( 
            IMFDebugNetSource * This,
            /* [in] */ DWORD dwBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IMFDebugNetSource * This,
            /* [in] */ DWORD nFailRerty);
        
        HRESULT ( STDMETHODCALLTYPE *SetConfiguration )( 
            IMFDebugNetSource * This,
            /* [in] */ IPropertyStore *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetSampleTime )( 
            IMFDebugNetSource * This,
            /* [annotation][out] */ 
            __out  DWORD *pmsTime);
        
        END_INTERFACE
    } IMFDebugNetSourceVtbl;

    interface IMFDebugNetSource
    {
        CONST_VTBL struct IMFDebugNetSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFDebugNetSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFDebugNetSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFDebugNetSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFDebugNetSource_SetLinkBandwidth(This,dwBandwidth)	\
    ( (This)->lpVtbl -> SetLinkBandwidth(This,dwBandwidth) ) 

#define IMFDebugNetSource_Disconnect(This,nFailRerty)	\
    ( (This)->lpVtbl -> Disconnect(This,nFailRerty) ) 

#define IMFDebugNetSource_SetConfiguration(This,pConfig)	\
    ( (This)->lpVtbl -> SetConfiguration(This,pConfig) ) 

#define IMFDebugNetSource_GetNetSampleTime(This,pmsTime)	\
    ( (This)->lpVtbl -> GetNetSampleTime(This,pmsTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFDebugNetSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0021 */
/* [local] */ 

EXTERN_C const GUID MFRECORDQUEUE_STATISTICS;
EXTERN_C const GUID MFRECORDQUEUE_STATISTICS_SERVICE;
typedef 
enum _MFRECORDQUEUE_STATISTICS_IDS
    {	MFRECORDQUEUE_SAMPLES_IN_MEMORY	= 0,
	MFRECORDQUEUE_SAMPLES_ON_DISK	= ( MFRECORDQUEUE_SAMPLES_IN_MEMORY + 1 ) ,
	MFRECORDQUEUE_SAMPLES_DROPPED	= ( MFRECORDQUEUE_SAMPLES_ON_DISK + 1 ) ,
	MFRECORDQUEUE_SAMPLES_SENT	= ( MFRECORDQUEUE_SAMPLES_DROPPED + 1 ) ,
	MFRECORDQUEUE_BYTES_SENT	= ( MFRECORDQUEUE_SAMPLES_SENT + 1 ) ,
	MFRECORDQUEUE_BYTES_IN_MEMORY	= ( MFRECORDQUEUE_BYTES_SENT + 1 ) ,
	MFRECORDQUEUE_BYTES_ON_DISK	= ( MFRECORDQUEUE_BYTES_IN_MEMORY + 1 ) 
    } 	MFRECORDQUEUE_STATISTICS_IDS;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0021_v0_0_s_ifspec;

#ifndef __IMFNetMessageTransfer_INTERFACE_DEFINED__
#define __IMFNetMessageTransfer_INTERFACE_DEFINED__

/* interface IMFNetMessageTransfer */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetMessageTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9E528EC-21BA-4b40-BE43-EBD4287CF8CB")
    IMFNetMessageTransfer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginGetMessage( 
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndGetMessage( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [out] */ INamedPropertyStore **ppOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessMessage( 
            /* [in] */ INamedPropertyStore *pStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetMessageTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetMessageTransfer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetMessageTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetMessageTransfer * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginGetMessage )( 
            IMFNetMessageTransfer * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndGetMessage )( 
            IMFNetMessageTransfer * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [out] */ INamedPropertyStore **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMessage )( 
            IMFNetMessageTransfer * This,
            /* [in] */ INamedPropertyStore *pStore);
        
        END_INTERFACE
    } IMFNetMessageTransferVtbl;

    interface IMFNetMessageTransfer
    {
        CONST_VTBL struct IMFNetMessageTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetMessageTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetMessageTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetMessageTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetMessageTransfer_BeginGetMessage(This,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginGetMessage(This,pCallback,pState) ) 

#define IMFNetMessageTransfer_EndGetMessage(This,pResult,ppOut)	\
    ( (This)->lpVtbl -> EndGetMessage(This,pResult,ppOut) ) 

#define IMFNetMessageTransfer_ProcessMessage(This,pStore)	\
    ( (This)->lpVtbl -> ProcessMessage(This,pStore) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetMessageTransfer_INTERFACE_DEFINED__ */


#ifndef __IMFNetConnection_INTERFACE_DEFINED__
#define __IMFNetConnection_INTERFACE_DEFINED__

/* interface IMFNetConnection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e9cd0393-a268-4bb4-82de-658d53574d41")
    IMFNetConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginConnect( 
            /* [in] */ INamedPropertyStore *pIn,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndConnect( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [out] */ INamedPropertyStore **ppOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [out] */ IPropertyStore **ppStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginConnect )( 
            IMFNetConnection * This,
            /* [in] */ INamedPropertyStore *pIn,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndConnect )( 
            IMFNetConnection * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [out] */ INamedPropertyStore **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IMFNetConnection * This,
            /* [out] */ IPropertyStore **ppStore);
        
        END_INTERFACE
    } IMFNetConnectionVtbl;

    interface IMFNetConnection
    {
        CONST_VTBL struct IMFNetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetConnection_BeginConnect(This,pIn,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginConnect(This,pIn,pCallback,pState) ) 

#define IMFNetConnection_EndConnect(This,pResult,ppOut)	\
    ( (This)->lpVtbl -> EndConnect(This,pResult,ppOut) ) 

#define IMFNetConnection_GetPropertyStore(This,ppStore)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,ppStore) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0023 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0023_v0_0_s_ifspec;

#ifndef __IMFNetChannelFactory_INTERFACE_DEFINED__
#define __IMFNetChannelFactory_INTERFACE_DEFINED__

/* interface IMFNetChannelFactory */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetChannelFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("238849FB-9087-4bc3-A098-AC6F1A07D6C8")
    IMFNetChannelFactory : public IMFNetConnection
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateChannelCreationContext( 
            /* [annotation][out] */ 
            __out  IUnknown **ppChannelCreationContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCreateNetChannels( 
            /* [in] */ IUnknown *pChannelCreationContext,
            /* [in] */ DWORD nChannels,
            /* [in] */ INamedPropertyStore *pInputParameters,
            /* [in] */ INamedPropertyStore *pOutputParameters,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndCreateNetChannels( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFNetChannel **ppNetDataChannel,
            /* [annotation][out] */ 
            __out  IMFNetChannel **ppNetFeedbackChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetChannelFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetChannelFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetChannelFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetChannelFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginConnect )( 
            IMFNetChannelFactory * This,
            /* [in] */ INamedPropertyStore *pIn,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndConnect )( 
            IMFNetChannelFactory * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [out] */ INamedPropertyStore **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IMFNetChannelFactory * This,
            /* [out] */ IPropertyStore **ppStore);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateChannelCreationContext )( 
            IMFNetChannelFactory * This,
            /* [annotation][out] */ 
            __out  IUnknown **ppChannelCreationContext);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCreateNetChannels )( 
            IMFNetChannelFactory * This,
            /* [in] */ IUnknown *pChannelCreationContext,
            /* [in] */ DWORD nChannels,
            /* [in] */ INamedPropertyStore *pInputParameters,
            /* [in] */ INamedPropertyStore *pOutputParameters,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndCreateNetChannels )( 
            IMFNetChannelFactory * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFNetChannel **ppNetDataChannel,
            /* [annotation][out] */ 
            __out  IMFNetChannel **ppNetFeedbackChannel);
        
        END_INTERFACE
    } IMFNetChannelFactoryVtbl;

    interface IMFNetChannelFactory
    {
        CONST_VTBL struct IMFNetChannelFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetChannelFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetChannelFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetChannelFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetChannelFactory_BeginConnect(This,pIn,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginConnect(This,pIn,pCallback,pState) ) 

#define IMFNetChannelFactory_EndConnect(This,pResult,ppOut)	\
    ( (This)->lpVtbl -> EndConnect(This,pResult,ppOut) ) 

#define IMFNetChannelFactory_GetPropertyStore(This,ppStore)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,ppStore) ) 


#define IMFNetChannelFactory_AllocateChannelCreationContext(This,ppChannelCreationContext)	\
    ( (This)->lpVtbl -> AllocateChannelCreationContext(This,ppChannelCreationContext) ) 

#define IMFNetChannelFactory_BeginCreateNetChannels(This,pChannelCreationContext,nChannels,pInputParameters,pOutputParameters,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginCreateNetChannels(This,pChannelCreationContext,nChannels,pInputParameters,pOutputParameters,pCallback,pState) ) 

#define IMFNetChannelFactory_EndCreateNetChannels(This,pResult,ppNetDataChannel,ppNetFeedbackChannel)	\
    ( (This)->lpVtbl -> EndCreateNetChannels(This,pResult,ppNetDataChannel,ppNetFeedbackChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetChannelFactory_INTERFACE_DEFINED__ */


#ifndef __IMFAuthenticationContext_INTERFACE_DEFINED__
#define __IMFAuthenticationContext_INTERFACE_DEFINED__

/* interface IMFAuthenticationContext */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFAuthenticationContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FEB8E8F-AA79-4de8-A928-D1B4DE0552D5")
    IMFAuthenticationContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImpersonationToken( 
            /* [annotation][out] */ 
            __out  LONG *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImpersonationAccountName( 
            /* [annotation][out] */ 
            __out  LPCWSTR *ppwszAccountName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFAuthenticationContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFAuthenticationContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFAuthenticationContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFAuthenticationContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpersonationToken )( 
            IMFAuthenticationContext * This,
            /* [annotation][out] */ 
            __out  LONG *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetImpersonationAccountName )( 
            IMFAuthenticationContext * This,
            /* [annotation][out] */ 
            __out  LPCWSTR *ppwszAccountName);
        
        END_INTERFACE
    } IMFAuthenticationContextVtbl;

    interface IMFAuthenticationContext
    {
        CONST_VTBL struct IMFAuthenticationContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFAuthenticationContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFAuthenticationContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFAuthenticationContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFAuthenticationContext_GetImpersonationToken(This,pToken)	\
    ( (This)->lpVtbl -> GetImpersonationToken(This,pToken) ) 

#define IMFAuthenticationContext_GetImpersonationAccountName(This,ppwszAccountName)	\
    ( (This)->lpVtbl -> GetImpersonationAccountName(This,ppwszAccountName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFAuthenticationContext_INTERFACE_DEFINED__ */


#ifndef __IMFChannelAccelerator_INTERFACE_DEFINED__
#define __IMFChannelAccelerator_INTERFACE_DEFINED__

/* interface IMFChannelAccelerator */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFChannelAccelerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65FD3BBE-6EE8-4826-90CF-4BCD7B0DBC79")
    IMFChannelAccelerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddChannelBandwidth( 
            /* [in] */ DWORD dwBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteChannelBandwidth( 
            /* [in] */ DWORD dwBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAcceleration( 
            /* [in] */ DWORD dwAccelerationBandwidth,
            /* [in] */ QWORD dwAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableSendTimeSmoothing( 
            BOOL fSendTimeSmoothing) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsToResetClock( 
            /* [annotation][out] */ 
            __out  BOOL *pfResetWallClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ QWORD qwCurrentTime,
            /* [in] */ DWORD dwPacketLength,
            /* [annotation][out] */ 
            __out  QWORD *pqwModifiedTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFChannelAcceleratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFChannelAccelerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFChannelAccelerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFChannelAccelerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddChannelBandwidth )( 
            IMFChannelAccelerator * This,
            /* [in] */ DWORD dwBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteChannelBandwidth )( 
            IMFChannelAccelerator * This,
            /* [in] */ DWORD dwBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *AddAcceleration )( 
            IMFChannelAccelerator * This,
            /* [in] */ DWORD dwAccelerationBandwidth,
            /* [in] */ QWORD dwAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE *EnableSendTimeSmoothing )( 
            IMFChannelAccelerator * This,
            BOOL fSendTimeSmoothing);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMFChannelAccelerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsToResetClock )( 
            IMFChannelAccelerator * This,
            /* [annotation][out] */ 
            __out  BOOL *pfResetWallClock);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IMFChannelAccelerator * This,
            /* [in] */ QWORD qwCurrentTime,
            /* [in] */ DWORD dwPacketLength,
            /* [annotation][out] */ 
            __out  QWORD *pqwModifiedTime);
        
        END_INTERFACE
    } IMFChannelAcceleratorVtbl;

    interface IMFChannelAccelerator
    {
        CONST_VTBL struct IMFChannelAcceleratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFChannelAccelerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFChannelAccelerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFChannelAccelerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFChannelAccelerator_AddChannelBandwidth(This,dwBandwidth)	\
    ( (This)->lpVtbl -> AddChannelBandwidth(This,dwBandwidth) ) 

#define IMFChannelAccelerator_DeleteChannelBandwidth(This,dwBandwidth)	\
    ( (This)->lpVtbl -> DeleteChannelBandwidth(This,dwBandwidth) ) 

#define IMFChannelAccelerator_AddAcceleration(This,dwAccelerationBandwidth,dwAccelDuration)	\
    ( (This)->lpVtbl -> AddAcceleration(This,dwAccelerationBandwidth,dwAccelDuration) ) 

#define IMFChannelAccelerator_EnableSendTimeSmoothing(This,fSendTimeSmoothing)	\
    ( (This)->lpVtbl -> EnableSendTimeSmoothing(This,fSendTimeSmoothing) ) 

#define IMFChannelAccelerator_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IMFChannelAccelerator_NeedsToResetClock(This,pfResetWallClock)	\
    ( (This)->lpVtbl -> NeedsToResetClock(This,pfResetWallClock) ) 

#define IMFChannelAccelerator_Update(This,qwCurrentTime,dwPacketLength,pqwModifiedTime)	\
    ( (This)->lpVtbl -> Update(This,qwCurrentTime,dwPacketLength,pqwModifiedTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFChannelAccelerator_INTERFACE_DEFINED__ */


#ifndef __IMFMediaCacheStream_INTERFACE_DEFINED__
#define __IMFMediaCacheStream_INTERFACE_DEFINED__

/* interface IMFMediaCacheStream */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMediaCacheStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e9cd0395-a268-4bb4-82de-658d53574d41")
    IMFMediaCacheStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [annotation][in] */ 
            __out  IMFSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRead( 
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRead( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ IMFSample *pSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaCacheStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaCacheStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaCacheStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaCacheStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IMFMediaCacheStream * This,
            /* [annotation][in] */ 
            __out  IMFSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *BeginRead )( 
            IMFMediaCacheStream * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndRead )( 
            IMFMediaCacheStream * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IMFMediaCacheStream * This,
            /* [in] */ IMFSample *pSample);
        
        END_INTERFACE
    } IMFMediaCacheStreamVtbl;

    interface IMFMediaCacheStream
    {
        CONST_VTBL struct IMFMediaCacheStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaCacheStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaCacheStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaCacheStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaCacheStream_Read(This,ppSample)	\
    ( (This)->lpVtbl -> Read(This,ppSample) ) 

#define IMFMediaCacheStream_BeginRead(This,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginRead(This,pCallback,pState) ) 

#define IMFMediaCacheStream_EndRead(This,pResult,ppSample)	\
    ( (This)->lpVtbl -> EndRead(This,pResult,ppSample) ) 

#define IMFMediaCacheStream_Write(This,pSample)	\
    ( (This)->lpVtbl -> Write(This,pSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaCacheStream_INTERFACE_DEFINED__ */


#ifndef __IMFMediaCache_INTERFACE_DEFINED__
#define __IMFMediaCache_INTERFACE_DEFINED__

/* interface IMFMediaCache */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMediaCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e9cd0396-a268-4bb4-82de-658d53574d41")
    IMFMediaCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateCacheStream( 
            /* [annotation][out] */ 
            __out  IMFMediaCacheStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveCacheStream( 
            /* [in] */ IMFMediaCacheStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstCacheStream( 
            /* [annotation][out] */ 
            __out  IMFMediaCacheStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCacheStream( 
            /* [annotation][out] */ 
            __out  IMFMediaCacheStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCacheStream )( 
            IMFMediaCache * This,
            /* [annotation][out] */ 
            __out  IMFMediaCacheStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveCacheStream )( 
            IMFMediaCache * This,
            /* [in] */ IMFMediaCacheStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstCacheStream )( 
            IMFMediaCache * This,
            /* [annotation][out] */ 
            __out  IMFMediaCacheStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCacheStream )( 
            IMFMediaCache * This,
            /* [annotation][out] */ 
            __out  IMFMediaCacheStream **ppStream);
        
        END_INTERFACE
    } IMFMediaCacheVtbl;

    interface IMFMediaCache
    {
        CONST_VTBL struct IMFMediaCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaCache_CreateCacheStream(This,ppStream)	\
    ( (This)->lpVtbl -> CreateCacheStream(This,ppStream) ) 

#define IMFMediaCache_RemoveCacheStream(This,pStream)	\
    ( (This)->lpVtbl -> RemoveCacheStream(This,pStream) ) 

#define IMFMediaCache_GetFirstCacheStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetFirstCacheStream(This,ppStream) ) 

#define IMFMediaCache_GetNextCacheStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetNextCacheStream(This,ppStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaCache_INTERFACE_DEFINED__ */


#ifndef __IMFMediaCacheManager_INTERFACE_DEFINED__
#define __IMFMediaCacheManager_INTERFACE_DEFINED__

/* interface IMFMediaCacheManager */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMediaCacheManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e9cd0394-a268-4bb4-82de-658d53574d41")
    IMFMediaCacheManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginOpenCacheFile( 
            /* [in] */ LPCWSTR pszUrl,
            /* [in] */ LPCWSTR pszKey,
            /* [in] */ DWORD OpenMode,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOpenCacheFile( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaCache **ppCache) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaCacheManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaCacheManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaCacheManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaCacheManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOpenCacheFile )( 
            IMFMediaCacheManager * This,
            /* [in] */ LPCWSTR pszUrl,
            /* [in] */ LPCWSTR pszKey,
            /* [in] */ DWORD OpenMode,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndOpenCacheFile )( 
            IMFMediaCacheManager * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaCache **ppCache);
        
        END_INTERFACE
    } IMFMediaCacheManagerVtbl;

    interface IMFMediaCacheManager
    {
        CONST_VTBL struct IMFMediaCacheManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaCacheManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaCacheManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaCacheManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaCacheManager_BeginOpenCacheFile(This,pszUrl,pszKey,OpenMode,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginOpenCacheFile(This,pszUrl,pszKey,OpenMode,pCallback,pState) ) 

#define IMFMediaCacheManager_EndOpenCacheFile(This,pResult,ppCache)	\
    ( (This)->lpVtbl -> EndOpenCacheFile(This,pResult,ppCache) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaCacheManager_INTERFACE_DEFINED__ */


#ifndef __IMFRecordQueue_INTERFACE_DEFINED__
#define __IMFRecordQueue_INTERFACE_DEFINED__

/* interface IMFRecordQueue */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFRecordQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47b2d14f-568c-49f5-bc68-51370bb8b23f")
    IMFRecordQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [annotation][out] */ 
            __out  IMFMediaSource **ppMediaSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFRecordQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFRecordQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFRecordQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFRecordQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSource )( 
            IMFRecordQueue * This,
            /* [annotation][out] */ 
            __out  IMFMediaSource **ppMediaSource);
        
        END_INTERFACE
    } IMFRecordQueueVtbl;

    interface IMFRecordQueue
    {
        CONST_VTBL struct IMFRecordQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFRecordQueue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFRecordQueue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFRecordQueue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFRecordQueue_GetSource(This,ppMediaSource)	\
    ( (This)->lpVtbl -> GetSource(This,ppMediaSource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFRecordQueue_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0030 */
/* [local] */ 

typedef /* [public] */ struct STREAM_LEAKY_BUCKET_
    {
    double fBitrate;
    double fBufferWindow;
    double fBufferFullness;
    } 	STREAM_LEAKY_BUCKET;

typedef /* [public] */ struct STREAM_LEAKY_BUCKETS_
    {
    STREAM_LEAKY_BUCKET avgLeakyBucket;
    STREAM_LEAKY_BUCKET maxLeakyBucket;
    } 	STREAM_LEAKY_BUCKETS;

typedef 
enum _MFNETBUFFERCONTROLEVENT
    {	MFNETBC_BEGIN_STREAMING	= 0,
	MFNETBC_BEGIN_RENDERING	= ( MFNETBC_BEGIN_STREAMING + 1 ) ,
	MFNETBC_USER_STOPS_RENDERING	= ( MFNETBC_BEGIN_RENDERING + 1 ) ,
	MFNETBC_USER_RESUMES_RENDERING	= ( MFNETBC_USER_STOPS_RENDERING + 1 ) ,
	MFNETBC_REBUFFER_STOPS_RENDERING	= ( MFNETBC_USER_RESUMES_RENDERING + 1 ) ,
	MFNETBC_REBUFFER_RESUMES_RENDERING	= ( MFNETBC_REBUFFER_STOPS_RENDERING + 1 ) ,
	MFNETBC_ENDOFSTREAMING	= ( MFNETBC_REBUFFER_RESUMES_RENDERING + 1 ) 
    } 	MFNET_BUFFERCONTROL_EVENT;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0030_v0_0_s_ifspec;

#ifndef __IMFNetBufferControl_INTERFACE_DEFINED__
#define __IMFNetBufferControl_INTERFACE_DEFINED__

/* interface IMFNetBufferControl */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetBufferControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d99849fc-41d3-4bbf-aacd-ffb94ec48c2b")
    IMFNetBufferControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddStreamSet( 
            /* [in] */ DWORD dwStreamCount,
            /* [annotation][in] */ 
            __in_ecount(dwStreamCount)  STREAM_LEAKY_BUCKETS *pLeakyBuckets,
            /* [annotation][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pdwSteamSetIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentStreamSet( 
            /* [in] */ DWORD dwSteamSetIndex,
            /* [in] */ DWORD dwStreamCount,
            /* [annotation][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pStreamIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRecvPacket( 
            /* [in] */ DWORD dwCurrentTime,
            /* [in] */ DWORD dwPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnRecvSample( 
            /* [in] */ IMFSample *pSample,
            /* [in] */ DWORD dwCurrentTime,
            /* [annotation][out] */ 
            __out  BOOL *pfReadyForPlayback,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamSetId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            MFNET_BUFFERCONTROL_EVENT event,
            DWORD dwCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetBufferControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetBufferControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetBufferControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetBufferControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamSet )( 
            IMFNetBufferControl * This,
            /* [in] */ DWORD dwStreamCount,
            /* [annotation][in] */ 
            __in_ecount(dwStreamCount)  STREAM_LEAKY_BUCKETS *pLeakyBuckets,
            /* [annotation][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pdwSteamSetIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentStreamSet )( 
            IMFNetBufferControl * This,
            /* [in] */ DWORD dwSteamSetIndex,
            /* [in] */ DWORD dwStreamCount,
            /* [annotation][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pStreamIds);
        
        HRESULT ( STDMETHODCALLTYPE *OnRecvPacket )( 
            IMFNetBufferControl * This,
            /* [in] */ DWORD dwCurrentTime,
            /* [in] */ DWORD dwPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE *OnRecvSample )( 
            IMFNetBufferControl * This,
            /* [in] */ IMFSample *pSample,
            /* [in] */ DWORD dwCurrentTime,
            /* [annotation][out] */ 
            __out  BOOL *pfReadyForPlayback,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamSetId);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IMFNetBufferControl * This,
            MFNET_BUFFERCONTROL_EVENT event,
            DWORD dwCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IMFNetBufferControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFNetBufferControl * This);
        
        END_INTERFACE
    } IMFNetBufferControlVtbl;

    interface IMFNetBufferControl
    {
        CONST_VTBL struct IMFNetBufferControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetBufferControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetBufferControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetBufferControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetBufferControl_AddStreamSet(This,dwStreamCount,pLeakyBuckets,pdwSteamSetIndex)	\
    ( (This)->lpVtbl -> AddStreamSet(This,dwStreamCount,pLeakyBuckets,pdwSteamSetIndex) ) 

#define IMFNetBufferControl_SetCurrentStreamSet(This,dwSteamSetIndex,dwStreamCount,pStreamIds)	\
    ( (This)->lpVtbl -> SetCurrentStreamSet(This,dwSteamSetIndex,dwStreamCount,pStreamIds) ) 

#define IMFNetBufferControl_OnRecvPacket(This,dwCurrentTime,dwPacketSize)	\
    ( (This)->lpVtbl -> OnRecvPacket(This,dwCurrentTime,dwPacketSize) ) 

#define IMFNetBufferControl_OnRecvSample(This,pSample,dwCurrentTime,pfReadyForPlayback,pdwStreamSetId)	\
    ( (This)->lpVtbl -> OnRecvSample(This,pSample,dwCurrentTime,pfReadyForPlayback,pdwStreamSetId) ) 

#define IMFNetBufferControl_OnEvent(This,event,dwCurrentTime)	\
    ( (This)->lpVtbl -> OnEvent(This,event,dwCurrentTime) ) 

#define IMFNetBufferControl_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IMFNetBufferControl_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetBufferControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0031 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0031_v0_0_s_ifspec;

#ifndef __IMFNetEvent_INTERFACE_DEFINED__
#define __IMFNetEvent_INTERFACE_DEFINED__

/* interface IMFNetEvent */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8e2f2315-0036-4f47-b6fd-b86c67ec1ab3")
    IMFNetEvent : public IMFMediaEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVRoot( 
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequest( 
            /* [out] */ IMFNetHeaderCollection **ppRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResponse( 
            /* [out] */ IMFNetHeaderCollection **ppResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        END_INTERFACE
    } IMFNetEventVtbl;

    interface IMFNetEvent
    {
        CONST_VTBL struct IMFNetEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetEvent_INTERFACE_DEFINED__ */


#ifndef __IMFNetRawEvent_INTERFACE_DEFINED__
#define __IMFNetRawEvent_INTERFACE_DEFINED__

/* interface IMFNetRawEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetRawEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("efda1ed6-dc24-48c1-B7C5-F1E45CA5A14B")
    IMFNetRawEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParsedNetEvent( 
            /* [annotation][out] */ 
            __out  IMFNetEvent **ppNetEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParsedNetEvent( 
            /* [in] */ IMFNetEvent *pNetEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetRawEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetRawEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetRawEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetRawEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetRawEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetRawEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetRawEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetRawEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetRawEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetRawEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetRawEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetRawEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetRawEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetRawEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetRawEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetRawEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetRawEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetRawEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetRawEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetRawEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetRawEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetRawEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetParsedNetEvent )( 
            IMFNetRawEvent * This,
            /* [annotation][out] */ 
            __out  IMFNetEvent **ppNetEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetParsedNetEvent )( 
            IMFNetRawEvent * This,
            /* [in] */ IMFNetEvent *pNetEvent);
        
        END_INTERFACE
    } IMFNetRawEventVtbl;

    interface IMFNetRawEvent
    {
        CONST_VTBL struct IMFNetRawEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetRawEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetRawEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetRawEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetRawEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetRawEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetRawEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetRawEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetRawEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetRawEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetRawEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetRawEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetRawEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetRawEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetRawEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetRawEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetRawEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetRawEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetRawEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetRawEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetRawEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetRawEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetRawEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetRawEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetRawEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetRawEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetRawEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetRawEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetRawEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetRawEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetRawEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetRawEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetRawEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetRawEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetRawEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetRawEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetRawEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetRawEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetRawEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetRawEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetRawEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetRawEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetRawEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetRawEvent_GetParsedNetEvent(This,ppNetEvent)	\
    ( (This)->lpVtbl -> GetParsedNetEvent(This,ppNetEvent) ) 

#define IMFNetRawEvent_SetParsedNetEvent(This,pNetEvent)	\
    ( (This)->lpVtbl -> SetParsedNetEvent(This,pNetEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetRawEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0032 */
/* [local] */ 

typedef LPCWSTR MF_DRMNET_SESSIONID;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0032_v0_0_s_ifspec;

#ifndef __IMFNetCardeaLicenseRequestEvent_INTERFACE_DEFINED__
#define __IMFNetCardeaLicenseRequestEvent_INTERFACE_DEFINED__

/* interface IMFNetCardeaLicenseRequestEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetCardeaLicenseRequestEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("674eff6a-5144-487a-a01d-013fc23d0353")
    IMFNetCardeaLicenseRequestEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSessionId( 
            /* [annotation][out] */ 
            __out  MF_DRMNET_SESSIONID *pSessionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionId( 
            /* [in] */ MF_DRMNET_SESSIONID sessionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLicenseRequest( 
            /* [annotation][out] */ 
            __out  IMFMediaBuffer **ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLicenseResponse( 
            /* [in] */ IMFMediaBuffer *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLicenseKID( 
            /* [in] */ LPCWSTR pwszKID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetChannel( 
            /* [annotation][out] */ 
            __out  IUnknown **ppNetChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetChannel( 
            /* [in] */ IUnknown *pNetChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetCardeaLicenseRequestEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetCardeaLicenseRequestEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetCardeaLicenseRequestEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetCardeaLicenseRequestEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetCardeaLicenseRequestEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetCardeaLicenseRequestEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetCardeaLicenseRequestEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetCardeaLicenseRequestEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetCardeaLicenseRequestEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionId )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [annotation][out] */ 
            __out  MF_DRMNET_SESSIONID *pSessionId);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionId )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ MF_DRMNET_SESSIONID sessionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetLicenseRequest )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [annotation][out] */ 
            __out  IMFMediaBuffer **ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *SetLicenseResponse )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ IMFMediaBuffer *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *SetLicenseKID )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ LPCWSTR pwszKID);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetChannel )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [annotation][out] */ 
            __out  IUnknown **ppNetChannel);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetChannel )( 
            IMFNetCardeaLicenseRequestEvent * This,
            /* [in] */ IUnknown *pNetChannel);
        
        END_INTERFACE
    } IMFNetCardeaLicenseRequestEventVtbl;

    interface IMFNetCardeaLicenseRequestEvent
    {
        CONST_VTBL struct IMFNetCardeaLicenseRequestEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetCardeaLicenseRequestEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetCardeaLicenseRequestEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetCardeaLicenseRequestEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetCardeaLicenseRequestEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetCardeaLicenseRequestEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetCardeaLicenseRequestEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetCardeaLicenseRequestEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetCardeaLicenseRequestEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetCardeaLicenseRequestEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetCardeaLicenseRequestEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetCardeaLicenseRequestEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetCardeaLicenseRequestEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetCardeaLicenseRequestEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetCardeaLicenseRequestEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetCardeaLicenseRequestEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetCardeaLicenseRequestEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetCardeaLicenseRequestEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetCardeaLicenseRequestEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetCardeaLicenseRequestEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetCardeaLicenseRequestEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetCardeaLicenseRequestEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetCardeaLicenseRequestEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetCardeaLicenseRequestEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetCardeaLicenseRequestEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetCardeaLicenseRequestEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetCardeaLicenseRequestEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetCardeaLicenseRequestEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetCardeaLicenseRequestEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetCardeaLicenseRequestEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetCardeaLicenseRequestEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetCardeaLicenseRequestEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetCardeaLicenseRequestEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetCardeaLicenseRequestEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetCardeaLicenseRequestEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetCardeaLicenseRequestEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetCardeaLicenseRequestEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetCardeaLicenseRequestEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetCardeaLicenseRequestEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetCardeaLicenseRequestEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetCardeaLicenseRequestEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetCardeaLicenseRequestEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetCardeaLicenseRequestEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetCardeaLicenseRequestEvent_GetSessionId(This,pSessionId)	\
    ( (This)->lpVtbl -> GetSessionId(This,pSessionId) ) 

#define IMFNetCardeaLicenseRequestEvent_SetSessionId(This,sessionId)	\
    ( (This)->lpVtbl -> SetSessionId(This,sessionId) ) 

#define IMFNetCardeaLicenseRequestEvent_GetLicenseRequest(This,ppBuffer)	\
    ( (This)->lpVtbl -> GetLicenseRequest(This,ppBuffer) ) 

#define IMFNetCardeaLicenseRequestEvent_SetLicenseResponse(This,pBuffer)	\
    ( (This)->lpVtbl -> SetLicenseResponse(This,pBuffer) ) 

#define IMFNetCardeaLicenseRequestEvent_SetLicenseKID(This,pwszKID)	\
    ( (This)->lpVtbl -> SetLicenseKID(This,pwszKID) ) 

#define IMFNetCardeaLicenseRequestEvent_GetNetChannel(This,ppNetChannel)	\
    ( (This)->lpVtbl -> GetNetChannel(This,ppNetChannel) ) 

#define IMFNetCardeaLicenseRequestEvent_SetNetChannel(This,pNetChannel)	\
    ( (This)->lpVtbl -> SetNetChannel(This,pNetChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetCardeaLicenseRequestEvent_INTERFACE_DEFINED__ */


#ifndef __IMFNetDownloadEvent_INTERFACE_DEFINED__
#define __IMFNetDownloadEvent_INTERFACE_DEFINED__

/* interface IMFNetDownloadEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetDownloadEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc2f94f4-42ab-4f17-87ba-4ba3d51e99cb")
    IMFNetDownloadEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDownloadFileHandle( 
            /* [annotation][out] */ 
            __out  HANDLE *pHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDownloadFileHandle( 
            /* [in] */ HANDLE pHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteStream( 
            /* [annotation][out] */ 
            __out  IMFByteStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetByteStream( 
            /* [in] */ IMFByteStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetChannel( 
            /* [annotation][out] */ 
            __out  IUnknown **ppNetChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetChannel( 
            /* [in] */ IUnknown *pNetChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteRange( 
            /* [annotation][out] */ 
            __out  QWORD *pqwStartOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwByteRangeLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetByteRange( 
            /* [in] */ QWORD qwStartOffset,
            /* [in] */ QWORD qwByteRangeLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetDownloadEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetDownloadEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetDownloadEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetDownloadEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetDownloadEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetDownloadEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetDownloadEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetDownloadEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetDownloadEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetDownloadEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetDownloadEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetDownloadEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetDownloadEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetDownloadEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetDownloadEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetDownloadEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetDownloadEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetDownloadEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetDownloadEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetDownloadEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetDownloadEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadFileHandle )( 
            IMFNetDownloadEvent * This,
            /* [annotation][out] */ 
            __out  HANDLE *pHandle);
        
        HRESULT ( STDMETHODCALLTYPE *SetDownloadFileHandle )( 
            IMFNetDownloadEvent * This,
            /* [in] */ HANDLE pHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteStream )( 
            IMFNetDownloadEvent * This,
            /* [annotation][out] */ 
            __out  IMFByteStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetByteStream )( 
            IMFNetDownloadEvent * This,
            /* [in] */ IMFByteStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetChannel )( 
            IMFNetDownloadEvent * This,
            /* [annotation][out] */ 
            __out  IUnknown **ppNetChannel);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetChannel )( 
            IMFNetDownloadEvent * This,
            /* [in] */ IUnknown *pNetChannel);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteRange )( 
            IMFNetDownloadEvent * This,
            /* [annotation][out] */ 
            __out  QWORD *pqwStartOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwByteRangeLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetByteRange )( 
            IMFNetDownloadEvent * This,
            /* [in] */ QWORD qwStartOffset,
            /* [in] */ QWORD qwByteRangeLength);
        
        END_INTERFACE
    } IMFNetDownloadEventVtbl;

    interface IMFNetDownloadEvent
    {
        CONST_VTBL struct IMFNetDownloadEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetDownloadEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetDownloadEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetDownloadEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetDownloadEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetDownloadEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetDownloadEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetDownloadEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetDownloadEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetDownloadEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetDownloadEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetDownloadEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetDownloadEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetDownloadEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetDownloadEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetDownloadEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetDownloadEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetDownloadEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetDownloadEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetDownloadEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetDownloadEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetDownloadEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetDownloadEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetDownloadEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetDownloadEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetDownloadEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetDownloadEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetDownloadEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetDownloadEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetDownloadEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetDownloadEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetDownloadEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetDownloadEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetDownloadEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetDownloadEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetDownloadEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetDownloadEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetDownloadEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetDownloadEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetDownloadEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetDownloadEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetDownloadEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetDownloadEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetDownloadEvent_GetDownloadFileHandle(This,pHandle)	\
    ( (This)->lpVtbl -> GetDownloadFileHandle(This,pHandle) ) 

#define IMFNetDownloadEvent_SetDownloadFileHandle(This,pHandle)	\
    ( (This)->lpVtbl -> SetDownloadFileHandle(This,pHandle) ) 

#define IMFNetDownloadEvent_GetByteStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetByteStream(This,ppStream) ) 

#define IMFNetDownloadEvent_SetByteStream(This,pStream)	\
    ( (This)->lpVtbl -> SetByteStream(This,pStream) ) 

#define IMFNetDownloadEvent_GetNetChannel(This,ppNetChannel)	\
    ( (This)->lpVtbl -> GetNetChannel(This,ppNetChannel) ) 

#define IMFNetDownloadEvent_SetNetChannel(This,pNetChannel)	\
    ( (This)->lpVtbl -> SetNetChannel(This,pNetChannel) ) 

#define IMFNetDownloadEvent_GetByteRange(This,pqwStartOffset,pqwByteRangeLength)	\
    ( (This)->lpVtbl -> GetByteRange(This,pqwStartOffset,pqwByteRangeLength) ) 

#define IMFNetDownloadEvent_SetByteRange(This,qwStartOffset,qwByteRangeLength)	\
    ( (This)->lpVtbl -> SetByteRange(This,qwStartOffset,qwByteRangeLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetDownloadEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0034 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0034_v0_0_s_ifspec;

#ifndef __IMFNetDescribeEvent_INTERFACE_DEFINED__
#define __IMFNetDescribeEvent_INTERFACE_DEFINED__

/* interface IMFNetDescribeEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetDescribeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8e2f2316-0036-4f47-b6fd-b86c67ec1ab3")
    IMFNetDescribeEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPresentationTarget( 
            /* [annotation][out] */ 
            __out  IUnknown **ppNetPresentationTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPresentationTarget( 
            /* [in] */ IUnknown *pNetPresentationTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCongestionController( 
            /* [annotation][out] */ 
            __out  IMFNetworkCongestionControl **ppCongestionController) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCongestionController( 
            /* [in] */ IMFNetworkCongestionControl *pCongestionController) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetDescribeEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetDescribeEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetDescribeEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetDescribeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetDescribeEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetDescribeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetDescribeEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetDescribeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetDescribeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetDescribeEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetDescribeEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetDescribeEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetDescribeEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetDescribeEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetDescribeEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetDescribeEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetDescribeEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetDescribeEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetDescribeEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetDescribeEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetDescribeEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetPresentationTarget )( 
            IMFNetDescribeEvent * This,
            /* [annotation][out] */ 
            __out  IUnknown **ppNetPresentationTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetPresentationTarget )( 
            IMFNetDescribeEvent * This,
            /* [in] */ IUnknown *pNetPresentationTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetCongestionController )( 
            IMFNetDescribeEvent * This,
            /* [annotation][out] */ 
            __out  IMFNetworkCongestionControl **ppCongestionController);
        
        HRESULT ( STDMETHODCALLTYPE *SetCongestionController )( 
            IMFNetDescribeEvent * This,
            /* [in] */ IMFNetworkCongestionControl *pCongestionController);
        
        END_INTERFACE
    } IMFNetDescribeEventVtbl;

    interface IMFNetDescribeEvent
    {
        CONST_VTBL struct IMFNetDescribeEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetDescribeEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetDescribeEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetDescribeEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetDescribeEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetDescribeEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetDescribeEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetDescribeEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetDescribeEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetDescribeEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetDescribeEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetDescribeEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetDescribeEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetDescribeEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetDescribeEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetDescribeEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetDescribeEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetDescribeEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetDescribeEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetDescribeEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetDescribeEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetDescribeEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetDescribeEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetDescribeEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetDescribeEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetDescribeEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetDescribeEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetDescribeEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetDescribeEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetDescribeEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetDescribeEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetDescribeEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetDescribeEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetDescribeEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetDescribeEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetDescribeEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetDescribeEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetDescribeEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetDescribeEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetDescribeEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetDescribeEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetDescribeEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetDescribeEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetDescribeEvent_GetPresentationTarget(This,ppNetPresentationTarget)	\
    ( (This)->lpVtbl -> GetPresentationTarget(This,ppNetPresentationTarget) ) 

#define IMFNetDescribeEvent_SetPresentationTarget(This,pNetPresentationTarget)	\
    ( (This)->lpVtbl -> SetPresentationTarget(This,pNetPresentationTarget) ) 

#define IMFNetDescribeEvent_GetCongestionController(This,ppCongestionController)	\
    ( (This)->lpVtbl -> GetCongestionController(This,ppCongestionController) ) 

#define IMFNetDescribeEvent_SetCongestionController(This,pCongestionController)	\
    ( (This)->lpVtbl -> SetCongestionController(This,pCongestionController) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetDescribeEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0035 */
/* [local] */ 

typedef 
enum MF_THINNING_LEVEL
    {	NO_THINNING	= 0,
	INTERMEDIATE_FRAME_THINNING	= 1,
	REMOVE_ALL_FRAMES	= 2
    } 	MF_THINNING_LEVEL;

typedef /* [public] */ struct _MFSSENTRY
    {
    DWORD dwOldStreamNumber;
    DWORD dwNewStreamNumber;
    DWORD dwOldWireStreamNumber;
    DWORD dwNewWireStreamNumber;
    MF_THINNING_LEVEL ThinningLevel;
    } 	MFSSENTRY;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0035_v0_0_s_ifspec;

#ifndef __IMFNetSelectStreamsEvent_INTERFACE_DEFINED__
#define __IMFNetSelectStreamsEvent_INTERFACE_DEFINED__

/* interface IMFNetSelectStreamsEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetSelectStreamsEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("117509a5-4509-40c9-ad4c-f47f18a78f77")
    IMFNetSelectStreamsEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelections( 
            /* [annotation][size_is][out] */ 
            __out_ecount_part(*pdwSSEntryCount, *pdwSSEntryCount)  MFSSENTRY *pMFSSEntry,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwSSEntryCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportProperties( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  IPropertyStore **ppTransportProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetSelectStreamsEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetSelectStreamsEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetSelectStreamsEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetSelectStreamsEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetSelectStreamsEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetSelectStreamsEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetSelectStreamsEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetSelectStreamsEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetSelectStreamsEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetSelectStreamsEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetSelectStreamsEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetSelectStreamsEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetSelectStreamsEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetSelectStreamsEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetSelectStreamsEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelections )( 
            IMFNetSelectStreamsEvent * This,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(*pdwSSEntryCount, *pdwSSEntryCount)  MFSSENTRY *pMFSSEntry,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwSSEntryCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportProperties )( 
            IMFNetSelectStreamsEvent * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  IPropertyStore **ppTransportProps);
        
        END_INTERFACE
    } IMFNetSelectStreamsEventVtbl;

    interface IMFNetSelectStreamsEvent
    {
        CONST_VTBL struct IMFNetSelectStreamsEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetSelectStreamsEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetSelectStreamsEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetSelectStreamsEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetSelectStreamsEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetSelectStreamsEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetSelectStreamsEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetSelectStreamsEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetSelectStreamsEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetSelectStreamsEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetSelectStreamsEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetSelectStreamsEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetSelectStreamsEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetSelectStreamsEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetSelectStreamsEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetSelectStreamsEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetSelectStreamsEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetSelectStreamsEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetSelectStreamsEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetSelectStreamsEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetSelectStreamsEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetSelectStreamsEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetSelectStreamsEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetSelectStreamsEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetSelectStreamsEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetSelectStreamsEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetSelectStreamsEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetSelectStreamsEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetSelectStreamsEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetSelectStreamsEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetSelectStreamsEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetSelectStreamsEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetSelectStreamsEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetSelectStreamsEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetSelectStreamsEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetSelectStreamsEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetSelectStreamsEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetSelectStreamsEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetSelectStreamsEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetSelectStreamsEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetSelectStreamsEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetSelectStreamsEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetSelectStreamsEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetSelectStreamsEvent_GetStreamSelections(This,pMFSSEntry,pdwSSEntryCount)	\
    ( (This)->lpVtbl -> GetStreamSelections(This,pMFSSEntry,pdwSSEntryCount) ) 

#define IMFNetSelectStreamsEvent_GetTransportProperties(This,dwStreamId,ppTransportProps)	\
    ( (This)->lpVtbl -> GetTransportProperties(This,dwStreamId,ppTransportProps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetSelectStreamsEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0036 */
/* [local] */ 

typedef 
enum MF_SEEK_TYPE
    {	SEEK_TO_TIME	= 0,
	SEEK_TO_PACKET	= 1,
	SEEK_TO_BYTE_OFFSET	= 2
    } 	MF_SEEK_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0036_v0_0_s_ifspec;

#ifndef __IMFNetPlayEvent_INTERFACE_DEFINED__
#define __IMFNetPlayEvent_INTERFACE_DEFINED__

/* interface IMFNetPlayEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetPlayEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bbc20c5b-c228-4ab3-b188-e5d00d31475b")
    IMFNetPlayEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStartOffset( 
            /* [annotation][out] */ 
            __out  MF_SEEK_TYPE *pSeekType,
            /* [annotation][out] */ 
            __out  QWORD *pdwStartOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStopOffset( 
            /* [annotation][out] */ 
            __out  MF_SEEK_TYPE *pSeekType,
            /* [annotation][out] */ 
            __out  QWORD *pdwStopOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStartOffset( 
            /* [in] */ MF_SEEK_TYPE SeekType,
            /* [in] */ QWORD dwStartOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStopOffset( 
            /* [in] */ MF_SEEK_TYPE SeekType,
            /* [in] */ QWORD dwStopOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientRate( 
            /* [annotation][out] */ 
            __out  float *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientRate( 
            /* [in] */ float dRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerRate( 
            /* [annotation][out] */ 
            __out  float *pdRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServerRate( 
            /* [in] */ float dRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientSpeed( 
            /* [annotation][out] */ 
            __out  float *pdSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientSpeed( 
            /* [in] */ float dSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerSpeed( 
            /* [annotation][out] */ 
            __out  float *pdSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServerSpeed( 
            /* [in] */ float dSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccelParams( 
            /* [annotation][out] */ 
            __out  DWORD *pdwAccelBandwidth,
            /* [annotation][out] */ 
            __out  DWORD *pdwAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccelParams( 
            /* [in] */ DWORD dwAccelBandwidth,
            /* [in] */ DWORD dwAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedVideoStreams( 
            /* [annotation][size_is][out] */ 
            __out_ecount_part(*pdwStreamCount, *pdwStreamCount)  DWORD *pVideoStreamId,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelectedVideoStreams( 
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pVideoStreamId,
            /* [in] */ DWORD dwStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRtpInfo( 
            /* [in] */ DWORD dwStreamId,
            /* [in] */ DWORD dwSeq,
            /* [in] */ DWORD dwRtpTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRtpInfo( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwSeq,
            /* [annotation][out] */ 
            __out  DWORD *pdwRtpTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSendWallClockTime( 
            /* [annotation][out] */ 
            __out  BOOL *pfSendWallClockTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSendWallClockTime( 
            /* [in] */ BOOL fSendWallClockTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetPlayEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetPlayEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetPlayEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetPlayEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetPlayEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetPlayEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetPlayEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetPlayEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetPlayEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetPlayEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetPlayEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetPlayEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetPlayEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetPlayEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetPlayEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetPlayEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetPlayEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetPlayEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetPlayEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetPlayEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetPlayEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartOffset )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  MF_SEEK_TYPE *pSeekType,
            /* [annotation][out] */ 
            __out  QWORD *pdwStartOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopOffset )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  MF_SEEK_TYPE *pSeekType,
            /* [annotation][out] */ 
            __out  QWORD *pdwStopOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetStartOffset )( 
            IMFNetPlayEvent * This,
            /* [in] */ MF_SEEK_TYPE SeekType,
            /* [in] */ QWORD dwStartOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetStopOffset )( 
            IMFNetPlayEvent * This,
            /* [in] */ MF_SEEK_TYPE SeekType,
            /* [in] */ QWORD dwStopOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientRate )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  float *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientRate )( 
            IMFNetPlayEvent * This,
            /* [in] */ float dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerRate )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  float *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *SetServerRate )( 
            IMFNetPlayEvent * This,
            /* [in] */ float dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientSpeed )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  float *pdSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientSpeed )( 
            IMFNetPlayEvent * This,
            /* [in] */ float dSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerSpeed )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  float *pdSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *SetServerSpeed )( 
            IMFNetPlayEvent * This,
            /* [in] */ float dSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccelParams )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwAccelBandwidth,
            /* [annotation][out] */ 
            __out  DWORD *pdwAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccelParams )( 
            IMFNetPlayEvent * This,
            /* [in] */ DWORD dwAccelBandwidth,
            /* [in] */ DWORD dwAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedVideoStreams )( 
            IMFNetPlayEvent * This,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(*pdwStreamCount, *pdwStreamCount)  DWORD *pVideoStreamId,
            /* [annotation][out][in] */ 
            __inout  DWORD *pdwStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectedVideoStreams )( 
            IMFNetPlayEvent * This,
            /* [annotation][size_is][in] */ 
            __in_ecount(dwStreamCount)  DWORD *pVideoStreamId,
            /* [in] */ DWORD dwStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetRtpInfo )( 
            IMFNetPlayEvent * This,
            /* [in] */ DWORD dwStreamId,
            /* [in] */ DWORD dwSeq,
            /* [in] */ DWORD dwRtpTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetRtpInfo )( 
            IMFNetPlayEvent * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwSeq,
            /* [annotation][out] */ 
            __out  DWORD *pdwRtpTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetSendWallClockTime )( 
            IMFNetPlayEvent * This,
            /* [annotation][out] */ 
            __out  BOOL *pfSendWallClockTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSendWallClockTime )( 
            IMFNetPlayEvent * This,
            /* [in] */ BOOL fSendWallClockTime);
        
        END_INTERFACE
    } IMFNetPlayEventVtbl;

    interface IMFNetPlayEvent
    {
        CONST_VTBL struct IMFNetPlayEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetPlayEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetPlayEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetPlayEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetPlayEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetPlayEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetPlayEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetPlayEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetPlayEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetPlayEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetPlayEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetPlayEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetPlayEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetPlayEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetPlayEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetPlayEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetPlayEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetPlayEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetPlayEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetPlayEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetPlayEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetPlayEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetPlayEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetPlayEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetPlayEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetPlayEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetPlayEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetPlayEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetPlayEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetPlayEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetPlayEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetPlayEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetPlayEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetPlayEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetPlayEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetPlayEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetPlayEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetPlayEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetPlayEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetPlayEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetPlayEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetPlayEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetPlayEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetPlayEvent_GetStartOffset(This,pSeekType,pdwStartOffset)	\
    ( (This)->lpVtbl -> GetStartOffset(This,pSeekType,pdwStartOffset) ) 

#define IMFNetPlayEvent_GetStopOffset(This,pSeekType,pdwStopOffset)	\
    ( (This)->lpVtbl -> GetStopOffset(This,pSeekType,pdwStopOffset) ) 

#define IMFNetPlayEvent_SetStartOffset(This,SeekType,dwStartOffset)	\
    ( (This)->lpVtbl -> SetStartOffset(This,SeekType,dwStartOffset) ) 

#define IMFNetPlayEvent_SetStopOffset(This,SeekType,dwStopOffset)	\
    ( (This)->lpVtbl -> SetStopOffset(This,SeekType,dwStopOffset) ) 

#define IMFNetPlayEvent_GetClientRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetClientRate(This,pdRate) ) 

#define IMFNetPlayEvent_SetClientRate(This,dRate)	\
    ( (This)->lpVtbl -> SetClientRate(This,dRate) ) 

#define IMFNetPlayEvent_GetServerRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetServerRate(This,pdRate) ) 

#define IMFNetPlayEvent_SetServerRate(This,dRate)	\
    ( (This)->lpVtbl -> SetServerRate(This,dRate) ) 

#define IMFNetPlayEvent_GetClientSpeed(This,pdSpeed)	\
    ( (This)->lpVtbl -> GetClientSpeed(This,pdSpeed) ) 

#define IMFNetPlayEvent_SetClientSpeed(This,dSpeed)	\
    ( (This)->lpVtbl -> SetClientSpeed(This,dSpeed) ) 

#define IMFNetPlayEvent_GetServerSpeed(This,pdSpeed)	\
    ( (This)->lpVtbl -> GetServerSpeed(This,pdSpeed) ) 

#define IMFNetPlayEvent_SetServerSpeed(This,dSpeed)	\
    ( (This)->lpVtbl -> SetServerSpeed(This,dSpeed) ) 

#define IMFNetPlayEvent_GetAccelParams(This,pdwAccelBandwidth,pdwAccelDuration)	\
    ( (This)->lpVtbl -> GetAccelParams(This,pdwAccelBandwidth,pdwAccelDuration) ) 

#define IMFNetPlayEvent_SetAccelParams(This,dwAccelBandwidth,dwAccelDuration)	\
    ( (This)->lpVtbl -> SetAccelParams(This,dwAccelBandwidth,dwAccelDuration) ) 

#define IMFNetPlayEvent_GetSelectedVideoStreams(This,pVideoStreamId,pdwStreamCount)	\
    ( (This)->lpVtbl -> GetSelectedVideoStreams(This,pVideoStreamId,pdwStreamCount) ) 

#define IMFNetPlayEvent_SetSelectedVideoStreams(This,pVideoStreamId,dwStreamCount)	\
    ( (This)->lpVtbl -> SetSelectedVideoStreams(This,pVideoStreamId,dwStreamCount) ) 

#define IMFNetPlayEvent_SetRtpInfo(This,dwStreamId,dwSeq,dwRtpTime)	\
    ( (This)->lpVtbl -> SetRtpInfo(This,dwStreamId,dwSeq,dwRtpTime) ) 

#define IMFNetPlayEvent_GetRtpInfo(This,dwStreamId,pdwSeq,pdwRtpTime)	\
    ( (This)->lpVtbl -> GetRtpInfo(This,dwStreamId,pdwSeq,pdwRtpTime) ) 

#define IMFNetPlayEvent_GetSendWallClockTime(This,pfSendWallClockTime)	\
    ( (This)->lpVtbl -> GetSendWallClockTime(This,pfSendWallClockTime) ) 

#define IMFNetPlayEvent_SetSendWallClockTime(This,fSendWallClockTime)	\
    ( (This)->lpVtbl -> SetSendWallClockTime(This,fSendWallClockTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetPlayEvent_INTERFACE_DEFINED__ */


#ifndef __IMFNetEosEvent_INTERFACE_DEFINED__
#define __IMFNetEosEvent_INTERFACE_DEFINED__

/* interface IMFNetEosEvent */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetEosEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7C1411A3-4133-4d4e-BF38-276DBF9BB48A")
    IMFNetEosEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRtpInfo( 
            /* [in] */ DWORD dwStreamId,
            /* [in] */ DWORD dwSeq,
            /* [in] */ DWORD dwRtpTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRtpInfo( 
            /* [in] */ DWORD dwStreamId,
            /* [out] */ DWORD *pdwSeq,
            /* [out] */ DWORD *pdwRtpTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetEosEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetEosEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetEosEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetEosEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetEosEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetEosEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetEosEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetEosEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetEosEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetEosEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetEosEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetEosEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetEosEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetEosEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetEosEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetEosEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetEosEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetEosEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetEosEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetEosEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetEosEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetEosEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *SetRtpInfo )( 
            IMFNetEosEvent * This,
            /* [in] */ DWORD dwStreamId,
            /* [in] */ DWORD dwSeq,
            /* [in] */ DWORD dwRtpTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetRtpInfo )( 
            IMFNetEosEvent * This,
            /* [in] */ DWORD dwStreamId,
            /* [out] */ DWORD *pdwSeq,
            /* [out] */ DWORD *pdwRtpTime);
        
        END_INTERFACE
    } IMFNetEosEventVtbl;

    interface IMFNetEosEvent
    {
        CONST_VTBL struct IMFNetEosEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetEosEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetEosEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetEosEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetEosEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetEosEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetEosEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetEosEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetEosEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetEosEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetEosEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetEosEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetEosEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetEosEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetEosEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetEosEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetEosEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetEosEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetEosEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetEosEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetEosEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetEosEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetEosEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetEosEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetEosEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetEosEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetEosEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetEosEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetEosEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetEosEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetEosEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetEosEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetEosEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetEosEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetEosEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetEosEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetEosEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetEosEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetEosEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetEosEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetEosEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetEosEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetEosEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetEosEvent_SetRtpInfo(This,dwStreamId,dwSeq,dwRtpTime)	\
    ( (This)->lpVtbl -> SetRtpInfo(This,dwStreamId,dwSeq,dwRtpTime) ) 

#define IMFNetEosEvent_GetRtpInfo(This,dwStreamId,pdwSeq,pdwRtpTime)	\
    ( (This)->lpVtbl -> GetRtpInfo(This,dwStreamId,pdwSeq,pdwRtpTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetEosEvent_INTERFACE_DEFINED__ */


#ifndef __IMFNetCloseEvent_INTERFACE_DEFINED__
#define __IMFNetCloseEvent_INTERFACE_DEFINED__

/* interface IMFNetCloseEvent */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetCloseEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19006102-92B7-4263-953C-B84C24BEDCCE")
    IMFNetCloseEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamingStatus( 
            HRESULT *phrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetCloseEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetCloseEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetCloseEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetCloseEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetCloseEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetCloseEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetCloseEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetCloseEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetCloseEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetCloseEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetCloseEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetCloseEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetCloseEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetCloseEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetCloseEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetCloseEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetCloseEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetCloseEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetCloseEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetCloseEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetCloseEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamingStatus )( 
            IMFNetCloseEvent * This,
            HRESULT *phrResult);
        
        END_INTERFACE
    } IMFNetCloseEventVtbl;

    interface IMFNetCloseEvent
    {
        CONST_VTBL struct IMFNetCloseEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetCloseEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetCloseEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetCloseEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetCloseEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetCloseEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetCloseEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetCloseEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetCloseEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetCloseEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetCloseEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetCloseEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetCloseEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetCloseEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetCloseEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetCloseEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetCloseEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetCloseEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetCloseEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetCloseEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetCloseEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetCloseEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetCloseEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetCloseEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetCloseEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetCloseEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetCloseEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetCloseEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetCloseEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetCloseEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetCloseEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetCloseEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetCloseEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetCloseEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetCloseEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetCloseEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetCloseEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetCloseEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetCloseEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetCloseEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetCloseEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetCloseEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetCloseEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetCloseEvent_GetStreamingStatus(This,phrResult)	\
    ( (This)->lpVtbl -> GetStreamingStatus(This,phrResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetCloseEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0039 */
/* [local] */ 

typedef /* [public] */ struct NackReport
    {
    DWORD dwSsrc;
    DWORD dwSeqNumber;
    } 	NackReport;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0039_v0_0_s_ifspec;

#ifndef __IMFNackHandler_INTERFACE_DEFINED__
#define __IMFNackHandler_INTERFACE_DEFINED__

/* interface IMFNackHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNackHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7F6A364-168C-4965-862C-B190A1C7C5F0")
    IMFNackHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessNacks( 
            /* [size_is][in] */ NackReport *rgNacks,
            /* [in] */ DWORD cNacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSsrc( 
            /* [out] */ DWORD *pdwStreamSsrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNackSsrc( 
            /* [out] */ DWORD *pdwNackSsrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNackHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNackHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNackHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNackHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessNacks )( 
            IMFNackHandler * This,
            /* [size_is][in] */ NackReport *rgNacks,
            /* [in] */ DWORD cNacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSsrc )( 
            IMFNackHandler * This,
            /* [out] */ DWORD *pdwStreamSsrc);
        
        HRESULT ( STDMETHODCALLTYPE *GetNackSsrc )( 
            IMFNackHandler * This,
            /* [out] */ DWORD *pdwNackSsrc);
        
        END_INTERFACE
    } IMFNackHandlerVtbl;

    interface IMFNackHandler
    {
        CONST_VTBL struct IMFNackHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNackHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNackHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNackHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNackHandler_ProcessNacks(This,rgNacks,cNacks)	\
    ( (This)->lpVtbl -> ProcessNacks(This,rgNacks,cNacks) ) 

#define IMFNackHandler_GetStreamSsrc(This,pdwStreamSsrc)	\
    ( (This)->lpVtbl -> GetStreamSsrc(This,pdwStreamSsrc) ) 

#define IMFNackHandler_GetNackSsrc(This,pdwNackSsrc)	\
    ( (This)->lpVtbl -> GetNackSsrc(This,pdwNackSsrc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNackHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0040 */
/* [local] */ 

typedef /* [public] */ struct _RtcpReport
    {
    DWORD dwSsrc;
    BYTE bFraction;
    INT32 iLost;
    DWORD dwLast_seq;
    DWORD dwJitter;
    DWORD dwLsr;
    DWORD dwDlsr;
    } 	RtcpReport;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0040_v0_0_s_ifspec;

#ifndef __IMFRrHandler_INTERFACE_DEFINED__
#define __IMFRrHandler_INTERFACE_DEFINED__

/* interface IMFRrHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFRrHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B018140-4910-43f8-8FB0-FB8F62A67153")
    IMFRrHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessReport( 
            /* [in] */ RtcpReport *pRtcpReceiverReport,
            /* [out] */ DWORD *pdwStreamId,
            /* [out] */ MFPacketStatusReport *pReport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSsrc( 
            /* [out] */ DWORD *pdwStreamSsrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRrLength( 
            /* [in] */ DWORD dwRrLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFRrHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFRrHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFRrHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFRrHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessReport )( 
            IMFRrHandler * This,
            /* [in] */ RtcpReport *pRtcpReceiverReport,
            /* [out] */ DWORD *pdwStreamId,
            /* [out] */ MFPacketStatusReport *pReport);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSsrc )( 
            IMFRrHandler * This,
            /* [out] */ DWORD *pdwStreamSsrc);
        
        HRESULT ( STDMETHODCALLTYPE *SetRrLength )( 
            IMFRrHandler * This,
            /* [in] */ DWORD dwRrLength);
        
        END_INTERFACE
    } IMFRrHandlerVtbl;

    interface IMFRrHandler
    {
        CONST_VTBL struct IMFRrHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFRrHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFRrHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFRrHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFRrHandler_ProcessReport(This,pRtcpReceiverReport,pdwStreamId,pReport)	\
    ( (This)->lpVtbl -> ProcessReport(This,pRtcpReceiverReport,pdwStreamId,pReport) ) 

#define IMFRrHandler_GetStreamSsrc(This,pdwStreamSsrc)	\
    ( (This)->lpVtbl -> GetStreamSsrc(This,pdwStreamSsrc) ) 

#define IMFRrHandler_SetRrLength(This,dwRrLength)	\
    ( (This)->lpVtbl -> SetRrLength(This,dwRrLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFRrHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0041 */
/* [local] */ 

typedef /* [public] */ struct _BfrReport
    {
    DWORD dwN1;
    DWORD dwN2;
    WORD wN3;
    WORD wPD;
    WORD wNSN;
    WORD wNUN;
    DWORD dwD1;
    DWORD dwD2;
    WORD wD3;
    WORD wTD;
    } 	BfrReport;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0041_v0_0_s_ifspec;

#ifndef __IMFBfrHandler_INTERFACE_DEFINED__
#define __IMFBfrHandler_INTERFACE_DEFINED__

/* interface IMFBfrHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFBfrHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("672b333c-077b-4f68-b4b6-c116bb1f947b")
    IMFBfrHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessBfrReport( 
            /* [in] */ BfrReport *pBfrReport,
            /* [out] */ DWORD *pdwStreamId,
            /* [out] */ MFStreamBufferStatusReport *pReport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSsrc( 
            /* [out] */ DWORD *pdwStreamSsrc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFBfrHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFBfrHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFBfrHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFBfrHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessBfrReport )( 
            IMFBfrHandler * This,
            /* [in] */ BfrReport *pBfrReport,
            /* [out] */ DWORD *pdwStreamId,
            /* [out] */ MFStreamBufferStatusReport *pReport);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSsrc )( 
            IMFBfrHandler * This,
            /* [out] */ DWORD *pdwStreamSsrc);
        
        END_INTERFACE
    } IMFBfrHandlerVtbl;

    interface IMFBfrHandler
    {
        CONST_VTBL struct IMFBfrHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFBfrHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFBfrHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFBfrHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFBfrHandler_ProcessBfrReport(This,pBfrReport,pdwStreamId,pReport)	\
    ( (This)->lpVtbl -> ProcessBfrReport(This,pBfrReport,pdwStreamId,pReport) ) 

#define IMFBfrHandler_GetStreamSsrc(This,pdwStreamSsrc)	\
    ( (This)->lpVtbl -> GetStreamSsrc(This,pdwStreamSsrc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFBfrHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0042 */
/* [local] */ 

typedef /* [public] */ struct _TransportParams
    {
    DWORD dwSsrc;
    DWORD dwNackSsrc;
    DWORD dwMaxMtu;
    IPropertyStore *pSDPProps;
    IUnknown *pDataChannel;
    LPWSTR wszSharedDataChannelGuid;
    IUnknown *pFeedbackSocket;
    LPWSTR wszSharedFeedbackChannelGuid;
    LPWSTR wszSdesName;
    BYTE *pClientFeedbackAddr;
    DWORD dwClientFeedbackAddrLen;
    DWORD dwClientDataport;
    GUID *rgsExtensionGuids;
    DWORD dwNumExtensionGuids;
    } 	TransportParams;

typedef /* [public] */ struct _RtpInfo
    {
    DWORD dwStreamId;
    DWORD dwSeqNum;
    DWORD dwRtpTimestamp;
    } 	RtpInfo;

typedef /* [public] */ struct _SeekInfo
    {
    MF_SEEK_TYPE seekType;
    QWORD qwStartOffset;
    float flSpeed;
    float flScale;
    } 	SeekInfo;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0042_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0042_v0_0_s_ifspec;

#ifndef __IMFRtspSinkActivate_INTERFACE_DEFINED__
#define __IMFRtspSinkActivate_INTERFACE_DEFINED__

/* interface IMFRtspSinkActivate */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFRtspSinkActivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("032B3ADC-569B-48aa-AE08-62BCC3C5266B")
    IMFRtspSinkActivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IPropertyStore *pSessionProps,
            /* [in] */ IMFPresentationDescriptor *pPresentationDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFRtspSinkActivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFRtspSinkActivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFRtspSinkActivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFRtspSinkActivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFRtspSinkActivate * This,
            /* [in] */ IPropertyStore *pSessionProps,
            /* [in] */ IMFPresentationDescriptor *pPresentationDescriptor);
        
        END_INTERFACE
    } IMFRtspSinkActivateVtbl;

    interface IMFRtspSinkActivate
    {
        CONST_VTBL struct IMFRtspSinkActivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFRtspSinkActivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFRtspSinkActivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFRtspSinkActivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFRtspSinkActivate_Initialize(This,pSessionProps,pPresentationDescriptor)	\
    ( (This)->lpVtbl -> Initialize(This,pSessionProps,pPresentationDescriptor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFRtspSinkActivate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0043 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0043_v0_0_s_ifspec;

#ifndef __IMFNetSinkConfig_INTERFACE_DEFINED__
#define __IMFNetSinkConfig_INTERFACE_DEFINED__

/* interface IMFNetSinkConfig */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetSinkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E18A897-0FB9-44bd-B41D-D391A7FB31BE")
    IMFNetSinkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStreamSignalHandler( 
            /* [in] */ IMFStreamSignalHandler *pStreamSignalHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectStream( 
            /* [in] */ DWORD dwStreamId,
            /* [in] */ TransportParams *pProps,
            /* [out] */ IMFNackHandler **ppNackHandler,
            /* [out] */ IMFRrHandler **ppRrHandler,
            /* [out] */ IMFBfrHandler **ppBfrHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TeardownStream( 
            /* [in] */ DWORD dwStreamId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pdwStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartStreaming( 
            /* [out][in] */ SeekInfo *pSeekInfo,
            /* [size_is][out] */ RtpInfo *pRtpInfo,
            /* [out][in] */ DWORD *pdwRtpInfoCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseStreaming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAcceleration( 
            /* [in] */ DWORD dwAccelBandwidth,
            /* [in] */ DWORD dwAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSendWallClockTime( 
            /* [in] */ BOOL fSendWallClockTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnablePacing( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetSinkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetSinkConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetSinkConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetSinkConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamSignalHandler )( 
            IMFNetSinkConfig * This,
            /* [in] */ IMFStreamSignalHandler *pStreamSignalHandler);
        
        HRESULT ( STDMETHODCALLTYPE *SelectStream )( 
            IMFNetSinkConfig * This,
            /* [in] */ DWORD dwStreamId,
            /* [in] */ TransportParams *pProps,
            /* [out] */ IMFNackHandler **ppNackHandler,
            /* [out] */ IMFRrHandler **ppRrHandler,
            /* [out] */ IMFBfrHandler **ppBfrHandler);
        
        HRESULT ( STDMETHODCALLTYPE *TeardownStream )( 
            IMFNetSinkConfig * This,
            /* [in] */ DWORD dwStreamId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMFNetSinkConfig * This,
            /* [out] */ DWORD *pdwStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *StartStreaming )( 
            IMFNetSinkConfig * This,
            /* [out][in] */ SeekInfo *pSeekInfo,
            /* [size_is][out] */ RtpInfo *pRtpInfo,
            /* [out][in] */ DWORD *pdwRtpInfoCount);
        
        HRESULT ( STDMETHODCALLTYPE *PauseStreaming )( 
            IMFNetSinkConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAcceleration )( 
            IMFNetSinkConfig * This,
            /* [in] */ DWORD dwAccelBandwidth,
            /* [in] */ DWORD dwAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetSendWallClockTime )( 
            IMFNetSinkConfig * This,
            /* [in] */ BOOL fSendWallClockTime);
        
        HRESULT ( STDMETHODCALLTYPE *EnablePacing )( 
            IMFNetSinkConfig * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IMFNetSinkConfigVtbl;

    interface IMFNetSinkConfig
    {
        CONST_VTBL struct IMFNetSinkConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetSinkConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetSinkConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetSinkConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetSinkConfig_SetStreamSignalHandler(This,pStreamSignalHandler)	\
    ( (This)->lpVtbl -> SetStreamSignalHandler(This,pStreamSignalHandler) ) 

#define IMFNetSinkConfig_SelectStream(This,dwStreamId,pProps,ppNackHandler,ppRrHandler,ppBfrHandler)	\
    ( (This)->lpVtbl -> SelectStream(This,dwStreamId,pProps,ppNackHandler,ppRrHandler,ppBfrHandler) ) 

#define IMFNetSinkConfig_TeardownStream(This,dwStreamId)	\
    ( (This)->lpVtbl -> TeardownStream(This,dwStreamId) ) 

#define IMFNetSinkConfig_GetStreamCount(This,pdwStreamCount)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pdwStreamCount) ) 

#define IMFNetSinkConfig_StartStreaming(This,pSeekInfo,pRtpInfo,pdwRtpInfoCount)	\
    ( (This)->lpVtbl -> StartStreaming(This,pSeekInfo,pRtpInfo,pdwRtpInfoCount) ) 

#define IMFNetSinkConfig_PauseStreaming(This)	\
    ( (This)->lpVtbl -> PauseStreaming(This) ) 

#define IMFNetSinkConfig_SetAcceleration(This,dwAccelBandwidth,dwAccelDuration)	\
    ( (This)->lpVtbl -> SetAcceleration(This,dwAccelBandwidth,dwAccelDuration) ) 

#define IMFNetSinkConfig_SetSendWallClockTime(This,fSendWallClockTime)	\
    ( (This)->lpVtbl -> SetSendWallClockTime(This,fSendWallClockTime) ) 

#define IMFNetSinkConfig_EnablePacing(This,fEnable)	\
    ( (This)->lpVtbl -> EnablePacing(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetSinkConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0044 */
/* [local] */ 

typedef 
enum MF_LOG_TYPE
    {	LOG_V4	= 0,
	LOG_V9_CONNECT	= 1,
	LOG_V9_PLAY	= 2,
	LOG_V9_SENDEVENT	= 3
    } 	MF_LOG_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0044_v0_0_s_ifspec;

#ifndef __IMFNetLogEvent_INTERFACE_DEFINED__
#define __IMFNetLogEvent_INTERFACE_DEFINED__

/* interface IMFNetLogEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetLogEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d5ebc6b-6a6c-4f5c-8507-22c5eb1aead7")
    IMFNetLogEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLog( 
            /* [annotation][out] */ 
            __out  LPCWSTR *ppwszLog,
            /* [annotation][out] */ 
            __out  MF_LOG_TYPE *pLogType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetLogEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetLogEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetLogEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetLogEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetLogEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetLogEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetLogEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetLogEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetLogEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetLogEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetLogEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetLogEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetLogEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetLogEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetLogEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetLogEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetLogEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetLogEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetLogEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetLogEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetLogEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetLogEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetLog )( 
            IMFNetLogEvent * This,
            /* [annotation][out] */ 
            __out  LPCWSTR *ppwszLog,
            /* [annotation][out] */ 
            __out  MF_LOG_TYPE *pLogType);
        
        END_INTERFACE
    } IMFNetLogEventVtbl;

    interface IMFNetLogEvent
    {
        CONST_VTBL struct IMFNetLogEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetLogEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetLogEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetLogEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetLogEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetLogEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetLogEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetLogEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetLogEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetLogEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetLogEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetLogEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetLogEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetLogEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetLogEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetLogEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetLogEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetLogEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetLogEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetLogEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetLogEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetLogEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetLogEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetLogEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetLogEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetLogEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetLogEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetLogEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetLogEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetLogEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetLogEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetLogEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetLogEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetLogEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetLogEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetLogEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetLogEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetLogEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetLogEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetLogEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetLogEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetLogEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetLogEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetLogEvent_GetLog(This,ppwszLog,pLogType)	\
    ( (This)->lpVtbl -> GetLog(This,ppwszLog,pLogType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetLogEvent_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0045 */
/* [local] */ 

typedef struct _SDPTEMPLATE_RTPTYPE_INFO {
  DWORD cTypes;
  struct RTPTYPE {
    DWORD dwType;
    DWORD dwMediaTypeIndex;
    DWORD cbEncodingOffset;
    DWORD dwSampleRate;
    DWORD dwNumChannels;
    DWORD cbFormatOffset;
  };
  struct RTPTYPE RtpTypes[1];
} SDPTEMPLATE_RTPTYPE_INFO;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0045_v0_0_s_ifspec;

#ifndef __IMFSdpTemplate_INTERFACE_DEFINED__
#define __IMFSdpTemplate_INTERFACE_DEFINED__

/* interface IMFSdpTemplate */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFSdpTemplate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03271c24-dc86-4b41-8c47-76f9c2bf347c")
    IMFSdpTemplate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ LPCWSTR pszLanguage,
            /* [annotation][out] */ 
            __out  IMFMediaBuffer **ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindStream( 
            /* [in] */ LPCWSTR pszStreamUrl,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindStreamUrl( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  LPCWSTR *ppszStreamUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindDataStream( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwDataStreamId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSdpTemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFSdpTemplate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFSdpTemplate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFSdpTemplate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            IMFSdpTemplate * This,
            /* [in] */ LPCWSTR pszLanguage,
            /* [annotation][out] */ 
            __out  IMFMediaBuffer **ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *FindStream )( 
            IMFSdpTemplate * This,
            /* [in] */ LPCWSTR pszStreamUrl,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamId);
        
        HRESULT ( STDMETHODCALLTYPE *FindStreamUrl )( 
            IMFSdpTemplate * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  LPCWSTR *ppszStreamUrl);
        
        HRESULT ( STDMETHODCALLTYPE *FindDataStream )( 
            IMFSdpTemplate * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwDataStreamId);
        
        END_INTERFACE
    } IMFSdpTemplateVtbl;

    interface IMFSdpTemplate
    {
        CONST_VTBL struct IMFSdpTemplateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSdpTemplate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSdpTemplate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSdpTemplate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSdpTemplate_Serialize(This,pszLanguage,ppBuffer)	\
    ( (This)->lpVtbl -> Serialize(This,pszLanguage,ppBuffer) ) 

#define IMFSdpTemplate_FindStream(This,pszStreamUrl,pdwStreamId)	\
    ( (This)->lpVtbl -> FindStream(This,pszStreamUrl,pdwStreamId) ) 

#define IMFSdpTemplate_FindStreamUrl(This,dwStreamId,ppszStreamUrl)	\
    ( (This)->lpVtbl -> FindStreamUrl(This,dwStreamId,ppszStreamUrl) ) 

#define IMFSdpTemplate_FindDataStream(This,dwStreamId,pdwDataStreamId)	\
    ( (This)->lpVtbl -> FindDataStream(This,dwStreamId,pdwDataStreamId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFSdpTemplate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0046 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0046_v0_0_s_ifspec;

#ifndef __IMFNetPresentationTarget_INTERFACE_DEFINED__
#define __IMFNetPresentationTarget_INTERFACE_DEFINED__

/* interface IMFNetPresentationTarget */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetPresentationTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0B35174-11FF-43c9-9360-6DCF46DB4404")
    IMFNetPresentationTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSessionRepresentation( 
            /* [in] */ REFGUID refID,
            /* [in] */ REFIID refiid,
            /* [annotation][out] */ 
            __out  IUnknown **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWireIdFromStreamId( 
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwWireStreamId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamIdFromWireId( 
            /* [in] */ DWORD dwWireStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCacheControlFlagsToStore( 
            /* [in] */ IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCacheControlFlags( 
            /* [in] */ BOOL fCachingAllowed,
            /* [in] */ BOOL fSplittingAllowed,
            /* [in] */ DWORD dwCacheExpiration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMFMetadataProvider( 
            /* [in] */ IMFMetadataProvider *pMFMetadataProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateRepresentationFromSink( 
            /* [in] */ IMFMediaSink *pSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetPresentationTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetPresentationTarget * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetPresentationTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetPresentationTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionRepresentation )( 
            IMFNetPresentationTarget * This,
            /* [in] */ REFGUID refID,
            /* [in] */ REFIID refiid,
            /* [annotation][out] */ 
            __out  IUnknown **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetWireIdFromStreamId )( 
            IMFNetPresentationTarget * This,
            /* [in] */ DWORD dwStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwWireStreamId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamIdFromWireId )( 
            IMFNetPresentationTarget * This,
            /* [in] */ DWORD dwWireStreamId,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCacheControlFlagsToStore )( 
            IMFNetPresentationTarget * This,
            /* [in] */ IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheControlFlags )( 
            IMFNetPresentationTarget * This,
            /* [in] */ BOOL fCachingAllowed,
            /* [in] */ BOOL fSplittingAllowed,
            /* [in] */ DWORD dwCacheExpiration);
        
        HRESULT ( STDMETHODCALLTYPE *SetMFMetadataProvider )( 
            IMFNetPresentationTarget * This,
            /* [in] */ IMFMetadataProvider *pMFMetadataProvider);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateRepresentationFromSink )( 
            IMFNetPresentationTarget * This,
            /* [in] */ IMFMediaSink *pSink);
        
        END_INTERFACE
    } IMFNetPresentationTargetVtbl;

    interface IMFNetPresentationTarget
    {
        CONST_VTBL struct IMFNetPresentationTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetPresentationTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetPresentationTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetPresentationTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetPresentationTarget_GetSessionRepresentation(This,refID,refiid,ppvObject)	\
    ( (This)->lpVtbl -> GetSessionRepresentation(This,refID,refiid,ppvObject) ) 

#define IMFNetPresentationTarget_GetWireIdFromStreamId(This,dwStreamId,pdwWireStreamId)	\
    ( (This)->lpVtbl -> GetWireIdFromStreamId(This,dwStreamId,pdwWireStreamId) ) 

#define IMFNetPresentationTarget_GetStreamIdFromWireId(This,dwWireStreamId,pdwStreamId)	\
    ( (This)->lpVtbl -> GetStreamIdFromWireId(This,dwWireStreamId,pdwStreamId) ) 

#define IMFNetPresentationTarget_GetCacheControlFlagsToStore(This,pStore)	\
    ( (This)->lpVtbl -> GetCacheControlFlagsToStore(This,pStore) ) 

#define IMFNetPresentationTarget_SetCacheControlFlags(This,fCachingAllowed,fSplittingAllowed,dwCacheExpiration)	\
    ( (This)->lpVtbl -> SetCacheControlFlags(This,fCachingAllowed,fSplittingAllowed,dwCacheExpiration) ) 

#define IMFNetPresentationTarget_SetMFMetadataProvider(This,pMFMetadataProvider)	\
    ( (This)->lpVtbl -> SetMFMetadataProvider(This,pMFMetadataProvider) ) 

#define IMFNetPresentationTarget_UpdateRepresentationFromSink(This,pSink)	\
    ( (This)->lpVtbl -> UpdateRepresentationFromSink(This,pSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetPresentationTarget_INTERFACE_DEFINED__ */


#ifndef __IMFMcastConfig_INTERFACE_DEFINED__
#define __IMFMcastConfig_INTERFACE_DEFINED__

/* interface IMFMcastConfig */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMcastConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6a7beca8-ae93-49d8-b35a-6b007bf14d8d")
    IMFMcastConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMulticastUrl( 
            /* [annotation][out] */ 
            __out  LPCWSTR *ppszMulticastUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [annotation][out] */ 
            __out  IPropertyStore **ppPropStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMcastConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMcastConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMcastConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMcastConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMulticastUrl )( 
            IMFMcastConfig * This,
            /* [annotation][out] */ 
            __out  LPCWSTR *ppszMulticastUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IMFMcastConfig * This,
            /* [annotation][out] */ 
            __out  IPropertyStore **ppPropStore);
        
        END_INTERFACE
    } IMFMcastConfigVtbl;

    interface IMFMcastConfig
    {
        CONST_VTBL struct IMFMcastConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMcastConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMcastConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMcastConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMcastConfig_GetMulticastUrl(This,ppszMulticastUrl)	\
    ( (This)->lpVtbl -> GetMulticastUrl(This,ppszMulticastUrl) ) 

#define IMFMcastConfig_GetPropertyStore(This,ppPropStore)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,ppPropStore) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMcastConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0048 */
/* [local] */ 

typedef 
enum _STREAM_SIGNAL_TYPE
    {	NO_SIGNAL	= 0,
	STREAM_ERROR	= 1,
	EOS_SIGNAL	= 2,
	POLICY_CHANGE	= 3,
	NEW_PRESENTATION_SIGNAL	= 4
    } 	STREAM_SIGNAL_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0048_v0_0_s_ifspec;

#ifndef __IMFStreamSignalHandler_INTERFACE_DEFINED__
#define __IMFStreamSignalHandler_INTERFACE_DEFINED__

/* interface IMFStreamSignalHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFStreamSignalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("875D3D43-5FEE-4f37-B3D8-23454E99A4D2")
    IMFStreamSignalHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSignal( 
            STREAM_SIGNAL_TYPE dwStreamSignal,
            HRESULT hrStatus,
            IUnknown *pUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStreamSignalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStreamSignalHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStreamSignalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStreamSignalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSignal )( 
            IMFStreamSignalHandler * This,
            STREAM_SIGNAL_TYPE dwStreamSignal,
            HRESULT hrStatus,
            IUnknown *pUnknown);
        
        END_INTERFACE
    } IMFStreamSignalHandlerVtbl;

    interface IMFStreamSignalHandler
    {
        CONST_VTBL struct IMFStreamSignalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStreamSignalHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStreamSignalHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStreamSignalHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStreamSignalHandler_OnSignal(This,dwStreamSignal,hrStatus,pUnknown)	\
    ( (This)->lpVtbl -> OnSignal(This,dwStreamSignal,hrStatus,pUnknown) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStreamSignalHandler_INTERFACE_DEFINED__ */


#ifndef __IMFNetHttpPushSetup_INTERFACE_DEFINED__
#define __IMFNetHttpPushSetup_INTERFACE_DEFINED__

/* interface IMFNetHttpPushSetup */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetHttpPushSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7D06AEE5-0CC1-43a4-B79B-7ADB25067019")
    IMFNetHttpPushSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginOpenConnection( 
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOpenConnection( 
            /* [in] */ IMFAsyncResult *pResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetHttpPushSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetHttpPushSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetHttpPushSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetHttpPushSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOpenConnection )( 
            IMFNetHttpPushSetup * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndOpenConnection )( 
            IMFNetHttpPushSetup * This,
            /* [in] */ IMFAsyncResult *pResult);
        
        END_INTERFACE
    } IMFNetHttpPushSetupVtbl;

    interface IMFNetHttpPushSetup
    {
        CONST_VTBL struct IMFNetHttpPushSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetHttpPushSetup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetHttpPushSetup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetHttpPushSetup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetHttpPushSetup_BeginOpenConnection(This,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginOpenConnection(This,pCallback,pState) ) 

#define IMFNetHttpPushSetup_EndOpenConnection(This,pResult)	\
    ( (This)->lpVtbl -> EndOpenConnection(This,pResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetHttpPushSetup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0050 */
/* [local] */ 

typedef 
enum _RTPMCAST_CHANNEL_LAYOUT
    {	RTPMCAST_LAYOUT_PORT_SEQUENTIAL	= 1,
	RTPMCAST_LAYOUT_ADDRESS_SEQUENTIAL	= 2,
	RTPMCAST_LAYOUT_NON_SEQUENTIAL	= 3
    } 	RTPMCAST_CHANNEL_LAYOUT;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0050_v0_0_s_ifspec;

#ifndef __IMFLPCMSinkActivate_INTERFACE_DEFINED__
#define __IMFLPCMSinkActivate_INTERFACE_DEFINED__

/* interface IMFLPCMSinkActivate */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFLPCMSinkActivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9781e33c-d4af-4092-887c-34d58ba530f1")
    IMFLPCMSinkActivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFActivate *pByteStreamActivate,
            /* [in] */ IMFMediaType *pMediaType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFLPCMSinkActivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFLPCMSinkActivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFLPCMSinkActivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFLPCMSinkActivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFLPCMSinkActivate * This,
            /* [in] */ IMFActivate *pByteStreamActivate,
            /* [in] */ IMFMediaType *pMediaType);
        
        END_INTERFACE
    } IMFLPCMSinkActivateVtbl;

    interface IMFLPCMSinkActivate
    {
        CONST_VTBL struct IMFLPCMSinkActivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFLPCMSinkActivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFLPCMSinkActivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFLPCMSinkActivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFLPCMSinkActivate_Initialize(This,pByteStreamActivate,pMediaType)	\
    ( (This)->lpVtbl -> Initialize(This,pByteStreamActivate,pMediaType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFLPCMSinkActivate_INTERFACE_DEFINED__ */


#ifndef __IMFMPEG2SinkActivate_INTERFACE_DEFINED__
#define __IMFMPEG2SinkActivate_INTERFACE_DEFINED__

/* interface IMFMPEG2SinkActivate */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMPEG2SinkActivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30982126-392d-44a0-b426-cc250f4beda4")
    IMFMPEG2SinkActivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFActivate *pByteStreamActivate,
            /* [in] */ IMFMediaType *pAudioMediaType,
            /* [in] */ IMFMediaType *pVideoMediaType,
            /* [in] */ BOOL fPALVideo,
            /* [in] */ IMFAttributes *pSinkAttributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMPEG2SinkActivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMPEG2SinkActivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMPEG2SinkActivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMPEG2SinkActivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFMPEG2SinkActivate * This,
            /* [in] */ IMFActivate *pByteStreamActivate,
            /* [in] */ IMFMediaType *pAudioMediaType,
            /* [in] */ IMFMediaType *pVideoMediaType,
            /* [in] */ BOOL fPALVideo,
            /* [in] */ IMFAttributes *pSinkAttributes);
        
        END_INTERFACE
    } IMFMPEG2SinkActivateVtbl;

    interface IMFMPEG2SinkActivate
    {
        CONST_VTBL struct IMFMPEG2SinkActivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMPEG2SinkActivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMPEG2SinkActivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMPEG2SinkActivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMPEG2SinkActivate_Initialize(This,pByteStreamActivate,pAudioMediaType,pVideoMediaType,fPALVideo,pSinkAttributes)	\
    ( (This)->lpVtbl -> Initialize(This,pByteStreamActivate,pAudioMediaType,pVideoMediaType,fPALVideo,pSinkAttributes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMPEG2SinkActivate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0052 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0052_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0052_v0_0_s_ifspec;

#ifndef __IMFNetChannelActivate_INTERFACE_DEFINED__
#define __IMFNetChannelActivate_INTERFACE_DEFINED__

/* interface IMFNetChannelActivate */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetChannelActivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8780ed4c-a3d9-4ada-9489-023ddb3bd1d6")
    IMFNetChannelActivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFNetChannel *pNetChannel,
            /* [in] */ IMFLock *pLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceNetChannel( 
            /* [in] */ IMFNetChannel *pNewNetChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetChannelActivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetChannelActivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetChannelActivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetChannelActivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFNetChannelActivate * This,
            /* [in] */ IMFNetChannel *pNetChannel,
            /* [in] */ IMFLock *pLock);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceNetChannel )( 
            IMFNetChannelActivate * This,
            /* [in] */ IMFNetChannel *pNewNetChannel);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMFNetChannelActivate * This);
        
        END_INTERFACE
    } IMFNetChannelActivateVtbl;

    interface IMFNetChannelActivate
    {
        CONST_VTBL struct IMFNetChannelActivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetChannelActivate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetChannelActivate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetChannelActivate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetChannelActivate_Initialize(This,pNetChannel,pLock)	\
    ( (This)->lpVtbl -> Initialize(This,pNetChannel,pLock) ) 

#define IMFNetChannelActivate_ReplaceNetChannel(This,pNewNetChannel)	\
    ( (This)->lpVtbl -> ReplaceNetChannel(This,pNewNetChannel) ) 

#define IMFNetChannelActivate_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetChannelActivate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0053 */
/* [local] */ 

EXTERN_C const GUID MF_PRES_TARGET_PRES_DESC;
EXTERN_C const GUID MF_PRES_TARGET_ASF_PROFILE;
EXTERN_C const GUID MF_PRES_TARGET_ASF_HEADER;
EXTERN_C const GUID MF_PRES_TARGET_SDP_RTSP_V9;
EXTERN_C const GUID MF_PRES_TARGET_SDP_RTSP_V10;
EXTERN_C const GUID MF_PRES_TARGET_SDP_MCAST;
EXTERN_C const GUID MF_PRES_TARGET_SDP_HTTP_V10;
EXTERN_C const GUID MFNETSINK_STATISTICS;
EXTERN_C const GUID MFNETSINK_STATISTICS_SERVICE;
EXTERN_C const GUID MFNETSINK_CONFIG_SERVICE;
EXTERN_C const GUID MFNETVROOT_BASIC_STATISTICS;
EXTERN_C const GUID MFNETVROOT_STATISTICS_SERVICE;
EXTERN_C const GUID MFNETVROOT_EVENTROUTER;
EXTERN_C const GUID MFNETVROOT_DEVICEREGISTRATION;
EXTERN_C const GUID MFNETVROOT_CARDEATRANSCRYPTIONMANAGER;
EXTERN_C const GUID MFNETVROOT_TRANSCODEMANAGER;
EXTERN_C const GUID MFNETVROOT_NETSESSIONFACTORYPTR;
EXTERN_C const GUID MFNETVROOT_SERVERPROPS;
typedef 
enum _MFNETSINK_STATISTICS_IDS
    {	MFNETSINK_PACKETSSENT	= 0,
	MFNETSINK_BYTESSENT	= ( MFNETSINK_PACKETSSENT + 1 ) ,
	MFNETSINK_PACKETSSKIPPED	= ( MFNETSINK_BYTESSENT + 1 ) ,
	MFNETSINK_BYTESSKIPPED	= ( MFNETSINK_PACKETSSKIPPED + 1 ) ,
	MFNETSINK_AVGBANDWIDTHBPS	= ( MFNETSINK_BYTESSKIPPED + 1 ) ,
	MFNETSINK_CONTENTBITRATE	= ( MFNETSINK_AVGBANDWIDTHBPS + 1 ) ,
	MFNETSINK_SPEEDFACTOR	= ( MFNETSINK_CONTENTBITRATE + 1 ) ,
	MFNETSINK_ACCELERATION	= ( MFNETSINK_SPEEDFACTOR + 1 ) ,
	MFNETSINK_RESENDSREQUESTED	= ( MFNETSINK_ACCELERATION + 1 ) ,
	MFNETSINK_RESENDSSENT	= ( MFNETSINK_RESENDSREQUESTED + 1 ) ,
	MFNETSINK_REALTIMEELAPSED	= ( MFNETSINK_RESENDSSENT + 1 ) ,
	MFNETSINK_STREAMINGTIME	= ( MFNETSINK_REALTIMEELAPSED + 1 ) ,
	MFNETSINK_DATAQUEUED	= ( MFNETSINK_STREAMINGTIME + 1 ) ,
	MFNETSINK_ALLOCATEDBANDWIDTH	= ( MFNETSINK_DATAQUEUED + 1 ) ,
	MFNETSINK_LATESENDS	= ( MFNETSINK_ALLOCATEDBANDWIDTH + 1 ) 
    } 	MFNETSINK_STATISTICS_IDS;

typedef 
enum _MFNETVROOT_BASIC_STATISTICS_IDS
    {	MFNETVROOT_CONNECTEDPLAYERS	= 0,
	MFNETVROOT_STREAMINGPLAYERS	= ( MFNETVROOT_CONNECTEDPLAYERS + 1 ) ,
	MFNETVROOT_HTTPCONNECTEDPLAYERS	= ( MFNETVROOT_STREAMINGPLAYERS + 1 ) ,
	MFNETVROOT_HTTPSTREAMINGPLAYERS	= ( MFNETVROOT_HTTPCONNECTEDPLAYERS + 1 ) ,
	MFNETVROOT_RTSPCONNECTEDPLAYERS	= ( MFNETVROOT_HTTPSTREAMINGPLAYERS + 1 ) ,
	MFNETVROOT_RTSPSTREAMINGPLAYERS	= ( MFNETVROOT_RTSPCONNECTEDPLAYERS + 1 ) ,
	MFNETVROOT_QUEUELENGTH	= ( MFNETVROOT_RTSPSTREAMINGPLAYERS + 1 ) 
    } 	MFNETVROOT_BASIC_STATISTICS_IDS;

EXTERN_C const GUID MFNETCONNECTION_REMOTEIPADDRESS;
EXTERN_C const GUID MFNETCONNECTION_SSLCLIENTCERTINFO;
EXTERN_C const GUID MFNETCONNECTION_LISTENER;
EXTERN_C const GUID MFNETCONNECTION_SHARED_LOCK;
EXTERN_C const GUID MFNETCONNECTION_SHAREDFEEDBACKPORT;
EXTERN_C const GUID MFNETCONNECTION_SHAREDDATAPORT;
EXTERN_C const GUID MFNETCONNECTION_FEEDBACKSOCKET;
EXTERN_C const GUID MFNETCONNECTION_SESSIONID;
EXTERN_C const GUID MFNETCONNECTION_NETCHANNEL;
EXTERN_C const GUID MFNETCONNECTION_LAST_ERROR;
#if MFNETDLL
#define MFNETPUBLIC(func) STDAPI _##func
#else
#define MFNETPUBLIC(func) STDAPI func
#endif
#if MFNETDLL
#define MFNETPUBLIC(func) STDAPI _##func
#else
#define MFNETPUBLIC(func) STDAPI func
#endif
MFNETPUBLIC(MFCreateNetPresentationTarget)(
    IMFPresentationDescriptor *pPresentationDesc, 
    IPropertyStore *pMDEProfile,
    IUnknown ** ppTgt );
MFNETPUBLIC(MFCreateHttpSchemePlugin)(
    REFIID riid, LPVOID* ppvObject );
MFNETPUBLIC(MFCreateSecureHttpSchemePlugin)(
    REFIID riid, LPVOID* ppvObject );
MFNETPUBLIC(MFCreateUrlmonSchemePlugin)(
    REFIID riid, LPVOID* ppvObject );
MFNETPUBLIC(MFCreateDrmNetNDSchemePlugin)(
    REFIID riid, LPVOID* ppvObject );
MFNETPUBLIC(MFCreateHttpListener)(
    IMFNetListener ** ppNetListener );
MFNETPUBLIC(MFCreateDownloadHttpSession)(
    IPropertyStore * pConnectionProps,
    IMFNetVRoot * pVRoot,
    IMFNetSession ** ppNetSession );
MFNETPUBLIC(MFCreateRtspSession)(
    IPropertyStore * pConnectionProps,
    IMFNetVRoot * pVRoot,
    IMFNetSession ** ppNetSession );
MFNETPUBLIC(MFCreateNetActivate)(
    IMFMediaSink * pNetMediaSink,
    IMFActivate ** ppActivate);
MFNETPUBLIC(MFCreateMDESession)(
    LPCWSTR pwszFileName,
    LPCWSTR  wszSelectedProtocol,
    IPropertyStore * pProfileProps,
    IMDEDatapath ** ppMDEDatapath);
MFNETPUBLIC(MFCreateMDEDownloadDataPath)(
    LPCWSTR pwszFileName,
    IPropertyStore * pProfileProps,
    IMDEDatapath ** ppMDEDatapath);
MFNETPUBLIC(MFCreateMDEDownloadStream)(
    IMFByteStream* pStream,
    IPropertyStore * pProfileProps,
    IMDEDatapath ** ppMDEDatapath);
MFNETPUBLIC(MFCreateRtspSinkV10)(
    IMFMediaSink ** ppSink );
EXTERN_C const GUID NETSERVER_TCP_PACKETPAIR_PACKET;
EXTERN_C const GUID NETSERVER_UDP_PACKETPAIR_PACKET;
typedef 
enum _MF_SAMPLEEXTENSION_EOS_TYPE
    {	MF_SAMPLEEXT_EOSTYPE_NOEOS	= 0,
	MF_SAMPLEEXT_EOSTYPE_ENDOFSTREAM	= 1,
	MF_SAMPLEEXT_EOSTYPE_ENDOFSTREAMSEGMENT	= 2
    } 	MF_SAMPLEEXTENSION_EOS_TYPE;

EXTERN_C const GUID MFSampleExtension_MediatypeIndex;
EXTERN_C const GUID MFSampleExtension_TIMECODE;
EXTERN_C const GUID MFSampleExtension_EOS;
EXTERN_C const GUID MFSampleExtension_StreamTick;
EXTERN_C const GUID NETSTREAMSINK_STATUS_DATAQUEUEDINMS;
EXTERN_C const GUID NETSTREAMSINK_PACKETIZER;
EXTERN_C const GUID NETSTREAMSINK_NETCHANNEL;
EXTERN_C const GUID NETSTREAMSINK_SSRC;
EXTERN_C const GUID NETSTREAMSINK_CHANNELID;
EXTERN_C const GUID NETSTREAMSINK_NACKSSRC;
EXTERN_C const GUID NETSTREAMSINK_MAXMTU;
EXTERN_C const GUID NETSTREAMSINK_PAYLOADFORMATTYPEINFO;
EXTERN_C const GUID NETSTREAMSINK_NACKHANDLER;
EXTERN_C const GUID NETSTREAMSINK_BFRHANDLER;
EXTERN_C const GUID NETSTREAMSINK_RECEIVERREPORTHANDLER;
EXTERN_C const GUID NETSTREAMSINK_RECEIVERDATAPORT;
EXTERN_C const GUID NETSTREAMSINK_RECEIVERFEEDBACKPORT;
EXTERN_C const GUID NETSTREAMSINK_FECSTREAM;
EXTERN_C const GUID NETSTREAMSINK_FECPACKETIZER;
EXTERN_C const GUID NETSTREAMSINK_NACKPACKETIZER;
EXTERN_C const GUID NETSTREAMSINK_USINGBFR;
EXTERN_C const GUID NETSTREAMSINK_DEJITTERBUFFERSIZE;
EXTERN_C const GUID NETSTREAMSINK_CODEDDATABUFFERSIZE;
EXTERN_C const GUID NETSTREAMSINK_TARGETBUFFERDURATION;
EXTERN_C const GUID NETSTREAMSINK_BURSTPAIRENABLED;
EXTERN_C const GUID NETSTREAMSINK_DATACHANNELSTUB;
EXTERN_C const GUID NETSTREAMSINK_FEEDBACKCHANNELSTUB;
EXTERN_C const GUID NETMEDIASINK_SAMPLESWITHRTPTIMESTAMPS;
EXTERN_C const GUID MFNETLISTENER_FEEDBACKSPLITTER;
EXTERN_C const GUID MFNETLISTENER_RECEIVERREPORTSPLITTER;
EXTERN_C const GUID MFNETLISTENER_PMPSERVERCONTEXT;
EXTERN_C const GUID MFNETLISTENER_UNPROTECTED_PMPSERVERCONTEXT;
EXTERN_C const GUID MFNETVROOT_ENABLENACK;
EXTERN_C const GUID MFNETVROOT_ENABLEFEC;
EXTERN_C const GUID MFNETVROOT_ENABLEBFR;
EXTERN_C const GUID MFNETVROOT_STATISTICS;
EXTERN_C const GUID MFNETVROOT_TYPEOFSERVICE;
EXTERN_C const GUID MFNETVROOT_PORT;
EXTERN_C const GUID MFNETVROOT_IDLESESSIONTIMEOUT;
EXTERN_C const GUID MFNETVROOT_CONTENTDESCRIPTONLIMIT;
EXTERN_C const GUID MFNETVROOT_SSLCONFIGURATION;
EXTERN_C const GUID MFNETVROOT_ENABLEEDGETRAVERSAL;
EXTERN_C const PROPERTYKEY PKEY_MFNETPUSH_URL;
EXTERN_C const PROPERTYKEY PKEY_MFNETPUSH_TEMPLATEURL;
EXTERN_C const PROPERTYKEY PKEY_MFNETPUSH_AUTODESTROY;
EXTERN_C const PROPERTYKEY PKEY_MFNETPUSH_CREDENTIALMANAGER;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_ANN;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_ACC;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_HV;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_HA;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_APP;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_AL;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_AB;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_VB;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_LAYOUT;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_UNICAST_URL;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_LOG_URL;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_DOMAIN;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_SIGN_DATA;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_KEY_BLOB;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_MULTICAST_URL;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_ENABLED;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_LANGUAGE;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_BITRATE_KBPS;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_ADDRESS;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_FEC_SPAN;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_FEC_PACKETS_PER_SPAN;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_ANNOUNCEMENT_INTERVAL;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CHANNEL_ACCELERATION_RATE;
EXTERN_C const PROPERTYKEY PKEY_RTPMCAST_CONFIGURATION;
EXTERN_C const GUID MFNETSESSION_SHARED_LOCK;
EXTERN_C const GUID MFNETSESSION_LINK_BANDWIDTH;
EXTERN_C const GUID MFNETSESSION_MDE_DATAPATH;
EXTERN_C const GUID MFNETSESSION_USEQOSFORRTP;
EXTERN_C const GUID SDPBUILDER_URL;
EXTERN_C const GUID SDPBUILDER_RTPTYPE;
EXTERN_C const GUID SDPBUILDER_ENABLERTX;
EXTERN_C const GUID SDPBUILDER_ENABLERTXDUP;
EXTERN_C const GUID SDPBUILDER_RTXTIME;
EXTERN_C const GUID SDPBUILDER_ENABLEFEC;
EXTERN_C const GUID SDPBUILDER_ENABLEBFR;
EXTERN_C const GUID SDPBUILDER_BFRINTERVAL;
EXTERN_C const GUID SDPBUILDER_RTPFORMATNAME;
EXTERN_C const GUID SDPBUILDER_SSRC;
EXTERN_C const GUID SDPBUILDER_MULTICASTADDRESS;
EXTERN_C const GUID SDPBUILDER_MULTICASTPORT;
EXTERN_C const GUID SDPBUILDER_SOURCEADDRESS;
EXTERN_C const GUID SDPBUILDER_LOG_URL;
EXTERN_C const GUID SDPBUILDER_FECSPAN;
EXTERN_C const GUID SDPBUILDER_FECPACKETSPERSPAN;
EXTERN_C const GUID SDPBUILDER_SIGNPUBLICKEY;
EXTERN_C const GUID SDPBUILDER_ALLOW_CACHING;
EXTERN_C const GUID SDPBUILDER_ALLOW_SPLITTING;
EXTERN_C const GUID SDPBUILDER_CACHE_EXPIRATION;
EXTERN_C const GUID SDPBUILDER_LICENSE_RESPONSE;
EXTERN_C const GUID SDPBUILDER_LICENSE_KID;
EXTERN_C const GUID SDPBUILDER_CONTENTDESCRIPTONLIMIT;
EXTERN_C const GUID MEDIACACHE_DISK_QUOTA;
EXTERN_C const GUID MEDIACACHE_MEM_QUOTA;
EXTERN_C const GUID MEDIACACHE_TIME_QUOTA;
EXTERN_C const GUID MEDIACACHE_DISK_LOW_THRESHOLD;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_FECPARAMETERS;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_NACKPARAMETERS;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_LEAKYBUCKETPARAMETERS;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_ACCELERATIONPARAMETERS;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_RELIABLE_DELIVERY;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_RECEIVER_BUFFER_SIZE_MS;
EXTERN_C const PROPERTYKEY PKEY_MFNETRTPSTREAM_FEEDBACKINTERVAL;
EXTERN_C const PROPERTYKEY PKEY_MFNETCHFAC_SUPPORT_UNRELIABLE_DELIVERY;
EXTERN_C const PROPERTYKEY PKEY_MFNETCHFAC_SUPPORT_RELIABLE_DELIVERY;
EXTERN_C const PROPERTYKEY PKEY_MFNETCHFAC_ESTIMATED_BANDWIDTH_KBPS;
EXTERN_C const PROPERTYKEY PKEY_MFNETCHFAC_LOCAL_IP_ADDRESS;
EXTERN_C const PROPERTYKEY PKEY_MFNETCHFAC_SESSION_ID;

enum __MIDL___MIDL_itf_mfinternal_0000_0053_0001
    {	MFPID_StreamSelection_Language	= ( PID_FIRST_USABLE + 0 ) ,
	MFPID_StreamSelection_MediaType	= ( PID_FIRST_USABLE + 1 ) ,
	MFPID_StreamSelection_StreamCount	= ( PID_FIRST_USABLE + 2 ) ,
	MFPID_StreamSelection_Bitrate	= ( 0xffff + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0053_v0_0_s_ifspec;

#ifndef __IMFPersistStreamMap_INTERFACE_DEFINED__
#define __IMFPersistStreamMap_INTERFACE_DEFINED__

/* interface IMFPersistStreamMap */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFPersistStreamMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5aac5312-a48a-4688-a7a0-b78c43fef031")
    IMFPersistStreamMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapPtrToId( 
            /* [in] */ IUnknown *pUnk,
            /* [annotation][out] */ 
            __out  DWORD *pId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapIdToPtr( 
            /* [in] */ DWORD Id,
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindIdByPtr( 
            /* [in] */ IUnknown *pUnk,
            /* [annotation][out] */ 
            __out  DWORD *pId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPtrById( 
            /* [in] */ DWORD Id,
            /* [annotation][out] */ 
            __out  IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPersistStreamMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPersistStreamMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPersistStreamMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPersistStreamMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapPtrToId )( 
            IMFPersistStreamMap * This,
            /* [in] */ IUnknown *pUnk,
            /* [annotation][out] */ 
            __out  DWORD *pId);
        
        HRESULT ( STDMETHODCALLTYPE *MapIdToPtr )( 
            IMFPersistStreamMap * This,
            /* [in] */ DWORD Id,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *FindIdByPtr )( 
            IMFPersistStreamMap * This,
            /* [in] */ IUnknown *pUnk,
            /* [annotation][out] */ 
            __out  DWORD *pId);
        
        HRESULT ( STDMETHODCALLTYPE *FindPtrById )( 
            IMFPersistStreamMap * This,
            /* [in] */ DWORD Id,
            /* [annotation][out] */ 
            __out  IUnknown **ppUnk);
        
        END_INTERFACE
    } IMFPersistStreamMapVtbl;

    interface IMFPersistStreamMap
    {
        CONST_VTBL struct IMFPersistStreamMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPersistStreamMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPersistStreamMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPersistStreamMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPersistStreamMap_MapPtrToId(This,pUnk,pId)	\
    ( (This)->lpVtbl -> MapPtrToId(This,pUnk,pId) ) 

#define IMFPersistStreamMap_MapIdToPtr(This,Id,pUnk)	\
    ( (This)->lpVtbl -> MapIdToPtr(This,Id,pUnk) ) 

#define IMFPersistStreamMap_FindIdByPtr(This,pUnk,pId)	\
    ( (This)->lpVtbl -> FindIdByPtr(This,pUnk,pId) ) 

#define IMFPersistStreamMap_FindPtrById(This,Id,ppUnk)	\
    ( (This)->lpVtbl -> FindPtrById(This,Id,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPersistStreamMap_INTERFACE_DEFINED__ */


#ifndef __IMFLock_INTERFACE_DEFINED__
#define __IMFLock_INTERFACE_DEFINED__

/* interface IMFLock */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97ec2ea3-0e42-4937-97ac-9d6d328824e1")
    IMFLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            BOOL fExclusive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            BOOL fExclusive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockExclusive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockExclusive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockShared( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockShared( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Upgrade( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IMFLock * This,
            BOOL fExclusive);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IMFLock * This,
            BOOL fExclusive);
        
        HRESULT ( STDMETHODCALLTYPE *LockExclusive )( 
            IMFLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockExclusive )( 
            IMFLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockShared )( 
            IMFLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockShared )( 
            IMFLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *Upgrade )( 
            IMFLock * This);
        
        END_INTERFACE
    } IMFLockVtbl;

    interface IMFLock
    {
        CONST_VTBL struct IMFLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFLock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFLock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFLock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFLock_Lock(This,fExclusive)	\
    ( (This)->lpVtbl -> Lock(This,fExclusive) ) 

#define IMFLock_Unlock(This,fExclusive)	\
    ( (This)->lpVtbl -> Unlock(This,fExclusive) ) 

#define IMFLock_LockExclusive(This)	\
    ( (This)->lpVtbl -> LockExclusive(This) ) 

#define IMFLock_UnlockExclusive(This)	\
    ( (This)->lpVtbl -> UnlockExclusive(This) ) 

#define IMFLock_LockShared(This)	\
    ( (This)->lpVtbl -> LockShared(This) ) 

#define IMFLock_UnlockShared(This)	\
    ( (This)->lpVtbl -> UnlockShared(This) ) 

#define IMFLock_Upgrade(This)	\
    ( (This)->lpVtbl -> Upgrade(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFLock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0055 */
/* [local] */ 

STDAPI 
MFCreateLock(
    __out IMFLock ** ppLock);
STDAPI 
MFAppendCollection(
    __in IMFCollection * pDestinationCollection, 
    __in IMFCollection * pSourceCollection);
#include "mfgrl.h"
STDAPI MFCloneSample(
    IMFSample * pFrom,
    __out IMFSample ** ppTo,
    BOOL fDupBuffers );
STDAPI MFCreateWMDRMContext( 
    __out IUnknown ** ppUnkContext ); 


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0055_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0055_v0_0_s_ifspec;

#ifndef __IMFWMDRMITACreator_INTERFACE_DEFINED__
#define __IMFWMDRMITACreator_INTERFACE_DEFINED__

/* interface IMFWMDRMITACreator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMFWMDRMITACreator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABDF559F-C509-404E-A562-D30AD351E6D1")
    IMFWMDRMITACreator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateWMDRMInputTrustAuthority( 
            /* [out] */ IMFInputTrustAuthority **ppWMDRMInputTrustAuthority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFWMDRMITACreatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFWMDRMITACreator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFWMDRMITACreator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFWMDRMITACreator * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateWMDRMInputTrustAuthority )( 
            IMFWMDRMITACreator * This,
            /* [out] */ IMFInputTrustAuthority **ppWMDRMInputTrustAuthority);
        
        END_INTERFACE
    } IMFWMDRMITACreatorVtbl;

    interface IMFWMDRMITACreator
    {
        CONST_VTBL struct IMFWMDRMITACreatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFWMDRMITACreator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFWMDRMITACreator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFWMDRMITACreator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFWMDRMITACreator_CreateWMDRMInputTrustAuthority(This,ppWMDRMInputTrustAuthority)	\
    ( (This)->lpVtbl -> CreateWMDRMInputTrustAuthority(This,ppWMDRMInputTrustAuthority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFWMDRMITACreator_INTERFACE_DEFINED__ */


#ifndef __IMFTopologyPriv_INTERFACE_DEFINED__
#define __IMFTopologyPriv_INTERFACE_DEFINED__

/* interface IMFTopologyPriv */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFTopologyPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47BAE55E-80DA-4046-A454-90520B5BC9A4")
    IMFTopologyPriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumOutputs( 
            WORD *pOutputsCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutput( 
            WORD wIndex,
            /* [annotation] */ 
            __out  IMFTopologyNode **ppNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSources( 
            WORD *pSourcesCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            WORD wIndex,
            /* [annotation] */ 
            __out  IMFTopologyNode **ppNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTopologyID( 
            TOPOID llID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHash( 
            /* [annotation] */ 
            __in_bcount(cbKeySize)  unsigned char *pbKey,
            ULONG cbKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHash( 
            /* [annotation] */ 
            __deref_out_bcount(*pcbHashSize)  unsigned char **ppbCoTaskMemKey,
            /* [annotation] */ 
            __out  ULONG *pcbHashSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFTopologyPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFTopologyPriv * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFTopologyPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFTopologyPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
            IMFTopologyPriv * This,
            WORD *pOutputsCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutput )( 
            IMFTopologyPriv * This,
            WORD wIndex,
            /* [annotation] */ 
            __out  IMFTopologyNode **ppNode);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSources )( 
            IMFTopologyPriv * This,
            WORD *pSourcesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSource )( 
            IMFTopologyPriv * This,
            WORD wIndex,
            /* [annotation] */ 
            __out  IMFTopologyNode **ppNode);
        
        HRESULT ( STDMETHODCALLTYPE *SetTopologyID )( 
            IMFTopologyPriv * This,
            TOPOID llID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHash )( 
            IMFTopologyPriv * This,
            /* [annotation] */ 
            __in_bcount(cbKeySize)  unsigned char *pbKey,
            ULONG cbKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *GetHash )( 
            IMFTopologyPriv * This,
            /* [annotation] */ 
            __deref_out_bcount(*pcbHashSize)  unsigned char **ppbCoTaskMemKey,
            /* [annotation] */ 
            __out  ULONG *pcbHashSize);
        
        END_INTERFACE
    } IMFTopologyPrivVtbl;

    interface IMFTopologyPriv
    {
        CONST_VTBL struct IMFTopologyPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFTopologyPriv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFTopologyPriv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFTopologyPriv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFTopologyPriv_EnumOutputs(This,pOutputsCount)	\
    ( (This)->lpVtbl -> EnumOutputs(This,pOutputsCount) ) 

#define IMFTopologyPriv_GetOutput(This,wIndex,ppNode)	\
    ( (This)->lpVtbl -> GetOutput(This,wIndex,ppNode) ) 

#define IMFTopologyPriv_EnumSources(This,pSourcesCount)	\
    ( (This)->lpVtbl -> EnumSources(This,pSourcesCount) ) 

#define IMFTopologyPriv_GetSource(This,wIndex,ppNode)	\
    ( (This)->lpVtbl -> GetSource(This,wIndex,ppNode) ) 

#define IMFTopologyPriv_SetTopologyID(This,llID)	\
    ( (This)->lpVtbl -> SetTopologyID(This,llID) ) 

#define IMFTopologyPriv_SetHash(This,pbKey,cbKeySize)	\
    ( (This)->lpVtbl -> SetHash(This,pbKey,cbKeySize) ) 

#define IMFTopologyPriv_GetHash(This,ppbCoTaskMemKey,pcbHashSize)	\
    ( (This)->lpVtbl -> GetHash(This,ppbCoTaskMemKey,pcbHashSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFTopologyPriv_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0057 */
/* [local] */ 

typedef struct MFTOPOCONNECTOR_PARAM_TAG
    {
    DWORD cbSize;
    DWORD ConnectMethod;
    IMFTopologyNode *pUp;
    DWORD dwUpIndex;
    IMFMediaType *pUpType;
    IMFTopologyNode *pDown;
    DWORD dwDownIndex;
    IMFMediaType *pDownType;
    IMFMediaType *pErrorType;
    } 	MFTOPOCONNECTOR_PARAM;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0057_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0057_v0_0_s_ifspec;

#ifndef __IMFTopoConnector_INTERFACE_DEFINED__
#define __IMFTopoConnector_INTERFACE_DEFINED__

/* interface IMFTopoConnector */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFTopoConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE9A6158-F660-4643-B56A-DF9F7998C7CD")
    IMFTopoConnector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartLoad( 
            /* [in] */ IMFTopology *pInput,
            /* [in] */ IMFTopology *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectNodes( 
            /* [in] */ MFTOPOCONNECTOR_PARAM *pParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinishLoad( 
            /* [in] */ HRESULT hrLoad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneNodeToOutputTopology( 
            IMFTopologyNode *pNode,
            /* [annotation] */ 
            __out  IMFTopologyNode **ppDestNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveNode( 
            IMFTopologyNode *pNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformDefaults( 
            /* [in] */ IMFAttributes *pDefaultConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFTopoConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFTopoConnector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFTopoConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFTopoConnector * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartLoad )( 
            IMFTopoConnector * This,
            /* [in] */ IMFTopology *pInput,
            /* [in] */ IMFTopology *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectNodes )( 
            IMFTopoConnector * This,
            /* [in] */ MFTOPOCONNECTOR_PARAM *pParam);
        
        HRESULT ( STDMETHODCALLTYPE *FinishLoad )( 
            IMFTopoConnector * This,
            /* [in] */ HRESULT hrLoad);
        
        HRESULT ( STDMETHODCALLTYPE *CloneNodeToOutputTopology )( 
            IMFTopoConnector * This,
            IMFTopologyNode *pNode,
            /* [annotation] */ 
            __out  IMFTopologyNode **ppDestNode);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveNode )( 
            IMFTopoConnector * This,
            IMFTopologyNode *pNode);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformDefaults )( 
            IMFTopoConnector * This,
            /* [in] */ IMFAttributes *pDefaultConfig);
        
        END_INTERFACE
    } IMFTopoConnectorVtbl;

    interface IMFTopoConnector
    {
        CONST_VTBL struct IMFTopoConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFTopoConnector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFTopoConnector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFTopoConnector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFTopoConnector_StartLoad(This,pInput,pOutput)	\
    ( (This)->lpVtbl -> StartLoad(This,pInput,pOutput) ) 

#define IMFTopoConnector_ConnectNodes(This,pParam)	\
    ( (This)->lpVtbl -> ConnectNodes(This,pParam) ) 

#define IMFTopoConnector_FinishLoad(This,hrLoad)	\
    ( (This)->lpVtbl -> FinishLoad(This,hrLoad) ) 

#define IMFTopoConnector_CloneNodeToOutputTopology(This,pNode,ppDestNode)	\
    ( (This)->lpVtbl -> CloneNodeToOutputTopology(This,pNode,ppDestNode) ) 

#define IMFTopoConnector_RemoveNode(This,pNode)	\
    ( (This)->lpVtbl -> RemoveNode(This,pNode) ) 

#define IMFTopoConnector_SetTransformDefaults(This,pDefaultConfig)	\
    ( (This)->lpVtbl -> SetTransformDefaults(This,pDefaultConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFTopoConnector_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0058 */
/* [local] */ 

STDAPI MFCreateTopoConnector( 
    __in IMFComponentCreator * pCreator, 
    __out IMFTopoConnector ** ppTopoConnector ); 
EXTERN_GUID( MF_FULL_TOPO_SERVICE, 0xC0F6E2CE, 0xB802, 0x4DF2, 0xBC, 0x8D, 0xA0, 0xA6, 0x7A, 0x99, 0xC9, 0x50);


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0058_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0058_v0_0_s_ifspec;

#ifndef __IMFPersistMetadata_INTERFACE_DEFINED__
#define __IMFPersistMetadata_INTERFACE_DEFINED__

/* interface IMFPersistMetadata */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFPersistMetadata;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86C4B209-F744-4251-8A84-268AEA95934C")
    IMFPersistMetadata : public IMFMetadata
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CommitProperties( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPersistMetadataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPersistMetadata * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPersistMetadata * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPersistMetadata * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            IMFPersistMetadata * This,
            /* [in] */ LPCWSTR pwszRFC1766);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            IMFPersistMetadata * This,
            /* [out] */ LPWSTR *ppwszRFC1766);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllLanguages )( 
            IMFPersistMetadata * This,
            /* [out] */ PROPVARIANT *ppvLanguages);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IMFPersistMetadata * This,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ const PROPVARIANT *ppvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IMFPersistMetadata * This,
            /* [in] */ LPCWSTR pwszName,
            /* [out] */ PROPVARIANT *ppvValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteProperty )( 
            IMFPersistMetadata * This,
            /* [in] */ LPCWSTR pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllPropertyNames )( 
            IMFPersistMetadata * This,
            /* [out] */ PROPVARIANT *ppvNames);
        
        HRESULT ( STDMETHODCALLTYPE *CommitProperties )( 
            IMFPersistMetadata * This);
        
        END_INTERFACE
    } IMFPersistMetadataVtbl;

    interface IMFPersistMetadata
    {
        CONST_VTBL struct IMFPersistMetadataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPersistMetadata_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPersistMetadata_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPersistMetadata_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPersistMetadata_SetLanguage(This,pwszRFC1766)	\
    ( (This)->lpVtbl -> SetLanguage(This,pwszRFC1766) ) 

#define IMFPersistMetadata_GetLanguage(This,ppwszRFC1766)	\
    ( (This)->lpVtbl -> GetLanguage(This,ppwszRFC1766) ) 

#define IMFPersistMetadata_GetAllLanguages(This,ppvLanguages)	\
    ( (This)->lpVtbl -> GetAllLanguages(This,ppvLanguages) ) 

#define IMFPersistMetadata_SetProperty(This,pwszName,ppvValue)	\
    ( (This)->lpVtbl -> SetProperty(This,pwszName,ppvValue) ) 

#define IMFPersistMetadata_GetProperty(This,pwszName,ppvValue)	\
    ( (This)->lpVtbl -> GetProperty(This,pwszName,ppvValue) ) 

#define IMFPersistMetadata_DeleteProperty(This,pwszName)	\
    ( (This)->lpVtbl -> DeleteProperty(This,pwszName) ) 

#define IMFPersistMetadata_GetAllPropertyNames(This,ppvNames)	\
    ( (This)->lpVtbl -> GetAllPropertyNames(This,ppvNames) ) 


#define IMFPersistMetadata_CommitProperties(This)	\
    ( (This)->lpVtbl -> CommitProperties(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPersistMetadata_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreLanguage_INTERFACE_DEFINED__
#define __IPropertyStoreLanguage_INTERFACE_DEFINED__

/* interface IPropertyStoreLanguage */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IPropertyStoreLanguage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2281D369-36DF-4c3b-92A7-0B572C422D11")
    IPropertyStoreLanguage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLanguage( 
            /* [annotation][in] */ 
            __in  LPWSTR pwszRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [annotation][string][ref][out] */ 
            __deref_out  LPWSTR *ppwszRfc1766) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreLanguageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreLanguage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreLanguage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreLanguage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            IPropertyStoreLanguage * This,
            /* [annotation][in] */ 
            __in  LPWSTR pwszRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            IPropertyStoreLanguage * This,
            /* [annotation][string][ref][out] */ 
            __deref_out  LPWSTR *ppwszRfc1766);
        
        END_INTERFACE
    } IPropertyStoreLanguageVtbl;

    interface IPropertyStoreLanguage
    {
        CONST_VTBL struct IPropertyStoreLanguageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreLanguage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreLanguage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreLanguage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreLanguage_SetLanguage(This,pwszRfc1766)	\
    ( (This)->lpVtbl -> SetLanguage(This,pwszRfc1766) ) 

#define IPropertyStoreLanguage_GetLanguage(This,ppwszRfc1766)	\
    ( (This)->lpVtbl -> GetLanguage(This,ppwszRfc1766) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreLanguage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0060 */
/* [local] */ 

typedef 
enum _PROPERTY_ATTRIBUTE
    {	paNone	= 0,
	paValue	= ( paNone + 1 ) ,
	paName	= ( paValue + 1 ) ,
	paReadOnly	= ( paName + 1 ) ,
	paSupported	= ( paReadOnly + 1 ) ,
	paRequired	= ( paSupported + 1 ) ,
	paEnabled	= ( paRequired + 1 ) ,
	paDirty	= ( paEnabled + 1 ) ,
	paNullable	= ( paDirty + 1 ) ,
	paDefaultValue	= ( paNullable + 1 ) ,
	paMultiValued	= ( paDefaultValue + 1 ) ,
	paMaxValues	= ( paMultiValued + 1 ) ,
	paValidValues	= ( paMaxValues + 1 ) ,
	paDefaultDataType	= ( paValidValues + 1 ) ,
	paDataTypesAccepted	= ( paDefaultDataType + 1 ) ,
	paDataTypePreserved	= ( paDataTypesAccepted + 1 ) ,
	paExtendedDataType	= ( paDataTypePreserved + 1 ) ,
	paCaseSensitive	= ( paExtendedDataType + 1 ) ,
	paCasePreserved	= ( paCaseSensitive + 1 ) ,
	paMaxTextLength	= ( paCasePreserved + 1 ) ,
	paTextFormat	= ( paMaxTextLength + 1 ) ,
	paTextEncoding	= ( paTextFormat + 1 ) ,
	paMinValue	= ( paTextEncoding + 1 ) ,
	paMaxValue	= ( paMinValue + 1 ) ,
	paStepValue	= ( paMaxValue + 1 ) ,
	paIntegerOnly	= ( paStepValue + 1 ) ,
	paUnsignedOnly	= ( paIntegerOnly + 1 ) ,
	paEnumeration	= ( paUnsignedOnly + 1 ) ,
	paLanguageAware	= ( paEnumeration + 1 ) ,
	paLanguage	= ( paLanguageAware + 1 ) ,
	paLanguagesSupported	= ( paLanguage + 1 ) ,
	paLanguagesAvailable	= ( paLanguagesSupported + 1 ) ,
	paFormatCode	= ( paLanguagesAvailable + 1 ) ,
	paFormatName	= ( paFormatCode + 1 ) ,
	paWellKnown	= ( paFormatName + 1 ) ,
	paComputed	= ( paWellKnown + 1 ) ,
	paOriginator	= ( paComputed + 1 ) ,
	paMultipleAccess	= ( paOriginator + 1 ) ,
	paSigned	= ( paMultipleAccess + 1 ) ,
	paProtected	= ( paSigned + 1 ) ,
	paShortName	= ( paProtected + 1 ) ,
	paLongName	= ( paShortName + 1 ) ,
	paToolTip	= ( paLongName + 1 ) 
    } 	PROPERTY_ATTRIBUTE;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0060_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0060_v0_0_s_ifspec;

#ifndef __IPropertyAdvanced_INTERFACE_DEFINED__
#define __IPropertyAdvanced_INTERFACE_DEFINED__

/* interface IPropertyAdvanced */
/* [local][unique][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropertyAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("166235FF-C550-4c46-8F0B-457FA3939B0F")
    IPropertyAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [annotation][out] */ 
            __out  PROPERTYKEY *pKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD idxValue,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ DWORD idxValue,
            /* [in] */ const PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [in] */ DWORD idxValue,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertValue( 
            /* [in] */ DWORD idxValue,
            /* [in] */ const PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ DWORD idxValue,
            /* [annotation][out] */ 
            __out  DWORD *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeAt( 
            /* [in] */ DWORD idxValue,
            /* [in] */ DWORD idxAttr,
            /* [annotation][out] */ 
            __out  PROPERTY_ATTRIBUTE *pattr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ DWORD idxValue,
            /* [in] */ PROPERTY_ATTRIBUTE attr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ DWORD idxValue,
            /* [in] */ PROPERTY_ATTRIBUTE attr,
            /* [in] */ const PROPVARIANT *pvarAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedAttribute( 
            /* [in] */ DWORD idxValue,
            /* [in] */ LPCWSTR pwszAttr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamedAttribute( 
            /* [in] */ DWORD idxValue,
            /* [in] */ LPCWSTR pwszAttr,
            /* [in] */ const PROPVARIANT *pvarAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeID( 
            /* [in] */ DWORD idxValue,
            /* [in] */ DWORD idxAttr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarAttrID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetKey )( 
            IPropertyAdvanced * This,
            /* [annotation][out] */ 
            __out  PROPERTYKEY *pKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ const PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValue )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *InsertValue )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ const PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [annotation][out] */ 
            __out  DWORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeAt )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ DWORD idxAttr,
            /* [annotation][out] */ 
            __out  PROPERTY_ATTRIBUTE *pattr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvName);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ PROPERTY_ATTRIBUTE attr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarAttr);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ PROPERTY_ATTRIBUTE attr,
            /* [in] */ const PROPVARIANT *pvarAttr);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedAttribute )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ LPCWSTR pwszAttr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarAttr);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamedAttribute )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ LPCWSTR pwszAttr,
            /* [in] */ const PROPVARIANT *pvarAttr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeID )( 
            IPropertyAdvanced * This,
            /* [in] */ DWORD idxValue,
            /* [in] */ DWORD idxAttr,
            /* [annotation][out] */ 
            __out  PROPVARIANT *pvarAttrID);
        
        END_INTERFACE
    } IPropertyAdvancedVtbl;

    interface IPropertyAdvanced
    {
        CONST_VTBL struct IPropertyAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyAdvanced_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyAdvanced_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyAdvanced_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyAdvanced_GetKey(This,pKey)	\
    ( (This)->lpVtbl -> GetKey(This,pKey) ) 

#define IPropertyAdvanced_GetValue(This,idxValue,pvarValue)	\
    ( (This)->lpVtbl -> GetValue(This,idxValue,pvarValue) ) 

#define IPropertyAdvanced_SetValue(This,idxValue,pvarValue)	\
    ( (This)->lpVtbl -> SetValue(This,idxValue,pvarValue) ) 

#define IPropertyAdvanced_RemoveValue(This,idxValue,pvarValue)	\
    ( (This)->lpVtbl -> RemoveValue(This,idxValue,pvarValue) ) 

#define IPropertyAdvanced_InsertValue(This,idxValue,pvarValue)	\
    ( (This)->lpVtbl -> InsertValue(This,idxValue,pvarValue) ) 

#define IPropertyAdvanced_GetAttributeCount(This,idxValue,pcAttributes)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,idxValue,pcAttributes) ) 

#define IPropertyAdvanced_GetAttributeAt(This,idxValue,idxAttr,pattr,pvName)	\
    ( (This)->lpVtbl -> GetAttributeAt(This,idxValue,idxAttr,pattr,pvName) ) 

#define IPropertyAdvanced_GetAttribute(This,idxValue,attr,pvarAttr)	\
    ( (This)->lpVtbl -> GetAttribute(This,idxValue,attr,pvarAttr) ) 

#define IPropertyAdvanced_SetAttribute(This,idxValue,attr,pvarAttr)	\
    ( (This)->lpVtbl -> SetAttribute(This,idxValue,attr,pvarAttr) ) 

#define IPropertyAdvanced_GetNamedAttribute(This,idxValue,pwszAttr,pvarAttr)	\
    ( (This)->lpVtbl -> GetNamedAttribute(This,idxValue,pwszAttr,pvarAttr) ) 

#define IPropertyAdvanced_SetNamedAttribute(This,idxValue,pwszAttr,pvarAttr)	\
    ( (This)->lpVtbl -> SetNamedAttribute(This,idxValue,pwszAttr,pvarAttr) ) 

#define IPropertyAdvanced_GetAttributeID(This,idxValue,idxAttr,pvarAttrID)	\
    ( (This)->lpVtbl -> GetAttributeID(This,idxValue,idxAttr,pvarAttrID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyAdvanced_INTERFACE_DEFINED__ */


#ifndef __IEnumProperty_INTERFACE_DEFINED__
#define __IEnumProperty_INTERFACE_DEFINED__

/* interface IEnumProperty */
/* [local][unique][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B861C84-73C4-41ff-B65E-008AA2AFE0EC")
    IEnumProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cKeys,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(cKeys, *pcKeysFetched)  PROPERTYKEY *pKeys,
            /* [annotation][out] */ 
            __out_opt  ULONG *pcKeysFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [annotation][out] */ 
            __out  IEnumProperty **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumProperty * This,
            /* [in] */ ULONG cKeys,
            /* [annotation][size_is][out] */ 
            __out_ecount_part(cKeys, *pcKeysFetched)  PROPERTYKEY *pKeys,
            /* [annotation][out] */ 
            __out_opt  ULONG *pcKeysFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumProperty * This,
            /* [in] */ ULONG cKeys);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumProperty * This,
            /* [annotation][out] */ 
            __out  IEnumProperty **ppEnum);
        
        END_INTERFACE
    } IEnumPropertyVtbl;

    interface IEnumProperty
    {
        CONST_VTBL struct IEnumPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumProperty_Next(This,cKeys,pKeys,pcKeysFetched)	\
    ( (This)->lpVtbl -> Next(This,cKeys,pKeys,pcKeysFetched) ) 

#define IEnumProperty_Skip(This,cKeys)	\
    ( (This)->lpVtbl -> Skip(This,cKeys) ) 

#define IEnumProperty_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumProperty_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumProperty_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0062 */
/* [local] */ 

EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY   PSA_KEY_STORE        = { { 0x1d1dc658, 0x68f8, 0x4bb5, { 0x8f, 0xb5, 0x5c, 0x97, 0x8d, 0x25, 0x3d, 0x6d } }, 0x00000001 };
EXTERN_C const DECLSPEC_SELECTANY DWORD         PSA_VAL_APPEND       = ( (DWORD) -1 );
EXTERN_C const DECLSPEC_SELECTANY DWORD         PSA_VAL_PROPERTY     = ( (DWORD) -2 );


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0062_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0062_v0_0_s_ifspec;

#ifndef __IPropertyStoreAdvanced_INTERFACE_DEFINED__
#define __IPropertyStoreAdvanced_INTERFACE_DEFINED__

/* interface IPropertyStoreAdvanced */
/* [local][unique][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A2C53AA-A615-43b0-AF26-F79DAF9303E6")
    IPropertyStoreAdvanced : public IPropertyStore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenProperty( 
            /* [in] */ const PROPERTYKEY *pKey,
            /* [annotation][out] */ 
            __out  IPropertyAdvanced **ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyEnumerator( 
            /* [annotation][out] */ 
            __out  IEnumProperty **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyStoreAdvanced * This,
            /* [out] */ DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyStoreAdvanced * This,
            /* [in] */ DWORD iProp,
            /* [out] */ PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyStoreAdvanced * This,
            /* [in] */ REFPROPERTYKEY key,
            /* [out] */ PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPropertyStoreAdvanced * This,
            /* [in] */ REFPROPERTYKEY key,
            /* [in] */ REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStoreAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenProperty )( 
            IPropertyStoreAdvanced * This,
            /* [in] */ const PROPERTYKEY *pKey,
            /* [annotation][out] */ 
            __out  IPropertyAdvanced **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyEnumerator )( 
            IPropertyStoreAdvanced * This,
            /* [annotation][out] */ 
            __out  IEnumProperty **ppEnum);
        
        END_INTERFACE
    } IPropertyStoreAdvancedVtbl;

    interface IPropertyStoreAdvanced
    {
        CONST_VTBL struct IPropertyStoreAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreAdvanced_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreAdvanced_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreAdvanced_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreAdvanced_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStoreAdvanced_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStoreAdvanced_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStoreAdvanced_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStoreAdvanced_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IPropertyStoreAdvanced_OpenProperty(This,pKey,ppProperty)	\
    ( (This)->lpVtbl -> OpenProperty(This,pKey,ppProperty) ) 

#define IPropertyStoreAdvanced_CreatePropertyEnumerator(This,ppEnum)	\
    ( (This)->lpVtbl -> CreatePropertyEnumerator(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreAdvanced_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0063 */
/* [local] */ 

//
// Component Info IDs
//
DEFINE_GUID( MFComponentID_ASFMediaSource,         0x60b00001, 0x55b6, 0x4ebf, 0x88, 0xc6, 0x98, 0xde, 0x80, 0xd7, 0x7a, 0x20 );
DEFINE_GUID( MFComponentID_ASFMediaSink,           0x60b00002, 0x55b6, 0x4ebf, 0x88, 0xc6, 0x98, 0xde, 0x80, 0xd7, 0x7a, 0x20 );
DEFINE_GUID( MFComponentID_MP3MediaSource,         0x60b00003, 0x55b6, 0x4ebf, 0x88, 0xc6, 0x98, 0xde, 0x80, 0xd7, 0x7a, 0x20 );
DEFINE_GUID( MFComponentID_MP3MediaSink,           0x60b00004, 0x55b6, 0x4ebf, 0x88, 0xc6, 0x98, 0xde, 0x80, 0xd7, 0x7a, 0x20 );
DEFINE_GUID( MFComponentID_NetworkMediaSource,     0x60b00005, 0x55b6, 0x4ebf, 0x88, 0xc6, 0x98, 0xde, 0x80, 0xd7, 0x7a, 0x20 );
DEFINE_GUID( MFComponentID_LPCMMediaSource,        0x60b00006, 0x55b6, 0x4ebf, 0x88, 0xc6, 0x98, 0xde, 0x80, 0xd7, 0x7a, 0x20 );
//
// Component Info Roles
//
DEFINE_GUID( MFComponentRole_MediaSource,          0xcd180001, 0x2353, 0x480f, 0x8c, 0x34, 0x17, 0xdc, 0x09, 0xc4, 0x9e, 0x0f );
DEFINE_GUID( MFComponentRole_MediaSink,            0xcd180002, 0x2353, 0x480f, 0x8c, 0x34, 0x17, 0xdc, 0x09, 0xc4, 0x9e, 0x0f );
//
// Initialize and populate a PROPVARIANT from an uninitialized PROPVARIANT
//   cbValue is required for VT_BLOB only and optional for other VARTYPES
// If cbValue is zero for VT_BOOL then pValue is assumed to point to a BOOL
//
EXTERN_C HRESULT STDAPICALLTYPE CreatePropVariant(
        __out PROPVARIANT *pv,
        VARTYPE vt,
        __in_bcount(cbValue) const void * pValue,
        DWORD cbValue
        );

#ifndef UNDER_CE
EXTERN_C HRESULT STDAPICALLTYPE DestroyPropVariant(
        __inout PROPVARIANT *pv
        );
#endif // !UNDER_CE

EXTERN_C HRESULT STDAPICALLTYPE CopyPropVariant(
        __out PROPVARIANT *pvDest,
        const PROPVARIANT *pvSrc,
        VARTYPE vtDest
        );

EXTERN_C HRESULT STDAPICALLTYPE ConvertPropVariant(
        __inout PROPVARIANT *pv,
        VARTYPE vt
        );

//
// Extract data from a PROPVARIANT
//
EXTERN_C HRESULT STDAPICALLTYPE ExtractPropVariant(
        __in PROPVARIANT *pv,
        __out_bcount_part(*pcbValue, *pcbValue) void * pValue,
        __inout DWORD * pcbValue
        );

EXTERN_C HRESULT STDAPICALLTYPE AppendPropVariant(
        __inout PROPVARIANT *pvDest,
        const PROPVARIANT *pvSrc
        );

EXTERN_C HRESULT STDAPICALLTYPE CreatePropertyStore(
        __out IPropertyStore **ppStore
        );

EXTERN_C HRESULT STDAPICALLTYPE CopyPropertyStore(
        REFGUID guidFMTIDToCopy,
        IPropertyStore *pStoreDest,
        IPropertyStore *pStoreSrc
        );

EXTERN_C HRESULT STDAPICALLTYPE MergePropertyStore (
        IPropertyStore *pStoreDest,
        IPropertyStore *pStoreSrc,
        int iOperation
        );

EXTERN_C  const GUID MFMediaType_Interleaved;
EXTERN_C  const GUID MFMediaType_Stream;
EXTERN_C  const GUID MFMediaType_Line21;
EXTERN_C  const GUID MFMediaType_SMX;

EXTERN_C const GUID MFStreamFormat_MPEG2Transport;


EXTERN_C const GUID MFFormatNone;
EXTERN_C const GUID MFFormatVideoInfo;
EXTERN_C const GUID MFFormatVideoInfo2;
EXTERN_C const GUID MFFormatWaveFormatEx;
EXTERN_C const GUID MFFormatMPEGVideo;
EXTERN_C const GUID MFFormatDvInfo;


EXTERN_C const GUID MFPROTECTION_WMDRMV1;
EXTERN_C const GUID MFPROTECTION_WMDRMV7;
EXTERN_C const GUID MFPROTECTION_WMDRMV7ForDevice;

STDAPI MFStreamDescriptorProtectMediaType( 
            /* [in] */ IMFStreamDescriptor * pSD,
            /* [in] */ const GUID* pguidProtectionType);
typedef /* [public] */ struct _MFNETIOBUFFER
    {
    BYTE *pbBuf;
    DWORD cbBuf;
    BOOL fEndOfPacket;
    } 	MFNETIOBUFFER;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0063_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0063_v0_0_s_ifspec;

#ifndef __IMFNetChannel_INTERFACE_DEFINED__
#define __IMFNetChannel_INTERFACE_DEFINED__

/* interface IMFNetChannel */
/* [local][uuid][object] */ 


enum CHANNELOPTIONS
    {	SupportsReliableDelivery	= 0,
	TypeOfService	= ( SupportsReliableDelivery + 1 ) ,
	LastChannelOption	= ( TypeOfService + 1 ) 
    } ;

EXTERN_C const IID IID_IMFNetChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A990F0FA-60BB-454b-A3BC-B4FB11054697")
    IMFNetChannel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginSend( 
            /* [in] */ BYTE *pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [annotation][in] */ 
            __out  IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSend( 
            /* [in] */ IMFAsyncResult *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMultipleSend( 
            /* [annotation][in] */ 
            __in_ecount(nBuffers)  MFNETIOBUFFER *pBuffers,
            /* [in] */ DWORD nBuffers,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMultipleSend( 
            /* [in] */ IMFAsyncResult *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginReceive( 
            /* [annotation][in] */ 
            __bcount(cbBuffer)  BYTE *pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndReceive( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [in] */ DWORD *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [in] */ DWORD Id,
            /* [annotation][size_is][out] */ 
            __out_bcount_part(*pcbVal, *pcbVal)  BYTE *pbVal,
            /* [annotation][out][in] */ 
            __inout  DWORD *pcbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ DWORD Id,
            /* [annotation][size_is][in] */ 
            __in_bcount(cbVal)  BYTE *pbVal,
            /* [in] */ DWORD cbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetChannel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetChannel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetChannel * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginSend )( 
            IMFNetChannel * This,
            /* [in] */ BYTE *pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [annotation][in] */ 
            __out  IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndSend )( 
            IMFNetChannel * This,
            /* [in] */ IMFAsyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMultipleSend )( 
            IMFNetChannel * This,
            /* [annotation][in] */ 
            __in_ecount(nBuffers)  MFNETIOBUFFER *pBuffers,
            /* [in] */ DWORD nBuffers,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndMultipleSend )( 
            IMFNetChannel * This,
            /* [in] */ IMFAsyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *BeginReceive )( 
            IMFNetChannel * This,
            /* [annotation][in] */ 
            __bcount(cbBuffer)  BYTE *pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndReceive )( 
            IMFNetChannel * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [in] */ DWORD *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMFNetChannel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptions )( 
            IMFNetChannel * This,
            /* [in] */ DWORD Id,
            /* [annotation][size_is][out] */ 
            __out_bcount_part(*pcbVal, *pcbVal)  BYTE *pbVal,
            /* [annotation][out][in] */ 
            __inout  DWORD *pcbVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptions )( 
            IMFNetChannel * This,
            /* [in] */ DWORD Id,
            /* [annotation][size_is][in] */ 
            __in_bcount(cbVal)  BYTE *pbVal,
            /* [in] */ DWORD cbVal);
        
        END_INTERFACE
    } IMFNetChannelVtbl;

    interface IMFNetChannel
    {
        CONST_VTBL struct IMFNetChannelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetChannel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetChannel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetChannel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetChannel_BeginSend(This,pBuffer,cbBuffer,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginSend(This,pBuffer,cbBuffer,pCallback,pState) ) 

#define IMFNetChannel_EndSend(This,pResult)	\
    ( (This)->lpVtbl -> EndSend(This,pResult) ) 

#define IMFNetChannel_BeginMultipleSend(This,pBuffers,nBuffers,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginMultipleSend(This,pBuffers,nBuffers,pCallback,pState) ) 

#define IMFNetChannel_EndMultipleSend(This,pResult)	\
    ( (This)->lpVtbl -> EndMultipleSend(This,pResult) ) 

#define IMFNetChannel_BeginReceive(This,pBuffer,cbBuffer,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginReceive(This,pBuffer,cbBuffer,pCallback,pState) ) 

#define IMFNetChannel_EndReceive(This,pResult,pcbRead)	\
    ( (This)->lpVtbl -> EndReceive(This,pResult,pcbRead) ) 

#define IMFNetChannel_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IMFNetChannel_GetOptions(This,Id,pbVal,pcbVal)	\
    ( (This)->lpVtbl -> GetOptions(This,Id,pbVal,pcbVal) ) 

#define IMFNetChannel_SetOptions(This,Id,pbVal,cbVal)	\
    ( (This)->lpVtbl -> SetOptions(This,Id,pbVal,cbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetChannel_INTERFACE_DEFINED__ */


#ifndef __IMFNetHeaderCollection_INTERFACE_DEFINED__
#define __IMFNetHeaderCollection_INTERFACE_DEFINED__

/* interface IMFNetHeaderCollection */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetHeaderCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8e2f2314-0036-4f47-b6fd-b86c67ec1ab3")
    IMFNetHeaderCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD nIndex,
            /* [annotation][out] */ 
            __deref_out_ecount(*pcchVal)  LPCWSTR *ppszVal,
            /* [annotation][out] */ 
            __out  DWORD *pcchVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetString( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ LPCWSTR pszVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLong( 
            /* [in] */ LPCWSTR pszName,
            /* [annotation][out] */ 
            __out  long *plVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLong( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ long lVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnknown( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ REFIID riid,
            /* [annotation][out] */ 
            __out  void **ppVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnknown( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ IUnknown *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetHeaderCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetHeaderCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetHeaderCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetHeaderCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetHeaderCollection * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD nIndex,
            /* [annotation][out] */ 
            __deref_out_ecount(*pcchVal)  LPCWSTR *ppszVal,
            /* [annotation][out] */ 
            __out  DWORD *pcchVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetHeaderCollection * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ LPCWSTR pszVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLong )( 
            IMFNetHeaderCollection * This,
            /* [in] */ LPCWSTR pszName,
            /* [annotation][out] */ 
            __out  long *plVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetLong )( 
            IMFNetHeaderCollection * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ long lVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetHeaderCollection * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ REFIID riid,
            /* [annotation][out] */ 
            __out  void **ppVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetHeaderCollection * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ IUnknown *pVal);
        
        END_INTERFACE
    } IMFNetHeaderCollectionVtbl;

    interface IMFNetHeaderCollection
    {
        CONST_VTBL struct IMFNetHeaderCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetHeaderCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetHeaderCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetHeaderCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetHeaderCollection_GetString(This,pszName,nIndex,ppszVal,pcchVal)	\
    ( (This)->lpVtbl -> GetString(This,pszName,nIndex,ppszVal,pcchVal) ) 

#define IMFNetHeaderCollection_SetString(This,pszName,pszVal)	\
    ( (This)->lpVtbl -> SetString(This,pszName,pszVal) ) 

#define IMFNetHeaderCollection_GetLong(This,pszName,plVal)	\
    ( (This)->lpVtbl -> GetLong(This,pszName,plVal) ) 

#define IMFNetHeaderCollection_SetLong(This,pszName,lVal)	\
    ( (This)->lpVtbl -> SetLong(This,pszName,lVal) ) 

#define IMFNetHeaderCollection_GetUnknown(This,pszName,riid,ppVal)	\
    ( (This)->lpVtbl -> GetUnknown(This,pszName,riid,ppVal) ) 

#define IMFNetHeaderCollection_SetUnknown(This,pszName,pVal)	\
    ( (This)->lpVtbl -> SetUnknown(This,pszName,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetHeaderCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0065 */
/* [local] */ 

STDAPI GetMFSupportedPlaybackDLNAProfiles( 
            __in HKEY hkeyDLNAProfileIDRoot,
            __out PROPVARIANT* ppvDLNAProfileArray);
STDAPI GetSupportedMIMETypeBasedOnPlaybackDLNAProfile( 
            __in HKEY hkeyDLNAProfileIDRoot,
            __in LPCWSTR pwszDLNAProfile,
            __out PROPVARIANT* ppvMIMETypeArray);





extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0065_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0065_v0_0_s_ifspec;

#ifndef __IMFNetListener_INTERFACE_DEFINED__
#define __IMFNetListener_INTERFACE_DEFINED__

/* interface IMFNetListener */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c4c3fce-a6f3-4b43-8eec-c7ea60c54887")
    IMFNetListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartListening( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopListening( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddURL( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ IMFNetVRoot *pVRoot,
            /* [in] */ IMFNetSessionFactory *pNetSessionFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveURL( 
            /* [in] */ LPCWSTR pwszURL,
            /* [optional][out] */ IMFNetVRoot **ppVRoot,
            /* [optional][out] */ IMFNetSessionFactory **ppNetSessionFactory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetListener * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetListener * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFNetListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartListening )( 
            IMFNetListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *StopListening )( 
            IMFNetListener * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddURL )( 
            IMFNetListener * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ IMFNetVRoot *pVRoot,
            /* [in] */ IMFNetSessionFactory *pNetSessionFactory);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveURL )( 
            IMFNetListener * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [optional][out] */ IMFNetVRoot **ppVRoot,
            /* [optional][out] */ IMFNetSessionFactory **ppNetSessionFactory);
        
        END_INTERFACE
    } IMFNetListenerVtbl;

    interface IMFNetListener
    {
        CONST_VTBL struct IMFNetListenerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetListener_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetListener_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetListener_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetListener_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IMFNetListener_StartListening(This)	\
    ( (This)->lpVtbl -> StartListening(This) ) 

#define IMFNetListener_StopListening(This)	\
    ( (This)->lpVtbl -> StopListening(This) ) 

#define IMFNetListener_AddURL(This,pwszURL,pVRoot,pNetSessionFactory)	\
    ( (This)->lpVtbl -> AddURL(This,pwszURL,pVRoot,pNetSessionFactory) ) 

#define IMFNetListener_RemoveURL(This,pwszURL,ppVRoot,ppNetSessionFactory)	\
    ( (This)->lpVtbl -> RemoveURL(This,pwszURL,ppVRoot,ppNetSessionFactory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetListener_INTERFACE_DEFINED__ */


#ifndef __IMFNetSessionFactory_INTERFACE_DEFINED__
#define __IMFNetSessionFactory_INTERFACE_DEFINED__

/* interface IMFNetSessionFactory */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetSessionFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19be6242-215d-4916-b2ae-3c86a9117348")
    IMFNetSessionFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateNetSession( 
            /* [in] */ IPropertyStore *pConn,
            /* [in] */ IMFNetVRoot *pVRoot,
            /* [in] */ REFIID riidSession,
            /* [annotation][out] */ 
            __out  void **ppNetSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetSessionFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetSessionFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetSessionFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetSessionFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNetSession )( 
            IMFNetSessionFactory * This,
            /* [in] */ IPropertyStore *pConn,
            /* [in] */ IMFNetVRoot *pVRoot,
            /* [in] */ REFIID riidSession,
            /* [annotation][out] */ 
            __out  void **ppNetSession);
        
        END_INTERFACE
    } IMFNetSessionFactoryVtbl;

    interface IMFNetSessionFactory
    {
        CONST_VTBL struct IMFNetSessionFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetSessionFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetSessionFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetSessionFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetSessionFactory_CreateNetSession(This,pConn,pVRoot,riidSession,ppNetSession)	\
    ( (This)->lpVtbl -> CreateNetSession(This,pConn,pVRoot,riidSession,ppNetSession) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetSessionFactory_INTERFACE_DEFINED__ */


#ifndef __IMFNetVRoot_INTERFACE_DEFINED__
#define __IMFNetVRoot_INTERFACE_DEFINED__

/* interface IMFNetVRoot */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetVRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c4c3fcd-a6f3-4b43-8eec-c7ea60c54887")
    IMFNetVRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterDelegate( 
            /* [in] */ MediaEventType NetControlEventType,
            /* [in] */ IMFNetEventHandler *pDelegate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDelegate( 
            /* [in] */ MediaEventType NetControlEventType,
            /* [out] */ IMFNetEventHandler **ppDelegate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetVRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetVRoot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetVRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetVRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDelegate )( 
            IMFNetVRoot * This,
            /* [in] */ MediaEventType NetControlEventType,
            /* [in] */ IMFNetEventHandler *pDelegate);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelegate )( 
            IMFNetVRoot * This,
            /* [in] */ MediaEventType NetControlEventType,
            /* [out] */ IMFNetEventHandler **ppDelegate);
        
        END_INTERFACE
    } IMFNetVRootVtbl;

    interface IMFNetVRoot
    {
        CONST_VTBL struct IMFNetVRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetVRoot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetVRoot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetVRoot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetVRoot_RegisterDelegate(This,NetControlEventType,pDelegate)	\
    ( (This)->lpVtbl -> RegisterDelegate(This,NetControlEventType,pDelegate) ) 

#define IMFNetVRoot_GetDelegate(This,NetControlEventType,ppDelegate)	\
    ( (This)->lpVtbl -> GetDelegate(This,NetControlEventType,ppDelegate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetVRoot_INTERFACE_DEFINED__ */


#ifndef __IMFNetUrlTransformEvent_INTERFACE_DEFINED__
#define __IMFNetUrlTransformEvent_INTERFACE_DEFINED__

/* interface IMFNetUrlTransformEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetUrlTransformEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b0a495af-a4a3-4b28-b15b-c98dc2f4b092")
    IMFNetUrlTransformEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLogicalUrl( 
            /* [annotation][out] */ 
            __out  LPCWSTR *ppwszLogicalURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformedUrl( 
            /* [in] */ LPCWSTR pwszTransformedURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformedUrl( 
            /* [annotation][in] */ 
            __out  LPCWSTR *ppwszTransformedURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetByteStream( 
            /* [in] */ IMFByteStream *pStream,
            /* [in] */ IPropertyStore *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteStream( 
            /* [annotation][out] */ 
            __out  IMFByteStream **ppStream,
            /* [annotation][out] */ 
            __out  IPropertyStore **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageBody( 
            /* [annotation][out] */ 
            __out  BSTR *pbstrBody) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetUrlTransformEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetUrlTransformEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetUrlTransformEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetUrlTransformEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetUrlTransformEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetUrlTransformEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetUrlTransformEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetUrlTransformEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetUrlTransformEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetUrlTransformEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogicalUrl )( 
            IMFNetUrlTransformEvent * This,
            /* [annotation][out] */ 
            __out  LPCWSTR *ppwszLogicalURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformedUrl )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ LPCWSTR pwszTransformedURL);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformedUrl )( 
            IMFNetUrlTransformEvent * This,
            /* [annotation][in] */ 
            __out  LPCWSTR *ppwszTransformedURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetByteStream )( 
            IMFNetUrlTransformEvent * This,
            /* [in] */ IMFByteStream *pStream,
            /* [in] */ IPropertyStore *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteStream )( 
            IMFNetUrlTransformEvent * This,
            /* [annotation][out] */ 
            __out  IMFByteStream **ppStream,
            /* [annotation][out] */ 
            __out  IPropertyStore **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageBody )( 
            IMFNetUrlTransformEvent * This,
            /* [annotation][out] */ 
            __out  BSTR *pbstrBody);
        
        END_INTERFACE
    } IMFNetUrlTransformEventVtbl;

    interface IMFNetUrlTransformEvent
    {
        CONST_VTBL struct IMFNetUrlTransformEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetUrlTransformEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetUrlTransformEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetUrlTransformEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetUrlTransformEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetUrlTransformEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetUrlTransformEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetUrlTransformEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetUrlTransformEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetUrlTransformEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetUrlTransformEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetUrlTransformEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetUrlTransformEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetUrlTransformEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetUrlTransformEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetUrlTransformEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetUrlTransformEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetUrlTransformEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetUrlTransformEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetUrlTransformEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetUrlTransformEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetUrlTransformEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetUrlTransformEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetUrlTransformEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetUrlTransformEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetUrlTransformEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetUrlTransformEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetUrlTransformEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetUrlTransformEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetUrlTransformEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetUrlTransformEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetUrlTransformEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetUrlTransformEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetUrlTransformEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetUrlTransformEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetUrlTransformEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetUrlTransformEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetUrlTransformEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetUrlTransformEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetUrlTransformEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetUrlTransformEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetUrlTransformEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetUrlTransformEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetUrlTransformEvent_GetLogicalUrl(This,ppwszLogicalURL)	\
    ( (This)->lpVtbl -> GetLogicalUrl(This,ppwszLogicalURL) ) 

#define IMFNetUrlTransformEvent_SetTransformedUrl(This,pwszTransformedURL)	\
    ( (This)->lpVtbl -> SetTransformedUrl(This,pwszTransformedURL) ) 

#define IMFNetUrlTransformEvent_GetTransformedUrl(This,ppwszTransformedURL)	\
    ( (This)->lpVtbl -> GetTransformedUrl(This,ppwszTransformedURL) ) 

#define IMFNetUrlTransformEvent_SetByteStream(This,pStream,pProfile)	\
    ( (This)->lpVtbl -> SetByteStream(This,pStream,pProfile) ) 

#define IMFNetUrlTransformEvent_GetByteStream(This,ppStream,ppProfile)	\
    ( (This)->lpVtbl -> GetByteStream(This,ppStream,ppProfile) ) 

#define IMFNetUrlTransformEvent_GetMessageBody(This,pbstrBody)	\
    ( (This)->lpVtbl -> GetMessageBody(This,pbstrBody) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetUrlTransformEvent_INTERFACE_DEFINED__ */


#ifndef __IMFNetProfilesEvent_INTERFACE_DEFINED__
#define __IMFNetProfilesEvent_INTERFACE_DEFINED__

/* interface IMFNetProfilesEvent */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetProfilesEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B85B305E-4DA8-4c8a-B297-08EB86C821E3")
    IMFNetProfilesEvent : public IMFNetEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProfiles( 
            /* [annotation][out] */ 
            __out  IMFCollection **ppProfileCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSupportedProfiles( 
            /* [in] */ IMFCollection *pProfileCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProfile( 
            /* [annotation][out] */ 
            __out  IPropertyStore **ppOutputProfileProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProfile( 
            /* [in] */ IPropertyStore *pOutputProfileProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetProfilesEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetProfilesEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetProfilesEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetProfilesEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFNetProfilesEvent * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFNetProfilesEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFNetProfilesEvent * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFNetProfilesEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFNetProfilesEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFNetProfilesEvent * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFNetProfilesEvent * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFNetProfilesEvent * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFNetProfilesEvent * This,
            /* [out] */ MediaEventType *pmet);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedType )( 
            IMFNetProfilesEvent * This,
            /* [out] */ GUID *pguidExtendedType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IMFNetProfilesEvent * This,
            /* [out] */ HRESULT *phrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IMFNetProfilesEvent * This,
            /* [out] */ PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IMFNetProfilesEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetVRoot )( 
            IMFNetProfilesEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppVRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IMFNetProfilesEvent * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequest )( 
            IMFNetProfilesEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponse )( 
            IMFNetProfilesEvent * This,
            /* [out] */ IMFNetHeaderCollection **ppResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProfiles )( 
            IMFNetProfilesEvent * This,
            /* [annotation][out] */ 
            __out  IMFCollection **ppProfileCollection);
        
        HRESULT ( STDMETHODCALLTYPE *SetSupportedProfiles )( 
            IMFNetProfilesEvent * This,
            /* [in] */ IMFCollection *pProfileCollection);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputProfile )( 
            IMFNetProfilesEvent * This,
            /* [annotation][out] */ 
            __out  IPropertyStore **ppOutputProfileProps);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputProfile )( 
            IMFNetProfilesEvent * This,
            /* [in] */ IPropertyStore *pOutputProfileProps);
        
        END_INTERFACE
    } IMFNetProfilesEventVtbl;

    interface IMFNetProfilesEvent
    {
        CONST_VTBL struct IMFNetProfilesEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetProfilesEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetProfilesEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetProfilesEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetProfilesEvent_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFNetProfilesEvent_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFNetProfilesEvent_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFNetProfilesEvent_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFNetProfilesEvent_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFNetProfilesEvent_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFNetProfilesEvent_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFNetProfilesEvent_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFNetProfilesEvent_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFNetProfilesEvent_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFNetProfilesEvent_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFNetProfilesEvent_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFNetProfilesEvent_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFNetProfilesEvent_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFNetProfilesEvent_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFNetProfilesEvent_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFNetProfilesEvent_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFNetProfilesEvent_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFNetProfilesEvent_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFNetProfilesEvent_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFNetProfilesEvent_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFNetProfilesEvent_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFNetProfilesEvent_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFNetProfilesEvent_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFNetProfilesEvent_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFNetProfilesEvent_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFNetProfilesEvent_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFNetProfilesEvent_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFNetProfilesEvent_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFNetProfilesEvent_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFNetProfilesEvent_GetType(This,pmet)	\
    ( (This)->lpVtbl -> GetType(This,pmet) ) 

#define IMFNetProfilesEvent_GetExtendedType(This,pguidExtendedType)	\
    ( (This)->lpVtbl -> GetExtendedType(This,pguidExtendedType) ) 

#define IMFNetProfilesEvent_GetStatus(This,phrStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,phrStatus) ) 

#define IMFNetProfilesEvent_GetValue(This,pvValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvValue) ) 


#define IMFNetProfilesEvent_GetSession(This,riid,ppSession)	\
    ( (This)->lpVtbl -> GetSession(This,riid,ppSession) ) 

#define IMFNetProfilesEvent_GetVRoot(This,riid,ppVRoot)	\
    ( (This)->lpVtbl -> GetVRoot(This,riid,ppVRoot) ) 

#define IMFNetProfilesEvent_GetConnection(This,riid,ppConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,riid,ppConnection) ) 

#define IMFNetProfilesEvent_GetRequest(This,ppRequest)	\
    ( (This)->lpVtbl -> GetRequest(This,ppRequest) ) 

#define IMFNetProfilesEvent_GetResponse(This,ppResponse)	\
    ( (This)->lpVtbl -> GetResponse(This,ppResponse) ) 


#define IMFNetProfilesEvent_GetSupportedProfiles(This,ppProfileCollection)	\
    ( (This)->lpVtbl -> GetSupportedProfiles(This,ppProfileCollection) ) 

#define IMFNetProfilesEvent_SetSupportedProfiles(This,pProfileCollection)	\
    ( (This)->lpVtbl -> SetSupportedProfiles(This,pProfileCollection) ) 

#define IMFNetProfilesEvent_GetOutputProfile(This,ppOutputProfileProps)	\
    ( (This)->lpVtbl -> GetOutputProfile(This,ppOutputProfileProps) ) 

#define IMFNetProfilesEvent_SetOutputProfile(This,pOutputProfileProps)	\
    ( (This)->lpVtbl -> SetOutputProfile(This,pOutputProfileProps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetProfilesEvent_INTERFACE_DEFINED__ */


#ifndef __IMFNetEventHandler_INTERFACE_DEFINED__
#define __IMFNetEventHandler_INTERFACE_DEFINED__

/* interface IMFNetEventHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFNetEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e2b250a-f1a7-46be-b2d1-38a762a2bff7")
    IMFNetEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginNetEvent( 
            /* [in] */ IMFNetEvent *pNetEvent,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndNetEvent( 
            /* [in] */ IMFAsyncResult *pResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetEventHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginNetEvent )( 
            IMFNetEventHandler * This,
            /* [in] */ IMFNetEvent *pNetEvent,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndNetEvent )( 
            IMFNetEventHandler * This,
            /* [in] */ IMFAsyncResult *pResult);
        
        END_INTERFACE
    } IMFNetEventHandlerVtbl;

    interface IMFNetEventHandler
    {
        CONST_VTBL struct IMFNetEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetEventHandler_BeginNetEvent(This,pNetEvent,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginNetEvent(This,pNetEvent,pCallback,pState) ) 

#define IMFNetEventHandler_EndNetEvent(This,pResult)	\
    ( (This)->lpVtbl -> EndNetEvent(This,pResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetEventHandler_INTERFACE_DEFINED__ */


#ifndef __IMFNetSinkControlConnection_INTERFACE_DEFINED__
#define __IMFNetSinkControlConnection_INTERFACE_DEFINED__

/* interface IMFNetSinkControlConnection */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetSinkControlConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20A32133-518C-422a-A95A-691F9772C3AE")
    IMFNetSinkControlConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginSendRequest( 
            /* [in] */ IMFNetEvent *pNetEvent,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSendRequest( 
            /* [in] */ IMFAsyncResult *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetSinkControlConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetSinkControlConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetSinkControlConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetSinkControlConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginSendRequest )( 
            IMFNetSinkControlConnection * This,
            /* [in] */ IMFNetEvent *pNetEvent,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndSendRequest )( 
            IMFNetSinkControlConnection * This,
            /* [in] */ IMFAsyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IMFNetSinkControlConnection * This);
        
        END_INTERFACE
    } IMFNetSinkControlConnectionVtbl;

    interface IMFNetSinkControlConnection
    {
        CONST_VTBL struct IMFNetSinkControlConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetSinkControlConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetSinkControlConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetSinkControlConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetSinkControlConnection_BeginSendRequest(This,pNetEvent,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginSendRequest(This,pNetEvent,pCallback,pState) ) 

#define IMFNetSinkControlConnection_EndSendRequest(This,pResult)	\
    ( (This)->lpVtbl -> EndSendRequest(This,pResult) ) 

#define IMFNetSinkControlConnection_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetSinkControlConnection_INTERFACE_DEFINED__ */


#ifndef __IMFNetSession_INTERFACE_DEFINED__
#define __IMFNetSession_INTERFACE_DEFINED__

/* interface IMFNetSession */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFNetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fe5a22ac-a78c-441f-a5ce-24d31f0d45b4")
    IMFNetSession : public IMFNetEventHandler
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSessionProps( 
            /* [in] */ MF_DRMNET_SESSIONID sessionId,
            /* [in] */ IMFNetSinkControlConnection *pNetSinkControlConnection,
            /* [in] */ IMFNetChannel *pNetChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSessionIdle( 
            BOOL *pfIdleSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFNetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFNetSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFNetSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFNetSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginNetEvent )( 
            IMFNetSession * This,
            /* [in] */ IMFNetEvent *pNetEvent,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *pState);
        
        HRESULT ( STDMETHODCALLTYPE *EndNetEvent )( 
            IMFNetSession * This,
            /* [in] */ IMFAsyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionProps )( 
            IMFNetSession * This,
            /* [in] */ MF_DRMNET_SESSIONID sessionId,
            /* [in] */ IMFNetSinkControlConnection *pNetSinkControlConnection,
            /* [in] */ IMFNetChannel *pNetChannel);
        
        HRESULT ( STDMETHODCALLTYPE *IsSessionIdle )( 
            IMFNetSession * This,
            BOOL *pfIdleSession);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFNetSession * This);
        
        END_INTERFACE
    } IMFNetSessionVtbl;

    interface IMFNetSession
    {
        CONST_VTBL struct IMFNetSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFNetSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFNetSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFNetSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFNetSession_BeginNetEvent(This,pNetEvent,pCallback,pState)	\
    ( (This)->lpVtbl -> BeginNetEvent(This,pNetEvent,pCallback,pState) ) 

#define IMFNetSession_EndNetEvent(This,pResult)	\
    ( (This)->lpVtbl -> EndNetEvent(This,pResult) ) 


#define IMFNetSession_SetSessionProps(This,sessionId,pNetSinkControlConnection,pNetChannel)	\
    ( (This)->lpVtbl -> SetSessionProps(This,sessionId,pNetSinkControlConnection,pNetChannel) ) 

#define IMFNetSession_IsSessionIdle(This,pfIdleSession)	\
    ( (This)->lpVtbl -> IsSessionIdle(This,pfIdleSession) ) 

#define IMFNetSession_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFNetSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0074 */
/* [local] */ 

MFNETPUBLIC(MFCreateRtspListener)(
    IMFNetListener ** ppNetListener);
MFNETPUBLIC(MFCreateNetVRoot)(
    IMFNetVRoot ** ppVRoot );
EXTERN_GUID(MF_PD_NET_BROADCAST, 0xb13f98ea, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_SEEKABLE, 0xb13f98eb, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_STRIDABLE, 0xb13f98ec, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_RECORDABLE, 0xb13f98ed, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_PLAYLIST, 0xb13f98ee, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_SKIP_FORWARD, 0xb13f98ef, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_SKIP_BACKWARD, 0xb13f98f0, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_MUXSTREAM, 0xb13f98f1, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_PAUSABLE, 0xb13f98f2, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_STRIDING_RATES, 0xb13f98f3, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_SLOWEST_SPEED, 0xb13f98f4, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_FASTEST_SPEED, 0xb13f98f5, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_DLNA_PROFILE, 0xb13f98f6, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID(MF_PD_NET_ENCRYPTED, 0xb13f98f7, 0xa3e1, 0x4714, 0x83, 0xc7, 0xe, 0x3e, 0xfa, 0x39, 0xa1, 0x8a);
EXTERN_GUID( MF_SD_NET_BITRATE, 0xbef23946, 0x9034, 0x4bb7, 0xb2, 0xf4, 0xeb, 0xaf, 0x9f, 0x14, 0xd7, 0x96);
EXTERN_GUID( MF_SD_NET_PEAK_BITRATE, 0xbef23947, 0x9034, 0x4bb7, 0xb2, 0xf4, 0xeb, 0xaf, 0x9f, 0x14, 0xd7, 0x96);
EXTERN_GUID( MF_SD_NET_BUFFERSIZE, 0xbef23948, 0x9034, 0x4bb7, 0xb2, 0xf4, 0xeb, 0xaf, 0x9f, 0x14, 0xd7, 0x96);
EXTERN_GUID( MF_SD_NET_PEAK_BUFFERSIZE, 0xbef23949, 0x9034, 0x4bb7, 0xb2, 0xf4, 0xeb, 0xaf, 0x9f, 0x14, 0xd7, 0x96);
typedef 
enum _MF_LINE21_CCLEVEL
    {	L21_CCLEVEL_TC2	= 0
    } 	MF_LINE21_CCLEVEL;

typedef enum _MF_LINE21_CCLEVEL *PMF_LINE21_CCLEVEL;

typedef 
enum _MF_LINE21_CCSERVICE
    {	L21_CCSERVICE_None	= 0,
	L21_CCSERVICE_Caption1	= ( L21_CCSERVICE_None + 1 ) ,
	L21_CCSERVICE_Caption2	= ( L21_CCSERVICE_Caption1 + 1 ) ,
	L21_CCSERVICE_Text1	= ( L21_CCSERVICE_Caption2 + 1 ) ,
	L21_CCSERVICE_Text2	= ( L21_CCSERVICE_Text1 + 1 ) ,
	L21_CCSERVICE_XDS	= ( L21_CCSERVICE_Text2 + 1 ) ,
	L21_CCSERVICE_DefChannel	= 10,
	L21_CCSERVICE_Invalid	= ( L21_CCSERVICE_DefChannel + 1 ) 
    } 	MF_LINE21_CCSERVICE;

typedef enum _MF_LINE21_CCSERVICE *PMF_LINE21_CCSERVICE;

typedef 
enum _MF_LINE21_CCSTATE
    {	L21_CCSTATE_Off	= 0,
	L21_CCSTATE_On	= ( L21_CCSTATE_Off + 1 ) 
    } 	MF_LINE21_CCSTATE;

typedef enum _MF_LINE21_CCSTATE *PMF_LINE21_CCSTATE;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0074_v0_0_s_ifspec;

#ifndef __IMFLine21Decoder_INTERFACE_DEFINED__
#define __IMFLine21Decoder_INTERFACE_DEFINED__

/* interface IMFLine21Decoder */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IMFLine21Decoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A8A285C-8148-4A4B-955A-D655FF2433D3")
    IMFLine21Decoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDecoderLevel( 
            /* [annotation][out] */ 
            __out  MF_LINE21_CCLEVEL *pLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontName( 
            /* [annotation][size_is][out] */ 
            __out_ecount_part_opt(dwMaxSize, *pdwActualSize)  LPWSTR pszwFontName,
            /* [in] */ DWORD dwMaxSize,
            /* [out] */ DWORD *pdwActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentService( 
            /* [annotation][out] */ 
            __out  MF_LINE21_CCSERVICE *pService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentService( 
            /* [in] */ MF_LINE21_CCSERVICE Service) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceState( 
            /* [annotation][out] */ 
            __out  MF_LINE21_CCSTATE *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServiceState( 
            /* [in] */ MF_LINE21_CCSTATE State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundAlpha( 
            /* [annotation][out] */ 
            __out  BYTE *pbAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundAlpha( 
            /* [in] */ BYTE bAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFLine21DecoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFLine21Decoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFLine21Decoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFLine21Decoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderLevel )( 
            IMFLine21Decoder * This,
            /* [annotation][out] */ 
            __out  MF_LINE21_CCLEVEL *pLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontName )( 
            IMFLine21Decoder * This,
            /* [annotation][size_is][out] */ 
            __out_ecount_part_opt(dwMaxSize, *pdwActualSize)  LPWSTR pszwFontName,
            /* [in] */ DWORD dwMaxSize,
            /* [out] */ DWORD *pdwActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentService )( 
            IMFLine21Decoder * This,
            /* [annotation][out] */ 
            __out  MF_LINE21_CCSERVICE *pService);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentService )( 
            IMFLine21Decoder * This,
            /* [in] */ MF_LINE21_CCSERVICE Service);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceState )( 
            IMFLine21Decoder * This,
            /* [annotation][out] */ 
            __out  MF_LINE21_CCSTATE *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetServiceState )( 
            IMFLine21Decoder * This,
            /* [in] */ MF_LINE21_CCSTATE State);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundAlpha )( 
            IMFLine21Decoder * This,
            /* [annotation][out] */ 
            __out  BYTE *pbAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundAlpha )( 
            IMFLine21Decoder * This,
            /* [in] */ BYTE bAlpha);
        
        END_INTERFACE
    } IMFLine21DecoderVtbl;

    interface IMFLine21Decoder
    {
        CONST_VTBL struct IMFLine21DecoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFLine21Decoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFLine21Decoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFLine21Decoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFLine21Decoder_GetDecoderLevel(This,pLevel)	\
    ( (This)->lpVtbl -> GetDecoderLevel(This,pLevel) ) 

#define IMFLine21Decoder_GetFontName(This,pszwFontName,dwMaxSize,pdwActualSize)	\
    ( (This)->lpVtbl -> GetFontName(This,pszwFontName,dwMaxSize,pdwActualSize) ) 

#define IMFLine21Decoder_GetCurrentService(This,pService)	\
    ( (This)->lpVtbl -> GetCurrentService(This,pService) ) 

#define IMFLine21Decoder_SetCurrentService(This,Service)	\
    ( (This)->lpVtbl -> SetCurrentService(This,Service) ) 

#define IMFLine21Decoder_GetServiceState(This,pState)	\
    ( (This)->lpVtbl -> GetServiceState(This,pState) ) 

#define IMFLine21Decoder_SetServiceState(This,State)	\
    ( (This)->lpVtbl -> SetServiceState(This,State) ) 

#define IMFLine21Decoder_GetBackgroundAlpha(This,pbAlpha)	\
    ( (This)->lpVtbl -> GetBackgroundAlpha(This,pbAlpha) ) 

#define IMFLine21Decoder_SetBackgroundAlpha(This,bAlpha)	\
    ( (This)->lpVtbl -> SetBackgroundAlpha(This,bAlpha) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFLine21Decoder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0075 */
/* [local] */ 

EXTERN_C const DECLSPEC_SELECTANY GUID GUID_COUNTER_SERVING_BASIC = { 0x2ae15ef7, 0xb880, 0x48a5, { 0xb2, 0xc8, 0x73, 0x9e, 0xd6, 0xb4, 0x3e, 0xe4 } };
EXTERN_C const DECLSPEC_SELECTANY GUID GUID_COUNTER_NETWORKING_BASIC = { 0x792676d4, 0x706b, 0x481a, { 0xb8, 0x7f, 0x5c, 0xa8, 0xe0, 0x5b, 0xfa, 0x27 } };
EXTERN_C const DECLSPEC_SELECTANY GUID GUID_COUNTER_SINK = { 0x5d78539c, 0x0dd0, 0x4ad5, { 0x82, 0x33, 0x9c, 0x06, 0x86, 0x6c, 0x84, 0xc4 } };
EXTERN_C const DECLSPEC_SELECTANY GUID GUID_COUNTER_ASFMEDIASINK = { 0xa13c2719, 0x0ebe, 0x42a7, { 0x97, 0x74, 0x7b, 0xa9, 0xe0, 0x89, 0x3d, 0x0d } };
EXTERN_C const DECLSPEC_SELECTANY GUID GUID_COUNTER_ASFMEDIASOURCE = { 0xe6466dde, 0x650f, 0x4661, { 0xb5, 0xd4, 0xa1, 0xb, 0xf3, 0xea, 0xf9, 0xb8 } };
EXTERN_C const DECLSPEC_SELECTANY GUID GUID_COUNTER_CDMEDIASOURCE = { 0x789800b2, 0xc160, 0x40c4, {0xa1, 0x5a, 0x77, 0x5d, 0xcb, 0xfe, 0x31, 0xa0 } };
typedef /* [uuid][public] */  DECLSPEC_UUID("67323461-16e2-4b14-99e0-9394249b1db3") 
enum SERVING_BASIC_STATISTICS_IDS
    {	CONNECTEDPLAYERS	= 0,
	ALLOCATEDBANDWIDTH	= 1,
	PLAYERSENDRATE	= 2,
	STREAMINGPLAYERS	= 3
    } 	SERVING_BASIC_STATISTICS_IDS;

typedef /* [uuid][public] */  DECLSPEC_UUID("953b1174-fc31-4414-9c09-e27c16fcc237") 
enum NETWORKING_BASIC_STATISTICS_IDS
    {	HTTPCONNECTEDPLAYERS	= 0,
	HTTPSTREAMINGPLAYERS	= 1,
	RTSPCONNECTEDPLAYERS	= 2,
	RTSPSTREAMINGPLAYERS	= 3,
	QUEUELENGTH	= 4,
	LATESENDRATE	= 5
    } 	NETWORKING_BASIC_STATISTICS_IDS;

typedef /* [uuid][public] */  DECLSPEC_UUID("89f7b68a-5f92-4ba3-a066-a72a956f28e1") 
enum ASFMEDIASINK_STATISTICS_IDS
    {	MUX_FRAMESWRITTEN	= 0,
	MUX_FRAMESDROPPED	= 1
    } 	ASFMEDIASINK_STATISTICS_IDS;

typedef /* [uuid][public] */  DECLSPEC_UUID("D137506B-1C3E-4b0f-8E26-1378E944956C") 
enum ASFMEDIASOURCE_STATISTICS_IDS
    {	SRC_BYTESREAD	= 0
    } 	ASFMEDIASOURCE_STATISTICS_IDS;

EXTERN_C const GUID MFDEVICE_BASIC_STATISTICS;
EXTERN_C const GUID MFDEVICE_BASIC_STATISTICS_SERVICE;
typedef 
enum _MFDEVICE_BASIC_STATISTICS_IDS
    {	MFDEVICE_BYTESPROCESSED_ID	= 0,
	MFDEVICE_BYTESERRORPROCESSED_ID	= 1,
	MFDEVICE_BYTESDROPPED_ID	= 2,
	MFDEVICE_FRAMESPROCESSED_ID	= 3,
	MFDEVICE_FRAMESERRORPROCESSED_ID	= 4,
	MFDEVICE_FRAMESDROPPED_ID	= 5
    } 	MFDEVICE_BASIC_STATISTICS_IDS;

EXTERN_C const GUID MFAUDIORENDERSINK_STATISTICS;
EXTERN_C const GUID MFAUDIORENDERSINK_STATISTICS_SERVICE;
typedef 
enum _AUDIORENDERSINK_STATISTICS_IDS
    {	SAMPLES_RECEIVED_ID	= 0,
	BYTES_RECEIVED_ID	= 1,
	AUDIO_FRAMES_RECEIVED_ID	= 2
    } 	AUDIORENDERSINK_STATISTICS_IDS;

typedef /* [uuid][public] */  DECLSPEC_UUID("37f6cde8-73d7-4642-b252-636863ef81e1") 
enum CDMEDIASOURCE_STATISTICS_IDS
    {	AUDIO_BYTESDELIVERED	= 0,
	VIDEO_BYTESDELIVERED	= 1
    } 	CDMEDIASOURCE_STATISTICS_IDS;



extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0075_v0_0_s_ifspec;

#ifndef __IMFStatistics_INTERFACE_DEFINED__
#define __IMFStatistics_INTERFACE_DEFINED__

/* interface IMFStatistics */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFStatistics;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("294eb3fb-94dd-42c2-a12e-374bbf1098f8")
    IMFStatistics : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IncrementBy32( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ long lInc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncrementBy64( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ __int64 lInc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue32( 
            /* [in] */ DWORD dwIndex,
            /* [annotation][out] */ 
            __out  DWORD *pdwCurrentValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue64( 
            /* [in] */ DWORD dwIndex,
            /* [annotation][out] */ 
            __out  QWORD *pqwCurrentValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue32( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwCurrentValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue64( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ QWORD qwCurrentValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStatisticsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStatistics * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStatistics * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStatistics * This);
        
        HRESULT ( STDMETHODCALLTYPE *IncrementBy32 )( 
            IMFStatistics * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ long lInc);
        
        HRESULT ( STDMETHODCALLTYPE *IncrementBy64 )( 
            IMFStatistics * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __int64 lInc);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue32 )( 
            IMFStatistics * This,
            /* [in] */ DWORD dwIndex,
            /* [annotation][out] */ 
            __out  DWORD *pdwCurrentValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue64 )( 
            IMFStatistics * This,
            /* [in] */ DWORD dwIndex,
            /* [annotation][out] */ 
            __out  QWORD *pqwCurrentValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue32 )( 
            IMFStatistics * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwCurrentValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue64 )( 
            IMFStatistics * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ QWORD qwCurrentValue);
        
        END_INTERFACE
    } IMFStatisticsVtbl;

    interface IMFStatistics
    {
        CONST_VTBL struct IMFStatisticsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStatistics_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStatistics_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStatistics_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStatistics_IncrementBy32(This,dwIndex,lInc)	\
    ( (This)->lpVtbl -> IncrementBy32(This,dwIndex,lInc) ) 

#define IMFStatistics_IncrementBy64(This,dwIndex,lInc)	\
    ( (This)->lpVtbl -> IncrementBy64(This,dwIndex,lInc) ) 

#define IMFStatistics_GetValue32(This,dwIndex,pdwCurrentValue)	\
    ( (This)->lpVtbl -> GetValue32(This,dwIndex,pdwCurrentValue) ) 

#define IMFStatistics_GetValue64(This,dwIndex,pqwCurrentValue)	\
    ( (This)->lpVtbl -> GetValue64(This,dwIndex,pqwCurrentValue) ) 

#define IMFStatistics_SetValue32(This,dwIndex,dwCurrentValue)	\
    ( (This)->lpVtbl -> SetValue32(This,dwIndex,dwCurrentValue) ) 

#define IMFStatistics_SetValue64(This,dwIndex,qwCurrentValue)	\
    ( (This)->lpVtbl -> SetValue64(This,dwIndex,qwCurrentValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStatistics_INTERFACE_DEFINED__ */


#ifndef __IMFStatisticsCollection_INTERFACE_DEFINED__
#define __IMFStatisticsCollection_INTERFACE_DEFINED__

/* interface IMFStatisticsCollection */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFStatisticsCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("294eb3fc-94dd-42c2-a12e-374bbf1098f8")
    IMFStatisticsCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddStatistics( 
            /* [in] */ REFGUID guid,
            /* [in] */ IMFStatistics *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ REFGUID guid,
            /* [annotation][out] */ 
            __out  IMFStatistics **ppStatistics) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStatisticsCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStatisticsCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStatisticsCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStatisticsCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddStatistics )( 
            IMFStatisticsCollection * This,
            /* [in] */ REFGUID guid,
            /* [in] */ IMFStatistics *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IMFStatisticsCollection * This,
            /* [in] */ REFGUID guid,
            /* [annotation][out] */ 
            __out  IMFStatistics **ppStatistics);
        
        END_INTERFACE
    } IMFStatisticsCollectionVtbl;

    interface IMFStatisticsCollection
    {
        CONST_VTBL struct IMFStatisticsCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStatisticsCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStatisticsCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStatisticsCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStatisticsCollection_AddStatistics(This,guid,pStatistics)	\
    ( (This)->lpVtbl -> AddStatistics(This,guid,pStatistics) ) 

#define IMFStatisticsCollection_GetStatistics(This,guid,ppStatistics)	\
    ( (This)->lpVtbl -> GetStatistics(This,guid,ppStatistics) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStatisticsCollection_INTERFACE_DEFINED__ */


#ifndef __IMFStatisticsSite_INTERFACE_DEFINED__
#define __IMFStatisticsSite_INTERFACE_DEFINED__

/* interface IMFStatisticsSite */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFStatisticsSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("294eb3fd-94dd-42c2-a12e-374bbf1098f8")
    IMFStatisticsSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStatistics( 
            /* [in] */ IMFStatisticsCollection *pStatistics) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStatisticsSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStatisticsSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStatisticsSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStatisticsSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatistics )( 
            IMFStatisticsSite * This,
            /* [in] */ IMFStatisticsCollection *pStatistics);
        
        END_INTERFACE
    } IMFStatisticsSiteVtbl;

    interface IMFStatisticsSite
    {
        CONST_VTBL struct IMFStatisticsSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStatisticsSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStatisticsSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStatisticsSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStatisticsSite_SetStatistics(This,pStatistics)	\
    ( (This)->lpVtbl -> SetStatistics(This,pStatistics) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStatisticsSite_INTERFACE_DEFINED__ */


#ifndef __IMFDescriptorInterpreter_INTERFACE_DEFINED__
#define __IMFDescriptorInterpreter_INTERFACE_DEFINED__

/* interface IMFDescriptorInterpreter */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFDescriptorInterpreter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6D7CD50-2A95-4698-89E4-0D6420704440")
    IMFDescriptorInterpreter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadFromDescriptor( 
            /* [in] */ IUnknown *pDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDescriptor( 
            /* [annotation][out] */ 
            __deref_out  IUnknown **ppDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFDescriptorInterpreterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFDescriptorInterpreter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFDescriptorInterpreter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFDescriptorInterpreter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadFromDescriptor )( 
            IMFDescriptorInterpreter * This,
            /* [in] */ IUnknown *pDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDescriptor )( 
            IMFDescriptorInterpreter * This,
            /* [annotation][out] */ 
            __deref_out  IUnknown **ppDescriptor);
        
        END_INTERFACE
    } IMFDescriptorInterpreterVtbl;

    interface IMFDescriptorInterpreter
    {
        CONST_VTBL struct IMFDescriptorInterpreterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFDescriptorInterpreter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFDescriptorInterpreter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFDescriptorInterpreter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFDescriptorInterpreter_ReadFromDescriptor(This,pDescriptor)	\
    ( (This)->lpVtbl -> ReadFromDescriptor(This,pDescriptor) ) 

#define IMFDescriptorInterpreter_GenerateDescriptor(This,ppDescriptor)	\
    ( (This)->lpVtbl -> GenerateDescriptor(This,ppDescriptor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFDescriptorInterpreter_INTERFACE_DEFINED__ */


#ifndef __IMFGetMultipleServiceProviders_INTERFACE_DEFINED__
#define __IMFGetMultipleServiceProviders_INTERFACE_DEFINED__

/* interface IMFGetMultipleServiceProviders */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFGetMultipleServiceProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CA60D7E-E98D-4c2d-B25E-D4B7CF394185")
    IMFGetMultipleServiceProviders : public IMFGetService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMultipleServiceProviders( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ IMFCollection **ppIMFCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFGetMultipleServiceProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFGetMultipleServiceProviders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFGetMultipleServiceProviders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFGetMultipleServiceProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            IMFGetMultipleServiceProviders * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultipleServiceProviders )( 
            IMFGetMultipleServiceProviders * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ IMFCollection **ppIMFCollection);
        
        END_INTERFACE
    } IMFGetMultipleServiceProvidersVtbl;

    interface IMFGetMultipleServiceProviders
    {
        CONST_VTBL struct IMFGetMultipleServiceProvidersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFGetMultipleServiceProviders_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFGetMultipleServiceProviders_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFGetMultipleServiceProviders_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFGetMultipleServiceProviders_GetService(This,guidService,riid,ppvObject)	\
    ( (This)->lpVtbl -> GetService(This,guidService,riid,ppvObject) ) 


#define IMFGetMultipleServiceProviders_GetMultipleServiceProviders(This,guidService,riid,ppIMFCollection)	\
    ( (This)->lpVtbl -> GetMultipleServiceProviders(This,guidService,riid,ppIMFCollection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFGetMultipleServiceProviders_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0080 */
/* [local] */ 

STDAPI MFGetMultipleServiceProviders(
    IUnknown * punkObject,
    REFGUID guidService,
    REFIID riid,
    __out IMFCollection ** ppIMFCollection
    );
EXTERN_GUID(MFASFINDEXER_TYPE_FRAME, 0x49815230, 0x6bad, 0x44fd, 0x81, 0xa, 0x3f, 0x60, 0x98, 0x4e, 0xc7, 0xfd);
EXTERN_C const PROPERTYKEY MFPKEY_PmpSessionHost;


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0080_v0_0_s_ifspec;

#ifndef __IMFPMPSessionHost_INTERFACE_DEFINED__
#define __IMFPMPSessionHost_INTERFACE_DEFINED__

/* interface IMFPMPSessionHost */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFPMPSessionHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("994e23ac-1cc2-493c-b9fa-46f1cb040fa4")
    IMFPMPSessionHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProtectedSession( 
            /* [annotation][out] */ 
            __out  IMFMediaSession **ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPMPSessionHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPMPSessionHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPMPSessionHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPMPSessionHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtectedSession )( 
            IMFPMPSessionHost * This,
            /* [annotation][out] */ 
            __out  IMFMediaSession **ppSession);
        
        END_INTERFACE
    } IMFPMPSessionHostVtbl;

    interface IMFPMPSessionHost
    {
        CONST_VTBL struct IMFPMPSessionHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPMPSessionHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPMPSessionHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPMPSessionHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPMPSessionHost_GetProtectedSession(This,ppSession)	\
    ( (This)->lpVtbl -> GetProtectedSession(This,ppSession) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPMPSessionHost_INTERFACE_DEFINED__ */


#ifndef __IMFByteStreamReservation_INTERFACE_DEFINED__
#define __IMFByteStreamReservation_INTERFACE_DEFINED__

/* interface IMFByteStreamReservation */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFByteStreamReservation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1a37165b-2079-402c-9e2c-ebcdede8c12f")
    IMFByteStreamReservation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reserve( 
            /* [in] */ ULONG ulBandwidthBytesPerSecond) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFByteStreamReservationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFByteStreamReservation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFByteStreamReservation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFByteStreamReservation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reserve )( 
            IMFByteStreamReservation * This,
            /* [in] */ ULONG ulBandwidthBytesPerSecond);
        
        END_INTERFACE
    } IMFByteStreamReservationVtbl;

    interface IMFByteStreamReservation
    {
        CONST_VTBL struct IMFByteStreamReservationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFByteStreamReservation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFByteStreamReservation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFByteStreamReservation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFByteStreamReservation_Reserve(This,ulBandwidthBytesPerSecond)	\
    ( (This)->lpVtbl -> Reserve(This,ulBandwidthBytesPerSecond) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFByteStreamReservation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0082 */
/* [local] */ 

#define MFBYTESTREAM_IS_AVIOABLE                0x00000020
//                                          
// mediatype utility functions              
//                                          
#ifdef __cplusplus                          
BOOL                                        
IsD3DFormatRGB(                             
    __in        UINT32  unD3DFormat,        
    __out_opt   BOOL*   pbKnown = NULL      
    );                                      
#else                                       
BOOL                                        
IsD3DFormatRGB(                             
    __in        UINT32  unD3DFormat,        
    __out_opt   BOOL*   pbKnown             
    );                                      
#endif                                      
BOOL                                        
IsKnownLowQualityType(                      
    __in    IMFMediaType*   pType           
    );                                      
#ifdef __cplusplus                          
UINT32                                      
GetD3DFormatFromMFSubtype(                  
    __in    const GUID& guid                
    );                                      
#endif                                      
GUID                                        
GetAMSubtypeFromD3DFormat(                  
    __in    UINT32 unD3DFormat              
    );                                      
//                                                          
// DEPRECATED OLD STUFF ONLY HERE WHILE IT'S BEING REMOVED  
//                                                          
BOOL                                            
STDMETHODCALLTYPE                               
MFIsCompressedVideoFormat(                      
    __in    const MFVIDEOFORMAT* pVideoFormat   
    );                                          
typedef struct _MFDynamicVideoFormatData
    {
    MFRatio PixelAspectRatio;
    MFVideoInterlaceMode InterlaceMode;
    MFVideoArea PanScanAperture;
    MFVideoArea MinimumDisplayAperture;
    unsigned __int64 VideoFlags;
    DWORD NewPaletteEntries;
    MFPaletteEntry Palette[ 1 ];
    } 	MFDynamicVideoFormatData;

typedef struct _MFDynamicVideoFormatDataPalette256
    {
    MFRatio PixelAspectRatio;
    MFVideoInterlaceMode InterlaceMode;
    MFVideoArea PanScanAperture;
    MFVideoArea MinimumDisplayAperture;
    unsigned __int64 VideoFlags;
    DWORD NewPaletteEntries;
    MFPaletteEntry Palette[ 256 ];
    } 	MFDynamicVideoFormatDataPalette256;

#include "mferror.h"                          
static                                          
HRESULT                                         
MFSetDynamicVideoFormatData(                    
    IMFSample* pSample,                         
    const MFDynamicVideoFormatData* pData )     
{                                               
    return S_OK;                                
}                                               
static                                          
HRESULT                                         
MFGetDynamicVideoFormatData(                    
    IMFSample* pSample,                         
    MFDynamicVideoFormatData* pData )           
{                                               
    return MF_E_ATTRIBUTENOTFOUND;              
}                                               
static                                          
HRESULT                                         
MFGetDynamicVideoFormatDataPalette(             
    IMFSample* pSample,                         
    MFDynamicVideoFormatDataPalette256* pData ) 
{                                               
    return MF_E_ATTRIBUTENOTFOUND;              
}                                               
DEFINE_GUID(MFSampleExtension_VideoInterlace,                                   
0x8294da67, 0xf328, 0x4805, 0xb5, 0x51, 0x00, 0xde, 0xb4, 0xc5, 0x7a, 0x61);    
DEFINE_GUID(MFVIDEOFORMAT_DynamicData,                                          
0x2efc7246, 0xa951, 0x45e0, 0xae, 0xf4, 0x0d, 0xb0, 0x7a, 0xa9, 0x09, 0xda);    
EXTERN_C const GUID MF_MEDIASOURCE_SERVICE;
STDAPI MFCreateByteStreamMediaSource(
    __in IMFByteStream *pByteStream,
    __in IUnknown *punkContainerPlugin,
    __in_opt IPropertyStore *pProps,
    __out IMFMediaSource **ppMediaSource );
typedef 
enum _MF_MEDIASOURCE_PLUGIN_FLAGS
    {	MF_MEDIASOURCE_PLUGIN_FLAG_REVERSE	= 0x1
    } 	MF_MEDIASOURCE_PLUGIN_FLAGS;

typedef 
enum _MF_MEDIASOURCE_DATAPARSER_STATUSFLAGS
    {	DATAPARSER_STATUSFLAG_REACHEDEND	= 0x1,
	DATAPARSER_STATUSFLAG_NONFATAL_ERROR	= 0x2,
	DATAPARSER_STATUSFLAG_FORMAT_CHANGE	= 0x4
    } 	MF_MEDIASOURCE_DATAPARSER_STATUSFLAGS;

typedef struct _MF_MEDIASOURCE_PLUGIN_STREAM_BUFFER_STATE
    {
    DWORD dwStreamId;
    BOOL fIsLow;
    } 	MF_MEDIASOURCE_PLUGIN_STREAM_BUFFER_STATE;

EXTERN_GUID( MF_TIME_FORMAT_BYTESTREAM_OFFSET, 0xE7378117, 0xA4A8, 0x4D6C, 0x8C, 0x63, 0xDF, 0xDB, 0x57, 0x26, 0x57, 0xCA );


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0082_v0_0_s_ifspec;

#ifndef __IMFSourceHeaderParserPlugin_INTERFACE_DEFINED__
#define __IMFSourceHeaderParserPlugin_INTERFACE_DEFINED__

/* interface IMFSourceHeaderParserPlugin */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFSourceHeaderParserPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("030C27D4-7AB9-462A-ADE2-EAC788549DB7")
    IMFSourceHeaderParserPlugin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseHeader( 
            /* [annotation][in] */ 
            __in  QWORD qwFileLength,
            /* [annotation][in] */ 
            __in  IMFMediaBuffer *pMediaBuffer,
            /* [annotation][in] */ 
            __in  QWORD qwByteStreamOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwNextByteStreamOffset,
            /* [annotation][out] */ 
            __out  BOOL *pfNeedMoreData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [annotation][out] */ 
            __out  DWORD *pdwCharacteristics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GeneratePresentationDescriptor( 
            /* [annotation][out] */ 
            __out  IMFPresentationDescriptor **ppPD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSourceHeaderParserPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFSourceHeaderParserPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFSourceHeaderParserPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFSourceHeaderParserPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseHeader )( 
            IMFSourceHeaderParserPlugin * This,
            /* [annotation][in] */ 
            __in  QWORD qwFileLength,
            /* [annotation][in] */ 
            __in  IMFMediaBuffer *pMediaBuffer,
            /* [annotation][in] */ 
            __in  QWORD qwByteStreamOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwNextByteStreamOffset,
            /* [annotation][out] */ 
            __out  BOOL *pfNeedMoreData);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            IMFSourceHeaderParserPlugin * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *GeneratePresentationDescriptor )( 
            IMFSourceHeaderParserPlugin * This,
            /* [annotation][out] */ 
            __out  IMFPresentationDescriptor **ppPD);
        
        END_INTERFACE
    } IMFSourceHeaderParserPluginVtbl;

    interface IMFSourceHeaderParserPlugin
    {
        CONST_VTBL struct IMFSourceHeaderParserPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSourceHeaderParserPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSourceHeaderParserPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSourceHeaderParserPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSourceHeaderParserPlugin_ParseHeader(This,qwFileLength,pMediaBuffer,qwByteStreamOffset,pqwNextByteStreamOffset,pfNeedMoreData)	\
    ( (This)->lpVtbl -> ParseHeader(This,qwFileLength,pMediaBuffer,qwByteStreamOffset,pqwNextByteStreamOffset,pfNeedMoreData) ) 

#define IMFSourceHeaderParserPlugin_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#define IMFSourceHeaderParserPlugin_GeneratePresentationDescriptor(This,ppPD)	\
    ( (This)->lpVtbl -> GeneratePresentationDescriptor(This,ppPD) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFSourceHeaderParserPlugin_INTERFACE_DEFINED__ */


#ifndef __IMFSourceIndexParserPlugin_INTERFACE_DEFINED__
#define __IMFSourceIndexParserPlugin_INTERFACE_DEFINED__

/* interface IMFSourceIndexParserPlugin */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFSourceIndexParserPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3133E934-0981-40CD-9CE8-461BC0E414F0")
    IMFSourceIndexParserPlugin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIndexed( 
            /* [annotation][out] */ 
            __out  BOOL *pfIndexed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIndexLoaded( 
            /* [annotation][in] */ 
            __in  const GUID *pguidTimeFormat,
            /* [annotation][in] */ 
            __in  const PROPVARIANT *pvarStartPosition,
            /* [annotation][out] */ 
            __out  BOOL *pfLoaded,
            /* [annotation][out] */ 
            __out  QWORD *pqwOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseIndex( 
            /* [annotation][in] */ 
            __in  IMFMediaBuffer *pMediaBuffer,
            /* [annotation][in] */ 
            __in  QWORD qwByteStreamOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwNextByteStreamOffset,
            /* [annotation][out] */ 
            __out  BOOL *pfNeedMoreData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportsTimeFormat( 
            /* [annotation][in] */ 
            __in  const GUID *pguidTimeFormat,
            /* [annotation][out] */ 
            __out  BOOL *pfSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffsetForStartPosition( 
            /* [annotation][in] */ 
            __in  const GUID *pguidTimeFormat,
            /* [annotation][in] */ 
            __in  const PROPVARIANT *pvarStartPosition,
            /* [annotation][in] */ 
            __in  DWORD dwFlags,
            /* [annotation][out] */ 
            __out  QWORD *pqwOffset,
            /* [annotation][out] */ 
            __out  MFTIME *phnsApproxStartTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSourceIndexParserPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFSourceIndexParserPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFSourceIndexParserPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFSourceIndexParserPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsIndexed )( 
            IMFSourceIndexParserPlugin * This,
            /* [annotation][out] */ 
            __out  BOOL *pfIndexed);
        
        HRESULT ( STDMETHODCALLTYPE *IsIndexLoaded )( 
            IMFSourceIndexParserPlugin * This,
            /* [annotation][in] */ 
            __in  const GUID *pguidTimeFormat,
            /* [annotation][in] */ 
            __in  const PROPVARIANT *pvarStartPosition,
            /* [annotation][out] */ 
            __out  BOOL *pfLoaded,
            /* [annotation][out] */ 
            __out  QWORD *pqwOffset);
        
        HRESULT ( STDMETHODCALLTYPE *ParseIndex )( 
            IMFSourceIndexParserPlugin * This,
            /* [annotation][in] */ 
            __in  IMFMediaBuffer *pMediaBuffer,
            /* [annotation][in] */ 
            __in  QWORD qwByteStreamOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwNextByteStreamOffset,
            /* [annotation][out] */ 
            __out  BOOL *pfNeedMoreData);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsTimeFormat )( 
            IMFSourceIndexParserPlugin * This,
            /* [annotation][in] */ 
            __in  const GUID *pguidTimeFormat,
            /* [annotation][out] */ 
            __out  BOOL *pfSupported);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffsetForStartPosition )( 
            IMFSourceIndexParserPlugin * This,
            /* [annotation][in] */ 
            __in  const GUID *pguidTimeFormat,
            /* [annotation][in] */ 
            __in  const PROPVARIANT *pvarStartPosition,
            /* [annotation][in] */ 
            __in  DWORD dwFlags,
            /* [annotation][out] */ 
            __out  QWORD *pqwOffset,
            /* [annotation][out] */ 
            __out  MFTIME *phnsApproxStartTime);
        
        END_INTERFACE
    } IMFSourceIndexParserPluginVtbl;

    interface IMFSourceIndexParserPlugin
    {
        CONST_VTBL struct IMFSourceIndexParserPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSourceIndexParserPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSourceIndexParserPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSourceIndexParserPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSourceIndexParserPlugin_IsIndexed(This,pfIndexed)	\
    ( (This)->lpVtbl -> IsIndexed(This,pfIndexed) ) 

#define IMFSourceIndexParserPlugin_IsIndexLoaded(This,pguidTimeFormat,pvarStartPosition,pfLoaded,pqwOffset)	\
    ( (This)->lpVtbl -> IsIndexLoaded(This,pguidTimeFormat,pvarStartPosition,pfLoaded,pqwOffset) ) 

#define IMFSourceIndexParserPlugin_ParseIndex(This,pMediaBuffer,qwByteStreamOffset,pqwNextByteStreamOffset,pfNeedMoreData)	\
    ( (This)->lpVtbl -> ParseIndex(This,pMediaBuffer,qwByteStreamOffset,pqwNextByteStreamOffset,pfNeedMoreData) ) 

#define IMFSourceIndexParserPlugin_SupportsTimeFormat(This,pguidTimeFormat,pfSupported)	\
    ( (This)->lpVtbl -> SupportsTimeFormat(This,pguidTimeFormat,pfSupported) ) 

#define IMFSourceIndexParserPlugin_GetOffsetForStartPosition(This,pguidTimeFormat,pvarStartPosition,dwFlags,pqwOffset,phnsApproxStartTime)	\
    ( (This)->lpVtbl -> GetOffsetForStartPosition(This,pguidTimeFormat,pvarStartPosition,dwFlags,pqwOffset,phnsApproxStartTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFSourceIndexParserPlugin_INTERFACE_DEFINED__ */


#ifndef __IMFSourceDataParserPlugin_INTERFACE_DEFINED__
#define __IMFSourceDataParserPlugin_INTERFACE_DEFINED__

/* interface IMFSourceDataParserPlugin */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFSourceDataParserPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B929D2DC-9BC0-4027-A57C-481CEE715ADB")
    IMFSourceDataParserPlugin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStreamSelection( 
            /* [annotation][in] */ 
            __in  IMFPresentationDescriptor *pPD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [annotation][in] */ 
            __in  DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataLocation( 
            /* [annotation][out] */ 
            __out  QWORD *pqwByteStreamOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseData( 
            /* [annotation][in] */ 
            __in  IMFMediaBuffer *pIBuffer,
            /* [annotation][in] */ 
            __in  QWORD qwByteStreamOffset,
            /* [annotation][in] */ 
            __in  DWORD dwNumStreams,
            /* [annotation][size_is][in] */ 
            __in_ecount(dwNumStreams)  MF_MEDIASOURCE_PLUGIN_STREAM_BUFFER_STATE *pStreamBufferState,
            /* [annotation][out] */ 
            __out  QWORD *pqwNextByteStreamOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSample( 
            /* [annotation][out] */ 
            __out  DWORD *pdwStatusFlags,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamId,
            /* [annotation][out] */ 
            __out  IMFSample **ppSample,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSourceDataParserPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFSourceDataParserPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFSourceDataParserPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFSourceDataParserPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamSelection )( 
            IMFSourceDataParserPlugin * This,
            /* [annotation][in] */ 
            __in  IMFPresentationDescriptor *pPD);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IMFSourceDataParserPlugin * This,
            /* [annotation][in] */ 
            __in  DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IMFSourceDataParserPlugin * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataLocation )( 
            IMFSourceDataParserPlugin * This,
            /* [annotation][out] */ 
            __out  QWORD *pqwByteStreamOffset,
            /* [annotation][out] */ 
            __out  QWORD *pqwLength);
        
        HRESULT ( STDMETHODCALLTYPE *ParseData )( 
            IMFSourceDataParserPlugin * This,
            /* [annotation][in] */ 
            __in  IMFMediaBuffer *pIBuffer,
            /* [annotation][in] */ 
            __in  QWORD qwByteStreamOffset,
            /* [annotation][in] */ 
            __in  DWORD dwNumStreams,
            /* [annotation][size_is][in] */ 
            __in_ecount(dwNumStreams)  MF_MEDIASOURCE_PLUGIN_STREAM_BUFFER_STATE *pStreamBufferState,
            /* [annotation][out] */ 
            __out  QWORD *pqwNextByteStreamOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSample )( 
            IMFSourceDataParserPlugin * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwStatusFlags,
            /* [annotation][out] */ 
            __out  DWORD *pdwStreamId,
            /* [annotation][out] */ 
            __out  IMFSample **ppSample,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMFSourceDataParserPlugin * This);
        
        END_INTERFACE
    } IMFSourceDataParserPluginVtbl;

    interface IMFSourceDataParserPlugin
    {
        CONST_VTBL struct IMFSourceDataParserPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSourceDataParserPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSourceDataParserPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSourceDataParserPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSourceDataParserPlugin_SetStreamSelection(This,pPD)	\
    ( (This)->lpVtbl -> SetStreamSelection(This,pPD) ) 

#define IMFSourceDataParserPlugin_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#define IMFSourceDataParserPlugin_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define IMFSourceDataParserPlugin_GetDataLocation(This,pqwByteStreamOffset,pqwLength)	\
    ( (This)->lpVtbl -> GetDataLocation(This,pqwByteStreamOffset,pqwLength) ) 

#define IMFSourceDataParserPlugin_ParseData(This,pIBuffer,qwByteStreamOffset,dwNumStreams,pStreamBufferState,pqwNextByteStreamOffset)	\
    ( (This)->lpVtbl -> ParseData(This,pIBuffer,qwByteStreamOffset,dwNumStreams,pStreamBufferState,pqwNextByteStreamOffset) ) 

#define IMFSourceDataParserPlugin_GetNextSample(This,pdwStatusFlags,pdwStreamId,ppSample,ppMediaType)	\
    ( (This)->lpVtbl -> GetNextSample(This,pdwStatusFlags,pdwStreamId,ppSample,ppMediaType) ) 

#define IMFSourceDataParserPlugin_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFSourceDataParserPlugin_INTERFACE_DEFINED__ */


#ifndef __IMFMP3ContentInfo_INTERFACE_DEFINED__
#define __IMFMP3ContentInfo_INTERFACE_DEFINED__

/* interface IMFMP3ContentInfo */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFMP3ContentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cc6c6949-c8ec-4def-911c-67098f786aa2")
    IMFMP3ContentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHeaderSize( 
            /* [out] */ DWORD *pcbHeaderSize) = 0;
        
        virtual BOOL STDMETHODCALLTYPE HasFooter( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateHeader( 
            /* [annotation][out][in] */ 
            __inout_opt  IMFMediaBuffer *pMediaBuffer,
            /* [annotation][out] */ 
            __out  DWORD *pcbHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateFooter( 
            /* [annotation][out][in] */ 
            __inout  IMFMediaBuffer *pMediaBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMP3ContentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMP3ContentInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMP3ContentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMP3ContentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHeaderSize )( 
            IMFMP3ContentInfo * This,
            /* [out] */ DWORD *pcbHeaderSize);
        
        BOOL ( STDMETHODCALLTYPE *HasFooter )( 
            IMFMP3ContentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateHeader )( 
            IMFMP3ContentInfo * This,
            /* [annotation][out][in] */ 
            __inout_opt  IMFMediaBuffer *pMediaBuffer,
            /* [annotation][out] */ 
            __out  DWORD *pcbHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateFooter )( 
            IMFMP3ContentInfo * This,
            /* [annotation][out][in] */ 
            __inout  IMFMediaBuffer *pMediaBuffer);
        
        END_INTERFACE
    } IMFMP3ContentInfoVtbl;

    interface IMFMP3ContentInfo
    {
        CONST_VTBL struct IMFMP3ContentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMP3ContentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMP3ContentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMP3ContentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMP3ContentInfo_GetHeaderSize(This,pcbHeaderSize)	\
    ( (This)->lpVtbl -> GetHeaderSize(This,pcbHeaderSize) ) 

#define IMFMP3ContentInfo_HasFooter(This)	\
    ( (This)->lpVtbl -> HasFooter(This) ) 

#define IMFMP3ContentInfo_GenerateHeader(This,pMediaBuffer,pcbHeader)	\
    ( (This)->lpVtbl -> GenerateHeader(This,pMediaBuffer,pcbHeader) ) 

#define IMFMP3ContentInfo_GenerateFooter(This,pMediaBuffer)	\
    ( (This)->lpVtbl -> GenerateFooter(This,pMediaBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMP3ContentInfo_INTERFACE_DEFINED__ */



#ifndef __MFInternalLib_LIBRARY_DEFINED__
#define __MFInternalLib_LIBRARY_DEFINED__

/* library MFInternalLib */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_MFInternalLib;

EXTERN_C const CLSID CLSID_WMDRMContext;

#ifdef __cplusplus

class DECLSPEC_UUID("7f5d25f8-78a5-49a8-a33c-2c0e11831c66")
WMDRMContext;
#endif

EXTERN_C const CLSID CLSID_MFContentProtectionManager;

#ifdef __cplusplus

class DECLSPEC_UUID("7f5d25f9-78a5-49a8-a33c-2c0e11831c66")
MFContentProtectionManager;
#endif

EXTERN_C const CLSID CLSID_MFContentEnabler;

#ifdef __cplusplus

class DECLSPEC_UUID("7f5d25fa-78a5-49a8-a33c-2c0e11831c66")
MFContentEnabler;
#endif

EXTERN_C const CLSID CLSID_COutputProfileMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("98CFCDB4-5977-4564-85B5-B2654A956FBB")
COutputProfileMgr;
#endif

EXTERN_C const CLSID CLSID_CDevProxy;

#ifdef __cplusplus

class DECLSPEC_UUID("8AC3587A-4AE7-42d8-99E0-0A6013EEF90F")
CDevProxy;
#endif
#endif /* __MFInternalLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_mfinternal_0000_0086 */
/* [local] */ 

EXTERN_C const DECLSPEC_SELECTANY GUID MF_TOPOLOGY_ENABLE_HARDWARE_BRANCH_LOADER = { 0xf297151b, 0x1410, 0x4936, { 0xa1, 0x11, 0x6d, 0x10, 0x3a, 0x46, 0x1f, 0x34 } };
 HRESULT WINAPI CreateXCodeVideoProc( 
 IMFTransform** ppTransform ); 


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0086_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0086_v0_0_s_ifspec;

#ifndef __IMFTransformFieldOfUse_INTERFACE_DEFINED__
#define __IMFTransformFieldOfUse_INTERFACE_DEFINED__

/* interface IMFTransformFieldOfUse */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFTransformFieldOfUse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F2B8556-0DBC-41a9-8C10-E7FCAEC4DBBE")
    IMFTransformFieldOfUse : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIdentity( 
            /* [out] */ GUID *pguidLicensorID,
            /* [size_is][size_is][out] */ BYTE **ppbEphemeron,
            /* [out] */ DWORD *pcbEphemeron) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnlockCertificate( 
            /* [size_is][in] */ BYTE *pbCertificate,
            /* [in] */ DWORD cbCertificate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFTransformFieldOfUseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFTransformFieldOfUse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFTransformFieldOfUse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFTransformFieldOfUse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentity )( 
            IMFTransformFieldOfUse * This,
            /* [out] */ GUID *pguidLicensorID,
            /* [size_is][size_is][out] */ BYTE **ppbEphemeron,
            /* [out] */ DWORD *pcbEphemeron);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnlockCertificate )( 
            IMFTransformFieldOfUse * This,
            /* [size_is][in] */ BYTE *pbCertificate,
            /* [in] */ DWORD cbCertificate);
        
        END_INTERFACE
    } IMFTransformFieldOfUseVtbl;

    interface IMFTransformFieldOfUse
    {
        CONST_VTBL struct IMFTransformFieldOfUseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFTransformFieldOfUse_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFTransformFieldOfUse_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFTransformFieldOfUse_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFTransformFieldOfUse_GetIdentity(This,pguidLicensorID,ppbEphemeron,pcbEphemeron)	\
    ( (This)->lpVtbl -> GetIdentity(This,pguidLicensorID,ppbEphemeron,pcbEphemeron) ) 

#define IMFTransformFieldOfUse_SetUnlockCertificate(This,pbCertificate,cbCertificate)	\
    ( (This)->lpVtbl -> SetUnlockCertificate(This,pbCertificate,cbCertificate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFTransformFieldOfUse_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfinternal_0000_0087 */
/* [local] */ 

HRESULT MFCreateFieldOfUseMFTUnlock (
                                 __in_bcount(cbCertificates)             const BYTE              *pbCertificates, 
                                 __in                                    const DWORD              cbCertificates,
                                 __in_bcount_opt(cbPrivateKeyLicensee)   const BYTE              *pbPrivateKeyLicensee, 
                                 __in                                    const DWORD              cbPrivateKeyLicensee,
                                 __deref_out                             IMFFieldOfUseMFTUnlock **ppUnlock
                                 );
HRESULT MFVerifyCertificate (
                             __in                                 REFGUID     guidLicensorID,  
                             __in                                 DWORD       dwBlobVersion,
                             __in_bcount_opt(cbEphemeron)         const BYTE *pbEphemeron,
                             __in                                 DWORD       cbEphemeron,
                             __in_bcount(cbCertificate)           const BYTE *pbCertificate,
                             __in                                 DWORD       cbCertificate,
                             __in_bcount_opt(cbPublicKeyLicensor) const BYTE *pbPublicKeyLicensor, 
                             __in                                 const DWORD cbPublicKeyLicensor
                             );
HRESULT MFCreateEphemeron(
	__deref_out_bcount(*pcbEphemeron)   BYTE **ppbEphemeron,
    __out                               DWORD *pcbEphemeron
     );
STDAPI GetTranscodeComponentCreator( 
__out IMFComponentCreator** ppTranscodeComponentCreator ); 
DEFINE_GUID( CLSID_TranscodeSinkActivate, 

0x5a3b0a4a, 0x56a6, 0x478b, 0xa1, 0x36, 0x63, 0xeb, 0x2f, 0xe3, 0x6c, 0xd4 );

STDAPI MFCreateMFMetadataOnPropertyStore( 
    __in IPropertyStore *pStore, 
    __out IMFMetadataProvider ** ppProvider ); 


typedef struct
{
    DWORD dwSrcStreamID;
    DWORD dwDstStreamID;
} STREAMID_MAP;


STDAPI MFCopyMFMetadata( 
    __in IMFMetadataProvider *pSrc, 
    __in IMFMetadataProvider *pSink, 
    __in_ecount(cStreams) STREAMID_MAP *pMapping, 
    __in DWORD cStreams );


STDAPI MFCopyPropertyStore(
    __in IPropertyStore *pSrc,
    __in IPropertyStore *pSink );


STDAPI MFCreateVideoSampleAllocator(
    __in REFIID riid,
    __deref_out void** ppSampleAllocator);

EXTERN_GUID( MF_DEVSOURCE_ATTRIBUTE_USE_STREAM_TIME, 0x5b61b815, 0xebfa, 0x4d06, 0xad, 0x16, 0xb1, 0xf5, 0x15, 0x3, 0x2b, 0x79);


extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0087_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfinternal_0000_0087_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mferror.h ===
/*++

  Microsoft Windows Media Foundation
  Copyright (C) Microsoft Corporation. All rights reserved.

Module Name:

    mferror.mc

Abstract:

    Definitions for MediaFoundation events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the mferror.h file

 After making changes here, update the test error table by going to a machine with both dev and test and:
   1) Go to testsrc\multimediatest\mf\test\common\helper\errcodehelper\errormap\header\daytona
   2) check out guid*.c and errors.h
   3) Do a "Build -Z -clean"
   4) do a "build -cCZ"
   5) Check in the new guid*.c and errors.h files, which should contain the new change (probably a good idea to check before checking in)
   Contact PWinkler with questions/problems

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 RANGES

 14000 - 14999 = General Media Foundation errors

 15000 - 15999 = ASF parsing errors

 16000 - 16999 = Media Source errors

 17000 - 17999 = MEDIAFOUNDATION Network Error Events

 18000 - 18999 = MEDIAFOUNDATION WMContainer Error Events

 19000 - 19999 = MEDIAFOUNDATION Media Sink Error Events

 20000 - 20999 = Renderer errors

 21000 - 21999 = Topology Errors

 25000 - 25999 = Timeline Errors

 26000 - 26999 = Unused

 28000 - 28999 = Transform errors

 29000 - 29999 = Content Protection errors
 
 40000 - 40999 = Clock errors
 
 41000 - 41999 = MF Quality Management Errors

 42000 - 42999 = MF Transcode API Errors

**************************** READ ME ******************************************

--*/

#ifndef _MFERROR_H
#define _MFERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Success Events
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Warning Events
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Error Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_MF_WIN32                0x7
#define FACILITY_MF                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MF_E_PLATFORM_NOT_INITIALIZED
//
// MessageText:
//
// Platform not initialized. Please call MFStartup().%0
//
#define MF_E_PLATFORM_NOT_INITIALIZED    _HRESULT_TYPEDEF_(0xC00D36B0L)

//
// MessageId: MF_E_BUFFERTOOSMALL
//
// MessageText:
//
// The buffer was too small to carry out the requested action.%0
//
#define MF_E_BUFFERTOOSMALL              _HRESULT_TYPEDEF_(0xC00D36B1L)

//
// MessageId: MF_E_INVALIDREQUEST
//
// MessageText:
//
// The request is invalid in the current state.%0
//
#define MF_E_INVALIDREQUEST              _HRESULT_TYPEDEF_(0xC00D36B2L)

//
// MessageId: MF_E_INVALIDSTREAMNUMBER
//
// MessageText:
//
// The stream number provided was invalid.%0
//
#define MF_E_INVALIDSTREAMNUMBER         _HRESULT_TYPEDEF_(0xC00D36B3L)

//
// MessageId: MF_E_INVALIDMEDIATYPE
//
// MessageText:
//
// The data specified for the media type is invalid, inconsistent, or not supported by this object.%0
//
#define MF_E_INVALIDMEDIATYPE            _HRESULT_TYPEDEF_(0xC00D36B4L)

//
// MessageId: MF_E_NOTACCEPTING
//
// MessageText:
//
// The callee is currently not accepting further input.%0
//
#define MF_E_NOTACCEPTING                _HRESULT_TYPEDEF_(0xC00D36B5L)

//
// MessageId: MF_E_NOT_INITIALIZED
//
// MessageText:
//
// This object needs to be initialized before the requested operation can be carried out.%0
//
#define MF_E_NOT_INITIALIZED             _HRESULT_TYPEDEF_(0xC00D36B6L)

//
// MessageId: MF_E_UNSUPPORTED_REPRESENTATION
//
// MessageText:
//
// The requested representation is not supported by this object.%0
//
#define MF_E_UNSUPPORTED_REPRESENTATION  _HRESULT_TYPEDEF_(0xC00D36B7L)

//
// MessageId: MF_E_NO_MORE_TYPES
//
// MessageText:
//
// An object ran out of media types to suggest therefore the requested chain of streaming objects cannot be completed.%0
//
#define MF_E_NO_MORE_TYPES               _HRESULT_TYPEDEF_(0xC00D36B9L)

//
// MessageId: MF_E_UNSUPPORTED_SERVICE
//
// MessageText:
//
// The object does not support the specified service.%0
//
#define MF_E_UNSUPPORTED_SERVICE         _HRESULT_TYPEDEF_(0xC00D36BAL)

//
// MessageId: MF_E_UNEXPECTED
//
// MessageText:
//
// An unexpected error has occurred in the operation requested.%0
//
#define MF_E_UNEXPECTED                  _HRESULT_TYPEDEF_(0xC00D36BBL)

//
// MessageId: MF_E_INVALIDNAME
//
// MessageText:
//
// Invalid name.%0
//
#define MF_E_INVALIDNAME                 _HRESULT_TYPEDEF_(0xC00D36BCL)

//
// MessageId: MF_E_INVALIDTYPE
//
// MessageText:
//
// Invalid type.%0
//
#define MF_E_INVALIDTYPE                 _HRESULT_TYPEDEF_(0xC00D36BDL)

//
// MessageId: MF_E_INVALID_FILE_FORMAT
//
// MessageText:
//
// The file does not conform to the relevant file format specification.
//
#define MF_E_INVALID_FILE_FORMAT         _HRESULT_TYPEDEF_(0xC00D36BEL)

//
// MessageId: MF_E_INVALIDINDEX
//
// MessageText:
//
// Invalid index.%0
//
#define MF_E_INVALIDINDEX                _HRESULT_TYPEDEF_(0xC00D36BFL)

//
// MessageId: MF_E_INVALID_TIMESTAMP
//
// MessageText:
//
// An invalid timestamp was given.%0
//
#define MF_E_INVALID_TIMESTAMP           _HRESULT_TYPEDEF_(0xC00D36C0L)

//
// MessageId: MF_E_UNSUPPORTED_SCHEME
//
// MessageText:
//
// The scheme of the given URL is unsupported.%0
//
#define MF_E_UNSUPPORTED_SCHEME          _HRESULT_TYPEDEF_(0xC00D36C3L)

//
// MessageId: MF_E_UNSUPPORTED_BYTESTREAM_TYPE
//
// MessageText:
//
// The byte stream type of the given URL is unsupported.%0
//
#define MF_E_UNSUPPORTED_BYTESTREAM_TYPE _HRESULT_TYPEDEF_(0xC00D36C4L)

//
// MessageId: MF_E_UNSUPPORTED_TIME_FORMAT
//
// MessageText:
//
// The given time format is unsupported.%0
//
#define MF_E_UNSUPPORTED_TIME_FORMAT     _HRESULT_TYPEDEF_(0xC00D36C5L)

//
// MessageId: MF_E_NO_SAMPLE_TIMESTAMP
//
// MessageText:
//
// The Media Sample does not have a timestamp.%0
//
#define MF_E_NO_SAMPLE_TIMESTAMP         _HRESULT_TYPEDEF_(0xC00D36C8L)

//
// MessageId: MF_E_NO_SAMPLE_DURATION
//
// MessageText:
//
// The Media Sample does not have a duration.%0
//
#define MF_E_NO_SAMPLE_DURATION          _HRESULT_TYPEDEF_(0xC00D36C9L)

//
// MessageId: MF_E_INVALID_STREAM_DATA
//
// MessageText:
//
// The request failed because the data in the stream is corrupt.%0\n.
//
#define MF_E_INVALID_STREAM_DATA         _HRESULT_TYPEDEF_(0xC00D36CBL)

//
// MessageId: MF_E_RT_UNAVAILABLE
//
// MessageText:
//
// Real time services are not available.%0
//
#define MF_E_RT_UNAVAILABLE              _HRESULT_TYPEDEF_(0xC00D36CFL)

//
// MessageId: MF_E_UNSUPPORTED_RATE
//
// MessageText:
//
// The specified rate is not supported.%0
//
#define MF_E_UNSUPPORTED_RATE            _HRESULT_TYPEDEF_(0xC00D36D0L)

//
// MessageId: MF_E_THINNING_UNSUPPORTED
//
// MessageText:
//
// This component does not support stream-thinning.%0
//
#define MF_E_THINNING_UNSUPPORTED        _HRESULT_TYPEDEF_(0xC00D36D1L)

//
// MessageId: MF_E_REVERSE_UNSUPPORTED
//
// MessageText:
//
// The call failed because no reverse playback rates are available.%0
//
#define MF_E_REVERSE_UNSUPPORTED         _HRESULT_TYPEDEF_(0xC00D36D2L)

//
// MessageId: MF_E_UNSUPPORTED_RATE_TRANSITION
//
// MessageText:
//
// The requested rate transition cannot occur in the current state.%0
//
#define MF_E_UNSUPPORTED_RATE_TRANSITION _HRESULT_TYPEDEF_(0xC00D36D3L)

//
// MessageId: MF_E_RATE_CHANGE_PREEMPTED
//
// MessageText:
//
// The requested rate change has been pre-empted and will not occur.%0
//
#define MF_E_RATE_CHANGE_PREEMPTED       _HRESULT_TYPEDEF_(0xC00D36D4L)

//
// MessageId: MF_E_NOT_FOUND
//
// MessageText:
//
// The specified object or value does not exist.%0
//
#define MF_E_NOT_FOUND                   _HRESULT_TYPEDEF_(0xC00D36D5L)

//
// MessageId: MF_E_NOT_AVAILABLE
//
// MessageText:
//
// The requested value is not available.%0
//
#define MF_E_NOT_AVAILABLE               _HRESULT_TYPEDEF_(0xC00D36D6L)

//
// MessageId: MF_E_NO_CLOCK
//
// MessageText:
//
// The specified operation requires a clock and no clock is available.%0
//
#define MF_E_NO_CLOCK                    _HRESULT_TYPEDEF_(0xC00D36D7L)

//
// MessageId: MF_S_MULTIPLE_BEGIN
//
// MessageText:
//
// This callback and state had already been passed in to this event generator earlier.%0
//
#define MF_S_MULTIPLE_BEGIN              _HRESULT_TYPEDEF_(0x000D36D8L)

//
// MessageId: MF_E_MULTIPLE_BEGIN
//
// MessageText:
//
// This callback has already been passed in to this event generator.%0
//
#define MF_E_MULTIPLE_BEGIN              _HRESULT_TYPEDEF_(0xC00D36D9L)

//
// MessageId: MF_E_MULTIPLE_SUBSCRIBERS
//
// MessageText:
//
// Some component is already listening to events on this event generator.%0
//
#define MF_E_MULTIPLE_SUBSCRIBERS        _HRESULT_TYPEDEF_(0xC00D36DAL)

//
// MessageId: MF_E_TIMER_ORPHANED
//
// MessageText:
//
// This timer was orphaned before its callback time arrived.%0
//
#define MF_E_TIMER_ORPHANED              _HRESULT_TYPEDEF_(0xC00D36DBL)

//
// MessageId: MF_E_STATE_TRANSITION_PENDING
//
// MessageText:
//
// A state transition is already pending.%0
//
#define MF_E_STATE_TRANSITION_PENDING    _HRESULT_TYPEDEF_(0xC00D36DCL)

//
// MessageId: MF_E_UNSUPPORTED_STATE_TRANSITION
//
// MessageText:
//
// The requested state transition is unsupported.%0
//
#define MF_E_UNSUPPORTED_STATE_TRANSITION _HRESULT_TYPEDEF_(0xC00D36DDL)

//
// MessageId: MF_E_UNRECOVERABLE_ERROR_OCCURRED
//
// MessageText:
//
// An unrecoverable error has occurred.%0
//
#define MF_E_UNRECOVERABLE_ERROR_OCCURRED _HRESULT_TYPEDEF_(0xC00D36DEL)

//
// MessageId: MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS
//
// MessageText:
//
// The provided sample has too many buffers.%0
//
#define MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS _HRESULT_TYPEDEF_(0xC00D36DFL)

//
// MessageId: MF_E_SAMPLE_NOT_WRITABLE
//
// MessageText:
//
// The provided sample is not writable.%0
//
#define MF_E_SAMPLE_NOT_WRITABLE         _HRESULT_TYPEDEF_(0xC00D36E0L)

//
// MessageId: MF_E_INVALID_KEY
//
// MessageText:
//
// The specified key is not valid.
//
#define MF_E_INVALID_KEY                 _HRESULT_TYPEDEF_(0xC00D36E2L)

//
// MessageId: MF_E_BAD_STARTUP_VERSION
//
// MessageText:
//
// You are calling MFStartup with the wrong MF_VERSION. Mismatched bits?
//
#define MF_E_BAD_STARTUP_VERSION         _HRESULT_TYPEDEF_(0xC00D36E3L)

//
// MessageId: MF_E_UNSUPPORTED_CAPTION
//
// MessageText:
//
// The caption of the given URL is unsupported.%0
//
#define MF_E_UNSUPPORTED_CAPTION         _HRESULT_TYPEDEF_(0xC00D36E4L)

//
// MessageId: MF_E_INVALID_POSITION
//
// MessageText:
//
// The operation on the current offset is not permitted.%0
//
#define MF_E_INVALID_POSITION            _HRESULT_TYPEDEF_(0xC00D36E5L)

//
// MessageId: MF_E_ATTRIBUTENOTFOUND
//
// MessageText:
//
// The requested attribute was not found.%0
//
#define MF_E_ATTRIBUTENOTFOUND           _HRESULT_TYPEDEF_(0xC00D36E6L)

//
// MessageId: MF_E_PROPERTY_TYPE_NOT_ALLOWED
//
// MessageText:
//
// The specified property type is not allowed in this context.%0
//
#define MF_E_PROPERTY_TYPE_NOT_ALLOWED   _HRESULT_TYPEDEF_(0xC00D36E7L)

//
// MessageId: MF_E_PROPERTY_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The specified property type is not supported.%0
//
#define MF_E_PROPERTY_TYPE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D36E8L)

//
// MessageId: MF_E_PROPERTY_EMPTY
//
// MessageText:
//
// The specified property is empty.%0
//
#define MF_E_PROPERTY_EMPTY              _HRESULT_TYPEDEF_(0xC00D36E9L)

//
// MessageId: MF_E_PROPERTY_NOT_EMPTY
//
// MessageText:
//
// The specified property is not empty.%0
//
#define MF_E_PROPERTY_NOT_EMPTY          _HRESULT_TYPEDEF_(0xC00D36EAL)

//
// MessageId: MF_E_PROPERTY_VECTOR_NOT_ALLOWED
//
// MessageText:
//
// The vector property specified is not allowed in this context.%0
//
#define MF_E_PROPERTY_VECTOR_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D36EBL)

//
// MessageId: MF_E_PROPERTY_VECTOR_REQUIRED
//
// MessageText:
//
// A vector property is required in this context.%0
//
#define MF_E_PROPERTY_VECTOR_REQUIRED    _HRESULT_TYPEDEF_(0xC00D36ECL)

//
// MessageId: MF_E_OPERATION_CANCELLED
//
// MessageText:
//
// The operation is cancelled.%0
//
#define MF_E_OPERATION_CANCELLED         _HRESULT_TYPEDEF_(0xC00D36EDL)

//
// MessageId: MF_E_BYTESTREAM_NOT_SEEKABLE
//
// MessageText:
//
// The provided bytestream was expected to be seekable and it is not.%0
//
#define MF_E_BYTESTREAM_NOT_SEEKABLE     _HRESULT_TYPEDEF_(0xC00D36EEL)

//
// MessageId: MF_E_DISABLED_IN_SAFEMODE
//
// MessageText:
//
// The Media Foundation platform is disabled when the system is running in Safe Mode.%0
//
#define MF_E_DISABLED_IN_SAFEMODE        _HRESULT_TYPEDEF_(0xC00D36EFL)

//
// MessageId: MF_E_CANNOT_PARSE_BYTESTREAM
//
// MessageText:
//
// The Media Source could not parse the byte stream.%0
//
#define MF_E_CANNOT_PARSE_BYTESTREAM     _HRESULT_TYPEDEF_(0xC00D36F0L)

//
// MessageId: MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS
//
// MessageText:
//
// Mutually exclusive flags have been specified to source resolver. This flag combination is invalid.%0
//
#define MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS _HRESULT_TYPEDEF_(0xC00D36F1L)

//
// MessageId: MF_E_MEDIAPROC_WRONGSTATE
//
// MessageText:
//
// MediaProc is in the wrong state%0
//
#define MF_E_MEDIAPROC_WRONGSTATE        _HRESULT_TYPEDEF_(0xC00D36F2L)

//
// MessageId: MF_E_RT_THROUGHPUT_NOT_AVAILABLE
//
// MessageText:
//
// Real time I/O service can not provide requested throughput.%0
//
#define MF_E_RT_THROUGHPUT_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D36F3L)

//
// MessageId: MF_E_RT_TOO_MANY_CLASSES
//
// MessageText:
//
// The workqueue cannot be registered with more classes.%0
//
#define MF_E_RT_TOO_MANY_CLASSES         _HRESULT_TYPEDEF_(0xC00D36F4L)

//
// MessageId: MF_E_RT_WOULDBLOCK
//
// MessageText:
//
// This operation cannot succeed because another thread owns this object.%0
//
#define MF_E_RT_WOULDBLOCK               _HRESULT_TYPEDEF_(0xC00D36F5L)

//
// MessageId: MF_E_NO_BITPUMP
//
// MessageText:
//
// Internal. Bitpump not found.%0
//
#define MF_E_NO_BITPUMP                  _HRESULT_TYPEDEF_(0xC00D36F6L)

//
// MessageId: MF_E_RT_OUTOFMEMORY
//
// MessageText:
//
// No more RT memory available.%0
//
#define MF_E_RT_OUTOFMEMORY              _HRESULT_TYPEDEF_(0xC00D36F7L)

//
// MessageId: MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED
//
// MessageText:
//
// An MMCSS class has not been set for this work queue.%0
//
#define MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED _HRESULT_TYPEDEF_(0xC00D36F8L)

//
// MessageId: MF_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// Insufficient memory for response.%0
//
#define MF_E_INSUFFICIENT_BUFFER         _HRESULT_TYPEDEF_(0xC00D7170L)

//
// MessageId: MF_E_CANNOT_CREATE_SINK
//
// MessageText:
//
// Activate failed to create mediasink. Call OutputNode::GetUINT32(MF_TOPONODE_MAJORTYPE) for more information. %0
//
#define MF_E_CANNOT_CREATE_SINK          _HRESULT_TYPEDEF_(0xC00D36FAL)

//
// MessageId: MF_E_BYTESTREAM_UNKNOWN_LENGTH
//
// MessageText:
//
// The length of the provided bytestream is unknown.%0
//
#define MF_E_BYTESTREAM_UNKNOWN_LENGTH   _HRESULT_TYPEDEF_(0xC00D36FBL)

//
// MessageId: MF_E_SESSION_PAUSEWHILESTOPPED
//
// MessageText:
//
// The media session cannot pause from a stopped state.%0
//
#define MF_E_SESSION_PAUSEWHILESTOPPED   _HRESULT_TYPEDEF_(0xC00D36FCL)

//
// MessageId: MF_S_ACTIVATE_REPLACED
//
// MessageText:
//
// The activate could not be created in the remote process for some reason it was replaced with empty one.%0
//
#define MF_S_ACTIVATE_REPLACED           _HRESULT_TYPEDEF_(0x000D36FDL)

//
// MessageId: MF_E_FORMAT_CHANGE_NOT_SUPPORTED
//
// MessageText:
//
// The data specified for the media type is supported, but would require a format change, which is not supported by this object.%0
//
#define MF_E_FORMAT_CHANGE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D36FEL)

//
// MessageId: MF_E_INVALID_WORKQUEUE
//
// MessageText:
//
// The operation failed because an invalid combination of workqueue ID and flags was specified.%0
//
#define MF_E_INVALID_WORKQUEUE           _HRESULT_TYPEDEF_(0xC00D36FFL)

//
// MessageId: MF_E_DRM_UNSUPPORTED
//
// MessageText:
//
// No DRM support is available.%0
//
#define MF_E_DRM_UNSUPPORTED             _HRESULT_TYPEDEF_(0xC00D3700L)

//
// MessageId: MF_E_UNAUTHORIZED
//
// MessageText:
//
// This operation is not authorized.%0
//
#define MF_E_UNAUTHORIZED                _HRESULT_TYPEDEF_(0xC00D3701L)

//
// MessageId: MF_E_OUT_OF_RANGE
//
// MessageText:
//
// The value is not in the specified or valid range.%0
//
#define MF_E_OUT_OF_RANGE                _HRESULT_TYPEDEF_(0xC00D3702L)

//
// MessageId: MF_E_INVALID_CODEC_MERIT
//
// MessageText:
//
// The registered codec merit is not valid.%0
//
#define MF_E_INVALID_CODEC_MERIT         _HRESULT_TYPEDEF_(0xC00D3703L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION ASF Parsing Informational Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_S_ASF_PARSEINPROGRESS
//
// MessageText:
//
// Parsing is still in progress and is not yet complete.%0
//
#define MF_S_ASF_PARSEINPROGRESS         _HRESULT_TYPEDEF_(0x400D3A98L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION ASF Parsing Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_ASF_PARSINGINCOMPLETE
//
// MessageText:
//
// Not enough data have been parsed to carry out the requested action.%0
//
#define MF_E_ASF_PARSINGINCOMPLETE       _HRESULT_TYPEDEF_(0xC00D3A98L)

//
// MessageId: MF_E_ASF_MISSINGDATA
//
// MessageText:
//
// There is a gap in the ASF data provided.%0
//
#define MF_E_ASF_MISSINGDATA             _HRESULT_TYPEDEF_(0xC00D3A99L)

//
// MessageId: MF_E_ASF_INVALIDDATA
//
// MessageText:
//
// The data provided are not valid ASF.%0
//
#define MF_E_ASF_INVALIDDATA             _HRESULT_TYPEDEF_(0xC00D3A9AL)

//
// MessageId: MF_E_ASF_OPAQUEPACKET
//
// MessageText:
//
// The packet is opaque, so the requested information cannot be returned.%0
//
#define MF_E_ASF_OPAQUEPACKET            _HRESULT_TYPEDEF_(0xC00D3A9BL)

//
// MessageId: MF_E_ASF_NOINDEX
//
// MessageText:
//
// The requested operation failed since there is no appropriate ASF index.%0
//
#define MF_E_ASF_NOINDEX                 _HRESULT_TYPEDEF_(0xC00D3A9CL)

//
// MessageId: MF_E_ASF_OUTOFRANGE
//
// MessageText:
//
// The value supplied is out of range for this operation.%0
//
#define MF_E_ASF_OUTOFRANGE              _HRESULT_TYPEDEF_(0xC00D3A9DL)

//
// MessageId: MF_E_ASF_INDEXNOTLOADED
//
// MessageText:
//
// The index entry requested needs to be loaded before it can be available.%0
//
#define MF_E_ASF_INDEXNOTLOADED          _HRESULT_TYPEDEF_(0xC00D3A9EL)    

//
// MessageId: MF_E_ASF_TOO_MANY_PAYLOADS
//
// MessageText:
//
// The packet has reached the maximum number of payloads.%0
//
#define MF_E_ASF_TOO_MANY_PAYLOADS       _HRESULT_TYPEDEF_(0xC00D3A9FL)    

//
// MessageId: MF_E_ASF_UNSUPPORTED_STREAM_TYPE
//
// MessageText:
//
// Stream type is not supported.%0
//
#define MF_E_ASF_UNSUPPORTED_STREAM_TYPE _HRESULT_TYPEDEF_(0xC00D3AA0L)    

//
// MessageId: MF_E_ASF_DROPPED_PACKET
//
// MessageText:
//
// One or more ASF packets were dropped.%0
//
#define MF_E_ASF_DROPPED_PACKET          _HRESULT_TYPEDEF_(0xC00D3AA1L)    


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Media Source Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_NO_EVENTS_AVAILABLE
//
// MessageText:
//
// There are no events available in the queue.%0
//
#define MF_E_NO_EVENTS_AVAILABLE         _HRESULT_TYPEDEF_(0xC00D3E80L)

//
// MessageId: MF_E_INVALID_STATE_TRANSITION
//
// MessageText:
//
// A media source cannot go from the stopped state to the paused state.%0
//
#define MF_E_INVALID_STATE_TRANSITION    _HRESULT_TYPEDEF_(0xC00D3E82L)

//
// MessageId: MF_E_END_OF_STREAM
//
// MessageText:
//
// The media stream cannot process any more samples because there are no more samples in the stream.%0
//
#define MF_E_END_OF_STREAM               _HRESULT_TYPEDEF_(0xC00D3E84L)

//
// MessageId: MF_E_SHUTDOWN
//
// MessageText:
//
// The request is invalid because Shutdown() has been called.%0
//
#define MF_E_SHUTDOWN                    _HRESULT_TYPEDEF_(0xC00D3E85L)

//
// MessageId: MF_E_MP3_NOTFOUND
//
// MessageText:
//
// The MP3 object was not found.%0
//
#define MF_E_MP3_NOTFOUND                _HRESULT_TYPEDEF_(0xC00D3E86L)

//
// MessageId: MF_E_MP3_OUTOFDATA
//
// MessageText:
//
// The MP3 parser ran out of data before finding the MP3 object.%0
//
#define MF_E_MP3_OUTOFDATA               _HRESULT_TYPEDEF_(0xC00D3E87L)

//
// MessageId: MF_E_MP3_NOTMP3
//
// MessageText:
//
// The file is not really a MP3 file.%0
//
#define MF_E_MP3_NOTMP3                  _HRESULT_TYPEDEF_(0xC00D3E88L)

//
// MessageId: MF_E_MP3_NOTSUPPORTED
//
// MessageText:
//
// The MP3 file is not supported.%0
//
#define MF_E_MP3_NOTSUPPORTED            _HRESULT_TYPEDEF_(0xC00D3E89L)

//
// MessageId: MF_E_NO_DURATION
//
// MessageText:
//
// The Media stream has no duration.%0
//
#define MF_E_NO_DURATION                 _HRESULT_TYPEDEF_(0xC00D3E8AL)

//
// MessageId: MF_E_INVALID_FORMAT
//
// MessageText:
//
// The Media format is recognized but is invalid.%0
//
#define MF_E_INVALID_FORMAT              _HRESULT_TYPEDEF_(0xC00D3E8CL)

//
// MessageId: MF_E_PROPERTY_NOT_FOUND
//
// MessageText:
//
// The property requested was not found.%0
//
#define MF_E_PROPERTY_NOT_FOUND          _HRESULT_TYPEDEF_(0xC00D3E8DL)

//
// MessageId: MF_E_PROPERTY_READ_ONLY
//
// MessageText:
//
// The property is read only.%0
//
#define MF_E_PROPERTY_READ_ONLY          _HRESULT_TYPEDEF_(0xC00D3E8EL)

//
// MessageId: MF_E_PROPERTY_NOT_ALLOWED
//
// MessageText:
//
// The specified property is not allowed in this context.%0
//
#define MF_E_PROPERTY_NOT_ALLOWED        _HRESULT_TYPEDEF_(0xC00D3E8FL)

//
// MessageId: MF_E_MEDIA_SOURCE_NOT_STARTED
//
// MessageText:
//
// The media source is not started.%0
//
#define MF_E_MEDIA_SOURCE_NOT_STARTED    _HRESULT_TYPEDEF_(0xC00D3E91L)

//
// MessageId: MF_E_UNSUPPORTED_FORMAT
//
// MessageText:
//
// The Media format is recognized but not supported.%0
//
#define MF_E_UNSUPPORTED_FORMAT          _HRESULT_TYPEDEF_(0xC00D3E98L)

//
// MessageId: MF_E_MP3_BAD_CRC
//
// MessageText:
//
// The MPEG frame has bad CRC.%0
//
#define MF_E_MP3_BAD_CRC                 _HRESULT_TYPEDEF_(0xC00D3E99L)

//
// MessageId: MF_E_NOT_PROTECTED
//
// MessageText:
//
// The file is not protected.%0
//
#define MF_E_NOT_PROTECTED               _HRESULT_TYPEDEF_(0xC00D3E9AL)

//
// MessageId: MF_E_MEDIA_SOURCE_WRONGSTATE
//
// MessageText:
//
// The media source is in the wrong state%0
//
#define MF_E_MEDIA_SOURCE_WRONGSTATE     _HRESULT_TYPEDEF_(0xC00D3E9BL)

//
// MessageId: MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED
//
// MessageText:
//
// No streams are selected in source presentation descriptor.%0
//
#define MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED _HRESULT_TYPEDEF_(0xC00D3E9CL)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Network Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// An attempt to acquire a network resource failed.%0
//
#define MF_E_NETWORK_RESOURCE_FAILURE    _HRESULT_TYPEDEF_(0xC00D4268L)

//
// MessageId: MF_E_NET_WRITE
//
// MessageText:
//
// Error writing to the network.%0
//
#define MF_E_NET_WRITE                   _HRESULT_TYPEDEF_(0xC00D4269L)

//
// MessageId: MF_E_NET_READ
//
// MessageText:
//
// Error reading from the network.%0
//
#define MF_E_NET_READ                    _HRESULT_TYPEDEF_(0xC00D426AL)

//
// MessageId: MF_E_NET_REQUIRE_NETWORK
//
// MessageText:
//
// Internal. Entry cannot complete operation without network.%0
//
#define MF_E_NET_REQUIRE_NETWORK         _HRESULT_TYPEDEF_(0xC00D426BL)

//
// MessageId: MF_E_NET_REQUIRE_ASYNC
//
// MessageText:
//
// Internal. Async op is required.%0
//
#define MF_E_NET_REQUIRE_ASYNC           _HRESULT_TYPEDEF_(0xC00D426CL)

//
// MessageId: MF_E_NET_BWLEVEL_NOT_SUPPORTED
//
// MessageText:
//
// Internal. Bandwidth levels are not supported.%0
//
#define MF_E_NET_BWLEVEL_NOT_SUPPORTED   _HRESULT_TYPEDEF_(0xC00D426DL)

//
// MessageId: MF_E_NET_STREAMGROUPS_NOT_SUPPORTED
//
// MessageText:
//
// Internal. Stream groups are not supported.%0
//
#define MF_E_NET_STREAMGROUPS_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D426EL)

//
// MessageId: MF_E_NET_MANUALSS_NOT_SUPPORTED
//
// MessageText:
//
// Manual stream selection is not supported.%0
//
#define MF_E_NET_MANUALSS_NOT_SUPPORTED  _HRESULT_TYPEDEF_(0xC00D426FL)

//
// MessageId: MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR
//
// MessageText:
//
// Invalid presentation descriptor.%0
//
#define MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR _HRESULT_TYPEDEF_(0xC00D4270L)

//
// MessageId: MF_E_NET_CACHESTREAM_NOT_FOUND
//
// MessageText:
//
// Cannot find cache stream.%0
//
#define MF_E_NET_CACHESTREAM_NOT_FOUND   _HRESULT_TYPEDEF_(0xC00D4271L)

//
// MessageId: MF_I_MANUAL_PROXY
//
// MessageText:
//
// The proxy setting is manual.%0
//
#define MF_I_MANUAL_PROXY                _HRESULT_TYPEDEF_(0x400D4272L)

//duplicate removed
//MessageId=17011 Severity=Informational Facility=MEDIAFOUNDATION SymbolicName=MF_E_INVALID_REQUEST
//Language=English
//The request is invalid in the current state.%0
//.
//
// MessageId: MF_E_NET_REQUIRE_INPUT
//
// MessageText:
//
// Internal. Entry cannot complete operation without input.%0
//
#define MF_E_NET_REQUIRE_INPUT           _HRESULT_TYPEDEF_(0xC00D4274L)

//
// MessageId: MF_E_NET_REDIRECT
//
// MessageText:
//
// The client redirected to another server.%0
//
#define MF_E_NET_REDIRECT                _HRESULT_TYPEDEF_(0xC00D4275L)

//
// MessageId: MF_E_NET_REDIRECT_TO_PROXY
//
// MessageText:
//
// The client is redirected to a proxy server.%0
//
#define MF_E_NET_REDIRECT_TO_PROXY       _HRESULT_TYPEDEF_(0xC00D4276L)

//
// MessageId: MF_E_NET_TOO_MANY_REDIRECTS
//
// MessageText:
//
// The client reached maximum redirection limit.%0
//
#define MF_E_NET_TOO_MANY_REDIRECTS      _HRESULT_TYPEDEF_(0xC00D4277L)

//
// MessageId: MF_E_NET_TIMEOUT
//
// MessageText:
//
// The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define MF_E_NET_TIMEOUT                 _HRESULT_TYPEDEF_(0xC00D4278L)

//
// MessageId: MF_E_NET_CLIENT_CLOSE
//
// MessageText:
//
// The control socket is closed by the client.%0
//
#define MF_E_NET_CLIENT_CLOSE            _HRESULT_TYPEDEF_(0xC00D4279L)

//
// MessageId: MF_E_NET_BAD_CONTROL_DATA
//
// MessageText:
//
// The server received invalid data from the client on the control connection.%0
//
#define MF_E_NET_BAD_CONTROL_DATA        _HRESULT_TYPEDEF_(0xC00D427AL)

//
// MessageId: MF_E_NET_INCOMPATIBLE_SERVER
//
// MessageText:
//
// The server is not a compatible streaming media server.%0
//
#define MF_E_NET_INCOMPATIBLE_SERVER     _HRESULT_TYPEDEF_(0xC00D427BL)

//
// MessageId: MF_E_NET_UNSAFE_URL
//
// MessageText:
//
// Url.%0
//
#define MF_E_NET_UNSAFE_URL              _HRESULT_TYPEDEF_(0xC00D427CL)

//
// MessageId: MF_E_NET_CACHE_NO_DATA
//
// MessageText:
//
// Data is not available.%0
//
#define MF_E_NET_CACHE_NO_DATA           _HRESULT_TYPEDEF_(0xC00D427DL)

//
// MessageId: MF_E_NET_EOL
//
// MessageText:
//
// End of line.%0
//
#define MF_E_NET_EOL                     _HRESULT_TYPEDEF_(0xC00D427EL)

//
// MessageId: MF_E_NET_BAD_REQUEST
//
// MessageText:
//
// The request could not be understood by the server.%0
//
#define MF_E_NET_BAD_REQUEST             _HRESULT_TYPEDEF_(0xC00D427FL)

//
// MessageId: MF_E_NET_INTERNAL_SERVER_ERROR
//
// MessageText:
//
// The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define MF_E_NET_INTERNAL_SERVER_ERROR   _HRESULT_TYPEDEF_(0xC00D4280L)

//
// MessageId: MF_E_NET_SESSION_NOT_FOUND
//
// MessageText:
//
// Session not found.%0
//
#define MF_E_NET_SESSION_NOT_FOUND       _HRESULT_TYPEDEF_(0xC00D4281L)

//
// MessageId: MF_E_NET_NOCONNECTION
//
// MessageText:
//
// There is no connection established with the Windows Media server. The operation failed.%0
//
#define MF_E_NET_NOCONNECTION            _HRESULT_TYPEDEF_(0xC00D4282L)

//
// MessageId: MF_E_NET_CONNECTION_FAILURE
//
// MessageText:
//
// The network connection has failed.%0
//
#define MF_E_NET_CONNECTION_FAILURE      _HRESULT_TYPEDEF_(0xC00D4283L)

//
// MessageId: MF_E_NET_INCOMPATIBLE_PUSHSERVER
//
// MessageText:
//
// The Server service that received the HTTP push request is not a compatible version of Windows Media Services (WMS).  This error may indicate the push request was received by IIS instead of WMS.  Ensure WMS is started and has the HTTP Server control protocol properly enabled and try again.%0
//
#define MF_E_NET_INCOMPATIBLE_PUSHSERVER _HRESULT_TYPEDEF_(0xC00D4284L)

//
// MessageId: MF_E_NET_SERVER_ACCESSDENIED
//
// MessageText:
//
// The Windows Media server is denying access.  The username and/or password might be incorrect.%0
//
#define MF_E_NET_SERVER_ACCESSDENIED     _HRESULT_TYPEDEF_(0xC00D4285L)

//
// MessageId: MF_E_NET_PROXY_ACCESSDENIED
//
// MessageText:
//
// The proxy server is denying access.  The username and/or password might be incorrect.%0
//
#define MF_E_NET_PROXY_ACCESSDENIED      _HRESULT_TYPEDEF_(0xC00D4286L)

//
// MessageId: MF_E_NET_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server.%0
//
#define MF_E_NET_CANNOTCONNECT           _HRESULT_TYPEDEF_(0xC00D4287L)

//
// MessageId: MF_E_NET_INVALID_PUSH_TEMPLATE
//
// MessageText:
//
// The specified push template is invalid.%0
//
#define MF_E_NET_INVALID_PUSH_TEMPLATE   _HRESULT_TYPEDEF_(0xC00D4288L)

//
// MessageId: MF_E_NET_INVALID_PUSH_PUBLISHING_POINT
//
// MessageText:
//
// The specified push publishing point is invalid.%0
//
#define MF_E_NET_INVALID_PUSH_PUBLISHING_POINT _HRESULT_TYPEDEF_(0xC00D4289L)

//
// MessageId: MF_E_NET_BUSY
//
// MessageText:
//
// The requested resource is in use.%0
//
#define MF_E_NET_BUSY                    _HRESULT_TYPEDEF_(0xC00D428AL)

//
// MessageId: MF_E_NET_RESOURCE_GONE
//
// MessageText:
//
// The Publishing Point or file on the Windows Media Server is no longer available.%0
//
#define MF_E_NET_RESOURCE_GONE           _HRESULT_TYPEDEF_(0xC00D428BL)

//
// MessageId: MF_E_NET_ERROR_FROM_PROXY
//
// MessageText:
//
// The proxy experienced an error while attempting to contact the media server.%0
//
#define MF_E_NET_ERROR_FROM_PROXY        _HRESULT_TYPEDEF_(0xC00D428CL)

//
// MessageId: MF_E_NET_PROXY_TIMEOUT
//
// MessageText:
//
// The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define MF_E_NET_PROXY_TIMEOUT           _HRESULT_TYPEDEF_(0xC00D428DL)

//
// MessageId: MF_E_NET_SERVER_UNAVAILABLE
//
// MessageText:
//
// The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define MF_E_NET_SERVER_UNAVAILABLE      _HRESULT_TYPEDEF_(0xC00D428EL)

//
// MessageId: MF_E_NET_TOO_MUCH_DATA
//
// MessageText:
//
// The encoding process was unable to keep up with the amount of supplied data.%0
//
#define MF_E_NET_TOO_MUCH_DATA           _HRESULT_TYPEDEF_(0xC00D428FL)

//
// MessageId: MF_E_NET_SESSION_INVALID
//
// MessageText:
//
// Session not found.%0
//
#define MF_E_NET_SESSION_INVALID         _HRESULT_TYPEDEF_(0xC00D4290L)

//
// MessageId: MF_E_OFFLINE_MODE
//
// MessageText:
//
// The requested URL is not available in offline mode.%0
//
#define MF_E_OFFLINE_MODE                _HRESULT_TYPEDEF_(0xC00D4291L)

//
// MessageId: MF_E_NET_UDP_BLOCKED
//
// MessageText:
//
// A device in the network is blocking UDP traffic.%0
//
#define MF_E_NET_UDP_BLOCKED             _HRESULT_TYPEDEF_(0xC00D4292L)

//
// MessageId: MF_E_NET_UNSUPPORTED_CONFIGURATION
//
// MessageText:
//
// The specified configuration value is not supported.%0
//
#define MF_E_NET_UNSUPPORTED_CONFIGURATION _HRESULT_TYPEDEF_(0xC00D4293L)

//
// MessageId: MF_E_NET_PROTOCOL_DISABLED
//
// MessageText:
//
// The networking protocol is disabled.%0
//
#define MF_E_NET_PROTOCOL_DISABLED       _HRESULT_TYPEDEF_(0xC00D4294L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION WMContainer Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_ALREADY_INITIALIZED
//
// MessageText:
//
// This object has already been initialized and cannot be re-initialized at this time.%0
//
#define MF_E_ALREADY_INITIALIZED         _HRESULT_TYPEDEF_(0xC00D4650L)

//
// MessageId: MF_E_BANDWIDTH_OVERRUN
//
// MessageText:
//
// The amount of data passed in exceeds the given bitrate and buffer window.%0
//
#define MF_E_BANDWIDTH_OVERRUN           _HRESULT_TYPEDEF_(0xC00D4651L)

//
// MessageId: MF_E_LATE_SAMPLE
//
// MessageText:
//
// The sample was passed in too late to be correctly processed.%0
//
#define MF_E_LATE_SAMPLE                 _HRESULT_TYPEDEF_(0xC00D4652L)

//
// MessageId: MF_E_FLUSH_NEEDED
//
// MessageText:
//
// The requested action cannot be carried out until the object is flushed and the queue is emptied.%0
//
#define MF_E_FLUSH_NEEDED                _HRESULT_TYPEDEF_(0xC00D4653L)

//
// MessageId: MF_E_INVALID_PROFILE
//
// MessageText:
//
// The profile is invalid.%0
//
#define MF_E_INVALID_PROFILE             _HRESULT_TYPEDEF_(0xC00D4654L)

//
// MessageId: MF_E_INDEX_NOT_COMMITTED
//
// MessageText:
//
// The index that is being generated needs to be committed before the requested action can be carried out.%0
//
#define MF_E_INDEX_NOT_COMMITTED         _HRESULT_TYPEDEF_(0xC00D4655L)

//
// MessageId: MF_E_NO_INDEX
//
// MessageText:
//
// The index that is necessary for the requested action is not found.%0
//
#define MF_E_NO_INDEX                    _HRESULT_TYPEDEF_(0xC00D4656L)

//
// MessageId: MF_E_CANNOT_INDEX_IN_PLACE
//
// MessageText:
//
// The requested index cannot be added in-place to the specified ASF content.%0
//
#define MF_E_CANNOT_INDEX_IN_PLACE       _HRESULT_TYPEDEF_(0xC00D4657L)

//
// MessageId: MF_E_MISSING_ASF_LEAKYBUCKET
//
// MessageText:
//
// The ASF leaky bucket parameters must be specified in order to carry out this request.%0
//
#define MF_E_MISSING_ASF_LEAKYBUCKET     _HRESULT_TYPEDEF_(0xC00D4658L)

//
// MessageId: MF_E_INVALID_ASF_STREAMID
//
// MessageText:
//
// The stream id is invalid. The valid range for ASF stream id is from 1 to 127.%0
//
#define MF_E_INVALID_ASF_STREAMID        _HRESULT_TYPEDEF_(0xC00D4659L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Media Sink Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_STREAMSINK_REMOVED
//
// MessageText:
//
// The requested Stream Sink has been removed and cannot be used.%0
//
#define MF_E_STREAMSINK_REMOVED          _HRESULT_TYPEDEF_(0xC00D4A38L)

//
// MessageId: MF_E_STREAMSINKS_OUT_OF_SYNC
//
// MessageText:
//
// The various Stream Sinks in this Media Sink are too far out of sync for the requested action to take place.%0
//
#define MF_E_STREAMSINKS_OUT_OF_SYNC     _HRESULT_TYPEDEF_(0xC00D4A3AL)

//
// MessageId: MF_E_STREAMSINKS_FIXED
//
// MessageText:
//
// Stream Sinks cannot be added to or removed from this Media Sink because its set of streams is fixed.%0
//
#define MF_E_STREAMSINKS_FIXED           _HRESULT_TYPEDEF_(0xC00D4A3BL)

//
// MessageId: MF_E_STREAMSINK_EXISTS
//
// MessageText:
//
// The given Stream Sink already exists.%0
//
#define MF_E_STREAMSINK_EXISTS           _HRESULT_TYPEDEF_(0xC00D4A3CL)

//
// MessageId: MF_E_SAMPLEALLOCATOR_CANCELED
//
// MessageText:
//
// Sample allocations have been canceled.%0
//
#define MF_E_SAMPLEALLOCATOR_CANCELED    _HRESULT_TYPEDEF_(0xC00D4A3DL)

//
// MessageId: MF_E_SAMPLEALLOCATOR_EMPTY
//
// MessageText:
//
// The sample allocator is currently empty, due to outstanding requests.%0
//
#define MF_E_SAMPLEALLOCATOR_EMPTY       _HRESULT_TYPEDEF_(0xC00D4A3EL)

//
// MessageId: MF_E_SINK_ALREADYSTOPPED
//
// MessageText:
//
// When we try to sopt a stream sink, it is already stopped %0
//
#define MF_E_SINK_ALREADYSTOPPED         _HRESULT_TYPEDEF_(0xC00D4A3FL)

//
// MessageId: MF_E_ASF_FILESINK_BITRATE_UNKNOWN
//
// MessageText:
//
// The ASF file sink could not reserve AVIO because the bitrate is unknown.%0
//
#define MF_E_ASF_FILESINK_BITRATE_UNKNOWN _HRESULT_TYPEDEF_(0xC00D4A40L)

//
// MessageId: MF_E_SINK_NO_STREAMS
//
// MessageText:
//
// No streams are selected in sink presentation descriptor.%0
//
#define MF_E_SINK_NO_STREAMS             _HRESULT_TYPEDEF_(0xC00D4A41L)

//
// MessageId: MF_S_SINK_NOT_FINALIZED
//
// MessageText:
//
// The sink has not been finalized before shut down. This may cause sink generate a corrupted content.%0
//
#define MF_S_SINK_NOT_FINALIZED          _HRESULT_TYPEDEF_(0x000D4A42L)

//
// MessageId: MF_E_METADATA_TOO_LONG
//
// MessageText:
//
// A metadata item was too long to write to the output container.%0
//
#define MF_E_METADATA_TOO_LONG           _HRESULT_TYPEDEF_(0xC00D4A43L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Renderer Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_VIDEO_REN_NO_PROCAMP_HW
//
// MessageText:
//
// There is no available procamp hardware with which to perform color correction.%0
//
#define MF_E_VIDEO_REN_NO_PROCAMP_HW     _HRESULT_TYPEDEF_(0xC00D4E20L)

//
// MessageId: MF_E_VIDEO_REN_NO_DEINTERLACE_HW
//
// MessageText:
//
// There is no available deinterlacing hardware with which to deinterlace the video stream.%0
//
#define MF_E_VIDEO_REN_NO_DEINTERLACE_HW _HRESULT_TYPEDEF_(0xC00D4E21L)

//
// MessageId: MF_E_VIDEO_REN_COPYPROT_FAILED
//
// MessageText:
//
// A video stream requires copy protection to be enabled, but there was a failure in attempting to enable copy protection.%0
//
#define MF_E_VIDEO_REN_COPYPROT_FAILED   _HRESULT_TYPEDEF_(0xC00D4E22L)

//
// MessageId: MF_E_VIDEO_REN_SURFACE_NOT_SHARED
//
// MessageText:
//
// A component is attempting to access a surface for sharing that is not shared.%0
//
#define MF_E_VIDEO_REN_SURFACE_NOT_SHARED _HRESULT_TYPEDEF_(0xC00D4E23L)

//
// MessageId: MF_E_VIDEO_DEVICE_LOCKED
//
// MessageText:
//
// A component is attempting to access a shared device that is already locked by another component.%0
//
#define MF_E_VIDEO_DEVICE_LOCKED         _HRESULT_TYPEDEF_(0xC00D4E24L)

//
// MessageId: MF_E_NEW_VIDEO_DEVICE
//
// MessageText:
//
// The device is no longer available. The handle should be closed and a new one opened.%0
//
#define MF_E_NEW_VIDEO_DEVICE            _HRESULT_TYPEDEF_(0xC00D4E25L)

//
// MessageId: MF_E_NO_VIDEO_SAMPLE_AVAILABLE
//
// MessageText:
//
// A video sample is not currently queued on a stream that is required for mixing.%0
//
#define MF_E_NO_VIDEO_SAMPLE_AVAILABLE   _HRESULT_TYPEDEF_(0xC00D4E26L)

//
// MessageId: MF_E_NO_AUDIO_PLAYBACK_DEVICE
//
// MessageText:
//
// No audio playback device was found.%0
//
#define MF_E_NO_AUDIO_PLAYBACK_DEVICE    _HRESULT_TYPEDEF_(0xC00D4E84L)

//
// MessageId: MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE
//
// MessageText:
//
// The requested audio playback device is currently in use.%0
//
#define MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE _HRESULT_TYPEDEF_(0xC00D4E85L)

//
// MessageId: MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED
//
// MessageText:
//
// The audio playback device is no longer present.%0
//
#define MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED _HRESULT_TYPEDEF_(0xC00D4E86L)

//
// MessageId: MF_E_AUDIO_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The audio service is not running.%0
//
#define MF_E_AUDIO_SERVICE_NOT_RUNNING   _HRESULT_TYPEDEF_(0xC00D4E87L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Topology Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_TOPO_INVALID_OPTIONAL_NODE
//
// MessageText:
//
// The topology contains an invalid optional node.  Possible reasons are incorrect number of outputs and inputs or optional node is at the beginning or end of a segment. %0
//
#define MF_E_TOPO_INVALID_OPTIONAL_NODE  _HRESULT_TYPEDEF_(0xC00D520EL)

//
// MessageId: MF_E_TOPO_CANNOT_FIND_DECRYPTOR
//
// MessageText:
//
// No suitable transform was found to decrypt the content. %0
//
#define MF_E_TOPO_CANNOT_FIND_DECRYPTOR  _HRESULT_TYPEDEF_(0xC00D5211L)

//
// MessageId: MF_E_TOPO_CODEC_NOT_FOUND
//
// MessageText:
//
// No suitable transform was found to encode or decode the content. %0
//
#define MF_E_TOPO_CODEC_NOT_FOUND        _HRESULT_TYPEDEF_(0xC00D5212L)

//
// MessageId: MF_E_TOPO_CANNOT_CONNECT
//
// MessageText:
//
// Unable to find a way to connect nodes%0
//
#define MF_E_TOPO_CANNOT_CONNECT         _HRESULT_TYPEDEF_(0xC00D5213L)

//
// MessageId: MF_E_TOPO_UNSUPPORTED
//
// MessageText:
//
// Unsupported operations in topoloader%0
//
#define MF_E_TOPO_UNSUPPORTED            _HRESULT_TYPEDEF_(0xC00D5214L)

//
// MessageId: MF_E_TOPO_INVALID_TIME_ATTRIBUTES
//
// MessageText:
//
// The topology or its nodes contain incorrectly set time attributes%0
//
#define MF_E_TOPO_INVALID_TIME_ATTRIBUTES _HRESULT_TYPEDEF_(0xC00D5215L)

//
// MessageId: MF_E_TOPO_LOOPS_IN_TOPOLOGY
//
// MessageText:
//
// The topology contains loops, which are unsupported in media foundation topologies%0
//
#define MF_E_TOPO_LOOPS_IN_TOPOLOGY      _HRESULT_TYPEDEF_(0xC00D5216L)

//
// MessageId: MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR
//
// MessageText:
//
// A source stream node in the topology does not have a presentation descriptor%0
//
#define MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR _HRESULT_TYPEDEF_(0xC00D5217L)

//
// MessageId: MF_E_TOPO_MISSING_STREAM_DESCRIPTOR
//
// MessageText:
//
// A source stream node in the topology does not have a stream descriptor%0
//
#define MF_E_TOPO_MISSING_STREAM_DESCRIPTOR _HRESULT_TYPEDEF_(0xC00D5218L)

//
// MessageId: MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED
//
// MessageText:
//
// A stream descriptor was set on a source stream node but it was not selected on the presentation descriptor%0
//
#define MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED _HRESULT_TYPEDEF_(0xC00D5219L)

//
// MessageId: MF_E_TOPO_MISSING_SOURCE
//
// MessageText:
//
// A source stream node in the topology does not have a source%0
//
#define MF_E_TOPO_MISSING_SOURCE         _HRESULT_TYPEDEF_(0xC00D521AL)

//
// MessageId: MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED
//
// MessageText:
//
// The topology loader does not support sink activates on output nodes.%0
//
#define MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D521BL)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Timeline Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID
//
// MessageText:
//
// The sequencer cannot find a segment with the given ID.%0\n.
//
#define MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID _HRESULT_TYPEDEF_(0xC00D61ACL)

//
// MessageId: MF_S_SEQUENCER_CONTEXT_CANCELED
//
// MessageText:
//
// The context was canceled.%0\n.
//
#define MF_S_SEQUENCER_CONTEXT_CANCELED  _HRESULT_TYPEDEF_(0x000D61ADL)

//
// MessageId: MF_E_NO_SOURCE_IN_CACHE
//
// MessageText:
//
// Cannot find source in source cache.%0\n.
//
#define MF_E_NO_SOURCE_IN_CACHE          _HRESULT_TYPEDEF_(0xC00D61AEL)

//
// MessageId: MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM
//
// MessageText:
//
// Cannot update topology flags.%0\n.
//
#define MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM _HRESULT_TYPEDEF_(0x000D61AFL)


//////////////////////////////////////////////////////////////////////////////
//
// Transform errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_TRANSFORM_TYPE_NOT_SET
//
// MessageText:
//
// A valid type has not been set for this stream or a stream that it depends on.%0
//
#define MF_E_TRANSFORM_TYPE_NOT_SET      _HRESULT_TYPEDEF_(0xC00D6D60L)

//
// MessageId: MF_E_TRANSFORM_STREAM_CHANGE
//
// MessageText:
//
// A stream change has occurred. Output cannot be produced until the streams have been renegotiated.%0
//
#define MF_E_TRANSFORM_STREAM_CHANGE     _HRESULT_TYPEDEF_(0xC00D6D61L)

//
// MessageId: MF_E_TRANSFORM_INPUT_REMAINING
//
// MessageText:
//
// The transform cannot take the requested action until all of the input data it currently holds is processed or flushed.%0
//
#define MF_E_TRANSFORM_INPUT_REMAINING   _HRESULT_TYPEDEF_(0xC00D6D62L)

//
// MessageId: MF_E_TRANSFORM_PROFILE_MISSING
//
// MessageText:
//
// The transform requires a profile but no profile was supplied or found.%0
//
#define MF_E_TRANSFORM_PROFILE_MISSING   _HRESULT_TYPEDEF_(0xC00D6D63L)

//
// MessageId: MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT
//
// MessageText:
//
// The transform requires a profile but the supplied profile was invalid or corrupt.%0
//
#define MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT _HRESULT_TYPEDEF_(0xC00D6D64L)

//
// MessageId: MF_E_TRANSFORM_PROFILE_TRUNCATED
//
// MessageText:
//
// The transform requires a profile but the supplied profile ended unexpectedly while parsing.%0
//
#define MF_E_TRANSFORM_PROFILE_TRUNCATED _HRESULT_TYPEDEF_(0xC00D6D65L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED
//
// MessageText:
//
// The property ID does not match any property supported by the transform.%0
//
#define MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED _HRESULT_TYPEDEF_(0xC00D6D66L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG
//
// MessageText:
//
// The variant does not have the type expected for this property ID.%0
//
#define MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG _HRESULT_TYPEDEF_(0xC00D6D67L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE
//
// MessageText:
//
// An attempt was made to set the value on a read-only property.%0
//
#define MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE _HRESULT_TYPEDEF_(0xC00D6D68L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM
//
// MessageText:
//
// The array property value has an unexpected number of dimensions.%0
//
#define MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM _HRESULT_TYPEDEF_(0xC00D6D69L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG
//
// MessageText:
//
// The array or blob property value has an unexpected size.%0
//
#define MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG _HRESULT_TYPEDEF_(0xC00D6D6AL)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The property value is out of range for this transform.%0
//
#define MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE _HRESULT_TYPEDEF_(0xC00D6D6BL)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE
//
// MessageText:
//
// The property value is incompatible with some other property or mediatype set on the transform.%0
//
#define MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE _HRESULT_TYPEDEF_(0xC00D6D6CL)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE
//
// MessageText:
//
// The requested operation is not supported for the currently set output mediatype.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE _HRESULT_TYPEDEF_(0xC00D6D6DL)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE
//
// MessageText:
//
// The requested operation is not supported for the currently set input mediatype.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE _HRESULT_TYPEDEF_(0xC00D6D6EL)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION
//
// MessageText:
//
// The requested operation is not supported for the currently set combination of mediatypes.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION _HRESULT_TYPEDEF_(0xC00D6D6FL)

//
// MessageId: MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES
//
// MessageText:
//
// The requested feature is not supported in combination with some other currently enabled feature.%0
//
#define MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES _HRESULT_TYPEDEF_(0xC00D6D70L)

//
// MessageId: MF_E_TRANSFORM_NEED_MORE_INPUT
//
// MessageText:
//
// The transform cannot produce output until it gets more input samples.%0
//
#define MF_E_TRANSFORM_NEED_MORE_INPUT   _HRESULT_TYPEDEF_(0xC00D6D72L)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG
//
// MessageText:
//
// The requested operation is not supported for the current speaker configuration.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG _HRESULT_TYPEDEF_(0xC00D6D73L)

//
// MessageId: MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING
//
// MessageText:
//
// The transform cannot accept mediatype changes in the middle of processing.%0
//
#define MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING _HRESULT_TYPEDEF_(0xC00D6D74L)

//
// MessageId: MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT
//
// MessageText:
//
// The caller should not propagate this event to downstream components.%0
//
#define MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT _HRESULT_TYPEDEF_(0x000D6D75L)

//
// MessageId: MF_E_UNSUPPORTED_D3D_TYPE
//
// MessageText:
//
// The input type is not supported for D3D device.%0
//
#define MF_E_UNSUPPORTED_D3D_TYPE        _HRESULT_TYPEDEF_(0xC00D6D76L)

//
// MessageId: MF_E_TRANSFORM_ASYNC_LOCKED
//
// MessageText:
//
// The caller does not appear to support this transform's asynchronous capabilities.%0
//
#define MF_E_TRANSFORM_ASYNC_LOCKED      _HRESULT_TYPEDEF_(0xC00D6D77L)

//
// MessageId: MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER
//
// MessageText:
//
// An audio compression manager driver could not be initialized by the transform.%0
//
#define MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER _HRESULT_TYPEDEF_(0xC00D6D78L)


//////////////////////////////////////////////////////////////////////////////
//
// Content Protection errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
// You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define MF_E_LICENSE_INCORRECT_RIGHTS    _HRESULT_TYPEDEF_(0xC00D7148L)

//
// MessageId: MF_E_LICENSE_OUTOFDATE
//
// MessageText:
//
// The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define MF_E_LICENSE_OUTOFDATE           _HRESULT_TYPEDEF_(0xC00D7149L)

//
// MessageId: MF_E_LICENSE_REQUIRED
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define MF_E_LICENSE_REQUIRED            _HRESULT_TYPEDEF_(0xC00D714AL)

//
// MessageId: MF_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
// The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define MF_E_DRM_HARDWARE_INCONSISTENT   _HRESULT_TYPEDEF_(0xC00D714BL)

//
// MessageId: MF_E_NO_CONTENT_PROTECTION_MANAGER
//
// MessageText:
//
// The APP needs to provide IMFContentProtectionManager callback to access the protected media file.%0
//
#define MF_E_NO_CONTENT_PROTECTION_MANAGER _HRESULT_TYPEDEF_(0xC00D714CL)

//
// MessageId: MF_E_LICENSE_RESTORE_NO_RIGHTS
//
// MessageText:
//
// Client does not have rights to restore licenses.%0
//
#define MF_E_LICENSE_RESTORE_NO_RIGHTS   _HRESULT_TYPEDEF_(0xC00D714DL)

//
// MessageId: MF_E_BACKUP_RESTRICTED_LICENSE
//
// MessageText:
//
// Licenses are restricted and hence can not be backed up.%0
//
#define MF_E_BACKUP_RESTRICTED_LICENSE   _HRESULT_TYPEDEF_(0xC00D714EL)

//
// MessageId: MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// License restore requires machine to be individualized.%0
//
#define MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION _HRESULT_TYPEDEF_(0xC00D714FL)

//
// MessageId: MF_S_PROTECTION_NOT_REQUIRED
//
// MessageText:
//
// Protection for stream is not required.%0
//
#define MF_S_PROTECTION_NOT_REQUIRED     _HRESULT_TYPEDEF_(0x000D7150L)

//
// MessageId: MF_E_COMPONENT_REVOKED
//
// MessageText:
//
// Component is revoked.%0
//
#define MF_E_COMPONENT_REVOKED           _HRESULT_TYPEDEF_(0xC00D7151L)

//
// MessageId: MF_E_TRUST_DISABLED
//
// MessageText:
//
// Trusted functionality is currently disabled on this component.%0
//
#define MF_E_TRUST_DISABLED              _HRESULT_TYPEDEF_(0xC00D7152L)

//
// MessageId: MF_E_WMDRMOTA_NO_ACTION
//
// MessageText:
//
// No Action is set on WMDRM Output Trust Authority.%0
//
#define MF_E_WMDRMOTA_NO_ACTION          _HRESULT_TYPEDEF_(0xC00D7153L)

//
// MessageId: MF_E_WMDRMOTA_ACTION_ALREADY_SET
//
// MessageText:
//
// Action is already set on WMDRM Output Trust Authority.%0
//
#define MF_E_WMDRMOTA_ACTION_ALREADY_SET _HRESULT_TYPEDEF_(0xC00D7154L)

//
// MessageId: MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE
//
// MessageText:
//
// DRM Heaader is not available.%0
//
#define MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D7155L)

//
// MessageId: MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED
//
// MessageText:
//
// Current encryption scheme is not supported.%0
//
#define MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D7156L)

//
// MessageId: MF_E_WMDRMOTA_ACTION_MISMATCH
//
// MessageText:
//
// Action does not match with current configuration.%0
//
#define MF_E_WMDRMOTA_ACTION_MISMATCH    _HRESULT_TYPEDEF_(0xC00D7157L)

//
// MessageId: MF_E_WMDRMOTA_INVALID_POLICY
//
// MessageText:
//
// Invalid policy for WMDRM Output Trust Authority.%0
//
#define MF_E_WMDRMOTA_INVALID_POLICY     _HRESULT_TYPEDEF_(0xC00D7158L)

//
// MessageId: MF_E_POLICY_UNSUPPORTED
//
// MessageText:
//
// The policies that the Input Trust Authority requires to be enforced are unsupported by the outputs.%0
//
#define MF_E_POLICY_UNSUPPORTED          _HRESULT_TYPEDEF_(0xC00D7159L)

//
// MessageId: MF_E_OPL_NOT_SUPPORTED
//
// MessageText:
//
// The OPL that the license requires to be enforced are not supported by the Input Trust Authority.%0
//
#define MF_E_OPL_NOT_SUPPORTED           _HRESULT_TYPEDEF_(0xC00D715AL)

//
// MessageId: MF_E_TOPOLOGY_VERIFICATION_FAILED
//
// MessageText:
//
// The topology could not be successfully verified.%0
//
#define MF_E_TOPOLOGY_VERIFICATION_FAILED _HRESULT_TYPEDEF_(0xC00D715BL)

//
// MessageId: MF_E_SIGNATURE_VERIFICATION_FAILED
//
// MessageText:
//
// Signature verification could not be completed successfully for this component.%0
//
#define MF_E_SIGNATURE_VERIFICATION_FAILED _HRESULT_TYPEDEF_(0xC00D715CL)

//
// MessageId: MF_E_DEBUGGING_NOT_ALLOWED
//
// MessageText:
//
// Running this process under a debugger while using protected content is not allowed.%0
//
#define MF_E_DEBUGGING_NOT_ALLOWED       _HRESULT_TYPEDEF_(0xC00D715DL)

//
// MessageId: MF_E_CODE_EXPIRED
//
// MessageText:
//
// MF component has expired.%0
//
#define MF_E_CODE_EXPIRED                _HRESULT_TYPEDEF_(0xC00D715EL)

//
// MessageId: MF_E_GRL_VERSION_TOO_LOW
//
// MessageText:
//
// The current GRL on the machine does not meet the minimum version requirements.%0
//
#define MF_E_GRL_VERSION_TOO_LOW         _HRESULT_TYPEDEF_(0xC00D715FL)

//
// MessageId: MF_E_GRL_RENEWAL_NOT_FOUND
//
// MessageText:
//
// The current GRL on the machine does not contain any renewal entries for the specified revocation.%0
//
#define MF_E_GRL_RENEWAL_NOT_FOUND       _HRESULT_TYPEDEF_(0xC00D7160L)

//
// MessageId: MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND
//
// MessageText:
//
// The current GRL on the machine does not contain any extensible entries for the specified extension GUID.%0
//
#define MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D7161L)

//
// MessageId: MF_E_KERNEL_UNTRUSTED
//
// MessageText:
//
// The kernel isn't secure for high security level content.%0
//
#define MF_E_KERNEL_UNTRUSTED            _HRESULT_TYPEDEF_(0xC00D7162L)

//
// MessageId: MF_E_PEAUTH_UNTRUSTED
//
// MessageText:
//
// The response from protected environment driver isn't valid.%0
//
#define MF_E_PEAUTH_UNTRUSTED            _HRESULT_TYPEDEF_(0xC00D7163L)

//
// MessageId: MF_E_NON_PE_PROCESS
//
// MessageText:
//
// A non-PE process tried to talk to PEAuth.%0
//
#define MF_E_NON_PE_PROCESS              _HRESULT_TYPEDEF_(0xC00D7165L)

//
// MessageId: MF_E_REBOOT_REQUIRED
//
// MessageText:
//
// We need to reboot the machine.%0
//
#define MF_E_REBOOT_REQUIRED             _HRESULT_TYPEDEF_(0xC00D7167L)

//
// MessageId: MF_S_WAIT_FOR_POLICY_SET
//
// MessageText:
//
// Protection for this stream is not guaranteed to be enforced until the MEPolicySet event is fired.%0
//
#define MF_S_WAIT_FOR_POLICY_SET         _HRESULT_TYPEDEF_(0x000D7168L)

//
// MessageId: MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT
//
// MessageText:
//
// This video stream is disabled because it is being sent to an unknown software output.%0
//
#define MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT _HRESULT_TYPEDEF_(0x000D7169L)

//
// MessageId: MF_E_GRL_INVALID_FORMAT
//
// MessageText:
//
// The GRL file is not correctly formed, it may have been corrupted or overwritten.%0
//
#define MF_E_GRL_INVALID_FORMAT          _HRESULT_TYPEDEF_(0xC00D716AL)

//
// MessageId: MF_E_GRL_UNRECOGNIZED_FORMAT
//
// MessageText:
//
// The GRL file is in a format newer than those recognized by this GRL Reader.%0
//
#define MF_E_GRL_UNRECOGNIZED_FORMAT     _HRESULT_TYPEDEF_(0xC00D716BL)

//
// MessageId: MF_E_ALL_PROCESS_RESTART_REQUIRED
//
// MessageText:
//
// The GRL was reloaded and required all processes that can run protected media to restart.%0
//
#define MF_E_ALL_PROCESS_RESTART_REQUIRED _HRESULT_TYPEDEF_(0xC00D716CL)

//
// MessageId: MF_E_PROCESS_RESTART_REQUIRED
//
// MessageText:
//
// The GRL was reloaded and the current process needs to restart.%0
//
#define MF_E_PROCESS_RESTART_REQUIRED    _HRESULT_TYPEDEF_(0xC00D716DL)

//
// MessageId: MF_E_USERMODE_UNTRUSTED
//
// MessageText:
//
// The user space is untrusted for protected content play.%0
//
#define MF_E_USERMODE_UNTRUSTED          _HRESULT_TYPEDEF_(0xC00D716EL)

//
// MessageId: MF_E_PEAUTH_SESSION_NOT_STARTED
//
// MessageText:
//
// PEAuth communication session hasn't been started.%0
//
#define MF_E_PEAUTH_SESSION_NOT_STARTED  _HRESULT_TYPEDEF_(0xC00D716FL)

//
// MessageId: MF_E_PEAUTH_PUBLICKEY_REVOKED
//
// MessageText:
//
// PEAuth's public key is revoked.%0
//
#define MF_E_PEAUTH_PUBLICKEY_REVOKED    _HRESULT_TYPEDEF_(0xC00D7171L)

//
// MessageId: MF_E_GRL_ABSENT
//
// MessageText:
//
// The GRL is absent.%0
//
#define MF_E_GRL_ABSENT                  _HRESULT_TYPEDEF_(0xC00D7172L)

//
// MessageId: MF_S_PE_TRUSTED
//
// MessageText:
//
// The Protected Environment is trusted.%0
//
#define MF_S_PE_TRUSTED                  _HRESULT_TYPEDEF_(0x000D7173L)

//
// MessageId: MF_E_PE_UNTRUSTED
//
// MessageText:
//
// The Protected Environment is untrusted.%0
//
#define MF_E_PE_UNTRUSTED                _HRESULT_TYPEDEF_(0xC00D7174L)

//
// MessageId: MF_E_PEAUTH_NOT_STARTED
//
// MessageText:
//
// The Protected Environment Authorization service (PEAUTH) has not been started.%0
//
#define MF_E_PEAUTH_NOT_STARTED          _HRESULT_TYPEDEF_(0xC00D7175L)

//
// MessageId: MF_E_INCOMPATIBLE_SAMPLE_PROTECTION
//
// MessageText:
//
// The sample protection algorithms supported by components are not compatible.%0
//
#define MF_E_INCOMPATIBLE_SAMPLE_PROTECTION _HRESULT_TYPEDEF_(0xC00D7176L)

//
// MessageId: MF_E_PE_SESSIONS_MAXED
//
// MessageText:
//
// No more protected environment sessions can be supported.%0
//
#define MF_E_PE_SESSIONS_MAXED           _HRESULT_TYPEDEF_(0xC00D7177L)

//
// MessageId: MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED
//
// MessageText:
//
// WMDRM ITA does not allow protected content with high security level for this release.%0
//
#define MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D7178L)

//
// MessageId: MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED
//
// MessageText:
//
// WMDRM ITA cannot allow the requested action for the content as one or more components is not properly signed.%0
//
#define MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D7179L)

//
// MessageId: MF_E_ITA_UNSUPPORTED_ACTION
//
// MessageText:
//
// WMDRM ITA does not support the requested action.%0
//
#define MF_E_ITA_UNSUPPORTED_ACTION      _HRESULT_TYPEDEF_(0xC00D717AL)

//
// MessageId: MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS
//
// MessageText:
//
// WMDRM ITA encountered an error in parsing the Secure Audio Path parameters.%0
//
#define MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS _HRESULT_TYPEDEF_(0xC00D717BL)

//
// MessageId: MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS
//
// MessageText:
//
// The Policy Manager action passed in is invalid.%0
//
#define MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS _HRESULT_TYPEDEF_(0xC00D717CL)

//
// MessageId: MF_E_BAD_OPL_STRUCTURE_FORMAT
//
// MessageText:
//
// The structure specifying Output Protection Level is not the correct format.%0
//
#define MF_E_BAD_OPL_STRUCTURE_FORMAT    _HRESULT_TYPEDEF_(0xC00D717DL)

//
// MessageId: MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID
//
// MessageText:
//
// WMDRM ITA does not recognize the Explicite Analog Video Output Protection guid specified in the license.%0
//
#define MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID _HRESULT_TYPEDEF_(0xC00D717EL)

//
// MessageId: MF_E_NO_PMP_HOST
//
// MessageText:
//
// IMFPMPHost object not available.%0
//
#define MF_E_NO_PMP_HOST                 _HRESULT_TYPEDEF_(0xC00D717FL)

//
// MessageId: MF_E_ITA_OPL_DATA_NOT_INITIALIZED
//
// MessageText:
//
// WMDRM ITA could not initialize the Output Protection Level data.%0
//
#define MF_E_ITA_OPL_DATA_NOT_INITIALIZED _HRESULT_TYPEDEF_(0xC00D7180L)

//
// MessageId: MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT
//
// MessageText:
//
// WMDRM ITA does not recognize the Analog Video Output specified by the OTA.%0
//
#define MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT _HRESULT_TYPEDEF_(0xC00D7181L)

//
// MessageId: MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT
//
// MessageText:
//
// WMDRM ITA does not recognize the Digital Video Output specified by the OTA.%0
//
#define MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT _HRESULT_TYPEDEF_(0xC00D7182L)


//////////////////////////////////////////////////////////////////////////////
//
// Clock errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_CLOCK_INVALID_CONTINUITY_KEY
//
// MessageText:
//
// The continuity key supplied is not currently valid.%0
//
#define MF_E_CLOCK_INVALID_CONTINUITY_KEY _HRESULT_TYPEDEF_(0xC00D9C40L)

//
// MessageId: MF_E_CLOCK_NO_TIME_SOURCE
//
// MessageText:
//
// No Presentation Time Source has been specified.%0
//
#define MF_E_CLOCK_NO_TIME_SOURCE        _HRESULT_TYPEDEF_(0xC00D9C41L)

//
// MessageId: MF_E_CLOCK_STATE_ALREADY_SET
//
// MessageText:
//
// The clock is already in the requested state.%0
//
#define MF_E_CLOCK_STATE_ALREADY_SET     _HRESULT_TYPEDEF_(0xC00D9C42L)

//
// MessageId: MF_E_CLOCK_NOT_SIMPLE
//
// MessageText:
//
// The clock has too many advanced features to carry out the request.%0
//
#define MF_E_CLOCK_NOT_SIMPLE            _HRESULT_TYPEDEF_(0xC00D9C43L)

//
// MessageId: MF_S_CLOCK_STOPPED
//
// MessageText:
//
// Timer::SetTimer returns this success code if called happened while timer is stopped. Timer is not going to be dispatched until clock is running%0
//
#define MF_S_CLOCK_STOPPED               _HRESULT_TYPEDEF_(0x000D9C44L)


//////////////////////////////////////////////////////////////////////////////
//
// MF Quality Management errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_NO_MORE_DROP_MODES
//
// MessageText:
//
// The component does not support any more drop modes.%0
//
#define MF_E_NO_MORE_DROP_MODES          _HRESULT_TYPEDEF_(0xC00DA028L)

//
// MessageId: MF_E_NO_MORE_QUALITY_LEVELS
//
// MessageText:
//
// The component does not support any more quality levels.%0
//
#define MF_E_NO_MORE_QUALITY_LEVELS      _HRESULT_TYPEDEF_(0xC00DA029L)

//
// MessageId: MF_E_DROPTIME_NOT_SUPPORTED
//
// MessageText:
//
// The component does not support drop time functionality.%0
//
#define MF_E_DROPTIME_NOT_SUPPORTED      _HRESULT_TYPEDEF_(0xC00DA02AL)

//
// MessageId: MF_E_QUALITYKNOB_WAIT_LONGER
//
// MessageText:
//
// Quality Manager needs to wait longer before bumping the Quality Level up.%0
//
#define MF_E_QUALITYKNOB_WAIT_LONGER     _HRESULT_TYPEDEF_(0xC00DA02BL)

//
// MessageId: MF_E_QM_INVALIDSTATE
//
// MessageText:
//
// Quality Manager is in an invalid state. Quality Management is off at this moment.%0
//
#define MF_E_QM_INVALIDSTATE             _HRESULT_TYPEDEF_(0xC00DA02CL)


//////////////////////////////////////////////////////////////////////////////
//
// MF Transcode errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_TRANSCODE_NO_CONTAINERTYPE
//
// MessageText:
//
// No transcode output container type is specified.%0
//
#define MF_E_TRANSCODE_NO_CONTAINERTYPE  _HRESULT_TYPEDEF_(0xC00DA410L)

//
// MessageId: MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS
//
// MessageText:
//
// The profile does not have a media type configuration for any selected source streams.%0
//
#define MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS _HRESULT_TYPEDEF_(0xC00DA411L)

//
// MessageId: MF_E_TRANSCODE_NO_MATCHING_ENCODER
//
// MessageText:
//
// Cannot find an encoder MFT that accepts the user preferred output type.%0
//
#define MF_E_TRANSCODE_NO_MATCHING_ENCODER _HRESULT_TYPEDEF_(0xC00DA412L)


//////////////////////////////////////////////////////////////////////////////
//
// MF HW Device Proxy errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_ALLOCATOR_NOT_INITIALIZED
//
// MessageText:
//
// Memory allocator is not initialized.%0
//
#define MF_E_ALLOCATOR_NOT_INITIALIZED   _HRESULT_TYPEDEF_(0xC00DA7F8L)

//
// MessageId: MF_E_ALLOCATOR_NOT_COMMITED
//
// MessageText:
//
// Memory allocator is not committed yet.%0
//
#define MF_E_ALLOCATOR_NOT_COMMITED      _HRESULT_TYPEDEF_(0xC00DA7F9L)

//
// MessageId: MF_E_ALLOCATOR_ALREADY_COMMITED
//
// MessageText:
//
// Memory allocator has already been committed.%0
//
#define MF_E_ALLOCATOR_ALREADY_COMMITED  _HRESULT_TYPEDEF_(0xC00DA7FAL)

//
// MessageId: MF_E_STREAM_ERROR
//
// MessageText:
//
// An error occurred in media stream.%0
//
#define MF_E_STREAM_ERROR                _HRESULT_TYPEDEF_(0xC00DA7FBL)

//
// MessageId: MF_E_INVALID_STREAM_STATE
//
// MessageText:
//
// Stream is not in a state to handle the request.%0
//
#define MF_E_INVALID_STREAM_STATE        _HRESULT_TYPEDEF_(0xC00DA7FCL)

//
// MessageId: MF_E_HW_STREAM_NOT_CONNECTED
//
// MessageText:
//
// Hardware stream is not connected yet.%0
//
#define MF_E_HW_STREAM_NOT_CONNECTED     _HRESULT_TYPEDEF_(0xC00DA7FDL)

#endif // _MFERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\metadataparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for MetadataParser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __MetadataParser_h__
#define __MetadataParser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMetadataMunger_FWD_DEFINED__
#define __IMetadataMunger_FWD_DEFINED__
typedef interface IMetadataMunger IMetadataMunger;
#endif 	/* __IMetadataMunger_FWD_DEFINED__ */


#ifndef __IMetaDataParser_FWD_DEFINED__
#define __IMetaDataParser_FWD_DEFINED__
typedef interface IMetaDataParser IMetaDataParser;
#endif 	/* __IMetaDataParser_FWD_DEFINED__ */


#ifndef __MetaDataParser_FWD_DEFINED__
#define __MetaDataParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class MetaDataParser MetaDataParser;
#else
typedef struct MetaDataParser MetaDataParser;
#endif /* __cplusplus */

#endif 	/* __MetaDataParser_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IMetadataMunger_INTERFACE_DEFINED__
#define __IMetadataMunger_INTERFACE_DEFINED__

/* interface IMetadataMunger */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMetadataMunger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2144D706-BFD3-462f-BFF2-7154D56623F9")
    IMetadataMunger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKeySetSize( 
            /* [retval][out] */ DWORD *dwKeySetSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataValueAtIndex( 
            /* [in] */ int index,
            /* [ref][out] */ DWORD *mediaLibraryProperty,
            /* [ref][out] */ VARIANT *varData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataValueForPropertyCode( 
            /* [in] */ DWORD mediaLibraryProperty,
            /* [ref][out] */ VARIANT *varData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinalProcessing( 
            /* [in] */ IUnknown *pImediaObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetadataMungerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMetadataMunger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMetadataMunger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMetadataMunger * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKeySetSize )( 
            IMetadataMunger * This,
            /* [retval][out] */ DWORD *dwKeySetSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetaDataValueAtIndex )( 
            IMetadataMunger * This,
            /* [in] */ int index,
            /* [ref][out] */ DWORD *mediaLibraryProperty,
            /* [ref][out] */ VARIANT *varData);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetaDataValueForPropertyCode )( 
            IMetadataMunger * This,
            /* [in] */ DWORD mediaLibraryProperty,
            /* [ref][out] */ VARIANT *varData);
        
        HRESULT ( STDMETHODCALLTYPE *FinalProcessing )( 
            IMetadataMunger * This,
            /* [in] */ IUnknown *pImediaObject);
        
        END_INTERFACE
    } IMetadataMungerVtbl;

    interface IMetadataMunger
    {
        CONST_VTBL struct IMetadataMungerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetadataMunger_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMetadataMunger_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMetadataMunger_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMetadataMunger_GetPropertyKeySetSize(This,dwKeySetSize)	\
    ( (This)->lpVtbl -> GetPropertyKeySetSize(This,dwKeySetSize) ) 

#define IMetadataMunger_GetMetaDataValueAtIndex(This,index,mediaLibraryProperty,varData)	\
    ( (This)->lpVtbl -> GetMetaDataValueAtIndex(This,index,mediaLibraryProperty,varData) ) 

#define IMetadataMunger_GetMetaDataValueForPropertyCode(This,mediaLibraryProperty,varData)	\
    ( (This)->lpVtbl -> GetMetaDataValueForPropertyCode(This,mediaLibraryProperty,varData) ) 

#define IMetadataMunger_FinalProcessing(This,pImediaObject)	\
    ( (This)->lpVtbl -> FinalProcessing(This,pImediaObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMetadataMunger_INTERFACE_DEFINED__ */


#ifndef __IMetaDataParser_INTERFACE_DEFINED__
#define __IMetaDataParser_INTERFACE_DEFINED__

/* interface IMetaDataParser */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMetaDataParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74291EC2-094B-45af-BE16-5639B8B42791")
    IMetaDataParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMungerInstance( 
            /* [in] */ BSTR bstrFileURL,
            /* [retval][out] */ IMetadataMunger **ppMetadataMunger) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetaDataParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMetaDataParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMetaDataParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMetaDataParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMungerInstance )( 
            IMetaDataParser * This,
            /* [in] */ BSTR bstrFileURL,
            /* [retval][out] */ IMetadataMunger **ppMetadataMunger);
        
        END_INTERFACE
    } IMetaDataParserVtbl;

    interface IMetaDataParser
    {
        CONST_VTBL struct IMetaDataParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetaDataParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMetaDataParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMetaDataParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMetaDataParser_CreateMungerInstance(This,bstrFileURL,ppMetadataMunger)	\
    ( (This)->lpVtbl -> CreateMungerInstance(This,bstrFileURL,ppMetadataMunger) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMetaDataParser_INTERFACE_DEFINED__ */



#ifndef __MetaDataParserLib_LIBRARY_DEFINED__
#define __MetaDataParserLib_LIBRARY_DEFINED__

/* library MetaDataParserLib */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_MetaDataParserLib;

EXTERN_C const CLSID CLSID_MetaDataParser;

#ifdef __cplusplus

class DECLSPEC_UUID("9E164D20-64A5-411e-B690-880DD2C6D5D9")
MetaDataParser;
#endif
#endif /* __MetaDataParserLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mfidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for mfidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mfidl_h__
#define __mfidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMFMediaSession_FWD_DEFINED__
#define __IMFMediaSession_FWD_DEFINED__
typedef interface IMFMediaSession IMFMediaSession;
#endif 	/* __IMFMediaSession_FWD_DEFINED__ */


#ifndef __IMFSourceResolver_FWD_DEFINED__
#define __IMFSourceResolver_FWD_DEFINED__
typedef interface IMFSourceResolver IMFSourceResolver;
#endif 	/* __IMFSourceResolver_FWD_DEFINED__ */


#ifndef __IMFMediaSource_FWD_DEFINED__
#define __IMFMediaSource_FWD_DEFINED__
typedef interface IMFMediaSource IMFMediaSource;
#endif 	/* __IMFMediaSource_FWD_DEFINED__ */


#ifndef __IMFMediaStream_FWD_DEFINED__
#define __IMFMediaStream_FWD_DEFINED__
typedef interface IMFMediaStream IMFMediaStream;
#endif 	/* __IMFMediaStream_FWD_DEFINED__ */


#ifndef __IMFMediaSink_FWD_DEFINED__
#define __IMFMediaSink_FWD_DEFINED__
typedef interface IMFMediaSink IMFMediaSink;
#endif 	/* __IMFMediaSink_FWD_DEFINED__ */


#ifndef __IMFStreamSink_FWD_DEFINED__
#define __IMFStreamSink_FWD_DEFINED__
typedef interface IMFStreamSink IMFStreamSink;
#endif 	/* __IMFStreamSink_FWD_DEFINED__ */


#ifndef __IMFVideoSampleAllocator_FWD_DEFINED__
#define __IMFVideoSampleAllocator_FWD_DEFINED__
typedef interface IMFVideoSampleAllocator IMFVideoSampleAllocator;
#endif 	/* __IMFVideoSampleAllocator_FWD_DEFINED__ */


#ifndef __IMFVideoSampleAllocatorNotify_FWD_DEFINED__
#define __IMFVideoSampleAllocatorNotify_FWD_DEFINED__
typedef interface IMFVideoSampleAllocatorNotify IMFVideoSampleAllocatorNotify;
#endif 	/* __IMFVideoSampleAllocatorNotify_FWD_DEFINED__ */


#ifndef __IMFVideoSampleAllocatorCallback_FWD_DEFINED__
#define __IMFVideoSampleAllocatorCallback_FWD_DEFINED__
typedef interface IMFVideoSampleAllocatorCallback IMFVideoSampleAllocatorCallback;
#endif 	/* __IMFVideoSampleAllocatorCallback_FWD_DEFINED__ */


#ifndef __IMFTopology_FWD_DEFINED__
#define __IMFTopology_FWD_DEFINED__
typedef interface IMFTopology IMFTopology;
#endif 	/* __IMFTopology_FWD_DEFINED__ */


#ifndef __IMFTopologyNode_FWD_DEFINED__
#define __IMFTopologyNode_FWD_DEFINED__
typedef interface IMFTopologyNode IMFTopologyNode;
#endif 	/* __IMFTopologyNode_FWD_DEFINED__ */


#ifndef __IMFGetService_FWD_DEFINED__
#define __IMFGetService_FWD_DEFINED__
typedef interface IMFGetService IMFGetService;
#endif 	/* __IMFGetService_FWD_DEFINED__ */


#ifndef __IMFClock_FWD_DEFINED__
#define __IMFClock_FWD_DEFINED__
typedef interface IMFClock IMFClock;
#endif 	/* __IMFClock_FWD_DEFINED__ */


#ifndef __IMFPresentationClock_FWD_DEFINED__
#define __IMFPresentationClock_FWD_DEFINED__
typedef interface IMFPresentationClock IMFPresentationClock;
#endif 	/* __IMFPresentationClock_FWD_DEFINED__ */


#ifndef __IMFPresentationTimeSource_FWD_DEFINED__
#define __IMFPresentationTimeSource_FWD_DEFINED__
typedef interface IMFPresentationTimeSource IMFPresentationTimeSource;
#endif 	/* __IMFPresentationTimeSource_FWD_DEFINED__ */


#ifndef __IMFClockStateSink_FWD_DEFINED__
#define __IMFClockStateSink_FWD_DEFINED__
typedef interface IMFClockStateSink IMFClockStateSink;
#endif 	/* __IMFClockStateSink_FWD_DEFINED__ */


#ifndef __IMFPresentationDescriptor_FWD_DEFINED__
#define __IMFPresentationDescriptor_FWD_DEFINED__
typedef interface IMFPresentationDescriptor IMFPresentationDescriptor;
#endif 	/* __IMFPresentationDescriptor_FWD_DEFINED__ */


#ifndef __IMFStreamDescriptor_FWD_DEFINED__
#define __IMFStreamDescriptor_FWD_DEFINED__
typedef interface IMFStreamDescriptor IMFStreamDescriptor;
#endif 	/* __IMFStreamDescriptor_FWD_DEFINED__ */


#ifndef __IMFMediaTypeHandler_FWD_DEFINED__
#define __IMFMediaTypeHandler_FWD_DEFINED__
typedef interface IMFMediaTypeHandler IMFMediaTypeHandler;
#endif 	/* __IMFMediaTypeHandler_FWD_DEFINED__ */


#ifndef __IMFTimer_FWD_DEFINED__
#define __IMFTimer_FWD_DEFINED__
typedef interface IMFTimer IMFTimer;
#endif 	/* __IMFTimer_FWD_DEFINED__ */


#ifndef __IMFShutdown_FWD_DEFINED__
#define __IMFShutdown_FWD_DEFINED__
typedef interface IMFShutdown IMFShutdown;
#endif 	/* __IMFShutdown_FWD_DEFINED__ */


#ifndef __IMFTopoLoader_FWD_DEFINED__
#define __IMFTopoLoader_FWD_DEFINED__
typedef interface IMFTopoLoader IMFTopoLoader;
#endif 	/* __IMFTopoLoader_FWD_DEFINED__ */


#ifndef __IMFContentProtectionManager_FWD_DEFINED__
#define __IMFContentProtectionManager_FWD_DEFINED__
typedef interface IMFContentProtectionManager IMFContentProtectionManager;
#endif 	/* __IMFContentProtectionManager_FWD_DEFINED__ */


#ifndef __IMFContentEnabler_FWD_DEFINED__
#define __IMFContentEnabler_FWD_DEFINED__
typedef interface IMFContentEnabler IMFContentEnabler;
#endif 	/* __IMFContentEnabler_FWD_DEFINED__ */


#ifndef __IMFMetadata_FWD_DEFINED__
#define __IMFMetadata_FWD_DEFINED__
typedef interface IMFMetadata IMFMetadata;
#endif 	/* __IMFMetadata_FWD_DEFINED__ */


#ifndef __IMFMetadataProvider_FWD_DEFINED__
#define __IMFMetadataProvider_FWD_DEFINED__
typedef interface IMFMetadataProvider IMFMetadataProvider;
#endif 	/* __IMFMetadataProvider_FWD_DEFINED__ */


#ifndef __IMFRateSupport_FWD_DEFINED__
#define __IMFRateSupport_FWD_DEFINED__
typedef interface IMFRateSupport IMFRateSupport;
#endif 	/* __IMFRateSupport_FWD_DEFINED__ */


#ifndef __IMFRateControl_FWD_DEFINED__
#define __IMFRateControl_FWD_DEFINED__
typedef interface IMFRateControl IMFRateControl;
#endif 	/* __IMFRateControl_FWD_DEFINED__ */


#ifndef __IMFTimecodeTranslate_FWD_DEFINED__
#define __IMFTimecodeTranslate_FWD_DEFINED__
typedef interface IMFTimecodeTranslate IMFTimecodeTranslate;
#endif 	/* __IMFTimecodeTranslate_FWD_DEFINED__ */


#ifndef __IMFSimpleAudioVolume_FWD_DEFINED__
#define __IMFSimpleAudioVolume_FWD_DEFINED__
typedef interface IMFSimpleAudioVolume IMFSimpleAudioVolume;
#endif 	/* __IMFSimpleAudioVolume_FWD_DEFINED__ */


#ifndef __IMFAudioStreamVolume_FWD_DEFINED__
#define __IMFAudioStreamVolume_FWD_DEFINED__
typedef interface IMFAudioStreamVolume IMFAudioStreamVolume;
#endif 	/* __IMFAudioStreamVolume_FWD_DEFINED__ */


#ifndef __IMFAudioPolicy_FWD_DEFINED__
#define __IMFAudioPolicy_FWD_DEFINED__
typedef interface IMFAudioPolicy IMFAudioPolicy;
#endif 	/* __IMFAudioPolicy_FWD_DEFINED__ */


#ifndef __IMFSampleGrabberSinkCallback_FWD_DEFINED__
#define __IMFSampleGrabberSinkCallback_FWD_DEFINED__
typedef interface IMFSampleGrabberSinkCallback IMFSampleGrabberSinkCallback;
#endif 	/* __IMFSampleGrabberSinkCallback_FWD_DEFINED__ */


#ifndef __IMFSampleGrabberSinkCallback2_FWD_DEFINED__
#define __IMFSampleGrabberSinkCallback2_FWD_DEFINED__
typedef interface IMFSampleGrabberSinkCallback2 IMFSampleGrabberSinkCallback2;
#endif 	/* __IMFSampleGrabberSinkCallback2_FWD_DEFINED__ */


#ifndef __IMFWorkQueueServices_FWD_DEFINED__
#define __IMFWorkQueueServices_FWD_DEFINED__
typedef interface IMFWorkQueueServices IMFWorkQueueServices;
#endif 	/* __IMFWorkQueueServices_FWD_DEFINED__ */


#ifndef __IMFQualityManager_FWD_DEFINED__
#define __IMFQualityManager_FWD_DEFINED__
typedef interface IMFQualityManager IMFQualityManager;
#endif 	/* __IMFQualityManager_FWD_DEFINED__ */


#ifndef __IMFQualityAdvise_FWD_DEFINED__
#define __IMFQualityAdvise_FWD_DEFINED__
typedef interface IMFQualityAdvise IMFQualityAdvise;
#endif 	/* __IMFQualityAdvise_FWD_DEFINED__ */


#ifndef __IMFQualityAdviseLimits_FWD_DEFINED__
#define __IMFQualityAdviseLimits_FWD_DEFINED__
typedef interface IMFQualityAdviseLimits IMFQualityAdviseLimits;
#endif 	/* __IMFQualityAdviseLimits_FWD_DEFINED__ */


#ifndef __IMFRealTimeClient_FWD_DEFINED__
#define __IMFRealTimeClient_FWD_DEFINED__
typedef interface IMFRealTimeClient IMFRealTimeClient;
#endif 	/* __IMFRealTimeClient_FWD_DEFINED__ */


#ifndef __IMFSequencerSource_FWD_DEFINED__
#define __IMFSequencerSource_FWD_DEFINED__
typedef interface IMFSequencerSource IMFSequencerSource;
#endif 	/* __IMFSequencerSource_FWD_DEFINED__ */


#ifndef __IMFMediaSourceTopologyProvider_FWD_DEFINED__
#define __IMFMediaSourceTopologyProvider_FWD_DEFINED__
typedef interface IMFMediaSourceTopologyProvider IMFMediaSourceTopologyProvider;
#endif 	/* __IMFMediaSourceTopologyProvider_FWD_DEFINED__ */


#ifndef __IMFMediaSourcePresentationProvider_FWD_DEFINED__
#define __IMFMediaSourcePresentationProvider_FWD_DEFINED__
typedef interface IMFMediaSourcePresentationProvider IMFMediaSourcePresentationProvider;
#endif 	/* __IMFMediaSourcePresentationProvider_FWD_DEFINED__ */


#ifndef __IMFTopologyNodeAttributeEditor_FWD_DEFINED__
#define __IMFTopologyNodeAttributeEditor_FWD_DEFINED__
typedef interface IMFTopologyNodeAttributeEditor IMFTopologyNodeAttributeEditor;
#endif 	/* __IMFTopologyNodeAttributeEditor_FWD_DEFINED__ */


#ifndef __IMFByteStreamBuffering_FWD_DEFINED__
#define __IMFByteStreamBuffering_FWD_DEFINED__
typedef interface IMFByteStreamBuffering IMFByteStreamBuffering;
#endif 	/* __IMFByteStreamBuffering_FWD_DEFINED__ */


#ifndef __IMFNetCredential_FWD_DEFINED__
#define __IMFNetCredential_FWD_DEFINED__
typedef interface IMFNetCredential IMFNetCredential;
#endif 	/* __IMFNetCredential_FWD_DEFINED__ */


#ifndef __IMFNetCredentialManager_FWD_DEFINED__
#define __IMFNetCredentialManager_FWD_DEFINED__
typedef interface IMFNetCredentialManager IMFNetCredentialManager;
#endif 	/* __IMFNetCredentialManager_FWD_DEFINED__ */


#ifndef __IMFNetCredentialCache_FWD_DEFINED__
#define __IMFNetCredentialCache_FWD_DEFINED__
typedef interface IMFNetCredentialCache IMFNetCredentialCache;
#endif 	/* __IMFNetCredentialCache_FWD_DEFINED__ */


#ifndef __IMFSSLCertificateManager_FWD_DEFINED__
#define __IMFSSLCertificateManager_FWD_DEFINED__
typedef interface IMFSSLCertificateManager IMFSSLCertificateManager;
#endif 	/* __IMFSSLCertificateManager_FWD_DEFINED__ */


#ifndef __IMFSourceOpenMonitor_FWD_DEFINED__
#define __IMFSourceOpenMonitor_FWD_DEFINED__
typedef interface IMFSourceOpenMonitor IMFSourceOpenMonitor;
#endif 	/* __IMFSourceOpenMonitor_FWD_DEFINED__ */


#ifndef __IMFNetProxyLocator_FWD_DEFINED__
#define __IMFNetProxyLocator_FWD_DEFINED__
typedef interface IMFNetProxyLocator IMFNetProxyLocator;
#endif 	/* __IMFNetProxyLocator_FWD_DEFINED__ */


#ifndef __IMFNetProxyLocatorFactory_FWD_DEFINED__
#define __IMFNetProxyLocatorFactory_FWD_DEFINED__
typedef interface IMFNetProxyLocatorFactory IMFNetProxyLocatorFactory;
#endif 	/* __IMFNetProxyLocatorFactory_FWD_DEFINED__ */


#ifndef __IMFSaveJob_FWD_DEFINED__
#define __IMFSaveJob_FWD_DEFINED__
typedef interface IMFSaveJob IMFSaveJob;
#endif 	/* __IMFSaveJob_FWD_DEFINED__ */


#ifndef __IMFNetSchemeHandlerConfig_FWD_DEFINED__
#define __IMFNetSchemeHandlerConfig_FWD_DEFINED__
typedef interface IMFNetSchemeHandlerConfig IMFNetSchemeHandlerConfig;
#endif 	/* __IMFNetSchemeHandlerConfig_FWD_DEFINED__ */


#ifndef __IMFSchemeHandler_FWD_DEFINED__
#define __IMFSchemeHandler_FWD_DEFINED__
typedef interface IMFSchemeHandler IMFSchemeHandler;
#endif 	/* __IMFSchemeHandler_FWD_DEFINED__ */


#ifndef __IMFByteStreamHandler_FWD_DEFINED__
#define __IMFByteStreamHandler_FWD_DEFINED__
typedef interface IMFByteStreamHandler IMFByteStreamHandler;
#endif 	/* __IMFByteStreamHandler_FWD_DEFINED__ */


#ifndef __IMFTrustedInput_FWD_DEFINED__
#define __IMFTrustedInput_FWD_DEFINED__
typedef interface IMFTrustedInput IMFTrustedInput;
#endif 	/* __IMFTrustedInput_FWD_DEFINED__ */


#ifndef __IMFInputTrustAuthority_FWD_DEFINED__
#define __IMFInputTrustAuthority_FWD_DEFINED__
typedef interface IMFInputTrustAuthority IMFInputTrustAuthority;
#endif 	/* __IMFInputTrustAuthority_FWD_DEFINED__ */


#ifndef __IMFTrustedOutput_FWD_DEFINED__
#define __IMFTrustedOutput_FWD_DEFINED__
typedef interface IMFTrustedOutput IMFTrustedOutput;
#endif 	/* __IMFTrustedOutput_FWD_DEFINED__ */


#ifndef __IMFOutputTrustAuthority_FWD_DEFINED__
#define __IMFOutputTrustAuthority_FWD_DEFINED__
typedef interface IMFOutputTrustAuthority IMFOutputTrustAuthority;
#endif 	/* __IMFOutputTrustAuthority_FWD_DEFINED__ */


#ifndef __IMFOutputPolicy_FWD_DEFINED__
#define __IMFOutputPolicy_FWD_DEFINED__
typedef interface IMFOutputPolicy IMFOutputPolicy;
#endif 	/* __IMFOutputPolicy_FWD_DEFINED__ */


#ifndef __IMFOutputSchema_FWD_DEFINED__
#define __IMFOutputSchema_FWD_DEFINED__
typedef interface IMFOutputSchema IMFOutputSchema;
#endif 	/* __IMFOutputSchema_FWD_DEFINED__ */


#ifndef __IMFSecureChannel_FWD_DEFINED__
#define __IMFSecureChannel_FWD_DEFINED__
typedef interface IMFSecureChannel IMFSecureChannel;
#endif 	/* __IMFSecureChannel_FWD_DEFINED__ */


#ifndef __IMFSampleProtection_FWD_DEFINED__
#define __IMFSampleProtection_FWD_DEFINED__
typedef interface IMFSampleProtection IMFSampleProtection;
#endif 	/* __IMFSampleProtection_FWD_DEFINED__ */


#ifndef __IMFMediaSinkPreroll_FWD_DEFINED__
#define __IMFMediaSinkPreroll_FWD_DEFINED__
typedef interface IMFMediaSinkPreroll IMFMediaSinkPreroll;
#endif 	/* __IMFMediaSinkPreroll_FWD_DEFINED__ */


#ifndef __IMFFinalizableMediaSink_FWD_DEFINED__
#define __IMFFinalizableMediaSink_FWD_DEFINED__
typedef interface IMFFinalizableMediaSink IMFFinalizableMediaSink;
#endif 	/* __IMFFinalizableMediaSink_FWD_DEFINED__ */


#ifndef __IMFStreamingSinkConfig_FWD_DEFINED__
#define __IMFStreamingSinkConfig_FWD_DEFINED__
typedef interface IMFStreamingSinkConfig IMFStreamingSinkConfig;
#endif 	/* __IMFStreamingSinkConfig_FWD_DEFINED__ */


#ifndef __IMFRemoteProxy_FWD_DEFINED__
#define __IMFRemoteProxy_FWD_DEFINED__
typedef interface IMFRemoteProxy IMFRemoteProxy;
#endif 	/* __IMFRemoteProxy_FWD_DEFINED__ */


#ifndef __IMFObjectReferenceStream_FWD_DEFINED__
#define __IMFObjectReferenceStream_FWD_DEFINED__
typedef interface IMFObjectReferenceStream IMFObjectReferenceStream;
#endif 	/* __IMFObjectReferenceStream_FWD_DEFINED__ */


#ifndef __IMFPMPHost_FWD_DEFINED__
#define __IMFPMPHost_FWD_DEFINED__
typedef interface IMFPMPHost IMFPMPHost;
#endif 	/* __IMFPMPHost_FWD_DEFINED__ */


#ifndef __IMFPMPClient_FWD_DEFINED__
#define __IMFPMPClient_FWD_DEFINED__
typedef interface IMFPMPClient IMFPMPClient;
#endif 	/* __IMFPMPClient_FWD_DEFINED__ */


#ifndef __IMFPMPServer_FWD_DEFINED__
#define __IMFPMPServer_FWD_DEFINED__
typedef interface IMFPMPServer IMFPMPServer;
#endif 	/* __IMFPMPServer_FWD_DEFINED__ */


#ifndef __IMFRemoteDesktopPlugin_FWD_DEFINED__
#define __IMFRemoteDesktopPlugin_FWD_DEFINED__
typedef interface IMFRemoteDesktopPlugin IMFRemoteDesktopPlugin;
#endif 	/* __IMFRemoteDesktopPlugin_FWD_DEFINED__ */


#ifndef __IMFSAMIStyle_FWD_DEFINED__
#define __IMFSAMIStyle_FWD_DEFINED__
typedef interface IMFSAMIStyle IMFSAMIStyle;
#endif 	/* __IMFSAMIStyle_FWD_DEFINED__ */


#ifndef __IMFTranscodeProfile_FWD_DEFINED__
#define __IMFTranscodeProfile_FWD_DEFINED__
typedef interface IMFTranscodeProfile IMFTranscodeProfile;
#endif 	/* __IMFTranscodeProfile_FWD_DEFINED__ */


#ifndef __IMFTranscodeSinkInfoProvider_FWD_DEFINED__
#define __IMFTranscodeSinkInfoProvider_FWD_DEFINED__
typedef interface IMFTranscodeSinkInfoProvider IMFTranscodeSinkInfoProvider;
#endif 	/* __IMFTranscodeSinkInfoProvider_FWD_DEFINED__ */


#ifndef __IMFFieldOfUseMFTUnlock_FWD_DEFINED__
#define __IMFFieldOfUseMFTUnlock_FWD_DEFINED__
typedef interface IMFFieldOfUseMFTUnlock IMFFieldOfUseMFTUnlock;
#endif 	/* __IMFFieldOfUseMFTUnlock_FWD_DEFINED__ */


#ifndef __IMFLocalMFTRegistration_FWD_DEFINED__
#define __IMFLocalMFTRegistration_FWD_DEFINED__
typedef interface IMFLocalMFTRegistration IMFLocalMFTRegistration;
#endif 	/* __IMFLocalMFTRegistration_FWD_DEFINED__ */


/* header files for imported files */
#include "mfobjects.h"
#include "mftransform.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mfidl_0000_0000 */
/* [local] */ 

#include <windef.h>
typedef 
enum MFSESSION_SETTOPOLOGY_FLAGS
    {	MFSESSION_SETTOPOLOGY_IMMEDIATE	= 0x1,
	MFSESSION_SETTOPOLOGY_NORESOLUTION	= 0x2,
	MFSESSION_SETTOPOLOGY_CLEAR_CURRENT	= 0x4
    } 	MFSESSION_SETTOPOLOGY_FLAGS;

typedef 
enum MFSESSION_GETFULLTOPOLOGY_FLAGS
    {	MFSESSION_GETFULLTOPOLOGY_CURRENT	= 0x1
    } 	MFSESSION_GETFULLTOPOLOGY_FLAGS;

typedef 
enum MFPMPSESSION_CREATION_FLAGS
    {	MFPMPSESSION_UNPROTECTED_PROCESS	= 0x1
    } 	MFPMPSESSION_CREATION_FLAGS;

typedef unsigned __int64 TOPOID;






extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0000_v0_0_s_ifspec;

#ifndef __IMFMediaSession_INTERFACE_DEFINED__
#define __IMFMediaSession_INTERFACE_DEFINED__

/* interface IMFMediaSession */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90377834-21D0-4dee-8214-BA2E3E6C1127")
    IMFMediaSession : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTopology( 
            /* [in] */ DWORD dwSetTopologyFlags,
            /* [in] */ IMFTopology *pTopology) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearTopologies( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [unique][in] */ const GUID *pguidTimeFormat,
            /* [unique][in] */ const PROPVARIANT *pvarStartPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClock( 
            /* [out] */ IMFClock **ppClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionCapabilities( 
            /* [out] */ DWORD *pdwCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullTopology( 
            /* [in] */ DWORD dwGetFullTopologyFlags,
            /* [in] */ TOPOID TopoId,
            /* [out] */ IMFTopology **ppFullTopology) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMFMediaSession * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaSession * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaSession * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            IMFMediaSession * This,
            /* [in] */ MediaEventType met,
            /* [in] */ REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTopology )( 
            IMFMediaSession * This,
            /* [in] */ DWORD dwSetTopologyFlags,
            /* [in] */ IMFTopology *pTopology);
        
        HRESULT ( STDMETHODCALLTYPE *ClearTopologies )( 
            IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IMFMediaSession * This,
            /* [unique][in] */ const GUID *pguidTimeFormat,
            /* [unique][in] */ const PROPVARIANT *pvarStartPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClock )( 
            IMFMediaSession * This,
            /* [out] */ IMFClock **ppClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionCapabilities )( 
            IMFMediaSession * This,
            /* [out] */ DWORD *pdwCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullTopology )( 
            IMFMediaSession * This,
            /* [in] */ DWORD dwGetFullTopologyFlags,
            /* [in] */ TOPOID TopoId,
            /* [out] */ IMFTopology **ppFullTopology);
        
        END_INTERFACE
    } IMFMediaSessionVtbl;

    interface IMFMediaSession
    {
        CONST_VTBL struct IMFMediaSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaSession_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaSession_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaSession_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaSession_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaSession_SetTopology(This,dwSetTopologyFlags,pTopology)	\
    ( (This)->lpVtbl -> SetTopology(This,dwSetTopologyFlags,pTopology) ) 

#define IMFMediaSession_ClearTopologies(This)	\
    ( (This)->lpVtbl -> ClearTopologies(This) ) 

#define IMFMediaSession_Start(This,pguidTimeFormat,pvarStartPosition)	\
    ( (This)->lpVtbl -> Start(This,pguidTimeFormat,pvarStartPosition) ) 

#define IMFMediaSession_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMFMediaSession_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMFMediaSession_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IMFMediaSession_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IMFMediaSession_GetClock(This,ppClock)	\
    ( (This)->lpVtbl -> GetClock(This,ppClock) ) 

#define IMFMediaSession_GetSessionCapabilities(This,pdwCaps)	\
    ( (This)->lpVtbl -> GetSessionCapabilities(This,pdwCaps) ) 

#define IMFMediaSession_GetFullTopology(This,dwGetFullTopologyFlags,TopoId,ppFullTopology)	\
    ( (This)->lpVtbl -> GetFullTopology(This,dwGetFullTopologyFlags,TopoId,ppFullTopology) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0001 */
/* [local] */ 

EXTERN_GUID( MF_SESSION_TOPOLOADER, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x71);
EXTERN_GUID( MF_SESSION_GLOBAL_TIME, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x72);
EXTERN_GUID( MF_SESSION_QUALITY_MANAGER, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x73);
EXTERN_GUID( MF_SESSION_CONTENT_PROTECTION_MANAGER, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x74);
EXTERN_GUID( MF_SESSION_SERVER_CONTEXT, 0xafe5b291, 0x50fa, 0x46e8, 0xb9, 0xbe, 0xc, 0xc, 0x3c, 0xe4, 0xb3, 0xa5);
EXTERN_GUID( MF_SESSION_REMOTE_SOURCE_MODE, 0xf4033ef4, 0x9bb3, 0x4378, 0x94, 0x1f, 0x85, 0xa0, 0x85, 0x6b, 0xc2, 0x44);
EXTERN_GUID( MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME, 0x190e852f, 0x6238, 0x42d1, 0xb5, 0xaf, 0x69, 0xea, 0x33, 0x8e, 0xf8, 0x50);
EXTERN_GUID( MF_PMP_SERVER_CONTEXT, 0x2f00c910, 0xd2cf, 0x4278, 0x8b, 0x6a, 0xd0, 0x77, 0xfa, 0xc3, 0xa2, 0x5f);
STDAPI MFCreateMediaSession(
    IMFAttributes* pConfiguration,
    __out IMFMediaSession** ppMediaSession
    );
STDAPI MFCreatePMPMediaSession(
    DWORD dwCreationFlags,
    IMFAttributes *pConfiguration,
    __out IMFMediaSession** ppMediaSession,
    __out_opt IMFActivate **ppEnablerActivate
    );
typedef 
enum MF_OBJECT_TYPE
    {	MF_OBJECT_MEDIASOURCE	= 0,
	MF_OBJECT_BYTESTREAM	= ( MF_OBJECT_MEDIASOURCE + 1 ) ,
	MF_OBJECT_INVALID	= ( MF_OBJECT_BYTESTREAM + 1 ) 
    } 	MF_OBJECT_TYPE;


enum __MIDL___MIDL_itf_mfidl_0000_0001_0001
    {	MF_RESOLUTION_MEDIASOURCE	= 0x1,
	MF_RESOLUTION_BYTESTREAM	= 0x2,
	MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE	= 0x10,
	MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL	= 0x20,
	MF_RESOLUTION_READ	= 0x10000,
	MF_RESOLUTION_WRITE	= 0x20000
    } ;
typedef 
enum _MF_CONNECT_METHOD
    {	MF_CONNECT_DIRECT	= 0,
	MF_CONNECT_ALLOW_CONVERTER	= 0x1,
	MF_CONNECT_ALLOW_DECODER	= 0x3,
	MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES	= 0x4,
	MF_CONNECT_AS_OPTIONAL	= 0x10000,
	MF_CONNECT_AS_OPTIONAL_BRANCH	= 0x20000
    } 	MF_CONNECT_METHOD;

typedef 
enum _MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS
    {	MF_TOPOLOGY_RESOLUTION_SUCCEEDED	= 0,
	MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE	= 0x1,
	MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS	= 0x2
    } 	MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS;




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0001_v0_0_s_ifspec;

#ifndef __IMFSourceResolver_INTERFACE_DEFINED__
#define __IMFSourceResolver_INTERFACE_DEFINED__

/* interface IMFSourceResolver */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFSourceResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FBE5A32D-A497-4b61-BB85-97B1A848A6E3")
    IMFSourceResolver : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateObjectFromURL( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateObjectFromByteStream( 
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BeginCreateObjectFromURL( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EndCreateObjectFromURL( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BeginCreateObjectFromByteStream( 
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EndCreateObjectFromByteStream( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CancelObjectCreation( 
            /* [in] */ IUnknown *pIUnknownCancelCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSourceResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFSourceResolver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFSourceResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFSourceResolver * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateObjectFromURL )( 
            IMFSourceResolver * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateObjectFromByteStream )( 
            IMFSourceResolver * This,
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginCreateObjectFromURL )( 
            IMFSourceResolver * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndCreateObjectFromURL )( 
            IMFSourceResolver * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginCreateObjectFromByteStream )( 
            IMFSourceResolver * This,
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndCreateObjectFromByteStream )( 
            IMFSourceResolver * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CancelObjectCreation )( 
            IMFSourceResolver * This,
            /* [in] */ IUnknown *pIUnknownCancelCookie);
        
        END_INTERFACE
    } IMFSourceResolverVtbl;

    interface IMFSourceResolver
    {
        CONST_VTBL struct IMFSourceResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSourceResolver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSourceResolver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSourceResolver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSourceResolver_CreateObjectFromURL(This,pwszURL,dwFlags,pProps,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> CreateObjectFromURL(This,pwszURL,dwFlags,pProps,pObjectType,ppObject) ) 

#define IMFSourceResolver_CreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> CreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,pObjectType,ppObject) ) 

#define IMFSourceResolver_BeginCreateObjectFromURL(This,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginCreateObjectFromURL(This,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState) ) 

#define IMFSourceResolver_EndCreateObjectFromURL(This,pResult,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> EndCreateObjectFromURL(This,pResult,pObjectType,ppObject) ) 

#define IMFSourceResolver_BeginCreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginCreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState) ) 

#define IMFSourceResolver_EndCreateObjectFromByteStream(This,pResult,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> EndCreateObjectFromByteStream(This,pResult,pObjectType,ppObject) ) 

#define IMFSourceResolver_CancelObjectCreation(This,pIUnknownCancelCookie)	\
    ( (This)->lpVtbl -> CancelObjectCreation(This,pIUnknownCancelCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteBeginCreateObjectFromURL_Proxy( 
    IMFSourceResolver * This,
    /* [string][in] */ LPCWSTR pwszURL,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IMFRemoteAsyncCallback *pCallback);


void __RPC_STUB IMFSourceResolver_RemoteBeginCreateObjectFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteEndCreateObjectFromURL_Proxy( 
    IMFSourceResolver * This,
    /* [in] */ IUnknown *pResult,
    /* [out] */ MF_OBJECT_TYPE *pObjectType,
    /* [out] */ IUnknown **ppObject);


void __RPC_STUB IMFSourceResolver_RemoteEndCreateObjectFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteBeginCreateObjectFromByteStream_Proxy( 
    IMFSourceResolver * This,
    /* [in] */ IMFByteStream *pByteStream,
    /* [in] */ LPCWSTR pwszURL,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IMFRemoteAsyncCallback *pCallback);


void __RPC_STUB IMFSourceResolver_RemoteBeginCreateObjectFromByteStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteEndCreateObjectFromByteStream_Proxy( 
    IMFSourceResolver * This,
    /* [in] */ IUnknown *pResult,
    /* [out] */ MF_OBJECT_TYPE *pObjectType,
    /* [out] */ IUnknown **ppObject);


void __RPC_STUB IMFSourceResolver_RemoteEndCreateObjectFromByteStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFSourceResolver_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0002 */
/* [local] */ 

STDAPI MFCreateSourceResolver( 
        /* out */     __out IMFSourceResolver     **ppISourceResolver);
STDAPI CreatePropertyStore( 
        /* out */     __out IPropertyStore        **ppStore);
STDAPI MFGetSupportedSchemes(                      
       __out PROPVARIANT* pPropVarSchemeArray  );  
STDAPI MFGetSupportedMimeTypes(                      
       __out PROPVARIANT* pPropVarMimeTypeArray  );  
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_SourceOpenMonitor = { { 0x074d4637, 0xb5ae, 0x465d, 0xaf, 0x17, 0x1a, 0x53, 0x8d, 0x28, 0x59, 0xdd}, 0x02 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_ApproxSeek = { { 0xb4cd270f, 0x244d, 0x4969, 0xbb, 0x92, 0x3f, 0x0f, 0xb8, 0x31, 0x6f, 0x10}, 0x01 }; 
#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_IterativeSeekIfNoIndex = { { 0x170b65dc, 0x4a4e, 0x407a, 0xac, 0x22, 0x57, 0x7f, 0x50, 0xe4, 0xa3, 0x7c }, 0x01 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_IterativeSeek_Max_Count = { { 0x170b65dc, 0x4a4e, 0x407a, 0xac, 0x22, 0x57, 0x7f, 0x50, 0xe4, 0xa3, 0x7c }, 0x02 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_IterativeSeek_Tolerance_In_MilliSecond = { { 0x170b65dc, 0x4a4e, 0x407a, 0xac, 0x22, 0x57, 0x7f, 0x50, 0xe4, 0xa3, 0x7c }, 0x03 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_Content_DLNA_Profile_ID = { { 0xcfa31b45, 0x525d, 0x4998, 0xbb, 0x44, 0x3f, 0x7d, 0x81, 0x54, 0x2f, 0xa4 }, 0x01 }; 
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
typedef 
enum _MFMEDIASOURCE_CHARACTERISTICS
    {	MFMEDIASOURCE_IS_LIVE	= 0x1,
	MFMEDIASOURCE_CAN_SEEK	= 0x2,
	MFMEDIASOURCE_CAN_PAUSE	= 0x4,
	MFMEDIASOURCE_HAS_SLOW_SEEK	= 0x8,
	MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS	= 0x10,
	MFMEDIASOURCE_CAN_SKIPFORWARD	= 0x20,
	MFMEDIASOURCE_CAN_SKIPBACKWARD	= 0x40
    } 	MFMEDIASOURCE_CHARACTERISTICS;

#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID( MF_TIME_FORMAT_ENTRY_RELATIVE, 0x4399f178, 0x46d3, 0x4504, 0xaf, 0xda, 0x20, 0xd3, 0x2e, 0x9b, 0xa3, 0x60 );
#endif // (WINVER >= _WIN32_WINNT_WIN7) 




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0002_v0_0_s_ifspec;

#ifndef __IMFMediaSource_INTERFACE_DEFINED__
#define __IMFMediaSource_INTERFACE_DEFINED__

/* interface IMFMediaSource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("279a808d-aec7-40c8-9c6b-a6b492c78a66")
    IMFMediaSource : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [out] */ DWORD *pdwCharacteristics) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreatePresentationDescriptor( 
            /* [annotation][out] */ 
            __out  IMFPresentationDescriptor **ppPresentationDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ IMFPresentationDescriptor *pPresentationDescriptor,
            /* [unique][in] */ const GUID *pguidTimeFormat,
            /* [unique][in] */ const PROPVARIANT *pvarStartPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMFMediaSource * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaSource * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaSource * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            IMFMediaSource * This,
            /* [in] */ MediaEventType met,
            /* [in] */ REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            IMFMediaSource * This,
            /* [out] */ DWORD *pdwCharacteristics);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreatePresentationDescriptor )( 
            IMFMediaSource * This,
            /* [annotation][out] */ 
            __out  IMFPresentationDescriptor **ppPresentationDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IMFMediaSource * This,
            /* [in] */ IMFPresentationDescriptor *pPresentationDescriptor,
            /* [unique][in] */ const GUID *pguidTimeFormat,
            /* [unique][in] */ const PROPVARIANT *pvarStartPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMFMediaSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMFMediaSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFMediaSource * This);
        
        END_INTERFACE
    } IMFMediaSourceVtbl;

    interface IMFMediaSource
    {
        CONST_VTBL struct IMFMediaSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaSource_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaSource_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaSource_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaSource_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaSource_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#define IMFMediaSource_CreatePresentationDescriptor(This,ppPresentationDescriptor)	\
    ( (This)->lpVtbl -> CreatePresentationDescriptor(This,ppPresentationDescriptor) ) 

#define IMFMediaSource_Start(This,pPresentationDescriptor,pguidTimeFormat,pvarStartPosition)	\
    ( (This)->lpVtbl -> Start(This,pPresentationDescriptor,pguidTimeFormat,pvarStartPosition) ) 

#define IMFMediaSource_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMFMediaSource_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMFMediaSource_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFMediaSource_RemoteCreatePresentationDescriptor_Proxy( 
    IMFMediaSource * This,
    /* [out] */ DWORD *pcbPD,
    /* [size_is][size_is][out] */ BYTE **pbPD,
    /* [out] */ IMFPresentationDescriptor **ppRemotePD);


void __RPC_STUB IMFMediaSource_RemoteCreatePresentationDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFMediaSource_INTERFACE_DEFINED__ */


#ifndef __IMFMediaStream_INTERFACE_DEFINED__
#define __IMFMediaStream_INTERFACE_DEFINED__

/* interface IMFMediaStream */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D182108F-4EC6-443f-AA42-A71106EC825F")
    IMFMediaStream : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaSource( 
            /* [out] */ IMFMediaSource **ppMediaSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamDescriptor( 
            /* [out] */ IMFStreamDescriptor **ppStreamDescriptor) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RequestSample( 
            /* [in] */ IUnknown *pToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMFMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaStream * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaStream * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            IMFMediaStream * This,
            /* [in] */ MediaEventType met,
            /* [in] */ REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaSource )( 
            IMFMediaStream * This,
            /* [out] */ IMFMediaSource **ppMediaSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamDescriptor )( 
            IMFMediaStream * This,
            /* [out] */ IMFStreamDescriptor **ppStreamDescriptor);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RequestSample )( 
            IMFMediaStream * This,
            /* [in] */ IUnknown *pToken);
        
        END_INTERFACE
    } IMFMediaStreamVtbl;

    interface IMFMediaStream
    {
        CONST_VTBL struct IMFMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaStream_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaStream_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaStream_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaStream_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaStream_GetMediaSource(This,ppMediaSource)	\
    ( (This)->lpVtbl -> GetMediaSource(This,ppMediaSource) ) 

#define IMFMediaStream_GetStreamDescriptor(This,ppStreamDescriptor)	\
    ( (This)->lpVtbl -> GetStreamDescriptor(This,ppStreamDescriptor) ) 

#define IMFMediaStream_RequestSample(This,pToken)	\
    ( (This)->lpVtbl -> RequestSample(This,pToken) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFMediaStream_RemoteRequestSample_Proxy( 
    IMFMediaStream * This);


void __RPC_STUB IMFMediaStream_RemoteRequestSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFMediaStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0004 */
/* [local] */ 

#define MEDIASINK_FIXED_STREAMS         0x00000001
#define MEDIASINK_CANNOT_MATCH_CLOCK    0x00000002
#define MEDIASINK_RATELESS              0x00000004
#define MEDIASINK_CLOCK_REQUIRED        0x00000008
#define MEDIASINK_CAN_PREROLL           0x00000010
#if (WINVER >= _WIN32_WINNT_WIN7) 
#define MEDIASINK_IS_FINALIZABLE        0x00000020
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
#define MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE 0x00000020




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0004_v0_0_s_ifspec;

#ifndef __IMFMediaSink_INTERFACE_DEFINED__
#define __IMFMediaSink_INTERFACE_DEFINED__

/* interface IMFMediaSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6ef2a660-47c0-4666-b13d-cbb717f2fa2c")
    IMFMediaSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [out] */ DWORD *pdwCharacteristics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamSink( 
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [in] */ IMFMediaType *pMediaType,
            /* [out] */ IMFStreamSink **ppStreamSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamSink( 
            /* [in] */ DWORD dwStreamSinkIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSinkCount( 
            /* [out] */ DWORD *pcStreamSinkCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSinkByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IMFStreamSink **ppStreamSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSinkById( 
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [out] */ IMFStreamSink **ppStreamSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPresentationClock( 
            /* [in] */ IMFPresentationClock *pPresentationClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPresentationClock( 
            /* [out] */ IMFPresentationClock **ppPresentationClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFMediaSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFMediaSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFMediaSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            IMFMediaSink * This,
            /* [out] */ DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamSink )( 
            IMFMediaSink * This,
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [in] */ IMFMediaType *pMediaType,
            /* [out] */ IMFStreamSink **ppStreamSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamSink )( 
            IMFMediaSink * This,
            /* [in] */ DWORD dwStreamSinkIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSinkCount )( 
            IMFMediaSink * This,
            /* [out] */ DWORD *pcStreamSinkCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSinkByIndex )( 
            IMFMediaSink * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IMFStreamSink **ppStreamSink);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSinkById )( 
            IMFMediaSink * This,
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [out] */ IMFStreamSink **ppStreamSink);
        
        HRESULT ( STDMETHODCALLTYPE *SetPresentationClock )( 
            IMFMediaSink * This,
            /* [in] */ IMFPresentationClock *pPresentationClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetPresentationClock )( 
            IMFMediaSink * This,
            /* [out] */ IMFPresentationClock **ppPresentationClock);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IMFMediaSink * This);
        
        END_INTERFACE
    } IMFMediaSinkVtbl;

    interface IMFMediaSink
    {
        CONST_VTBL struct IMFMediaSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaSink_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#define IMFMediaSink_AddStreamSink(This,dwStreamSinkIdentifier,pMediaType,ppStreamSink)	\
    ( (This)->lpVtbl -> AddStreamSink(This,dwStreamSinkIdentifier,pMediaType,ppStreamSink) ) 

#define IMFMediaSink_RemoveStreamSink(This,dwStreamSinkIdentifier)	\
    ( (This)->lpVtbl -> RemoveStreamSink(This,dwStreamSinkIdentifier) ) 

#define IMFMediaSink_GetStreamSinkCount(This,pcStreamSinkCount)	\
    ( (This)->lpVtbl -> GetStreamSinkCount(This,pcStreamSinkCount) ) 

#define IMFMediaSink_GetStreamSinkByIndex(This,dwIndex,ppStreamSink)	\
    ( (This)->lpVtbl -> GetStreamSinkByIndex(This,dwIndex,ppStreamSink) ) 

#define IMFMediaSink_GetStreamSinkById(This,dwStreamSinkIdentifier,ppStreamSink)	\
    ( (This)->lpVtbl -> GetStreamSinkById(This,dwStreamSinkIdentifier,ppStreamSink) ) 

#define IMFMediaSink_SetPresentationClock(This,pPresentationClock)	\
    ( (This)->lpVtbl -> SetPresentationClock(This,pPresentationClock) ) 

#define IMFMediaSink_GetPresentationClock(This,ppPresentationClock)	\
    ( (This)->lpVtbl -> GetPresentationClock(This,ppPresentationClock) ) 

#define IMFMediaSink_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0005 */
/* [local] */ 

typedef 
enum _MFSTREAMSINK_MARKER_TYPE
    {	MFSTREAMSINK_MARKER_DEFAULT	= 0,
	MFSTREAMSINK_MARKER_ENDOFSEGMENT	= ( MFSTREAMSINK_MARKER_DEFAULT + 1 ) ,
	MFSTREAMSINK_MARKER_TICK	= ( MFSTREAMSINK_MARKER_ENDOFSEGMENT + 1 ) ,
	MFSTREAMSINK_MARKER_EVENT	= ( MFSTREAMSINK_MARKER_TICK + 1 ) 
    } 	MFSTREAMSINK_MARKER_TYPE;




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0005_v0_0_s_ifspec;

#ifndef __IMFStreamSink_INTERFACE_DEFINED__
#define __IMFStreamSink_INTERFACE_DEFINED__

/* interface IMFStreamSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFStreamSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A97B3CF-8E7C-4a3d-8F8C-0C843DC247FB")
    IMFStreamSink : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaSink( 
            /* [out] */ IMFMediaSink **ppMediaSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentifier( 
            /* [out] */ DWORD *pdwIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTypeHandler( 
            /* [out] */ IMFMediaTypeHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessSample( 
            /* [in] */ IMFSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaceMarker( 
            /* [in] */ MFSTREAMSINK_MARKER_TYPE eMarkerType,
            /* [in] */ const PROPVARIANT *pvarMarkerValue,
            /* [in] */ const PROPVARIANT *pvarContextValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStreamSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStreamSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStreamSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStreamSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            IMFStreamSink * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFStreamSink * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFStreamSink * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            IMFStreamSink * This,
            /* [in] */ MediaEventType met,
            /* [in] */ REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaSink )( 
            IMFStreamSink * This,
            /* [out] */ IMFMediaSink **ppMediaSink);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentifier )( 
            IMFStreamSink * This,
            /* [out] */ DWORD *pdwIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTypeHandler )( 
            IMFStreamSink * This,
            /* [out] */ IMFMediaTypeHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSample )( 
            IMFStreamSink * This,
            /* [in] */ IMFSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *PlaceMarker )( 
            IMFStreamSink * This,
            /* [in] */ MFSTREAMSINK_MARKER_TYPE eMarkerType,
            /* [in] */ const PROPVARIANT *pvarMarkerValue,
            /* [in] */ const PROPVARIANT *pvarContextValue);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMFStreamSink * This);
        
        END_INTERFACE
    } IMFStreamSinkVtbl;

    interface IMFStreamSink
    {
        CONST_VTBL struct IMFStreamSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStreamSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStreamSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStreamSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStreamSink_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFStreamSink_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFStreamSink_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFStreamSink_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFStreamSink_GetMediaSink(This,ppMediaSink)	\
    ( (This)->lpVtbl -> GetMediaSink(This,ppMediaSink) ) 

#define IMFStreamSink_GetIdentifier(This,pdwIdentifier)	\
    ( (This)->lpVtbl -> GetIdentifier(This,pdwIdentifier) ) 

#define IMFStreamSink_GetMediaTypeHandler(This,ppHandler)	\
    ( (This)->lpVtbl -> GetMediaTypeHandler(This,ppHandler) ) 

#define IMFStreamSink_ProcessSample(This,pSample)	\
    ( (This)->lpVtbl -> ProcessSample(This,pSample) ) 

#define IMFStreamSink_PlaceMarker(This,eMarkerType,pvarMarkerValue,pvarContextValue)	\
    ( (This)->lpVtbl -> PlaceMarker(This,eMarkerType,pvarMarkerValue,pvarContextValue) ) 

#define IMFStreamSink_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStreamSink_INTERFACE_DEFINED__ */


#ifndef __IMFVideoSampleAllocator_INTERFACE_DEFINED__
#define __IMFVideoSampleAllocator_INTERFACE_DEFINED__

/* interface IMFVideoSampleAllocator */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFVideoSampleAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86cbc910-e533-4751-8e3b-f19b5b806a03")
    IMFVideoSampleAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDirectXManager( 
            /* [unique][in] */ IUnknown *pManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninitializeSampleAllocator( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeSampleAllocator( 
            /* [in] */ DWORD cRequestedFrames,
            /* [in] */ IMFMediaType *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [out] */ IMFSample **ppSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFVideoSampleAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFVideoSampleAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFVideoSampleAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFVideoSampleAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectXManager )( 
            IMFVideoSampleAllocator * This,
            /* [unique][in] */ IUnknown *pManager);
        
        HRESULT ( STDMETHODCALLTYPE *UninitializeSampleAllocator )( 
            IMFVideoSampleAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeSampleAllocator )( 
            IMFVideoSampleAllocator * This,
            /* [in] */ DWORD cRequestedFrames,
            /* [in] */ IMFMediaType *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IMFVideoSampleAllocator * This,
            /* [out] */ IMFSample **ppSample);
        
        END_INTERFACE
    } IMFVideoSampleAllocatorVtbl;

    interface IMFVideoSampleAllocator
    {
        CONST_VTBL struct IMFVideoSampleAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFVideoSampleAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFVideoSampleAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFVideoSampleAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFVideoSampleAllocator_SetDirectXManager(This,pManager)	\
    ( (This)->lpVtbl -> SetDirectXManager(This,pManager) ) 

#define IMFVideoSampleAllocator_UninitializeSampleAllocator(This)	\
    ( (This)->lpVtbl -> UninitializeSampleAllocator(This) ) 

#define IMFVideoSampleAllocator_InitializeSampleAllocator(This,cRequestedFrames,pMediaType)	\
    ( (This)->lpVtbl -> InitializeSampleAllocator(This,cRequestedFrames,pMediaType) ) 

#define IMFVideoSampleAllocator_AllocateSample(This,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,ppSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFVideoSampleAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0007 */
/* [local] */ 

#if (WINVER >= _WIN32_WINNT_WIN7) 


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0007_v0_0_s_ifspec;

#ifndef __IMFVideoSampleAllocatorNotify_INTERFACE_DEFINED__
#define __IMFVideoSampleAllocatorNotify_INTERFACE_DEFINED__

/* interface IMFVideoSampleAllocatorNotify */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFVideoSampleAllocatorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A792CDBE-C374-4e89-8335-278E7B9956A4")
    IMFVideoSampleAllocatorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyRelease( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFVideoSampleAllocatorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFVideoSampleAllocatorNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFVideoSampleAllocatorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFVideoSampleAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyRelease )( 
            IMFVideoSampleAllocatorNotify * This);
        
        END_INTERFACE
    } IMFVideoSampleAllocatorNotifyVtbl;

    interface IMFVideoSampleAllocatorNotify
    {
        CONST_VTBL struct IMFVideoSampleAllocatorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFVideoSampleAllocatorNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFVideoSampleAllocatorNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFVideoSampleAllocatorNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFVideoSampleAllocatorNotify_NotifyRelease(This)	\
    ( (This)->lpVtbl -> NotifyRelease(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFVideoSampleAllocatorNotify_INTERFACE_DEFINED__ */


#ifndef __IMFVideoSampleAllocatorCallback_INTERFACE_DEFINED__
#define __IMFVideoSampleAllocatorCallback_INTERFACE_DEFINED__

/* interface IMFVideoSampleAllocatorCallback */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFVideoSampleAllocatorCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("992388B4-3372-4f67-8B6F-C84C071F4751")
    IMFVideoSampleAllocatorCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            /* [unique][in] */ IMFVideoSampleAllocatorNotify *pNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFreeSampleCount( 
            /* [out] */ LONG *plSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFVideoSampleAllocatorCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFVideoSampleAllocatorCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFVideoSampleAllocatorCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFVideoSampleAllocatorCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IMFVideoSampleAllocatorCallback * This,
            /* [unique][in] */ IMFVideoSampleAllocatorNotify *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE *GetFreeSampleCount )( 
            IMFVideoSampleAllocatorCallback * This,
            /* [out] */ LONG *plSamples);
        
        END_INTERFACE
    } IMFVideoSampleAllocatorCallbackVtbl;

    interface IMFVideoSampleAllocatorCallback
    {
        CONST_VTBL struct IMFVideoSampleAllocatorCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFVideoSampleAllocatorCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFVideoSampleAllocatorCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFVideoSampleAllocatorCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFVideoSampleAllocatorCallback_SetCallback(This,pNotify)	\
    ( (This)->lpVtbl -> SetCallback(This,pNotify) ) 

#define IMFVideoSampleAllocatorCallback_GetFreeSampleCount(This,plSamples)	\
    ( (This)->lpVtbl -> GetFreeSampleCount(This,plSamples) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFVideoSampleAllocatorCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0009 */
/* [local] */ 

#endif // (WINVER >= _WIN32_WINNT_WIN7) 



extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0009_v0_0_s_ifspec;

#ifndef __IMFTopology_INTERFACE_DEFINED__
#define __IMFTopology_INTERFACE_DEFINED__

/* interface IMFTopology */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFTopology;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83CF873A-F6DA-4bc8-823F-BACFD55DC433")
    IMFTopology : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTopologyID( 
            /* [out] */ TOPOID *pID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddNode( 
            /* [in] */ IMFTopologyNode *pNode) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RemoveNode( 
            /* [in] */ IMFTopologyNode *pNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeCount( 
            /* [out] */ WORD *pwNodes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNode( 
            /* [in] */ WORD wIndex,
            /* [out] */ IMFTopologyNode **ppNode) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneFrom( 
            /* [in] */ IMFTopology *pTopology) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeByID( 
            /* [in] */ TOPOID qwTopoNodeID,
            /* [out] */ IMFTopologyNode **ppNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceNodeCollection( 
            /* [out] */ IMFCollection **ppCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputNodeCollection( 
            /* [out] */ IMFCollection **ppCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFTopologyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFTopology * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFTopology * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFTopology * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFTopology * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFTopology * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFTopology * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFTopology * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFTopology * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFTopology * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFTopology * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFTopology * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFTopology * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFTopology * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFTopology * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFTopology * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFTopology * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFTopology * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFTopology * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFTopology * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetTopologyID )( 
            IMFTopology * This,
            /* [out] */ TOPOID *pID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *AddNode )( 
            IMFTopology * This,
            /* [in] */ IMFTopologyNode *pNode);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RemoveNode )( 
            IMFTopology * This,
            /* [in] */ IMFTopologyNode *pNode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeCount )( 
            IMFTopology * This,
            /* [out] */ WORD *pwNodes);
        
        HRESULT ( STDMETHODCALLTYPE *GetNode )( 
            IMFTopology * This,
            /* [in] */ WORD wIndex,
            /* [out] */ IMFTopologyNode **ppNode);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IMFTopology * This);
        
        HRESULT ( STDMETHODCALLTYPE *CloneFrom )( 
            IMFTopology * This,
            /* [in] */ IMFTopology *pTopology);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeByID )( 
            IMFTopology * This,
            /* [in] */ TOPOID qwTopoNodeID,
            /* [out] */ IMFTopologyNode **ppNode);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceNodeCollection )( 
            IMFTopology * This,
            /* [out] */ IMFCollection **ppCollection);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputNodeCollection )( 
            IMFTopology * This,
            /* [out] */ IMFCollection **ppCollection);
        
        END_INTERFACE
    } IMFTopologyVtbl;

    interface IMFTopology
    {
        CONST_VTBL struct IMFTopologyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFTopology_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFTopology_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFTopology_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFTopology_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFTopology_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFTopology_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFTopology_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFTopology_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFTopology_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFTopology_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFTopology_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFTopology_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFTopology_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFTopology_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFTopology_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFTopology_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFTopology_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFTopology_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFTopology_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFTopology_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFTopology_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFTopology_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFTopology_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFTopology_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFTopology_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFTopology_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFTopology_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFTopology_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFTopology_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFTopology_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFTopology_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFTopology_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFTopology_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFTopology_GetTopologyID(This,pID)	\
    ( (This)->lpVtbl -> GetTopologyID(This,pID) ) 

#define IMFTopology_AddNode(This,pNode)	\
    ( (This)->lpVtbl -> AddNode(This,pNode) ) 

#define IMFTopology_RemoveNode(This,pNode)	\
    ( (This)->lpVtbl -> RemoveNode(This,pNode) ) 

#define IMFTopology_GetNodeCount(This,pwNodes)	\
    ( (This)->lpVtbl -> GetNodeCount(This,pwNodes) ) 

#define IMFTopology_GetNode(This,wIndex,ppNode)	\
    ( (This)->lpVtbl -> GetNode(This,wIndex,ppNode) ) 

#define IMFTopology_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IMFTopology_CloneFrom(This,pTopology)	\
    ( (This)->lpVtbl -> CloneFrom(This,pTopology) ) 

#define IMFTopology_GetNodeByID(This,qwTopoNodeID,ppNode)	\
    ( (This)->lpVtbl -> GetNodeByID(This,qwTopoNodeID,ppNode) ) 

#define IMFTopology_GetSourceNodeCollection(This,ppCollection)	\
    ( (This)->lpVtbl -> GetSourceNodeCollection(This,ppCollection) ) 

#define IMFTopology_GetOutputNodeCollection(This,ppCollection)	\
    ( (This)->lpVtbl -> GetOutputNodeCollection(This,ppCollection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFTopology_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0010 */
/* [local] */ 

EXTERN_GUID( MF_TOPOLOGY_PROJECTSTART, 0x7ed3f802, 0x86bb, 0x4b3f, 0xb7, 0xe4, 0x7c, 0xb4, 0x3a, 0xfd, 0x4b, 0x80);
EXTERN_GUID( MF_TOPOLOGY_PROJECTSTOP, 0x7ed3f803, 0x86bb, 0x4b3f, 0xb7, 0xe4, 0x7c, 0xb4, 0x3a, 0xfd, 0x4b, 0x80);
EXTERN_GUID( MF_TOPOLOGY_NO_MARKIN_MARKOUT, 0x7ed3f804, 0x86bb, 0x4b3f, 0xb7, 0xe4, 0x7c, 0xb4, 0x3a, 0xfd, 0x4b, 0x80);
#if (WINVER >= _WIN32_WINNT_WIN7) 
typedef 
enum MFTOPOLOGY_DXVA_MODE
    {	MFTOPOLOGY_DXVA_DEFAULT	= 0,
	MFTOPOLOGY_DXVA_NONE	= 1,
	MFTOPOLOGY_DXVA_FULL	= 2
    } 	MFTOPOLOGY_DXVA_MODE;

EXTERN_GUID(MF_TOPOLOGY_DXVA_MODE, 0x1e8d34f6, 0xf5ab, 0x4e23, 0xbb, 0x88, 0x87, 0x4a, 0xa3, 0xa1, 0xa7, 0x4d);
EXTERN_GUID(MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS, 0xb86cac42, 0x41a6, 0x4b79, 0x89, 0x7a, 0x1a, 0xb0, 0xe5, 0x2b, 0x4a, 0x1b);
EXTERN_GUID(MF_TOPOLOGY_PLAYBACK_MAX_DIMS,  0x5715cf19, 0x5768, 0x44aa, 0xad, 0x6e, 0x87, 0x21, 0xf1, 0xb0, 0xf9, 0xbb);
typedef 
enum MFTOPOLOGY_HARDWARE_MODE
    {	MFTOPOLOGY_HWMODE_SOFTWARE_ONLY	= 0,
	MFTOPOLOGY_HWMODE_USE_HARDWARE	= 1,
	MFTOPOLOGY_HWMODE_HARDWARE_ONLY	= 2
    } 	MFTOPOLOGY_HARDWARE_MODE;

EXTERN_GUID(MF_TOPOLOGY_HARDWARE_MODE, 0xd2d362fd, 0x4e4f, 0x4191, 0xa5, 0x79, 0xc6, 0x18, 0xb6, 0x67, 0x6, 0xaf);
EXTERN_GUID(MF_TOPOLOGY_PLAYBACK_FRAMERATE, 0xc164737a, 0xc2b1, 0x4553, 0x83, 0xbb, 0x5a, 0x52, 0x60, 0x72, 0x44, 0x8f);
EXTERN_GUID(MF_TOPOLOGY_DYNAMIC_CHANGE_ALLOWED, 0x811f5ed7, 0xebe9, 0x4bf1, 0x82, 0xce, 0x4, 0xe4, 0xcc, 0x37, 0xe4, 0x2a);
EXTERN_GUID(MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES, 0x6248c36d, 0x5d0b, 0x4f40, 0xa0, 0xbb, 0xb0, 0xb3, 0x05, 0xf7, 0x76, 0x98);
EXTERN_GUID( MF_TOPOLOGY_START_TIME_ON_PRESENTATION_SWITCH, 0xc8cc113f, 0x7951, 0x4548, 0xaa, 0xd6, 0x9e, 0xd6, 0x20, 0x2e, 0x62, 0xb3);
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
STDAPI MFCreateTopology(
    __out IMFTopology ** ppTopo );
typedef 
enum MF_TOPOLOGY_TYPE
    {	MF_TOPOLOGY_OUTPUT_NODE	= 0,
	MF_TOPOLOGY_SOURCESTREAM_NODE	= ( MF_TOPOLOGY_OUTPUT_NODE + 1 ) ,
	MF_TOPOLOGY_TRANSFORM_NODE	= ( MF_TOPOLOGY_SOURCESTREAM_NODE + 1 ) ,
	MF_TOPOLOGY_TEE_NODE	= ( MF_TOPOLOGY_TRANSFORM_NODE + 1 ) ,
	MF_TOPOLOGY_MAX	= 0xffffffff
    } 	MF_TOPOLOGY_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0010_v0_0_s_ifspec;

#ifndef __IMFTopologyNode_INTERFACE_DEFINED__
#define __IMFTopologyNode_INTERFACE_DEFINED__

/* interface IMFTopologyNode */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFTopologyNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83CF873A-F6DA-4bc8-823F-BACFD55DC430")
    IMFTopologyNode : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObject( 
            /* [in] */ IUnknown *pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ IUnknown **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeType( 
            /* [out] */ MF_TOPOLOGY_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTopoNodeID( 
            /* [out] */ TOPOID *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTopoNodeID( 
            /* [in] */ TOPOID ullTopoID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD *pcOutputs) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE ConnectOutput( 
            /* [in] */ DWORD dwOutputIndex,
            /* [in] */ IMFTopologyNode *pDownstreamNode,
            /* [in] */ DWORD dwInputIndexOnDownstreamNode) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DisconnectOutput( 
            /* [in] */ DWORD dwOutputIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInput( 
            /* [in] */ DWORD dwInputIndex,
            /* [out] */ IMFTopologyNode **ppUpstreamNode,
            /* [out] */ DWORD *pdwOutputIndexOnUpstreamNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutput( 
            /* [in] */ DWORD dwOutputIndex,
            /* [out] */ IMFTopologyNode **ppDownstreamNode,
            /* [out] */ DWORD *pdwInputIndexOnDownstreamNode) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetOutputPrefType( 
            /* [in] */ DWORD dwOutputIndex,
            /* [in] */ IMFMediaType *pType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetOutputPrefType( 
            /* [in] */ DWORD dwOutputIndex,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetInputPrefType( 
            /* [in] */ DWORD dwInputIndex,
            /* [in] */ IMFMediaType *pType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetInputPrefType( 
            /* [in] */ DWORD dwInputIndex,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneFrom( 
            /* [in] */ IMFTopologyNode *pNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFTopologyNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFTopologyNode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFTopologyNode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFTopologyNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFTopologyNode * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFTopologyNode * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFTopologyNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFTopologyNode * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFTopologyNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFTopologyNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFTopologyNode * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFTopologyNode * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFTopologyNode * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *SetObject )( 
            IMFTopologyNode * This,
            /* [in] */ IUnknown *pObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IMFTopologyNode * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeType )( 
            IMFTopologyNode * This,
            /* [out] */ MF_TOPOLOGY_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetTopoNodeID )( 
            IMFTopologyNode * This,
            /* [out] */ TOPOID *pID);
        
        HRESULT ( STDMETHODCALLTYPE *SetTopoNodeID )( 
            IMFTopologyNode * This,
            /* [in] */ TOPOID ullTopoID);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputCount )( 
            IMFTopologyNode * This,
            /* [out] */ DWORD *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCount )( 
            IMFTopologyNode * This,
            /* [out] */ DWORD *pcOutputs);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *ConnectOutput )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwOutputIndex,
            /* [in] */ IMFTopologyNode *pDownstreamNode,
            /* [in] */ DWORD dwInputIndexOnDownstreamNode);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DisconnectOutput )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwOutputIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetInput )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwInputIndex,
            /* [out] */ IMFTopologyNode **ppUpstreamNode,
            /* [out] */ DWORD *pdwOutputIndexOnUpstreamNode);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutput )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwOutputIndex,
            /* [out] */ IMFTopologyNode **ppDownstreamNode,
            /* [out] */ DWORD *pdwInputIndexOnDownstreamNode);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetOutputPrefType )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwOutputIndex,
            /* [in] */ IMFMediaType *pType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetOutputPrefType )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwOutputIndex,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetInputPrefType )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwInputIndex,
            /* [in] */ IMFMediaType *pType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetInputPrefType )( 
            IMFTopologyNode * This,
            /* [in] */ DWORD dwInputIndex,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppType);
        
        HRESULT ( STDMETHODCALLTYPE *CloneFrom )( 
            IMFTopologyNode * This,
            /* [in] */ IMFTopologyNode *pNode);
        
        END_INTERFACE
    } IMFTopologyNodeVtbl;

    interface IMFTopologyNode
    {
        CONST_VTBL struct IMFTopologyNodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFTopologyNode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFTopologyNode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFTopologyNode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFTopologyNode_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFTopologyNode_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFTopologyNode_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFTopologyNode_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFTopologyNode_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFTopologyNode_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFTopologyNode_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFTopologyNode_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFTopologyNode_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFTopologyNode_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFTopologyNode_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFTopologyNode_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFTopologyNode_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFTopologyNode_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFTopologyNode_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFTopologyNode_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFTopologyNode_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFTopologyNode_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFTopologyNode_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFTopologyNode_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFTopologyNode_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFTopologyNode_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFTopologyNode_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFTopologyNode_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFTopologyNode_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFTopologyNode_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFTopologyNode_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFTopologyNode_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFTopologyNode_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFTopologyNode_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFTopologyNode_SetObject(This,pObject)	\
    ( (This)->lpVtbl -> SetObject(This,pObject) ) 

#define IMFTopologyNode_GetObject(This,ppObject)	\
    ( (This)->lpVtbl -> GetObject(This,ppObject) ) 

#define IMFTopologyNode_GetNodeType(This,pType)	\
    ( (This)->lpVtbl -> GetNodeType(This,pType) ) 

#define IMFTopologyNode_GetTopoNodeID(This,pID)	\
    ( (This)->lpVtbl -> GetTopoNodeID(This,pID) ) 

#define IMFTopologyNode_SetTopoNodeID(This,ullTopoID)	\
    ( (This)->lpVtbl -> SetTopoNodeID(This,ullTopoID) ) 

#define IMFTopologyNode_GetInputCount(This,pcInputs)	\
    ( (This)->lpVtbl -> GetInputCount(This,pcInputs) ) 

#define IMFTopologyNode_GetOutputCount(This,pcOutputs)	\
    ( (This)->lpVtbl -> GetOutputCount(This,pcOutputs) ) 

#define IMFTopologyNode_ConnectOutput(This,dwOutputIndex,pDownstreamNode,dwInputIndexOnDownstreamNode)	\
    ( (This)->lpVtbl -> ConnectOutput(This,dwOutputIndex,pDownstreamNode,dwInputIndexOnDownstreamNode) ) 

#define IMFTopologyNode_DisconnectOutput(This,dwOutputIndex)	\
    ( (This)->lpVtbl -> DisconnectOutput(This,dwOutputIndex) ) 

#define IMFTopologyNode_GetInput(This,dwInputIndex,ppUpstreamNode,pdwOutputIndexOnUpstreamNode)	\
    ( (This)->lpVtbl -> GetInput(This,dwInputIndex,ppUpstreamNode,pdwOutputIndexOnUpstreamNode) ) 

#define IMFTopologyNode_GetOutput(This,dwOutputIndex,ppDownstreamNode,pdwInputIndexOnDownstreamNode)	\
    ( (This)->lpVtbl -> GetOutput(This,dwOutputIndex,ppDownstreamNode,pdwInputIndexOnDownstreamNode) ) 

#define IMFTopologyNode_SetOutputPrefType(This,dwOutputIndex,pType)	\
    ( (This)->lpVtbl -> SetOutputPrefType(This,dwOutputIndex,pType) ) 

#define IMFTopologyNode_GetOutputPrefType(This,dwOutputIndex,ppType)	\
    ( (This)->lpVtbl -> GetOutputPrefType(This,dwOutputIndex,ppType) ) 

#define IMFTopologyNode_SetInputPrefType(This,dwInputIndex,pType)	\
    ( (This)->lpVtbl -> SetInputPrefType(This,dwInputIndex,pType) ) 

#define IMFTopologyNode_GetInputPrefType(This,dwInputIndex,ppType)	\
    ( (This)->lpVtbl -> GetInputPrefType(This,dwInputIndex,ppType) ) 

#define IMFTopologyNode_CloneFrom(This,pNode)	\
    ( (This)->lpVtbl -> CloneFrom(This,pNode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFTopologyNode_RemoteGetOutputPrefType_Proxy( 
    IMFTopologyNode * This,
    /* [in] */ DWORD dwOutputIndex,
    /* [out] */ DWORD *pcbData,
    /* [size_is][size_is][out] */ BYTE **ppbData);


void __RPC_STUB IMFTopologyNode_RemoteGetOutputPrefType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFTopologyNode_RemoteGetInputPrefType_Proxy( 
    IMFTopologyNode * This,
    /* [in] */ DWORD dwInputIndex,
    /* [out] */ DWORD *pcbData,
    /* [size_is][size_is][out] */ BYTE **ppbData);


void __RPC_STUB IMFTopologyNode_RemoteGetInputPrefType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFTopologyNode_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0011 */
/* [local] */ 

typedef 
enum _MF_TOPONODE_FLUSH_MODE
    {	MF_TOPONODE_FLUSH_ALWAYS	= 0,
	MF_TOPONODE_FLUSH_SEEK	= ( MF_TOPONODE_FLUSH_ALWAYS + 1 ) ,
	MF_TOPONODE_FLUSH_NEVER	= ( MF_TOPONODE_FLUSH_SEEK + 1 ) 
    } 	MF_TOPONODE_FLUSH_MODE;

EXTERN_GUID( MF_TOPONODE_FLUSH, 0x494bbce8, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
typedef 
enum _MF_TOPONODE_DRAIN_MODE
    {	MF_TOPONODE_DRAIN_DEFAULT	= 0,
	MF_TOPONODE_DRAIN_ALWAYS	= ( MF_TOPONODE_DRAIN_DEFAULT + 1 ) ,
	MF_TOPONODE_DRAIN_NEVER	= ( MF_TOPONODE_DRAIN_ALWAYS + 1 ) 
    } 	MF_TOPONODE_DRAIN_MODE;

EXTERN_GUID( MF_TOPONODE_DRAIN, 0x494bbce9, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_D3DAWARE, 0x494bbced, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPOLOGY_RESOLUTION_STATUS, 0x494bbcde, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_ERRORCODE, 0x494bbcee, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_CONNECT_METHOD, 0x494bbcf1, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_LOCKED, 0x494bbcf7, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_WORKQUEUE_ID, 0x494bbcf8, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_WORKQUEUE_MMCSS_CLASS, 0x494bbcf9, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_DECRYPTOR, 0x494bbcfa, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_DISCARDABLE, 0x494bbcfb, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_ERROR_MAJORTYPE, 0x494bbcfd, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_ERROR_SUBTYPE, 0x494bbcfe, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_WORKQUEUE_MMCSS_TASKID, 0x494bbcff, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_MARKIN_HERE, 0x494bbd00, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_MARKOUT_HERE, 0x494bbd01, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_DECODER, 0x494bbd02, 0xb031,  0x4e38,  0x97, 0xc4, 0xd5, 0x42, 0x2d, 0xd6, 0x18, 0xdc);
EXTERN_GUID( MF_TOPONODE_MEDIASTART, 0x835c58ea, 0xe075, 0x4bc7, 0xbc, 0xba, 0x4d, 0xe0, 0x00, 0xdf, 0x9a, 0xe6);
EXTERN_GUID( MF_TOPONODE_MEDIASTOP, 0x835c58eb, 0xe075, 0x4bc7, 0xbc, 0xba, 0x4d, 0xe0, 0x00, 0xdf, 0x9a, 0xe6);
EXTERN_GUID( MF_TOPONODE_SOURCE, 0x835c58ec, 0xe075, 0x4bc7, 0xbc, 0xba, 0x4d, 0xe0, 0x00, 0xdf, 0x9a, 0xe6);
EXTERN_GUID( MF_TOPONODE_PRESENTATION_DESCRIPTOR, 0x835c58ed, 0xe075, 0x4bc7, 0xbc, 0xba, 0x4d, 0xe0, 0x00, 0xdf, 0x9a, 0xe6);
EXTERN_GUID( MF_TOPONODE_STREAM_DESCRIPTOR, 0x835c58ee, 0xe075, 0x4bc7, 0xbc, 0xba, 0x4d, 0xe0, 0x00, 0xdf, 0x9a, 0xe6);
EXTERN_GUID( MF_TOPONODE_SEQUENCE_ELEMENTID, 0x835c58ef, 0xe075, 0x4bc7, 0xbc, 0xba, 0x4d, 0xe0, 0x00, 0xdf, 0x9a, 0xe6);
EXTERN_GUID( MF_TOPONODE_TRANSFORM_OBJECTID, 0x88dcc0c9, 0x293e, 0x4e8b, 0x9a, 0xeb, 0xa, 0xd6, 0x4c, 0xc0, 0x16, 0xb0);
EXTERN_GUID( MF_TOPONODE_STREAMID, 0x14932f9b, 0x9087, 0x4bb4, 0x84, 0x12, 0x51, 0x67, 0x14, 0x5c, 0xbe, 0x04);
EXTERN_GUID( MF_TOPONODE_NOSHUTDOWN_ON_REMOVE, 0x14932f9c, 0x9087, 0x4bb4, 0x84, 0x12, 0x51, 0x67, 0x14, 0x5c, 0xbe, 0x04);
EXTERN_GUID( MF_TOPONODE_RATELESS, 0x14932f9d, 0x9087, 0x4bb4, 0x84, 0x12, 0x51, 0x67, 0x14, 0x5c, 0xbe, 0x04);
EXTERN_GUID( MF_TOPONODE_DISABLE_PREROLL, 0x14932f9e, 0x9087, 0x4bb4, 0x84, 0x12, 0x51, 0x67, 0x14, 0x5c, 0xbe, 0x04);
EXTERN_GUID( MF_TOPONODE_PRIMARYOUTPUT, 0x6304ef99, 0x16b2, 0x4ebe, 0x9d, 0x67, 0xe4, 0xc5, 0x39, 0xb3, 0xa2, 0x59);
STDAPI MFCreateTopologyNode(
    MF_TOPOLOGY_TYPE NodeType,
    __out IMFTopologyNode ** ppNode );
#if (WINVER >= _WIN32_WINNT_WIN7) 
STDAPI MFGetTopoNodeCurrentType(
    IMFTopologyNode* pNode,
    DWORD dwStreamIndex,
    BOOL fOutput,
    __deref_out IMFMediaType** ppType);
#endif // (WINVER >= _WIN32_WINNT_WIN7) 


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0011_v0_0_s_ifspec;

#ifndef __IMFGetService_INTERFACE_DEFINED__
#define __IMFGetService_INTERFACE_DEFINED__

/* interface IMFGetService */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFGetService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa993888-4383-415a-a930-dd472a8cf6f7")
    IMFGetService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFGetServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFGetService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFGetService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFGetService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            IMFGetService * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *ppvObject);
        
        END_INTERFACE
    } IMFGetServiceVtbl;

    interface IMFGetService
    {
        CONST_VTBL struct IMFGetServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFGetService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFGetService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFGetService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFGetService_GetService(This,guidService,riid,ppvObject)	\
    ( (This)->lpVtbl -> GetService(This,guidService,riid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFGetService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0012 */
/* [local] */ 

STDAPI MFGetService(
    IUnknown* punkObject,
    REFGUID guidService,
    REFIID riid,
    __out LPVOID* ppvObject
    );
typedef LONGLONG MFTIME;

typedef 
enum _MFCLOCK_CHARACTERISTICS_FLAGS
    {	MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ	= 0x2,
	MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING	= 0x4,
	MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK	= 0x8
    } 	MFCLOCK_CHARACTERISTICS_FLAGS;

typedef 
enum _MFCLOCK_STATE
    {	MFCLOCK_STATE_INVALID	= 0,
	MFCLOCK_STATE_RUNNING	= ( MFCLOCK_STATE_INVALID + 1 ) ,
	MFCLOCK_STATE_STOPPED	= ( MFCLOCK_STATE_RUNNING + 1 ) ,
	MFCLOCK_STATE_PAUSED	= ( MFCLOCK_STATE_STOPPED + 1 ) 
    } 	MFCLOCK_STATE;

typedef 
enum _MFCLOCK_RELATIONAL_FLAGS
    {	MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD	= 0x1
    } 	MFCLOCK_RELATIONAL_FLAGS;

typedef struct _MFCLOCK_PROPERTIES
    {
    unsigned __int64 qwCorrelationRate;
    GUID guidClockId;
    DWORD dwClockFlags;
    unsigned __int64 qwClockFrequency;
    DWORD dwClockTolerance;
    DWORD dwClockJitter;
    } 	MFCLOCK_PROPERTIES;

#define MFCLOCK_FREQUENCY_HNS       10000000
#define MFCLOCK_TOLERANCE_UNKNOWN   50000
#define MFCLOCK_JITTER_ISR          1000
#define MFCLOCK_JITTER_DPC          4000
#define MFCLOCK_JITTER_PASSIVE      10000


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0012_v0_0_s_ifspec;

#ifndef __IMFClock_INTERFACE_DEFINED__
#define __IMFClock_INTERFACE_DEFINED__

/* interface IMFClock */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2eb1e945-18b8-4139-9b1a-d5d584818530")
    IMFClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClockCharacteristics( 
            /* [out] */ DWORD *pdwCharacteristics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCorrelatedTime( 
            /* [in] */ DWORD dwReserved,
            /* [out] */ LONGLONG *pllClockTime,
            /* [out] */ MFTIME *phnsSystemTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContinuityKey( 
            /* [out] */ DWORD *pdwContinuityKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ DWORD dwReserved,
            /* [out] */ MFCLOCK_STATE *peClockState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ MFCLOCK_PROPERTIES *pClockProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockCharacteristics )( 
            IMFClock * This,
            /* [out] */ DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelatedTime )( 
            IMFClock * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LONGLONG *pllClockTime,
            /* [out] */ MFTIME *phnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetContinuityKey )( 
            IMFClock * This,
            /* [out] */ DWORD *pdwContinuityKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMFClock * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ MFCLOCK_STATE *peClockState);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMFClock * This,
            /* [out] */ MFCLOCK_PROPERTIES *pClockProperties);
        
        END_INTERFACE
    } IMFClockVtbl;

    interface IMFClock
    {
        CONST_VTBL struct IMFClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFClock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFClock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFClock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFClock_GetClockCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetClockCharacteristics(This,pdwCharacteristics) ) 

#define IMFClock_GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime)	\
    ( (This)->lpVtbl -> GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime) ) 

#define IMFClock_GetContinuityKey(This,pdwContinuityKey)	\
    ( (This)->lpVtbl -> GetContinuityKey(This,pdwContinuityKey) ) 

#define IMFClock_GetState(This,dwReserved,peClockState)	\
    ( (This)->lpVtbl -> GetState(This,dwReserved,peClockState) ) 

#define IMFClock_GetProperties(This,pClockProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pClockProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFClock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0013 */
/* [local] */ 

STDAPI_(MFTIME) 
MFGetSystemTime(
    );
#define PRESENTATION_CURRENT_POSITION   0x7fffffffffffffff




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0013_v0_0_s_ifspec;

#ifndef __IMFPresentationClock_INTERFACE_DEFINED__
#define __IMFPresentationClock_INTERFACE_DEFINED__

/* interface IMFPresentationClock */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFPresentationClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("868CE85C-8EA9-4f55-AB82-B009A910A805")
    IMFPresentationClock : public IMFClock
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTimeSource( 
            /* [in] */ IMFPresentationTimeSource *pTimeSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeSource( 
            /* [out] */ IMFPresentationTimeSource **ppTimeSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ MFTIME *phnsClockTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddClockStateSink( 
            /* [in] */ IMFClockStateSink *pStateSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveClockStateSink( 
            /* [in] */ IMFClockStateSink *pStateSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LONGLONG llClockStartOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPresentationClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPresentationClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPresentationClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPresentationClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockCharacteristics )( 
            IMFPresentationClock * This,
            /* [out] */ DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelatedTime )( 
            IMFPresentationClock * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LONGLONG *pllClockTime,
            /* [out] */ MFTIME *phnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetContinuityKey )( 
            IMFPresentationClock * This,
            /* [out] */ DWORD *pdwContinuityKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMFPresentationClock * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ MFCLOCK_STATE *peClockState);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMFPresentationClock * This,
            /* [out] */ MFCLOCK_PROPERTIES *pClockProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeSource )( 
            IMFPresentationClock * This,
            /* [in] */ IMFPresentationTimeSource *pTimeSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeSource )( 
            IMFPresentationClock * This,
            /* [out] */ IMFPresentationTimeSource **ppTimeSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IMFPresentationClock * This,
            /* [out] */ MFTIME *phnsClockTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddClockStateSink )( 
            IMFPresentationClock * This,
            /* [in] */ IMFClockStateSink *pStateSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveClockStateSink )( 
            IMFPresentationClock * This,
            /* [in] */ IMFClockStateSink *pStateSink);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IMFPresentationClock * This,
            /* [in] */ LONGLONG llClockStartOffset);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMFPresentationClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMFPresentationClock * This);
        
        END_INTERFACE
    } IMFPresentationClockVtbl;

    interface IMFPresentationClock
    {
        CONST_VTBL struct IMFPresentationClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPresentationClock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPresentationClock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPresentationClock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPresentationClock_GetClockCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetClockCharacteristics(This,pdwCharacteristics) ) 

#define IMFPresentationClock_GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime)	\
    ( (This)->lpVtbl -> GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime) ) 

#define IMFPresentationClock_GetContinuityKey(This,pdwContinuityKey)	\
    ( (This)->lpVtbl -> GetContinuityKey(This,pdwContinuityKey) ) 

#define IMFPresentationClock_GetState(This,dwReserved,peClockState)	\
    ( (This)->lpVtbl -> GetState(This,dwReserved,peClockState) ) 

#define IMFPresentationClock_GetProperties(This,pClockProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pClockProperties) ) 


#define IMFPresentationClock_SetTimeSource(This,pTimeSource)	\
    ( (This)->lpVtbl -> SetTimeSource(This,pTimeSource) ) 

#define IMFPresentationClock_GetTimeSource(This,ppTimeSource)	\
    ( (This)->lpVtbl -> GetTimeSource(This,ppTimeSource) ) 

#define IMFPresentationClock_GetTime(This,phnsClockTime)	\
    ( (This)->lpVtbl -> GetTime(This,phnsClockTime) ) 

#define IMFPresentationClock_AddClockStateSink(This,pStateSink)	\
    ( (This)->lpVtbl -> AddClockStateSink(This,pStateSink) ) 

#define IMFPresentationClock_RemoveClockStateSink(This,pStateSink)	\
    ( (This)->lpVtbl -> RemoveClockStateSink(This,pStateSink) ) 

#define IMFPresentationClock_Start(This,llClockStartOffset)	\
    ( (This)->lpVtbl -> Start(This,llClockStartOffset) ) 

#define IMFPresentationClock_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMFPresentationClock_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPresentationClock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0014 */
/* [local] */ 

STDAPI MFCreatePresentationClock(
    __out IMFPresentationClock** ppPresentationClock
    );


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0014_v0_0_s_ifspec;

#ifndef __IMFPresentationTimeSource_INTERFACE_DEFINED__
#define __IMFPresentationTimeSource_INTERFACE_DEFINED__

/* interface IMFPresentationTimeSource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFPresentationTimeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FF12CCE-F76F-41c2-863B-1666C8E5E139")
    IMFPresentationTimeSource : public IMFClock
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUnderlyingClock( 
            /* [out] */ IMFClock **ppClock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPresentationTimeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPresentationTimeSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPresentationTimeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPresentationTimeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClockCharacteristics )( 
            IMFPresentationTimeSource * This,
            /* [out] */ DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelatedTime )( 
            IMFPresentationTimeSource * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ LONGLONG *pllClockTime,
            /* [out] */ MFTIME *phnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetContinuityKey )( 
            IMFPresentationTimeSource * This,
            /* [out] */ DWORD *pdwContinuityKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMFPresentationTimeSource * This,
            /* [in] */ DWORD dwReserved,
            /* [out] */ MFCLOCK_STATE *peClockState);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IMFPresentationTimeSource * This,
            /* [out] */ MFCLOCK_PROPERTIES *pClockProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnderlyingClock )( 
            IMFPresentationTimeSource * This,
            /* [out] */ IMFClock **ppClock);
        
        END_INTERFACE
    } IMFPresentationTimeSourceVtbl;

    interface IMFPresentationTimeSource
    {
        CONST_VTBL struct IMFPresentationTimeSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPresentationTimeSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPresentationTimeSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPresentationTimeSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPresentationTimeSource_GetClockCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetClockCharacteristics(This,pdwCharacteristics) ) 

#define IMFPresentationTimeSource_GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime)	\
    ( (This)->lpVtbl -> GetCorrelatedTime(This,dwReserved,pllClockTime,phnsSystemTime) ) 

#define IMFPresentationTimeSource_GetContinuityKey(This,pdwContinuityKey)	\
    ( (This)->lpVtbl -> GetContinuityKey(This,pdwContinuityKey) ) 

#define IMFPresentationTimeSource_GetState(This,dwReserved,peClockState)	\
    ( (This)->lpVtbl -> GetState(This,dwReserved,peClockState) ) 

#define IMFPresentationTimeSource_GetProperties(This,pClockProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pClockProperties) ) 


#define IMFPresentationTimeSource_GetUnderlyingClock(This,ppClock)	\
    ( (This)->lpVtbl -> GetUnderlyingClock(This,ppClock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPresentationTimeSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0015 */
/* [local] */ 

STDAPI
MFCreateSystemTimeSource(
    __out IMFPresentationTimeSource** ppSystemTimeSource
    );


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0015_v0_0_s_ifspec;

#ifndef __IMFClockStateSink_INTERFACE_DEFINED__
#define __IMFClockStateSink_INTERFACE_DEFINED__

/* interface IMFClockStateSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFClockStateSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F6696E82-74F7-4f3d-A178-8A5E09C3659F")
    IMFClockStateSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClockStart( 
            /* [in] */ MFTIME hnsSystemTime,
            /* [in] */ LONGLONG llClockStartOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClockStop( 
            /* [in] */ MFTIME hnsSystemTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClockPause( 
            /* [in] */ MFTIME hnsSystemTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClockRestart( 
            /* [in] */ MFTIME hnsSystemTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClockSetRate( 
            /* [in] */ MFTIME hnsSystemTime,
            /* [in] */ float flRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFClockStateSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFClockStateSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFClockStateSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFClockStateSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnClockStart )( 
            IMFClockStateSink * This,
            /* [in] */ MFTIME hnsSystemTime,
            /* [in] */ LONGLONG llClockStartOffset);
        
        HRESULT ( STDMETHODCALLTYPE *OnClockStop )( 
            IMFClockStateSink * This,
            /* [in] */ MFTIME hnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *OnClockPause )( 
            IMFClockStateSink * This,
            /* [in] */ MFTIME hnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *OnClockRestart )( 
            IMFClockStateSink * This,
            /* [in] */ MFTIME hnsSystemTime);
        
        HRESULT ( STDMETHODCALLTYPE *OnClockSetRate )( 
            IMFClockStateSink * This,
            /* [in] */ MFTIME hnsSystemTime,
            /* [in] */ float flRate);
        
        END_INTERFACE
    } IMFClockStateSinkVtbl;

    interface IMFClockStateSink
    {
        CONST_VTBL struct IMFClockStateSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFClockStateSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFClockStateSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFClockStateSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFClockStateSink_OnClockStart(This,hnsSystemTime,llClockStartOffset)	\
    ( (This)->lpVtbl -> OnClockStart(This,hnsSystemTime,llClockStartOffset) ) 

#define IMFClockStateSink_OnClockStop(This,hnsSystemTime)	\
    ( (This)->lpVtbl -> OnClockStop(This,hnsSystemTime) ) 

#define IMFClockStateSink_OnClockPause(This,hnsSystemTime)	\
    ( (This)->lpVtbl -> OnClockPause(This,hnsSystemTime) ) 

#define IMFClockStateSink_OnClockRestart(This,hnsSystemTime)	\
    ( (This)->lpVtbl -> OnClockRestart(This,hnsSystemTime) ) 

#define IMFClockStateSink_OnClockSetRate(This,hnsSystemTime,flRate)	\
    ( (This)->lpVtbl -> OnClockSetRate(This,hnsSystemTime,flRate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFClockStateSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0016 */
/* [local] */ 

EXTERN_GUID( MF_PD_PMPHOST_CONTEXT, 0x6c990d31, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_APP_CONTEXT, 0x6c990d32, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_DURATION, 0x6c990d33, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_TOTAL_FILE_SIZE, 0x6c990d34, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_AUDIO_ENCODING_BITRATE, 0x6c990d35, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_VIDEO_ENCODING_BITRATE, 0x6c990d36, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_MIME_TYPE, 0x6c990d37, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID(MF_PD_LAST_MODIFIED_TIME, 0x6c990d38, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID(MF_PD_PLAYBACK_ELEMENT_ID, 0x6c990d39, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_PREFERRED_LANGUAGE, 0x6c990d3A, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID(MF_PD_PLAYBACK_BOUNDARY_TIME, 0x6c990d3b, 0xbb8e, 0x477a, 0x85, 0x98, 0xd, 0x5d, 0x96, 0xfc, 0xd8, 0x8a );
EXTERN_GUID( MF_PD_AUDIO_ISVARIABLEBITRATE, 0x33026ee0, 0xe387, 0x4582, 0xae, 0x0a, 0x34, 0xa2, 0xad, 0x3b, 0xaa, 0x18 );
#endif // (WINVER >= _WIN32_WINNT_WIN7) 


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0016_v0_0_s_ifspec;

#ifndef __IMFPresentationDescriptor_INTERFACE_DEFINED__
#define __IMFPresentationDescriptor_INTERFACE_DEFINED__

/* interface IMFPresentationDescriptor */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFPresentationDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03cb2711-24d7-4db6-a17f-f3a7a479a536")
    IMFPresentationDescriptor : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamDescriptorCount( 
            /* [out] */ DWORD *pdwDescriptorCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ BOOL *pfSelected,
            /* [out] */ IMFStreamDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectStream( 
            /* [in] */ DWORD dwDescriptorIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeselectStream( 
            /* [in] */ DWORD dwDescriptorIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFPresentationDescriptor **ppPresentationDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFPresentationDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFPresentationDescriptor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFPresentationDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFPresentationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFPresentationDescriptor * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFPresentationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFPresentationDescriptor * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFPresentationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFPresentationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFPresentationDescriptor * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFPresentationDescriptor * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFPresentationDescriptor * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamDescriptorCount )( 
            IMFPresentationDescriptor * This,
            /* [out] */ DWORD *pdwDescriptorCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamDescriptorByIndex )( 
            IMFPresentationDescriptor * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ BOOL *pfSelected,
            /* [out] */ IMFStreamDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *SelectStream )( 
            IMFPresentationDescriptor * This,
            /* [in] */ DWORD dwDescriptorIndex);
        
        HRESULT ( STDMETHODCALLTYPE *DeselectStream )( 
            IMFPresentationDescriptor * This,
            /* [in] */ DWORD dwDescriptorIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFPresentationDescriptor * This,
            /* [out] */ IMFPresentationDescriptor **ppPresentationDescriptor);
        
        END_INTERFACE
    } IMFPresentationDescriptorVtbl;

    interface IMFPresentationDescriptor
    {
        CONST_VTBL struct IMFPresentationDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFPresentationDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFPresentationDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFPresentationDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFPresentationDescriptor_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFPresentationDescriptor_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFPresentationDescriptor_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFPresentationDescriptor_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFPresentationDescriptor_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFPresentationDescriptor_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFPresentationDescriptor_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFPresentationDescriptor_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFPresentationDescriptor_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFPresentationDescriptor_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFPresentationDescriptor_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFPresentationDescriptor_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFPresentationDescriptor_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFPresentationDescriptor_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFPresentationDescriptor_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFPresentationDescriptor_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFPresentationDescriptor_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFPresentationDescriptor_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFPresentationDescriptor_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFPresentationDescriptor_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFPresentationDescriptor_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFPresentationDescriptor_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFPresentationDescriptor_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFPresentationDescriptor_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFPresentationDescriptor_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFPresentationDescriptor_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFPresentationDescriptor_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFPresentationDescriptor_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFPresentationDescriptor_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFPresentationDescriptor_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFPresentationDescriptor_GetStreamDescriptorCount(This,pdwDescriptorCount)	\
    ( (This)->lpVtbl -> GetStreamDescriptorCount(This,pdwDescriptorCount) ) 

#define IMFPresentationDescriptor_GetStreamDescriptorByIndex(This,dwIndex,pfSelected,ppDescriptor)	\
    ( (This)->lpVtbl -> GetStreamDescriptorByIndex(This,dwIndex,pfSelected,ppDescriptor) ) 

#define IMFPresentationDescriptor_SelectStream(This,dwDescriptorIndex)	\
    ( (This)->lpVtbl -> SelectStream(This,dwDescriptorIndex) ) 

#define IMFPresentationDescriptor_DeselectStream(This,dwDescriptorIndex)	\
    ( (This)->lpVtbl -> DeselectStream(This,dwDescriptorIndex) ) 

#define IMFPresentationDescriptor_Clone(This,ppPresentationDescriptor)	\
    ( (This)->lpVtbl -> Clone(This,ppPresentationDescriptor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFPresentationDescriptor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0017 */
/* [local] */ 

STDAPI MFCreatePresentationDescriptor(
    DWORD cStreamDescriptors,
    __in_ecount_opt( cStreamDescriptors ) IMFStreamDescriptor** apStreamDescriptors,
    __deref_out IMFPresentationDescriptor** ppPresentationDescriptor
    );

STDAPI MFRequireProtectedEnvironment(
     __in IMFPresentationDescriptor* pPresentationDescriptor
     );

STDAPI MFSerializePresentationDescriptor(
    __in IMFPresentationDescriptor * pPD,
    __out DWORD * pcbData,
    __deref_out_bcount_full(*pcbData) BYTE ** ppbData);

STDAPI MFDeserializePresentationDescriptor(
    __in DWORD cbData,
    __in_ecount( cbData ) BYTE * pbData,
    __deref_out IMFPresentationDescriptor ** ppPD);

EXTERN_GUID(MF_SD_LANGUAGE, 0xaf2180, 0xbdc2, 0x423c, 0xab, 0xca, 0xf5, 0x3, 0x59, 0x3b, 0xc1, 0x21);
EXTERN_GUID(MF_SD_PROTECTED, 0xaf2181, 0xbdc2, 0x423c, 0xab, 0xca, 0xf5, 0x3, 0x59, 0x3b, 0xc1, 0x21);


extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0017_v0_0_s_ifspec;

#ifndef __IMFStreamDescriptor_INTERFACE_DEFINED__
#define __IMFStreamDescriptor_INTERFACE_DEFINED__

/* interface IMFStreamDescriptor */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFStreamDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56c03d9c-9dbb-45f5-ab4b-d80f47c05938")
    IMFStreamDescriptor : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamIdentifier( 
            /* [out] */ DWORD *pdwStreamIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTypeHandler( 
            /* [out] */ IMFMediaTypeHandler **ppMediaTypeHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStreamDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFStreamDescriptor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFStreamDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFStreamDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFStreamDescriptor * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFStreamDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFStreamDescriptor * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFStreamDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFStreamDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFStreamDescriptor * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFStreamDescriptor * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFStreamDescriptor * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamIdentifier )( 
            IMFStreamDescriptor * This,
            /* [out] */ DWORD *pdwStreamIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTypeHandler )( 
            IMFStreamDescriptor * This,
            /* [out] */ IMFMediaTypeHandler **ppMediaTypeHandler);
        
        END_INTERFACE
    } IMFStreamDescriptorVtbl;

    interface IMFStreamDescriptor
    {
        CONST_VTBL struct IMFStreamDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStreamDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStreamDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStreamDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStreamDescriptor_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFStreamDescriptor_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFStreamDescriptor_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFStreamDescriptor_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFStreamDescriptor_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFStreamDescriptor_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFStreamDescriptor_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFStreamDescriptor_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFStreamDescriptor_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFStreamDescriptor_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFStreamDescriptor_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFStreamDescriptor_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFStreamDescriptor_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFStreamDescriptor_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFStreamDescriptor_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFStreamDescriptor_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFStreamDescriptor_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFStreamDescriptor_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFStreamDescriptor_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFStreamDescriptor_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFStreamDescriptor_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFStreamDescriptor_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFStreamDescriptor_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFStreamDescriptor_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFStreamDescriptor_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFStreamDescriptor_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFStreamDescriptor_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFStreamDescriptor_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFStreamDescriptor_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFStreamDescriptor_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFStreamDescriptor_GetStreamIdentifier(This,pdwStreamIdentifier)	\
    ( (This)->lpVtbl -> GetStreamIdentifier(This,pdwStreamIdentifier) ) 

#define IMFStreamDescriptor_GetMediaTypeHandler(This,ppMediaTypeHandler)	\
    ( (This)->lpVtbl -> GetMediaTypeHandler(This,ppMediaTypeHandler) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStreamDescriptor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0018 */
/* [local] */ 

STDAPI MFCreateStreamDescriptor(
    DWORD dwStreamIdentifier,
    DWORD cMediaTypes,
    __in_ecount(cMediaTypes) IMFMediaType** apMediaTypes,
    __out IMFStreamDescriptor** ppDescriptor
    );



extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0018_v0_0_s_ifspec;

#ifndef __IMFMediaTypeHandler_INTERFACE_DEFINED__
#define __IMFMediaTypeHandler_INTERFACE_DEFINED__

/* interface IMFMediaTypeHandler */
/* [uuid][object] */ 






EXTERN_C const IID IID_IMFMediaTypeHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e93dcf6c-4b07-4e1e-8123-aa16ed6eadf5")
    IMFMediaTypeHandler : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsMediaTypeSupported( 
            /* [in] */ IMFMediaType *pMediaType,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppMediaType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetMediaTypeCount( 
            /* [annotation][out] */ 
            __out  DWORD *pdwTypeCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetMediaTypeByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [annotation][out] */ 
            __out  IMFMediaType **ppType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetCurrentMediaType( 
            /* [in] */ IMFMediaType *pMediaType) = 0;
        
        virtual /* [local] */ HRESULT STDMETH