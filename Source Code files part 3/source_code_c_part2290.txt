e requested information.
//
#define BDK_E_MULTIPLE_MATCHES           ((HRESULT)0x800427C4L)


//
// MessageId: BDK_E_BAD_PUID
//
// MessageText:
//
//  PUID entered was invalid.
//
#define BDK_E_BAD_PUID                   ((HRESULT)0x800427CEL)


//
// MessageId: BDK_E_BAD_OBJECT_ID_LENGTH
//
// MessageText:
//
//  ObjectId length must be 16.
//
#define BDK_E_BAD_OBJECT_ID_LENGTH       ((HRESULT)0x800427D9L)


//
// MessageId: BDK_E_END_PERIOD_LESS_THAN_START_PERIOD
//
// MessageText:
//
//  Start period can never be greater than End period.
//
#define BDK_E_END_PERIOD_LESS_THAN_START_PERIOD ((HRESULT)0x800427DAL)


//
// MessageId: BDK_E_BAD_BILLING_PERIOD_LENGTH
//
// MessageText:
//
//  Billing period length must be 6.
//
#define BDK_E_BAD_BILLING_PERIOD_LENGTH  ((HRESULT)0x800427DBL)


//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET
//
// MessageText:
//
//  Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET   ((HRESULT)0x800427DCL)


//
// MessageId: BDK_E_INVALID_USAGE_EVENT_DATE
//
// MessageText:
//
//  The usage event date specified was invalid.  One possible reason is that it is too far in the future.
//
#define BDK_E_INVALID_USAGE_EVENT_DATE   ((HRESULT)0x800427DFL)


//
// MessageId: BDK_E_NULL_DEFAULT_BILLING_PERIOD
//
// MessageText:
//
//  The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.
//
#define BDK_E_NULL_DEFAULT_BILLING_PERIOD ((HRESULT)0x800427E0L)


//
// MessageId: BDK_E_BAD_START_BILLING_PERIOD
//
// MessageText:
//
//  The start billing period is less than the currently available billing period.
//
#define BDK_E_BAD_START_BILLING_PERIOD   ((HRESULT)0x800427E1L)


//
// MessageId: BDK_E_BAD_END_BILLING_PERIOD
//
// MessageText:
//
//  The end billing period is less than the currently available billing period.
//
#define BDK_E_BAD_END_BILLING_PERIOD     ((HRESULT)0x800427E2L)


//
// MessageId: BDK_E_NEW_DUE_DATE_IS_PAST
//
// MessageText:
//
//  The new due date is in the past
//
#define BDK_E_NEW_DUE_DATE_IS_PAST       ((HRESULT)0x800427E7L)


//
// MessageId: BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED
//
// MessageText:
//
//  The new due date is more than MAXIMUM DELAY days in the future than the original due date
//
#define BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED ((HRESULT)0x800427ECL)


//
// MessageId: BDK_E_NO_NEW_DUE_DATE_SPECIFIED
//
// MessageText:
//
//  If the applydeclineEffect is off, we need a new due date specified
//
#define BDK_E_NO_NEW_DUE_DATE_SPECIFIED  ((HRESULT)0x800427F1L)


//
// MessageId: BDK_E_INVALID_TRANSACTION_TYPE
//
// MessageText:
//
//  Invalid transaction type
//
#define BDK_E_INVALID_TRANSACTION_TYPE   ((HRESULT)0x800427F6L)


//
// MessageId: BDK_E_INVALID_REASON_CODE
//
// MessageText:
//
//  Invalid reason code
//
#define BDK_E_INVALID_REASON_CODE        ((HRESULT)0x800427FBL)


//
// MessageId: BDK_E_GROUP_SID_INITIALIZATION_FAILED
//
// MessageText:
//
//  Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.
//
#define BDK_E_GROUP_SID_INITIALIZATION_FAILED ((HRESULT)0x8004280BL)


//
// MessageId: BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI
//
// MessageText:
//
//  This operation is not valid for wholesale payment instruments.
//
#define BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI ((HRESULT)0x8004280CL)


//
// MessageId: BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT
//
// MessageText:
//
//  This operation is not valid for direct debit payment instrument.
//
#define BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT ((HRESULT)0x8004280DL)


//
// MessageId: BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT
//
// MessageText:
//
//  Adjustment amount exceeds the resource credit limit.
//
#define BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT ((HRESULT)0x8004280EL)


//
// MessageId: BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS
//
// MessageText:
//
//  Adjusting a resource balance is not allowed for subscriptions that are not active.
//
#define BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS ((HRESULT)0x8004280FL)


//
// MessageId: BDK_E_FAILED_TO_CREATE_MAIL_RECORD
//
// MessageText:
//
//  Failed to create mail record for account: %1.
//
#define BDK_E_FAILED_TO_CREATE_MAIL_RECORD ((HRESULT)0x80042810L)


//
// MessageId: BDK_E_MSNIA_LATE_USAGE
//
// MessageText:
//
//  This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.
//
#define BDK_E_MSNIA_LATE_USAGE           ((HRESULT)0x80042811L)


//
// MessageId: BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB
//
// MessageText:
//
//  Failed to write asynchronous immediate settlement failure into the audit db for account: %1.
//
#define BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB ((HRESULT)0x80042812L)


//
// MessageId: BDK_E_INVALID_REFERRAL_OFFER
//
// MessageText:
//
//  This offering is not configured as a referral offer.
//
#define BDK_E_INVALID_REFERRAL_OFFER     ((HRESULT)0x8004ABCCL)


//
// MessageId: BDK_E_REWARD_REFERRAL_XML_REQUIRED
//
// MessageText:
//
//  Reward referral XML is required as this is a referral based offer.
//
#define BDK_E_REWARD_REFERRAL_XML_REQUIRED ((HRESULT)0x80042813L)


//
// MessageId: BDK_E_REFERRER_NOT_IN_SYSTEM
//
// MessageText:
//
//  Referral PUID not found.
//
#define BDK_E_REFERRER_NOT_IN_SYSTEM     ((HRESULT)0x80042814L)


//
// MessageId: BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER
//
// MessageText:
//
//  Referrer has exceeded the max number of referrals configured on the offer.
//
#define BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER ((HRESULT)0x80042815L)


//
// MessageId: BDK_E_REFERRER_NOT_ACTIVE
//
// MessageText:
//
//  The referrer does not have an Active or Locked account in the system.
//
#define BDK_E_REFERRER_NOT_ACTIVE        ((HRESULT)0x80042816L)


//
// MessageId: BDK_E_CANNOT_REFER_SELF
//
// MessageText:
//
//  The referrer cannot refer self for the offer.
//
#define BDK_E_CANNOT_REFER_SELF          ((HRESULT)0x80042817L)


//
// MessageId: BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL
//
// MessageText:
//
//  The referral xml has reward referral info but the offer is not configured for reward referrals.
//
#define BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL ((HRESULT)0x80042818L)


//
// MessageId: BDK_E_INVALID_REWARD_REFFERAL_SCHEMA
//
// MessageText:
//
//  The reward referral schema in the referral xml is invalid.
//
#define BDK_E_INVALID_REWARD_REFFERAL_SCHEMA ((HRESULT)0x80042819L)


//
// MessageId: BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER
//
// MessageText:
//
//  The referrer does not have any eligible offers configured for the reward.
//
#define BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER ((HRESULT)0x8004281AL)


//
// MessageId: BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS
//
// MessageText:
//
//  Invalid mandate status for SettleBalance.
//
#define BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS ((HRESULT)0x8004281BL)


//
// MessageId: BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED
//
// MessageText:
//
//  More than one usage event reported to ReportSingleUsageEvent API
//
#define BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED ((HRESULT)0x8004281CL)


//
// MessageId: BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM
//
// MessageText:
//
//  The reported usage is below the threshold in immediate settle usage.
//
#define BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM ((HRESULT)0x8004281DL)


//
// MessageId: BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE
//
// MessageText:
//
//  ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.
//
#define BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE ((HRESULT)0x8004281EL)


//
// MessageId: BDK_E_REPORT_USAGE_WITH_PREPAID
//
// MessageText:
//
//  ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.
//
#define BDK_E_REPORT_USAGE_WITH_PREPAID  ((HRESULT)0x8004281FL)


//
// MessageId: BDK_E_NO_USAGE_EVENT_REPORTED
//
// MessageText:
//
//  ReportSingleUsage cannot be used with empty event set.
//
#define BDK_E_NO_USAGE_EVENT_REPORTED    ((HRESULT)0x80042820L)


//
// MessageId: BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT
//
// MessageText:
//
//  The payment instrument type does not support immediate settlements
//
#define BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT ((HRESULT)0x80042821L)


//
// MessageId: BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH
//
// MessageText:
//
//  The reported resource and unit of measure do not match.
//
#define BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH ((HRESULT)0x80042822L)


//
// MessageId: BDK_E_INVALID_REDIRECT_INPUTINFO_XML
//
// MessageText:
//
//  Invalid  data passed in RedirectInputInfoXML node.
//
#define BDK_E_INVALID_REDIRECT_INPUTINFO_XML ((HRESULT)0x80042823L)


//
// MessageId: BDK_E_TRANSACTION_NOT_CANCELLABLE
//
// MessageText:
//
//  Transaction cannot be cancelled.
//
#define BDK_E_TRANSACTION_NOT_CANCELLABLE ((HRESULT)0x80042824L)


//
// MessageId: BDK_E_NO_CDS_FOUND
//
// MessageText:
//
//  No CDs found.
//
#define BDK_E_NO_CDS_FOUND               ((HRESULT)0x80042825L)


//
// MessageId: BDK_E_INVALID_CHARGE_DESCRIPTOR
//
// MessageText:
//
//  Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length
//
#define BDK_E_INVALID_CHARGE_DESCRIPTOR  ((HRESULT)0x80042826L)


//
// MessageId: BDK_E_TAXWARE_FAILURE
//
// MessageText:
//
//  Taxware error. Check the event log and the tracer.
//
#define BDK_E_TAXWARE_FAILURE            ((HRESULT)0x8004EA60L)


//
// MessageId: BDK_E_ADDRESS_VALIDATION_FAILURE
//
// MessageText:
//
//  Address validation error. Check the event log and the tracer.
//
#define BDK_E_ADDRESS_VALIDATION_FAILURE ((HRESULT)0x8004EA61L)


//
// MessageId: BDK_E_ZIP_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid ZIP code.
//
#define BDK_E_ZIP_INVALID                ((HRESULT)0x8004EA6BL)


//
// MessageId: BDK_E_STATE_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code.
//
#define BDK_E_STATE_INVALID              ((HRESULT)0x8004EA6CL)


//
// MessageId: BDK_E_ZIP_CITY_MISSING
//
// MessageText:
//
//  VERAZIP: Missing ZIP code or city name.
//
#define BDK_E_ZIP_CITY_MISSING           ((HRESULT)0x8004EA6DL)


//
// MessageId: BDK_E_STATE_ZIP_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code combination.
//
#define BDK_E_STATE_ZIP_INVALID          ((HRESULT)0x8004EA6EL)


//
// MessageId: BDK_E_STATE_CITY_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/city name combination.
//
#define BDK_E_STATE_CITY_INVALID         ((HRESULT)0x8004EA6FL)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
//
#define BDK_E_STATE_ZIP_CITY_INVALID     ((HRESULT)0x8004EA70L)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID2
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination.
//
#define BDK_E_STATE_ZIP_CITY_INVALID2    ((HRESULT)0x8004EA71L)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID3
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination.
//
#define BDK_E_STATE_ZIP_CITY_INVALID3    ((HRESULT)0x8004EA72L)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID4
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.
//
#define BDK_E_STATE_ZIP_CITY_INVALID4    ((HRESULT)0x8004EA73L)


//
// MessageId: BDK_E_MULTIPLE_COUNTIES_FOUND
//
// MessageText:
//
//  VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.
//
#define BDK_E_MULTIPLE_COUNTIES_FOUND    ((HRESULT)0x8004EA7DL)


//
// MessageId: BDK_E_ZIP_INVALID_FOR_ENTERED_STATE
//
// MessageText:
//
//  VERAZIP: Invalid state code for ZIP code. Changed to correct state code.
//
#define BDK_E_ZIP_INVALID_FOR_ENTERED_STATE ((HRESULT)0x8004EA7EL)


//
// MessageId: BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES
//
// MessageText:
//
//  VERAZIP: ZIP code has multiple city names.
//
#define BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES ((HRESULT)0x8004EA89L)


//
// MessageId: BDK_E_MULTIPLE_CITIES_FOUND
//
// MessageText:
//
//  VERAZIP: City has multiple ZIP codes.
//
#define BDK_E_MULTIPLE_CITIES_FOUND      ((HRESULT)0x8004EA8AL)


//
// MessageId: BDK_E_BAD_CITYNAME_LENGTH
//
// MessageText:
//
//  Incorrect city name length.
//
#define BDK_E_BAD_CITYNAME_LENGTH        ((HRESULT)0x8004EA8BL)


//
// MessageId: BDK_E_BAD_COUNTRYCODE_LENGTH
//
// MessageText:
//
//  Incorrect country code length.
//
#define BDK_E_BAD_COUNTRYCODE_LENGTH     ((HRESULT)0x8004EA8CL)


//
// MessageId: BDK_E_BAD_STATECODE_LENGTH
//
// MessageText:
//
//  Incorrect code length for state or province.
//
#define BDK_E_BAD_STATECODE_LENGTH       ((HRESULT)0x8004EA8DL)


//
// MessageId: BDK_E_BAD_ZIPCODE_LENGTH
//
// MessageText:
//
//  Incorrect zip code length.
//
#define BDK_E_BAD_ZIPCODE_LENGTH         ((HRESULT)0x8004EA8EL)


//
// MessageId: BDK_E_BAD_PRODUCTCODE_LENGTH
//
// MessageText:
//
//  Incorrect product code length.
//
#define BDK_E_BAD_PRODUCTCODE_LENGTH     ((HRESULT)0x8004EA8FL)


//
// MessageId: BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH
//
// MessageText:
//
//  Incorrect business location code length.
//
#define BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH ((HRESULT)0x8004EA90L)


//
// MessageId: BDK_E_BAD_TRANSACTIONDATE_LENGTH
//
// MessageText:
//
//  Incorrect transaction date length.
//
#define BDK_E_BAD_TRANSACTIONDATE_LENGTH ((HRESULT)0x8004EA91L)


//
// MessageId: BDK_E_BAD_VATREGISTRATION_LENGTH
//
// MessageText:
//
//  Incorrect VAT registration length.
//
#define BDK_E_BAD_VATREGISTRATION_LENGTH ((HRESULT)0x8004EA92L)


//
// MessageId: BDK_E_BAD_CURRENCYCODE_LENGTH
//
// MessageText:
//
//  Incorrect currency code length.
//
#define BDK_E_BAD_CURRENCYCODE_LENGTH    ((HRESULT)0x8004EA93L)


//
// MessageId: BDK_E_BAD_WTCODE_LENGTH
//
// MessageText:
//
//  Incorrect WorldTax code length.
//
#define BDK_E_BAD_WTCODE_LENGTH          ((HRESULT)0x8004EA94L)


//
// MessageId: BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP
//
// MessageText:
//
//  Invalid input parameter passed to TaxWare or VeraZip.
//
#define BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP ((HRESULT)0x8004EA95L)


//
// MessageId: BDK_E_INVALID_VATID_FORMAT
//
// MessageText:
//
//  The Vat ID provided is of invalid format.
//
#define BDK_E_INVALID_VATID_FORMAT       ((HRESULT)0x8004EA97L)


//
// MessageId: BDK_E_INVALID_VATID_INVALID
//
// MessageText:
//
//  The Vat ID provided is invalid.
//
#define BDK_E_INVALID_VATID_INVALID      ((HRESULT)0x8004EA98L)


//
// MessageId: BDK_E_UNSUPPORTED_CHAR_EXIST
//
// MessageText:
//
//  Input string contains unsupported characters.
//
#define BDK_E_UNSUPPORTED_CHAR_EXIST     ((HRESULT)0x8004EA9CL)


//
// MessageId: BDK_E_ERROR_COUNTRYCODE_MISMATCH
//
// MessageText:
//
//  Country code in Address does not match with the country code in Account Info.
//
#define BDK_E_ERROR_COUNTRYCODE_MISMATCH ((HRESULT)0x8004EAA1L)


//
// MessageId: BDK_E_ERROR_COUNTRYCODE_REQUIRED
//
// MessageText:
//
//  A Country code is required in Account Info.
//
#define BDK_E_ERROR_COUNTRYCODE_REQUIRED ((HRESULT)0x8004EAA6L)


//
// MessageId: BDK_E_INVALID_TOKEN_SPECIFIED
//
// MessageText:
//
//  Token passed is Invalid.
//
#define BDK_E_INVALID_TOKEN_SPECIFIED    ((HRESULT)0x8004138DL)


//
// MessageId: BDK_E_TOKEN_ALREADY_BLACKLISTED
//
// MessageText:
//
//  The token is already blacklisted.
//
#define BDK_E_TOKEN_ALREADY_BLACKLISTED  ((HRESULT)0x80041392L)


//
// MessageId: BDK_E_TOKEN_ALREADY_UNBLACKLISTED
//
// MessageText:
//
//  The token is already un-blacklisted.
//
#define BDK_E_TOKEN_ALREADY_UNBLACKLISTED ((HRESULT)0x80041393L)


//
// MessageId: BDK_E_TOKEN_BLACKLISTED
//
// MessageText:
//
//  The specified token has been blacklisted.
//
#define BDK_E_TOKEN_BLACKLISTED          ((HRESULT)0x800413BFL)


//
// MessageId: BDK_E_TOKEN_RANGE_BLACKLISTED
//
// MessageText:
//
//  The specified token belongs to a blacklisted token range.
//
#define BDK_E_TOKEN_RANGE_BLACKLISTED    ((HRESULT)0x800413C4L)


//
// MessageId: BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED
//
// MessageText:
//
//  The usage for the specified token has been exceeded.
//
#define BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED ((HRESULT)0x800413C9L)


//
// MessageId: BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL
//
// MessageText:
//
//  Token Expiry date not set as may be duration based token was not activated correctly.
//
#define BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL ((HRESULT)0x800413CEL)


//
// MessageId: BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS
//
// MessageText:
//
//  Failed while consumption to create an entry in token_instance_deal_subscription table.
//
#define BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS ((HRESULT)0x800413CFL)


//
// MessageId: BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT
//
// MessageText:
//
//  Not found non-active token range to be activated.
//
#define BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT ((HRESULT)0x800413D3L)


//
// MessageId: BDK_E_TOKEN_EXPIRED
//
// MessageText:
//
//  The specified token has expired.
//
#define BDK_E_TOKEN_EXPIRED              ((HRESULT)0x800413F1L)


//
// MessageId: BDK_E_TOKEN_NOT_STARTED
//
// MessageText:
//
//  The specified token cannot be used yet.
//
#define BDK_E_TOKEN_NOT_STARTED          ((HRESULT)0x800413F6L)


//
// MessageId: BDK_E_TOKEN_RANGE_NOT_ACTIVE
//
// MessageText:
//
//  The specified token has not been activated yet.
//
#define BDK_E_TOKEN_RANGE_NOT_ACTIVE     ((HRESULT)0x800413FBL)


//
// MessageId: BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE
//
// MessageText:
//
//  The reason code specified is not valid.
//
#define BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE ((HRESULT)0x8004141EL)


//
// MessageId: BDK_E_TRACKING_GUID_NODATA
//
// MessageText:
//
//  The specified action is in progress.
//
#define BDK_E_TRACKING_GUID_NODATA       ((HRESULT)0x8004145AL)


//
// MessageId: BDK_E_DUPLICATE_TOKEN_TRACKING_GUID
//
// MessageText:
//
//  The specified tracking has already been used
//
#define BDK_E_DUPLICATE_TOKEN_TRACKING_GUID ((HRESULT)0x8004145FL)


//
// MessageId: BDK_E_ALREADY_ACTIVATED
//
// MessageText:
//
//  The specified token has already been activated
//
#define BDK_E_ALREADY_ACTIVATED          ((HRESULT)0x8004146EL)


//
// MessageId: BDK_E_INVALID_COMMITTED_STATUS
//
// MessageText:
//
//  Committed status is not valid for this API.
//
#define BDK_E_INVALID_COMMITTED_STATUS   ((HRESULT)0x80041470L)


//
// MessageId: BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION
//
// MessageText:
//
//  The description specified is not valid.
//
#define BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION ((HRESULT)0x80041473L)


//
// MessageId: BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE
//
// MessageText:
//
//  Blacklist Effective date passed was prior to the order creation date.
//
#define BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE ((HRESULT)0x80041478L)


//
// MessageId: BDK_E_TOKEN_CONSUMED
//
// MessageText:
//
//  The Token has been consumed.
//
#define BDK_E_TOKEN_CONSUMED             ((HRESULT)0x8004147DL)


//
// MessageId: BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS
//
// MessageText:
//
//  Part Number specified for the token import is not a valid part number for the associated token class.
//
#define BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS ((HRESULT)0x80041482L)


//
// MessageId: BDK_E_INVALID_EXTERNAL_REFERENCE_ID
//
// MessageText:
//
//  External reference id is too long or invalid.
//
#define BDK_E_INVALID_EXTERNAL_REFERENCE_ID ((HRESULT)0x80041483L)


//
// MessageId: BDK_E_TOKEN_ALREADY_DEACTIVATED
//
// MessageText:
//
//  The token is already deactivated.
//
#define BDK_E_TOKEN_ALREADY_DEACTIVATED  ((HRESULT)0x80041487L)


//
// MessageId: BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH
//
// MessageText:
//
//  Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.
//
#define BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH ((HRESULT)0x80041491L)


//
// MessageId: ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID
//
// MessageText:
//
//  Null parameter was passed for Token Class GUID during token class access verification.
//
#define ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID ((HRESULT)0x80041496L)


//
// MessageId: BDK_E_INVALID_BOOKMARK
//
// MessageText:
//
//  The argument specified is not a valid bookmark.
//
#define BDK_E_INVALID_BOOKMARK           ((HRESULT)0x80041484L)


//
// MessageId: BDK_E_INVALID_MAX
//
// MessageText:
//
//  The max argument must be between 1 and 50.
//
#define BDK_E_INVALID_MAX                ((HRESULT)0x80041485L)


//
// MessageId: BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD
//
// MessageText:
//
//  Unable to retrieve event ID and billing impact for event.
//
#define BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD ((HRESULT)0x8004CD14L)


//
// MessageId: BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT
//
// MessageText:
//
//  Unable to find line item matching event.
//
#define BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT ((HRESULT)0x8004CD46L)


//
// MessageId: BDK_E_CANCELREFUND_OFFSET_OF_OFFSET
//
// MessageText:
//
//  Cannot process if there is an offset of an offset.
//
#define BDK_E_CANCELREFUND_OFFSET_OF_OFFSET ((HRESULT)0x8004CD78L)


//
// MessageId: BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE
//
// MessageText:
//
//  This can't happen, both line item and related line item in the active list.
//
#define BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE ((HRESULT)0x8004CDAAL)


//
// MessageId: BDK_E_INVALID_SESSION_KEY
//
// MessageText:
//
//  The session key passed in does not pass validation checks.
//
#define BDK_E_INVALID_SESSION_KEY        ((HRESULT)0x8004768EL)


//
// MessageId: BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID
//
// MessageText:
//
//  This object ID is not entitled to get a deliverable token.
//
#define BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID ((HRESULT)0x8004A0B4L)


//
// MessageId: BDK_E_PRODUCT_KEY_NOT_AVAILABLE
//
// MessageText:
//
//  The token cannot be issued, either because the database is unavailable or there are no more unused tokens.
//
#define BDK_E_PRODUCT_KEY_NOT_AVAILABLE  ((HRESULT)0x80041488L)


//
// MessageId: BDK_E_PIN_OR_SEQ_REQUIRED
//
// MessageText:
//
//  Either PIN or Sequence number is required as input parameter to validate Token.
//
#define BDK_E_PIN_OR_SEQ_REQUIRED        ((HRESULT)0x80041489L)


//
// MessageId: BDK_E_INPUT_PARAM_MALFORMED
//
// MessageText:
//
//  Either Token Class Guid or Signature or Part Number should be specified for validating Token.
//
#define BDK_E_INPUT_PARAM_MALFORMED      ((HRESULT)0x8004148AL)


//
// MessageId: BDK_E_INVALID_ADJUSTMENT_OFFSET
//
// MessageText:
//
//  The offset must be between -1 and 365 inclusive.
//
#define BDK_E_INVALID_ADJUSTMENT_OFFSET  ((HRESULT)0x8004CDB7L)


//
// MessageId: BDK_E_INVALID_ITEM_INSTANCE_ID
//
// MessageText:
//
//  Invalid item instance ID.
//
#define BDK_E_INVALID_ITEM_INSTANCE_ID   ((HRESULT)0x8004CDDCL)


//
// MessageId: BDK_E_INVALID_REVERSE_REASON
//
// MessageText:
//
//  Invalid reason for reverse operation.
//
#define BDK_E_INVALID_REVERSE_REASON     ((HRESULT)0x8004CDDDL)


//
// MessageId: BDK_E_TOO_MANY_ITEMS_IN_PURCHASE
//
// MessageText:
//
//  Only 1 item can be purchased at once.
//
#define BDK_E_TOO_MANY_ITEMS_IN_PURCHASE ((HRESULT)0x8004CDE0L)


//
// MessageId: BDK_E_INVALID_OFFERING_TYPE
//
// MessageText:
//
//  PurchaseItem accepts only offers that are configured for item, PurchaseSubscription accepts only subscription offers.
//
#define BDK_E_INVALID_OFFERING_TYPE      ((HRESULT)0x8004CDE1L)


//
// MessageId: BDK_E_PRICE_IS_NEGATIVE
//
// MessageText:
//
//  The price specified must be a positive value.
//
#define BDK_E_PRICE_IS_NEGATIVE          ((HRESULT)0x8004CDE2L)


//
// MessageId: BDK_E_DYNAMIC_PRICE_CONFIGURATION
//
// MessageText:
//
//  Cannot pass in a price and/or currency because it is configured on the item.
//
#define BDK_E_DYNAMIC_PRICE_CONFIGURATION ((HRESULT)0x8004CDE3L)


//
// MessageId: BDK_E_DMP_MAX_BALANCE_EXCEEDED
//
// MessageText:
//
//  The maximum allowable DMP point balance is exceeded.
//
#define BDK_E_DMP_MAX_BALANCE_EXCEEDED   ((HRESULT)0x8004CDE4L)


//
// MessageId: BDK_E_CURRENCY_MISSING
//
// MessageText:
//
//  Calling partner needs to add a currency because it is not pre-configured.
//
#define BDK_E_CURRENCY_MISSING           ((HRESULT)0x8004CDE5L)


//
// MessageId: BDK_E_PENDING_ITEM_PURCHASE
//
// MessageText:
//
//  The user already has a pending purchase for for this item that must first be cancelled or completed.
//
#define BDK_E_PENDING_ITEM_PURCHASE      ((HRESULT)0x8004CDE6L)


//
// MessageId: BDK_E_DMP_FLOW_NOT_ENABLED
//
// MessageText:
//
//  Unable to talk to DMP system.
//
#define BDK_E_DMP_FLOW_NOT_ENABLED       ((HRESULT)0x8004CDE7L)


//
// MessageId: BDK_E_ITEM_ALREADY_REVERSED
//
// MessageText:
//
//  Item has been already reversed.
//
#define BDK_E_ITEM_ALREADY_REVERSED      ((HRESULT)0x8004CDE8L)


//
// MessageId: BDK_E_ITEM_NOT_FULFILLED
//
// MessageText:
//
//  Reversing an item that has not been fulfilled.
//
#define BDK_E_ITEM_NOT_FULFILLED         ((HRESULT)0x8004CDE9L)


//
// MessageId: BDK_E_DMP_UNKNOWN_ERROR
//
// MessageText:
//
//  Unknown DMP error has occurred.
//
#define BDK_E_DMP_UNKNOWN_ERROR          ((HRESULT)0x8004CDEAL)


//
// MessageId: BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE
//
// MessageText:
//
//  Payment method type does not support operation.
//
#define BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE ((HRESULT)0x8004CDECL)


//
// MessageId: BDK_E_INVALID_CANCEL_TRANSACTION_RESULT
//
// MessageText:
//
//  Redirect vendor returned an invalid CancelTransaction result.
//
#define BDK_E_INVALID_CANCEL_TRANSACTION_RESULT ((HRESULT)0x8004CDEDL)


//
// MessageId: BDK_E_CVM_MISSING
//
// MessageText:
//
//  CVM code Missing
//
#define BDK_E_CVM_MISSING                ((HRESULT)0x8004CDEEL)


//
// MessageId: BDK_E_RENEWAL_DOES_NOT_EXISTS
//
// MessageText:
//
//  The renewal does not exists.
//
#define BDK_E_RENEWAL_DOES_NOT_EXISTS    ((HRESULT)0x8004AC9AL)


//
// MessageId: BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS
//
// MessageText:
//
//  The token schedule rennewal exists for this offer.
//
#define BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS ((HRESULT)0x8004AC9CL)


//
// MessageId: BDK_E_NULL_CATEGORY
//
// MessageText:
//
//  Category should not be null.
//
#define BDK_E_NULL_CATEGORY              ((HRESULT)0x8004AC62L)


//
// MessageId: BDK_E_NULL_ACCOUNTID
//
// MessageText:
//
//  Account ID cannot be null.
//
#define BDK_E_NULL_ACCOUNTID             ((HRESULT)0x8004AC63L)


//
// MessageId: BDK_E_NULL_SUBSCRIPTIONREFID
//
// MessageText:
//
//  Subscription Ref ID cannot be null.
//
#define BDK_E_NULL_SUBSCRIPTIONREFID     ((HRESULT)0x8004AC64L)


//
// MessageId: BDK_E_INVALID_SURVEYRESULTCODE
//
// MessageText:
//
//  Invalid Survey Result Code.
//
#define BDK_E_INVALID_SURVEYRESULTCODE   ((HRESULT)0x8004AC65L)


//
// MessageId: BDK_E_CD_NOTFOUND
//
// MessageText:
//
//  CD not found.
//
#define BDK_E_CD_NOTFOUND                ((HRESULT)0x8004AC66L)


//
// MessageId: BDK_E_INVALID_ACCOUNTID
//
// MessageText:
//
//  Invalid Account ID.
//
#define BDK_E_INVALID_ACCOUNTID          ((HRESULT)0x8004AC67L)


//
// MessageId: BDK_E_INVALID_ANONYMOUS_INFO_XML
//
// MessageText:
//
//  Invalid AnonymousInfo Xml.
//
#define BDK_E_INVALID_ANONYMOUS_INFO_XML ((HRESULT)0x8004AC68L)


//
// MessageId: BDK_E_UNSUPPORTED_OBJECT_TYPE
//
// MessageText:
//
//  Unsupported object type.
//
#define BDK_E_UNSUPPORTED_OBJECT_TYPE    ((HRESULT)0x8004AC69L)


//
// MessageId: BDK_E_INVALID_PHONE_XML
//
// MessageText:
//
//  Invalid Phone XML.
//
#define BDK_E_INVALID_PHONE_XML          ((HRESULT)0x8004AC6AL)


//
// MessageId: BDK_E_INVALID_REQUESTOR_INFO
//
// MessageText:
//
//  Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters.
//
#define BDK_E_INVALID_REQUESTOR_INFO     ((HRESULT)0x8004AC6CL)


//
// MessageId: BDK_E_PENDING_TRANSACTIONS
//
// MessageText:
//
//  There are pending transactions on this deal or subscription.
//
#define BDK_E_PENDING_TRANSACTIONS       ((HRESULT)0x8004ACAAL)


//
// MessageId: BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH
//
// MessageText:
//
//  The lineitem id and settlement id do not match
//
#define BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH ((HRESULT)0x800452D0L)


//
// MessageId: BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS
//
// MessageText:
//
//  Invalid original charge details
//
#define BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS ((HRESULT)0x800452D5L)


//
// MessageId: BDK_E_PARTIAL_CHAREGBACK
//
// MessageText:
//
//  Partial Chargeback cannot be Processed
//
#define BDK_E_PARTIAL_CHAREGBACK         ((HRESULT)0x800452D8L)


//
// MessageId: BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL
//
// MessageText:
//
//  Invalid lineitem id for reversal
//
#define BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL ((HRESULT)0x800452DAL)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_DATE
//
// MessageText:
//
//  Invalid chargeback date. Chargeback date must greater or equals to original settlement date
//
#define BDK_E_INVALID_CHARGEBACK_DATE    ((HRESULT)0x800452E9L)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_AMOUNT
//
// MessageText:
//
//  Invalid chargeback amount.
//
#define BDK_E_INVALID_CHARGEBACK_AMOUNT  ((HRESULT)0x800452EEL)


//
// MessageId: BDK_E_ALREADY_OFFSET_TAX
//
// MessageText:
//
//  Tax was already offset for this line item.
//
#define BDK_E_ALREADY_OFFSET_TAX         ((HRESULT)0x800452F1L)


//
// MessageId: BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED
//
// MessageText:
//
//  mappoint is not enabled for the country code.
//
#define BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED ((HRESULT)0x80049CEBL)


//
// MessageId: BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT
//
// MessageText:
//
//  SCS had error connecting to mappoint due to some network problems.
//
#define BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT ((HRESULT)0x8004CE4FL)


//
// MessageId: BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT
//
// MessageText:
//
//  SCS had some internal error connecting that is preventing connection to mappoint.
//
#define BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT ((HRESULT)0x8004CE50L)


//
// MessageId: BDK_E_ZERO_ADDRESSES_BY_MAPPOINT
//
// MessageText:
//
//  Mappoint returned 0 addresses.
//
#define BDK_E_ZERO_ADDRESSES_BY_MAPPOINT ((HRESULT)0x8004CE51L)


//
// MessageId: BDK_E_UNKNOWN_ERROR
//
// MessageText:
//
//  UNKNOWN ERROR in MAPPOINT API.
//
#define BDK_E_UNKNOWN_ERROR              ((HRESULT)0x8004CE52L)


//
// MessageId: BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR
//
// MessageText:
//
//  UNKNOWN ERROR ENCOUNTERED.
//
#define BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR ((HRESULT)0x8004ACA4L)


//
// MessageId: BDK_E_INVALID_ADDRESSINFOXML
//
// MessageText:
//
//  Invalid AddressInfo Xml.
//
#define BDK_E_INVALID_ADDRESSINFOXML     ((HRESULT)0x8004CE54L)


//
// MessageId: BDK_E_POST_BOX_ERROR_MAPPOINT
//
// MessageText:
//
//  Mappoint does not support Post Box Addresses currently.
//
#define BDK_E_POST_BOX_ERROR_MAPPOINT    ((HRESULT)0x8004CE55L)


//
// MessageId: BDK_E_MAPPOINT_CONNECTION_MAPPOINT
//
// MessageText:
//
//  The connection to Mappoint has timed out.
//
#define BDK_E_MAPPOINT_CONNECTION_MAPPOINT ((HRESULT)0x8004CE56L)


//
// MessageId: BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS
//
// MessageText:
//
//  Invalid Chargeback details provided as input
//
#define BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS ((HRESULT)0x8004D818L)


//
// MessageId: BDK_E_CHARGEBACK_NOT_FOUND
//
// MessageText:
//
//  Chargeback id not found
//
#define BDK_E_CHARGEBACK_NOT_FOUND       ((HRESULT)0x8004D81DL)


//
// MessageId: BDK_E_CHARGEBACK_NOT_MATCH
//
// MessageText:
//
//  Chargeback id did not match
//
#define BDK_E_CHARGEBACK_NOT_MATCH       ((HRESULT)0x8004D827L)


//
// MessageId: BDK_E_DOUBLE_CHARGEBACK
//
// MessageText:
//
//  Double chargeback
//
#define BDK_E_DOUBLE_CHARGEBACK          ((HRESULT)0x8004D836L)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_LINEITEM_ID
//
// MessageText:
//
//  Invalid chargebacklineitem id
//
#define BDK_E_INVALID_CHARGEBACK_LINEITEM_ID ((HRESULT)0x8004D83BL)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_REVERSAL_ID
//
// MessageText:
//
//  Invalid reversal chargeback id
//
#define BDK_E_INVALID_CHARGEBACK_REVERSAL_ID ((HRESULT)0x8004D84AL)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID
//
// MessageText:
//
//  Invalid chargeback for reversal chargeback id
//
#define BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID ((HRESULT)0x8004D84FL)


//
// MessageId: BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID
//
// MessageText:
//
//  invalid lineitem id for chargeback id
//
#define BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID ((HRESULT)0x8004D854L)


//
// MessageId: BDK_E_INVALID_LINEITEM_TYPE
//
// MessageText:
//
//  invalid lineitem id
//
#define BDK_E_INVALID_LINEITEM_TYPE      ((HRESULT)0x8004D859L)


//
// MessageId: BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL
//
// MessageText:
//
//  Double chargeback for reversal
//
#define BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL ((HRESULT)0x8004D868L)


//
// MessageId: BDK_E_COUNTRY_NOT_SUPPORTED
//
// MessageText:
//
//  The country trying to be mapped is not supported by MAPPOINT
//
#define BDK_E_COUNTRY_NOT_SUPPORTED      ((HRESULT)0x8004ACA5L)


//
// MessageId: BDK_E_COUNTRY_MAPPOINT_DISABLED
//
// MessageText:
//
//  SCS has temporarily disabled MAPPOINT support for this country
//
#define BDK_E_COUNTRY_MAPPOINT_DISABLED  ((HRESULT)0x8004ACA6L)


//
// MessageId: BDK_E_INVALID_PARAMETER
//
// MessageText:
//
//  The input parameter is incorrect
//
#define BDK_E_INVALID_PARAMETER          ((HRESULT)0x8004ACA7L)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_ID
//
// MessageText:
//
//  Invalid ChargebackID Generation.
//
#define BDK_E_INVALID_CHARGEBACK_ID      ((HRESULT)0x8004283CL)


//
// MessageId: BDK_E_CHARGEBACK_PROCESSING_FAILURE
//
// MessageText:
//
//  Error when Chargeback Processing Failure.
//
#define BDK_E_CHARGEBACK_PROCESSING_FAILURE ((HRESULT)0x8004283DL)


//
// MessageId: BDK_E_INVALID_MERCHANT_REFERENCE
//
// MessageText:
//
//  Invalid Merchant Reference Number.
//
#define BDK_E_INVALID_MERCHANT_REFERENCE ((HRESULT)0x8004283EL)


//
// MessageId: BDK_E_CHARGEBACK_INFO_MISSING
//
// MessageText:
//
//  Error when any input details missing.
//
#define BDK_E_CHARGEBACK_INFO_MISSING    ((HRESULT)0x8004283FL)


//
// MessageId: BDK_E_RECORD_CHARGEBACK_FAILED
//
// MessageText:
//
//  Error while recording chargeback/reversal in Chargeback History table.
//
#define BDK_E_RECORD_CHARGEBACK_FAILED   ((HRESULT)0x80042840L)


//
// MessageId: BDK_E_DOUBLE_CHARGEBACK_REVERSAL
//
// MessageText:
//
//  Double Chargeback Reversal
//
#define BDK_E_DOUBLE_CHARGEBACK_REVERSAL ((HRESULT)0x80042841L)


//
// MessageId: BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK
//
// MessageText:
//
//  Chargeback Processing Reversal
//
#define BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK ((HRESULT)0x80042842L)


//
// MessageId: BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION
//
// MessageText:
//
//  Payment instrument not associated with subscription
//
#define BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION ((HRESULT)0x80042843L)


//
// MessageId: BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED
//
// MessageText:
//
//  Subscription already converted or renewed
//
#define BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED ((HRESULT)0x80042844L)


//
// MessageId: BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING
//
// MessageText:
//
//  Merchant Reference Number missing
//
#define BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING ((HRESULT)0x80042845L)


//
// MessageId: BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER
//
// MessageText:
//
//  Invalid Encrypt Account number
//
#define BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER ((HRESULT)0x80042846L)


//
// MessageId: BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL
//
// MessageText:
//
//  Subscription has been scheduled to renew
//
#define BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL ((HRESULT)0x80042847L)


//
// MessageId: BDK_E_PROFILE_ALREADY_EXISTS
//
// MessageText:
//
//  Account holder's profile already exists.
//
#define BDK_E_PROFILE_ALREADY_EXISTS     ((HRESULT)0x80042848L)


//
// MessageId: BDK_E_PROFILE_DOES_NOT_EXIST
//
// MessageText:
//
//  Account holder's profile does not exist.
//
#define BDK_E_PROFILE_DOES_NOT_EXIST     ((HRESULT)0x80042849L)


//
// MessageId: BDK_E_ACCOUNT_WITHOUT_ADDRESS
//
// MessageText:
//
//  Account does not have an address associated with it.
//
#define BDK_E_ACCOUNT_WITHOUT_ADDRESS    ((HRESULT)0x8004284AL)


//
// MessageId: BDK_E_NO_PAYOUT_PREFERENCE
//
// MessageText:
//
//  Payout preference (default) is not set.
//
#define BDK_E_NO_PAYOUT_PREFERENCE       ((HRESULT)0x8004284BL)


//
// MessageId: BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE
//
// MessageText:
//
//  Payout preference (default) can not be deleted.
//
#define BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE ((HRESULT)0x8004284CL)


//
// MessageId: BDK_E_INVALID_PAYUSERINFOXML
//
// MessageText:
//
//  Invalid PayUserInfo XML.
//
#define BDK_E_INVALID_PAYUSERINFOXML     ((HRESULT)0x8004284DL)


//
// MessageId: BDK_E_INVALID_USERPROFILEXML
//
// MessageText:
//
//  Invalid UserProfile XML.
//
#define BDK_E_INVALID_USERPROFILEXML     ((HRESULT)0x8004284EL)


//
// MessageId: BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID
//
// MessageText:
//
//  Account ID must not be specified.
//
#define BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID ((HRESULT)0x8004284FL)


//
// MessageId: BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED
//
// MessageText:
//
//  Description length exceeded
//
#define BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED ((HRESULT)0x80042850L)


//
// MessageId: BDK_E_REFERRAL_CODE_NOT_FOUND
//
// MessageText:
//
//  Referral code not found in SCS database
//
#define BDK_E_REFERRAL_CODE_NOT_FOUND    ((HRESULT)0x8004AC59L)


//
// MessageId: ERROR_MISSING_PROV_INFO
//
// MessageText:
//
//  There is no existing provisioning information to complete this call
//
#define ERROR_MISSING_PROV_INFO          ((HRESULT)0x8004D2FDL)


//
// MessageId: BDK_E_INVALID_RESOURCE_TYPE
//
// MessageText:
//
//  Invalid Resource Type
//
#define BDK_E_INVALID_RESOURCE_TYPE      ((HRESULT)0x8004AC5AL)


//
// MessageId: BDK_E_DMP_FIRST
//
// MessageText:
//
//  BDK_E_DMP_FIRST
//
#define BDK_E_DMP_FIRST                  ((HRESULT)0x8004FA00L)


//
// MessageId: BDK_E_DMP_LAST
//
// MessageText:
//
//  BDK_E_DMP_LAST
//
#define BDK_E_DMP_LAST                   ((HRESULT)0x8004FDE7L)


//
// MessageId: BDK_E_INVALID_TARGET_USER_INFORMATION
//
// MessageText:
//
//  Invalid target user information specified
//
#define BDK_E_INVALID_TARGET_USER_INFORMATION ((HRESULT)0x80047918L)


//
// MessageId: BDK_E_INVALID_DELEGATE_USER_INFORMATION
//
// MessageText:
//
//  Invalid delegate user information
//
#define BDK_E_INVALID_DELEGATE_USER_INFORMATION ((HRESULT)0x80047919L)


//
// MessageId: BDK_E_INVALID_SOURCE_USER_INFORMATION
//
// MessageText:
//
//  Invalid source information
//
#define BDK_E_INVALID_SOURCE_USER_INFORMATION ((HRESULT)0x8004791AL)


//
// MessageId: BDK_E_INVALID_TRANSACTION_INFORMATION
//
// MessageText:
//
//  Invalid transaction Id
//
#define BDK_E_INVALID_TRANSACTION_INFORMATION ((HRESULT)0x8004791BL)


//
// MessageId: BDK_E_NO_MATCHING_TRANSACTION
//
// MessageText:
//
//  Transaction information passed in does not match the information stored
//
#define BDK_E_NO_MATCHING_TRANSACTION    ((HRESULT)0x8004791CL)


//
// MessageId: BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION
//
// MessageText:
//
//  Unable to find transaction in PENDING_PAYOUT state matching the input parameters
//
#define BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION ((HRESULT)0x8004791DL)


//
// MessageId: BDK_E_NO_MATCHING_PENDING_TRANSACTION
//
// MessageText:
//
//  Unable to find transaction in PENDING state matching the input parameters
//
#define BDK_E_NO_MATCHING_PENDING_TRANSACTION ((HRESULT)0x8004791EL)

//Please avoid using message id starting with 60000, reserved for TaxWare
#endif //__bdkerror_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\inc\psoencrypter.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for psoencrypter.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __psoencrypter_h__
#define __psoencrypter_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPsoEncrypter_FWD_DEFINED__
#define __IPsoEncrypter_FWD_DEFINED__
typedef interface IPsoEncrypter IPsoEncrypter;
#endif 	/* __IPsoEncrypter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IPsoEncrypter_INTERFACE_DEFINED__
#define __IPsoEncrypter_INTERFACE_DEFINED__

/* interface IPsoEncrypter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPsoEncrypter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77298B76-8915-40c8-93E6-FBE5DDEDC5C1")
    IPsoEncrypter : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Provider( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ LONG lErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ LONG *lErrorCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorDescription( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertObjectIDToAcctID( 
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateGUID( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertServiceRefIDToSubID( 
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSessionKey( 
            /* [retval][out] */ BSTR *pbstrSessionKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR bstrEncryptedText,
            /* [in] */ BSTR bstrSessionKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSessionKeyEx( 
            /* [retval][out] */ BSTR *pbstrSessionKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptEx( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPsoEncrypterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPsoEncrypter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPsoEncrypter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPsoEncrypter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPsoEncrypter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPsoEncrypter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPsoEncrypter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPsoEncrypter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPsoEncrypter * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Provider )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorCode )( 
            IPsoEncrypter * This,
            /* [in] */ LONG lErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IPsoEncrypter * This,
            /* [retval][out] */ LONG *lErrorCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorDescription )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConvertObjectIDToAcctID )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateGUID )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConvertServiceRefIDToSubID )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSessionKey )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrSessionKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrEncryptedText,
            /* [in] */ BSTR bstrSessionKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSessionKeyEx )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrSessionKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptEx )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        END_INTERFACE
    } IPsoEncrypterVtbl;

    interface IPsoEncrypter
    {
        CONST_VTBL struct IPsoEncrypterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPsoEncrypter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPsoEncrypter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPsoEncrypter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPsoEncrypter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPsoEncrypter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPsoEncrypter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPsoEncrypter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPsoEncrypter_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IPsoEncrypter_get_Provider(This,pbstrVal)	\
    (This)->lpVtbl -> get_Provider(This,pbstrVal)

#define IPsoEncrypter_put_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> put_ErrorCode(This,lErrorCode)

#define IPsoEncrypter_get_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,lErrorCode)

#define IPsoEncrypter_put_ErrorDescription(This,bstrVal)	\
    (This)->lpVtbl -> put_ErrorDescription(This,bstrVal)

#define IPsoEncrypter_get_ErrorDescription(This,pbstrVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrVal)

#define IPsoEncrypter_Encrypt(This,bstrBlob,bstrKey,pbstrResult)	\
    (This)->lpVtbl -> Encrypt(This,bstrBlob,bstrKey,pbstrResult)

#define IPsoEncrypter_ConvertObjectIDToAcctID(This,bstrVal,pbstrValOut)	\
    (This)->lpVtbl -> ConvertObjectIDToAcctID(This,bstrVal,pbstrValOut)

#define IPsoEncrypter_GenerateGUID(This,pbstrVal)	\
    (This)->lpVtbl -> GenerateGUID(This,pbstrVal)

#define IPsoEncrypter_ConvertServiceRefIDToSubID(This,bstrVal,pbstrValOut)	\
    (This)->lpVtbl -> ConvertServiceRefIDToSubID(This,bstrVal,pbstrValOut)

#define IPsoEncrypter_GenerateSessionKey(This,pbstrSessionKey)	\
    (This)->lpVtbl -> GenerateSessionKey(This,pbstrSessionKey)

#define IPsoEncrypter_Decrypt(This,bstrEncryptedText,bstrSessionKey,pbstrResult)	\
    (This)->lpVtbl -> Decrypt(This,bstrEncryptedText,bstrSessionKey,pbstrResult)

#define IPsoEncrypter_GenerateSessionKeyEx(This,pbstrSessionKey)	\
    (This)->lpVtbl -> GenerateSessionKeyEx(This,pbstrSessionKey)

#define IPsoEncrypter_EncryptEx(This,bstrBlob,bstrKey,pbstrResult)	\
    (This)->lpVtbl -> EncryptEx(This,bstrBlob,bstrKey,pbstrResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Initialize_Proxy( 
    IPsoEncrypter * This);


void __RPC_STUB IPsoEncrypter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_Provider_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_get_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_put_ErrorCode_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IPsoEncrypter_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_ErrorCode_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ LONG *lErrorCode);


void __RPC_STUB IPsoEncrypter_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_put_ErrorDescription_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoEncrypter_put_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_ErrorDescription_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Encrypt_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_ConvertObjectIDToAcctID_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal,
    /* [retval][out] */ BSTR *pbstrValOut);


void __RPC_STUB IPsoEncrypter_ConvertObjectIDToAcctID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateGUID_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_GenerateGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_ConvertServiceRefIDToSubID_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal,
    /* [retval][out] */ BSTR *pbstrValOut);


void __RPC_STUB IPsoEncrypter_ConvertServiceRefIDToSubID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateSessionKey_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrSessionKey);


void __RPC_STUB IPsoEncrypter_GenerateSessionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Decrypt_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrEncryptedText,
    /* [in] */ BSTR bstrSessionKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateSessionKeyEx_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrSessionKey);


void __RPC_STUB IPsoEncrypter_GenerateSessionKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_EncryptEx_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_EncryptEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPsoEncrypter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\inc\psomessages.h ===
#define  MAKEERROR(fac,err)   		MAKE_HRESULT(SEVERITY_ERROR,fac,err)
#define  MAKEWIN32ERROR(err)  		MAKEERROR(FACILITY_WIN32,err)
#define  GETWIN32ERROR()      		MAKEWIN32ERROR(GetLastError())
#define  MAKESCODE(fac,err)   		MAKE_HRESULT(SEVERITY_SUCCESS,fac,err)
#define  MAKEWIN32SCODE(err)  		MAKESCODE(FACILITY_WIN32,err)
#define  GETWIN32SCODE()      		MAKEWIN32SCODE(GetLastError())
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_PSOConnector            0x402
#define FACILITY_PSO                     0x401
#define FACILITY_DEFAULT                 0x100


//
// Define the severity codes
//


//
// MessageId: E_PSO_UNEXPECTED_ERROR
//
// MessageText:
//
//  Unexpected error in Partner Side Object (PSO). Contact SPG for assistance.
//
#define E_PSO_UNEXPECTED_ERROR           0x84010064L

//
// MessageId: E_PSO_HTTP_ERROR
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). Verify that the partner key provided by SPG is installed in HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that it contains an environment hive with valid WsdlLocation and WsmlLocation settings.
//
#define E_PSO_HTTP_ERROR                 0x84010065L

//
// MessageId: E_PSO_NOT_INITIALIZED
//
// MessageText:
//
//  The Partner Side Object (PSO) has not been initialized. You must first call the Initialize or the Connect method. You cannot call this function in the current state.
//
#define E_PSO_NOT_INITIALIZED            0x84010066L

//
// MessageId: E_PSO_NO_ENVIRONMENT
//
// MessageText:
//
//  Error retrieving the default partner environment name or an environment property such as WsdlLocation, WsmlLocation, or PartnerUsername. Verify that the partner key provided by SPG is installed in HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that it contains an environment hive with valid WsdlLocation and WsmlLocation settings and proper security attributes.
//
#define E_PSO_NO_ENVIRONMENT             0x84010067L

//
// MessageId: E_PSO_NO_SOAPCLIENT
//
// MessageText:
//
//  Error creating an instance of __uuidof(SoapClient). Verify that the SOAP Toolkit (version 2.0 SP2 or greater) is installed. The SOAP Toolkit is available at http://msdn.microsoft.com/xml/.
//
#define E_PSO_NO_SOAPCLIENT              0x84010068L

//
// MessageId: E_PSO_POOLCONNECTIONS
//
// MessageText:
//
//  Invalid number of PoolConnections specified. The acceptable range is between 0 and 64 connections.
//
#define E_PSO_POOLCONNECTIONS            0x84010069L

//
// MessageId: E_PSO_HTTP_ERROR_401
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). 401 - Access is denied. Check that the correct partner key MSI is installed, that the registry configuration points to the correct server, that the partner MSI package contains the correct key for the environment you are attempting to connect to, and that the server did not inadvertantly reset the partner password.
//
#define E_PSO_HTTP_ERROR_401             0x8401006AL

//
// MessageId: E_PSO_HTTP_ERROR_500
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). 500 - An internal server error has occurred. This can be due to a server configuration problem.
//
#define E_PSO_HTTP_ERROR_500             0x8401006BL

//
// MessageId: E_PSO_SOAP_PROPERTY
//
// MessageText:
//
//  Error setting a property on the SoapClient connection object. Verify that the SOAP Toolkit (version 2.0 SP2 or greater) is installed, and that %ProgramFiles%\Common Files\MSSoap\Binaries\mssoap1.dll is version 1.2.814.0 or greater. The SOAP Toolkit is available at http://msdn.microsoft.com/xml/.
//
#define E_PSO_SOAP_PROPERTY              0x8401006CL

//
// MessageId: E_PSO_TEMP_PATH
//
// MessageText:
//
//  Unable to get the temporary file path.
//
#define E_PSO_TEMP_PATH                  0x8401006DL

//
// MessageId: E_PSO_TEMP_FILE
//
// MessageText:
//
//  Unable to get the temporary file name or to create a temporary file. This is generally a write permissions problem.
//  If a user has a profile, the temporary path is defined by the TEMP environment setting and is typically [HOMEPATH]\[Username]\Local Settings\Temp.
//  If a user does not have a profile, such as IWAM_Computername or IUSR_Computername, this path is either [SystemDrive]\Temp or [SystemRoot]\Temp.
//
#define E_PSO_TEMP_FILE                  0x8401006EL

//
// MessageId: E_PSO_REG_PARTNER_HIVE
//
// MessageText:
//
//  Error opening partner registry hive or hive does not exist. (Re)install the partner key.
//  Check whether HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner exists and has the proper security settings.
//  Check whether this key contains a correct Environment and PartnerHive value.
//
#define E_PSO_REG_PARTNER_HIVE           0x8401006FL

//
// MessageId: E_PSO_REG_PARTNER_VALUE
//
// MessageText:
//
//  Error reading partner registry data. (Re)install the partner key.
//  Check whether Environment and PartnerHive values exist under HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that the key has proper security settings.
//
#define E_PSO_REG_PARTNER_VALUE          0x84010070L

//
// MessageId: E_PSO_REG_KEY_VALUE
//
// MessageText:
//
//  Error reading partner registry password data. (Re)install the partner key.
//  Check whether HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner\[Environment]\[PartnerHive]\Passwords exists and that it has proper security settings.
//
#define E_PSO_REG_KEY_VALUE              0x84010071L

//
// MessageId: S_PSOCONNECTOR_FINALCONSTRUCT
//
// MessageText:
//
//  A PSO Connector Object has been created.
//
#define S_PSOCONNECTOR_FINALCONSTRUCT    0x440200C8L

//
// MessageId: S_PSOCONNECTOR_INITIALIZED
//
// MessageText:
//
//  A PSO Connector Object has been successfully initialized.
//
#define S_PSOCONNECTOR_INITIALIZED       0x440200C9L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\SampleProvider.cpp ===
// SampleProvider.cpp : Implementation of CSampleProvider
#include "stdafx.h"
#include "SPK_ISvcProvider_Sample.h"
#include "SampleProvider.h"
#include "SvcProvider_i.c"

/////////////////////////////////////////////////////////////////////////////
// CSampleProvider
HRESULT CSampleProvider::ProvisionService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrServiceInstanceFriendlyName,
            BSTR bstrBaseServiceInstanceId,
            BSTR bstrDetails,
            BSTR *pbstrResponseXML)
{
//Write Code to Provision Service here

    return S_OK;
}

HRESULT CSampleProvider::DeprovisionService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            VARIANT_BOOL RemoveServiceFlag,
            BSTR *pbstrResponseXML)
{
//Write Code to Deprovision Service here

    if (VARIANT_TRUE == RemoveServiceFlag)
    {
        //Deprovision Service
    }
    else
    {
        //Remove Role of the user
    }

    return S_OK;
}

HRESULT CSampleProvider::EnableService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR *pbstrResponseXML)
{
//Write Code to Enable Service here

    return S_OK;
}

HRESULT CSampleProvider::DisableService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrDetails,
            BSTR *pbstrResponseXML)
{
//Write Code to Disable Service here

    return S_OK;
}

HRESULT CSampleProvider::ValidateProvisioningData(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrDetails,
            BSTR *pbstrDetailsResponse,
            BSTR *pbstrResponseXML)
{
//Write Code to Validate data here

    return S_OK;
}

HRESULT CSampleProvider::CheckProvisioningStatus(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR * pbstrResponseXML)
{
//Write Code to Check Status here

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\SampleProvider.h ===
// SampleProvider.h : Declaration of the CSampleProvider

#ifndef __SAMPLEPROVIDER_H_
#define __SAMPLEPROVIDER_H_

#include "resource.h"       // main symbols
#include "SPK_ISvcProvider_Sample.h"

/////////////////////////////////////////////////////////////////////////////
// CSampleProvider
class ATL_NO_VTABLE CSampleProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSampleProvider, &CLSID_SampleProvider>,
	public IDispatchImpl<ISvcProvider, &IID_ISvcProvider, &LIBID_EMULATORLib>
{
public:
	CSampleProvider()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLEPROVIDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSampleProvider)
	COM_INTERFACE_ENTRY(ISvcProvider)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
// ISvcProvider
    STDMETHOD(ProvisionService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrServiceInstanceFriendlyName,
            BSTR bstrBaseServiceInstanceId,
            BSTR bstrDetails,
            BSTR * pbstrResponseXML);

    STDMETHOD(DeprovisionService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            VARIANT_BOOL RemoveServiceFlag,
            BSTR * pbstrResponseXML);
    STDMETHOD(EnableService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR * pbstrResponseXML);

    STDMETHOD(DisableService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrDetails,
            BSTR * pbstrResponseXML);

    STDMETHOD(ValidateProvisioningData)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrDetails,
            BSTR *pbstrDetailsResponse,
            BSTR * pbstrResponseXML);

    STDMETHOD(CheckProvisioningStatus)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR * pbstrResponseXML);
};

#endif //__SAMPLEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SPK_ISvcProvider_Sample.rc
//
#define IDS_PROJNAME                    100
#define IDR_SAMPLEPROVIDER              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\SPK_ISvcProvider_Sample.cpp ===
// SPK_ISvcProvider_Sample.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SPK_ISvcProvider_Sampleps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SPK_ISvcProvider_Sample.h"

#include "SPK_ISvcProvider_Sample_i.c"
#include "SampleProvider.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SampleProvider, CSampleProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SPK_ISVCPROVIDER_SAMPLELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\inc\psoconnector.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for psoconnector.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __psoconnector_h__
#define __psoconnector_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPsoConnector_FWD_DEFINED__
#define __IPsoConnector_FWD_DEFINED__
typedef interface IPsoConnector IPsoConnector;
#endif 	/* __IPsoConnector_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mssoap.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IPsoConnector_INTERFACE_DEFINED__
#define __IPsoConnector_INTERFACE_DEFINED__

/* interface IPsoConnector */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPsoConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECFEB027-7719-4537-8E5D-40AA0ECE4896")
    IPsoConnector : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [retval][out] */ ISOAPClient **psoapClient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PoolConnections( 
            /* [in] */ LONG lConnectionCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PoolConnections( 
            /* [retval][out] */ LONG *lConnectionCount) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_WsdlLocation( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WsdlLocation( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerEnvironment( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerEnvironment( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerUsername( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerUsername( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerPassword( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerPassword( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ LONG lErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ LONG *lErrorCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorDescription( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoImpersonateClient( 
            /* [in] */ VARIANT_BOOL vImpersonate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoImpersonateClient( 
            /* [retval][out] */ VARIANT_BOOL *vImpersonate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshConnection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPsoConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPsoConnector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPsoConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPsoConnector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPsoConnector * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPsoConnector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPsoConnector * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPsoConnector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPsoConnector * This,
            /* [retval][out] */ ISOAPClient **psoapClient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPsoConnector * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PoolConnections )( 
            IPsoConnector * This,
            /* [in] */ LONG lConnectionCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PoolConnections )( 
            IPsoConnector * This,
            /* [retval][out] */ LONG *lConnectionCount);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WsdlLocation )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WsdlLocation )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerEnvironment )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerEnvironment )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerUsername )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerUsername )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerPassword )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerPassword )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorCode )( 
            IPsoConnector * This,
            /* [in] */ LONG lErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IPsoConnector * This,
            /* [retval][out] */ LONG *lErrorCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorDescription )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoImpersonateClient )( 
            IPsoConnector * This,
            /* [in] */ VARIANT_BOOL vImpersonate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoImpersonateClient )( 
            IPsoConnector * This,
            /* [retval][out] */ VARIANT_BOOL *vImpersonate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshConnection )( 
            IPsoConnector * This);
        
        END_INTERFACE
    } IPsoConnectorVtbl;

    interface IPsoConnector
    {
        CONST_VTBL struct IPsoConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPsoConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPsoConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPsoConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPsoConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPsoConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPsoConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPsoConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPsoConnector_Connect(This,psoapClient)	\
    (This)->lpVtbl -> Connect(This,psoapClient)

#define IPsoConnector_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IPsoConnector_get_Version(This,pbstrVal)	\
    (This)->lpVtbl -> get_Version(This,pbstrVal)

#define IPsoConnector_put_PoolConnections(This,lConnectionCount)	\
    (This)->lpVtbl -> put_PoolConnections(This,lConnectionCount)

#define IPsoConnector_get_PoolConnections(This,lConnectionCount)	\
    (This)->lpVtbl -> get_PoolConnections(This,lConnectionCount)

#define IPsoConnector_put_WsdlLocation(This,bstrVal)	\
    (This)->lpVtbl -> put_WsdlLocation(This,bstrVal)

#define IPsoConnector_get_WsdlLocation(This,pbstrVal)	\
    (This)->lpVtbl -> get_WsdlLocation(This,pbstrVal)

#define IPsoConnector_put_PartnerEnvironment(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerEnvironment(This,bstrVal)

#define IPsoConnector_get_PartnerEnvironment(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerEnvironment(This,pbstrVal)

#define IPsoConnector_put_PartnerUsername(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerUsername(This,bstrVal)

#define IPsoConnector_get_PartnerUsername(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerUsername(This,pbstrVal)

#define IPsoConnector_put_PartnerPassword(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerPassword(This,bstrVal)

#define IPsoConnector_get_PartnerPassword(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerPassword(This,pbstrVal)

#define IPsoConnector_put_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> put_ErrorCode(This,lErrorCode)

#define IPsoConnector_get_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,lErrorCode)

#define IPsoConnector_put_ErrorDescription(This,bstrVal)	\
    (This)->lpVtbl -> put_ErrorDescription(This,bstrVal)

#define IPsoConnector_get_ErrorDescription(This,pbstrVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrVal)

#define IPsoConnector_put_CoImpersonateClient(This,vImpersonate)	\
    (This)->lpVtbl -> put_CoImpersonateClient(This,vImpersonate)

#define IPsoConnector_get_CoImpersonateClient(This,vImpersonate)	\
    (This)->lpVtbl -> get_CoImpersonateClient(This,vImpersonate)

#define IPsoConnector_RefreshConnection(This)	\
    (This)->lpVtbl -> RefreshConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_Connect_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ ISOAPClient **psoapClient);


void __RPC_STUB IPsoConnector_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_Initialize_Proxy( 
    IPsoConnector * This);


void __RPC_STUB IPsoConnector_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_Version_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PoolConnections_Proxy( 
    IPsoConnector * This,
    /* [in] */ LONG lConnectionCount);


void __RPC_STUB IPsoConnector_put_PoolConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PoolConnections_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ LONG *lConnectionCount);


void __RPC_STUB IPsoConnector_get_PoolConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_WsdlLocation_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_WsdlLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_WsdlLocation_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_WsdlLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerEnvironment_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerEnvironment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerEnvironment_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerEnvironment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerUsername_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerUsername_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerPassword_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerPassword_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_ErrorCode_Proxy( 
    IPsoConnector * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IPsoConnector_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_ErrorCode_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ LONG *lErrorCode);


void __RPC_STUB IPsoConnector_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_ErrorDescription_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_ErrorDescription_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_CoImpersonateClient_Proxy( 
    IPsoConnector * This,
    /* [in] */ VARIANT_BOOL vImpersonate);


void __RPC_STUB IPsoConnector_put_CoImpersonateClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_CoImpersonateClient_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ VARIANT_BOOL *vImpersonate);


void __RPC_STUB IPsoConnector_get_CoImpersonateClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_RefreshConnection_Proxy( 
    IPsoConnector * This);


void __RPC_STUB IPsoConnector_RefreshConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPsoConnector_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7DA79598_5322_4023_BE8C_7C38757E8D80__INCLUDED_)
#define AFX_STDAFX_H__7DA79598_5322_4023_BE8C_7C38757E8D80__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7DA79598_5322_4023_BE8C_7C38757E8D80__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\SPK_ISvcProvider_Sample.h ===
/* MIDL: this ALWAYS GENERATED file contains the definitions for the interfaces */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\inc\svcprovider_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for svcprovider.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISvcProvider,0x7917F8A0,0x6DCA,0x4D4E,0x91,0x59,0xBA,0x37,0x32,0xAE,0xD5,0x76);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for svcprovider.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISvcProvider,0x7917F8A0,0x6DCA,0x4D4E,0x91,0x59,0xBA,0x37,0x32,0xAE,0xD5,0x76);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\C++\TestConnection\TestConnection.cpp ===
/*++

   Copyright (c) 2000 Microsoft Corporation

   Abstract:

       SPG PSO Partner Side Object
       TestConnection

   Author:

       Daniel Doubrovkine (ddoub)

   Project:

       SPS - Subscription Platform Service

--*/

#include <stdio.h>
#include <conio.h>
#include <atlbase.h>
#include <pso.h>
#include <psoconnector.h>

#define ChkHR(x) hr = x; if (FAILED(hr)) goto LocalCleanup;

int __cdecl main(int argc, char ** argv)
{
    HRESULT hr = S_OK;
    BOOL fCoInitialized = FALSE;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    fCoInitialized = SUCCEEDED(hr) ? TRUE : FALSE;

    {
        CComBSTR bstrVersion;

        CComBSTR bstrWsdlLocation;
        CComBSTR bstrPartnerUsername;
        CComBSTR bstrPartnerPassword;
        CComBSTR bstrPartnerEnvironment;
        LONG ulConnectionCount;
        CComVariant varArgs[2];

        CComPtr<IPsoConnector> pPsoConnector = NULL;
        CComPtr<ISOAPClient> pSoapClient = NULL;
        DISPID dwDispID = 0;
        CComBSTR bstrMethod(L"TestConnection");
        DISPPARAMS DispParams = { & varArgs[0], NULL, 2, 0 };

        printf("TestConnection: running TestConnection (ddoub)\n");

        printf("TestConnection: creating IPsoConnector\n");

        ChkHR(pPsoConnector.CoCreateInstance(__uuidof(PsoConnector)));
        ChkHR(pPsoConnector->get_Version(& bstrVersion));

        printf("TestConnection: pso version: %S\n", (LPWSTR) bstrVersion);
        printf("TestConnection: setting pool connection count to %d\n", 1);

        ChkHR(pPsoConnector->put_PoolConnections(1));

        printf("TestConnection: initializing\n");

        ChkHR(pPsoConnector->Initialize());

        printf("TestConnection: quering properties\n");

        ChkHR(pPsoConnector->get_PartnerUsername(& bstrPartnerUsername));
        ChkHR(pPsoConnector->get_PartnerPassword(& bstrPartnerPassword));
        ChkHR(pPsoConnector->get_PartnerEnvironment(& bstrPartnerEnvironment));
        ChkHR(pPsoConnector->get_WsdlLocation(& bstrWsdlLocation));
        ChkHR(pPsoConnector->get_PoolConnections(& ulConnectionCount));

        printf("TestConnection: PartnerUsername=%S\n", (LPWSTR) bstrPartnerUsername);
        // printf("TestConnection: PartnerPassword=%S\n", (LPWSTR) bstrPartnerPassword);
        printf("TestConnection: PartnerPassword=<hidden>\n");
        printf("TestConnection: PartnerEnvironment=%S\n", (LPWSTR) bstrPartnerEnvironment);
        printf("TestConnection: WsdlLocation=%S\n", (LPWSTR) bstrWsdlLocation);
        printf("TestConnection: ConnectionCount=%d\n", ulConnectionCount);

        varArgs[1] = CComBSTR(L"String");
        varArgs[0].vt = VT_EMPTY;
        varArgs[0].bstrVal = NULL;

        ChkHR(pPsoConnector->Connect(& pSoapClient));
        ChkHR(pSoapClient->GetIDsOfNames( IID_NULL, & bstrMethod, 1, LOCALE_SYSTEM_DEFAULT, & dwDispID));

        printf("TestConnection: disp id=%ld\n", dwDispID);

        ChkHR(pSoapClient->Invoke(
                  dwDispID,
                  IID_NULL,
                  LOCALE_SYSTEM_DEFAULT,
                  DISPATCH_METHOD,
                  & DispParams,
                  NULL,
                  NULL,
                  NULL));

        printf("TestConnection: retval=%ld (%S)\n", varArgs[0].vt, varArgs[0].bstrVal);

    LocalCleanup:

        if (FAILED(hr) && pSoapClient)
        {
            CComBSTR bstrFaultCode;
            CComBSTR bstrFaultString;

            if (SUCCEEDED(pSoapClient->get_faultcode(& bstrFaultCode)))
            {
                printf("TestConnection: soap fault code=%S.\n", (LPCWSTR) bstrFaultCode);
            }

            if (SUCCEEDED(pSoapClient->get_faultstring(& bstrFaultString)))
            {
                printf("TestConnection: soap fault string=%S.\n", (LPCWSTR) bstrFaultString);
            }
        }

        if (FAILED(hr) && pPsoConnector)
        {
            LONG lErrorCode = 0;
            CComBSTR bstrErrorDescription;

            if (SUCCEEDED(pPsoConnector->get_ErrorCode(& lErrorCode)))
            {
                printf("TestConnection: pso error code=%#x.\n", lErrorCode);
            }

            if (SUCCEEDED(pPsoConnector->get_ErrorDescription(& bstrErrorDescription)))
            {
                printf("TestConnection: pso error description=%S.\n", (LPCWSTR) bstrErrorDescription);
            }
        }
    }

    if (fCoInitialized)
    {
        CoUninitialize();
    }

    if (FAILED(hr))
    {
        LPSTR pszMessageBuffer = NULL;
        DWORD dwBufferLength;

        if (dwBufferLength = FormatMessageA(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
                (LPSTR) & pszMessageBuffer,
                0,
                NULL
                ))
        {
            printf("TestConnection: %s", pszMessageBuffer);
            LocalFree(pszMessageBuffer);
        }

        printf("TestConnection: error, hr=%#x\n", hr);
    }
    else
    {
        printf("TestConnection: success.\n");
    }

    {
        STARTUPINFO ProcessStartupInfo;
        GetStartupInfo(& ProcessStartupInfo);
        if (ProcessStartupInfo.dwFlags & STARTF_USESHOWWINDOW)
        {
            printf("\nPress any key to continue.");
            _getch();
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\CSharp\TestConnection\TestConnection.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;

public class TestConnection
{
    static void Main()
    {

        try
        {
            // initialize the provider, call this once
            System.Console.WriteLine( "success: initialize billing provider" );
            BillingProvider.Initialize();
        }
        catch (Exception eInitialize)
        {
            System.Console.WriteLine( "failure: " + eInitialize.Message );
            return;
        }

        try
        {

            string outStr;

            System.Console.WriteLine( "success: creating billing provider" );
            BillingProvider sps = new BillingProvider();

            System.Console.WriteLine( "success: running testconnection" );
            // execute the method
            sps.TestConnection( "Testing 1, 2, 3..!", out outStr );
            // show the output
            System.Console.WriteLine( "success: " + outStr );
        }
        catch (Exception eTest)
        {
            System.Console.WriteLine( "failure: " + eTest.Message );
            System.Console.WriteLine( BillingProvider.ErrorCode() );
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\CSharp\TestConnectionClientCert\TestConnectionClentCert.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using System.Web.Services.Protocols;

public class TestConnection
{
    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.WriteLine("\nUsage: TestConnectionClientCertCSharp.exe <certificate>");
            Console.WriteLine("       <certificate> - Location to certificate file");
            return;
        }

        try
        {
            string outStr;

            System.Console.WriteLine( "success: creating billing provider" );
            // initializes billing provider
            BillingProvider sps = new BillingProvider(args[0], "https://" + Environment.MachineName + "/scs/scsapiwebservice.asmx");

            System.Console.WriteLine( "success: running testconnection" );
            // execute the method
            sps.TestConnection( "Testing 1, 2, 3..!", out outStr );
            // show the output
            System.Console.WriteLine( "success: " + outStr );
        }
        catch (SoapException eTest)
        {
            System.Console.WriteLine( "failure: " + eTest.Message );
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\ISvcProvider2\C++\inc\svcprovider.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for svcprovider.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __svcprovider_h__
#define __svcprovider_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISvcProvider_FWD_DEFINED__
#define __ISvcProvider_FWD_DEFINED__
typedef interface ISvcProvider ISvcProvider;
#endif 	/* __ISvcProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ISvcProvider_INTERFACE_DEFINED__
#define __ISvcProvider_INTERFACE_DEFINED__

/* interface ISvcProvider */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISvcProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7917F8A0-6DCA-4D4E-9159-BA3732AED576")
    ISvcProvider : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProvisionService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR ServiceInstanceFriendlyName,
            /* [in] */ BSTR BaseServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeprovisionService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ VARIANT_BOOL RemoveServiceFlag,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValidateProvisioningData( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR Details,
            /* [out] */ BSTR *DetailsResponse,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckProvisioningStatus( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISvcProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISvcProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISvcProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISvcProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISvcProvider * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISvcProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISvcProvider * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISvcProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProvisionService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR ServiceInstanceFriendlyName,
            /* [in] */ BSTR BaseServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeprovisionService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ VARIANT_BOOL RemoveServiceFlag,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ValidateProvisioningData )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR Details,
            /* [out] */ BSTR *DetailsResponse,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckProvisioningStatus )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [retval][out] */ BSTR *ResponseXML);
        
        END_INTERFACE
    } ISvcProviderVtbl;

    interface ISvcProvider
    {
        CONST_VTBL struct ISvcProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISvcProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISvcProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISvcProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISvcProvider_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISvcProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISvcProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISvcProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISvcProvider_ProvisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ServiceInstanceFriendlyName,BaseServiceInstanceId,Details,ResponseXML)	\
    (This)->lpVtbl -> ProvisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ServiceInstanceFriendlyName,BaseServiceInstanceId,Details,ResponseXML)

#define ISvcProvider_DeprovisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,RemoveServiceFlag,ResponseXML)	\
    (This)->lpVtbl -> DeprovisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,RemoveServiceFlag,ResponseXML)

#define ISvcProvider_EnableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ResponseXML)	\
    (This)->lpVtbl -> EnableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ResponseXML)

#define ISvcProvider_DisableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,Details,ResponseXML)	\
    (This)->lpVtbl -> DisableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,Details,ResponseXML)

#define ISvcProvider_ValidateProvisioningData(This,PUIDHigh,PUIDLow,ServiceComponentId,Details,DetailsResponse,ResponseXML)	\
    (This)->lpVtbl -> ValidateProvisioningData(This,PUIDHigh,PUIDLow,ServiceComponentId,Details,DetailsResponse,ResponseXML)

#define ISvcProvider_CheckProvisioningStatus(This,PUIDHigh,PUIDLow,ServiceComponentId,ResponseXML)	\
    (This)->lpVtbl -> CheckProvisioningStatus(This,PUIDHigh,PUIDLow,ServiceComponentId,ResponseXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_ProvisionService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [in] */ BSTR ServiceInstanceFriendlyName,
    /* [in] */ BSTR BaseServiceInstanceId,
    /* [in] */ BSTR Details,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_ProvisionService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_DeprovisionService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [in] */ VARIANT_BOOL RemoveServiceFlag,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_DeprovisionService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_EnableService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_EnableService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_DisableService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [in] */ BSTR Details,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_DisableService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_ValidateProvisioningData_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR Details,
    /* [out] */ BSTR *DetailsResponse,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_ValidateProvisioningData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_CheckProvisioningStatus_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_CheckProvisioningStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISvcProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\CSharp\TestConnection\BillingProvider.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using Billing.PSO;

public class BillingProvider : bdk
{
  // data that persists across all connections
  private static PsoConnectorClass mPso;

  // this static constructor does the key retrieval from the PSO just once,
  // before anyone uses this object
  static BillingProvider()
  {
    mPso = new PsoConnectorClass();
  }

  public static void Initialize()
  {
    // no pool connections, using C# soap interface
    mPso.PoolConnections = 0;
    // retrieve partner credentials
    mPso.Initialize();
  }

  public static String ErrorDescription()
  {
    return mPso.ErrorDescription;
  }

  public static int ErrorCode()
  {
    return mPso.ErrorCode;
  }

  public BillingProvider() : base()
  {
    // set up the bdk that we have inherited from
    this.Url = mPso.WsdlLocation;
    this.PreAuthenticate = true;
    this.Credentials = new NetworkCredential(
     mPso.PartnerUsername,
     mPso.PartnerPassword
    );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\CSharp\TestConnectionClientCert\BillingProvider.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using Billing.PSO;

/// <summary>
/// Sample code for using Client Certificate to call Subscription & Commerce web service.
/// </summary>
public class BillingProvider : bdk
{
    /// <summary>
    /// Initializes the SOAP client proxy to use specified certificate and wsdl
    /// </summary>
    /// <param name="certificateFile">The path to the client certificate file</param>
    /// <param name="wsdlLocation">The Wsdl URL that points to SCS web service.
    /// Generally this value is stored persistently in some registry or configuration file
    /// </param>
    public BillingProvider(string certificateFile, string wsdlLocation) : base()
    {
        this.Url = wsdlLocation;
        this.PreAuthenticate = true;
        X509Certificate clientCert = GetCertFromFile(certificateFile);
        this.ClientCertificates.Add(clientCert);
    }

    /// <summary>
    /// Get X509 Certificate from file on local file system.
    /// It assumes that you have installed the certificate in local computer store.
    /// This assumes that the file is BASE-64 encoded.
    /// If the file is DER encoded, <see cref="X509Certificate.CreateFromCertFile"/> or
    /// <see cref="X509Certificate.CreateFromCertFile"/> can be used directly.
    /// </summary>
    /// <param name="fileName">The certificate file path</param>
    /// <returns>The <see cref="X509Certificate"/> representing the certificate</returns>
    protected X509Certificate GetCertFromFile(string fileName)
    {
        // Open the certificate, and read it into a byte array.
        using(FileStream certFile = new FileStream(fileName,
                  FileMode.Open,
                  FileAccess.Read))
        {
            int size = (int)certFile.Length;
            byte[] certBytes = new byte[size];
            size = certFile.Read(certBytes, 0, size);
            // Remove the unnecessary characters.
            String certString = Encoding.ASCII.GetString(certBytes);
            StringBuilder sb = new StringBuilder(certString);
            sb.Replace("-----BEGIN CERTIFICATE-----", "");
            sb.Replace("-----END CERTIFICATE-----", "");
    
            // Decode the bytes from base64 to raw bytes.
            certBytes = Convert.FromBase64String(sb.ToString());
            X509Certificate cert = new X509Certificate(certBytes);
            return cert;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\7.5\inc\bdkerror.h ===
#ifndef __bdkerror_h__
#define __bdkerror_h__

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: BDK_E_BAN_NULL_INPUT_PARAMETER
//
// MessageText:
//
//  Null input parameter passed to a "ban" API.
//
#define BDK_E_BAN_NULL_INPUT_PARAMETER   ((HRESULT)0x80047594L)


//
// MessageId: BDK_E_ALREADY_BANNED
//
// MessageText:
//
//  Already banned.
//
#define BDK_E_ALREADY_BANNED             ((HRESULT)0x80047599L)


//
// MessageId: BDK_E_NOT_BANNED
//
// MessageText:
//
//  Not banned.
//
#define BDK_E_NOT_BANNED                 ((HRESULT)0x8004759EL)


//
// MessageId: BDK_E_BANNEDPERSON
//
// MessageText:
//
//  This account is banned.
//
#define BDK_E_BANNEDPERSON               ((HRESULT)0x800475BCL)


//
// MessageId: BDK_E_COUNTRY_CURRENCY_PI_MISMATCH
//
// MessageText:
//
//  Country/currency/payment instrument type mismatch.
//
#define BDK_E_COUNTRY_CURRENCY_PI_MISMATCH ((HRESULT)0x800475C1L)


//
// MessageId: BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE
//
// MessageText:
//
//  Invalid payment instrument type.
//
#define BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE ((HRESULT)0x800475C8L)


//
// MessageId: BDK_E_INVALID_CREDIT_CARD_TYPE
//
// MessageText:
//
//  Invalid credit card type.
//
#define BDK_E_INVALID_CREDIT_CARD_TYPE   ((HRESULT)0x800475CBL)


//
// MessageId: BDK_E_DECRYPTION_FAILURE
//
// MessageText:
//
//  Decryption failed. Verify that data is encrypted correctly.
//
#define BDK_E_DECRYPTION_FAILURE         ((HRESULT)0x800475D0L)


//
// MessageId: BDK_E_BANNED_PAYMENT_INSTRUMENT
//
// MessageText:
//
//  Payment instrument is banned.
//
#define BDK_E_BANNED_PAYMENT_INSTRUMENT  ((HRESULT)0x800475C6L)


//
// MessageId: BDK_E_INVALID_DD_ACCOUNT
//
// MessageText:
//
//  Direct debit account validation failed.
//
#define BDK_E_INVALID_DD_ACCOUNT         ((HRESULT)0x800475E4L)


//
// MessageId: BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24
//
// MessageText:
//
//  Concatenated direct debit account number exceeds 24 characters.
//
#define BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 ((HRESULT)0x800475E9L)


//
// MessageId: BDK_E_INVALID_CREDIT_CARD_NUMBER
//
// MessageText:
//
//  Invalid credit card number.
//
#define BDK_E_INVALID_CREDIT_CARD_NUMBER ((HRESULT)0x80047530L)


//
// MessageId: BDK_E_CREDIT_CARD_EXPIRED
//
// MessageText:
//
//  Credit card has already expired.
//
#define BDK_E_CREDIT_CARD_EXPIRED        ((HRESULT)0x80047531L)


//
// MessageId: BDK_E_AVS_FAILED
//
// MessageText:
//
//  Address verification failed.
//
#define BDK_E_AVS_FAILED                 ((HRESULT)0x8004760CL)


//
// MessageId: BDK_E_NO_AVS_RESULT
//
// MessageText:
//
//  Address verification through AVS did not provide a result.
//
#define BDK_E_NO_AVS_RESULT              ((HRESULT)0x8004760DL)


//
// MessageId: BDK_E_AUTHORIZATION_FAILED
//
// MessageText:
//
//  Payment Instrument authorization failed.
//
#define BDK_E_AUTHORIZATION_FAILED       ((HRESULT)0x80047611L)


//
// MessageId: BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED
//
// MessageText:
//
//  Unable to connect to payment provider.
//
#define BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED ((HRESULT)0x8004761BL)


//
// MessageId: BDK_E_DD_INVALID_COUNTRY
//
// MessageText:
//
//  Invalid country code.
//
#define BDK_E_DD_INVALID_COUNTRY         ((HRESULT)0x8004762FL)


//
// MessageId: BDK_E_DD_INVALID_ACCOUNT_FORMAT
//
// MessageText:
//
//  Invalid account format.
//
#define BDK_E_DD_INVALID_ACCOUNT_FORMAT  ((HRESULT)0x80047634L)


//
// MessageId: BDK_E_DD_INVALID_BANKCODE_FORMAT
//
// MessageText:
//
//  Invalid bank code format.
//
#define BDK_E_DD_INVALID_BANKCODE_FORMAT ((HRESULT)0x80047639L)


//
// MessageId: BDK_E_DD_INVALID_BRANCHCODE_FORMAT
//
// MessageText:
//
//  Invalid branch code format.
//
#define BDK_E_DD_INVALID_BRANCHCODE_FORMAT ((HRESULT)0x8004763EL)


//
// MessageId: BDK_E_DD_INVALID_CHECKDIGIT_FORMAT
//
// MessageText:
//
//  Invalid check digit format.
//
#define BDK_E_DD_INVALID_CHECKDIGIT_FORMAT ((HRESULT)0x80047643L)


//
// MessageId: BDK_E_DD_ACCOUNT_MISSING
//
// MessageText:
//
//  Account missing.
//
#define BDK_E_DD_ACCOUNT_MISSING         ((HRESULT)0x80047648L)


//
// MessageId: BDK_E_DD_BANKCODE_MISSING
//
// MessageText:
//
//  Bank code missing.
//
#define BDK_E_DD_BANKCODE_MISSING        ((HRESULT)0x8004764DL)


//
// MessageId: BDK_E_DD_BRANCHCODE_MISSING
//
// MessageText:
//
//  Branch code missing.
//
#define BDK_E_DD_BRANCHCODE_MISSING      ((HRESULT)0x80047652L)


//
// MessageId: BDK_E_DD_CHECKDIGIT_MISSING
//
// MessageText:
//
//  Check digit missing.
//
#define BDK_E_DD_CHECKDIGIT_MISSING      ((HRESULT)0x80047657L)


//
// MessageId: BDK_E_DD_ERROR_IN_FIELDS
//
// MessageText:
//
//  Some fields have errors.
//
#define BDK_E_DD_ERROR_IN_FIELDS         ((HRESULT)0x8004765CL)


//
// MessageId: BDK_E_DD_INVALID_ACCOUNT_VALUE
//
// MessageText:
//
//  Invalid account code.
//
#define BDK_E_DD_INVALID_ACCOUNT_VALUE   ((HRESULT)0x80047661L)


//
// MessageId: BDK_E_DD_INVALID_BANKCODE_VALUE
//
// MessageText:
//
//  Invalid bank code.
//
#define BDK_E_DD_INVALID_BANKCODE_VALUE  ((HRESULT)0x80047666L)


//
// MessageId: BDK_E_DD_INVALID_BRANCHCODE_VALUE
//
// MessageText:
//
//  Invalid branch code.
//
#define BDK_E_DD_INVALID_BRANCHCODE_VALUE ((HRESULT)0x8004766BL)


//
// MessageId: BDK_E_DD_INVALID_CHECKDIGIT_VALUE
//
// MessageText:
//
//  Invalid check digit.
//
#define BDK_E_DD_INVALID_CHECKDIGIT_VALUE ((HRESULT)0x80047670L)


//
// MessageId: BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME
//
// MessageText:
//
//  Account holder name not specified or it exceeds 35 characters.
//
#define BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME ((HRESULT)0x8004767AL)


//
// MessageId: BDK_E_DD_UNKNOWN_PROVIDER_FAILURE
//
// MessageText:
//
//  Soap call to provider failed.
//
#define BDK_E_DD_UNKNOWN_PROVIDER_FAILURE ((HRESULT)0x8004771FL)


//
// MessageId: BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT
//
// MessageText:
//
//  Payment provider connection timed out.
//
#define BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT ((HRESULT)0x8004767FL)


//
// MessageId: BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER
//
// MessageText:
//
//  Transaction declined by payment provider.
//
#define BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER ((HRESULT)0x80047680L)


//
// MessageId: BDK_E_INVALID_INITIATE_TRANSACTION_RESULT
//
// MessageText:
//
//  Payment provider error.
//
#define BDK_E_INVALID_INITIATE_TRANSACTION_RESULT ((HRESULT)0x80047681L)


//
// MessageId: BDK_E_INVALID_WHOLESALE_PARTNER
//
// MessageText:
//
//  The wholesale partner specified is invalid.
//
#define BDK_E_INVALID_WHOLESALE_PARTNER  ((HRESULT)0x80047684L)


//
// MessageId: BDK_E_PI_NOT_SUPPORTED
//
// MessageText:
//
//  PI Not Supported in this version
//
#define BDK_E_PI_NOT_SUPPORTED           ((HRESULT)0x80047693L)


//
// MessageId: BDK_E_UPS_NOT_UPDATED
//
// MessageText:
//
//  A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.
//
#define BDK_E_UPS_NOT_UPDATED            ((HRESULT)0x8004769DL)


//
// MessageId: BDK_E_DD_UNSUPPORTED
//
// MessageText:
//
//  This branch will not support Direct Debit transactions.
//
#define BDK_E_DD_UNSUPPORTED             ((HRESULT)0x800476A2L)


//
// MessageId: BDK_E_DD_MPF_NON_XML_RESPONSE
//
// MessageText:
//
//  Internal error, Return from MPF is not in XML format.
//
#define BDK_E_DD_MPF_NON_XML_RESPONSE    ((HRESULT)0x800476A7L)


//
// MessageId: BDK_E_DD_MPF_INCORRECT_XML_FORMAT
//
// MessageText:
//
//  Internal error, Return XML from MPF is not in correct format.
//
#define BDK_E_DD_MPF_INCORRECT_XML_FORMAT ((HRESULT)0x800476ACL)


//
// MessageId: BDK_E_DD_GC_NON_XML_RESPONSE
//
// MessageText:
//
//  Global Collect error, Return from Global Collect is not in XML format.
//
#define BDK_E_DD_GC_NON_XML_RESPONSE     ((HRESULT)0x800476B1L)


//
// MessageId: BDK_E_DD_GC_INCORRECT_XML_FORMAT
//
// MessageText:
//
//  Global Collect error, Return XML from Global Collect is not in correct format.
//
#define BDK_E_DD_GC_INCORRECT_XML_FORMAT ((HRESULT)0x800476B6L)


//
// MessageId: BDK_E_DD_GC_RETURNED_NOK_RESULT
//
// MessageText:
//
//  Global collect failed to process this request, returned NOT OK result.
//
#define BDK_E_DD_GC_RETURNED_NOK_RESULT  ((HRESULT)0x800476BBL)


//
// MessageId: BDK_E_DD_GC_CHECK_INCOMPLETE
//
// MessageText:
//
//  Direct Debit account Check performed by Global Collect is not complete for this account.
//
#define BDK_E_DD_GC_CHECK_INCOMPLETE     ((HRESULT)0x800476C0L)


//
// MessageId: BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED
//
// MessageText:
//
//  Global Collect error, Return XML from Global Collect is not in correct format. Error in CHECKSPERFORMED node of the return XML.
//
#define BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED ((HRESULT)0x800476C5L)


//
// MessageId: BDK_E_DD_GC_XML_INVALID_CHECK_RESULT
//
// MessageText:
//
//  Global Collect error, Return XML from Global Collect is not in correct format. Data within CHECKSPERFORMED nodes are invalid.
//
#define BDK_E_DD_GC_XML_INVALID_CHECK_RESULT ((HRESULT)0x800476CAL)


//
// MessageId: BDK_E_DD_GC_INVALID_RFBANKCODE
//
// MessageText:
//
//  Global collect returned non null Reformatted Bank Code though the input Bank code was blank.
//
#define BDK_E_DD_GC_INVALID_RFBANKCODE   ((HRESULT)0x800476CFL)


//
// MessageId: BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS
//
// MessageText:
//
//  Invalid payment instrument details.
//
#define BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS ((HRESULT)0x800476D9L)


//
// MessageId: BDK_E_INVALID_BAN_REASON_CODE
//
// MessageText:
//
//  Invalid ban reason code.
//
#define BDK_E_INVALID_BAN_REASON_CODE    ((HRESULT)0x800476DEL)


//
// MessageId: BDK_E_INVALID_CVM_CODE
//
// MessageText:
//
//  Invalid encrypted CVM code.
//
#define BDK_E_INVALID_CVM_CODE           ((HRESULT)0x800476E3L)


//
// MessageId: BDK_E_UNEXPECTED_CVM_RESPONSE_CODE
//
// MessageText:
//
//  Unexpected CVM response code.
//
#define BDK_E_UNEXPECTED_CVM_RESPONSE_CODE ((HRESULT)0x800476E8L)


//
// MessageId: BDK_E_CVM_FAILED
//
// MessageText:
//
//  CVM check failed.
//
#define BDK_E_CVM_FAILED                 ((HRESULT)0x800476EDL)


//
// MessageId: BDK_E_IMMEDIATE_SETTLEMENT_FAILURE
//
// MessageText:
//
//  Immediate settlement failed
//
#define BDK_E_IMMEDIATE_SETTLEMENT_FAILURE ((HRESULT)0x800476EEL)


//
// MessageId: BDK_E_FREQUENCY_CHECK_FAILED
//
// MessageText:
//
//  Frequency check failed.
//
#define BDK_E_FREQUENCY_CHECK_FAILED     ((HRESULT)0x800476F2L)


//
// MessageId: BDK_E_DD_INVALID_MERCHANT_INDEX
//
// MessageText:
//
//  Invalid merchant index.
//
#define BDK_E_DD_INVALID_MERCHANT_INDEX  ((HRESULT)0x800476F7L)


//
// MessageId: BDK_E_DD_DUPLICATE_MRN
//
// MessageText:
//
//  Duplicate merchant reference.
//
#define BDK_E_DD_DUPLICATE_MRN           ((HRESULT)0x800476FCL)


//
// MessageId: BDK_E_DD_UNKNOWN_VALIDATION_FAILURE
//
// MessageText:
//
//  Account validation failed.
//
#define BDK_E_DD_UNKNOWN_VALIDATION_FAILURE ((HRESULT)0x80047701L)


//
// MessageId: BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL
//
// MessageText:
//
//  Bank account type may not be specified for this country.
//
#define BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL ((HRESULT)0x80047706L)


//
// MessageId: BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL
//
// MessageText:
//
//  Bank account type is required for this country.
//
#define BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL ((HRESULT)0x8004770BL)


//
// MessageId: BDK_E_DD_RISK_DECLINE
//
// MessageText:
//
//  Risk check failed.
//
#define BDK_E_DD_RISK_DECLINE            ((HRESULT)0x80047715L)


//
// MessageId: BDK_E_UNABLE_TO_VALIDATE_TAX_ID
//
// MessageText:
//
//  Unable to validate the tax ID.
//
#define BDK_E_UNABLE_TO_VALIDATE_TAX_ID  ((HRESULT)0x80047724L)


//
// MessageId: BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED
//
// MessageText:
//
//  Number of updates allowed in a period has exceeded the maximum limit.
//
#define BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED ((HRESULT)0x80047729L)


//
// MessageId: BDK_E_EXTERNAL_VENDOR_ERROR
//
// MessageText:
//
//  External vendor error.
//
#define BDK_E_EXTERNAL_VENDOR_ERROR      ((HRESULT)0x8004772EL)


//
// MessageId: BDK_E_ALREADY_IN_SPECIFIED_STATE
//
// MessageText:
//
//  Object is already in the specified state.
//
#define BDK_E_ALREADY_IN_SPECIFIED_STATE ((HRESULT)0x80049C41L)


//
// MessageId: BDK_E_MISSING_SEARCH_CRITERIA
//
// MessageText:
//
//  Required search criteria field missing. Either a phone number or both first name and last name is required.
//
#define BDK_E_MISSING_SEARCH_CRITERIA    ((HRESULT)0x80049C44L)


//
// MessageId: BDK_E_REQUIRED_FIELD_MISSING
//
// MessageText:
//
//  Required field missing.
//
#define BDK_E_REQUIRED_FIELD_MISSING     ((HRESULT)0x80049C45L)


//
// MessageId: BDK_E_ACTIVE_SUBSCRIPTIONS
//
// MessageText:
//
//  The account has subscriptions.
//
#define BDK_E_ACTIVE_SUBSCRIPTIONS       ((HRESULT)0x80049C46L)


//
// MessageId: BDK_E_UNEXPECTED_FIELD
//
// MessageText:
//
//  Unexpected field
//
#define BDK_E_UNEXPECTED_FIELD           ((HRESULT)0x80049C47L)


//
// MessageId: BDK_E_INVALID_ACCOUNT_SOUCE
//
// MessageText:
//
//  Invalid account source.
//
#define BDK_E_INVALID_ACCOUNT_SOUCE      ((HRESULT)0x80049C4DL)


//
// MessageId: BDK_E_INVALID_CREATION_DATE
//
// MessageText:
//
//  Creation date/time cannot be later than current date/time.
//
#define BDK_E_INVALID_CREATION_DATE      ((HRESULT)0x80049C4EL)


//
// MessageId: BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS
//
// MessageText:
//
//  No more tax exemptions are allowed for this account.
//
#define BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS ((HRESULT)0x80049C55L)


//
// MessageId: BDK_E_GENERATE_NEXT_ID
//
// MessageText:
//
//  Generating next ID.
//
#define BDK_E_GENERATE_NEXT_ID           ((HRESULT)0x80049C59L)


//
// MessageId: BDK_E_INVALID_STATE_FOR_COUNTRY
//
// MessageText:
//
//  State invalid for the country.
//
#define BDK_E_INVALID_STATE_FOR_COUNTRY  ((HRESULT)0x80049C5FL)


//
// MessageId: BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH
//
// MessageText:
//
//  Country for address provided does not match existing country for account.
//
#define BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH ((HRESULT)0x80049C61L)


//
// MessageId: BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH
//
// MessageText:
//
//  The offering requested is not available in the country of this account.
//
#define BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH ((HRESULT)0x80049C62L)


//
// MessageId: BDK_E_INVALID_BILLABLE_ACCOUNT_ID
//
// MessageText:
//
//  Invalid account.
//
#define BDK_E_INVALID_BILLABLE_ACCOUNT_ID ((HRESULT)0x80049CC2L)


//
// MessageId: BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID
//
// MessageText:
//
//  Invalid account status.
//
#define BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID ((HRESULT)0x80049CC7L)


//
// MessageId: BDK_E_INVALID_PHONE_TYPE
//
// MessageText:
//
//  Invalid phone type.
//
#define BDK_E_INVALID_PHONE_TYPE         ((HRESULT)0x80049CD6L)


//
// MessageId: BDK_E_INVALID_OFFERING_ID
//
// MessageText:
//
//  Invalid offering.
//
#define BDK_E_INVALID_OFFERING_ID        ((HRESULT)0x80049CE5L)


//
// MessageId: BDK_E_INVALID_PURCHASE_INPUT_DATA
//
// MessageText:
//
//  The combination of data passed to PurchaseOffering is invalid for the scenario.
//
#define BDK_E_INVALID_PURCHASE_INPUT_DATA ((HRESULT)0x80049CE6L)


//
// MessageId: BDK_E_PUID_MISSING_ATTRIBUTE
//
// MessageText:
//
//  UPS profile is missing either FirstName, LastName, Country or PMN
//
#define BDK_E_PUID_MISSING_ATTRIBUTE     ((HRESULT)0x80049CE7L)


//
// MessageId: BDK_E_INVALID_COUNTRY_CODE
//
// MessageText:
//
//  Invalid country code.
//
#define BDK_E_INVALID_COUNTRY_CODE       ((HRESULT)0x80049CEAL)


//
// MessageId: BDK_E_INVALID_ADDRESS_ID
//
// MessageText:
//
//  Invalid address ID.
//
#define BDK_E_INVALID_ADDRESS_ID         ((HRESULT)0x80049CEFL)


//
// MessageId: BDK_E_INVALID_PAYMENT_METHOD_ID
//
// MessageText:
//
//  Invalid payment instrument ID.
//
#define BDK_E_INVALID_PAYMENT_METHOD_ID  ((HRESULT)0x80049CF9L)


//
// MessageId: BDK_E_PI_EXECEED_MAX_OWNER_SHIP
//
// MessageText:
//
//  Cannot exceed max ownership for the payment instrument.
//
#define BDK_E_PI_EXECEED_MAX_OWNER_SHIP  ((HRESULT)0x80049D03L)


//
// MessageId: BDK_E_SUBSCRIPTION_ALREADY_CANCELED
//
// MessageText:
//
//  Subscription is already cancelled.
//
#define BDK_E_SUBSCRIPTION_ALREADY_CANCELED ((HRESULT)0x80049D08L)


//
// MessageId: BDK_E_DELAYED_EXPIRE_ALREADY_PENDING
//
// MessageText:
//
//  A delayed expire request is already pending and should not be requested again.
//
#define BDK_E_DELAYED_EXPIRE_ALREADY_PENDING ((HRESULT)0x80049D0AL)


//
// MessageId: BDK_E_DELAYED_EXPIRE_NOT_PENDING
//
// MessageText:
//
//  A delayed expire is not pending and cannot be undone.
//
#define BDK_E_DELAYED_EXPIRE_NOT_PENDING ((HRESULT)0x80049D0BL)


//
// MessageId: BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED
//
// MessageText:
//
//  A delayed expire is not support unless the subscription is active with no term commits.
//
#define BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED ((HRESULT)0x80049D0CL)


//
// MessageId: BDK_E_INVALID_CANCEL_DATE
//
// MessageText:
//
//  The value specified for the cancel option/date should be DELAYED_EXPIRE, UNDO_DELAYED_EXPIRE, IMMEDIATE_EXPIRE or IMMEDIATE_CANCEL.
//
#define BDK_E_INVALID_CANCEL_DATE        ((HRESULT)0x80049D09L)


//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_ID
//
// MessageText:
//
//  Invalid subscription ID.
//
#define BDK_E_INVALID_SUBSCRIPTION_ID    ((HRESULT)0x80049D0DL)


//
// MessageId: BDK_E_INVALID_PERIOD_TO_PROCESS
//
// MessageText:
//
//  Invalid period.
//
#define BDK_E_INVALID_PERIOD_TO_PROCESS  ((HRESULT)0x80049D2BL)


//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_STATUS
//
// MessageText:
//
//  Invalid subscription status or invalid operation for the status.
//
#define BDK_E_INVALID_SUBSCRIPTION_STATUS ((HRESULT)0x80049D3AL)


//
// MessageId: BDK_E_NON_ACTIVE_ACCOUNT
//
// MessageText:
//
//  Account is inactive.
//
#define BDK_E_NON_ACTIVE_ACCOUNT         ((HRESULT)0x80049D94L)


//
// MessageId: BDK_E_VATID_DOESNOTHAVEEXPDATE
//
// MessageText:
//
//  VATIDs do not have an expiration date.
//
#define BDK_E_VATID_DOESNOTHAVEEXPDATE   ((HRESULT)0x80049D95L)


//
// MessageId: BDK_E_TAXID_EXPDATE
//
// MessageText:
//
//  Expiration date was not specified.
//
#define BDK_E_TAXID_EXPDATE              ((HRESULT)0x80049D96L)


//
// MessageId: BDK_E_INVALID_TAX_EXEMPT_TYPE
//
// MessageText:
//
//  Invalid tax exemption type.
//
#define BDK_E_INVALID_TAX_EXEMPT_TYPE    ((HRESULT)0x80049D97L)


//
// MessageId: BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID
//
// MessageText:
//
//  Invalid Tax Exempt Billable Account Id specified.
//
#define BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID ((HRESULT)0x80049D98L)


//
// MessageId: BDK_E_NO_ACTIVE_SUBSCRIPTION
//
// MessageText:
//
//  No active subscription for adding a service instance.
//
#define BDK_E_NO_ACTIVE_SUBSCRIPTION     ((HRESULT)0x80049D99L)


//
// MessageId: BDK_E_INVALID_SERVICE_INSTANCE
//
// MessageText:
//
//  Invalid service instance for adding a new user.
//
#define BDK_E_INVALID_SERVICE_INSTANCE   ((HRESULT)0x80049D9EL)


//
// MessageId: BDK_E_ADD_USER_TO_SERVICE_INSTANCE
//
// MessageText:
//
//  Failed to add a new user to a service instance.
//
#define BDK_E_ADD_USER_TO_SERVICE_INSTANCE ((HRESULT)0x80049DA3L)


//
// MessageId: BDK_E_INVALID_BILLABLEACCTSTATUS
//
// MessageText:
//
//  Status change not allowed.
//
#define BDK_E_INVALID_BILLABLEACCTSTATUS ((HRESULT)0x80049DA8L)


//
// MessageId: BDK_E_SERVICE_INSTANCES_NONE
//
// MessageText:
//
//  No service instances available for the billable account.
//
#define BDK_E_SERVICE_INSTANCES_NONE     ((HRESULT)0x80049DBCL)


//
// MessageId: BDK_E_ACCOUNT_CLOSED
//
// MessageText:
//
//  Account is already closed.
//
#define BDK_E_ACCOUNT_CLOSED             ((HRESULT)0x80049DD1L)


//
// MessageId: BDK_E_BILLINGPERIOD_PAST
//
// MessageText:
//
//  Period is already past.
//
#define BDK_E_BILLINGPERIOD_PAST         ((HRESULT)0x80049DD6L)


//
// MessageId: BDK_E_INVALID_ADJUSTMENTGUID
//
// MessageText:
//
//  Invalid adjustment GUID.
//
#define BDK_E_INVALID_ADJUSTMENTGUID     ((HRESULT)0x80049DD7L)


//
// MessageId: BDK_E_INVALID_ADJUSMENT_FOR_PERIOD
//
// MessageText:
//
//  Adjustment not applicable to the specified period.
//
#define BDK_E_INVALID_ADJUSMENT_FOR_PERIOD ((HRESULT)0x80049DD8L)


//
// MessageId: BDK_E_ADJUSTMENT_TOOBIG
//
// MessageText:
//
//  Adjustment amount is too large.
//
#define BDK_E_ADJUSTMENT_TOOBIG          ((HRESULT)0x80049DD9L)


//
// MessageId: BDK_E_ADJUSTMENT_TOOSMALL
//
// MessageText:
//
//  Adjustment amount is too small.
//
#define BDK_E_ADJUSTMENT_TOOSMALL        ((HRESULT)0x80049DDBL)


//
// MessageId: BDK_E_INVALID_LOCALE
//
// MessageText:
//
//  Invalid locale.
//
#define BDK_E_INVALID_LOCALE             ((HRESULT)0x80049DE5L)


//
// MessageId: BDK_E_INVALID_CUSTOMER_TYPE
//
// MessageText:
//
//  Invalid customer type.
//
#define BDK_E_INVALID_CUSTOMER_TYPE      ((HRESULT)0x80049DE6L)


//
// MessageId: BDK_E_INVALID_CURRENCY
//
// MessageText:
//
//  Invalid currency.
//
#define BDK_E_INVALID_CURRENCY           ((HRESULT)0x80049DE7L)


//
// MessageId: BDK_E_DATE_EXPIRED
//
// MessageText:
//
//  Date is already expired.
//
#define BDK_E_DATE_EXPIRED               ((HRESULT)0x80049DE8L)


//
// MessageId: BDK_E_GUID_EXISTS
//
// MessageText:
//
//  GUID already exists.
//
#define BDK_E_GUID_EXISTS                ((HRESULT)0x80049DEAL)


//
// MessageId: BDK_E_INVALID_VIOLATION_ID
//
// MessageText:
//
//  Invalid violation ID.
//
#define BDK_E_INVALID_VIOLATION_ID       ((HRESULT)0x80049DECL)


//
// MessageId: BDK_E_MISSING_VIOLATION_ID
//
// MessageText:
//
//  Violation ID is required.
//
#define BDK_E_MISSING_VIOLATION_ID       ((HRESULT)0x80049DEDL)


//
// MessageId: BDK_E_NEEDTODEPROVISION
//
// MessageText:
//
//  De-provision service instances before proceeding.
//
#define BDK_E_NEEDTODEPROVISION          ((HRESULT)0x80049DEFL)


//
// MessageId: BDK_E_PARTIALCONV_INITIATED
//
// MessageText:
//
//  Partial conversion is already initiated.
//
#define BDK_E_PARTIALCONV_INITIATED      ((HRESULT)0x80049DF0L)


//
// MessageId: BDK_E_CANNOT_UPDATE_CURRENCY
//
// MessageText:
//
//  The currency of the account cannot be updated.
//
#define BDK_E_CANNOT_UPDATE_CURRENCY     ((HRESULT)0x80049DF1L)


//
// MessageId: BDK_E_PARTIALCONV_EXPECTED
//
// MessageText:
//
//  Subscription is expected to be in the partial state.
//
#define BDK_E_PARTIALCONV_EXPECTED       ((HRESULT)0x80049DF2L)


//
// MessageId: BDK_E_INVALID_CATEGORY_NAME
//
// MessageText:
//
//  Invalid category. Valid category name has a size limit of 50 characters.
//
#define BDK_E_INVALID_CATEGORY_NAME      ((HRESULT)0x80049DF3L)


//
// MessageId: BDK_E_OFFERING_NOT_PURCHASEABLE
//
// MessageText:
//
//  Offering cannot be purchased.
//
#define BDK_E_OFFERING_NOT_PURCHASEABLE  ((HRESULT)0x80049DF5L)


//
// MessageId: BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH
//
// MessageText:
//
//  Offering currency does not match account currency.
//
#define BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH ((HRESULT)0x80049DF6L)


//
// MessageId: BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH
//
// MessageText:
//
//  Offering does not support payment instrument type.
//
#define BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH ((HRESULT)0x80049DF7L)


//
// MessageId: BDK_E_INVALID_DATE
//
// MessageText:
//
//  Invalid date.
//
#define BDK_E_INVALID_DATE               ((HRESULT)0x80049DF8L)


//
// MessageId: BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP
//
// MessageText:
//
//  Cannot exceed max ownership for the offering.
//
#define BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP ((HRESULT)0x80049DF9L)


//
// MessageId: BDK_E_INVALID_RESOURCE_ID
//
// MessageText:
//
//  Invalid resource ID.
//
#define BDK_E_INVALID_RESOURCE_ID        ((HRESULT)0x80049E02L)


//
// MessageId: BDK_E_UNIT_OF_MEASURE_MISMATCH
//
// MessageText:
//
//  Unit of measure reported in the usage event does not match the one in SPS.
//
#define BDK_E_UNIT_OF_MEASURE_MISMATCH   ((HRESULT)0x80049E03L)


//
// MessageId: BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE
//
// MessageText:
//
//  Event date is before the subscription purchase date.
//
#define BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE ((HRESULT)0x80049E04L)


//
// MessageId: BDK_E_INVALID_OFFERING_FOR_LOCALE
//
// MessageText:
//
//  Offering invalid for the locale.
//
#define BDK_E_INVALID_OFFERING_FOR_LOCALE ((HRESULT)0x80049E05L)


//
// MessageId: BDK_E_NOT_A_BASE_OFFERING
//
// MessageText:
//
//  Offering is not a base offering.
//
#define BDK_E_NOT_A_BASE_OFFERING        ((HRESULT)0x80049E06L)


//
// MessageId: BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH
//
// MessageText:
//
//  There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.
//
#define BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH ((HRESULT)0x80049E08L)


//
// MessageId: BDK_E_INVALID_OFFERING_FOR_COUNTRY
//
// MessageText:
//
//  Offering is invalid for Country.
//
#define BDK_E_INVALID_OFFERING_FOR_COUNTRY ((HRESULT)0x80049E09L)


//
// MessageId: BDK_E_MEG_CONFLICT
//
// MessageText:
//
//  The offering requested conflicts with an existing subscription on this account.
//
#define BDK_E_MEG_CONFLICT               ((HRESULT)0x80049E0AL)


//
// MessageId: BDK_E_INVALID_ACCOUNT_STATUS
//
// MessageText:
//
//  Account state does not allow this operation.
//
#define BDK_E_INVALID_ACCOUNT_STATUS     ((HRESULT)0x80049E16L)


//
// MessageId: BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST
//
// MessageText:
//
//  Payment instrument has active subscriptions.
//
#define BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST ((HRESULT)0x80049E1BL)


//
// MessageId: BDK_E_EXISTING_BILLING_ACTIVITY
//
// MessageText:
//
//  The account has billing charges.
//
#define BDK_E_EXISTING_BILLING_ACTIVITY  ((HRESULT)0x80049E1CL)


//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION
//
// MessageText:
//
//  Subscription is in an invalid state for this operation.
//
#define BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION ((HRESULT)0x80049E20L)


//
// MessageId: BDK_E_PRIMARY_PHONE_REQUIRED
//
// MessageText:
//
//  Primary phone required for payment instruments.
//
#define BDK_E_PRIMARY_PHONE_REQUIRED     ((HRESULT)0x80049E25L)


//
// MessageId: BDK_E_EMAIL_REQUIRED
//
// MessageText:
//
//  Account requires an e-mail address for this operation.
//
#define BDK_E_EMAIL_REQUIRED             ((HRESULT)0x80049E2AL)


//
// MessageId: BDK_E_ACCOUNT_NOT_CLOSED
//
// MessageText:
//
//  To perform this operation, the account should be closed.
//
#define BDK_E_ACCOUNT_NOT_CLOSED         ((HRESULT)0x80049E2BL)


//
// MessageId: BDK_E_INVALID_VIOLATION
//
// MessageText:
//
//  Invalid violation ID.
//
#define BDK_E_INVALID_VIOLATION          ((HRESULT)0x80049E13L)


//
// MessageId: BDK_E_SUBSCRIPTION_IS_CANCELLED
//
// MessageText:
//
//  Subscription is cancelled and cannot change status.
//
#define BDK_E_SUBSCRIPTION_IS_CANCELLED  ((HRESULT)0x80049E14L)


//
// MessageId: BDK_E_NO_VIOLATION
//
// MessageText:
//
//  Subscription has no violations.
//
#define BDK_E_NO_VIOLATION               ((HRESULT)0x80049E15L)


//
// MessageId: BDK_E_EXISTS_VIOLATION
//
// MessageText:
//
//  Subscription has violations.
//
#define BDK_E_EXISTS_VIOLATION           ((HRESULT)0x80049E17L)


//
// MessageId: BDK_E_INVALID_SERVICE_COMPONENT_ID
//
// MessageText:
//
//  Invalid Service Component Id was passed.
//
#define BDK_E_INVALID_SERVICE_COMPONENT_ID ((HRESULT)0x80049E32L)


//
// MessageId: BDK_E_END_DATE_IN_THE_PAST
//
// MessageText:
//
//  End date is already past.
//
#define BDK_E_END_DATE_IN_THE_PAST       ((HRESULT)0x80049E33L)


//
// MessageId: BDK_E_END_DATE_BEYOND_MAX
//
// MessageText:
//
//  End date passed in is later than the latest allowable end date for this subscription.
//
#define BDK_E_END_DATE_BEYOND_MAX        ((HRESULT)0x80049E34L)


//
// MessageId: BDK_E_VIOLATION_ALREADY_SET
//
// MessageText:
//
//  Violation is already set.
//
#define BDK_E_VIOLATION_ALREADY_SET      ((HRESULT)0x80049E3EL)


//
// MessageId: BDK_E_NO_VIOLATION_SET
//
// MessageText:
//
//  Violation ID not set.
//
#define BDK_E_NO_VIOLATION_SET           ((HRESULT)0x80049E43L)


//
// MessageId: BDK_E_INVALID_CONVERSION
//
// MessageText:
//
//  Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew). 
//
#define BDK_E_INVALID_CONVERSION         ((HRESULT)0x80049E4DL)


//
// MessageId: BDK_E_SUBS_NOT_INTERMEDIATE
//
// MessageText:
//
//  Subscription is not in the partial state.
//
#define BDK_E_SUBS_NOT_INTERMEDIATE      ((HRESULT)0x80049E4EL)


//
// MessageId: BDK_E_OFFERING_NOT_PUBLISHED
//
// MessageText:
//
//  Offering is not published.
//
#define BDK_E_OFFERING_NOT_PUBLISHED     ((HRESULT)0x80049E52L)


//
// MessageId: BDK_E_CONVERSION_NEEDTODEPROVISION
//
// MessageText:
//
//  Service instances must be de-provisioned to proceed.
//
#define BDK_E_CONVERSION_NEEDTODEPROVISION ((HRESULT)0x80049E53L)


//
// MessageId: BDK_E_INVALID_MANDATE_STATUS
//
// MessageText:
//
//  Invalid mandate status.
//
#define BDK_E_INVALID_MANDATE_STATUS     ((HRESULT)0x80049E57L)


//
// MessageId: BDK_E_PI_ALREADY_GOOD
//
// MessageText:
//
//  Payment instrument status is already GOOD.
//
#define BDK_E_PI_ALREADY_GOOD            ((HRESULT)0x80049E61L)


//
// MessageId: BDK_E_PI_ALREADY_DECLINED
//
// MessageText:
//
//  Payment instrument status is already DECLINED.
//
#define BDK_E_PI_ALREADY_DECLINED        ((HRESULT)0x80049E66L)


//
// MessageId: BDK_E_PI_IS_DISABLED
//
// MessageText:
//
//  Payment instrument status is DISABLED and cannot be changed.
//
#define BDK_E_PI_IS_DISABLED             ((HRESULT)0x80049E6BL)


//
// MessageId: BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED
//
// MessageText:
//
//  SAP Number is required for Invoice PI.
//
#define BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED ((HRESULT)0x80049E70L)


//
// MessageId: BDK_E_INVALID_INVOICE_INFO_XML
//
// MessageText:
//
//  Invoice XML was invalid.
//
#define BDK_E_INVALID_INVOICE_INFO_XML   ((HRESULT)0x80049E71L)


//
// MessageId: BDK_E_MAX_PI_PER_ACCOUNT_REACHED
//
// MessageText:
//
//  Max Limit for this PI Type within account reached.
//
#define BDK_E_MAX_PI_PER_ACCOUNT_REACHED ((HRESULT)0x8004AD81L)


//
// MessageId: BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH
//
// MessageText:
//
//  PI country does not match Account country.
//
#define BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH ((HRESULT)0x80049E77L)


//
// MessageId: BDK_E_ERROR_OCCURRED_TRY_LATER
//
// MessageText:
//
//  An error occured. Try again later.
//
#define BDK_E_ERROR_OCCURRED_TRY_LATER   ((HRESULT)0x80049E78L)


//
// MessageId: BDK_E_ERROR_OCCURRED
//
// MessageText:
//
//  An error occured.
//
#define BDK_E_ERROR_OCCURRED             ((HRESULT)0x80049E79L)


//
// MessageId: BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS
//
// MessageText:
//
//  Payment instrument exists or the payment instrument status is invalid or does not allow the operation.
//
#define BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS ((HRESULT)0x80049E7FL)


//
// MessageId: BDK_E_INVALID_OFFERING_GUID
//
// MessageText:
//
//  Invalid offering GUID.
//
#define BDK_E_INVALID_OFFERING_GUID      ((HRESULT)0x80049E84L)


//
// MessageId: BDK_E_OFFERING_REQUIRES_PI
//
// MessageText:
//
//  Offering requires a payment instrument.
//
#define BDK_E_OFFERING_REQUIRES_PI       ((HRESULT)0x80049E89L)


//
// MessageId: BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST
//
// MessageText:
//
//  Offering cannot be purchased because it has delayed provisioning components.
//
#define BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST ((HRESULT)0x80049E93L)


//
// MessageId: BDK_E_INVALID_AMOUNT_FOR_CURRENCY
//
// MessageText:
//
//  Invalid currency format.
//
#define BDK_E_INVALID_AMOUNT_FOR_CURRENCY ((HRESULT)0x80049E99L)


//
// MessageId: BDK_E_INVALID_EMAIL_ADDRESS
//
// MessageText:
//
//  Invalid e-mail address.
//
#define BDK_E_INVALID_EMAIL_ADDRESS      ((HRESULT)0x80049EA2L)


//
// MessageId: BDK_E_INVALID_TAX_EXEMPT_STATUS
//
// MessageText:
//
//  Invalid tax exemption status.
//
#define BDK_E_INVALID_TAX_EXEMPT_STATUS  ((HRESULT)0x80049EACL)


//
// MessageId: BDK_E_NO_VALID_TAX_EXEMPTION
//
// MessageText:
//
//  No valid tax exemption certificates exist for the account.
//
#define BDK_E_NO_VALID_TAX_EXEMPTION     ((HRESULT)0x80049EADL)


//
// MessageId: BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE
//
// MessageText:
//
//  Invalid tax exemption status change.
//
#define BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE ((HRESULT)0x80049EB1L)


//
// MessageId: BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS
//
// MessageText:
//
//  The status of the old payment instrument does not allow this operation.
//
#define BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS ((HRESULT)0x80049EB6L)


//
// MessageId: BDK_E_INVALID_START_PERIOD
//
// MessageText:
//
//  The specified start period is invalid.
//
#define BDK_E_INVALID_START_PERIOD       ((HRESULT)0x80049EC4L)


//
// MessageId: BDK_E_INVALID_END_PERIOD
//
// MessageText:
//
//  The specified end period is invalid.
//
#define BDK_E_INVALID_END_PERIOD         ((HRESULT)0x80049EC5L)


//
// MessageId: BDK_E_INVALID_DETAILEDLEVEL
//
// MessageText:
//
//  The specified Detailed level is invalid.
//
#define BDK_E_INVALID_DETAILEDLEVEL      ((HRESULT)0x80049EC6L)


//
// MessageId: BDK_E_EXCEED_DATERANGE_LIMIT
//
// MessageText:
//
//  Difference between BeginDate and EndDate is more than 6 months
//
#define BDK_E_EXCEED_DATERANGE_LIMIT     ((HRESULT)0x80049EC7L)


//
// MessageId: BDK_E_WRONG_DATERANGE
//
// MessageText:
//
//  Begin Date can never be greater than EndDate
//
#define BDK_E_WRONG_DATERANGE            ((HRESULT)0x80049EC8L)


//
// MessageId: BDK_E_INVALID_BEGIN_DATE
//
// MessageText:
//
//  Begin date is not valid
//
#define BDK_E_INVALID_BEGIN_DATE         ((HRESULT)0x80049EC9L)


//
// MessageId: BDK_E_INVALID_END_DATE
//
// MessageText:
//
//  End date is not valid
//
#define BDK_E_INVALID_END_DATE           ((HRESULT)0x80049ECBL)


//
// MessageId: BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE
//
// MessageText:
//
//  End date is greater than the current date
//
#define BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE ((HRESULT)0x80049ECCL)


//
// MessageId: BDK_E_COMPUTE_ONLY
//
// MessageText:
//
//  SPS is in compute-only mode.
//
#define BDK_E_COMPUTE_ONLY               ((HRESULT)0x80049ECAL)


//
// MessageId: BDK_E_MISSED_PROCESSING_PERIOD
//
// MessageText:
//
//  Detected that month(s) were missed in periodic processing.
//
#define BDK_E_MISSED_PROCESSING_PERIOD   ((HRESULT)0x80049F33L)


//
// MessageId: BDK_E_SUBSCRIPTION_NOT_EXPIRED
//
// MessageText:
//
//  Subscription is not expired.
//
#define BDK_E_SUBSCRIPTION_NOT_EXPIRED   ((HRESULT)0x80049F43L)


//
// MessageId: BDK_E_TOOLATE_REINSTATE
//
// MessageText:
//
//  Subscription can no longer be reinstated.
//
#define BDK_E_TOOLATE_REINSTATE          ((HRESULT)0x80049F44L)


//
// MessageId: BDK_E_EXTRA_REFERRAL_DATA
//
// MessageText:
//
//  Only a single Referral node may be passed in to this API.
//
#define BDK_E_EXTRA_REFERRAL_DATA        ((HRESULT)0x80049F47L)


//
// MessageId: BDK_E_NO_REFERRAL_UPDATES_ALLOWED
//
// MessageText:
//
//  bstrReferralIDSetXML parameter must be left empty for this API.
//
#define BDK_E_NO_REFERRAL_UPDATES_ALLOWED ((HRESULT)0x80049F4CL)


//
// MessageId: BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS
//
// MessageText:
//
//  Cannot schedule a new renewal because there exists already a free renewal on the subscription.
//
#define BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS ((HRESULT)0x80049F4DL)


//
// MessageId: BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS
//
// MessageText:
//
//  Cannot convert a deal with multiple components with delayed provisioning.
//
#define BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS ((HRESULT)0x80049F4EL)


//
// MessageId: BDK_E_INVALID_COBRAND
//
// MessageText:
//
//  The specified cobrand is invalid.
//
#define BDK_E_INVALID_COBRAND            ((HRESULT)0x80049F56L)


//
// MessageId: BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION
//
// MessageText:
//
//  This operation is not valid for wholesale subscriptions.
//
#define BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION ((HRESULT)0x80049F65L)


//
// MessageId: BDK_E_HCI_NOT_VALID
//
// MessageText:
//
//  HCI not valid for Account Id.
//
#define BDK_E_HCI_NOT_VALID              ((HRESULT)0x80049F83L)


//
// MessageId: BDK_E_CANT_STOP_TAIWAN_TAXINV
//
// MessageText:
//
//  Taiwan users cannot opt out of hard copy tax invoices.
//
#define BDK_E_CANT_STOP_TAIWAN_TAXINV    ((HRESULT)0x80049F85L)


//
// MessageId: BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS
//
// MessageText:
//
//  Adjusting a resource balance is not allowed for subscriptions that are not active.
//
#define BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS ((HRESULT)0x80049FB5L)


//
// MessageId: BDK_E_INVALID_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token specified was invalid.
//
#define BDK_E_INVALID_TOKEN_TYPE         ((HRESULT)0x8004A00AL)


//
// MessageId: BDK_E_TOKEN_NOT_VALID_FOR_OFFERING
//
// MessageText:
//
//  The token Id specified is not valid for the given offering.
//
#define BDK_E_TOKEN_NOT_VALID_FOR_OFFERING ((HRESULT)0x8004A04BL)


//
// MessageId: BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT
//
// MessageText:
//
//  Deal Token mapping currently not present in the system to be marked as invalid.
//
#define BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT ((HRESULT)0x8004A04CL)


//
// MessageId: BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED
//
// MessageText:
//
//  Maximum consumption count per user reached.
//
#define BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED ((HRESULT)0x8004A00BL)


//
// MessageId: BDK_E_INSERTING_USER_TOKEN_HASH
//
// MessageText:
//
//  Error in inserting a new row in table user_token_hash.
//
#define BDK_E_INSERTING_USER_TOKEN_HASH  ((HRESULT)0x8004A00CL)


//
// MessageId: BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED
//
// MessageText:
//
//  A token Id and a payment instrument Id cannot both be specified.
//
#define BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED ((HRESULT)0x8004A06EL)


//
// MessageId: BDK_E_TOKEN_CLASS_INVALID
//
// MessageText:
//
//  The token class is invalid or does not exist.
//
#define BDK_E_TOKEN_CLASS_INVALID        ((HRESULT)0x8004A073L)


//
// MessageId: BDK_E_INPUT_FILTER_XML_MISSING
//
// MessageText:
//
//  The Input TokenClass Restriction Info Filter is Missing.
//
#define BDK_E_INPUT_FILTER_XML_MISSING   ((HRESULT)0x8004A074L)


//
// MessageId: BDK_E_TOKEN_CLASS_NOT_FOUND
//
// MessageText:
//
//  Unable to find the token mapping to the specified token class.
//
#define BDK_E_TOKEN_CLASS_NOT_FOUND      ((HRESULT)0x800413ABL)


//
// MessageId: BDK_E_INVALID_INPUT_FILTER_XML
//
// MessageText:
//
//  Invalid TokenClass Restriction Info Filter.
//
#define BDK_E_INVALID_INPUT_FILTER_XML   ((HRESULT)0x8004A075L)


//
// MessageId: BDK_E_PI_CANNOT_BE_SPECIFIED
//
// MessageText:
//
//  A payment instrument cannot be specified.
//
#define BDK_E_PI_CANNOT_BE_SPECIFIED     ((HRESULT)0x8004A078L)


//
// MessageId: BDK_E_SUBSCRIPTION_NOT_PREPAID
//
// MessageText:
//
//  The subscription specified is not a PrePaid subscription.
//
#define BDK_E_SUBSCRIPTION_NOT_PREPAID   ((HRESULT)0x8004A07DL)


//
// MessageId: BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO
//
// MessageText:
//
//  The total number of extended days cannot be less than zero.
//
#define BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO ((HRESULT)0x8004A082L)


//
// MessageId: BDK_E_INVALID_NUMBER_OF_DAYS
//
// MessageText:
//
//  The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.
//
#define BDK_E_INVALID_NUMBER_OF_DAYS     ((HRESULT)0x8004A087L)


//
// MessageId: BDK_E_INVALID_NUMBER_OF_MONTHS
//
// MessageText:
//
//  The number of months specified is invalid, possibly because it is negative.
//
#define BDK_E_INVALID_NUMBER_OF_MONTHS   ((HRESULT)0x8004A088L)


//
// MessageId: BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX
//
// MessageText:
//
//  The total number of extended days is greater than the maximum allowed for the current subscription.
//
#define BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX ((HRESULT)0x8004A08CL)


//
// MessageId: BDK_E_PREPAID_TOKEN_IS_REQUIRED
//
// MessageText:
//
//  The deal specified requires a valid Prepaid Token Id to be specified.
//
#define BDK_E_PREPAID_TOKEN_IS_REQUIRED  ((HRESULT)0x8004A096L)


//
// MessageId: BDK_E_TERM_COMMIT_EXISTS
//
// MessageText:
//
//  There are remaining cycles on the current term commit.
//
#define BDK_E_TERM_COMMIT_EXISTS         ((HRESULT)0x8004A09BL)


//
// MessageId: BDK_E_TOKEN_NOT_APPLICABLE
//
// MessageText:
//
//  The specified token cannot be used for the current operation.
//
#define BDK_E_TOKEN_NOT_APPLICABLE       ((HRESULT)0x8004A0A0L)


//
// MessageId: BDK_E_TOKEN_RENEWAL_PRESENT
//
// MessageText:
//
//  Renewal cannot be scheduled if there is already a token based renewal present.
//
#define BDK_E_TOKEN_RENEWAL_PRESENT      ((HRESULT)0x8004A0A5L)


//
// MessageId: BDK_E_EXCEEDS_MAXIMUM_DURATION
//
// MessageText:
//
//  Error subscription duration exceeds max duration.
//
#define BDK_E_EXCEEDS_MAXIMUM_DURATION   ((HRESULT)0x8004A0FAL)


//
// MessageId: BDK_E_CONVERSION_CREDITS_NOT_ENABLED
//
// MessageText:
//
//  Error conversion credits were applied but the offer does not support conversion credits.
//
#define BDK_E_CONVERSION_CREDITS_NOT_ENABLED ((HRESULT)0x8004A104L)


//
// MessageId: BDK_E_INVALID_USERROLE_FOR_ADDPI
//
// MessageText:
//
//  Only BillableAccountAdmin can add the PI.
//
#define BDK_E_INVALID_USERROLE_FOR_ADDPI ((HRESULT)0x8004A10EL)


//
// MessageId: BDK_E_BLACKLIST_ACTION_NOT_PERFORMED
//
// MessageText:
//
//  BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.
//
#define BDK_E_BLACKLIST_ACTION_NOT_PERFORMED ((HRESULT)0x8004A0AAL)


//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_ACTION
//
// MessageText:
//
//  BlacklistToken was called with invalid bstrSubscriptionAction parameter.
//
#define BDK_E_INVALID_SUBSCRIPTION_ACTION ((HRESULT)0x8004A0AFL)


//
// MessageId: BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND
//
// MessageText:
//
//  Invalid distribution channel specified for token class part number.
//
#define BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND ((HRESULT)0x8004A0B9L)


//
// MessageId: BDK_E_INVALID_LEN_PART_NUMBER
//
// MessageText:
//
//  Invalid length for token class part number.
//
#define BDK_E_INVALID_LEN_PART_NUMBER    ((HRESULT)0x8004A0BEL)


//
// MessageId: BDK_E_INVALID_LEN_SAP_CUST_NAME
//
// MessageText:
//
//  nvalid length for SAP customer name.
//
#define BDK_E_INVALID_LEN_SAP_CUST_NAME  ((HRESULT)0x8004A0C3L)


//
// MessageId: BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME
//
// MessageText:
//
//  Invalid length for Support Vendor name.
//
#define BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME ((HRESULT)0x8004A0C8L)


//
// MessageId: BDK_E_INSERING_TOKEN_CLASS_PARTNER
//
// MessageText:
//
//  Failed while inserting in partner_token_class table.
//
#define BDK_E_INSERING_TOKEN_CLASS_PARTNER ((HRESULT)0x8004A0CDL)


//
// MessageId: BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS
//
// MessageText:
//
//  Token Part Number is currently associated with other token class please remove the association from the other token class and try again.
//
#define BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS ((HRESULT)0x8004A0D2L)


//
// MessageId: BDK_E_TOKEN_ALREADY_DELIVERED
//
// MessageText:
//
//  A token is being delivered to the same service instance at this moment. Please retry.
//
#define BDK_E_TOKEN_ALREADY_DELIVERED    ((HRESULT)0x8004148DL)


//
// MessageId: BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID
//
// MessageText:
//
//  A Token passed in does not have an associated Distribution batch.
//
#define BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID ((HRESULT)0x80049DDAL)


//
// MessageId: BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE
//
// MessageText:
//
//  A Distribution Batch associated with the passed in Token is in inactive state.
//
#define BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE ((HRESULT)0x80049DDFL)


//
// MessageId: BDK_E_DISTRIBUTION_PROGRAM_INACTIVE
//
// MessageText:
//
//  A Distribution Program is in inactive state.
//
#define BDK_E_DISTRIBUTION_PROGRAM_INACTIVE ((HRESULT)0x80049DE9L)


//
// MessageId: BDK_E_INSERTING_RECONCILE_HISTORY
//
// MessageText:
//
//  Failed while inserting in reconcile_history table.
//
#define BDK_E_INSERTING_RECONCILE_HISTORY ((HRESULT)0x800414BEL)


//
// MessageId: BDK_E_TOKEN_ALREADY_ISSUED
//
// MessageText:
//
//  Specified Token is already issued.
//
#define BDK_E_TOKEN_ALREADY_ISSUED       ((HRESULT)0x800414C3L)


//
// MessageId: BDK_E_TOKEN_ALREADY_UNISSUED
//
// MessageText:
//
//  Specified Token is already unissued, can not unissue the same token again.
//
#define BDK_E_TOKEN_ALREADY_UNISSUED     ((HRESULT)0x800414C8L)


//
// MessageId: BDK_E_TOKEN_ISSUE_UPDATE
//
// MessageText:
//
//  Failed to update the token issue status in token_instance table.
//
#define BDK_E_TOKEN_ISSUE_UPDATE         ((HRESULT)0x800414CDL)


//
// MessageId: BDK_E_INVALID_COMBINATION
//
// MessageText:
//
//  The input parameter combination does not match the system.
//
#define BDK_E_INVALID_COMBINATION        ((HRESULT)0x800414D2L)


//
// MessageId: BDK_E_INVALID_REPLACEMENT_REASON_CODE
//
// MessageText:
//
//  Invalid Replacement Reason code specified.
//
#define BDK_E_INVALID_REPLACEMENT_REASON_CODE ((HRESULT)0x800414D7L)


//
// MessageId: BDK_E_MAX_REPLACEMENT_REACHED
//
// MessageText:
//
//  The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value.
//
#define BDK_E_MAX_REPLACEMENT_REACHED    ((HRESULT)0x800414DCL)


//
// MessageId: BDK_E_TOKEN_REPLACEMENT_FAILED
//
// MessageText:
//
//  Token Replacement failed due to unknown error.
//
#define BDK_E_TOKEN_REPLACEMENT_FAILED   ((HRESULT)0x800414E1L)


//
// MessageId: BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE
//
// MessageText:
//
//  Failed to update Token Distribution status.
//
#define BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE ((HRESULT)0x800414E6L)


//
// MessageId: BDK_E_SIGNATURE_TOKEN_MISMATCH
//
// MessageText:
//
//  Signature does not belong to specified Token.
//
#define BDK_E_SIGNATURE_TOKEN_MISMATCH   ((HRESULT)0x800414EBL)


//
// MessageId: BDK_E_INVALID_STATUS_NAME
//
// MessageText:
//
//  Invalid Token Staus Name specified.
//
#define BDK_E_INVALID_STATUS_NAME        ((HRESULT)0x800414F0L)


//
// MessageId: BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS
//
// MessageText:
//
//  Invalid distribution status to issue token.
//
#define BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS ((HRESULT)0x800414F5L)


//
// MessageId: BDK_E_ALREADY_REPLACED_TOKEN
//
// MessageText:
//
//  Specified token is replaced token, can not provide replacement for Replaced Token.
//
#define BDK_E_ALREADY_REPLACED_TOKEN     ((HRESULT)0x800414FAL)


//
// MessageId: BDK_E_TOKEN_ACTION_ACCESS_DENIED
//
// MessageText:
//
//  Invalid Partner specified or the partner does not have permission to take action on specified token.
//
#define BDK_E_TOKEN_ACTION_ACCESS_DENIED ((HRESULT)0x800414FFL)


//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR
//
// MessageText:
//
//  Value for returnStatementSet parameter must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR ((HRESULT)0x8004A604L)


//
// MessageId: BDK_E_BAD_BEGIN_BILLING_PERIOD
//
// MessageText:
//
//  The begin billing period is not valid for this account.
//
#define BDK_E_BAD_BEGIN_BILLING_PERIOD   ((HRESULT)0x8004A609L)


//
// MessageId: BDK_E_INVALID_END_BILLING_PERIOD
//
// MessageText:
//
//  The end billing period is not valid for this account.
//
#define BDK_E_INVALID_END_BILLING_PERIOD ((HRESULT)0x8004A60EL)


//
// MessageId: BDK_E_BILLING_PERIOD_NEGATIVE
//
// MessageText:
//
//  The billing period value cannot be negative.
//
#define BDK_E_BILLING_PERIOD_NEGATIVE    ((HRESULT)0x8004A613L)


//
// MessageId: BDK_E_BAD_START_END_BILLING_PERIOD
//
// MessageText:
//
//  The end period must be greater than start period.
//
#define BDK_E_BAD_START_END_BILLING_PERIOD ((HRESULT)0x8004A618L)


//
// MessageId: BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE
//
// MessageText:
//
//  The account history date cannot be greater than the current date.
//
#define BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE ((HRESULT)0x8004A61DL)


//
// MessageId: BDK_E_NO_NON_NULL_PARAMS
//
// MessageText:
//
//  Cannot pass null for all parameters.
//
#define BDK_E_NO_NON_NULL_PARAMS         ((HRESULT)0x8004A622L)


//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD
//
// MessageText:
//
//  The billing period value must be of the format YYYYMM (Y representing the year and M representing month).
//
#define BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD ((HRESULT)0x8004A627L)


//
// MessageId: BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION
//
// MessageText:
//
//  The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration).
//
#define BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION ((HRESULT)0x8004A62CL)


//
// MessageId: BDK_E_MISMATCH_SUB_ID_OFFER_GUID
//
// MessageText:
//
//  The offering guid passed in does not match offering guid on subscription.
//
#define BDK_E_MISMATCH_SUB_ID_OFFER_GUID ((HRESULT)0x8004A6FEL)


//
// MessageId: BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE
//
// MessageText:
//
//  The event time stamp is too far in future.
//
#define BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE ((HRESULT)0x8004A70DL)


//
// MessageId: BDK_E_INVALID_POLICY_ID
//
// MessageText:
//
//  The policy GuidID/Version combination supplied does not exist.
//
#define BDK_E_INVALID_POLICY_ID          ((HRESULT)0x80049F88L)


//
// MessageId: BDK_E_OFFERING_PI_COUNTRY_MISMATCH
//
// MessageText:
//
//  The offering specified does not support the country of payment instrument being used.
//
#define BDK_E_OFFERING_PI_COUNTRY_MISMATCH ((HRESULT)0x80049F89L)


//
// MessageId: BDK_E_INSERT_AGREEMENT_SIGNATURE
//
// MessageText:
//
//  Error inserting into table agreement_signature.
//
#define BDK_E_INSERT_AGREEMENT_SIGNATURE ((HRESULT)0x80049F8DL)


//
// MessageId: BDK_E_AGREEMENT_ALREADY_SIGNED
//
// MessageText:
//
//  Agreement for this subscription has already been signed by this user at a different time.
//
#define BDK_E_AGREEMENT_ALREADY_SIGNED   ((HRESULT)0x80049F92L)


//
// MessageId: BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY
//
// MessageText:
//
//  The specified policy has not been localized in the specified locale.
//
#define BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY ((HRESULT)0x80049F9CL)


//
// MessageId: BDK_E_POLICY_DEAL_VERSION_MISMATCH
//
// MessageText:
//
//  The policy specified is valid but the version is incorrect.
//
#define BDK_E_POLICY_DEAL_VERSION_MISMATCH ((HRESULT)0x80049F9EL)


//
// MessageId: BDK_E_POLICY_DEAL_COUNTRY_MISMATCH
//
// MessageText:
//
//  The policy specified exists but is not valid on the deal/country combination of the supplied subscription.
//
#define BDK_E_POLICY_DEAL_COUNTRY_MISMATCH ((HRESULT)0x80049FA1L)


//
// MessageId: BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE
//
// MessageText:
//
//  The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed.
//
#define BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE ((HRESULT)0x8004A6D1L)


//
// MessageId: BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW
//
// MessageText:
//
//  A payment instrument cannot specified when the conversion mode is RENEW.
//
#define BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW ((HRESULT)0x8004A6D6L)


//
// MessageId: BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING
//
// MessageText:
//
//  Renewing from a perpetual offering is not allowed.
//
#define BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING ((HRESULT)0x8004A6E5L)


//
// MessageId: BDK_E_INVALID_TECERTIFICATENUMBER
//
// MessageText:
//
//  Tax Exempt Certificate Number is invalid.
//
#define BDK_E_INVALID_TECERTIFICATENUMBER ((HRESULT)0x8004A6EAL)


//
// MessageId: BDK_E_NO_WHOLESALE_TO_WHOLESALE
//
// MessageText:
//
//  Conversions between wholesale offers are not allowed.
//
#define BDK_E_NO_WHOLESALE_TO_WHOLESALE  ((HRESULT)0x8004A708L)


//
// MessageId: BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS
//
// MessageText:
//
//  The status of the new payment instrument specified does not allow this operation.
//
#define BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS ((HRESULT)0x8004A712L)


//
// MessageId: BDK_E_INVALID_RENEWAL
//
// MessageText:
//
//  Renewal does not exist.
//
#define BDK_E_INVALID_RENEWAL            ((HRESULT)0x8004A71CL)


//
// MessageId: BDK_E_ERROR_PHONE_STRING_TOOLONG
//
// MessageText:
//
//  The length of phone number is greater than expected.
//
#define BDK_E_ERROR_PHONE_STRING_TOOLONG ((HRESULT)0x8004A721L)


//
// MessageId: BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED
//
// MessageText:
//
//  The calling partner does not have access to the token class.
//
#define BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED ((HRESULT)0x8004A72BL)


//
// MessageId: BDK_E_LAST_ADMIN_ROLE
//
// MessageText:
//
//  Last administrator role on the account cannot be removed.
//
#define BDK_E_LAST_ADMIN_ROLE            ((HRESULT)0x8004C3C3L)


//
// MessageId: BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN
//
// MessageText:
//
//  The PUID is already being used as BillableAccountAdmin.
//
#define BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN ((HRESULT)0x8004C3C4L)


//
// MessageId: BDK_E_UPDATING_MEMBERNAME
//
// MessageText:
//
//  Error updating member name.
//
#define BDK_E_UPDATING_MEMBERNAME        ((HRESULT)0x8004C3C8L)


//
// MessageId: BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED
//
// MessageText:
//
//  Object can have a maximum of 2000 roles.
//
#define BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED ((HRESULT)0x8004C3CDL)


//
// MessageId: BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED
//
// MessageText:
//
//  The allowable number of the delegate admins for an account has reached its limit.
//
#define BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED ((HRESULT)0x8004C3CEL)


//
// MessageId: PROVISION_E_MALFORMED_REQUEST
//
// MessageText:
//
//  Provisioning: Provision request malformed.
//
#define PROVISION_E_MALFORMED_REQUEST    ((HRESULT)0x8004AB7DL)


//
// MessageId: PROVISION_E_WRONG_INPUT_PARAMETERS
//
// MessageText:
//
//  Provisioning: Wrong input parameters.
//
#define PROVISION_E_WRONG_INPUT_PARAMETERS ((HRESULT)0x8004AB7EL)


//
// MessageId: PROVISION_E_MPF_CALL_FAILED
//
// MessageText:
//
//  Provisioning: Microsoft Provisioning Framework call failed. %1
//
#define PROVISION_E_MPF_CALL_FAILED      ((HRESULT)0x8004AB7FL)


//
// MessageId: PROVISION_E_XML_OPERATION_ERROR
//
// MessageText:
//
//  Provisioning: Error during XML manipulation. %1
//
#define PROVISION_E_XML_OPERATION_ERROR  ((HRESULT)0x8004AB80L)


//
// MessageId: PROVISION_E_MPF_CREATE
//
// MessageText:
//
//  Provisioning: MPF client instantiation failed. %1
//
#define PROVISION_E_MPF_CREATE           ((HRESULT)0x8004AB81L)


//
// MessageId: PROVISION_E_CREATION
//
// MessageText:
//
//  Provisioning: General error in startup code. %1
//
#define PROVISION_E_CREATION             ((HRESULT)0x8004AB82L)


//
// MessageId: BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS
//
// MessageText:
//
//  The number of service instances in the provisioning request exceeds the configured limit.
//
#define BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS ((HRESULT)0x8004ABA2L)


//
// MessageId: BDK_E_DBBADZIP
//
// MessageText:
//
//  Invalid ZIP code.
//
#define BDK_E_DBBADZIP                   ((HRESULT)0x8004ABA3L)


//
// MessageId: BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS
//
// MessageText:
//
//  The account has subscription(s) in non-cancelled state that require information that you are attempting to remove.
//
#define BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS ((HRESULT)0x8004ABA4L)


//
// MessageId: BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED
//
// MessageText:
//
//  The account requires additional attributes before performing the operation.
//
#define BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED ((HRESULT)0x8004ABA5L)


//
// MessageId: BDK_E_ACCT_ALREADY_REFERRED
//
// MessageText:
//
//  The referrer has already reffered the customer to this offer.
//
#define BDK_E_ACCT_ALREADY_REFERRED      ((HRESULT)0x8004ABCEL)


//
// MessageId: BDK_E_REWARD_OFFER_NOT_PURCHASABLE
//
// MessageText:
//
//  There are no reward offers currently available in the system.
//
#define BDK_E_REWARD_OFFER_NOT_PURCHASABLE ((HRESULT)0x8004ABDAL)


//
// MessageId: BDK_E_AGREEMENT_NOT_SIGNED
//
// MessageText:
//
//  Need to sign the agreement before continuing with the call.
//
#define BDK_E_AGREEMENT_NOT_SIGNED       ((HRESULT)0x8004AC79L)


//
// MessageId: BDK_E_ITEM_VIOLATION_EXISTS
//
// MessageText:
//
//  The user has a violation on their payment instrument.
//
#define BDK_E_ITEM_VIOLATION_EXISTS      ((HRESULT)0x8004AC7AL)


//
// MessageId: BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION
//
// MessageText:
//
//  Title and/or category is not allowed for this offer.
//
#define BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION ((HRESULT)0x8004AC7BL)


//
// MessageId: BDK_E_PENDING_TRANSACTION
//
// MessageText:
//
//  Account has a pending transaction.
//
#define BDK_E_PENDING_TRANSACTION        ((HRESULT)0x8004AC7CL)


//
// MessageId: BDK_E_INCREMENT_TOTAL
//
// MessageText:
//
//  Cannot update total.
//
#define BDK_E_INCREMENT_TOTAL            ((HRESULT)0x80044E39L)


//
// MessageId: BDK_E_RES_NOT_BELONG_TO_OBJECT
//
// MessageText:
//
//  Resource does not belong to this object id.
//
#define BDK_E_RES_NOT_BELONG_TO_OBJECT   ((HRESULT)0x80044E57L)


//
// MessageId: BDK_E_DECLINING_BALANCE
//
// MessageText:
//
//  Payment instrument on the current subscription has a declining balance.
//
#define BDK_E_DECLINING_BALANCE          ((HRESULT)0x80044E5CL)


//
// MessageId: BDK_E_DUPLICATE_TRACKING_GUID
//
// MessageText:
//
//  Duplicate tracking GUID.
//
#define BDK_E_DUPLICATE_TRACKING_GUID    ((HRESULT)0x80044E75L)


//
// MessageId: BDK_E_INVALID_EXPIRATION_DATE
//
// MessageText:
//
//  Invalid credit card expiration date.
//
#define BDK_E_INVALID_EXPIRATION_DATE    ((HRESULT)0x80044EA7L)


//
// MessageId: BDK_E_UNKNOWN_MANDATE_STATUS
//
// MessageText:
//
//  Invalid mandate status.
//
#define BDK_E_UNKNOWN_MANDATE_STATUS     ((HRESULT)0x80044EACL)


//
// MessageId: BDK_E_INVALID_PAYMENT_METHOD_TYPE
//
// MessageText:
//
//  Payment method of this type can't support the action
//
#define BDK_E_INVALID_PAYMENT_METHOD_TYPE ((HRESULT)0x80044EB2L)


//
// MessageId: BDK_E_INVALID_CURRENCY2
//
// MessageText:
//
//  Invalid input currency.
//
#define BDK_E_INVALID_CURRENCY2          ((HRESULT)0x80044EC0L)


//
// MessageId: BDK_E_INVALID_AMOUNT
//
// MessageText:
//
//  Invalid amount passed in as argument.
//
#define BDK_E_INVALID_AMOUNT             ((HRESULT)0x80044EFCL)


//
// MessageId: BDK_E_INVALID_BILLING_PERIOD
//
// MessageText:
//
//  Invalid billing period.
//
#define BDK_E_INVALID_BILLING_PERIOD     ((HRESULT)0x80044F42L)


//
// MessageId: BDK_E_INVALID_ANNIV
//
// MessageText:
//
//  Invalid billing anniversary date.
//
#define BDK_E_INVALID_ANNIV              ((HRESULT)0x80044F9CL)


//
// MessageId: BDK_E_INVALID_LINEITEM_ID
//
// MessageText:
//
//  Invalid line item ID.
//
#define BDK_E_INVALID_LINEITEM_ID        ((HRESULT)0x80044FF6L)


//
// MessageId: BDK_E_INVALID_EVENT_TYPE
//
// MessageText:
//
//  The event type of the line item is invalid for this operation.
//
#define BDK_E_INVALID_EVENT_TYPE         ((HRESULT)0x8004501EL)


//
// MessageId: BDK_E_LINE_ITEM_ID_NOT_OPEN
//
// MessageText:
//
//  Line item ID not associated with an open record.
//
#define BDK_E_LINE_ITEM_ID_NOT_OPEN      ((HRESULT)0x80045046L)


//
// MessageId: BDK_E_LINEITEM_ALREADY_OFFSET
//
// MessageText:
//
//  Line item has already been offset.
//
#define BDK_E_LINEITEM_ALREADY_OFFSET    ((HRESULT)0x8004504BL)


//
// MessageId: BDK_E_LINEITEM_ALREADY_CHARGED_BACK
//
// MessageText:
//
//  Line item has already been Charged back.
//
#define BDK_E_LINEITEM_ALREADY_CHARGED_BACK ((HRESULT)0x8004504DL)


//
// MessageId: BDK_E_INVALID_OFFSET_AMOUNT
//
// MessageText:
//
//  Offset amount must be greater than zero but less than or equal to original amount. %1
//
#define BDK_E_INVALID_OFFSET_AMOUNT      ((HRESULT)0x80045050L)


//
// MessageId: BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED
//
// MessageText:
//
//  Cannot offset line item that is soft- or hard-declined.
//
#define BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED ((HRESULT)0x80045055L)


//
// MessageId: BDK_E_AMOUNT_NOT_COLLECTED_YET
//
// MessageText:
//
//  Amount has not been collected, so it cannot be offset and immediately settled.
//
#define BDK_E_AMOUNT_NOT_COLLECTED_YET   ((HRESULT)0x8004505AL)


//
// MessageId: BDK_E_CANNOT_OFFSET_ZERO_AMOUNT
//
// MessageText:
//
//  Cannot offset line item amount of zero.
//
#define BDK_E_CANNOT_OFFSET_ZERO_AMOUNT  ((HRESULT)0x8004505FL)


//
// MessageId: BDK_E_AMOUNT_IN_PROCESS
//
// MessageText:
//
//  The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.
//
#define BDK_E_AMOUNT_IN_PROCESS          ((HRESULT)0x80045064L)


//
// MessageId: BDK_E_INVALID_CREDIT_AMOUNT
//
// MessageText:
//
//  Credit amount should not be zero.
//
#define BDK_E_INVALID_CREDIT_AMOUNT      ((HRESULT)0x80045082L)


//
// MessageId: BDK_E_CREDIT_AMOUNT_OVER_LIMIT
//
// MessageText:
//
//  Credit amount should not exceed the limit.
//
#define BDK_E_CREDIT_AMOUNT_OVER_LIMIT   ((HRESULT)0x80045083L)


//
// MessageId: BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2
//
// MessageText:
//
//  Invalid amount for currency (JPY or KRW).
//
#define BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2 ((HRESULT)0x80045084L)


//
// MessageId: BDK_E_DUPLICATE_EVENT_ID
//
// MessageText:
//
//  Same event id already been used, please create a new event id and retry.
//
#define BDK_E_DUPLICATE_EVENT_ID         ((HRESULT)0x80045091L)


//
// MessageId: BDK_E_OFFSET_IMM_SETTLE_IN_PROG
//
// MessageText:
//
//  Line items in the immediate_settle_in_progress state cannot be offset.
//
#define BDK_E_OFFSET_IMM_SETTLE_IN_PROG  ((HRESULT)0x8004509BL)


//
// MessageId: BDK_E_SA_IN_STATE_UNOFFSETABLE
//
// MessageText:
//
//  Line item with this settlement amount status cannot be offset.
//
#define BDK_E_SA_IN_STATE_UNOFFSETABLE   ((HRESULT)0x800450A5L)


//
// MessageId: BDK_E_SA_IN_STATE_UNESCHEATABLE
//
// MessageText:
//
//  this settlement amount status cannot be escheated.
//
#define BDK_E_SA_IN_STATE_UNESCHEATABLE  ((HRESULT)0x800450A6L)


//
// MessageId: BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL
//
// MessageText:
//
//  Offset amount should never exceed the original item amount.
//
#define BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL ((HRESULT)0x800450AAL)


//
// MessageId: BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS
//
// MessageText:
//
//  The subscription is not active. The resource usage event is still being reported for the subscription.
//
#define BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS ((HRESULT)0x800450AFL)


//
// MessageId: BDK_E_PI_IN_DECLINE
//
// MessageText:
//
//  the payment instrument already has declines on it
//
#define BDK_E_PI_IN_DECLINE              ((HRESULT)0x800450C8L)


//
// MessageId: BDK_E_SA_IN_INTERMEDIATE_STATUS
//
// MessageText:
//
//  The operation is not allowed when there are Settlement Amounts in intermediate status.
//
#define BDK_E_SA_IN_INTERMEDIATE_STATUS  ((HRESULT)0x800451D1L)


//
// MessageId: BDK_E_INVALID_SETTLEMENT_AMOUNT_ID
//
// MessageText:
//
//  The specified settlement amount id is invalid.
//
#define BDK_E_INVALID_SETTLEMENT_AMOUNT_ID ((HRESULT)0x800451D6L)


//
// MessageId: BDK_E_MISMATCH_RATED_USAGE_TOTAL
//
// MessageText:
//
//  This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.
//
#define BDK_E_MISMATCH_RATED_USAGE_TOTAL ((HRESULT)0x800451E5L)


//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2
//
// MessageText:
//
//  Value for returnStatementSet parameter must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2 ((HRESULT)0x800451BDL)


//
// MessageId: BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE
//
// MessageText:
//
//  %1
//
#define BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE ((HRESULT)0x800451EAL)


//
// MessageId: BDK_E_REFUND_LINEITEM_NOT_SETTLED
//
// MessageText:
//
//  Refund failed - line item was offset but original line item was never settled.
//
#define BDK_E_REFUND_LINEITEM_NOT_SETTLED ((HRESULT)0x80045217L)


//
// MessageId: BDK_E_RESOURCE_BALANCE_INACTIVE
//
// MessageText:
//
//  Specified resource balance has already been billed.
//
#define BDK_E_RESOURCE_BALANCE_INACTIVE  ((HRESULT)0x80045226L)


//
// MessageId: BDK_E_INVALID_NUMBER_OF_UNITS
//
// MessageText:
//
//  Usage category does not exist for this resource.
//
#define BDK_E_INVALID_NUMBER_OF_UNITS    ((HRESULT)0x80045235L)


//
// MessageId: BDK_E_INVALID_USAGE_CATEGORY
//
// MessageText:
//
//  Usage category does not exist for this resource.
//
#define BDK_E_INVALID_USAGE_CATEGORY     ((HRESULT)0x8004523AL)


//
// MessageId: BDK_E_INSUFFICIENT_PREPAID_BALANCE
//
// MessageText:
//
//  The prepaid resource balance is not sufficient for this usage event.
//
#define BDK_E_INSUFFICIENT_PREPAID_BALANCE ((HRESULT)0x8004523FL)


//
// MessageId: BDK_E_INVALID_FINANCIAL_REASON_CODE
//
// MessageText:
//
//  Financial reason code does not exist.
//
#define BDK_E_INVALID_FINANCIAL_REASON_CODE ((HRESULT)0x80045262L)


//
// MessageId: BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED
//
// MessageText:
//
//  Offset of offset is not permitted through this API.
//
#define BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED ((HRESULT)0x80045267L)


//
// MessageId: BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT
//
// MessageText:
//
//  If offset is not to be shown by getstatement, the offset amount must match the original amount.
//
#define BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT ((HRESULT)0x80045276L)


//
// MessageId: BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET
//
// MessageText:
//
//  Invalid financial reason code passed for the offset usage API.
//
#define BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET ((HRESULT)0x8004527BL)


//
// MessageId: BDK_E_EVENT_ACTION_NOT_OFFSETTABLE
//
// MessageText:
//
//  The line item is associated with a non-offsettable event action.
//
#define BDK_E_EVENT_ACTION_NOT_OFFSETTABLE ((HRESULT)0x80045280L)


//
// MessageId: BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED
//
// MessageText:
//
//  Action is not permitted for immediate settle of usage offers.
//
#define BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED ((HRESULT)0x80045285L)


//
// MessageId: BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE
//
// MessageText:
//
//  Resource offset is only allowed for usage.
//
#define BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE ((HRESULT)0x8004528AL)


//
// MessageId: BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE
//
// MessageText:
//
//  Invalid Tax Refund Code.
//
#define BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE ((HRESULT)0x800452ADL)


//
// MessageId: BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER
//
// MessageText:
//
//  The transaction confirmation number is already used on the account.
//
#define BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER ((HRESULT)0x800455FAL)


//
// MessageId: BDK_E_TRANSACTION_NOT_EXIST
//
// MessageText:
//
//  The transaction does not exist.
//
#define BDK_E_TRANSACTION_NOT_EXIST      ((HRESULT)0x80045609L)


//
// MessageId: BDK_E_INVALID_CUMULATIVE_AMOUNT
//
// MessageText:
//
//  Invalid combination of cumulative authorized amount and cumulative reversed amount.
//
#define BDK_E_INVALID_CUMULATIVE_AMOUNT  ((HRESULT)0x80045613L)


//
// MessageId: BDK_E_TRANSACTION_EVENT_UNKNOWN
//
// MessageText:
//
//  The transaction event code is unknown.
//
#define BDK_E_TRANSACTION_EVENT_UNKNOWN  ((HRESULT)0x80045618L)


//
// MessageId: BDK_E_TRANSACTION_EVENT_INCONSISTENT
//
// MessageText:
//
//  The transaction event code is not consistent.
//
#define BDK_E_TRANSACTION_EVENT_INCONSISTENT ((HRESULT)0x8004561DL)


//
// MessageId: BDK_E_INVALID_SEQUENCE_NUMBER
//
// MessageText:
//
//  Invalid sequence number reported in transaction event.
//
#define BDK_E_INVALID_SEQUENCE_NUMBER    ((HRESULT)0x80045622L)


//
// MessageId: BDK_E_INVALID_VENDOR_TRANSACTION_ID
//
// MessageText:
//
//  Invalid vendor internal transaction id.
//
#define BDK_E_INVALID_VENDOR_TRANSACTION_ID ((HRESULT)0x80045627L)


//
// MessageId: BDK_E_INVALID_REJECTION_REASON_CODE
//
// MessageText:
//
//  Invalid rejection reason code.
//
#define BDK_E_INVALID_REJECTION_REASON_CODE ((HRESULT)0x8004562CL)


//
// MessageId: BDK_E_INVALID_TRANSACTION_STATUS
//
// MessageText:
//
//  Invalid transaction status.
//
#define BDK_E_INVALID_TRANSACTION_STATUS ((HRESULT)0x80045659L)


//
// MessageId: BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT
//
// MessageText:
//
//  Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount.
//
#define BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT ((HRESULT)0x8004566DL)


//
// MessageId: BDK_E_UNKNOWN_MERCHANT_ID
//
// MessageText:
//
//  Invalid merchant id.
//
#define BDK_E_UNKNOWN_MERCHANT_ID        ((HRESULT)0x80045677L)


//
// MessageId: BDK_E_TRANSACTION_ALREADY_CANCELLED
//
// MessageText:
//
//  Transaction has already been cancelled.
//
#define BDK_E_TRANSACTION_ALREADY_CANCELLED ((HRESULT)0x8004567CL)


//
// MessageId: BDK_E_PMN_INSERT_FAILURE
//
// MessageText:
//
//  Passport member name could not be added.
//
#define BDK_E_PMN_INSERT_FAILURE         ((HRESULT)0x800461BCL)


//
// MessageId: BDK_E_BADSAMECARDUSEDMULTIPLETIMES
//
// MessageText:
//
//  Payment card number has been used multiple times.
//
#define BDK_E_BADSAMECARDUSEDMULTIPLETIMES ((HRESULT)0x800461D0L)


//
// MessageId: BDK_E_PI_ALREADY_ON_ACCOUNT
//
// MessageText:
//
//  Payment instrument already assigned to account.
//
#define BDK_E_PI_ALREADY_ON_ACCOUNT      ((HRESULT)0x800461DFL)


//
// MessageId: BDK_E_PUID_ROLE_LIMIT_EXCEEDED
//
// MessageText:
//
//  Passport ID can have a maximum of 100 roles.
//
#define BDK_E_PUID_ROLE_LIMIT_EXCEEDED   ((HRESULT)0x800461E4L)


//
// MessageId: BDK_E_TOOMANY_FDE_PURCHASES
//
// MessageText:
//
//  Too many fraud enticing purchases on the payment instrument
//
#define BDK_E_TOOMANY_FDE_PURCHASES      ((HRESULT)0x800461E5L)


//
// MessageId: BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED
//
// MessageText:
//
//  Passport PUIDs associated with this tax Id has already reaches the maximum limit.
//
#define BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED ((HRESULT)0x8004620CL)


//
// MessageId: BDK_E_NOPERMISSION
//
// MessageText:
//
//  Access denied.
//
#define BDK_E_NOPERMISSION               ((HRESULT)0x80042711L)


//
// MessageId: BDK_E_CANNOT_REMOVE_SELF
//
// MessageText:
//
//  Cannot remove self from object.
//
#define BDK_E_CANNOT_REMOVE_SELF         ((HRESULT)0x80042712L)


//
// MessageId: BDK_E_BADXML
//
// MessageText:
//
//  XML is either malformed or incorrect for this API.
//
#define BDK_E_BADXML                     ((HRESULT)0x80042713L)


//
// MessageId: BDK_E_INVALIDCOMMENTSIZE
//
// MessageText:
//
//  Comment text length must be between 1 and 512 characters.
//
#define BDK_E_INVALIDCOMMENTSIZE         ((HRESULT)0x80042714L)


//
// MessageId: BDK_E_BADCANCELMODE
//
// MessageText:
//
//  Invalid cancellation mode.
//
#define BDK_E_BADCANCELMODE              ((HRESULT)0x80042715L)


//
// MessageId: BDK_E_INVALID_BUF_SIZE
//
// MessageText:
//
//  Input parameter is the wrong size.
//
#define BDK_E_INVALID_BUF_SIZE           ((HRESULT)0x80042716L)


//
// MessageId: BDK_E_INVALID_ROLE
//
// MessageText:
//
//  Invalid role.
//
#define BDK_E_INVALID_ROLE               ((HRESULT)0x80042717L)


//
// MessageId: BDK_E_INVALID_PPORT_ID
//
// MessageText:
//
//  Invalid Passport ID.
//
#define BDK_E_INVALID_PPORT_ID           ((HRESULT)0x80042718L)


//
// MessageId: BDK_E_INVALID_ARG
//
// MessageText:
//
//  Invalid argument.
//
#define BDK_E_INVALID_ARG                ((HRESULT)0x8004271AL)


//
// MessageId: BDK_E_UNKNOWN_SERVER_FAILURE
//
// MessageText:
//
//  Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.
//
#define BDK_E_UNKNOWN_SERVER_FAILURE     ((HRESULT)0x8004271FL)


//
// MessageId: BDK_E_INVALID_STATUS_VALUE
//
// MessageText:
//
//  Status must be ENABLED or SUSPENDED.
//
#define BDK_E_INVALID_STATUS_VALUE       ((HRESULT)0x80042720L)


//
// MessageId: BDK_E_INVALID_FILTER
//
// MessageText:
//
//  Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.
//
#define BDK_E_INVALID_FILTER             ((HRESULT)0x80042721L)


//
// MessageId: BDK_E_MISSING_CATEGORY
//
// MessageText:
//
//  Missing category.
//
#define BDK_E_MISSING_CATEGORY           ((HRESULT)0x80042722L)


//
// MessageId: BDK_E_FIELD_TOO_SHORT
//
// MessageText:
//
//  Input field is too short.
//
#define BDK_E_FIELD_TOO_SHORT            ((HRESULT)0x80042723L)


//
// MessageId: BDK_E_FIELD_TOO_LONG
//
// MessageText:
//
//  Input field is too long.
//
#define BDK_E_FIELD_TOO_LONG             ((HRESULT)0x80042724L)


//
// MessageId: BDK_E_BADZIP
//
// MessageText:
//
//  Invalid ZIP code.
//
#define BDK_E_BADZIP                     ((HRESULT)0x80042725L)


//
// MessageId: BDK_E_ONLYONENODE
//
// MessageText:
//
//  Only one of these nodes should be passed.
//
#define BDK_E_ONLYONENODE                ((HRESULT)0x80042726L)


//
// MessageId: BDK_E_INVALID_FIELD_LENGTH
//
// MessageText:
//
//  Input field length does not meet requirement.
//
#define BDK_E_INVALID_FIELD_LENGTH       ((HRESULT)0x80042727L)


//
// MessageId: BDK_E_CSR_AUTHZ_FAILED
//
// MessageText:
//
//  Only customer service representatives can invoke this API.
//
#define BDK_E_CSR_AUTHZ_FAILED           ((HRESULT)0x80042728L)


//
// MessageId: BDK_E_NOT_ACCOUNT_ADMIN
//
// MessageText:
//
//  Caller is not an account administrator.
//
#define BDK_E_NOT_ACCOUNT_ADMIN          ((HRESULT)0x80042729L)


//
// MessageId: BDK_E_DELEGATE_ID_UNSPECIFIED
//
// MessageText:
//
//  Delegate ID entered was invalid or not specified.
//
#define BDK_E_DELEGATE_ID_UNSPECIFIED    ((HRESULT)0x8004272AL)


//
// MessageId: BDK_E_REQUESTER_ID_UNSPECIFIED
//
// MessageText:
//
//  Requester Passport ID must be specified.
//
#define BDK_E_REQUESTER_ID_UNSPECIFIED   ((HRESULT)0x8004272BL)


//
// MessageId: BDK_E_INVALID_FLAG_VALUE
//
// MessageText:
//
//  Boolean value must be 0 or 1
//
#define BDK_E_INVALID_FLAG_VALUE         ((HRESULT)0x8004272CL)


//
// MessageId: BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION
//
// MessageText:
//
//  Subscription service instance is inactive.
//
#define BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION ((HRESULT)0x8004272DL)


//
// MessageId: BDK_E_INVALID_OBJECT_ID
//
// MessageText:
//
//  Invalid object.
//
#define BDK_E_INVALID_OBJECT_ID          ((HRESULT)0x8004272EL)


//
// MessageId: BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH
//
// MessageText:
//
//  Input field length of first name does not meet requirement.
//
#define BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH ((HRESULT)0x8004272FL)


//
// MessageId: BDK_E_INVALID_LASTNAME_FIELD_LENGTH
//
// MessageText:
//
//  Input field length of last name does not meet requirement.
//
#define BDK_E_INVALID_LASTNAME_FIELD_LENGTH ((HRESULT)0x80042730L)


//
// MessageId: BDK_E_INVALID_ADDRESS_FIELD_LENGTH
//
// MessageText:
//
//  Input field length of address does not meet requirement.
//
#define BDK_E_INVALID_ADDRESS_FIELD_LENGTH ((HRESULT)0x80042731L)


//
// MessageId: BDK_E_PARTNERNOTINBILLING
//
// MessageText:
//
//  Calling partner is not registered in SPS database.
//
#define BDK_E_PARTNERNOTINBILLING        ((HRESULT)0x80042738L)


//
// MessageId: BDK_E_RATING_FAILURE
//
// MessageText:
//
//  Rating error has occurred. Check the event log and the tracer.
//
#define BDK_E_RATING_FAILURE             ((HRESULT)0x8004273DL)


//
// MessageId: BDK_SVR2_STARTED
//
// MessageText:
//
//  BDKSVR2 started.
//
#define BDK_SVR2_STARTED                 ((HRESULT)0x80042742L)


//
// MessageId: BDK_CSR_API_CALL_MADE
//
// MessageText:
//
//  CSR call made.
//
#define BDK_CSR_API_CALL_MADE            ((HRESULT)0x80042743L)


//
// MessageId: BDK_E_CSR_CALL_FROM_NONCSR
//
// MessageText:
//
//  CSR call attempt by non-CSR caller.
//
#define BDK_E_CSR_CALL_FROM_NONCSR       ((HRESULT)0x80042744L)


//
// MessageId: BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS
//
// MessageText:
//
//  "From" and "to" payment instrument are not on the same account in TransferBalance.
//
#define BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS ((HRESULT)0x8004274CL)


//
// MessageId: BDK_E_TRANS_BALANCE_TO_PI_INVALID
//
// MessageText:
//
//  Invalid "to" payment instrument in TransferBalance.
//
#define BDK_E_TRANS_BALANCE_TO_PI_INVALID ((HRESULT)0x80042751L)


//
// MessageId: BDK_E_TRANS_BALANCE_TO_SAME_PI
//
// MessageText:
//
//  Cannot transfer to same payment instrument in TransferBalance.
//
#define BDK_E_TRANS_BALANCE_TO_SAME_PI   ((HRESULT)0x80042756L)


//
// MessageId: BDK_E_TRANS_BALANCE_NOT_ALLOW
//
// MessageText:
//
//  Cannot transfer balances between payment instrument types.
//
#define BDK_E_TRANS_BALANCE_NOT_ALLOW    ((HRESULT)0x8004275BL)


//
// MessageId: BDK_E_INTERNAL_ERROR
//
// MessageText:
//
//  Internal database inconsistencies detected.
//
#define BDK_E_INTERNAL_ERROR             ((HRESULT)0x80042760L)


//
// MessageId: BDK_E_OUTSTANDING_BALANCE
//
// MessageText:
//
//  Payment instrument has outstanding balance.
//
#define BDK_E_OUTSTANDING_BALANCE        ((HRESULT)0x80042765L)


//
// MessageId: BDK_E_INVALID_REFERRALDATA_XML
//
// MessageText:
//
//  Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).
//
#define BDK_E_INVALID_REFERRALDATA_XML   ((HRESULT)0x8004276AL)


//
// MessageId: BDK_E_INVALID_GUID
//
// MessageText:
//
//  Invalid GUID.
//
#define BDK_E_INVALID_GUID               ((HRESULT)0x8004276FL)


//
// MessageId: E_UNSUPPORTED_PAYMENT_INSTRUMENT
//
// MessageText:
//
//  Payment instrument type not supported for SettleBalance.
//
#define E_UNSUPPORTED_PAYMENT_INSTRUMENT ((HRESULT)0x80042774L)


//
// MessageId: BDK_E_SUBSCRIPTION_INACTIVE
//
// MessageText:
//
//  Subscription is inactive.
//
#define BDK_E_SUBSCRIPTION_INACTIVE      ((HRESULT)0x80042779L)


//
// MessageId: BDK_E_INVALID_PM_FOR_STOP_PAYMENTS
//
// MessageText:
//
//  Payments can only be stopped for credit card and direct debit transactions.
//
#define BDK_E_INVALID_PM_FOR_STOP_PAYMENTS ((HRESULT)0x8004277EL)


//
// MessageId: BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS
//
// MessageText:
//
//  Excessive number of usage events reported in one ReportUsageEvent() call.
//
#define BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS ((HRESULT)0x80042783L)


//
// MessageId: BDK_E_FIELD_NOT_UPDATEABLE
//
// MessageText:
//
//  Field cannot be updated.
//
#define BDK_E_FIELD_NOT_UPDATEABLE       ((HRESULT)0x80042788L)


//
// MessageId: BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED
//
// MessageText:
//
//  Calling CancelSubscription with an end date and in compute-only mode is not supported.
//
#define BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED ((HRESULT)0x8004278DL)


//
// MessageId: BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT
//
// MessageText:
//
//  The SETTLE event should be the last event in the event list for ImportSettleBillingItems.
//
#define BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT ((HRESULT)0x8004278EL)


//
// MessageId: BDK_E_PAYMENT_METHOD_NO_LONGER_VALID
//
// MessageText:
//
//  Line item payment method is no longer valid.
//
#define BDK_E_PAYMENT_METHOD_NO_LONGER_VALID ((HRESULT)0x8004278FL)


//
// MessageId: BDK_E_PROCESS_USAGE_EVENTS
//
// MessageText:
//
//  Failed to process all usage events.
//
#define BDK_E_PROCESS_USAGE_EVENTS       ((HRESULT)0x80042790L)


//
// MessageId: BDK_E_WRONG_OBJECT_ID_TYPE
//
// MessageText:
//
//  Object ID does not contain account and subscription information.
//
#define BDK_E_WRONG_OBJECT_ID_TYPE       ((HRESULT)0x80042791L)


//
// MessageId: BDK_E_INVALID_PHONE_VALUE
//
// MessageText:
//
//  Field contains invalid characters for a phone number.
//
#define BDK_E_INVALID_PHONE_VALUE        ((HRESULT)0x80042792L)


//
// MessageId: BDK_E_INVALID_AMOUNT_VALUE
//
// MessageText:
//
//  Invalid amount.
//
#define BDK_E_INVALID_AMOUNT_VALUE       ((HRESULT)0x80042797L)


//
// MessageId: BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE
//
// MessageText:
//
//  Payment instrument ID and line item ID do not match.
//
#define BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE ((HRESULT)0x80042793L)


//
// MessageId: BDK_E_INTERNAL_ADD_COMMENT_FAILED
//
// MessageText:
//
//  InternalAddComment failed. Escalate error to SPG development.
//
#define BDK_E_INTERNAL_ADD_COMMENT_FAILED ((HRESULT)0x80042794L)


//
// MessageId: BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE
//
// MessageText:
//
//  Immediate settle flag value not supported.
//
#define BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE ((HRESULT)0x80042795L)


//
// MessageId: BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS
//
// MessageText:
//
//  No eligible records were found for this call.
//
#define BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS ((HRESULT)0x8004279CL)


//
// MessageId: BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE
//
// MessageText:
//
//  Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.
//
#define BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE ((HRESULT)0x800427A6L)


//
// MessageId: BDK_E_INVALID_TELENUMERIC_STRING
//
// MessageText:
//
//  The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.
//
#define BDK_E_INVALID_TELENUMERIC_STRING ((HRESULT)0x800427B0L)


//
// MessageId: BDK_E_NO_MATCH
//
// MessageText:
//
//  There are no matches for the requested information.
//
#define BDK_E_NO_MATCH                   ((HRESULT)0x800427BAL)


//
// MessageId: BDK_E_MULTIPLE_MATCHES
//
// MessageText:
//
//  There are multiple matches for the requested information.
//
#define BDK_E_MULTIPLE_MATCHES           ((HRESULT)0x800427C4L)


//
// MessageId: BDK_E_BAD_PUID
//
// MessageText:
//
//  PUID entered was invalid.
//
#define BDK_E_BAD_PUID                   ((HRESULT)0x800427CEL)


//
// MessageId: BDK_E_BAD_OBJECT_ID_LENGTH
//
// MessageText:
//
//  ObjectId length must be 16.
//
#define BDK_E_BAD_OBJECT_ID_LENGTH       ((HRESULT)0x800427D9L)


//
// MessageId: BDK_E_END_PERIOD_LESS_THAN_START_PERIOD
//
// MessageText:
//
//  Start period can never be greater than End period.
//
#define BDK_E_END_PERIOD_LESS_THAN_START_PERIOD ((HRESULT)0x800427DAL)


//
// MessageId: BDK_E_BAD_BILLING_PERIOD_LENGTH
//
// MessageText:
//
//  Billing period length must be 6.
//
#define BDK_E_BAD_BILLING_PERIOD_LENGTH  ((HRESULT)0x800427DBL)


//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET
//
// MessageText:
//
//  Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET   ((HRESULT)0x800427DCL)


//
// MessageId: BDK_E_INVALID_USAGE_EVENT_DATE
//
// MessageText:
//
//  The usage event date specified was invalid.  One possible reason is that it is too far in the future.
//
#define BDK_E_INVALID_USAGE_EVENT_DATE   ((HRESULT)0x800427DFL)


//
// MessageId: BDK_E_NULL_DEFAULT_BILLING_PERIOD
//
// MessageText:
//
//  The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.
//
#define BDK_E_NULL_DEFAULT_BILLING_PERIOD ((HRESULT)0x800427E0L)


//
// MessageId: BDK_E_BAD_START_BILLING_PERIOD
//
// MessageText:
//
//  The start billing period is less than the currently available billing period.
//
#define BDK_E_BAD_START_BILLING_PERIOD   ((HRESULT)0x800427E1L)


//
// MessageId: BDK_E_BAD_END_BILLING_PERIOD
//
// MessageText:
//
//  The end billing period is less than the currently available billing period.
//
#define BDK_E_BAD_END_BILLING_PERIOD     ((HRESULT)0x800427E2L)


//
// MessageId: BDK_E_NEW_DUE_DATE_IS_PAST
//
// MessageText:
//
//  The new due date is in the past
//
#define BDK_E_NEW_DUE_DATE_IS_PAST       ((HRESULT)0x800427E7L)


//
// MessageId: BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED
//
// MessageText:
//
//  The new due date is more than MAXIMUM DELAY days in the future than the original due date
//
#define BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED ((HRESULT)0x800427ECL)


//
// MessageId: BDK_E_NO_NEW_DUE_DATE_SPECIFIED
//
// MessageText:
//
//  If the applydeclineEffect is off, we need a new due date specified
//
#define BDK_E_NO_NEW_DUE_DATE_SPECIFIED  ((HRESULT)0x800427F1L)


//
// MessageId: BDK_E_INVALID_TRANSACTION_TYPE
//
// MessageText:
//
//  Invalid transaction type
//
#define BDK_E_INVALID_TRANSACTION_TYPE   ((HRESULT)0x800427F6L)


//
// MessageId: BDK_E_INVALID_REASON_CODE
//
// MessageText:
//
//  Invalid reason code
//
#define BDK_E_INVALID_REASON_CODE        ((HRESULT)0x800427FBL)


//
// MessageId: BDK_E_GROUP_SID_INITIALIZATION_FAILED
//
// MessageText:
//
//  Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.
//
#define BDK_E_GROUP_SID_INITIALIZATION_FAILED ((HRESULT)0x8004280BL)


//
// MessageId: BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI
//
// MessageText:
//
//  This operation is not valid for wholesale payment instruments.
//
#define BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI ((HRESULT)0x8004280CL)


//
// MessageId: BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT
//
// MessageText:
//
//  This operation is not valid for direct debit payment instrument.
//
#define BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT ((HRESULT)0x8004280DL)


//
// MessageId: BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT
//
// MessageText:
//
//  Adjustment amount exceeds the resource credit limit.
//
#define BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT ((HRESULT)0x8004280EL)


//
// MessageId: BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS
//
// MessageText:
//
//  Adjusting a resource balance is not allowed for subscriptions that are not active.
//
#define BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS ((HRESULT)0x8004280FL)


//
// MessageId: BDK_E_FAILED_TO_CREATE_MAIL_RECORD
//
// MessageText:
//
//  Failed to create mail record for account: %1.
//
#define BDK_E_FAILED_TO_CREATE_MAIL_RECORD ((HRESULT)0x80042810L)


//
// MessageId: BDK_E_MSNIA_LATE_USAGE
//
// MessageText:
//
//  This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.
//
#define BDK_E_MSNIA_LATE_USAGE           ((HRESULT)0x80042811L)


//
// MessageId: BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB
//
// MessageText:
//
//  Failed to write asynchronous immediate settlement failure into the audit db for account: %1.
//
#define BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB ((HRESULT)0x80042812L)


//
// MessageId: BDK_E_INVALID_REFERRAL_OFFER
//
// MessageText:
//
//  This offering is not configured as a referral offer.
//
#define BDK_E_INVALID_REFERRAL_OFFER     ((HRESULT)0x8004ABCCL)


//
// MessageId: BDK_E_REWARD_REFERRAL_XML_REQUIRED
//
// MessageText:
//
//  Reward referral XML is required as this is a referral based offer.
//
#define BDK_E_REWARD_REFERRAL_XML_REQUIRED ((HRESULT)0x80042813L)


//
// MessageId: BDK_E_REFERRER_NOT_IN_SYSTEM
//
// MessageText:
//
//  Referral PUID not found.
//
#define BDK_E_REFERRER_NOT_IN_SYSTEM     ((HRESULT)0x80042814L)


//
// MessageId: BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER
//
// MessageText:
//
//  Referrer has exceeded the max number of referrals configured on the offer.
//
#define BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER ((HRESULT)0x80042815L)


//
// MessageId: BDK_E_REFERRER_NOT_ACTIVE
//
// MessageText:
//
//  The referrer does not have an Active or Locked account in the system.
//
#define BDK_E_REFERRER_NOT_ACTIVE        ((HRESULT)0x80042816L)


//
// MessageId: BDK_E_CANNOT_REFER_SELF
//
// MessageText:
//
//  The referrer cannot refer self for the offer.
//
#define BDK_E_CANNOT_REFER_SELF          ((HRESULT)0x80042817L)


//
// MessageId: BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL
//
// MessageText:
//
//  The referral xml has reward referral info but the offer is not configured for reward referrals.
//
#define BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL ((HRESULT)0x80042818L)


//
// MessageId: BDK_E_INVALID_REWARD_REFFERAL_SCHEMA
//
// MessageText:
//
//  The reward referral schema in the referral xml is invalid.
//
#define BDK_E_INVALID_REWARD_REFFERAL_SCHEMA ((HRESULT)0x80042819L)


//
// MessageId: BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER
//
// MessageText:
//
//  The referrer does not have any eligible offers configured for the reward.
//
#define BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER ((HRESULT)0x8004281AL)


//
// MessageId: BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS
//
// MessageText:
//
//  Invalid mandate status for SettleBalance.
//
#define BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS ((HRESULT)0x8004281BL)


//
// MessageId: BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED
//
// MessageText:
//
//  More than one usage event reported to ReportSingleUsageEvent API
//
#define BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED ((HRESULT)0x8004281CL)


//
// MessageId: BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM
//
// MessageText:
//
//  The reported usage is below the threshold in immediate settle usage.
//
#define BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM ((HRESULT)0x8004281DL)


//
// MessageId: BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE
//
// MessageText:
//
//  ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.
//
#define BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE ((HRESULT)0x8004281EL)


//
// MessageId: BDK_E_REPORT_USAGE_WITH_PREPAID
//
// MessageText:
//
//  ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.
//
#define BDK_E_REPORT_USAGE_WITH_PREPAID  ((HRESULT)0x8004281FL)


//
// MessageId: BDK_E_NO_USAGE_EVENT_REPORTED
//
// MessageText:
//
//  ReportSingleUsage cannot be used with empty event set.
//
#define BDK_E_NO_USAGE_EVENT_REPORTED    ((HRESULT)0x80042820L)


//
// MessageId: BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT
//
// MessageText:
//
//  The payment instrument type does not support immediate settlements
//
#define BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT ((HRESULT)0x80042821L)


//
// MessageId: BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH
//
// MessageText:
//
//  The reported resource and unit of measure do not match.
//
#define BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH ((HRESULT)0x80042822L)


//
// MessageId: BDK_E_INVALID_REDIRECT_INPUTINFO_XML
//
// MessageText:
//
//  Invalid  data passed in RedirectInputInfoXML node.
//
#define BDK_E_INVALID_REDIRECT_INPUTINFO_XML ((HRESULT)0x80042823L)


//
// MessageId: BDK_E_TRANSACTION_NOT_CANCELLABLE
//
// MessageText:
//
//  Transaction cannot be cancelled.
//
#define BDK_E_TRANSACTION_NOT_CANCELLABLE ((HRESULT)0x80042824L)


//
// MessageId: BDK_E_NO_CDS_FOUND
//
// MessageText:
//
//  No CDs found.
//
#define BDK_E_NO_CDS_FOUND               ((HRESULT)0x80042825L)


//
// MessageId: BDK_E_INVALID_CHARGE_DESCRIPTOR
//
// MessageText:
//
//  Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length
//
#define BDK_E_INVALID_CHARGE_DESCRIPTOR  ((HRESULT)0x80042826L)


//
// MessageId: BDK_E_INVALID_WHOLESALEPI
//
// MessageText:
//
//  This Wholesale payment instrument has no related wholesale partner.
//
#define BDK_E_INVALID_WHOLESALEPI        ((HRESULT)0x800428A0L)


//
// MessageId: BDK_E_NOT_BOBOPARTNER
//
// MessageText:
//
//  This partner is not BOBO wholesale partner.
//
#define BDK_E_NOT_BOBOPARTNER            ((HRESULT)0x800428A1L)


//
// MessageId: BDK_E_INVALID_BOBOPARTNER
//
// MessageText:
//
//  This BOBO wholesale partner has no entitle endpoint.
//
#define BDK_E_INVALID_BOBOPARTNER        ((HRESULT)0x800428A2L)


//
// MessageId: BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE
//
// MessageText:
//
//  The entitlement endpoint web service could not be reached
//
#define BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE ((HRESULT)0x800428FAL)


//
// MessageId: BDK_E_ENTITLEMENT_VALIDATION_FAILED
//
// MessageText:
//
//  The entitlement endpoint returned a validation failure
//
#define BDK_E_ENTITLEMENT_VALIDATION_FAILED ((HRESULT)0x800428FBL)


//
// MessageId: BDK_E_INVALID_ENTITLEMENT_ENDPOINT
//
// MessageText:
//
//  The entitlement endpoint is invalid
//
#define BDK_E_INVALID_ENTITLEMENT_ENDPOINT ((HRESULT)0x800428FCL)


//
// MessageId: BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT
//
// MessageText:
//
//  Calling partner does not have permissions to access the sandboxed object
//
#define BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT ((HRESULT)0x80049D57L)


//
// MessageId: BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF
//
// MessageText:
//
//  Calling partner does not have permissions to call on behalf of this partner
//
#define BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF ((HRESULT)0x80042828L)


//
// MessageId: BDK_E_TAXWARE_FAILURE
//
// MessageText:
//
//  Taxware error. Check the event log and the tracer.
//
#define BDK_E_TAXWARE_FAILURE            ((HRESULT)0x8004EA60L)


//
// MessageId: BDK_E_ADDRESS_VALIDATION_FAILURE
//
// MessageText:
//
//  Address validation error. Check the event log and the tracer.
//
#define BDK_E_ADDRESS_VALIDATION_FAILURE ((HRESULT)0x8004EA61L)


//
// MessageId: BDK_E_ZIP_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid ZIP code.
//
#define BDK_E_ZIP_INVALID                ((HRESULT)0x8004EA6BL)


//
// MessageId: BDK_E_STATE_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code.
//
#define BDK_E_STATE_INVALID              ((HRESULT)0x8004EA6CL)


//
// MessageId: BDK_E_ZIP_CITY_MISSING
//
// MessageText:
//
//  VERAZIP: Missing ZIP code or city name.
//
#define BDK_E_ZIP_CITY_MISSING           ((HRESULT)0x8004EA6DL)


//
// MessageId: BDK_E_STATE_ZIP_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code combination.
//
#define BDK_E_STATE_ZIP_INVALID          ((HRESULT)0x8004EA6EL)


//
// MessageId: BDK_E_STATE_CITY_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/city name combination.
//
#define BDK_E_STATE_CITY_INVALID         ((HRESULT)0x8004EA6FL)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
//
#define BDK_E_STATE_ZIP_CITY_INVALID     ((HRESULT)0x8004EA70L)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID2
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination.
//
#define BDK_E_STATE_ZIP_CITY_INVALID2    ((HRESULT)0x8004EA71L)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID3
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination.
//
#define BDK_E_STATE_ZIP_CITY_INVALID3    ((HRESULT)0x8004EA72L)


//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID4
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.
//
#define BDK_E_STATE_ZIP_CITY_INVALID4    ((HRESULT)0x8004EA73L)


//
// MessageId: BDK_E_MULTIPLE_COUNTIES_FOUND
//
// MessageText:
//
//  VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.
//
#define BDK_E_MULTIPLE_COUNTIES_FOUND    ((HRESULT)0x8004EA7DL)


//
// MessageId: BDK_E_ZIP_INVALID_FOR_ENTERED_STATE
//
// MessageText:
//
//  VERAZIP: Invalid state code for ZIP code. Changed to correct state code.
//
#define BDK_E_ZIP_INVALID_FOR_ENTERED_STATE ((HRESULT)0x8004EA7EL)


//
// MessageId: BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES
//
// MessageText:
//
//  VERAZIP: ZIP code has multiple city names.
//
#define BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES ((HRESULT)0x8004EA89L)


//
// MessageId: BDK_E_MULTIPLE_CITIES_FOUND
//
// MessageText:
//
//  VERAZIP: City has multiple ZIP codes.
//
#define BDK_E_MULTIPLE_CITIES_FOUND      ((HRESULT)0x8004EA8AL)


//
// MessageId: BDK_E_BAD_CITYNAME_LENGTH
//
// MessageText:
//
//  Incorrect city name length.
//
#define BDK_E_BAD_CITYNAME_LENGTH        ((HRESULT)0x8004EA8BL)


//
// MessageId: BDK_E_BAD_COUNTRYCODE_LENGTH
//
// MessageText:
//
//  Incorrect country code length.
//
#define BDK_E_BAD_COUNTRYCODE_LENGTH     ((HRESULT)0x8004EA8CL)


//
// MessageId: BDK_E_BAD_STATECODE_LENGTH
//
// MessageText:
//
//  Incorrect code length for state or province.
//
#define BDK_E_BAD_STATECODE_LENGTH       ((HRESULT)0x8004EA8DL)


//
// MessageId: BDK_E_BAD_ZIPCODE_LENGTH
//
// MessageText:
//
//  Incorrect zip code length.
//
#define BDK_E_BAD_ZIPCODE_LENGTH         ((HRESULT)0x8004EA8EL)


//
// MessageId: BDK_E_BAD_PRODUCTCODE_LENGTH
//
// MessageText:
//
//  Incorrect product code length.
//
#define BDK_E_BAD_PRODUCTCODE_LENGTH     ((HRESULT)0x8004EA8FL)


//
// MessageId: BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH
//
// MessageText:
//
//  Incorrect business location code length.
//
#define BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH ((HRESULT)0x8004EA90L)


//
// MessageId: BDK_E_BAD_TRANSACTIONDATE_LENGTH
//
// MessageText:
//
//  Incorrect transaction date length.
//
#define BDK_E_BAD_TRANSACTIONDATE_LENGTH ((HRESULT)0x8004EA91L)


//
// MessageId: BDK_E_BAD_VATREGISTRATION_LENGTH
//
// MessageText:
//
//  Incorrect VAT registration length.
//
#define BDK_E_BAD_VATREGISTRATION_LENGTH ((HRESULT)0x8004EA92L)


//
// MessageId: BDK_E_BAD_CURRENCYCODE_LENGTH
//
// MessageText:
//
//  Incorrect currency code length.
//
#define BDK_E_BAD_CURRENCYCODE_LENGTH    ((HRESULT)0x8004EA93L)


//
// MessageId: BDK_E_BAD_WTCODE_LENGTH
//
// MessageText:
//
//  Incorrect WorldTax code length.
//
#define BDK_E_BAD_WTCODE_LENGTH          ((HRESULT)0x8004EA94L)


//
// MessageId: BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP
//
// MessageText:
//
//  Invalid input parameter passed to TaxWare or VeraZip.
//
#define BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP ((HRESULT)0x8004EA95L)


//
// MessageId: BDK_E_INVALID_VATID_FORMAT
//
// MessageText:
//
//  The Vat ID provided is of invalid format.
//
#define BDK_E_INVALID_VATID_FORMAT       ((HRESULT)0x8004EA97L)


//
// MessageId: BDK_E_INVALID_VATID_INVALID
//
// MessageText:
//
//  The Vat ID provided is invalid.
//
#define BDK_E_INVALID_VATID_INVALID      ((HRESULT)0x8004EA98L)


//
// MessageId: BDK_E_UNSUPPORTED_CHAR_EXIST
//
// MessageText:
//
//  Input string contains unsupported characters.
//
#define BDK_E_UNSUPPORTED_CHAR_EXIST     ((HRESULT)0x8004EA9CL)


//
// MessageId: BDK_E_ERROR_COUNTRYCODE_MISMATCH
//
// MessageText:
//
//  Country code in Address does not match with the country code in Account Info.
//
#define BDK_E_ERROR_COUNTRYCODE_MISMATCH ((HRESULT)0x8004EAA1L)


//
// MessageId: BDK_E_ERROR_COUNTRYCODE_REQUIRED
//
// MessageText:
//
//  A Country code is required in Account Info.
//
#define BDK_E_ERROR_COUNTRYCODE_REQUIRED ((HRESULT)0x8004EAA6L)


//
// MessageId: BDK_E_INVALID_TOKEN_SPECIFIED
//
// MessageText:
//
//  Token passed is Invalid.
//
#define BDK_E_INVALID_TOKEN_SPECIFIED    ((HRESULT)0x8004138DL)


//
// MessageId: BDK_E_TOKEN_ALREADY_BLACKLISTED
//
// MessageText:
//
//  The token is already blacklisted.
//
#define BDK_E_TOKEN_ALREADY_BLACKLISTED  ((HRESULT)0x80041392L)


//
// MessageId: BDK_E_TOKEN_ALREADY_UNBLACKLISTED
//
// MessageText:
//
//  The token is already un-blacklisted.
//
#define BDK_E_TOKEN_ALREADY_UNBLACKLISTED ((HRESULT)0x80041393L)


//
// MessageId: BDK_E_TOKEN_BLACKLISTED
//
// MessageText:
//
//  The specified token has been blacklisted.
//
#define BDK_E_TOKEN_BLACKLISTED          ((HRESULT)0x800413BFL)


//
// MessageId: BDK_E_TOKEN_RANGE_BLACKLISTED
//
// MessageText:
//
//  The specified token belongs to a blacklisted token range.
//
#define BDK_E_TOKEN_RANGE_BLACKLISTED    ((HRESULT)0x800413C4L)


//
// MessageId: BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED
//
// MessageText:
//
//  The usage for the specified token has been exceeded.
//
#define BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED ((HRESULT)0x800413C9L)


//
// MessageId: BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL
//
// MessageText:
//
//  Token Expiry date not set as may be duration based token was not activated correctly.
//
#define BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL ((HRESULT)0x800413CEL)


//
// MessageId: BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS
//
// MessageText:
//
//  Failed while consumption to create an entry in token_instance_deal_subscription table.
//
#define BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS ((HRESULT)0x800413CFL)


//
// MessageId: BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT
//
// MessageText:
//
//  Not found non-active token range to be activated.
//
#define BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT ((HRESULT)0x800413D3L)


//
// MessageId: BDK_E_TOKEN_EXPIRED
//
// MessageText:
//
//  The specified token has expired.
//
#define BDK_E_TOKEN_EXPIRED              ((HRESULT)0x800413F1L)


//
// MessageId: BDK_E_TOKEN_NOT_STARTED
//
// MessageText:
//
//  The specified token cannot be used yet.
//
#define BDK_E_TOKEN_NOT_STARTED          ((HRESULT)0x800413F6L)


//
// MessageId: BDK_E_TOKEN_RANGE_NOT_ACTIVE
//
// MessageText:
//
//  The specified token has not been activated yet.
//
#define BDK_E_TOKEN_RANGE_NOT_ACTIVE     ((HRESULT)0x800413FBL)


//
// MessageId: BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE
//
// MessageText:
//
//  The reason code specified is not valid.
//
#define BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE ((HRESULT)0x8004141EL)


//
// MessageId: BDK_E_TRACKING_GUID_NODATA
//
// MessageText:
//
//  The specified action is in progress.
//
#define BDK_E_TRACKING_GUID_NODATA       ((HRESULT)0x8004145AL)


//
// MessageId: BDK_E_DUPLICATE_TOKEN_TRACKING_GUID
//
// MessageText:
//
//  The specified tracking has already been used
//
#define BDK_E_DUPLICATE_TOKEN_TRACKING_GUID ((HRESULT)0x8004145FL)


//
// MessageId: BDK_E_ALREADY_ACTIVATED
//
// MessageText:
//
//  The specified token has already been activated
//
#define BDK_E_ALREADY_ACTIVATED          ((HRESULT)0x8004146EL)


//
// MessageId: BDK_E_INVALID_COMMITTED_STATUS
//
// MessageText:
//
//  Committed status is not valid for this API.
//
#define BDK_E_INVALID_COMMITTED_STATUS   ((HRESULT)0x80041470L)


//
// MessageId: BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION
//
// MessageText:
//
//  The description specified is not valid.
//
#define BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION ((HRESULT)0x80041473L)


//
// MessageId: BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE
//
// MessageText:
//
//  Blacklist Effective date passed was prior to the order creation date.
//
#define BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE ((HRESULT)0x80041478L)


//
// MessageId: BDK_E_TOKEN_CONSUMED
//
// MessageText:
//
//  The Token has been consumed.
//
#define BDK_E_TOKEN_CONSUMED             ((HRESULT)0x8004147DL)


//
// MessageId: BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS
//
// MessageText:
//
//  Part Number specified for the token import is not a valid part number for the associated token class.
//
#define BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS ((HRESULT)0x80041482L)


//
// MessageId: BDK_E_INVALID_EXTERNAL_REFERENCE_ID
//
// MessageText:
//
//  External reference id is too long or invalid.
//
#define BDK_E_INVALID_EXTERNAL_REFERENCE_ID ((HRESULT)0x80041483L)


//
// MessageId: BDK_E_TOKEN_ALREADY_DEACTIVATED
//
// MessageText:
//
//  The token is already deactivated.
//
#define BDK_E_TOKEN_ALREADY_DEACTIVATED  ((HRESULT)0x80041487L)


//
// MessageId: BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH
//
// MessageText:
//
//  Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.
//
#define BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH ((HRESULT)0x80041491L)


//
// MessageId: ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID
//
// MessageText:
//
//  Null parameter was passed for Token Class GUID during token class access verification.
//
#define ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID ((HRESULT)0x80041496L)


//
// MessageId: BDK_E_INVALID_BOOKMARK
//
// MessageText:
//
//  The argument specified is not a valid bookmark.
//
#define BDK_E_INVALID_BOOKMARK           ((HRESULT)0x80041484L)


//
// MessageId: BDK_E_INVALID_MAX
//
// MessageText:
//
//  The max argument must be between 1 and 50.
//
#define BDK_E_INVALID_MAX                ((HRESULT)0x80041485L)


//
// MessageId: BDK_E_INTERNAL_ERROR_TOKEN
//
// MessageText:
//
//  Internal inconsistency in Token Database.
//
#define BDK_E_INTERNAL_ERROR_TOKEN       ((HRESULT)0x80041455L)


//
// MessageId: BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD
//
// MessageText:
//
//  Unable to retrieve event ID and billing impact for event.
//
#define BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD ((HRESULT)0x8004CD14L)


//
// MessageId: BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT
//
// MessageText:
//
//  Unable to find line item matching event.
//
#define BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT ((HRESULT)0x8004CD46L)


//
// MessageId: BDK_E_CANCELREFUND_OFFSET_OF_OFFSET
//
// MessageText:
//
//  Cannot process if there is an offset of an offset.
//
#define BDK_E_CANCELREFUND_OFFSET_OF_OFFSET ((HRESULT)0x8004CD78L)


//
// MessageId: BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE
//
// MessageText:
//
//  This can't happen, both line item and related line item in the active list.
//
#define BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE ((HRESULT)0x8004CDAAL)


//
// MessageId: BDK_E_INVALID_SESSION_KEY
//
// MessageText:
//
//  The session key passed in does not pass validation checks.
//
#define BDK_E_INVALID_SESSION_KEY        ((HRESULT)0x8004768EL)


//
// MessageId: BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID
//
// MessageText:
//
//  This object ID is not entitled to get a deliverable token.
//
#define BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID ((HRESULT)0x8004A0B4L)


//
// MessageId: BDK_E_PRODUCT_KEY_NOT_AVAILABLE
//
// MessageText:
//
//  The token cannot be issued, either because the database is unavailable or there are no more unused tokens.
//
#define BDK_E_PRODUCT_KEY_NOT_AVAILABLE  ((HRESULT)0x80041488L)


//
// MessageId: BDK_E_PIN_OR_SEQ_REQUIRED
//
// MessageText:
//
//  Either PIN or Sequence number is required as input parameter to validate Token.
//
#define BDK_E_PIN_OR_SEQ_REQUIRED        ((HRESULT)0x80041489L)


//
// MessageId: BDK_E_INPUT_PARAM_MALFORMED
//
// MessageText:
//
//  Either Token Class Guid or Signature or Part Number should be specified for validating Token.
//
#define BDK_E_INPUT_PARAM_MALFORMED      ((HRESULT)0x8004148AL)


//
// MessageId: BDK_E_INVALID_ADJUSTMENT_OFFSET
//
// MessageText:
//
//  The offset must be between -1 and 365 inclusive.
//
#define BDK_E_INVALID_ADJUSTMENT_OFFSET  ((HRESULT)0x8004CDB7L)


//
// MessageId: BDK_E_INVALID_ITEM_INSTANCE_ID
//
// MessageText:
//
//  Invalid item instance ID.
//
#define BDK_E_INVALID_ITEM_INSTANCE_ID   ((HRESULT)0x8004CDDCL)


//
// MessageId: BDK_E_INVALID_REVERSE_REASON
//
// MessageText:
//
//  Invalid reason for reverse operation.
//
#define BDK_E_INVALID_REVERSE_REASON     ((HRESULT)0x8004CDDDL)


//
// MessageId: BDK_E_TOO_MANY_ITEMS_IN_PURCHASE
//
// MessageText:
//
//  Only 1 item can be purchased at once.
//
#define BDK_E_TOO_MANY_ITEMS_IN_PURCHASE ((HRESULT)0x8004CDE0L)


//
// MessageId: BDK_E_INVALID_OFFERING_TYPE
//
// MessageText:
//
//  PurchaseItem accepts only offers that are configured for item, PurchaseSubscription accepts only subscription offers and the account must be specified, or free trial offer and account must not be specified.
//
#define BDK_E_INVALID_OFFERING_TYPE      ((HRESULT)0x8004CDE1L)


//
// MessageId: BDK_E_PRICE_IS_NEGATIVE
//
// MessageText:
//
//  The price specified must be a positive value.
//
#define BDK_E_PRICE_IS_NEGATIVE          ((HRESULT)0x8004CDE2L)


//
// MessageId: BDK_E_DYNAMIC_PRICE_CONFIGURATION
//
// MessageText:
//
//  Cannot pass in a price and/or currency because it is configured on the item.
//
#define BDK_E_DYNAMIC_PRICE_CONFIGURATION ((HRESULT)0x8004CDE3L)


//
// MessageId: BDK_E_DMP_MAX_BALANCE_EXCEEDED
//
// MessageText:
//
//  The maximum allowable DMP point balance is exceeded.
//
#define BDK_E_DMP_MAX_BALANCE_EXCEEDED   ((HRESULT)0x8004CDE4L)


//
// MessageId: BDK_E_CURRENCY_MISSING
//
// MessageText:
//
//  Calling partner needs to add a currency because it is not pre-configured.
//
#define BDK_E_CURRENCY_MISSING           ((HRESULT)0x8004CDE5L)


//
// MessageId: BDK_E_PENDING_ITEM_PURCHASE
//
// MessageText:
//
//  The user already has a pending purchase for for this item that must first be cancelled or completed.
//
#define BDK_E_PENDING_ITEM_PURCHASE      ((HRESULT)0x8004CDE6L)


//
// MessageId: BDK_E_DMP_FLOW_NOT_ENABLED
//
// MessageText:
//
//  Unable to talk to DMP system.
//
#define BDK_E_DMP_FLOW_NOT_ENABLED       ((HRESULT)0x8004CDE7L)


//
// MessageId: BDK_E_ITEM_ALREADY_REVERSED
//
// MessageText:
//
//  Item has been already reversed.
//
#define BDK_E_ITEM_ALREADY_REVERSED      ((HRESULT)0x8004CDE8L)


//
// MessageId: BDK_E_ITEM_NOT_FULFILLED
//
// MessageText:
//
//  Reversing an item that has not been fulfilled.
//
#define BDK_E_ITEM_NOT_FULFILLED         ((HRESULT)0x8004CDE9L)


//
// MessageId: BDK_E_DMP_UNKNOWN_ERROR
//
// MessageText:
//
//  Unknown DMP error has occurred.
//
#define BDK_E_DMP_UNKNOWN_ERROR          ((HRESULT)0x8004CDEAL)


//
// MessageId: BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE
//
// MessageText:
//
//  Payment method type does not support operation.
//
#define BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE ((HRESULT)0x8004CDECL)


//
// MessageId: BDK_E_INVALID_CANCEL_TRANSACTION_RESULT
//
// MessageText:
//
//  Redirect vendor returned an invalid CancelTransaction result.
//
#define BDK_E_INVALID_CANCEL_TRANSACTION_RESULT ((HRESULT)0x8004CDEDL)


//
// MessageId: BDK_E_CVM_MISSING
//
// MessageText:
//
//  CVM code Missing
//
#define BDK_E_CVM_MISSING                ((HRESULT)0x8004CDEEL)


//
// MessageId: BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL
//
// MessageText:
//
//  A fre Trial cannot be purchased using an account. Use only the PUID
//
#define BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL ((HRESULT)0x8004CDEFL)


//
// MessageId: BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH
//
// MessageText:
//
//  Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch
//
#define BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH ((HRESULT)0x8004CDF0L)


//
// MessageId: BDK_E_DONOR_BENEFICIARY_SAME
//
// MessageText:
//
//  The donor and the beneficiary are the same.
//
#define BDK_E_DONOR_BENEFICIARY_SAME     ((HRESULT)0x8004CDF1L)


//
// MessageId: BDK_E_RENEWAL_DOES_NOT_EXISTS
//
// MessageText:
//
//  The renewal does not exists.
//
#define BDK_E_RENEWAL_DOES_NOT_EXISTS    ((HRESULT)0x8004AC9AL)


//
// MessageId: BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS
//
// MessageText:
//
//  The token schedule rennewal exists for this offer.
//
#define BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS ((HRESULT)0x8004AC9CL)


//
// MessageId: BDK_E_INVALID_DISCOUNT
//
// MessageText:
//
//  Specified Discount is invalid.
//
#define BDK_E_INVALID_DISCOUNT           ((HRESULT)0x8004ACADL)


//
// MessageId: BDK_E_INSERT_DISCOUNT
//
// MessageText:
//
//  Could not insert into a discount table.
//
#define BDK_E_INSERT_DISCOUNT            ((HRESULT)0x8004ACB2L)


//
// MessageId: BDK_E_DISCOUNT_ALREADY_APPLIED
//
// MessageText:
//
//  Only one discount permitted per subscription.
//
#define BDK_E_DISCOUNT_ALREADY_APPLIED   ((HRESULT)0x8004ACB7L)


//
// MessageId: BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN
//
// MessageText:
//
//  Token is a discount coupon yet no discount was passed.
//
#define BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN ((HRESULT)0x8004ACBCL)


//
// MessageId: BDK_E_DISCOUNT_TOKEN
//
// MessageText:
//
//  Token is a discount coupon and cannot be associated with a deal.
//
#define BDK_E_DISCOUNT_TOKEN             ((HRESULT)0x8004ACC1L)


//
// MessageId: BDK_E_INSERT_DISCOUNT_LOCALIZE
//
// MessageText:
//
//  Failed to insert record into discount_localize table.
//
#define BDK_E_INSERT_DISCOUNT_LOCALIZE   ((HRESULT)0x8004ACC6L)


//
// MessageId: BDK_E_DISCOUNT_USAGE_EXCEEDED
//
// MessageText:
//
//  Per Account Usage limit was exceeded for discount.
//
#define BDK_E_DISCOUNT_USAGE_EXCEEDED    ((HRESULT)0x8004ACCBL)


//
// MessageId: BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH
//
// MessageText:
//
//  Token class and discount are not a valid combination.
//
#define BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH ((HRESULT)0x8004ACD0L)


//
// MessageId: BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER
//
// MessageText:
//
//  Partner does not have access to the specified customer type
//
#define BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER ((HRESULT)0x8004AD18L)


//
// MessageId: BDK_E_NULL_CATEGORY
//
// MessageText:
//
//  Category should not be null.
//
#define BDK_E_NULL_CATEGORY              ((HRESULT)0x8004AC62L)


//
// MessageId: BDK_E_NULL_ACCOUNTID
//
// MessageText:
//
//  Account ID cannot be null.
//
#define BDK_E_NULL_ACCOUNTID             ((HRESULT)0x8004AC63L)


//
// MessageId: BDK_E_NULL_SUBSCRIPTIONREFID
//
// MessageText:
//
//  Subscription Ref ID cannot be null.
//
#define BDK_E_NULL_SUBSCRIPTIONREFID     ((HRESULT)0x8004AC64L)


//
// MessageId: BDK_E_INVALID_SURVEYRESULTCODE
//
// MessageText:
//
//  Invalid Survey Result Code.
//
#define BDK_E_INVALID_SURVEYRESULTCODE   ((HRESULT)0x8004AC65L)


//
// MessageId: BDK_E_CD_NOTFOUND
//
// MessageText:
//
//  CD not found.
//
#define BDK_E_CD_NOTFOUND                ((HRESULT)0x8004AC66L)


//
// MessageId: BDK_E_INVALID_ACCOUNTID
//
// MessageText:
//
//  Invalid Account ID.
//
#define BDK_E_INVALID_ACCOUNTID          ((HRESULT)0x8004AC67L)


//
// MessageId: BDK_E_INVALID_ANONYMOUS_INFO_XML
//
// MessageText:
//
//  Invalid AnonymousInfo Xml.
//
#define BDK_E_INVALID_ANONYMOUS_INFO_XML ((HRESULT)0x8004AC68L)


//
// MessageId: BDK_E_UNSUPPORTED_OBJECT_TYPE
//
// MessageText:
//
//  Unsupported object type.
//
#define BDK_E_UNSUPPORTED_OBJECT_TYPE    ((HRESULT)0x8004AC69L)


//
// MessageId: BDK_E_INVALID_PHONE_XML
//
// MessageText:
//
//  Invalid Phone XML.
//
#define BDK_E_INVALID_PHONE_XML          ((HRESULT)0x8004AC6AL)


//
// MessageId: BDK_E_INVALID_REQUESTOR_INFO
//
// MessageText:
//
//  Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters.
//
#define BDK_E_INVALID_REQUESTOR_INFO     ((HRESULT)0x8004AC6CL)


//
// MessageId: BDK_E_PENDING_TRANSACTIONS
//
// MessageText:
//
//  There are pending transactions on this deal or subscription.
//
#define BDK_E_PENDING_TRANSACTIONS       ((HRESULT)0x8004ACAAL)


//
// MessageId: BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH
//
// MessageText:
//
//  The lineitem id and settlement id do not match
//
#define BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH ((HRESULT)0x800452D0L)


//
// MessageId: BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS
//
// MessageText:
//
//  Invalid original charge details
//
#define BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS ((HRESULT)0x800452D5L)


//
// MessageId: BDK_E_PARTIAL_CHAREGBACK
//
// MessageText:
//
//  Partial Chargeback cannot be Processed
//
#define BDK_E_PARTIAL_CHAREGBACK         ((HRESULT)0x800452D8L)


//
// MessageId: BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL
//
// MessageText:
//
//  Invalid lineitem id for reversal
//
#define BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL ((HRESULT)0x800452DAL)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_DATE
//
// MessageText:
//
//  Invalid chargeback date. Chargeback date must greater or equals to original settlement date
//
#define BDK_E_INVALID_CHARGEBACK_DATE    ((HRESULT)0x800452E9L)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_AMOUNT
//
// MessageText:
//
//  Invalid chargeback amount.
//
#define BDK_E_INVALID_CHARGEBACK_AMOUNT  ((HRESULT)0x800452EEL)


//
// MessageId: BDK_E_ALREADY_OFFSET_TAX
//
// MessageText:
//
//  Tax was already offset for this line item.
//
#define BDK_E_ALREADY_OFFSET_TAX         ((HRESULT)0x800452F1L)


//
// MessageId: BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED
//
// MessageText:
//
//  mappoint is not enabled for the country code.
//
#define BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED ((HRESULT)0x80049CEBL)


//
// MessageId: BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT
//
// MessageText:
//
//  SCS had error connecting to mappoint due to some network problems.
//
#define BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT ((HRESULT)0x8004CE4FL)


//
// MessageId: BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT
//
// MessageText:
//
//  SCS had some internal error connecting that is preventing connection to mappoint.
//
#define BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT ((HRESULT)0x8004CE50L)


//
// MessageId: BDK_E_ZERO_ADDRESSES_BY_MAPPOINT
//
// MessageText:
//
//  Mappoint returned 0 addresses.
//
#define BDK_E_ZERO_ADDRESSES_BY_MAPPOINT ((HRESULT)0x8004CE51L)


//
// MessageId: BDK_E_UNKNOWN_ERROR
//
// MessageText:
//
//  UNKNOWN ERROR in MAPPOINT API.
//
#define BDK_E_UNKNOWN_ERROR              ((HRESULT)0x8004CE52L)


//
// MessageId: BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR
//
// MessageText:
//
//  UNKNOWN ERROR ENCOUNTERED.
//
#define BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR ((HRESULT)0x8004ACA4L)


//
// MessageId: BDK_E_INVALID_ADDRESSINFOXML
//
// MessageText:
//
//  Invalid AddressInfo Xml.
//
#define BDK_E_INVALID_ADDRESSINFOXML     ((HRESULT)0x8004CE54L)


//
// MessageId: BDK_E_POST_BOX_ERROR_MAPPOINT
//
// MessageText:
//
//  Mappoint does not support Post Box Addresses currently.
//
#define BDK_E_POST_BOX_ERROR_MAPPOINT    ((HRESULT)0x8004CE55L)


//
// MessageId: BDK_E_MAPPOINT_CONNECTION_MAPPOINT
//
// MessageText:
//
//  The connection to Mappoint has timed out.
//
#define BDK_E_MAPPOINT_CONNECTION_MAPPOINT ((HRESULT)0x8004CE56L)


//
// MessageId: BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS
//
// MessageText:
//
//  Invalid Chargeback details provided as input
//
#define BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS ((HRESULT)0x8004D818L)


//
// MessageId: BDK_E_CHARGEBACK_NOT_FOUND
//
// MessageText:
//
//  Chargeback id not found
//
#define BDK_E_CHARGEBACK_NOT_FOUND       ((HRESULT)0x8004D81DL)


//
// MessageId: BDK_E_CHARGEBACK_NOT_MATCH
//
// MessageText:
//
//  Chargeback id did not match
//
#define BDK_E_CHARGEBACK_NOT_MATCH       ((HRESULT)0x8004D827L)


//
// MessageId: BDK_E_DOUBLE_CHARGEBACK
//
// MessageText:
//
//  Double chargeback
//
#define BDK_E_DOUBLE_CHARGEBACK          ((HRESULT)0x8004D836L)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_LINEITEM_ID
//
// MessageText:
//
//  Invalid chargebacklineitem id
//
#define BDK_E_INVALID_CHARGEBACK_LINEITEM_ID ((HRESULT)0x8004D83BL)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_REVERSAL_ID
//
// MessageText:
//
//  Invalid reversal chargeback id
//
#define BDK_E_INVALID_CHARGEBACK_REVERSAL_ID ((HRESULT)0x8004D84AL)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID
//
// MessageText:
//
//  Invalid chargeback for reversal chargeback id
//
#define BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID ((HRESULT)0x8004D84FL)


//
// MessageId: BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID
//
// MessageText:
//
//  invalid lineitem id for chargeback id
//
#define BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID ((HRESULT)0x8004D854L)


//
// MessageId: BDK_E_INVALID_LINEITEM_TYPE
//
// MessageText:
//
//  invalid lineitem id
//
#define BDK_E_INVALID_LINEITEM_TYPE      ((HRESULT)0x8004D859L)


//
// MessageId: BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL
//
// MessageText:
//
//  Double chargeback for reversal
//
#define BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL ((HRESULT)0x8004D868L)


//
// MessageId: BDK_E_COUNTRY_NOT_SUPPORTED
//
// MessageText:
//
//  The country of the address is not supported at this time
//
#define BDK_E_COUNTRY_NOT_SUPPORTED      ((HRESULT)0x8004ACA5L)


//
// MessageId: BDK_E_COUNTRY_MAPPOINT_DISABLED
//
// MessageText:
//
//  SCS has temporarily disabled MAPPOINT support for this country
//
#define BDK_E_COUNTRY_MAPPOINT_DISABLED  ((HRESULT)0x8004ACA6L)


//
// MessageId: BDK_E_INVALID_PARAMETER
//
// MessageText:
//
//  The input parameter is incorrect
//
#define BDK_E_INVALID_PARAMETER          ((HRESULT)0x8004ACA7L)


//
// MessageId: BDK_E_INVALID_CHARGEBACK_ID
//
// MessageText:
//
//  Invalid ChargebackID Generation.
//
#define BDK_E_INVALID_CHARGEBACK_ID      ((HRESULT)0x8004283CL)


//
// MessageId: BDK_E_CHARGEBACK_PROCESSING_FAILURE
//
// MessageText:
//
//  Error when Chargeback Processing Failure.
//
#define BDK_E_CHARGEBACK_PROCESSING_FAILURE ((HRESULT)0x8004283DL)


//
// MessageId: BDK_E_INVALID_MERCHANT_REFERENCE
//
// MessageText:
//
//  Invalid Merchant Reference Number.
//
#define BDK_E_INVALID_MERCHANT_REFERENCE ((HRESULT)0x8004283EL)


//
// MessageId: BDK_E_CHARGEBACK_INFO_MISSING
//
// MessageText:
//
//  Error when any input details missing.
//
#define BDK_E_CHARGEBACK_INFO_MISSING    ((HRESULT)0x8004283FL)


//
// MessageId: BDK_E_RECORD_CHARGEBACK_FAILED
//
// MessageText:
//
//  Error while recording chargeback/reversal in Chargeback History table.
//
#define BDK_E_RECORD_CHARGEBACK_FAILED   ((HRESULT)0x80042840L)


//
// MessageId: BDK_E_DOUBLE_CHARGEBACK_REVERSAL
//
// MessageText:
//
//  Double Chargeback Reversal
//
#define BDK_E_DOUBLE_CHARGEBACK_REVERSAL ((HRESULT)0x80042841L)


//
// MessageId: BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK
//
// MessageText:
//
//  Chargeback Processing Reversal
//
#define BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK ((HRESULT)0x80042842L)


//
// MessageId: BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION
//
// MessageText:
//
//  Payment instrument not associated with subscription
//
#define BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION ((HRESULT)0x80042843L)


//
// MessageId: BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED
//
// MessageText:
//
//  Subscription already converted or renewed
//
#define BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED ((HRESULT)0x80042844L)


//
// MessageId: BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING
//
// MessageText:
//
//  Merchant Reference Number missing
//
#define BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING ((HRESULT)0x80042845L)


//
// MessageId: BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER
//
// MessageText:
//
//  Invalid Encrypt Account number
//
#define BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER ((HRESULT)0x80042846L)


//
// MessageId: BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL
//
// MessageText:
//
//  Subscription has been scheduled to renew
//
#define BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL ((HRESULT)0x80042847L)


//
// MessageId: BDK_E_PROFILE_ALREADY_EXISTS
//
// MessageText:
//
//  Account holder's profile already exists.
//
#define BDK_E_PROFILE_ALREADY_EXISTS     ((HRESULT)0x80042848L)


//
// MessageId: BDK_E_PROFILE_DOES_NOT_EXIST
//
// MessageText:
//
//  Account holder's profile does not exist.
//
#define BDK_E_PROFILE_DOES_NOT_EXIST     ((HRESULT)0x80042849L)


//
// MessageId: BDK_E_ACCOUNT_WITHOUT_ADDRESS
//
// MessageText:
//
//  Account does not have an address associated with it.
//
#define BDK_E_ACCOUNT_WITHOUT_ADDRESS    ((HRESULT)0x8004284AL)


//
// MessageId: BDK_E_NO_PAYOUT_PREFERENCE
//
// MessageText:
//
//  Payout preference (default) is not set.
//
#define BDK_E_NO_PAYOUT_PREFERENCE       ((HRESULT)0x8004284BL)


//
// MessageId: BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE
//
// MessageText:
//
//  Payout preference (default) can not be deleted.
//
#define BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE ((HRESULT)0x8004284CL)


//
// MessageId: BDK_E_INVALID_PAYUSERINFOXML
//
// MessageText:
//
//  Invalid PayUserInfo XML.
//
#define BDK_E_INVALID_PAYUSERINFOXML     ((HRESULT)0x8004284DL)


//
// MessageId: BDK_E_INVALID_USERPROFILEXML
//
// MessageText:
//
//  Invalid UserProfile XML.
//
#define BDK_E_INVALID_USERPROFILEXML     ((HRESULT)0x8004284EL)


//
// MessageId: BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID
//
// MessageText:
//
//  Account ID must not be specified.
//
#define BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID ((HRESULT)0x8004284FL)


//
// MessageId: BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED
//
// MessageText:
//
//  Description length exceeded
//
#define BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED ((HRESULT)0x80042850L)


//
// MessageId: BDK_E_RIME_REJECTED
//
// MessageText:
//
//  RiME returns "Rejected"
//
#define BDK_E_RIME_REJECTED              ((HRESULT)0x80042851L)


//
// MessageId: BDK_E_RIME_INVALID_VALUE
//
// MessageText:
//
//  Invalid Values were sent to RiME
//
#define BDK_E_RIME_INVALID_VALUE         ((HRESULT)0x80042852L)


//
// MessageId: BDK_E_REFERRAL_CODE_NOT_FOUND
//
// MessageText:
//
//  Referral code not found in SCS database
//
#define BDK_E_REFERRAL_CODE_NOT_FOUND    ((HRESULT)0x8004AC59L)


//
// MessageId: ERROR_MISSING_PROV_INFO
//
// MessageText:
//
//  There is no existing provisioning information to complete this call
//
#define ERROR_MISSING_PROV_INFO          ((HRESULT)0x8004D2FDL)


//
// MessageId: BDK_E_INVALID_RESOURCE_TYPE
//
// MessageText:
//
//  Invalid Resource Type
//
#define BDK_E_INVALID_RESOURCE_TYPE      ((HRESULT)0x8004AC5AL)


//
// MessageId: BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED
//
// MessageText:
//
//  fail when submit to payment provider
//
#define BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED ((HRESULT)0x80044E2AL)


//
// MessageId: BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED
//
// MessageText:
//
//  declined when submit to payment provider
//
#define BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED ((HRESULT)0x80044E2BL)


//
// MessageId: BDK_E_ENCRYPTION_FAILURE
//
// MessageText:
//
//  fail to encrypt file
//
#define BDK_E_ENCRYPTION_FAILURE         ((HRESULT)0x80044E2CL)


//
// MessageId: BDK_E_DMP_FIRST
//
// MessageText:
//
//  BDK_E_DMP_FIRST
//
#define BDK_E_DMP_FIRST                  ((HRESULT)0x8004FA00L)


//
// MessageId: BDK_E_DMP_LAST
//
// MessageText:
//
//  BDK_E_DMP_LAST
//
#define BDK_E_DMP_LAST                   ((HRESULT)0x8004FDE7L)


//
// MessageId: BDK_E_INVALID_TARGET_USER_INFORMATION
//
// MessageText:
//
//  Invalid target user information specified
//
#define BDK_E_INVALID_TARGET_USER_INFORMATION ((HRESULT)0x80047918L)


//
// MessageId: BDK_E_INVALID_DELEGATE_USER_INFORMATION
//
// MessageText:
//
//  Invalid delegate user information
//
#define BDK_E_INVALID_DELEGATE_USER_INFORMATION ((HRESULT)0x80047919L)


//
// MessageId: BDK_E_INVALID_SOURCE_USER_INFORMATION
//
// MessageText:
//
//  Invalid source information
//
#define BDK_E_INVALID_SOURCE_USER_INFORMATION ((HRESULT)0x8004791AL)


//
// MessageId: BDK_E_INVALID_TRANSACTION_INFORMATION
//
// MessageText:
//
//  Invalid transaction Id
//
#define BDK_E_INVALID_TRANSACTION_INFORMATION ((HRESULT)0x8004791BL)


//
// MessageId: BDK_E_NO_MATCHING_TRANSACTION
//
// MessageText:
//
//  Transaction information passed in does not match the information stored
//
#define BDK_E_NO_MATCHING_TRANSACTION    ((HRESULT)0x8004791CL)


//
// MessageId: BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION
//
// MessageText:
//
//  Unable to find transaction in PENDING_PAYOUT state matching the input parameters
//
#define BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION ((HRESULT)0x8004791DL)


//
// MessageId: BDK_E_NO_MATCHING_PENDING_TRANSACTION
//
// MessageText:
//
//  Unable to find transaction in PENDING state matching the input parameters
//
#define BDK_E_NO_MATCHING_PENDING_TRANSACTION ((HRESULT)0x8004791EL)


//
// MessageId: BDK_E_ORDER_LAYER_FIRST
//
// MessageText:
//
//  BDK_E_ORDER_LAYER_FIRST
//
#define BDK_E_ORDER_LAYER_FIRST          ((HRESULT)0x8004DAC1L)


//
// MessageId: BDK_E_ORDER_LAYER_LAST
//
// MessageText:
//
//  BDK_E_ORDER_LAYER_LAST
//
#define BDK_E_ORDER_LAYER_LAST           ((HRESULT)0x8004DEA8L)


//
// MessageId: BDK_E_TRANSACTION_LAYER_FIRST
//
// MessageText:
//
//  BDK_E_TRANSACTION_LAYER_FIRST
//
#define BDK_E_TRANSACTION_LAYER_FIRST    ((HRESULT)0x8004DEA9L)


//
// MessageId: BDK_E_TRANSACTION_LAYER_LAST
//
// MessageText:
//
//  BDK_E_TRANSACTION_LAYER_LAST
//
#define BDK_E_TRANSACTION_LAYER_LAST     ((HRESULT)0x8004E290L)


//
// MessageId: SCS_E_CERT_INAVLID
//
// MessageText:
//
//  SCS_E_CERT_INAVLID
//
#define SCS_E_CERT_INAVLID               ((HRESULT)0x8004E678L)


//
// MessageId: SCS_E_INAVLID_CALLING_PARTNER
//
// MessageText:
//
//  SCS_E_INAVLID_CALLING_PARTNER
//
#define SCS_E_INAVLID_CALLING_PARTNER    ((HRESULT)0x8004E679L)


//
// MessageId: BDK_E_RISK_EVALUATION_FAILED
//
// MessageText:
//
//  BDK_E_RISK_EVALUATION_FAILED
//
#define BDK_E_RISK_EVALUATION_FAILED     ((HRESULT)0x8004FDE9L)


//
// MessageId: BDK_E_RISK_EVALUATION_EXCEPTION
//
// MessageText:
//
//  BDK_E_RISK_EVALUATION_EXCEPTION
//
#define BDK_E_RISK_EVALUATION_EXCEPTION  ((HRESULT)0x8004FDEAL)


//
// MessageId: BDK_E_RISK_EVALUATION_UNDEFINED
//
// MessageText:
//
//  BDK_E_RISK_EVALUATION_UNDEFINED
//
#define BDK_E_RISK_EVALUATION_UNDEFINED  ((HRESULT)0x8004FDEBL)


//
// MessageId: BDK_E_RISK_CONFIGURATION_ERROR
//
// MessageText:
//
//  BDK_E_RISK_CONFIGURATION_ERROR
//
#define BDK_E_RISK_CONFIGURATION_ERROR   ((HRESULT)0x8004FDECL)


//
// MessageId: BDK_E_RISK_NEXT
//
// MessageText:
//
//  BDK_E_RISK_NEXT
//
#define BDK_E_RISK_NEXT                  ((HRESULT)0x8004FDEDL)


//
// MessageId: BDK_E_DAV_APARTMENT
//
// MessageText:
//
//  Apartment number missing or not found
//
#define BDK_E_DAV_APARTMENT              ((HRESULT)0x8004FE4CL)


//
// MessageId: BDK_E_DAV_INSUFFICIENT
//
// MessageText:
//
//  Insufficient address information
//
#define BDK_E_DAV_INSUFFICIENT           ((HRESULT)0x8004FE4DL)


//
// MessageId: BDK_E_DAV_ID
//
// MessageText:
//
//  House number or PO box not found
//
#define BDK_E_DAV_ID                     ((HRESULT)0x8004FE4EL)


//
// MessageId: BDK_E_DAV_MULTIPLE
//
// MessageText:
//
//  Multiple address matches found
//
#define BDK_E_DAV_MULTIPLE               ((HRESULT)0x8004FE4FL)


//
// MessageId: BDK_E_DAV_POBOX
//
// MessageText:
//
//  PO box identifier out of range
//
#define BDK_E_DAV_POBOX                  ((HRESULT)0x8004FE50L)


//
// MessageId: BDK_E_DAV_ROUTE
//
// MessageText:
//
//  Route service identified out of range
//
#define BDK_E_DAV_ROUTE                  ((HRESULT)0x8004FE51L)


//
// MessageId: BDK_E_DAV_STREET
//
// MessageText:
//
//  Street name not found
//
#define BDK_E_DAV_STREET                 ((HRESULT)0x8004FE52L)


//
// MessageId: BDK_E_DAV_POSTAL
//
// MessageText:
//
//  Postal code not found
//
#define BDK_E_DAV_POSTAL                 ((HRESULT)0x8004FE53L)


//
// MessageId: BDK_E_DAV_GENERAL
//
// MessageText:
//
//  Genreal address error
//
#define BDK_E_DAV_GENERAL                ((HRESULT)0x8004FE54L)


//
// MessageId: BDK_E_DAV_MISSING_DATA
//
// MessageText:
//
//  Missing required address field(s)
//
#define BDK_E_DAV_MISSING_DATA           ((HRESULT)0x8004FE55L)


//
// MessageId: BDK_E_DAV_INVALID_DATA
//
// MessageText:
//
//  Invalid address field(s)
//
#define BDK_E_DAV_INVALID_DATA           ((HRESULT)0x8004FE56L)


//
// MessageId: BDK_E_DAV_SYSTEM_FAILURE
//
// MessageText:
//
//  System failure during address check
//
#define BDK_E_DAV_SYSTEM_FAILURE         ((HRESULT)0x8004FE57L)


//
// MessageId: BDK_E_DAV_TIMEOUT
//
// MessageText:
//
//  Timeout during DAV check
//
#define BDK_E_DAV_TIMEOUT                ((HRESULT)0x8004FE58L)


//
// MessageId: BDK_E_DAV_DISABLED
//
// MessageText:
//
//  Delivery Address Verification system is not available at this time
//
#define BDK_E_DAV_DISABLED               ((HRESULT)0x8004FE59L)


//
// MessageId: BDK_E_RISK_LAST
//
// MessageText:
//
//  BDK_E_RISK_LAST
//
#define BDK_E_RISK_LAST                  ((HRESULT)0x8004FFFFL)

//Please avoid using message id starting with 60000, reserved for TaxWare
#endif // __bdkerror_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\7.5\inc\psoconnector.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for psoconnector.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __psoconnector_h__
#define __psoconnector_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPsoConnector_FWD_DEFINED__
#define __IPsoConnector_FWD_DEFINED__
typedef interface IPsoConnector IPsoConnector;
#endif 	/* __IPsoConnector_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mssoap.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IPsoConnector_INTERFACE_DEFINED__
#define __IPsoConnector_INTERFACE_DEFINED__

/* interface IPsoConnector */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPsoConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECFEB027-7719-4537-8E5D-40AA0ECE4896")
    IPsoConnector : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [retval][out] */ ISOAPClient **psoapClient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PoolConnections( 
            /* [in] */ LONG lConnectionCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PoolConnections( 
            /* [retval][out] */ LONG *lConnectionCount) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_WsdlLocation( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WsdlLocation( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerEnvironment( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerEnvironment( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerUsername( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerUsername( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerPassword( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerPassword( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ LONG lErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ LONG *lErrorCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorDescription( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoImpersonateClient( 
            /* [in] */ VARIANT_BOOL vImpersonate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoImpersonateClient( 
            /* [retval][out] */ VARIANT_BOOL *vImpersonate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshConnection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPsoConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPsoConnector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPsoConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPsoConnector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPsoConnector * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPsoConnector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPsoConnector * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPsoConnector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPsoConnector * This,
            /* [retval][out] */ ISOAPClient **psoapClient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPsoConnector * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PoolConnections )( 
            IPsoConnector * This,
            /* [in] */ LONG lConnectionCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PoolConnections )( 
            IPsoConnector * This,
            /* [retval][out] */ LONG *lConnectionCount);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WsdlLocation )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WsdlLocation )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerEnvironment )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerEnvironment )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerUsername )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerUsername )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerPassword )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerPassword )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorCode )( 
            IPsoConnector * This,
            /* [in] */ LONG lErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IPsoConnector * This,
            /* [retval][out] */ LONG *lErrorCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorDescription )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoImpersonateClient )( 
            IPsoConnector * This,
            /* [in] */ VARIANT_BOOL vImpersonate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoImpersonateClient )( 
            IPsoConnector * This,
            /* [retval][out] */ VARIANT_BOOL *vImpersonate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshConnection )( 
            IPsoConnector * This);
        
        END_INTERFACE
    } IPsoConnectorVtbl;

    interface IPsoConnector
    {
        CONST_VTBL struct IPsoConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPsoConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPsoConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPsoConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPsoConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPsoConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPsoConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPsoConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPsoConnector_Connect(This,psoapClient)	\
    (This)->lpVtbl -> Connect(This,psoapClient)

#define IPsoConnector_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IPsoConnector_get_Version(This,pbstrVal)	\
    (This)->lpVtbl -> get_Version(This,pbstrVal)

#define IPsoConnector_put_PoolConnections(This,lConnectionCount)	\
    (This)->lpVtbl -> put_PoolConnections(This,lConnectionCount)

#define IPsoConnector_get_PoolConnections(This,lConnectionCount)	\
    (This)->lpVtbl -> get_PoolConnections(This,lConnectionCount)

#define IPsoConnector_put_WsdlLocation(This,bstrVal)	\
    (This)->lpVtbl -> put_WsdlLocation(This,bstrVal)

#define IPsoConnector_get_WsdlLocation(This,pbstrVal)	\
    (This)->lpVtbl -> get_WsdlLocation(This,pbstrVal)

#define IPsoConnector_put_PartnerEnvironment(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerEnvironment(This,bstrVal)

#define IPsoConnector_get_PartnerEnvironment(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerEnvironment(This,pbstrVal)

#define IPsoConnector_put_PartnerUsername(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerUsername(This,bstrVal)

#define IPsoConnector_get_PartnerUsername(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerUsername(This,pbstrVal)

#define IPsoConnector_put_PartnerPassword(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerPassword(This,bstrVal)

#define IPsoConnector_get_PartnerPassword(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerPassword(This,pbstrVal)

#define IPsoConnector_put_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> put_ErrorCode(This,lErrorCode)

#define IPsoConnector_get_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,lErrorCode)

#define IPsoConnector_put_ErrorDescription(This,bstrVal)	\
    (This)->lpVtbl -> put_ErrorDescription(This,bstrVal)

#define IPsoConnector_get_ErrorDescription(This,pbstrVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrVal)

#define IPsoConnector_put_CoImpersonateClient(This,vImpersonate)	\
    (This)->lpVtbl -> put_CoImpersonateClient(This,vImpersonate)

#define IPsoConnector_get_CoImpersonateClient(This,vImpersonate)	\
    (This)->lpVtbl -> get_CoImpersonateClient(This,vImpersonate)

#define IPsoConnector_RefreshConnection(This)	\
    (This)->lpVtbl -> RefreshConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_Connect_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ ISOAPClient **psoapClient);


void __RPC_STUB IPsoConnector_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_Initialize_Proxy( 
    IPsoConnector * This);


void __RPC_STUB IPsoConnector_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_Version_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PoolConnections_Proxy( 
    IPsoConnector * This,
    /* [in] */ LONG lConnectionCount);


void __RPC_STUB IPsoConnector_put_PoolConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PoolConnections_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ LONG *lConnectionCount);


void __RPC_STUB IPsoConnector_get_PoolConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_WsdlLocation_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_WsdlLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_WsdlLocation_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_WsdlLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerEnvironment_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerEnvironment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerEnvironment_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerEnvironment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerUsername_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerUsername_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerPassword_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerPassword_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_ErrorCode_Proxy( 
    IPsoConnector * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IPsoConnector_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_ErrorCode_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ LONG *lErrorCode);


void __RPC_STUB IPsoConnector_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_ErrorDescription_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_ErrorDescription_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_CoImpersonateClient_Proxy( 
    IPsoConnector * This,
    /* [in] */ VARIANT_BOOL vImpersonate);


void __RPC_STUB IPsoConnector_put_CoImpersonateClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_CoImpersonateClient_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ VARIANT_BOOL *vImpersonate);


void __RPC_STUB IPsoConnector_get_CoImpersonateClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_RefreshConnection_Proxy( 
    IPsoConnector * This);


void __RPC_STUB IPsoConnector_RefreshConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPsoConnector_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\7.5\inc\psoencrypter.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for psoencrypter.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __psoencrypter_h__
#define __psoencrypter_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPsoEncrypter_FWD_DEFINED__
#define __IPsoEncrypter_FWD_DEFINED__
typedef interface IPsoEncrypter IPsoEncrypter;
#endif 	/* __IPsoEncrypter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IPsoEncrypter_INTERFACE_DEFINED__
#define __IPsoEncrypter_INTERFACE_DEFINED__

/* interface IPsoEncrypter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPsoEncrypter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77298B76-8915-40c8-93E6-FBE5DDEDC5C1")
    IPsoEncrypter : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Provider( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ LONG lErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ LONG *lErrorCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorDescription( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertObjectIDToAcctID( 
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateGUID( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertServiceRefIDToSubID( 
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSessionKey( 
            /* [retval][out] */ BSTR *pbstrSessionKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR bstrEncryptedText,
            /* [in] */ BSTR bstrSessionKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSessionKeyEx( 
            /* [retval][out] */ BSTR *pbstrSessionKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptEx( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptToByteArray( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptExToByteArray( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPsoEncrypterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPsoEncrypter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPsoEncrypter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPsoEncrypter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPsoEncrypter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPsoEncrypter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPsoEncrypter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPsoEncrypter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPsoEncrypter * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Provider )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorCode )( 
            IPsoEncrypter * This,
            /* [in] */ LONG lErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IPsoEncrypter * This,
            /* [retval][out] */ LONG *lErrorCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorDescription )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConvertObjectIDToAcctID )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateGUID )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConvertServiceRefIDToSubID )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSessionKey )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrSessionKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrEncryptedText,
            /* [in] */ BSTR bstrSessionKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSessionKeyEx )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrSessionKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptEx )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptToByteArray )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ VARIANT *pVariant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptExToByteArray )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ VARIANT *pVariant);
        
        END_INTERFACE
    } IPsoEncrypterVtbl;

    interface IPsoEncrypter
    {
        CONST_VTBL struct IPsoEncrypterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPsoEncrypter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPsoEncrypter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPsoEncrypter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPsoEncrypter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPsoEncrypter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPsoEncrypter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPsoEncrypter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPsoEncrypter_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IPsoEncrypter_get_Provider(This,pbstrVal)	\
    (This)->lpVtbl -> get_Provider(This,pbstrVal)

#define IPsoEncrypter_put_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> put_ErrorCode(This,lErrorCode)

#define IPsoEncrypter_get_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,lErrorCode)

#define IPsoEncrypter_put_ErrorDescription(This,bstrVal)	\
    (This)->lpVtbl -> put_ErrorDescription(This,bstrVal)

#define IPsoEncrypter_get_ErrorDescription(This,pbstrVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrVal)

#define IPsoEncrypter_Encrypt(This,bstrBlob,bstrKey,pbstrResult)	\
    (This)->lpVtbl -> Encrypt(This,bstrBlob,bstrKey,pbstrResult)

#define IPsoEncrypter_ConvertObjectIDToAcctID(This,bstrVal,pbstrValOut)	\
    (This)->lpVtbl -> ConvertObjectIDToAcctID(This,bstrVal,pbstrValOut)

#define IPsoEncrypter_GenerateGUID(This,pbstrVal)	\
    (This)->lpVtbl -> GenerateGUID(This,pbstrVal)

#define IPsoEncrypter_ConvertServiceRefIDToSubID(This,bstrVal,pbstrValOut)	\
    (This)->lpVtbl -> ConvertServiceRefIDToSubID(This,bstrVal,pbstrValOut)

#define IPsoEncrypter_GenerateSessionKey(This,pbstrSessionKey)	\
    (This)->lpVtbl -> GenerateSessionKey(This,pbstrSessionKey)

#define IPsoEncrypter_Decrypt(This,bstrEncryptedText,bstrSessionKey,pbstrResult)	\
    (This)->lpVtbl -> Decrypt(This,bstrEncryptedText,bstrSessionKey,pbstrResult)

#define IPsoEncrypter_GenerateSessionKeyEx(This,pbstrSessionKey)	\
    (This)->lpVtbl -> GenerateSessionKeyEx(This,pbstrSessionKey)

#define IPsoEncrypter_EncryptEx(This,bstrBlob,bstrKey,pbstrResult)	\
    (This)->lpVtbl -> EncryptEx(This,bstrBlob,bstrKey,pbstrResult)

#define IPsoEncrypter_EncryptToByteArray(This,bstrBlob,bstrKey,pVariant)	\
    (This)->lpVtbl -> EncryptToByteArray(This,bstrBlob,bstrKey,pVariant)

#define IPsoEncrypter_EncryptExToByteArray(This,bstrBlob,bstrKey,pVariant)	\
    (This)->lpVtbl -> EncryptExToByteArray(This,bstrBlob,bstrKey,pVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Initialize_Proxy( 
    IPsoEncrypter * This);


void __RPC_STUB IPsoEncrypter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_Provider_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_get_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_put_ErrorCode_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IPsoEncrypter_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_ErrorCode_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ LONG *lErrorCode);


void __RPC_STUB IPsoEncrypter_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_put_ErrorDescription_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoEncrypter_put_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_ErrorDescription_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Encrypt_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_ConvertObjectIDToAcctID_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal,
    /* [retval][out] */ BSTR *pbstrValOut);


void __RPC_STUB IPsoEncrypter_ConvertObjectIDToAcctID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateGUID_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_GenerateGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_ConvertServiceRefIDToSubID_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal,
    /* [retval][out] */ BSTR *pbstrValOut);


void __RPC_STUB IPsoEncrypter_ConvertServiceRefIDToSubID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateSessionKey_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrSessionKey);


void __RPC_STUB IPsoEncrypter_GenerateSessionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Decrypt_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrEncryptedText,
    /* [in] */ BSTR bstrSessionKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateSessionKeyEx_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrSessionKey);


void __RPC_STUB IPsoEncrypter_GenerateSessionKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_EncryptEx_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_EncryptEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_EncryptToByteArray_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB IPsoEncrypter_EncryptToByteArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_EncryptExToByteArray_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ VARIANT *pVariant);


void __RPC_STUB IPsoEncrypter_EncryptExToByteArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPsoEncrypter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilBldVer.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: AssemblyVersion("3.0.0800.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\7.5\inc\psomessages.h ===
#define  MAKEERROR(fac,err)   		MAKE_HRESULT(SEVERITY_ERROR,fac,err)
#define  MAKEWIN32ERROR(err)  		MAKEERROR(FACILITY_WIN32,err)
#define  GETWIN32ERROR()      		MAKEWIN32ERROR(GetLastError())
#define  MAKESCODE(fac,err)   		MAKE_HRESULT(SEVERITY_SUCCESS,fac,err)
#define  MAKEWIN32SCODE(err)  		MAKESCODE(FACILITY_WIN32,err)
#define  GETWIN32SCODE()      		MAKEWIN32SCODE(GetLastError())
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_PSOConnector            0x402
#define FACILITY_PSO                     0x401
#define FACILITY_DEFAULT                 0x100


//
// Define the severity codes
//


//
// MessageId: E_PSO_UNEXPECTED_ERROR
//
// MessageText:
//
//  Unexpected error in Partner Side Object (PSO). Contact SPG for assistance.
//
#define E_PSO_UNEXPECTED_ERROR           0x84010064L

//
// MessageId: E_PSO_HTTP_ERROR
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). Verify that the partner key provided by SPG is installed in HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that it contains an environment hive with valid WsdlLocation and WsmlLocation settings.
//
#define E_PSO_HTTP_ERROR                 0x84010065L

//
// MessageId: E_PSO_NOT_INITIALIZED
//
// MessageText:
//
//  The Partner Side Object (PSO) has not been initialized. You must first call the Initialize or the Connect method. You cannot call this function in the current state.
//
#define E_PSO_NOT_INITIALIZED            0x84010066L

//
// MessageId: E_PSO_NO_ENVIRONMENT
//
// MessageText:
//
//  Error retrieving the default partner environment name or an environment property such as WsdlLocation, WsmlLocation, or PartnerUsername. Verify that the partner key provided by SPG is installed in HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that it contains an environment hive with valid WsdlLocation and WsmlLocation settings and proper security attributes.
//
#define E_PSO_NO_ENVIRONMENT             0x84010067L

//
// MessageId: E_PSO_NO_SOAPCLIENT
//
// MessageText:
//
//  Error creating an instance of __uuidof(SoapClient). Verify that the SOAP Toolkit (version 2.0 SP2 or greater) is installed. The SOAP Toolkit is available at http://msdn.microsoft.com/xml/.
//
#define E_PSO_NO_SOAPCLIENT              0x84010068L

//
// MessageId: E_PSO_POOLCONNECTIONS
//
// MessageText:
//
//  Invalid number of PoolConnections specified. The acceptable range is between 0 and 64 connections.
//
#define E_PSO_POOLCONNECTIONS            0x84010069L

//
// MessageId: E_PSO_HTTP_ERROR_401
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). 401 - Access is denied. Check that the correct partner key MSI is installed, that the registry configuration points to the correct server, that the partner MSI package contains the correct key for the environment you are attempting to connect to, and that the server did not inadvertantly reset the partner password.
//
#define E_PSO_HTTP_ERROR_401             0x8401006AL

//
// MessageId: E_PSO_HTTP_ERROR_500
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). 500 - An internal server error has occurred. This can be due to a server configuration problem.
//
#define E_PSO_HTTP_ERROR_500             0x8401006BL

//
// MessageId: E_PSO_SOAP_PROPERTY
//
// MessageText:
//
//  Error setting a property on the SoapClient connection object. Verify that the SOAP Toolkit (version 2.0 SP2 or greater) is installed, and that %ProgramFiles%\Common Files\MSSoap\Binaries\mssoap1.dll is version 1.2.814.0 or greater. The SOAP Toolkit is available at http://msdn.microsoft.com/xml/.
//
#define E_PSO_SOAP_PROPERTY              0x8401006CL

//
// MessageId: E_PSO_TEMP_PATH
//
// MessageText:
//
//  Unable to get the temporary file path.
//
#define E_PSO_TEMP_PATH                  0x8401006DL

//
// MessageId: E_PSO_TEMP_FILE
//
// MessageText:
//
//  Unable to get the temporary file name or to create a temporary file. This is generally a write permissions problem.
//  If a user has a profile, the temporary path is defined by the TEMP environment setting and is typically [HOMEPATH]\[Username]\Local Settings\Temp.
//  If a user does not have a profile, such as IWAM_Computername or IUSR_Computername, this path is either [SystemDrive]\Temp or [SystemRoot]\Temp.
//
#define E_PSO_TEMP_FILE                  0x8401006EL

//
// MessageId: E_PSO_REG_PARTNER_HIVE
//
// MessageText:
//
//  Error opening partner registry hive or hive does not exist. (Re)install the partner key.
//  Check whether HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner exists and has the proper security settings.
//  Check whether this key contains a correct Environment and PartnerHive value.
//
#define E_PSO_REG_PARTNER_HIVE           0x8401006FL

//
// MessageId: E_PSO_REG_PARTNER_VALUE
//
// MessageText:
//
//  Error reading partner registry data. (Re)install the partner key.
//  Check whether Environment and PartnerHive values exist under HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that the key has proper security settings.
//
#define E_PSO_REG_PARTNER_VALUE          0x84010070L

//
// MessageId: E_PSO_REG_KEY_VALUE
//
// MessageText:
//
//  Error reading partner registry password data. (Re)install the partner key.
//  Check whether HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner\[Environment]\[PartnerHive]\Passwords exists and that it has proper security settings.
//
#define E_PSO_REG_KEY_VALUE              0x84010071L

//
// MessageId: S_PSOCONNECTOR_FINALCONSTRUCT
//
// MessageText:
//
//  A PSO Connector Object has been created.
//
#define S_PSOCONNECTOR_FINALCONSTRUCT    0x440200C8L

//
// MessageId: S_PSOCONNECTOR_INITIALIZED
//
// MessageText:
//
//  A PSO Connector Object has been successfully initialized.
//
#define S_PSOCONNECTOR_INITIALIZED       0x440200C9L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\CSharp\TestConnectionClientCert\Bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.12
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.12.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="bdkSoap", Namespace="http://tempuri.org/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    public BdkSoapHeader BdkSoapHeaderValue;
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://hostname/scsnocc/scsapiwebservice.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus) {
        this.Invoke("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateToken(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
        object[] results = this.Invoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription});
        pbstrErrorXML = ((string)(results[0]));
        pbstrBlacklistActionSetXML = ((string)(results[1]));
        plBlacklistActionSetCount = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrBlacklistActionSetXML = ((string)(results[1]));
        plBlacklistActionSetCount = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelPayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelPayment(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml) {
        this.Invoke("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelPayment(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelPayment(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelRenewal", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId) {
        this.Invoke("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelRenewal(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance});
        amountChargedXML = ((string)(results[0]));
        subscriptionStatusInfoXML = ((string)(results[1]));
        removedServiceInstanceCount = ((int)(results[2]));
        removedServiceInstanceSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscriptionEx(System.IAsyncResult asyncResult, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        amountChargedXML = ((string)(results[0]));
        subscriptionStatusInfoXML = ((string)(results[1]));
        removedServiceInstanceCount = ((int)(results[2]));
        removedServiceInstanceSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelTransaction", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId) {
        this.Invoke("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelTransaction(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ChargePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, out string paymentInstrumentResultsXml) {
        object[] results = this.Invoke("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml});
        paymentInstrumentResultsXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndChargePaymentInstrument(System.IAsyncResult asyncResult, out string paymentInstrumentResultsXml) {
        object[] results = this.EndInvoke(asyncResult);
        paymentInstrumentResultsXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckCDAvailability", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, out string partnerName) {
        object[] results = this.Invoke("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob});
        partnerName = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckCDAvailability(System.IAsyncResult asyncResult, out string partnerName) {
        object[] results = this.EndInvoke(asyncResult);
        partnerName = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConsumeToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, out string consumedTokenDetailsXML) {
        object[] results = this.Invoke("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID});
        consumedTokenDetailsXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConsumeToken(System.IAsyncResult asyncResult, out string consumedTokenDetailsXML) {
        object[] results = this.EndInvoke(asyncResult);
        consumedTokenDetailsXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscriptionEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscriptionEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscriptionEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet, 
                out string pbstrRedirectOutputInfoXML) {
        object[] results = this.Invoke("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        pbstrRedirectOutputInfoXML = ((string)(results[6]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscriptionEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscriptionEx2(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet, out string pbstrRedirectOutputInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        pbstrRedirectOutputInfoXML = ((string)(results[6]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapHeaderAttribute("BdkSoapHeaderValue")]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateUserProfile", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride) {
        this.Invoke("CreateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateUserProfile(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeactivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus) {
        this.Invoke("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeactivateToken(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeliverToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML) {
        object[] results = this.Invoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey});
        pbstrErrorXML = ((string)(results[0]));
        pbstrEncryptedTokenSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeliverToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrEncryptedTokenSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
        object[] results = this.Invoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrNewExpirationDate = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrNewExpirationDate = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.FixExistingAddress", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void FixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, System.Double confidenceScoreThreshold, bool readOnlyMode, out bool result, out System.Double confidenceScore, out int tryNumber) {
        object[] results = this.Invoke("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode});
        result = ((bool)(results[0]));
        confidenceScore = ((System.Double)(results[1]));
        tryNumber = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginFixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, System.Double confidenceScoreThreshold, bool readOnlyMode, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndFixExistingAddress(System.IAsyncResult asyncResult, out bool result, out System.Double confidenceScore, out int tryNumber) {
        object[] results = this.EndInvoke(asyncResult);
        result = ((bool)(results[0]));
        confidenceScore = ((System.Double)(results[1]));
        tryNumber = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPuid", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml) {
        object[] results = this.Invoke("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max});
        errorXml = ((string)(results[0]));
        moreRows = ((int)(results[1]));
        accountInfoCount = ((int)(results[2]));
        accountInfoSetXml = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPuid(System.IAsyncResult asyncResult, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        moreRows = ((int)(results[1]));
        accountInfoCount = ((int)(results[2]));
        accountInfoSetXml = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType});
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId});
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
        object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        plPITypeCount = ((int)(results[1]));
        pbstrPITypeSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPITypeCount = ((int)(results[1]));
        pbstrPITypeSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
        object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML});
        pbstrErrorXML = ((string)(results[0]));
        plAccountDetailCount = ((int)(results[1]));
        pbstrAccountDetailSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountDetailCount = ((int)(results[1]));
        pbstrAccountDetailSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
        object[] results = this.Invoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory});
        errorXml = ((string)(results[0]));
        lineItemHistorySetXml = ((string)(results[1]));
        mcv = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        lineItemHistorySetXml = ((string)(results[1]));
        mcv = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentMethodTypeProperties", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentMethodTypeProperties(out string paymentTypeInfoSetXml) {
        object[] results = this.Invoke("GetPaymentMethodTypeProperties", new object[0]);
        paymentTypeInfoSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentMethodTypeProperties(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentMethodTypeProperties", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentMethodTypeProperties(System.IAsyncResult asyncResult, out string paymentTypeInfoSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        paymentTypeInfoSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitHistoryForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, out string errorXml, out int permitCount, out string permitSetXML) {
        object[] results = this.Invoke("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId});
        errorXml = ((string)(results[0]));
        permitCount = ((int)(results[1]));
        permitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitHistoryForObjectId(System.IAsyncResult asyncResult, out string errorXml, out int permitCount, out string permitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        permitCount = ((int)(results[1]));
        permitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale});
        pbstrPolicyInfoXML = ((string)(results[0]));
        pbstrErrorXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrPolicyInfoXML = ((string)(results[0]));
        pbstrErrorXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProductClasses", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetProductClasses(out string productClassSetXml) {
        object[] results = this.Invoke("GetProductClasses", new object[0]);
        productClassSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetProductClasses(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetProductClasses", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetProductClasses(System.IAsyncResult asyncResult, out string productClassSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        productClassSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProvisioningInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, out string ProvisioningInfoXml) {
        object[] results = this.Invoke("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel});
        ProvisioningInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetProvisioningInfo(System.IAsyncResult asyncResult, out string ProvisioningInfoXml) {
        object[] results = this.EndInvoke(asyncResult);
        ProvisioningInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralEvents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, out string ReferralEventsInfoXML) {
        object[] results = this.Invoke("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey});
        ReferralEventsInfoXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralEvents(System.IAsyncResult asyncResult, out string ReferralEventsInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        ReferralEventsInfoXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.Invoke("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid});
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReplacementToken(System.IAsyncResult asyncResult, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.EndInvoke(asyncResult);
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementTokenFromPuid", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, out int tokenInfoReturnedCount, out string replacementTokenSetXml) {
        object[] results = this.Invoke("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow});
        tokenInfoReturnedCount = ((int)(results[0]));
        replacementTokenSetXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReplacementTokenFromPuid(System.IAsyncResult asyncResult, out int tokenInfoReturnedCount, out string replacementTokenSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        tokenInfoReturnedCount = ((int)(results[0]));
        replacementTokenSetXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
        object[] results = this.Invoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID});
        pbstrErrorXML = ((string)(results[0]));
        plCount = ((int)(results[1]));
        pbstrResourcePriceSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCount = ((int)(results[1]));
        pbstrResourcePriceSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
        object[] results = this.Invoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet});
        errorXml = ((string)(results[0]));
        accountStatementInfoSetXml = ((string)(results[1]));
        userNotificationSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        accountStatementInfoSetXml = ((string)(results[1]));
        userNotificationSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
        object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plHistoryEventCount = ((int)(results[1]));
        pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plHistoryEventCount = ((int)(results[1]));
        pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClassRestrictionInfoForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, out string tokenClassRestrictionInfoSetXML) {
        object[] results = this.Invoke("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML});
        tokenClassRestrictionInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenClassRestrictionInfoForPUID(System.IAsyncResult asyncResult, out string tokenClassRestrictionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        tokenClassRestrictionInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClasses", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML) {
        object[] results = this.Invoke("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax});
        plAdditionalTokenClassCount = ((int)(results[0]));
        plTokenClassReturnedCount = ((int)(results[1]));
        pbstrTokenClassSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenClasses(System.IAsyncResult asyncResult, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        plAdditionalTokenClassCount = ((int)(results[0]));
        plTokenClassReturnedCount = ((int)(results[1]));
        pbstrTokenClassSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.Invoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType});
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTransactions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, out string transactionSetXml) {
        object[] results = this.Invoke("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml});
        transactionSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTransactions(System.IAsyncResult asyncResult, out string transactionSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        transactionSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUnconditionalReplacementToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.Invoke("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid});
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetUnconditionalReplacementToken(System.IAsyncResult asyncResult, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.EndInvoke(asyncResult);
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUserProfile", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, out string userProfileXml) {
        object[] results = this.Invoke("GetUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow});
        userProfileXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetUserProfile(System.IAsyncResult asyncResult, out string userProfileXml) {
        object[] results = this.EndInvoke(asyncResult);
        userProfileXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
        pbstrNewLineItemsXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
        pbstrNewLineItemsXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IssueTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId) {
        this.Invoke("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIssueTokenTrusted(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MarkTokenDistributionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber) {
        this.Invoke("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMarkTokenDistributionStatus(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MapAddress", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MapAddress(int delegateIdHigh, int delegateIdLow, string addressInfoXML, int maxReturnRange, System.Double confidenceScoreThreshold, out string MapAddressInfoSet) {
        object[] results = this.Invoke("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    addressInfoXML,
                    maxReturnRange,
                    confidenceScoreThreshold});
        MapAddressInfoSet = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMapAddress(int delegateIdHigh, int delegateIdLow, string addressInfoXML, int maxReturnRange, System.Double confidenceScoreThreshold, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    addressInfoXML,
                    maxReturnRange,
                    confidenceScoreThreshold}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMapAddress(System.IAsyncResult asyncResult, out string MapAddressInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        MapAddressInfoSet = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
        object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plAdminPUIDHigh = ((int)(results[1]));
        plAdminPUIDLow = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAdminPUIDHigh = ((int)(results[1]));
        plAdminPUIDLow = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MigrateOffer", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        plAddedServiceInstanceSetCount = ((int)(results[0]));
        pbstrAddedServiceInstanceSet = ((string)(results[1]));
        plRemovedServiceInstanceSetCount = ((int)(results[2]));
        pbstrRemoveServiceInstanceSet = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMigrateOffer(System.IAsyncResult asyncResult, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        plAddedServiceInstanceSetCount = ((int)(results[0]));
        pbstrAddedServiceInstanceSet = ((string)(results[1]));
        plRemovedServiceInstanceSetCount = ((int)(results[2]));
        pbstrRemoveServiceInstanceSet = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
        object[] results = this.Invoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML});
        pbstrError = ((string)(results[0]));
        pbstrNewLineItemXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
        pbstrNewLineItemXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetSingleUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, out string newLineItemXML) {
        object[] results = this.Invoke("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity});
        newLineItemXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetSingleUsageEvent(System.IAsyncResult asyncResult, out string newLineItemXML) {
        object[] results = this.EndInvoke(asyncResult);
        newLineItemXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, out long orderId) {
        object[] results = this.Invoke("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode});
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOrderCDforAccount(System.IAsyncResult asyncResult, out long orderId) {
        object[] results = this.EndInvoke(asyncResult);
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAnonymous", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, out long orderId) {
        object[] results = this.Invoke("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo});
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOrderCDforAnonymous(System.IAsyncResult asyncResult, out long orderId) {
        object[] results = this.EndInvoke(asyncResult);
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PayUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PayUser(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, System.Decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, out string payUserResultXml) {
        object[] results = this.Invoke("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml});
        payUserResultXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPayUser(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, System.Decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPayUser(System.IAsyncResult asyncResult, out string payUserResultXml) {
        object[] results = this.EndInvoke(asyncResult);
        payUserResultXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProcessChargeback", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, out string chargebackResponseInfoXml) {
        object[] results = this.Invoke("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml});
        chargebackResponseInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProcessChargeback(System.IAsyncResult asyncResult, out string chargebackResponseInfoXml) {
        object[] results = this.EndInvoke(asyncResult);
        chargebackResponseInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, out string receiptXml) {
        object[] results = this.Invoke("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml});
        receiptXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseItem(System.IAsyncResult asyncResult, out string receiptXml) {
        object[] results = this.EndInvoke(asyncResult);
        receiptXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOfferingEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOfferingEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOfferingEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML, 
                out string pbstrRedirectOutputInfoXML) {
        object[] results = this.Invoke("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        pbstrRedirectOutputInfoXML = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOfferingEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOfferingEx2(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML, out string pbstrRedirectOutputInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        pbstrRedirectOutputInfoXML = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReconcileTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, out int reconStatus) {
        object[] results = this.Invoke("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action});
        reconStatus = ((int)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReconcileTokenTrusted(System.IAsyncResult asyncResult, out int reconStatus) {
        object[] results = this.EndInvoke(asyncResult);
        reconStatus = ((int)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RefundTaxForAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RefundTaxForAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, out string pbstrNewLineItemSetXML) {
        object[] results = this.Invoke("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund});
        pbstrNewLineItemSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRefundTaxForAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRefundTaxForAccount(System.IAsyncResult asyncResult, out string pbstrNewLineItemSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrNewLineItemSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RegisterPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml) {
        object[] results = this.Invoke("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml});
        paymentInstrumentId = ((string)(results[0]));
        requiredPaperWorkUrl = ((string)(results[1]));
        paymentInstrumentsResultsXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRegisterPaymentInstrument(System.IAsyncResult asyncResult, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml) {
        object[] results = this.EndInvoke(asyncResult);
        paymentInstrumentId = ((string)(results[0]));
        requiredPaperWorkUrl = ((string)(results[1]));
        paymentInstrumentsResultsXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePMNBasedServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow) {
        this.Invoke("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePMNBasedServices(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportSingleUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, out string lineItemId, out string usageInfoXml, out string amountChargedXml) {
        object[] results = this.Invoke("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml});
        lineItemId = ((string)(results[0]));
        usageInfoXml = ((string)(results[1]));
        amountChargedXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportSingleUsageEvent(System.IAsyncResult asyncResult, out string lineItemId, out string usageInfoXml, out string amountChargedXml) {
        object[] results = this.EndInvoke(asyncResult);
        lineItemId = ((string)(results[0]));
        usageInfoXml = ((string)(results[1]));
        amountChargedXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportTransactionEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml) {
        this.Invoke("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportTransactionEvent(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
        object[] results = this.Invoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccountsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml) {
        object[] results = this.Invoke("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax});
        bookmarkNew = ((string)(results[0]));
        returnedAccountCount = ((int)(results[1]));
        accountInfoSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccountsEx(System.IAsyncResult asyncResult, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        bookmarkNew = ((string)(results[0]));
        returnedAccountCount = ((int)(results[1]));
        accountInfoSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchBillingInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, out string billingInfoSetXML) {
        object[] results = this.Invoke("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML});
        billingInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchBillingInfo(System.IAsyncResult asyncResult, out string billingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        billingInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
        this.Invoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSendHCI(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
        object[] results = this.Invoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnIssueTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId) {
        this.Invoke("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnIssueTokenTrusted(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateUserProfile", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride) {
        this.Invoke("UpdateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateUserProfile(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber) {
        this.Invoke("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateToken(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
}

/// <remarks/>
[System.Xml.Serialization.SoapTypeAttribute("BdkSoapHeader", "http://tempuri.org/")]
public class BdkSoapHeader : SoapHeader {
    
    /// <remarks/>
    public int PartitionId;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SCS\5.0\samples\SCS API\CSharp\TestConnection\Bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.12
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.12.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="bdkSoap", Namespace="http://tempuri.org/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    public BdkSoapHeader BdkSoapHeaderValue;
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://hostname/scsnocc/scsapiwebservice.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus) {
        this.Invoke("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateToken(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
        object[] results = this.Invoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription});
        pbstrErrorXML = ((string)(results[0]));
        pbstrBlacklistActionSetXML = ((string)(results[1]));
        plBlacklistActionSetCount = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrBlacklistActionSetXML = ((string)(results[1]));
        plBlacklistActionSetCount = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelPayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelPayment(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml) {
        this.Invoke("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelPayment(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, string confirmationId, string commentInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelPayment", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    confirmationId,
                    commentInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelPayment(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelRenewal", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId) {
        this.Invoke("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelRenewal", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    subscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelRenewal(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance});
        amountChargedXML = ((string)(results[0]));
        subscriptionStatusInfoXML = ((string)(results[1]));
        removedServiceInstanceCount = ((int)(results[2]));
        removedServiceInstanceSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscriptionEx", new object[] {
                    delegatePUIDHigh,
                    delegatePUIDLow,
                    requesterPUIDHigh,
                    requesterPUIDLow,
                    trackingGUID,
                    computeOnly,
                    subscriptionId,
                    cancelDate,
                    commentInfoXML,
                    closeBalance}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscriptionEx(System.IAsyncResult asyncResult, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        amountChargedXML = ((string)(results[0]));
        subscriptionStatusInfoXML = ((string)(results[1]));
        removedServiceInstanceCount = ((int)(results[2]));
        removedServiceInstanceSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelTransaction", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId) {
        this.Invoke("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelTransaction", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    transactionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelTransaction(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ChargePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, out string paymentInstrumentResultsXml) {
        object[] results = this.Invoke("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml});
        paymentInstrumentResultsXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ChargePaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    paymentInstrumentId,
                    chargeInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndChargePaymentInstrument(System.IAsyncResult asyncResult, out string paymentInstrumentResultsXml) {
        object[] results = this.EndInvoke(asyncResult);
        paymentInstrumentResultsXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckCDAvailability", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, out string partnerName) {
        object[] results = this.Invoke("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob});
        partnerName = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckCDAvailability", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckCDAvailability(System.IAsyncResult asyncResult, out string partnerName) {
        object[] results = this.EndInvoke(asyncResult);
        partnerName = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConsumeToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, out string consumedTokenDetailsXML) {
        object[] results = this.Invoke("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID});
        consumedTokenDetailsXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, bool computeOnly, string tokenID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ConsumeToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    trackingGuid,
                    computeOnly,
                    tokenID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConsumeToken(System.IAsyncResult asyncResult, out string consumedTokenDetailsXML) {
        object[] results = this.EndInvoke(asyncResult);
        consumedTokenDetailsXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscriptionEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscriptionEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscriptionEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet, 
                out string pbstrRedirectOutputInfoXML) {
        object[] results = this.Invoke("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        pbstrRedirectOutputInfoXML = ((string)(results[6]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscriptionEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscriptionEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscriptionEx2(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet, out string pbstrRedirectOutputInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        pbstrRedirectOutputInfoXML = ((string)(results[6]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapHeaderAttribute("BdkSoapHeaderValue")]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateUserProfile", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride) {
        this.Invoke("CreateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateUserProfile(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeactivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus) {
        this.Invoke("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeactivateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    committedStatus}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeactivateToken(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeliverToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML) {
        object[] results = this.Invoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey});
        pbstrErrorXML = ((string)(results[0]));
        pbstrEncryptedTokenSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeliverToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrEncryptedTokenSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
        object[] results = this.Invoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrNewExpirationDate = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrNewExpirationDate = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.FixExistingAddress", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void FixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, System.Double confidenceScoreThreshold, bool readOnlyMode, out bool result, out System.Double confidenceScore, out int tryNumber) {
        object[] results = this.Invoke("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode});
        result = ((bool)(results[0]));
        confidenceScore = ((System.Double)(results[1]));
        tryNumber = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginFixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, System.Double confidenceScoreThreshold, bool readOnlyMode, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("FixExistingAddress", new object[] {
                    acctId,
                    subRefID,
                    addId,
                    mappingCombination,
                    maxReturnRange,
                    confidenceScoreThreshold,
                    readOnlyMode}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndFixExistingAddress(System.IAsyncResult asyncResult, out bool result, out System.Double confidenceScore, out int tryNumber) {
        object[] results = this.EndInvoke(asyncResult);
        result = ((bool)(results[0]));
        confidenceScore = ((System.Double)(results[1]));
        tryNumber = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPuid", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml) {
        object[] results = this.Invoke("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max});
        errorXml = ((string)(results[0]));
        moreRows = ((int)(results[1]));
        accountInfoCount = ((int)(results[2]));
        accountInfoSetXml = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow,
                    roleSetXml,
                    fullData,
                    max}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPuid(System.IAsyncResult asyncResult, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        moreRows = ((int)(results[1]));
        accountInfoCount = ((int)(results[2]));
        accountInfoSetXml = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType});
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId,
                    lTokenType}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId});
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
        object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        plPITypeCount = ((int)(results[1]));
        pbstrPITypeSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPITypeCount = ((int)(results[1]));
        pbstrPITypeSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
        object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML});
        pbstrErrorXML = ((string)(results[0]));
        plAccountDetailCount = ((int)(results[1]));
        pbstrAccountDetailSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountDetailCount = ((int)(results[1]));
        pbstrAccountDetailSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
        object[] results = this.Invoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory});
        errorXml = ((string)(results[0]));
        lineItemHistorySetXml = ((string)(results[1]));
        mcv = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        lineItemHistorySetXml = ((string)(results[1]));
        mcv = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentMethodTypeProperties", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentMethodTypeProperties(out string paymentTypeInfoSetXml) {
        object[] results = this.Invoke("GetPaymentMethodTypeProperties", new object[0]);
        paymentTypeInfoSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentMethodTypeProperties(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentMethodTypeProperties", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentMethodTypeProperties(System.IAsyncResult asyncResult, out string paymentTypeInfoSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        paymentTypeInfoSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitHistoryForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, out string errorXml, out int permitCount, out string permitSetXML) {
        object[] results = this.Invoke("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId});
        errorXml = ((string)(results[0]));
        permitCount = ((int)(results[1]));
        permitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitHistoryForObjectId", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    objectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitHistoryForObjectId(System.IAsyncResult asyncResult, out string errorXml, out int permitCount, out string permitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        permitCount = ((int)(results[1]));
        permitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale});
        pbstrPolicyInfoXML = ((string)(results[0]));
        pbstrErrorXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrPolicyInfoXML = ((string)(results[0]));
        pbstrErrorXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProductClasses", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetProductClasses(out string productClassSetXml) {
        object[] results = this.Invoke("GetProductClasses", new object[0]);
        productClassSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetProductClasses(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetProductClasses", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetProductClasses(System.IAsyncResult asyncResult, out string productClassSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        productClassSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProvisioningInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, out string ProvisioningInfoXml) {
        object[] results = this.Invoke("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel});
        ProvisioningInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetProvisioningInfo(System.IAsyncResult asyncResult, out string ProvisioningInfoXml) {
        object[] results = this.EndInvoke(asyncResult);
        ProvisioningInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralEvents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, out string ReferralEventsInfoXML) {
        object[] results = this.Invoke("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey});
        ReferralEventsInfoXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralEvents(System.IAsyncResult asyncResult, out string ReferralEventsInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        ReferralEventsInfoXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.Invoke("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid});
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReplacementToken(System.IAsyncResult asyncResult, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.EndInvoke(asyncResult);
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementTokenFromPuid", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, out int tokenInfoReturnedCount, out string replacementTokenSetXml) {
        object[] results = this.Invoke("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow});
        tokenInfoReturnedCount = ((int)(results[0]));
        replacementTokenSetXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReplacementTokenFromPuid(System.IAsyncResult asyncResult, out int tokenInfoReturnedCount, out string replacementTokenSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        tokenInfoReturnedCount = ((int)(results[0]));
        replacementTokenSetXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
        object[] results = this.Invoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID});
        pbstrErrorXML = ((string)(results[0]));
        plCount = ((int)(results[1]));
        pbstrResourcePriceSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCount = ((int)(results[1]));
        pbstrResourcePriceSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
        object[] results = this.Invoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet});
        errorXml = ((string)(results[0]));
        accountStatementInfoSetXml = ((string)(results[1]));
        userNotificationSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        accountStatementInfoSetXml = ((string)(results[1]));
        userNotificationSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
        object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plHistoryEventCount = ((int)(results[1]));
        pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plHistoryEventCount = ((int)(results[1]));
        pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClassRestrictionInfoForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, out string tokenClassRestrictionInfoSetXML) {
        object[] results = this.Invoke("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML});
        tokenClassRestrictionInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenClassRestrictionInfoForPUID(System.IAsyncResult asyncResult, out string tokenClassRestrictionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        tokenClassRestrictionInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClasses", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML) {
        object[] results = this.Invoke("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax});
        plAdditionalTokenClassCount = ((int)(results[0]));
        plTokenClassReturnedCount = ((int)(results[1]));
        pbstrTokenClassSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenClasses(System.IAsyncResult asyncResult, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        plAdditionalTokenClassCount = ((int)(results[0]));
        plTokenClassReturnedCount = ((int)(results[1]));
        pbstrTokenClassSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.Invoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType});
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTransactions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, out string transactionSetXml) {
        object[] results = this.Invoke("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml});
        transactionSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTransactions", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    accountId,
                    offeringGuid,
                    transactionId,
                    filteringCriteriaXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTransactions(System.IAsyncResult asyncResult, out string transactionSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        transactionSetXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUnconditionalReplacementToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.Invoke("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid});
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUnconditionalReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    tiePinRedemptionToPuid,
                    replacementReasonCode,
                    tokenClassGuid,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetUnconditionalReplacementToken(System.IAsyncResult asyncResult, out string replacementPin, out int signature, out string sequenceNumber) {
        object[] results = this.EndInvoke(asyncResult);
        replacementPin = ((string)(results[0]));
        signature = ((int)(results[1]));
        sequenceNumber = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUserProfile", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, out string userProfileXml) {
        object[] results = this.Invoke("GetUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow});
        userProfileXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetUserProfile(System.IAsyncResult asyncResult, out string userProfileXml) {
        object[] results = this.EndInvoke(asyncResult);
        userProfileXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
        pbstrNewLineItemsXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
        pbstrNewLineItemsXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IssueTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId) {
        this.Invoke("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIssueTokenTrusted(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MarkTokenDistributionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber) {
        this.Invoke("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MarkTokenDistributionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrTokenId,
                    lTokenType,
                    bstrStatusName,
                    bstrStatusValue,
                    bstrPartNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMarkTokenDistributionStatus(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MapAddress", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MapAddress(int delegateIdHigh, int delegateIdLow, string addressInfoXML, int maxReturnRange, System.Double confidenceScoreThreshold, out string MapAddressInfoSet) {
        object[] results = this.Invoke("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    addressInfoXML,
                    maxReturnRange,
                    confidenceScoreThreshold});
        MapAddressInfoSet = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMapAddress(int delegateIdHigh, int delegateIdLow, string addressInfoXML, int maxReturnRange, System.Double confidenceScoreThreshold, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MapAddress", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    addressInfoXML,
                    maxReturnRange,
                    confidenceScoreThreshold}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMapAddress(System.IAsyncResult asyncResult, out string MapAddressInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        MapAddressInfoSet = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
        object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plAdminPUIDHigh = ((int)(results[1]));
        plAdminPUIDLow = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAdminPUIDHigh = ((int)(results[1]));
        plAdminPUIDLow = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MigrateOffer", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        plAddedServiceInstanceSetCount = ((int)(results[0]));
        pbstrAddedServiceInstanceSet = ((string)(results[1]));
        plRemovedServiceInstanceSetCount = ((int)(results[2]));
        pbstrRemoveServiceInstanceSet = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MigrateOffer", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMigrateOffer(System.IAsyncResult asyncResult, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        plAddedServiceInstanceSetCount = ((int)(results[0]));
        pbstrAddedServiceInstanceSet = ((string)(results[1]));
        plRemovedServiceInstanceSetCount = ((int)(results[2]));
        pbstrRemoveServiceInstanceSet = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
        object[] results = this.Invoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML});
        pbstrError = ((string)(results[0]));
        pbstrNewLineItemXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
        pbstrNewLineItemXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetSingleUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, out string newLineItemXML) {
        object[] results = this.Invoke("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity});
        newLineItemXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetSingleUsageEvent", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    lineItemId,
                    units,
                    CommentInfoXML,
                    reservedXML,
                    returnAsUsageActivity}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetSingleUsageEvent(System.IAsyncResult asyncResult, out string newLineItemXML) {
        object[] results = this.EndInvoke(asyncResult);
        newLineItemXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, out long orderId) {
        object[] results = this.Invoke("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode});
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OrderCDforAccount", new object[] {
                    accountIDBlob,
                    subscriptionRefIDBlob,
                    surveyResultCode}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOrderCDforAccount(System.IAsyncResult asyncResult, out long orderId) {
        object[] results = this.EndInvoke(asyncResult);
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAnonymous", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, out long orderId) {
        object[] results = this.Invoke("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo});
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OrderCDforAnonymous", new object[] {
                    anonymousInfoXml,
                    category,
                    requestorInfo}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOrderCDforAnonymous(System.IAsyncResult asyncResult, out long orderId) {
        object[] results = this.EndInvoke(asyncResult);
        orderId = ((long)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PayUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PayUser(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, System.Decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, out string payUserResultXml) {
        object[] results = this.Invoke("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml});
        payUserResultXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPayUser(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string trackingGuid, System.Decimal amount, string currency, string offeringGuid, string description, string externalReferenceId, string payUserInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PayUser", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    trackingGuid,
                    amount,
                    currency,
                    offeringGuid,
                    description,
                    externalReferenceId,
                    payUserInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPayUser(System.IAsyncResult asyncResult, out string payUserResultXml) {
        object[] results = this.EndInvoke(asyncResult);
        payUserResultXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProcessChargeback", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, out string chargebackResponseInfoXml) {
        object[] results = this.Invoke("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml});
        chargebackResponseInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProcessChargeback", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    fileId,
                    fileNamespace,
                    recordOnly,
                    mode,
                    chargebackInstanceXml,
                    commentInfoXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProcessChargeback(System.IAsyncResult asyncResult, out string chargebackResponseInfoXml) {
        object[] results = this.EndInvoke(asyncResult);
        chargebackResponseInfoXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, out string receiptXml) {
        object[] results = this.Invoke("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml});
        receiptXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PurchaseItem", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    trackingGuid,
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseItem(System.IAsyncResult asyncResult, out string receiptXml) {
        object[] results = this.EndInvoke(asyncResult);
        receiptXml = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOfferingEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOfferingEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOfferingEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML, 
                out string pbstrRedirectOutputInfoXML) {
        object[] results = this.Invoke("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        pbstrRedirectOutputInfoXML = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOfferingEx2(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                string bstrRedirectInputInfoXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOfferingEx2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime,
                    bstrRedirectInputInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOfferingEx2(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML, out string pbstrRedirectOutputInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        pbstrRedirectOutputInfoXML = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReconcileTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, out int reconStatus) {
        object[] results = this.Invoke("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action});
        reconStatus = ((int)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReconcileTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    token,
                    tokenType,
                    externalReferenceId,
                    timeStamp,
                    action}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReconcileTokenTrusted(System.IAsyncResult asyncResult, out int reconStatus) {
        object[] results = this.EndInvoke(asyncResult);
        reconStatus = ((int)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RefundTaxForAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RefundTaxForAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, out string pbstrNewLineItemSetXML) {
        object[] results = this.Invoke("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund});
        pbstrNewLineItemSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRefundTaxForAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrCommentInfoXML, bool fRevertTaxRefund, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RefundTaxForAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrCommentInfoXML,
                    fRevertTaxRefund}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRefundTaxForAccount(System.IAsyncResult asyncResult, out string pbstrNewLineItemSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrNewLineItemSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RegisterPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml) {
        object[] results = this.Invoke("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml});
        paymentInstrumentId = ((string)(results[0]));
        requiredPaperWorkUrl = ((string)(results[1]));
        paymentInstrumentsResultsXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RegisterPaymentInstrument", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requestorIdHigh,
                    requestorIdLow,
                    trackingGuid,
                    paymentInstrumentInfoXml,
                    accountInfoXml,
                    responseOptionsXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRegisterPaymentInstrument(System.IAsyncResult asyncResult, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml) {
        object[] results = this.EndInvoke(asyncResult);
        paymentInstrumentId = ((string)(results[0]));
        requiredPaperWorkUrl = ((string)(results[1]));
        paymentInstrumentsResultsXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePMNBasedServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow) {
        this.Invoke("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePMNBasedServices", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePMNBasedServices(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportSingleUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, out string lineItemId, out string usageInfoXml, out string amountChargedXml) {
        object[] results = this.Invoke("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml});
        lineItemId = ((string)(results[0]));
        usageInfoXml = ((string)(results[1]));
        amountChargedXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportSingleUsageEvent", new object[] {
                    trackingGuid,
                    computeOnly,
                    usageEventXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportSingleUsageEvent(System.IAsyncResult asyncResult, out string lineItemId, out string usageInfoXml, out string amountChargedXml) {
        object[] results = this.EndInvoke(asyncResult);
        lineItemId = ((string)(results[0]));
        usageInfoXml = ((string)(results[1]));
        amountChargedXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportTransactionEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml) {
        this.Invoke("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportTransactionEvent", new object[] {
                    sequenceNumber,
                    transactionId,
                    merchantId,
                    vendorInternalTransactionId,
                    amountXml,
                    transactionEventXml,
                    paymentDetailsXml}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportTransactionEvent(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
        object[] results = this.Invoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccountsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml) {
        object[] results = this.Invoke("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax});
        bookmarkNew = ((string)(results[0]));
        returnedAccountCount = ((int)(results[1]));
        accountInfoSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccountsEx", new object[] {
                    delegatePuidHigh,
                    delegatePuidLow,
                    accountSearchCriteriaXml,
                    bookmark,
                    returnedAccountCountMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccountsEx(System.IAsyncResult asyncResult, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        bookmarkNew = ((string)(results[0]));
        returnedAccountCount = ((int)(results[1]));
        accountInfoSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchBillingInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, out string billingInfoSetXML) {
        object[] results = this.Invoke("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML});
        billingInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchBillingInfo", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    billingInfoSearchCriteriaXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchBillingInfo(System.IAsyncResult asyncResult, out string billingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        billingInfoSetXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
        this.Invoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSendHCI(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
        object[] results = this.Invoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnIssueTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId) {
        this.Invoke("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnIssueTokenTrusted", new object[] {
                    partnerName,
                    delegateIdHigh,
                    delegateIdLow,
                    trackingGuid,
                    token,
                    tokenType,
                    externalReferenceId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnIssueTokenTrusted(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateUserProfile", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride) {
        this.Invoke("UpdateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateUserProfile(int delegateIdHigh, int delegateIdLow, int targetIdHigh, int targetIdLow, string userProfileXml, bool fOverride, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateUserProfile", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    targetIdHigh,
                    targetIdLow,
                    userProfileXml,
                    fOverride}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateUserProfile(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber) {
        this.Invoke("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    tokenClassGuid,
                    pin,
                    sequenceNumber,
                    signature,
                    partNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateToken(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
}

/// <remarks/>
[System.Xml.Serialization.SoapTypeAttribute("BdkSoapHeader", "http://tempuri.org/")]
public class BdkSoapHeader : SoapHeader {
    
    /// <remarks/>
    public int PartitionId;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\installers\Spiller\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\installers\SvcUtility\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\installers\SpilRuntime\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\installers\WstManagedClient\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\SqlIntTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
    /// <summary>
    /// Summary description for SqlIntTest.
    /// </summary>
    [TestFixture]
    public class SqlIntTest
    {
        OneDirData onedir = new OneDirData();

        [Test]
        public void TestSqlIntInput()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlInt32 c = SqlInt32.Null;
                onedir.TestSqlInt(scm, 1, 2, ref c);
                Assert.AreEqual(c.Value, 3,"c != 3");
            }
        }

        [Test]
        public void TestSqlIntInputNotNullOutputNotNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlInt32 c = new SqlInt32(5);
                onedir.TestSqlInt(scm, 1, 2, ref c);
                Assert.AreEqual(c.Value, 3,"c != 3");
            }
        }

        [Test]
        public void TestSqlIntInputNullOutputNotNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlInt32 c = SqlInt32.Null;
                onedir.TestSqlInt(scm, SqlInt32.Null,2, ref c);
                Assert.AreEqual(c.Value, 2, "c != 2");
            }
        }

        [Test]
        public void TestSqlIntInputNotNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlInt32 c = new SqlInt32(1);
                onedir.TestSqlInt(scm, SqlInt32.Null, SqlInt32.Null, ref c);
                
                Assert.AreEqual(c, SqlInt32.Null, "c != SqlInt32.Null");
            }
        }

        [Test]
        public void TestSqlIntInputNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlInt32 c = SqlInt32.Null;
                onedir.TestSqlInt(scm, SqlInt32.Null, SqlInt32.Null, ref c);
                
                Assert.AreEqual( c, SqlInt32.Null, "c != SqlInt32.Null");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS SPIL Test")]
[assembly: AssemblyDescription("Console application to test SPIL")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

//[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\BasicTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
    /// <summary>
    /// Perform basic functinality test in SPIL
    /// This sample shows the basic usage of SPIL generated functions
    /// </summary>
    [TestFixture]
    public class BasicTest
    {
        protected OneDirClass odc = new OneDirClass();
        protected int a = 100;
        protected int b = 10;

        [SetUp]
        public void Init()
        {
        }
            
        [Test]
        public void AddNumbers()
        {
            SqlInt64 c = new SqlInt64(0);
            // 
            // Use the "using()" statement model for resource reclamation
            // from the connection manager created. Internally at runtime,
            // automatic code is executed to call the IDispose interface on 
            // the connection manager object.
            // 
            using(SimpleConnectionManager scm = new SimpleConnectionManager())
            {
                Console.WriteLine( "Calling OneDir.AddNumber( {0}, {1})", a, b);
                ProcedureResults prs = odc.AddNumbers(scm, a, b, ref c);
                Console.WriteLine("\t {0} + {1} = {2}", a, b, c);
                Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n",prs.ReturnValue, prs.ResultsXml);
                Assert.AreEqual(110, c.Value,"Add Number");
            }
        }


        [Test]
        public void MultiplyNumbers()
        {
            //
            // Or use the plain model of creating and consuming the connection manager.
            //  Following also achieves the same resource release as done in the using()
            //  model. The only difference is that you are forced to create a new 
            //  try{} statement block to encapsulate the scm2.
            //  and then you have to do the finally{} block to explicitly dispose
            //  the state in the scm2 object.
            //
            Console.WriteLine( "Calling OneDir.MultiplyNumbers( {0}, {1})", a, b);
            SimpleConnectionManager scm2 = null;
            try
            {
                SqlInt64 c = new SqlInt64(0);
                scm2 = new SimpleConnectionManager();
                Console.WriteLine( "Calling OneDir.MultiplyNumbers( {0}, {1})", a, b);
                ProcedureResults prs = odc.MultiplyNumbers(scm2, a, b, ref c);
                Console.WriteLine("\t {0} x {1} = {2}", a, b, c);
                Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n",prs.ReturnValue, prs.ResultsXml);
                Assert.AreEqual(1000, c.Value,"Multiple number");
            }
            catch(Exception e)
            {
                // catch any exceptions
                Console.WriteLine(e.StackTrace);
            }
            finally
            {
                // dispose connection manager.
                if (scm2 != null)
                {
                    scm2.Dispose();
                }
            }
        }


        [Test]
        public void DivideNumbers()
        {
            using(SimpleConnectionManager scm = new SimpleConnectionManager())
            {
                string errMsg = new String( ' ', 20);
                SqlInt32 retVal = new SqlInt32(0);
                Console.WriteLine( "Calling OneDir.DivideNumbers( {0}, {1})", a, b);
                ProcedureResults prs = odc.DivideNumbers(scm, a, b, ref retVal, ref errMsg);
                Console.WriteLine("\t {0} / {1} = {2}\r\n.Return Message: {3}", a, b, retVal, errMsg);
                Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n", prs.ReturnValue, prs.ResultsXml);
                Assert.AreEqual(10, retVal.Value,"Divide Numbers");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\DataReaderTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
	/// <summary>
	/// Test DataReader Output
	/// </summary>
	[TestFixture]
    public class DataReaderTest
    {

		public DataReaderTest()
		{

		}
        [Test]
        public void ReturnReader()
        {
            using(SimpleConnectionManager scm = new SimpleConnectionManager())
            {
                OneDirData odd = new OneDirData();
                IDataReader reader = null;
                try
                {
                    reader = odd.ReturnReader(scm);
                    while(reader.Read())
                    {
                        Console.WriteLine(reader.GetString(0));
                    }
                }
                finally
                {
                    // must close reader
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\SqlStringTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
    /// <summary>
    /// Summary description for SqlStringTest.
    /// </summary>
    [TestFixture]
    public class SqlStringTest
	{
        OneDirData onedir = new OneDirData();

        [Test]
        public void TestStringInputNotNullOutputNotNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                string input = "SCS";
                string output = "test";
                onedir.TestSqlString(
                    scm,
                    input,
                    false,
                    ref output);
                Assert.IsNotNull("output = null!", output);
                Assert.AreEqual(output, "SCS Rocks!");
                    
            }
        }

        [Test]
        public void TestStringInputNullOutputNotNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                string input = null;
                string output = null;
                onedir.TestSqlString(
                    scm,
                    input,
                    false,
                    ref output);
                Assert.IsNotNull("output = null!", output);
                Assert.AreEqual("SPIL Rocks!", output);
                    
            }
        }

        [Test]
        public void TestStringInputNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                string input = null;
                string output = null;
                onedir.TestSqlString(
                    scm,
                    input,
                    true,
                    ref output);
                Assert.IsNull(output);                    
            }
        }

        [Test]
        public void TestStringInputNotNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                string input = null;
                string output = "test";
                onedir.TestSqlString(
                    scm,
                    input,
                    true,
                    ref output);
                Assert.IsNull(output);                    
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\SqlDecimalTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
	/// <summary>
	/// Summary description for SqlDecimalTest.
	/// </summary>
    [TestFixture]
    public class SqlDecimalTest
    {
        OneDirData onedir = new OneDirData();

        [Test]
        public void TestSqlDecimal()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlDecimal c = SqlDecimal.Null;
                onedir.TestSqlDecimal(scm, (decimal)1.0, (decimal)2.0, ref c);
                Assert.AreEqual(c.Value, 3.0,"c != 3.0");
            }
        }

        [Test]
        public void TestSqlDecimalInputNullOutputNotNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlDecimal c = SqlDecimal.Null;
                onedir.TestSqlDecimal(scm, SqlDecimal.Null,(decimal) 2.0, ref c);
                Assert.AreEqual(c.Value, 2.0,"c != 2.0");
            }
        }

        [Test]
        public void TestSqlDecimalInputNotNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlDecimal c = new SqlDecimal(5.0);
                onedir.TestSqlDecimal(scm, SqlDecimal.Null, SqlDecimal.Null, ref c);
                
                Assert.AreEqual(c, SqlDecimal.Null,"c != SqlDecimal.Null");
            }

        }
        [Test]
        public void TestSqlDecimalInputNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlDecimal c = SqlDecimal.Null;
                onedir.TestSqlDecimal(scm, SqlDecimal.Null, SqlDecimal.Null, ref c);
                
                Assert.AreEqual(c, SqlDecimal.Null,"c != SqlDecimal.Null");
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\cs\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\TestMultiDir.cs ===
using System;
using Microsoft.Subscriptions.Test;
using Microsoft.Subscriptions.Data;

namespace client
{
    /// <summary>
    /// Summary description for TestMultiDir.
    /// </summary>
    public class TestMultiDir
    {
        
        
        public TestMultiDir()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        public void Test(string name)
        {
            using(SimpleConnectionManager scm = new SimpleConnectionManager())
            {
                Random r = new Random();
                MultiDirData mdd = new MultiDirData();
                int id = r.Next();
                Console.WriteLine("\n#### Adding Account: [id: {0}, Name: '{1}']", id, name);
                ProcedureResults prs = mdd.AddName(scm, name, id);

                if(prs.ReturnValue == 0)
                    Console.WriteLine("Success.");
                else
                    Console.WriteLine("Failed.");

                id = r.Next();
                Console.WriteLine("\n#### Adding Another Account: [id: {0}, Name: '{1}']", id, name + "2");
                prs = mdd.AddName(scm, name + "2", id);

                if(prs.ReturnValue == 0)
                    Console.WriteLine("Success.");
                else
                    Console.WriteLine("Failed.");

                Console.WriteLine("\n#### Searching for [Name: '{0}']", name);
                //FindName searches for name on all partitions.
                ProcedureResults[] prsn = mdd.FindName(scm, name);
                foreach(ProcedureResults pr in prsn)
                {
                    if(pr.ReturnValue == 0)
                    {
                        Console.WriteLine("Success.");
                        Console.WriteLine(pr.ResultsXml);
                    }
                    else
                        Console.WriteLine("Failed.");
                }
            
                Console.WriteLine("\n#### Deleting Account: [Name: '{0}']", name);
                prs = mdd.DeleteName(scm, name);
                if(prs.ReturnValue == 0)
                    Console.WriteLine("Success.");
                else
                    Console.WriteLine("Failed.");
            
                // Delete a null string name.
                Console.WriteLine("\n#### Deleting Account: name = null");
                try
                {
                    prs = mdd.DeleteName(scm, null);
                    if(prs.ReturnValue == 0)
                        Console.WriteLine("Success.");
                    else
                        Console.WriteLine("Failed.");
                }
                catch(DataStoreException dse)
                {
                    Console.WriteLine(dse.Message);
                    Console.WriteLine(" - return value: " + prs.ReturnValue);
                    Console.WriteLine(" - dataset: \n" + prs.ResultsXml);
                }
            
                //do a search on the deleted name again.
                Console.WriteLine("\n#### Searching for [Name: '{0}']", name);
                //FindName searches for name on all partitions.
                prsn = mdd.FindName(scm, name);
                foreach(ProcedureResults pr in prsn)
                {
                    if(pr.ReturnValue == 0)
                    {
                        Console.WriteLine("Success.");
                        Console.WriteLine(pr.ResultsXml);
                    }
                    else
                        Console.WriteLine("Failed.");
                }

                //catch an exception thrown from SQL
                Console.WriteLine("\n####Catching exceptions:");
                try
                {
                    prs = mdd.ErrorName(scm);
                }
                catch(DataStoreException dse)
                {
                    Console.WriteLine(dse.Message);
                    Console.WriteLine(" - return value: " + prs.ReturnValue);
                    Console.WriteLine(" - dataset: \n" + prs.ResultsXml);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\SqlVariantTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
	/// <summary>
	/// Summary description for SqlVariantTest.
	/// </summary>
	[TestFixture]
	public class SqlVariantTest
	{
        OneDirData onedir = new OneDirData();
        /// <summary>
        /// Test sql_variant input/output parameter
        /// </summary>
        [Test]
        public void SqlVariantParameter()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                object input = 4;
                object output = 1;
                onedir.TestSqlVariant(scm, input, false, ref output);
                Assert.IsNotNull(output);
                Assert.AreEqual(output, ((int)input + 1), "output != input + 1");
            }
        }

        [Test]
        public void SqlVariantParameterInputNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                object input = 4;
                object output = null;
                onedir.TestSqlVariant(scm, input, true, ref output);
                if (output != null)
                    Console.WriteLine("output {0}", output.GetType());
                Assert.IsNull(output, "output is not null");
            }
        }

        [Test]
        public void SqlVariantParameterInputNotNullOutputNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                object input = 4;
                object output = "test";
                onedir.TestSqlVariant(scm, input, true, ref output);
                if (output != null)
                    Console.WriteLine("output {0}", output.GetType());
                Assert.IsNull(output, "output is not null");
            }
        }

        [Test]
        public void SqlVariantParameterInputNullOutputNotNull()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                object input = null;
                object output = null;
                onedir.TestSqlVariant(scm, input, false, ref output);
                Assert.AreEqual(1, output, "output is not 1");
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\TraceEventTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;

namespace Microsoft.Subscriptions.Data.Test
{
	/// <summary>
	/// Summary description for TraceEventTest.
	/// </summary>
	[TestFixture]
	public class TraceEventTest
	{
        protected OneDirData onedir = new OneDirData();
        internal StopWatch stopWatch = new StopWatch();
        

        [Test]
        public void TestTraceSqlInfo()
        {
            using(SimpleConnectionManager scm = new
                      SimpleConnectionManager())
            {
                SqlInt32 c = SqlInt32.Null;
                onedir.Context.OnQueryStart += new Microsoft.Subscriptions.Data.DataStoreContext.QueryStartEventHandler(QueryStart);
                onedir.Context.OnTraceMessage +=new Microsoft.Subscriptions.Data.DataStoreContext.DataStoreTraceEventHandler(TraceMessage);
                onedir.Context.OnQueryEnd += new Microsoft.Subscriptions.Data.DataStoreContext.QueryEndEventHandler(QueryEnd);
                onedir.TestSqlInt(scm, 1, 2, ref c);
                onedir.TestSqlInt(scm, 1, 2, ref c);
                onedir.TestSqlInt(scm, 1, 2, ref c);
                IDataReader reader = onedir.ReturnReader(scm);
                reader.Read();
                reader.Close();
                reader.Dispose();
                // get return value. This is not a thread-safe way to get return value

                Console.WriteLine("Return Value: " + DataStoreComponent.GetReturnValue(onedir.Context));
            }
            //Console.WriteLine(DataStoreContext.Current.Connection.State);
        }

        private void TraceMessage(object sender, DataStoreTraceEventArgs e)
        {
            Console.WriteLine(e.Message);
            // validate
            Assert.AreEqual("sum is 3", e.Message);
        }

        private void QueryStart(object sender, DataStoreContext.QueryStartEventArgs e)
        {
            Console.WriteLine("Starting Query");
            stopWatch.Start();
        }

        private void QueryEnd(object sender, DataStoreContext.QueryEndEventArgs e)
        {
            stopWatch.Stop();
            Console.WriteLine("Ending Query");
            Console.WriteLine("Query took " + stopWatch.Duration + " seconds");
            Console.WriteLine("Query text " + onedir.Context.Command.CommandText);
            Console.WriteLine("Connection: " + onedir.Context.Connection.State);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\cs\PartitionAlgorithm.cs ===
using System;
using Microsoft.Subscriptions.Data;
using System.Data;
using System.Data.SqlTypes;

namespace Microsoft.Subscriptions.DataStore.PartitionAlgorithms
{
	/// <summary>
	/// Summary description for PartitionAlgorithm.
	/// </summary>
	public class GlobalLookup
	{
		private GlobalLookup()
		{
		}

        ///<summary>
        /// Simple hash for any instance
        ///</summary>
        ///<param name="a"></param>
        public static int UseNum1Hash( int a) {
            // For NOW return that any partition is valid
            return DataStoreComponent.HashValueForAnyInstance;
        }

        ///<summary>
        /// Simple hash for any instance
        ///</summary>
        ///<param name="a"></param>
        ///<param name="dtTime"></param>
        public static int UseNum1TemporalHash( int a, SqlDateTime dtTime) {
            // For NOW return that any partition is valid
            // Ignore the temporal value supplied as dtTime as well ...

            return DataStoreComponent.HashValueForAnyInstance;
        }

     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\installers\sample\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\TransactionTest.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;
using Microsoft.Subscriptions.Test;


namespace Microsoft.Subscriptions.Data.Test
{
	/// <summary>
	/// This sample shows how to use TransactionWrapper in SPIL
	/// </summary>
	[TestFixture]
    public class TransactionTest
	{
        OneDirData onedir = new OneDirData();

        [Test]
        public void CompleteTransaction()
        {
            // use transaction wrapper
            using(TransactionWrapper tw = new TransactionWrapper(TransactionScope.SingleSqlDatabase))
            {
                using(SimpleConnectionManager scm = 
                          new SimpleConnectionManager())
                {   
                    onedir.DeleteCompany(scm, "MSFT");
                    onedir.InsertCompany(scm, "MSFT", "Microsoft Corp.");
                }
                // complete transaction
                tw.SetComplete();
            }

            // verify the company is inserted
            using(SimpleConnectionManager scm = new SimpleConnectionManager())
            {
                ProcedureResults pr = onedir.GetCompany(scm, "MSFT");
                Assert.AreEqual(pr.Results.Tables[0].Rows[0][1], "Microsoft Corp.");
            }

            // remove company symbol
            using(TransactionWrapper tw = new TransactionWrapper(TransactionScope.SingleSqlDatabase))
            {
                using(SimpleConnectionManager scm = 
                          new SimpleConnectionManager())
                {   
                    onedir.DeleteCompany(scm, "MSFT");
                }
                // complete transaction
                tw.SetComplete();
            }
        }

        [Test]
        public void AbortTransaction()
        {
            // use transaction wrapper
            using(TransactionWrapper tw = new TransactionWrapper(TransactionScope.SingleSqlDatabase))
            {
                using(SimpleConnectionManager scm = 
                          new SimpleConnectionManager())
                {   
                    onedir.DeleteCompany(scm, "MSFT");
                    onedir.InsertCompany(scm, "MSFT", "Microsoft Corp.");
                }
                // don't call SetComplete automatically abort transaction
                // tw.SetComplete();
            }

            // verify the company is inserted
            using(SimpleConnectionManager scm = new SimpleConnectionManager())
            {
                ProcedureResults pr = onedir.GetCompany(scm, "MSFT");
                // no row is selected out
                Assert.AreEqual(pr.Results.Tables[0].Rows.Count, 0);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\MultiDir\create\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\MultiDir\detach\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\MultiDir\populate\SP1\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\MultiDir\populate\SP2\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\MultiDir\populate\spgen\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\MultiDir\populate\tbl\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\OneDir\Create\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\StopWatch.cs ===
using System;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Threading;

namespace Microsoft.Subscriptions.Data.Test
{
    internal class StopWatch
    {
        private long startTime, stopTime;
        private long freq;

        private class NativeMethods
        {
            [DllImport("Kernel32.dll")]
            public static extern bool QueryPerformanceCounter(
                out long lpPerformanceCount);

            [DllImport("Kernel32.dll")]
            public static extern bool QueryPerformanceFrequency(
                out long lpFrequency);
        }
        // Constructor
        public StopWatch()
        {
            startTime = 0;
            stopTime  = 0;

            if (NativeMethods.QueryPerformanceFrequency(out freq) == false)
            {
                // high-performance counter not supported
                throw new Win32Exception();
            }
        }

        /// <summary>
        /// Start the timer
        /// </summary>
        public void Start()
        {
            Thread.Sleep(0);

            NativeMethods.QueryPerformanceCounter(out startTime);
        }

        /// <summary>
        /// Stop the timer
        /// </summary>
        public void Stop()
        {
            NativeMethods.QueryPerformanceCounter(out stopTime);
        }

        /// <summary>
        /// Returns the duration of the timer (in seconds) 
        /// </summary>
        public double Duration
        {
            get
            {
                return (double)(stopTime - startTime) / (double) freq;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\OneDir\detach\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\OneDir\populate\sp\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\OneDir\populate\tbl\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\unittest\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS SPIL Test")]
[assembly: AssemblyDescription("Console application to test SPIL")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

//[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\client\TestDriver.cs ===
using System;
using System.Data.SqlTypes;
using NUnit.Framework; // for NUnit
using Microsoft.Subscriptions.Data; // for SpilRun
using System.Data.SqlClient; // for SqlException
using System.Data;

namespace Microsoft.Subscriptions.Test
{
	/// <summary>
	/// Summary description for Main.
	/// </summary>
	[TestFixture]
	public class TestOneDir
	{
		protected OneDirClass odc = new OneDirClass();
		protected int a = 100;
		protected int b = 10;
            
		public static void Main()
		{
			TestOneDir tod = new TestOneDir();
			tod.Init();
			tod.TestAddNumbers();
			tod.TestDivideNumbers();
			tod.TestDivideNumbersWithSqlErrors();
			tod.TestMultiplyNumbers();
			tod.TestOutputParam();
			tod.TestOutputParamsWithSqlErrors();
			tod.TestReader();
		}

		[SetUp]
		public void Init()
		{
		}
            
		[Test]
		public void TestAddNumbers()
		{
			SqlInt64 c = new SqlInt64(0);
			// 
			// Use the "using()" statement model for resource reclamation
			// from the connection manager created. Internally at runtime,
			// automatic code is executed to call the IDispose interface on 
			// the connection manager object.
			// 
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
				Console.WriteLine( "Calling OneDir.AddNumber( {0}, {1})", a, b);
				ProcedureResults prs = odc.AddNumbers(scm, a, b, ref c);
				Console.WriteLine("\t {0} + {1} = {2}", a, b, c);
				Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n",prs.ReturnValue, prs.ResultsXml);
				//Assertion.AssertEquals("Add Number", 110, c.Value);
			}
		}

        [Test]
        public void TestSqlDecimalWithValue()
        {
            TestSqlDecimalRoutine(new SqlDecimal(3.0), new SqlMoney(2.0), new SqlDecimal(4.0));
        }
        
        [Ignore("This is an internal procedure")]
		private void TestSqlDecimalRoutine(SqlDecimal a, SqlMoney b, SqlDecimal sum)
		{
            string s = "";
			// 
			// Use the "using()" statement model for resource reclamation
			// from the connection manager created. Internally at runtime,
			// automatic code is executed to call the IDispose interface on 
			// the connection manager object.
			// 
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
				Console.WriteLine( "Calling OneDir.ParamSqlDecimal( {0}, {1})", a, b);
				ProcedureResults prs = odc.ParamSqlDecimal(scm, a, b, ref sum, ref s);
				Console.WriteLine("\t {0} + {1} = {2}", a, b, sum);
				Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n",prs.ReturnValue, prs.ResultsXml);
				//Assertion.AssertEquals("Add Number", 110, c.Value);
			}
		}

        [Test]
		public void TestSqlDecimalNull()
		{
		    TestSqlDecimalRoutine(SqlDecimal.Null, SqlMoney.Null, new SqlDecimal(1.0));	
            
            
		}

		[Test]
		public void TestMultiplyNumbers()
		{
			//
			// Or use the plain model of creating and consuming the connection manager.
			//  Following also achieves the same resource release as done in the using()
			//  model. The only difference is that you are forced to create a new 
			//  try{} statement block to encapsulate the scm2.
			//  and then you have to do the finally{} block to explicitly dispose
			//  the state in the scm2 object.
			//
			Console.WriteLine( "Calling OneDir.MultiplyNumbers( {0}, {1})", a, b);
			SimpleConnectionManager scm2 = null;
			try
			{
				SqlInt64 c = new SqlInt64(0);
				scm2 = new SimpleConnectionManager();
				Console.WriteLine( "Calling OneDir.MultiplyNumbers( {0}, {1})", a, b);
				ProcedureResults prs = odc.MultiplyNumbers(scm2, a, b, ref c);
				Console.WriteLine("\t {0} x {1} = {2}", a, b, c);
				Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n",prs.ReturnValue, prs.ResultsXml);
				//Assertion.AssertEquals("Multiple number", 1000, c.Value);
			}
			catch(Exception e)
			{
				// catch any exceptions
				Console.WriteLine(e.StackTrace);
			}
			finally
			{
				// dispose connection manager.
				scm2.Dispose();
				scm2 = null;
			}
		}

		[Test]
		public void TestDivideNumbers()
		{
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
                using(TransactionWrapper trans = new TransactionWrapper(TransactionScope.SingleSqlDatabase))
                {
				string errMsg = new String( ' ', 20);
				SqlInt32 retVal = new SqlInt32(0);
				Console.WriteLine( "Calling OneDir.DivideNumbers( {0}, {1})", a, b);
				ProcedureResults prs = odc.DivideNumbers(scm, a, b, ref retVal, ref errMsg);
				Console.WriteLine("\t {0} / {1} = {2}\r\n.Return Message: {3}", a, b, retVal, errMsg);
				Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n", prs.ReturnValue, prs.ResultsXml);
				//Assertion.AssertEquals("Divide Numbers", 10, retVal.Value);
			    trans.SetComplete();
                Console.Write("Transaction Complete.");
            }
            }
		}

		[Test]
		public void TestDivideNumbersWithSqlErrors()
		{
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
				string errMsg = new String( ' ', 20);
				SqlInt32 retVal = new SqlInt32(0);
				int d = 0;
				Console.WriteLine( "Calling OneDir.DivideNumbers( {0}, {1}) with zero for divisor", a, b);
				ProcedureResults prs = odc.DivideNumbers(scm, a, d, ref retVal, ref errMsg);
				Console.WriteLine("\t {0} / {1} = {2}\r\n.Return Message: {3}", a, d, retVal, errMsg);
				Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n", prs.ReturnValue, prs.ResultsXml);
					
			}
		}

		[Test]
		public void TestOutputParam()
		{
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
				SqlInt32 retVal = new SqlInt32(0);
				SqlInt32 i_a = new SqlInt32(1);
				SqlInt32 i_b = new SqlInt32(0);
				string s_c = null;//"this is an input varchar";
				SqlDateTime d_dt = SqlDateTime.Null;
                //SqlDateTime d_dt = new SqlDateTime(DateTime.Now);

				ProcedureResults prs = odc.OutputParam(scm, i_a, ref i_b, ref s_c, ref d_dt);
				Console.WriteLine("\t b = {0} \t c = {1} \t d = {2}", i_b, s_c, d_dt);
				Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n", prs.ReturnValue, prs.ResultsXml);
				//Assertion.AssertEquals("SQL output parameter integer", 2, i_b.Value);
				//Assertion.AssertEquals("SQL output parameter string", "This is a output varchar", s_c);
				//Assertion.AssertNotNull("SQL output parameter datetime", d_dt.Value);
			}
		}

		[Test]
		public void TestOutputParamsWithSqlErrors()
		{
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
				SqlInt32 retVal = new SqlInt32(0);
				SqlInt32 i_level = 11;
				SqlInt32 i_b = new SqlInt32(0);
				SqlInt32 i_c = new SqlInt32(0);
				Console.WriteLine( "Calling OneDir.OutputParamsRaise( {0}, {1}, {2})", i_level, i_b, i_c);
				try
				{
					odc.OutputParamsRaise(scm, i_level, ref i_b, ref i_c);
				}
				catch(DataStoreException dse)
				{
						
					ProcedureResults prs = dse.ProcedureResults;
					Console.WriteLine("\t output1 = {0} ", i_b);
					Console.WriteLine("\t output2 = {0} ", i_c);
					Console.WriteLine("\t Return value is : {0}\nXmlReturned\n{1}\n\n", prs.ReturnValue, prs.ResultsXml);
					//Assertion.AssertEquals("SQL output parameter b", 5, i_b.Value);
					//Assertion.AssertEquals("SQL output parameter c", 6, i_c.Value);
						
					SqlException sqle = (SqlException) dse.InnerException;
					foreach(SqlError err in sqle.Errors)
					{
						Console.WriteLine(
							String.Format("Sql Error: Number: {0} State: {1} Message: {2} LineNo: {3}",
							err.Number, err.State, err.Message, err.LineNumber));
					}
				}
			}
		}

		[Test]
		public void TestReader()
		{
			using(SimpleConnectionManager scm = new SimpleConnectionManager())
			{
				OneDirData odd = new OneDirData();
				IDataReader reader = odd.ReturnReader(scm);
				while(reader.Read())
				{
					Console.WriteLine(reader.GetString(0));
				}
				reader.Close();
			}
		}
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\installers\cab\makefile.inc ===
MakeCabs:
! if "$(LINKONLY)"=="1"
    echo Build_Status CabArc - Cabbing Spiller Sample sources
    echo cabArc -r -p -P ..\..\ N ..\..\SpillerSample.cab ..\..\source* ..\..\dirs ..\..\makefile* ..\..\*.sql ..\..\*.cs
    cabArc -r -p -P ..\..\ N ..\..\SpillerSample.cab ..\..\source* ..\..\dirs ..\..\makefile* ..\..\*.sql ..\..\*.cs
! endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Sample\unittest\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilAnnotator\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilAnnotator\Logging.cs ===
/*
 *  Logging.cs
 * 
 *  Interface and classes to help with logging messages
 * 
 *  Logging utility consists of following components:
 *      IAuditLog   - an interface for hiding the logger
 *      LogRouter classes - a set of classes that implement IAuditLog 
 *          and route log messages to registered loggers
 *      AddToLogEventHandler()  - a delegate used to send log messages from 
 *          IAuditLog implementor to the loggers
 *      a family of loggers - to log the message
 * 
 *  Usage:
 *    - create an instance of some IAuditLog implementor
 *      eg:   SimpleLogRouter slr = new SimpleLogRouter()
 *    - create desired loggers and register the same with log router
 *      eg:  DebugLogger dl = new DebugLogger()
 *           slr.LogNotifications += new AddToLogEventHandler( dl.AddToLog);
 *    - just send log messages
 *          IAuditLog ial = slr as IAuditLog;
 *          ial.SendToLog( sender, "my log message");
 * 
 * Revision History:
 *  Jan 2003 - TaoH      - pull from Utility library into spiller
 *  March 2002  - MuraliK      - created for SPG Bable project
 *  Aug 6, 2002 - JimGils/MuraliK   - added namespace; cleaned up for wider use
 */

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace Microsoft.Subscriptions.Utility
{
    public enum LogEventLevel
    {
        Verbose = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
        Fatal = 4,
        MaxValue = 5,
    };

    /// <summary>
    /// interface IAuditLog
    /// o  Specifies the interface for logging messages.
    /// Log router will implement the IAuditLog. Several loggers
    /// can be registered to the log router. Log Router will route
    /// log messages to such registered loggers.
    /// </summary>
    public interface IAuditLog 
    {
        /// <summary>
        /// Sends a specified message to the registered loggers.
        /// </summary>
        /// <param name="msg">Message to send.</param>
        void SendToLog(object sender, string msg);

        /// <summary>
        /// Sends specified message along with the log level to the registered logs
        /// </summary>
        /// <param name="lel">EventLevel at which to log.</param>
        /// <param name="msg"></param>
        void SendToLog(object sender, LogEventLevel level, string msg);

        /// <summary>
        /// Composes a single message with the variable list of arguments 
        /// and sends the message with specified log level to the registered logs.
        /// </summary>
        /// <param name="l">EventLevel at which to log.</param>
        /// <param name="parameters">Arguments to log.</param>
        void SendToLog(object sender, LogEventLevel level, params object[] parameters);
    }

    /// <summary>
    /// Class used to specify the arguments of log message sent to loggers.
    /// </summary>
    public class AuditLogEventArgs : EventArgs {
        private LogEventLevel level;     // level of this log message
        private string   message;        // the message to be logged

        public LogEventLevel Level
        {
            get { return level; }
            set { level = value; }
        }

        public string Message
        {
            get { return message; }
            set { message = value; }
        }

        public AuditLogEventArgs( string msg) {
            message = msg;
            level = LogEventLevel.Info;
        }

        public AuditLogEventArgs( string msg, LogEventLevel lvl) {
            message = msg;
            level = lvl;
        }
    } // class AuditLogEventArgs

    /// <summary>
    ///     AddToLogEventHandler() is the delegate that is used to send out the log messages.
    ///     Loggers should register this specific delegate function to receive messages.
    /// </summary>
    public delegate void AddToLogEventHandler( object sender, AuditLogEventArgs e);

    /// <summary>
    /// Simple Log Router - provides the basic level of log routing functionality.
    /// It implements the IAuditLog interface and maintains a set of registered loggers.
    /// It also maintains per-event level log statistics.
    /// </summary>
    public class SimpleLogRouter : IAuditLog  
    {
        private event AddToLogEventHandler logHandlers;
        private LogEventLevel levelThreshold = LogEventLevel.Info;
        private int[] logStats = new int[Enum.GetValues(typeof(LogEventLevel)).Length];

        public SimpleLogRouter(LogEventLevel lel) 
        {
            levelThreshold = lel;
            for(int i = 0; i < Enum.GetValues(typeof(LogEventLevel)).Length; i++) 
            {
                logStats[i] = 0;
            }
        }

        public event AddToLogEventHandler LogNotifications 
        {
            add { logHandlers += value; }
            remove { logHandlers -= value; }
        }

        public LogEventLevel Threshold 
        {
            get { return levelThreshold; }
            set { levelThreshold = value; }
        }

        #region IAuditLog methods
        public void SendToLog(object sender, string msg) 
        {
            if ( LogEventLevel.Info > levelThreshold) {
                NotifyHandlers(sender, msg);
            }
        }

        public void SendToLog(object sender, LogEventLevel level, string msg) 
        {
            if (level >= levelThreshold) 
            {
                string logType = LogLevelToString(level);
                NotifyHandlers( sender, level, logType + ": " + msg);
            }
        }

        public void SendToLog(object sender, LogEventLevel level, params object[] parameters) 
        {
            Debug.Assert(parameters.Length >= 1);
            if (parameters.Length > 1) 
            {
                StringBuilder sb = new StringBuilder();

                foreach(object o in parameters) 
                    sb.Append(o);

                this.SendToLog(sender, level, sb.ToString());
            }
            else 
            {
                this.SendToLog(sender, level, parameters[0].ToString());
            }
        }
        #endregion IAuditLog methods

        private void NotifyHandlers( object sender, string msg) 
        {
            AuditLogEventArgs ala = new AuditLogEventArgs( msg);

            if (logHandlers != null) 
                logHandlers( sender, ala);
        }

        private void NotifyHandlers( object sender, LogEventLevel level, string msg) {
            AuditLogEventArgs ala = new AuditLogEventArgs( msg, level);

            if (logHandlers != null) 
                logHandlers( sender, ala);
        }


        static readonly string[] StringsForLogEventLevel;
        const int NumValuesForLogEventLevel = (int)LogEventLevel.MaxValue + 1;

        static SimpleLogRouter() {
            StringsForLogEventLevel = new string[NumValuesForLogEventLevel];
            int[] alValues = (int[]) Enum.GetValues(typeof(LogEventLevel));
            for(int i = 0; i < alValues.Length; i++) {
                StringsForLogEventLevel[i] = Enum.GetName(typeof(LogEventLevel), alValues[i]);
            }
        }

        static private string LogLevelToString(LogEventLevel lel) {
            return StringsForLogEventLevel[(int)lel];
        }
    } // class SimpleLogRouter


    // -------------------------------------------------------------------
    //  SET OF pre-defined LOGGERs
    //
    //  DebugLogger - to log to debug stream
    //  ConsoleLogger - logs to the console
    //  FileLogger  - to log to specified file
    //
    //  EntryExitLogger - logs entry/exit/info about method calls
    // -------------------------------------------------------------------

    /// <summary>
    ///  Writes the log messages to the standard debug log
    /// </summary>
    public class DebugLogger {

        [MethodImpl(MethodImplOptions.Synchronized)]
        public void AddToLog( object sender, AuditLogEventArgs ala) {
            System.Diagnostics.Debug.WriteLine( ala.Message);
        }
    } // class DebugLogger

    /// <summary>
    ///  Writes the log messages to the standard console 
    /// </summary>
    public class ConsoleLogger {

        [MethodImpl(MethodImplOptions.Synchronized)]
        public void AddToLog( object sender, AuditLogEventArgs ala) {
            switch (ala.Level) {
                case LogEventLevel.Error:
                case LogEventLevel.Fatal:
                    Console.Error.WriteLine( "spiller : error : " + ala.Message);
                    break;
                
                case LogEventLevel.Warning:
                    Console.WriteLine( "spiller : warning : " + ala.Message);
                    break;
                
                default:
                    Console.WriteLine( "spiller: " + ala.Message);
                    break;
            } // swithc
        }
    } // class ConsoleLogger

    /// <summary>
    /// class FileLogger
    /// o  This class logs the messages sent to it in a file. 
    /// It makes no interpretation of the messages themselves.
    /// </summary>
    public class FileLogger
    {
        System.IO.StreamWriter sw = null;

        public FileLogger(string fileName) 
        {
            FileStream fs = 
                new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite);
            sw = new StreamWriter( fs);
        }

        ~FileLogger() 
        {
            this.Close();
        }

        public void Close() 
        {
            if ( sw != null) 
            {
                sw.Close();
                sw = null;
            }
        }

        [MethodImpl(MethodImplOptions.Synchronized)]
        public void AddToLog( object sender, AuditLogEventArgs ala) 
        {
            sw.WriteLine( ala.Message);
        }
    } // class FileLogger

    /// <summary>
    /// EntryExitLogger is useful for indicating when some method 
    ///     is entered and exited
    /// </summary>
    public class EntryExitLogger {
        private object sender = null;
        private string owner;
        private IAuditLog ial;

        public EntryExitLogger (string owner, IAuditLog ial) {
            this.owner = owner;
            this.ial = ial;
        }

        public void LogEntry(string what) {
            ial.SendToLog( sender, "[+" + owner + "] " + what);
        }

        public void LogExit(string what) {
            ial.SendToLog( sender, "[-" + owner + "] " + what);
        }

        public void LogInfo(string what) {
            ial.SendToLog( sender, LogEventLevel.Info, "[" + owner + "] " + what);
        }
    } // class EntryExitLogger

} // namespace Microsoft.Subscriptions.Utility.Logging
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilAnnotator\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Permissions;
using System.Runtime.InteropServices;
//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("SPIL Annotator")]
[assembly: AssemblyDescription("Annotate SQL source file with SPIL attributes")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft SPG")]
[assembly: AssemblyProduct("SPIL")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

//[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]

// It is a good thing to have CLSCompliance - hence marking it
[assembly:CLSCompliant(true)]

// Thanks a lot - i do not need COM anymore! the default is true - so mark it false
[assembly:ComVisible(false)]
//
// Require that at minimum the user should be able to read the INETROOT and SDPORT environment permission
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="INETROOT")]
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="SDPORT")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\AssemblyInfoIDE.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS SPIL Code Generator")]
[assembly: AssemblyDescription("Console application to generate code for database stored procedires")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Subscription Platform Services")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]         

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// Version Info comes from separate file!
// [assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]

// Since this is the version of AssemblyInfo file used for IDE, we massage the key file path
[assembly: AssemblyKeyFile("..\\..\\spiller.snk")]
[assembly: AssemblyKeyName("")]

// It is a good thing to have CLSCompliance - hence marking it
[assembly:CLSCompliant(true)]

// Thanks a lot - i do not need COM anymore! the default is true - so mark it false
[assembly:ComVisible(false)]
//
// Require that at minimum the user should be able to read the USERNAME environment permission
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="USERNAME")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS SPIL Code Generator")]
[assembly: AssemblyDescription("Console application to generate code for database stored procedires")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Subscription Platform Services")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]         

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// Version Info comes from separate file!
// [assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile(@"spiller.snk")]
[assembly: AssemblyKeyName("")]

// It is a good thing to have CLSCompliance - hence marking it
[assembly:CLSCompliant(true)]

// Thanks a lot - i do not need COM anymore! the default is true - so mark it false
[assembly:ComVisible(false)]
//
// Require that at minimum the user should be able to read the USERNAME environment permission
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="USERNAME")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\Logging.cs ===
/*
 *  Logging.cs
 * 
 *  Interface and classes to help with logging messages
 * 
 *  Logging utility consists of following components:
 *      IAuditLog   - an interface for hiding the logger
 *      LogRouter classes - a set of classes that implement IAuditLog 
 *          and route log messages to registered loggers
 *      AddToLogEventHandler()  - a delegate used to send log messages from 
 *          IAuditLog implementor to the loggers
 *      a family of loggers - to log the message
 * 
 *  Usage:
 *    - create an instance of some IAuditLog implementor
 *      eg:   SimpleLogRouter slr = new SimpleLogRouter()
 *    - create desired loggers and register the same with log router
 *      eg:  DebugLogger dl = new DebugLogger()
 *           slr.LogNotifications += new AddToLogEventHandler( dl.AddToLog);
 *    - just send log messages
 *          IAuditLog ial = slr as IAuditLog;
 *          ial.SendToLog( sender, "my log message");
 * 
 * Revision History:
 *  March 2002  - MuraliK      - created for SPG Bable project
 *  Aug 6, 2002 - JimGils/MuraliK   - added namespace; cleaned up for wider use
 */

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace Microsoft.Subscriptions.Utility.Logging
{
        public enum LogEventLevel
        {
                Verbose = 0,
                Info = 1,
                Warning = 2,
                Error = 3,
                Fatal = 4,
                MaxValue = 5,
        };

        /// <summary>
        /// interface IAuditLog
        /// o  Specifies the interface for logging messages.
        /// Log router will implement the IAuditLog. Several loggers
        /// can be registered to the log router. Log Router will route
        /// log messages to such registered loggers.
        /// </summary>
        public interface IAuditLog 
        {
                /// <summary>
                /// Sends a specified message to the registered loggers.
                /// </summary>
                /// <param name="msg">Message to send.</param>
                void SendToLog(object sender, string msg);

                /// <summary>
                /// Sends specified message along with the log level to the registered logs
                /// </summary>
                /// <param name="lel">EventLevel at which to log.</param>
                /// <param name="msg"></param>
                void SendToLog(object sender, LogEventLevel level, string msg);

                /// <summary>
                /// Composes a single message with the variable list of arguments 
                /// and sends the message with specified log level to the registered logs.
                /// </summary>
                /// <param name="l">EventLevel at which to log.</param>
                /// <param name="parameters">Arguments to log.</param>
                void SendToLog(object sender, LogEventLevel level, params object[] parameters);
        }

        /// <summary>
        /// Class used to specify the arguments of log message sent to loggers.
        /// </summary>
        public class AuditLogEventArgs : EventArgs 
        {
                private LogEventLevel level;     // level of this log message
                private string   message;        // the message to be logged

                public LogEventLevel Level
                {
                        get { return level; }
                        set { level = value; }
                }

                public string Message
                {
                        get { return message; }
                        set { message = value; }
                }

                public AuditLogEventArgs( string msg) 
                {
                        message = msg;
                        level = LogEventLevel.Info;
                }

                public AuditLogEventArgs( string msg, LogEventLevel lvl) 
                {
                        message = msg;
                        level = lvl;
                }
        } // class AuditLogEventArgs

        /// <summary>
        ///     AddToLogEventHandler() is the delegate that is used to send out the log messages.
        ///     Loggers should register this specific delegate function to receive messages.
        /// </summary>
        public delegate void AddToLogEventHandler( object sender, AuditLogEventArgs e);

        /// <summary>
        /// Simple Log Router - provides the basic level of log routing functionality.
        /// It implements the IAuditLog interface and maintains a set of registered loggers.
        /// It also maintains per-event level log statistics.
        /// </summary>
        public class SimpleLogRouter : IAuditLog  
        {
                private event AddToLogEventHandler logHandlers;
                private LogEventLevel levelThreshold = LogEventLevel.Info;
                private int[] logStats = new int[Enum.GetValues(typeof(LogEventLevel)).Length];

                public SimpleLogRouter(LogEventLevel lel) 
                {
                        levelThreshold = lel;
                        for(int i = 0; i < Enum.GetValues(typeof(LogEventLevel)).Length; i++) 
                        {
                                logStats[i] = 0;
                        }
                }

                public event AddToLogEventHandler LogNotifications 
                {
                        add { logHandlers += value; }
                        remove { logHandlers -= value; }
                }

                public LogEventLevel Threshold 
                {
                        get { return levelThreshold; }
                        set { levelThreshold = value; }
                }

        #region IAuditLog methods
                public void SendToLog(object sender, string msg) 
                {
                        if ( LogEventLevel.Info > levelThreshold) 
                        {
                                NotifyHandlers(sender, msg);
                        }
                }

                public void SendToLog(object sender, LogEventLevel level, string msg) 
                {
                        if (level >= levelThreshold) 
                        {
                                string logType = LogLevelToString(level);
                                NotifyHandlers( sender, level, logType + ": " + msg);
                        }
                }

                public void SendToLog(object sender, LogEventLevel level, params object[] parameters) 
                {
                        Debug.Assert(parameters.Length >= 1);
                        if (parameters.Length > 1) 
                        {
                                StringBuilder sb = new StringBuilder();

                                foreach(object o in parameters) 
                                        sb.Append(o);

                                this.SendToLog(sender, level, sb.ToString());
                        }
                        else 
                        {
                                this.SendToLog(sender, level, parameters[0].ToString());
                        }
                }
        #endregion IAuditLog methods

                private void NotifyHandlers( object sender, string msg) 
                {
                        AuditLogEventArgs ala = new AuditLogEventArgs( msg);

                        if (logHandlers != null) 
                                logHandlers( sender, ala);
                }

                private void NotifyHandlers( object sender, LogEventLevel level, string msg) 
                {
                        AuditLogEventArgs ala = new AuditLogEventArgs( msg, level);

                        if (logHandlers != null) 
                                logHandlers( sender, ala);
                }


                static readonly string[] StringsForLogEventLevel;
                const int NumValuesForLogEventLevel = (int)LogEventLevel.MaxValue + 1;

                static SimpleLogRouter() 
                {
                        StringsForLogEventLevel = new string[NumValuesForLogEventLevel];
                        int[] alValues = (int[]) Enum.GetValues(typeof(LogEventLevel));
                        for(int i = 0; i < alValues.Length; i++) 
                        {
                                StringsForLogEventLevel[i] = Enum.GetName(typeof(LogEventLevel), alValues[i]);
                        }
                }

                static private string LogLevelToString(LogEventLevel lel) 
                {
                        return StringsForLogEventLevel[(int)lel];
                }
        } // class SimpleLogRouter


        // -------------------------------------------------------------------
        //  SET OF pre-defined LOGGERs
        //
        //  DebugLogger - to log to debug stream
        //  ConsoleLogger - logs to the console
        //  FileLogger  - to log to specified file
        //
        //  EntryExitLogger - logs entry/exit/info about method calls
        // -------------------------------------------------------------------

        /// <summary>
        ///  Writes the log messages to the standard debug log
        /// </summary>
        public class DebugLogger 
        {

                [MethodImpl(MethodImplOptions.Synchronized)]
                public void AddToLog( object sender, AuditLogEventArgs ala) 
                {
                        System.Diagnostics.Debug.WriteLine( ala.Message);
                }
        } // class DebugLogger

        /// <summary>
        ///  Writes the log messages to the standard console 
        /// </summary>
        public class ConsoleLogger 
        {

                [MethodImpl(MethodImplOptions.Synchronized)]
                public void AddToLog( object sender, AuditLogEventArgs ala) 
                {
                        switch (ala.Level) 
                        {
                                case LogEventLevel.Error:
                                case LogEventLevel.Fatal:
                                        Console.Error.WriteLine("Spiller : " + ala.Message);
                                        break;
                                case LogEventLevel.Warning:
                                        Console.Error.WriteLine("Spiller : " + ala.Message);
                                        break;
                                default:
                                        Console.WriteLine( ala.Message);
                                        break;
                        } // swithc
                }
        } // class ConsoleLogger

        /// <summary>
        /// class FileLogger
        /// o  This class logs the messages sent to it in a file. 
        /// It makes no interpretation of the messages themselves.
        /// </summary>
        public class FileLogger
        {
                System.IO.StreamWriter sw = null;

                public FileLogger(string fileName) 
                {
                        FileStream fs = 
                                new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite);
                        sw = new StreamWriter( fs);
                }

                ~FileLogger() 
                {
                        this.Close();
                }

                public void Close() 
                {
                        if ( sw != null) 
                        {
                                sw.Close();
                                sw = null;
                        }
                }

                [MethodImpl(MethodImplOptions.Synchronized)]
                public void AddToLog( object sender, AuditLogEventArgs ala) 
                {
                        sw.WriteLine( ala.Message);
                }
        } // class FileLogger

        /// <summary>
        /// EntryExitLogger is useful for indicating when some method 
        ///     is entered and exited
        /// </summary>
        public class EntryExitLogger 
        {
                private object sender = null;
                private string owner;
                private IAuditLog ial;

                public EntryExitLogger (string owner, IAuditLog ial) 
                {
                        this.owner = owner;
                        this.ial = ial;
                }

                public void LogEntry(string what) 
                {
                        ial.SendToLog( sender, "[+" + owner + "] " + what);
                }

                public void LogExit(string what) 
                {
                        ial.SendToLog( sender, "[-" + owner + "] " + what);
                }

                public void LogInfo(string what) 
                {
                        ial.SendToLog( sender, LogEventLevel.Info, "[" + owner + "] " + what);
                }
        } // class EntryExitLogger

} // namespace Microsoft.Subscriptions.Utility.Logging
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\SpilCodeGenerationException.cs ===
using System;
using System.Runtime.Serialization;

namespace Microsoft.Subscriptions.Data.Tools
{
	/// <summary>
	/// Exception thrown during code generation
	/// </summary>
	[Serializable]
	public class SpilCodeGenerationException : Exception, ISerializable
	{
		public SpilCodeGenerationException()
		{
			
		}

        public SpilCodeGenerationException(string message)
            :base(message)
        {
			
        }

        public SpilCodeGenerationException(string message, Exception innerException)
            :base(message, innerException)
        {
			
        }

        public SpilCodeGenerationException(SerializationInfo info, StreamingContext context)
            :base(info, context)
        {
			
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilAnnotator\SpilAnnotator.cs ===
/*
 *  SpilAnnotator.cs
 * 
 *  Program to work with SPS 2.5 Concorde to 
 *      - Extract partition column information for public stored procedure from TowerXML database
 *        - Annotate source code with SPIL attributes for each stored procedure.
 * 
 * Revision History:
 *  Aug 2002    - TaoH  - created
 */

using System;
using System.Data.SqlClient;
using System.Data;
using System.Collections;
using System.IO;
using System.Xml;
using System.Diagnostics;
using Microsoft.Subscriptions.Utility;

namespace Microsoft.Subscriptions.Data.Tools
{
    /// <summary>
    /// Summary description for SpilAnnotator.
    /// </summary>
    public class SpilAnnotator
    {
        /// <summary>
        /// An config XML file that defines the SqlMethods
        /// </summary>
        private const string SpilAnnotatorXML = @"spAnnotate.xml";
        /// <summary>
        /// Audit Logger
        /// </summary>
        IAuditLog ial;
        /// <summary>
        /// Cache of hash algorithm mapping
        /// </summary>
        Hashtable hashAlgMap;
        private string hashFileName = null; 

        public SpilAnnotator()
        {
            SimpleLogRouter slr = new SimpleLogRouter( LogEventLevel.Info);
            DebugLogger dl = new DebugLogger();
            slr.LogNotifications += new AddToLogEventHandler(dl.AddToLog);

            ConsoleLogger cl = new ConsoleLogger();
            slr.LogNotifications += new AddToLogEventHandler(cl.AddToLog);

            ial = slr as IAuditLog;

            ial.SendToLog( this, "Starting SpilAnnotator");
        }

        /// <summary>
        /// Read Hash Algorithm XML file and cache the mapping between concorde Hash algorithm and
        /// new SPIL hash algorithm in memory
        /// </summary>
        /// <param name="hashAlgXml">The config hash algorithm XML file path</param>
        private void ReadHashAlg()
        {
            if(hashFileName == null)
                ial.SendToLog( this, LogEventLevel.Fatal, "Need to input hash algorithm config XML filename");
            
            hashAlgMap = new Hashtable();
            try
            {
                XmlDocument xmldoc = new XmlDocument();
                xmldoc.Load(hashFileName);
                XmlNodeList nodes = xmldoc.SelectNodes(@"//HashAlg");
                foreach(XmlNode node in nodes)
                {
                    string concordeHash = node.Attributes["name"].Value;
                    string spilHash = node.Attributes["Method"].Value;
                    if(!hashAlgMap.ContainsKey(concordeHash))
                    {
                        hashAlgMap.Add(concordeHash, spilHash);
                    }
                }
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to read hash algorithm XML " + ex.Message);
            }
        }


        /// <summary>
        /// Gets the database name for a given command code in TowerXML
        /// </summary>
        /// <param name="cmdCode">the Concorde command code fro the stored procedure</param>
        private string GetDBName(string cmdCode)
        {
            string dbname = null;
            SqlConnection conn = null;
            
            try
            {
                conn = OpenConnection("TowerXml");
            
                string sql = @"select distinct PR.vc_Resource_Name as DBName 
                    From towerxml..CommandToParameter CP, 
                         tower..physical_resource PR, 
                         towerxml..Service S ,
                         towerxml..Command C
                    Where C.Code = CP.CommandCode 
                       and S.[id] = PR.i_service_id 
                       and C.ServiceCode = S.Code 
                       and C.ResourceTypeCode = 'Database' 
                       and C.Code = '" + cmdCode + "'";
                SqlCommand cmd = new SqlCommand(sql, conn);
                SqlDataReader reader = cmd.ExecuteReader();
                if(reader.Read())
                {
                    dbname = reader.GetString(0);
                }
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to get db name for sproc: " + ex.Message);
                return null;
            }
            finally
            {
                CloseConnection(conn);
            }
            return dbname;
        }


        /// <summary>
        /// Opens a database connection
        /// </summary>
        /// <param name="dbName">the database name</param>
        /// <returns>the opened database connection</returns>
        private SqlConnection OpenConnection(string dbName)
        {
            SqlConnection conn = new SqlConnection("server=(local);database=" + dbName + ";trusted_connection=true");
            conn.Open();
            return conn;
        }

        /// <summary>
        /// Close a connection
        /// </summary>
        /// <param name="conn">the connection handle to close</param>
        private void CloseConnection(SqlConnection conn)
        {
            if(conn != null)
                conn.Close();
        }
        /// <summary>
        /// update CalledParameterName column in TowerXml
        /// </summary>
        public bool UpdateParameter()
        {
            SqlConnection con = null;
            
            try
            {
                ial.SendToLog( this, LogEventLevel.Info, "Updating calledparametername in TowerXML");
                con = OpenConnection("TowerXml");
                DataSet ds = new DataSet();
                SqlDataAdapter adapter = new SqlDataAdapter("SELECT CalledParameterName, [Sequence], CommandCode FROM COMMANDTOPARAMETER",con);
                adapter.Fill(ds);
                DataTable dt = ds.Tables[0];
                for(int i = 0; i < dt.Rows.Count ; i ++)
                {
                    //string cmdText = (string)dt.Rows[i]["CommandText"];
                    string cmdCode = (string)dt.Rows[i]["CommandCode"];
                    string cmdText = GetCommandText(cmdCode);
                    //Console.WriteLine("Updating {0}",cmdText);
                    int sequence = (int)dt.Rows[i]["Sequence"];
                    if(cmdText != null)
                    {
                        string dbName = GetDBName(cmdCode);
                        if(dbName != null)
                        {
                            try
                            {
                                // retrieve the stored procedure parameter name
                                string calledparam = GetCalledParamName(dbName, cmdText, sequence);
                                if(calledparam != null)
                                {
                                    // update the called parameter column using the real name in database.
                                    dt.Rows[i]["CalledParameterName"] = calledparam;
                                }
                                else
                                {
                                    ial.SendToLog( this, LogEventLevel.Error, "calledparameter is null for stored procedure: "+cmdText);
                                    return false;
                                }
                            }
                            catch(Exception ex)
                            {
                                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to update parameter for sproc: " + ex.Message);
                                //Console.WriteLine("Exception: Code:{0}; Seq:{1}; Reason:{2}",cmdCode,sequence,ex.Message);
                                return false;
                            }
                        }
                    }
                    else // commandText is null
                    {
                        return false;
                    }
                }

                // update calledparameter column in data adapter
                adapter.UpdateCommand = new SqlCommand("UPDATE CommandToParameter SET CalledParameterName = @CalledParameterName " +
                    "WHERE CommandCode = @CommandCode AND [Sequence]=@Sequence" , con);

                adapter.UpdateCommand.Parameters.Add("@CalledParameterName", SqlDbType.NVarChar, 50, "CalledParameterName");
                adapter.UpdateCommand.Parameters.Add("@CommandCode", SqlDbType.NVarChar, 50, "CommandCode");
                adapter.UpdateCommand.Parameters.Add("@Sequence", SqlDbType.SmallInt, 2, "Sequence");


                // Save the dataset changes back to database.
                //Console.Write("\nUpdating..............");
                adapter.Update(ds.GetChanges(),"Table");//update database.
                //Console.WriteLine("Done");
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to update parameter for sproc: " + ex.Message);
                return false;
            }
            finally
            {
                CloseConnection(con);
            }
            return true;
        }


        /// <summary>
        /// Gets the command text for the command code.
        /// </summary>
        /// <param name="cmdCode"></param>
        /// <returns></returns>
        private string GetCommandText(string cmdCode)
        {
            SqlConnection conn = null;
            string cmdText = null;
            try
            {
                conn = OpenConnection("TowerXml");
                SqlCommand cmd = new SqlCommand("SELECT CommandText FROM COMMAND WHERE CODE = '" + cmdCode + "'",conn);
                cmdText = (string)cmd.ExecuteScalar();
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to get command text: " + ex.Message);
                return null;
            }
            finally
            {
                CloseConnection(conn);
            }
            return cmdText;
        }

        /// <summary>
        /// Gets the called parameter name using sp_help
        /// </summary>
        /// <param name="dbName">the database name</param>
        /// <param name="cmdCode">the command code</param>
        /// <param name="sequence">the ordinal sequence of the parameter</param>
        /// <returns>the called parameter name</returns>
        private string GetCalledParamName(string dbName, string cmdText, int sequence)
        {
            SqlConnection con = null;
            
            try
            {
                con = OpenConnection(dbName);
                SqlCommand cmd = new SqlCommand("sp_help",con);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add(new SqlParameter("@objname",cmdText.Trim()));
                DataSet ds = new DataSet();
                SqlDataAdapter adapter = new SqlDataAdapter(cmd);
                adapter.Fill(ds);
                DataTable dt = ds.Tables[1]; //second table.
                for(int i = 0; i < dt.Rows.Count ; i ++)
                {
                    Int16 order = (Int16)dt.Rows[i]["Param_order"];
                    if(order == sequence)
                    {
                        return (string)dt.Rows[i]["Parameter_name"];
                    }
                }
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to get called parameter name: " + ex.Message);
                return null;                
            }
            finally
            {
                CloseConnection(con);
            }
            return null;
        }

        /// <summary>
        /// Gets the partitioned column name for all stored procedures in TowerXML. 
        /// Requires <see cref="UpdateParam"/> to run before this method.
        /// </summary>
        public bool GeneratePartitionColumn()
        {
            ial.SendToLog( this, LogEventLevel.Info, "Generating partition column information to "+ SpilAnnotatorXML);

            //Read in hash algorithm mapping XML
            ReadHashAlg();

            //stored procedure to partition attribute mapping.
            Hashtable spTbl = new Hashtable();
            
            string sql = @" 
                    select c.Code, c.CommandText, a.Code as HashAlgCode, a.Parameter, cp.calledparametername, cp.[Sequence], pr.vc_Resource_Name as dbname 
                    from command c 
                    join service s 
                    on s.Code = c.ServiceCode 
                    join Algorithm a 
                    on s.HashAlgorithmCode = a.Code 
                    join CommandToParameter cp 
                    on c.Code = cp.CommandCode and a.Parameter = cp.ParameterCode 
                    join tower..physical_resource pr 
                    on pr.i_service_id = s.[id] 
                    where resourcetypecode = 'Database' 
                    ";
            SqlConnection conn = null;
            
            try
            {
                conn = OpenConnection("TowerXml");
                SqlCommand cmd = new SqlCommand(sql, conn);
                SqlDataReader reader = cmd.ExecuteReader();
                while(reader.Read())
                {
                    string partitionCol;
                    if(reader.IsDBNull(4)) //partition column is null
                    {
                        ial.SendToLog( this, LogEventLevel.Warning, "Partition column info is null for " + reader.GetString(1));
                        continue;
                    }
                    else
                    {
                        partitionCol = reader.GetString(4).Replace("@","");    
                    }
                    if(!spTbl.ContainsKey(reader.GetString(1).ToLower()))
                    {
                        Debug.Assert(!reader.IsDBNull(2));
                        string concordeHash = reader.GetString(2).Trim();
                        string spilHash = hashAlgMap["concordeHash"].ToString();
                        if(spilHash == null)
                            spilHash = concordeHash;
                        string attr = string.Format("[PartitionBy({0},{1})]", spilHash,partitionCol);
                        spTbl.Add(reader.GetString(1).ToLower(), attr);
                    }
                }
                reader.Close();
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to update parameter for sproc: " + ex.Message);
                return false;
            }
            finally
            {
                CloseConnection(conn);
            }

            //Write XML Document to SpilAnnotatorXML
            try
            {
                XmlTextWriter writer = new XmlTextWriter(SpilAnnotatorXML,System.Text.Encoding.UTF8);
                writer.Formatting = Formatting.Indented;
                writer.WriteStartDocument();
                writer.WriteStartElement("PublicStoredProcedures");
                IDictionaryEnumerator ide = spTbl.GetEnumerator();
                while(ide.MoveNext())
                {
                    string spName = ide.Key.ToString();
                    string filePath = GetFileNameForSP(spName);
                    if(filePath == null)
                        return false;
                    writer.WriteStartElement("SqlMethod");
                    writer.WriteAttributeString("StoredProcedure",spName);
                    writer.WriteElementString("LocalPath", filePath);
                    writer.WriteElementString("PartitionBy",ide.Value.ToString());
                    writer.WriteEndElement();
                }
                writer.WriteEndElement();
                writer.WriteEndDocument();
                writer.Close();
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to write out SpilAnnotatorXML: " + ex.Message);    
                return false;
            }
            return true;
        }

        /// <summary>
        /// Annotate PartitionAll attributes
        /// </summary>
        /// <return>true if success, Exception otherwise</return>
        public bool AnnotatePartitionAll()
        {
            string sql = @"select xmlswitches, commandtext from command where XmlSwitches is not null";
            SqlConnection conn = OpenConnection("TowerXml");
            SqlCommand cmd = new SqlCommand(sql, conn);
            SqlDataReader reader = cmd.ExecuteReader();

            XmlTextWriter writer = new XmlTextWriter("SpilAnnotate2.xml",System.Text.Encoding.UTF8);
            writer.Formatting = Formatting.Indented;
            writer.WriteStartDocument();
            writer.WriteStartElement("PublicStoredProcedures");
            while(reader.Read())
            {
                string xmlSwitches = reader.GetString(0);
                if(reader.IsDBNull(1))
                    continue;
                string commandText = reader.GetString(1);
                if(xmlSwitches.StartsWith("<Switches RunAt='AllPartitions'"))
                {
                    string filePath = this.GetFileNameForSP(commandText);
                    Debug.Assert(filePath != null);
                    Debug.WriteLine(filePath);
                    string inetroot = Environment.GetEnvironmentVariable("INETROOT");
                    Debug.Assert(inetroot != null);
                    string fileName = filePath.Replace("$INETROOT",inetroot);   
                    writer.WriteStartElement("SqlMethod");
                    writer.WriteAttributeString("StoredProcedure",commandText);
                    writer.WriteElementString("LocalPath", filePath);
                    writer.WriteElementString("PartitionAll", "");
                    writer.WriteEndElement();    
                    
               //open local file and do annotation
                try
                {
                    // open the file to edit in source depot
                    if(!SDEdit(fileName))
                        return false;
                    // copy the file and add attributes
                    string backUpFilePath = fileName + ".bak";
                    StreamReader sr = new StreamReader(fileName);
                    StreamWriter sw = new StreamWriter(backUpFilePath);
                    for(string line = sr.ReadLine(); line != null; line = sr.ReadLine())
                    {
                        // if the line is create procedure
                        // write the attributes comments before the line
                        if(line.Replace(" ","").ToLower().StartsWith("createprocedure"))
                        {
                            sw.WriteLine("--Attributes: autogenerated by SpilAnnotator. -----");
                            sw.WriteLine("--[SqlMethod]");
                            sw.WriteLine("--{0}","[PartitionAll]");
                            // add more attributes here if necessary.
                        }
                        sw.WriteLine(line);
                    }
                    sr.Close();
                    sw.Close();
                    //Copy over
                    File.Copy(backUpFilePath, fileName, true);  
                    File.Delete(backUpFilePath);
                }
                catch(Exception ex)
                {
                    ial.SendToLog( this, LogEventLevel.Fatal, "Failed to annotate SQL source " + ex.Message);
                    return false;
                }
                }
            }
            writer.WriteEndElement();
            writer.WriteEndDocument();
            writer.Close();

            return true;
        }
        
        /// <summary>
        /// Get the local file full path from a stored procedure name.
        /// </summary>
        /// <param name="spName">the name of the stored procedure</param>
        /// <returns>the local file path, null if not found</returns>
        internal string GetFileNameForSP(string spName)
        {
            SqlConnection conn = null;
            try
            {
                conn = OpenConnection("butterfly");                
                SqlCommand cmd = new SqlCommand("SELECT FilePath FROM Sproc WHERE SPName = '" + spName + "'", conn);
                string filepath = cmd.ExecuteScalar().ToString().Replace(Environment.GetEnvironmentVariable("INETROOT"),@"$INETROOT");
                return filepath;
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to get file name for sproc: " + ex.Message);
                return null;
            }
            finally
            {              
                CloseConnection(conn);
            }
        }

        /// <summary>
        /// Open a source depot edit on a file. This requires sd.exe on PATH
        /// </summary>
        /// <param name="filePath">the full path to the file</param>
        protected bool SDEdit(string filePath)
        {
            if(File.Exists(filePath))
            {
                try
                {
                    ProcessStartInfo psi = new ProcessStartInfo("sd","edit "+filePath);
                    psi.UseShellExecute = true;
                    psi.CreateNoWindow = true;
                    psi.WindowStyle = ProcessWindowStyle.Hidden;
                    Process p = new Process();
                    p.StartInfo = psi;
                    p.Start();
                    p.WaitForExit(); //wait for source depot to exit
                } 
                catch(Exception ex)
                {
                    //Console.WriteLine(ex.Message);
                    ial.SendToLog( this, LogEventLevel.Fatal, "Failed to open source depot: " + ex.Message);
                    return false;        
                }
            }
            else // file doesn't exist
            {
                ial.SendToLog( this, LogEventLevel.Error, "Cannot find "+ filePath + " for source depot edit");
                return false;
            }
            return true;
        }


        /// <summary>
        /// Annotate all stored procedures in the <see cref="SpilAnnotatorXML"/> file.
        /// This procedure is not re-entrant.
        /// </summary>
        public bool Annotate()
        {
            ial.SendToLog( this, LogEventLevel.Info, "Starting annotating SQL source files");

            //Load SpilAnnotatorXMLlswithces
            XmlDocument doc = new XmlDocument();
            try
            {
                doc.Load(SpilAnnotatorXML);
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to load SpilAnnotatorXML file: " + ex.Message);
                return false;
            }
            //Annotate each node
            XmlNodeList nodes = doc.SelectNodes("//SqlMethod");
            foreach(XmlNode node in nodes)
            {
                string sprocName = node.Attributes["StoredProcedure"].Value;
                Debug.Assert(sprocName != null);
                WriteAnnotation(sprocName);
                //break;
            }
            return true;
        }

        /// <summary>
        /// Annotate one store procedure. The stored procedure must be a node in <see cref="SpilAnnotatorXML"/> config
        /// file. There're currently two child nodes of the stored procedure node. One is local file path
        /// to the source code, the other is the partition attributes.
        /// </summary>
        /// <param name="sprocName">The stored procedure name</param>
        /// <returns>true if write successfully, false else.</returns>
        public bool WriteAnnotation(string sprocName)
        {
            if(sprocName == null || sprocName == "")
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Sproc name cannot be empty");
                return false;
            }
            ial.SendToLog( this, LogEventLevel.Info, "Annotating "+sprocName);
            //Load SpilAnnotatorXML
            XmlDocument doc = new XmlDocument();
            try
            {
                doc.Load(SpilAnnotatorXML);
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to load SpilAnnotatorXML file: " + ex.Message);
                return false;               //open local file and do annotation
            }

            //Fetch filepath, attributes from SpilAnnotatorXML
            XmlNode node = doc.SelectSingleNode("//SqlMethod[@StoredProcedure='"+sprocName+"']");
            if(node != null)
            {
                //fetch file path
                XmlNode filePathNode = node.SelectSingleNode("LocalPath");
                if(filePathNode == null)
                {
                    ial.SendToLog( this, LogEventLevel.Fatal, "Failed to find Sproc source file path node ");
                    return false;
                } 
                string localFilePath = filePathNode.FirstChild.Value;
                //replace $INETROOT
                string inetroot = Environment.GetEnvironmentVariable("INETROOT");
                Debug.Assert(inetroot != null);
                localFilePath = localFilePath.Replace("$INETROOT",inetroot);
                if(!File.Exists(localFilePath))
                {
                    ial.SendToLog( this, LogEventLevel.Warning, "Failed to local Sproc source file: " + localFilePath);
                    return false;
                }
                //fetch PartitionBy attribute
                XmlNode partitionNode = node.SelectSingleNode("PartitionBy");
                if(filePathNode == null)
                {
                    ial.SendToLog( this, LogEventLevel.Fatal, "Failed to find PartitionBy attribute node");
                    return false;
                }
                string partitionAttr = partitionNode.FirstChild.Value;
                Debug.Assert(partitionAttr != null && partitionAttr != "");
                //open local file and do annotation
                try
                {
                    // open the file to edit in source depot
                    if(!SDEdit(localFilePath))
                        return false;
                    // copy the file and add attributes
                    string backUpFilePath = localFilePath + ".bak";
                    StreamReader sr = new StreamReader(localFilePath);
                    StreamWriter sw = new StreamWriter(backUpFilePath);
                    for(string line = sr.ReadLine(); line != null; line = sr.ReadLine())
                    {
                        // if the line is create procedure
                        // write the attributes comments before the line
                        if(line.Replace(" ","").ToLower().StartsWith("createprocedure"))
                        {
                            sw.WriteLine("--Attributes: autogenerated by SpilAnnotator. -----");
                            sw.WriteLine("--[SqlMethod]");
                            sw.WriteLine("--{0}",partitionAttr);
                            // add more attributes here if necessary.
                        }
                        sw.WriteLine(line);
                    }
                    sr.Close();
                    sw.Close();
                    //Copy over
                    File.Copy(backUpFilePath, localFilePath, true);
                    File.Delete(backUpFilePath);
                }
                catch(Exception ex)
                {
                    ial.SendToLog( this, LogEventLevel.Fatal, "Failed to annotate SQL source " + ex.Message);
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Print out usage information
        /// </summary>
        private static void PrintUsage()
        {
            Console.WriteLine("Usage: spilannotator [/c /h hashfile | /a]");
            Console.WriteLine("       /c:   create annotation config XML file");
            Console.WriteLine("           /h: hash algorithm mapping file");
            Console.WriteLine("           hashfile: an XML file specifies the mapping of hash algorithms");
            Console.WriteLine("       /a:   annotate SQL source file");
        }

        private void StoreHashXml(string[] args)
        {
            for(int i = 1; i < args.Length-1; i++) 
            {
                if ( (args[i] == "-h") || (args[i] == "/h")) 
                {
                    hashFileName = args[i+1];
                    break;
                }
            }
        }
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        public static int Main(string[] args) 
        {

            if (args.Length < 1) 
            {
                PrintUsage();
                return -1;
            }

            if ( args[0] == "-help") 
            {
                PrintUsage();
                return -1;
            }

            SpilAnnotator spilAnnotator = new SpilAnnotator();
            spilAnnotator.StoreHashXml(args);

            switch (args[0]) 
            {
                case "/c":
                    // generate the SpilAnnotationXML file
                    if(!spilAnnotator.UpdateParameter())
                        return -2;
                    if(!spilAnnotator.GeneratePartitionColumn())
                        return -3;
                    break;

                case "/a":
                    // annotate all SQL file
                    if (!spilAnnotator.AnnotatePartitionAll()) 
                        return -4;
                    break;

                default:
                    PrintUsage();
                    return -15;
            }

            return 0;
        } // Main()
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\IndentTextWriter.cs ===
using System;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for IndentTextWriter.
	/// </summary>
	public class IndentTextWriter
	{
        #region Declarations
        private TextWriter writer;
        private int indentLevel = 0;
        private int indentSize = 4; // default indent 4
        #endregion

        #region Constructors
		public IndentTextWriter(TextWriter writer)
		{
            this.writer = writer;
		}
        #endregion

        #region Public Methods
        /// <summary>
        /// Indent 
        /// </summary>
        public IndentTextWriter Indent()
        {
            this.indentLevel ++;
            return this;
        }

        /// <summary>
        /// Unindent
        /// </summary>
        public IndentTextWriter Unindent()
        {
            this.indentLevel --;
            if (this.indentLevel < 0)
                this.indentLevel = 0;
            return this;
        }

        /// <summary>
        /// Write a line
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteIndent();
            this.writer.WriteLine(format, args);
        }

        /// <summary>
        /// Write a string
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public void Write(string format, params object[] args)
        {
            this.WriteIndent();
            this.writer.Write(format, args);
        }

        /// <summary>
        /// Write an object
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public void WriteLine(object value)
        {
            this.WriteIndent();
            this.writer.WriteLine(value);
        }

		/// <summary>
		/// Write a string
		/// </summary>
		/// <param name="format"></param>
		/// <param name="args"></param>
		public void WriteLine(string value)
		{
			this.WriteIndent();
			this.writer.WriteLine(value);
		}

        /// <summary>
        /// Write an object
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public void Write(object value)
        {
            this.WriteIndent();
            this.writer.Write(value);
        }

		/// <summary>
		/// Write a string
		/// </summary>
		/// <param name="format"></param>
		/// <param name="args"></param>
		public void Write(string value)
		{
			this.WriteIndent();
			this.writer.Write(value);
		}
        
        protected void WriteIndent()
        {
            for(int i = 0; i < this.indentLevel; i ++)
            {
                for(int j = 0; j < this.indentSize; j ++)
                    this.writer.Write(" ");
            }
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets indent size
        /// </summary>
        public int IndentSize 
        {
            get { return this.IndentSize; }
            set { 
                this.IndentSize = value; 
                if (this.IndentSize < 0)
                    this.IndentSize = 0;
            }
        }

        /// <summary>
        /// Gets or sets indent level
        /// </summary>
        public int IndentLevel
        {
            get { return this.indentLevel; }
            set { 
                this.indentLevel = value; 
                if (this.indentLevel < 0)
                    this.indentLevel = 0;
            }
        }
        #endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\ProcedureInterfaces.cs ===
/*
 *  ProcedureInterfaces.cs
 *
 *  Support functions to generate procedure interfaces.
 *  Think of this class as being the JIT for generating the SPIL content
 *  for stored procedures.
 *
 *
 * Revision History:
 *  Feb 2003    - TaoH   - rewrote using CodeDom. Add support for data reader.
 *  Sep 2002    - TaoH   - added generation from SQL source
 *  Aug 2002    - MuraliK  - created initial version
 *  the database generator code is from TaoH
 */

using System;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Diagnostics;
using Microsoft.Subscriptions.Data.Tools;
using Microsoft.Subscriptions.Utility;
using Microsoft.Subscriptions.Utility.Logging;
using SSVParseLib;
using Microsoft.Subscriptions.Tools.SqlParser;
using Microsoft.Subscriptions.Tools.SqlParser.DataStructure;

namespace Microsoft.Subscriptions.Data
{

    /// <summary>
    /// Class consists of definition of constant values used inside SPIL runtime library
    /// </summary>
    public class SpilConstants
    {

        /// <summary>
        /// Constant defining the namespace for SPIL documents
        /// </summary>
        public const string SpilNamespace = "http://schemas.microsoft.com/subscriptions/spil";

        internal const string SpilToCSharpTransform = "Microsoft.Subscriptions.Data.SpilToCs.xsl";

        static internal string[] callTypeAttributeNames =
            new string[] {
                             "PartitionAll",
                             "PartitionAny",
                             "PartitionBy",
                             "CallByPhysicalInstance"
                         };

    }

    /// <summary>
    /// Summary description for ProcedureInterfaces.
    /// o  This class provides methods to generate SPIL documents from
    /// database or SQL stored procedure definition files.
    ///
    /// NOTE: Only Database reverse-engineering is implemented right now
    /// </summary>
    public class ProcedureInterfaces
    {

        private IAuditLog   ial;
        private bool useRegexParser = true;
        private bool suppressWarning = true;
        private bool alwaysCreate = false;

        /// <summary>
        /// Creates a new instance of the ProcedureInterfaces object
        /// </summary>
        /// <param name="auditLog">logger - enables this routine to log messages directly</param>
        public ProcedureInterfaces(IAuditLog auditLog)
        {
            this.ial = auditLog;
        }


        #region Properties
        /// <summary>
        /// Gets or sets whether to use Regex SQL parser or Yacc SQL Parser
        /// </summary>
        public bool UseRegexParser
        {
            get { return useRegexParser; }
            set { useRegexParser = value; }
        }

        /// <summary>
        /// Gets or sets whether to suppress SQL Source parsing warnings
        /// </summary>
        public bool SuppressWarning
        {
            get { return suppressWarning; }
            set { suppressWarning = value; }
        }

        /// <summary>
        /// Gets or sets whether to create spil code for all SQL code regardless of [SqlMethod] attribute.
        /// This is useful for creating unit test cases for any stored procedures
        /// </summary>
        public bool AlwaysCreate
        {
            get { return alwaysCreate; }
            set { alwaysCreate = value; }
        }
        #endregion
        /// <summary>
        /// Parameter declaration pattern. The regex matches the following in a single line:
        /// @param_name [as] [type][length] [output] [= default]
        /// where
        ///     param_name is a character string consisting of A-Za-z0-9 and underscore
        ///     as is an optional sql keyword
        ///     type is a required sql type string such as int, decimal. see spil.xsd for allowed sql types
        ///     length is an optional word that describes the length of the parameter. It only contains digits.
        ///     output is an optional sql keyword indicating the direction of the parameter
        ///     = default is an optional sql keyword indicating the default value of the parameter
        /// currently the output and [= default] has to follow the exact order.
        /// </summary>
        private const string paramDeclPattern = "@(?<paramname>[_|\\w]+)\\s+(as\\s+)?(?<type>[\\w]+)(\\((?<length>[\\d]+)\\))?\\s*(?<outpu" +
            "t>output)?(\\s*=\\s*(?<default>[\"?\\w\"?]+))?(\\s*,?\\s*--\\s*(?<comment>.*))?";
        /// <summary>
        /// Create Stored Procedure declaration pattern. The regex matches the following in a single line:
        /// [alter|create] proc[edure] procname
        /// where
        ///     alter or create is required sql keyword for creating stored procs
        ///     proc or procedure is required sql keyword
        ///     procname is a sql identifier indicating the procedure name. it must consist of A-Z or dot or underscore
        ///         The word after the last dot is used as the procedure name, anything before it is regarded as scope definition,
        ///         such as dbo. etc.
        /// alter or create must be at the beginning of the line except for white spaces.
        /// </summary>
        private const string procDeclPattern = @"^\s*(alter|create)\s*proc(edure)?\s*(?<procname>[\w|_|\.\[|\]]+)";

        private const string procSummaryPattern = "(?m:<summary>(?<summary>[\\w\\W\\s]*?)<\\/summary>)";
        
        //generate procedure node
        private Regex procDeclRegex = new Regex(procDeclPattern, RegexOptions.Compiled |
            RegexOptions.IgnoreCase |
            RegexOptions.Singleline);
        private Regex paramDeclRegex = new Regex(paramDeclPattern,RegexOptions.Compiled |
            RegexOptions.IgnoreCase |
            RegexOptions.Singleline);
        private Regex procSummaryRegex = new Regex(procSummaryPattern,RegexOptions.Compiled |
            RegexOptions.IgnoreCase |
            RegexOptions.Multiline);
        /// <summary>
        /// Generates the SPIL contents by parsing through the input SQL files
        ///  to find STORED PROCEDURE definitions to extract metadata
        /// </summary>
        /// <param name="storeName">The name of the DB catalog</param>
        /// <param name="sqlFilePaths">ArrayList of names of the source file of the stored procedure</param>
        /// <returns>on success, a valid XmlDocument that is conformant with SPIL</returns>
        public ProcedureGroup GenerateFromFiles( string storeName, ArrayList sqlFilePaths)
        {
            // Declare an object variable of the type to be deserialized.
            ProcedureGroup procGroup = new ProcedureGroup();

            //parse through source file line by line.
            ArrayList procedures = new ArrayList();
            foreach(string sqlFilePath in sqlFilePaths)
            {
                // Generate procedures from one file. The array list can be empty.
                ArrayList proceduresFromOneFile;
                if (this.UseRegexParser)
                {
                    proceduresFromOneFile = GenerateFromOneFile2(storeName, sqlFilePath);   
                }
                else
                {
                    proceduresFromOneFile = GenerateFromOneFile(storeName, sqlFilePath);
                }
                // Add one file procedures to the array list
                procedures.AddRange(proceduresFromOneFile);
            }

            // add procedure to procedure group
            procGroup.procedure = (ProcedureDefinition[])procedures.ToArray(typeof(ProcedureDefinition));
            return procGroup;
        }


        /// <summary>
        /// Generates the SPIL document by inspecting the specified database
        /// Input configuration file
        /// This function will use the connectionString in the SPIL input document
        ///  to connect to the database. Then it inquires metadata about the
        ///  stored procedures to create a new SPIL document.
        /// </summary>
        /// <param name="storeName">name of the database catalog</param>
        /// <param name="sqlFilePaths">ArrayList of names of the source file of the stored procedure</param>
        /// <returns>on success, a valid XmlDocument that is conformant with SPIL</returns>
        public ProcedureGroup GenerateFromDatabase( string storeName, ArrayList sqlFilePaths)
        {
            // Declare an object variable of the type to be deserialized.
            ProcedureGroup procGroup = new ProcedureGroup();

            SqlConnection con = null;
            ArrayList procedures = new ArrayList();
            try
            {
                // Get connection string
                string ConnString = "Integrated Security=SSPI;persist security info=False;Initial Catalog=" + storeName;

                ial.SendToLog( this, LogEventLevel.Info, "Using connection string \'" + ConnString + "\'");

                con = new SqlConnection(ConnString);
                con.Open();

                //Spiller v.2
                //Create a stored procedure node from given stored procedure file
                //assuming the file name is stored_procedure_name + ".sql"
                foreach(string sqlFilePath in sqlFilePaths)
                {
                    if(!File.Exists(sqlFilePath))
                    {
                        ial.SendToLog( this, LogEventLevel.Warning, sqlFilePath + " doesn't exist");
                        continue;
                    }

                    Hashtable attributes = ReadAnnotation(sqlFilePath);

                    // Don't generate procedure node if the sql file is not annotated with SqlMethod
                    if(attributes == null || !attributes.ContainsKey("SqlMethod"))
                        continue;
                    // stored procedure name should be the same as file name.
                    string spname = GetSpNameFromFileName(sqlFilePath);
                    ial.SendToLog( this, LogEventLevel.Info, "  Processing stored procedure: \'" + spname + "\'");

                    // create the procedure node
                    ProcedureDefinition procDef = new ProcedureDefinition();
                    procDef.spname = spname;

                    // Change name to Pascal Case
                    procDef.name = PascalCase(spname);

                    //add attributes
                    AddAttributesToProc(procDef, attributes);

                    // Add parameter Defs
                    ArrayList paramDefs = new ArrayList();
                    SqlCommand cmd = new SqlCommand("sp_procedure_params_rowset", con);
                    cmd.CommandType = CommandType.StoredProcedure;
                    SqlParameter pram = cmd.Parameters.Add("@procedure_name", SqlDbType.VarChar, 100);
                    pram.Value = spname;
                    SqlDataReader reader = cmd.ExecuteReader();
                    while(reader.Read())
                    {
                        string paramName = (string)reader["PARAMETER_NAME"];
                        paramName = paramName.Replace("@", "");
                        if(paramName == "RETURN_VALUE") //implicit parameter.
                            continue;
                        string paramType = (string)reader["LOCAL_TYPE_NAME"];
                        ParameterDefinition paramDef = new ParameterDefinition();
                        paramDef.spname = paramName;
                        paramDef.name = PascalCase(paramName);
                        paramDef.type = paramType;
                        paramDef.@default = null;
                        paramDefs.Add(paramDef);
                    }
                    reader.Close();

                    // Check if partitionBy attribute is one of parameter
                    if(attributes["PartitionBy"] != null)
                    {
                        string partitionCol = (string) attributes["PartitionBy"];
                        string[] cols = partitionCol.Split(",".ToCharArray()); //split multi-columns
                        for(int j = 1; j < cols.Length; j ++) //skip algorithm
                        {
                            string col = cols[j].Trim();
                            bool found = false;
                            for(int i = 0; i < paramDefs.Count; i ++)
                            {
                                ParameterDefinition pdef = (ParameterDefinition)paramDefs[i];
                                if(pdef.spname == col)
                                {
                                    found = true;
                                    break;
                                }
                            }
                            if(!found) //the partition column is not found in parameter list
                            {
                                RaiseFatalError(  "Failed to generate procedure: Partition Column not found in paramter list");
                                return null;
                            }
                        }
                    }
                    procDef.param = (ParameterDefinition[])paramDefs.ToArray(typeof(ParameterDefinition));
                }
                //} // foreach procedure

                ial.SendToLog( this, LogEventLevel.Info, "Done with processing all procedures ");
            }
            catch(Exception e)
            {
                RaiseFatalError(  "Error while generating SPIL for procedures: " + e.Message);
            }
            finally
            {
                if(con != null)
                    con.Close();
            }

            // add procedure to procedure group
            procGroup.procedure = (ProcedureDefinition[])procedures.ToArray(typeof(ProcedureDefinition));
            return procGroup;
        }

        /// <summary>
        /// Add annotated attributes to procedure node
        /// </summary>
        /// <param name="procDef">The stored procedure definition node</param>
        /// <param name="attributes">The attributes for the procedure</param>
        protected void AddAttributesToProc(ProcedureDefinition procDef, Hashtable attributes)
        {
            Debug.Assert(procDef != null && attributes != null);

            procDef.attribute = new ProcedureAttributes();

            // validate the call types and appropriately store state
            if ( attributes.ContainsKey( "PartitionAll"))
            {

                CheckForExclusiveCallType( attributes, "PartitionAll");
                procDef.attribute.callType = ProcedureCallType.CallOnAllPartitions;
            }
            else if (attributes.ContainsKey( "PartitionAny"))
            {

                CheckForExclusiveCallType( attributes, "PartitionAny");
                procDef.attribute.callType = ProcedureCallType.CallOnAnyPartition;
            }
            else if (attributes.ContainsKey( "PartitionBy"))
            {

                CheckForExclusiveCallType( attributes, "PartitionBy");
                procDef.attribute.callType = ProcedureCallType.CallOnPartitionHash;

                string partitionByAttributeParameters = attributes["PartitionBy"] as string;
                if ( partitionByAttributeParameters != null)
                {

                    PartitionByData pbData = new PartitionByData();
                    //get first parameter
                    string[] parameters = partitionByAttributeParameters.Split(",".ToCharArray());

                    if ( parameters.Length <= 0)
                        RaiseFatalError( "No hash algorithm specified for PartititionBy() attribute");

                    // set algorithm attributes
                    string algorithm = parameters[0].Trim();
                    if ( algorithm.Length == 0)
                        RaiseFatalError( "No hash algorithm specified for PartititionBy() attribute");
                    pbData.algorithm = algorithm;

                    // set partition parameters.
                    pbData.paramRef = new String[parameters.Length - 1];
                    for(int i = 1; i < parameters.Length; i++)
                    {
                        (pbData.paramRef)[i - 1] = parameters[i].Trim();
                    }

                    //add pb attributes to procedure definition
                    procDef.attribute.partitionBy = pbData;
                }
            }
            else if (attributes.ContainsKey( "CallByPhysicalInstance"))
            {

                CheckForExclusiveCallType( attributes, "CallByPhysicalInstance");
                procDef.attribute.callType = ProcedureCallType.CallOnPhysicalInstance;
            }
            else
            {
                procDef.attribute.callType = ProcedureCallType.CallOnAnyPartition;
            }

            // ReturnType attribute
            string returnType = attributes["ReturnType"] as string;
            if ( returnType != null && returnType == "IDataReader")
                procDef.attribute.returnType = ProcedureReturnType.IDataReader;
            else if ( returnType != null && returnType == "NonQuery")
                procDef.attribute.returnType = ProcedureReturnType.NonQuery;
            else if ( returnType != null && returnType == "Scalar")
                procDef.attribute.returnType = ProcedureReturnType.Scalar;
            else
                procDef.attribute.returnType = ProcedureReturnType.ProcedureResults;

            // Class attribute
            string className = attributes["Class"] as string;
            if( className != null)
                procDef.@class = className;

            string methodName = attributes["MethodName"] as string;
            if( methodName != null)
                procDef.name = methodName;
            else
                procDef.name = PascalCase(procDef.spname);
            // Add SqlMethod
            if (attributes.ContainsKey("SqlMethod"))
            {
                procDef.sqlmethodSpecified = true;
                procDef.sqlmethod = true;
            }
            // Add FileName
            string fileName = attributes["FileName"] as string;
            if (fileName != null)
            {
                procDef.filename = fileName;
            }
        }

        /// <summary>
        ///  Each stored procedure can have only one call type.
        ///  Check to see if any conflicting call type is present.
        ///  Any conflicting call type will cause a violation.
        /// </summary>
        /// <param name="attributes">The attributes dictionary defined in SQL source</param>
        /// <param name="currentCallType">The current call type found</param>
        protected void CheckForExclusiveCallType( Hashtable attributes, string currentCallType)
        {

            foreach( string otherCallType in SpilConstants.callTypeAttributeNames)
            {
                if ( otherCallType == currentCallType)
                    continue;
                if ( attributes.ContainsKey( otherCallType))
                    RaiseFatalError( currentCallType
                        + " attribute specified along with other call type attribute ("
                        + otherCallType
                        + "). Only one call type is supported.");
            }
        }

        /// <summary>
        /// Log a fatal event and throw a new exception
        /// </summary>
        /// <param name="msg">The human-readable description of the event</param>
        protected void RaiseFatalError( string msg)
        {
            ial.SendToLog( this, LogEventLevel.Fatal, msg);
            throw new Exception( msg);
        }


        /// <summary>
        /// Generate procedure definitions from one file.
        /// </summary>
        /// <param name="storeName">The database store name.</param>
        /// <param name="sqlFilePath">The SQL source file path.</param>
        /// <returns>An array list containing all SPIL procedure definitions in the source
        /// file. If none of such is founded, an empty ArrayList is returned</returns>
        protected ArrayList GenerateFromOneFile2(string storeName, string sqlFilePath)
        {
            //TODO: This code needs a little bit refactoring as it's getting fatter and fatter...
            ArrayList procedures = new ArrayList();
            StreamReader sr = null;
            Hashtable attributes = new Hashtable();
            string procedureSummary = String.Empty;
            ProcedureDefinition procDef = null;
            try
            {
                sr = new StreamReader(sqlFilePath);
                for(string line = sr.ReadLine().Trim(); line != null; line = sr.ReadLine())
                {
                    StringBuilder sb = new StringBuilder();
                    while (line != null && IsComment(line))
                    {
                        // retrieve the node of the comment
                        line = line.Remove(0,2); // remove --
                        sb.Append(line).Append(Environment.NewLine);
                        line = sr.ReadLine(); // read next line
                    }
                    Console.WriteLine(sb.ToString());
                    string summary = GetXmlComment(sb.ToString(),"summary");
                    if (summary != null && summary != String.Empty)
                    {
                        procedureSummary = summary;
                    }
                    // read attribute into attribute table
                    ReadAttribute(line, attributes);
                    // try to match procedure declaration
                    Match procMatch = procDeclRegex.Match(line);
                    if(procMatch.Success)
                    {
                        #region generate one procedure node
                        // Don't generate procedure node if the sql file is not annotated with SqlMethod

                        // Generate the procedure node
                        // get procedure name
                        string spname = procMatch.Result("${procname}");
                        // remove square brackets.
                        spname = spname.Replace("[",String.Empty);
                        spname = spname.Replace("]",String.Empty);
                        // strip of dot
                        int dot = spname.LastIndexOf(".");
                        if(dot != -1)
                            spname = spname.Substring(dot + 1);
                        ial.SendToLog( this, LogEventLevel.Info, "  Processing stored procedure: \'" + spname + "\'");

                        // create the procedure node
                        procDef = new ProcedureDefinition();
                        procDef.spname = spname;
                        procDef.summary = procedureSummary;
                        //add attributes
                        AddAttributesToProc(procDef, attributes);

                        // if no class name is annotated, use the storeName + "Data"
                        if(procDef.@class == null)
                            procDef.@class = storeName + "Data";

                        // add parameters
                        AddParameters(procDef, sr);

                        // validate procedure definition
                        // here is the place to add business logic for SPIL
                        // e.g. partition column must be one of the parameters
                        // if validation fails, this method should raise an exception.
                        ValidateProcedure(procDef);

                        // add into procedure array
                        procedures.Add(procDef);
                        
                        // clear attributes table
                        attributes.Clear();
                        #endregion
                    }
                }
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Warning, "Failed to generate procedure: " + ex.Message);
            }
            finally
            {
                if(sr != null) sr.Close();
            }
            return procedures;
        }

        private void OnParseError(object sender, ParseErrorEventArgs e)
        {
            Error error = e.Error;
            ial.SendToLog(this, LogEventLevel.Warning,
                String.Format("Parse Error(recovered) In {3}: Line {0}, Column {1}, Token {2}",
                error.LineNum + 1, error.OffSet , error.Token, e.FileName));
        }

        protected ArrayList GenerateFromOneFile(string storeName, string sqlFilePath)
        {
            ArrayList procedures = new ArrayList();
            //TODO: Make a static parser
            Parser parser = new Parser();
            if (!this.SuppressWarning) // if not suppress parsing warnings
            {
                parser.OnParseError += new ParseErrorEventHandler(OnParseError);
            }
            parser.Parse(sqlFilePath, false);

            SSYaccStackElement rootNode = parser.RootNode;
            if(rootNode == null)
            {
                RaiseFatalError("SQL Parsing Failed for file: " + sqlFilePath);
            }

            NodeList procDeclarations = rootNode.GetAllChildren(NodeType.ProcedureDeclarationWithAttribute);
            foreach(Node procDeclaration in procDeclarations)
            {
                ProcedureDefinition procDef = ProcessProcDeclaration(procDeclaration);
                // if no class name is annotated, use the storeName + "Data"
                if(procDef != null)
                {
                    if(procDef.@class == null)
                        procDef.@class = storeName + "Data";
                    procedures.Add(procDef); // add into our array.
                }
            }

            return procedures;
        }


        protected ProcedureDefinition ProcessProcDeclaration(Node procDeclaration)
        {
            // create proc declaration
            ProcedureDeclaration procDecl = (ProcedureDeclaration)procDeclaration.GetChild(NodeType.ProcedureDeclaration);
            if(procDecl == null)
            {
                return null; //should never happen
            }

            // create the procedure node
            ProcedureDefinition procDef = new ProcedureDefinition();
            procDef.spname = procDecl.Name;

            // Change name to Pascal Case
            procDef.name = PascalCase(procDecl.Name);


            // add attributes
            Hashtable attributes = new Hashtable();
            NodeList attrNodes = procDeclaration.GetAllChildren(NodeType.SpilAttribute);
            foreach(SpilAttribute attrNode in attrNodes)
            {
                attributes.Add(attrNode.Name, attrNode.Value);
            }
            if(attributes.Contains("SqlMethod"))
                AddAttributesToProc(procDef, attributes);
            else
                return null; //No "SqlMethod" attribute is defined.

            // add parameters
            ArrayList paramDefs = new ArrayList();
            NodeList parameters = procDecl.GetAllChildren(NodeType.ParamDeclaration);
            foreach(ParamDeclaration paramDecl in parameters)
            {
                ParameterDefinition paramDef = new ParameterDefinition();
                // needs to remove "@" from parameter name
                paramDef.spname = paramDecl.Name.Substring(1);
                paramDef.name = PascalCase(paramDef.spname);
                paramDef.type = paramDecl.DataType;
                //param direction
                string paramDirection = paramDecl.Direction;
                if(paramDirection != null && paramDirection.ToLower(System.Globalization.CultureInfo.CurrentCulture) == "output")
                {
                    paramDef.direction = SpilParameterDirection.Output;
                }
                else
                {
                    paramDef.direction = SpilParameterDirection.Input;
                }
                //param default
                string paramDefault = paramDecl.Default;
                if(paramDefault != null && paramDefault.Length > 0)
                {
                    paramDef.@default = paramDefault;
                }
                //param size
                string paramSize = paramDecl.Size;
                if(paramSize != null && paramSize.Length > 0)
                {
                    paramDef.size = paramSize;
                }

                paramDefs.Add(paramDef);
            }
            procDef.param = (ParameterDefinition[])paramDefs.ToArray(typeof(ParameterDefinition));

            // validate procedure definition
            // here is the place to add business logic for SPIL
            // e.g. partition column must be one of the parameters
            // if validation fails, this method should raise an exception.
            ValidateProcedure(procDef);

            return procDef;
        }


        /// <summary>
        /// Read a stored procedure file and add parameter definition to procedure
        /// </summary>
        /// <param name="procDef">The procedure definition</param>
        /// <param name="sr">The stream reader for the source file.</param>
        protected void AddParameters(ProcedureDefinition procDef, StreamReader sr)
        {
            //read in next few lines and create parameter child nodes
            ArrayList paramDefs = new ArrayList();
            while(true)
            {
                string line = sr.ReadLine().Trim();
                if(line.ToLower(System.Globalization.CultureInfo.CurrentCulture) == "as")
                    break; //break out parameter lines as soon as we meet "AS"
                if(line.StartsWith("--"))
                    continue; //comment line.
                Match m = paramDeclRegex.Match(line); //regex matching parameter lines
                if(m.Success)
                {
                    string paramName = m.Result("${paramname}");
                    string paramType = m.Result("${type}");
                    string paramDirection = m.Result("${output}");
                    string paramDefault = m.Result("${default}");
                    string paramSize = m.Result("${length}");
                    string paramDescription = m.Result("${comment}");

                    ParameterDefinition paramDef = new ParameterDefinition();
                    paramDef.spname = paramName;
                    paramDef.name = PascalCase(paramName);
                    paramDef.type = paramType;
                    //param direction
                    if(paramDirection != null && paramDirection.ToLower(System.Globalization.CultureInfo.CurrentCulture) == "output")
                    {
                        paramDef.direction = SpilParameterDirection.Output;
                    }
                    else
                    {
                        paramDef.direction = SpilParameterDirection.Input;
                    }
                    //param default
                    if(paramDefault != null && paramDefault.Length > 0)
                    {
                        paramDef.@default = paramDefault;
                    }
                    //param size
                    if(paramSize != null && paramSize.Length > 0)
                    {
                        paramDef.size = paramSize;
                    }
                    if(paramDescription != null && paramDescription.Length > 0)
                    {
                        // check if it's dbspec gen comment
                        if (paramDescription.StartsWith("<param"))
                        {
                            XmlDocument doc = new XmlDocument();
                            doc.LoadXml(paramDescription);
                            XmlNode node = doc.SelectSingleNode("/param");
                            if (node != null && node.Attributes["description"] != null)
                            {
                                paramDescription = node.Attributes["description"].Value;
                            }
                        }
                        paramDef.description = paramDescription;
                    }
                    paramDefs.Add(paramDef);
                }
            }
            procDef.param = (ParameterDefinition[])paramDefs.ToArray(typeof(ParameterDefinition));
        }

        /// <summary>
        /// Determines whether the line is a SQL comment
        /// </summary>
        /// <param name="line">the sql text</param>
        /// <returns>whether it's a comment</returns>
        protected bool IsComment(string line)
        {
            // check the line starts with "--" but not "--[" (this is a little hacky)
            if (line.StartsWith("--") && !line.StartsWith("--["))
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="line">The sql comment text</param>
        /// <param name="commentNode">The name of the node</param>
        /// <returns>The xml content if any</returns>
        protected string GetXmlComment(string text, string commentNode)
        {
            string comment = String.Empty;
            //parse the line
            if (commentNode == "summary")
            {
                // use regex
                Match procSummaryMatch = procSummaryRegex.Match(text);
                if (procSummaryMatch.Success)
                    comment = procSummaryMatch.Result("${summary}");
            }
            return comment;
        }
        /// <summary>
        /// Read and parse one single line to get attribute definition
        /// </summary>
        /// <param name="line">The source line to parse</param>
        /// <param name="attributeTable">The attribute table to store the key and value</param>
        protected void ReadAttribute(string line, Hashtable attributeTable)
        {
            // process attribute key and value
            // we don't strictly validate the attribute string yet.
            if(line.StartsWith("--["))
            {
                string attributeName;
                string attributeValue;
                //strip off comment characters
                line = line.Substring(3);
                //read attribute name
                int index = line.IndexOf("(");
                //if the attribute annotation doesn't contain ()
                //then it's a named attribute without value
                //otherwise, the value is in the parenthesis.
                if(index == -1) // attributes with no values
                {
                    attributeName = line.Substring(0,line.Length - 1);
                    attributeValue = null;
                }
                else // attributes with values
                {
                    attributeName = line.Substring(0, index);
                    attributeValue = line.Substring(index + 1, line.Length - 3 - index);
                }
                // add the attribute to the map.
                if(attributeName != null && !attributeTable.ContainsKey(attributeName))
                {
                    //Debug.Assert(attributeName.Length > 0);
                    attributeTable.Add(attributeName, attributeValue);
                }
            }
        }


        /// <summary>
        /// Validate a procedure definition to follow SPIL rules.
        /// If validation failed, this method would raise an exception.
        /// </summary>
        /// <param name="procDef"></param>
        protected void ValidateProcedure(ProcedureDefinition procDef)
        {
            // Check if partitionBy attribute is one of parameter
            if(procDef.attribute.callType == ProcedureCallType.CallOnPartitionHash)
            {
                string[] partitionCols = procDef.attribute.partitionBy.paramRef;
                for(int j = 1; j < partitionCols.Length; j ++) //skip algorithm
                {
                    string col = partitionCols[j].Trim();
                    bool found = false;
                    for(int i = 0; i < procDef.param.Length; i ++)
                    {
                        ParameterDefinition pdef = procDef.param[i];
                        if(pdef.spname == col)
                        {
                            found = true;
                            break;
                        }
                    }
                    if(!found) //the partition column is not found in parameter list
                    {
                        RaiseFatalError(  "Failed to generate procedure: Partition Column not found in paramter list");
                    }
                }
            }
        }
        /// <summary>
        /// Read the annotated stored procedure and returns the stored procedure SPIL attributes.
        /// The attribute name are case sensitive. If there're duplicate attributes, only the
        /// first one is returned. An attribute can have null values.
        /// </summary>
        /// <param name="sqlFilePath">the file name of the stored procedure to read annotation</param>
        /// <returns>A map that contains the attribute name as key, attribute value as value.</returns>
        protected Hashtable ReadAnnotation(string sqlFilePath)
        {
            Hashtable attributeTable = new Hashtable();
            StreamReader sr = null;
            try
            {
                sr = new StreamReader(sqlFilePath);
                // read each line until we match procedure declaration line.
                for(string line = sr.ReadLine(); line != null; line = sr.ReadLine())
                {
                    Match procMatch = procDeclRegex.Match(line);
                    if(procMatch.Success) // match procedure declaration line
                    {
                        break;
                    }
                    // process attribute key and value
                    // we don't strictly validate the attribute string yet.
                    if(line.StartsWith("--["))
                    {
                        string attributeName;
                        string attributeValue;
                        //strip off comment characters
                        line = line.Substring(3);
                        //read attribute name
                        int index = line.IndexOf("(");
                        //if the attribute annotation doesn't contain ()
                        //then it's a named attribute without value
                        //otherwise, the value is in the parenthesis.
                        if(index == -1) // attributes with no values
                        {
                            attributeName = line.Substring(0,line.Length - 1);
                            attributeValue = null;
                        }
                        else // attributes with values
                        {
                            attributeName = line.Substring(0, index);
                            attributeValue = line.Substring(index + 1, line.Length - 3 - index);
                        }
                        // add the attribute to the map.
                        if(attributeName != null && !attributeTable.ContainsKey(attributeName))
                        {
                            //Debug.Assert(attributeName.Length > 0);
                            attributeTable.Add(attributeName, attributeValue);
                        }
                    }
                }
            }
            catch(Exception e)
            {
                ial.SendToLog( this, LogEventLevel.Warning, "Failed to read annotation for " +sqlFilePath);
                ial.SendToLog( this, LogEventLevel.Warning, "Exception: " + e.Message);
                ial.SendToLog( this, LogEventLevel.Warning, "StackTrace: " + e.StackTrace);
                attributeTable = null;
            }
            finally
            {
                // we close stream reader in the caller.
                if(sr != null)
                    sr.Close();
            }
            return attributeTable;
        }

        /// <summary>
        /// Gets the stored procedure name from the file name
        /// This function assumes the file name is the stored procedure name plus ".sql"
        /// </summary>
        /// <param name="sqlFilePath">the SQL source file absolute path</param>
        /// <returns>the stored procedure name that's defined in the source</returns>
        protected string GetSpNameFromFileName(string sqlFilePath)
        {
            return Path.GetFileNameWithoutExtension(sqlFilePath);
        }

        /// <summary>
        /// change a string to pascal case. (should be put into a utility class)
        /// strips off the prefix of a stored procedure.
        /// This function assumes a stored procedure name has a prefix such as "sps_"
        /// and it has no consecutive underscore characters.
        /// </summary>
        /// <param name="input">input string</param>
        /// <returns>Pascal-case format of input string</returns>
        protected string PascalCase(string input)
        {
            if(input == null)
                return null;

            // remove version suffix tag if there's any
            string buildVerMajorNumber = Environment.GetEnvironmentVariable("_BLDVERMAJOR");
            string buildVerMinorNumber = Environment.GetEnvironmentVariable("_BLDVERMINOR");

            //ial.SendToLog( this, LogEventLevel.Info, "sproc version: " + buildVerMajorNumber + "." + buildVerMinorNumber);
            //Console.WriteLine("sproc version: " + buildVerMajorNumber + "." + buildVerMinorNumber);
            if(buildVerMajorNumber != String.Empty && buildVerMinorNumber != String.Empty)
            {
                string suffix = String.Format("_{0}_{1}",
                    buildVerMajorNumber, buildVerMinorNumber);
                if(input.EndsWith(suffix))
                {
                    input = input.Substring(0, input.Length - suffix.Length);
                }
            }

            input.Trim("_".ToCharArray());
            // if the string doesn't have underscores
            if(input.IndexOf("_") == -1)
            {
                if(input.Length > 0) // uppercase the first character
                {
                    input = input.Substring(0,1).ToUpper() + input.Substring(1);
                }
                // return input
                return input;
            }
            //use char array for high performance
            char[] chars = input.ToCharArray();
            bool fStart = false; //flag to indicate start of 'real' string, i.e. after prefix
            StringBuilder sb = new StringBuilder();
            // loop through the whole string. This loop does two things:
            // 1. strip off prefix and underscore character
            // 2. upper case the first character after underscore.
            for(int i = 0; i < chars.Length; i++)
            {
                if(!fStart)
                {
                    if(chars[i] != '_') // skip prefix string
                    {
                        continue;
                    }
                    else // passed prefixed string.
                    {
                        fStart = true;
                        i++;
                        sb.Append( Char.ToUpper( chars[i], System.Globalization.CultureInfo.CurrentCulture));
                        continue;
                    }
                }
                else
                {
                    if(chars[i] == '_')
                    {
                        i++; //skip underscores, upper case next letter, assuming it's not underscore again.
                        sb.Append( Char.ToUpper( chars[i], System.Globalization.CultureInfo.CurrentCulture));
                    }
                    else // simply append.
                    {
                        sb.Append(chars[i]);
                    }
                }
            }
            return sb.ToString();
        }
    } // class ProcedureInterfaces
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpillerSetup\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\Spil.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=1.1.4322.2032.
// 
namespace Microsoft.Subscriptions.Data.Tools {
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    [System.Xml.Serialization.XmlRootAttribute("procedureGroup", Namespace="http://schemas.microsoft.com/subscriptions/spil", IsNullable=false)]
    public class ProcedureGroup {
        
        /// <remarks/>
        public ProcedureGroupBinding binding;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("procedure")]
        public ProcedureDefinition[] procedure;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public class ProcedureGroupBinding {
        
        /// <remarks/>
        public string storeName;
        
        /// <remarks/>
        public string connectionString;
        
        /// <remarks/>
        public string @namespace;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("namespaceRef", IsNullable=false)]
        public string[] usingNamespace;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public class PartitionByData {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("paramRef")]
        public string[] paramRef;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string algorithm;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public class ProcedureAttributes {
        
        /// <remarks/>
        public PartitionByData partitionBy;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public ProcedureCallType callType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public ProcedureReturnType returnType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool writeRequired = false;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public enum ProcedureCallType {
        
        /// <remarks/>
        CallOnAnyPartition,
        
        /// <remarks/>
        CallOnAllPartitions,
        
        /// <remarks/>
        CallOnPartitionHash,
        
        /// <remarks/>
        CallOnPhysicalInstance,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public enum ProcedureReturnType {
        
        /// <remarks/>
        ProcedureResults,
        
        /// <remarks/>
        IDataReader,
        
        /// <remarks/>
        Scalar,
        
        /// <remarks/>
        NonQuery,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ParameterDefinition))]
    public abstract class ParameterDefinitionBase {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string spname;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string type;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public class ParameterDefinition : ParameterDefinitionBase {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string @default;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(SpilParameterDirection.Input)]
        public SpilParameterDirection direction = SpilParameterDirection.Input;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string size;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string description;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public enum SpilParameterDirection {
        
        /// <remarks/>
        Input,
        
        /// <remarks/>
        Output,
        
        /// <remarks/>
        InputOutput,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/subscriptions/spil")]
    public class ProcedureDefinition {
        
        /// <remarks/>
        public string summary;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("param")]
        public ParameterDefinition[] param;
        
        /// <remarks/>
        public ProcedureAttributes attribute;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string spname;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string @class;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool sqlmethod;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool sqlmethodSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string filename;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\StringUtil.cs ===
using System;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for StringUtil.
	/// </summary>
	internal class StringUtil
	{
		private StringUtil()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		/// <summary>
		/// Returns the string with all double quotes escaped.
		/// </summary>
		/// <param name="input"></param>
		/// <returns></returns>
		public static string EscapeDoubleQuote(string input)
		{
			if (input == null)
				return null;
			return input.Replace("\"", "\\\"");
		}	

        /// <summary>
        /// Capitalize First letter of the string
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public static string CapitalizeFirstLetter( string name) 
        {
            string newName = Char.ToUpper( name[0]) + name.Substring(1);
            return newName;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\Spiller.cs ===
/*
 *  Spiller.cs
 * 
 *  Program to work with SPIL files to 
 *      - generate .NET Framework code for input SPIL file
 *      - reverse engineer specified stored procedures to create interface contract
 * 
 * Revision History:
 *  Apr 2003    - TaoH     - added generate from directory option
 *  Aug 2002    - TaoH     - added webstore option
 *  Aug 2002    - MuraliK  - created
 */

using System;
using System.Xml;
using System.IO;
using System.Collections;
using Microsoft.Subscriptions.Data;
using Microsoft.Subscriptions.Utility;
using Microsoft.Subscriptions.Utility.Logging;

namespace Microsoft.Subscriptions.Data.Tools
{
    /// <summary>
    /// class Spiller
    /// o  The class implements the command line processing logic to use 
    /// SPIL CodeGenerator. It consumes a SPIL file and produces a .NET Framework 
    /// code file. 
    /// 
    /// At present it only produces code for C#.
    /// </summary>
    class Spiller
    {
        const string UsageTextResource = "Microsoft.Subscriptions.Data.Tools.UsageForSpiller.txt";

        IAuditLog ial;
        string param1;
        string outputFileName = null;
        ArrayList inputFileNames = null;
        
        // variables for parsing whole directory
        string inputDirectory = null;
        string inputFilePattern = null;

        public Spiller( string args0) 
        {

            SimpleLogRouter slr = new SimpleLogRouter( LogEventLevel.Info);
            DebugLogger dl = new DebugLogger();
            slr.LogNotifications += new AddToLogEventHandler(dl.AddToLog);

            ConsoleLogger cl = new ConsoleLogger();
            slr.LogNotifications += new AddToLogEventHandler(cl.AddToLog);

            ial = slr as IAuditLog;

            param1 = args0;
            ial.SendToLog( this, "Starting Spiller for " + param1);
        }

        private string storeName = null;
        private string className = null;
        private string nameSpace = null;
        private string connString = null;
        private string[] usingNameSpace = null;
        private bool useRegexParser = true;
        private bool suppressWarning = true;
        private ParamType paramType = ParamType.SqlDbType;
        private string[] testcases = null;

        /// <summary>
        /// Process command line arguments. Do we need stronger checking?
        /// </summary>
        private void ParseArgs( )
        {
            string[] args = Environment.GetCommandLineArgs();
            for(int i = 0; i < args.Length - 1; i ++)
            {
                if ( (args[i] == "-n") || (args[i] == "/n")) 
                {
                    if(!(args[i+1].StartsWith("/") || args[i+1].StartsWith("-")))
                        nameSpace = args[i+1];
                }
                else if ( (args[i] == "-t") || (args[i] == "/t")) 
                {
                    if(!(args[i+1].StartsWith("/") || args[i+1].StartsWith("-")))
                        storeName = args[i+1];
                }
                else if ( (args[i] == "-k") || (args[i] == "/k")) 
                {
                    if(!(args[i+1].StartsWith("/") || args[i+1].StartsWith("-")))
                        className = args[i+1];
                }
                else if ( (args[i] == "-s") || (args[i] == "/s")) 
                {
                    if(!(args[i+1].StartsWith("/") || args[i+1].StartsWith("-")))
                        connString = args[i+1];
                }
                else if ( (args[i] == "-t") || (args[i] == "/t")) 
                {
                    if(!(args[i+1].StartsWith("/") || args[i+1].StartsWith("-")))
                        storeName = args[i+1];
                }
                else if( (args[i] == "-u") || (args[i] == "/u"))
                {
                    ArrayList usingNameSpaceList = new ArrayList();
                    for(int j = i+1; j < args.Length; j++)
                    {
                        if(!(args[j].StartsWith("/") || args[j].StartsWith("-")))
                            usingNameSpaceList.Add(args[j]);
                        else
                            break;
                    }
                    usingNameSpace = (string[])usingNameSpaceList.ToArray(Type.GetType("System.String"));
                }
                else if( (args[i] == "-nowarning") || (args[i] == "/nowarning"))
                {
                    suppressWarning = false;
                }
                else if( (args[i] == "-sqlparser") || (args[i] == "/sqlparser"))
                {
                    useRegexParser = false;
                }
                else if( (args[i] == "-tc") || (args[i] == "/tc"))
                {
                    ArrayList testcaseFiles = new ArrayList();
                    for(int j = i+1; j < args.Length; j++)
                    {
                        if(!(args[j].StartsWith("/") || args[j].StartsWith("-")))
                            testcaseFiles.Add(args[j]);
                        else
                            break;
                    }
                    testcases = (string[])testcaseFiles.ToArray(Type.GetType("System.String"));
                }
            }
        }

        /// <summary>
        /// Generate C# from SPIL file. 
        /// Only generate methods if the procedure has [SqlMethod] attribute
        /// </summary>
        /// <returns></returns>
        private bool GenerateClassFile()
        {
            return GenerateClassFile(false);
        }

        /// <summary>
        /// Generate c# from SPIL file
        /// </summary>
        /// <param name="generateAllProcedures">if true, generate methods for all stored procedures. If false, only generate
        /// for stored procedures with [SqlMethod] attribute</param>
        /// <returns>true if generation is successful. false otherwise.</returns>
        private bool GenerateClassFile(bool generateAllProcedures) 
        {
            if(!File.Exists( param1)) 
            {
                ial.SendToLog( this, LogEventLevel.Error, "Failed to find file specified: " + param1);
                Console.Error.WriteLine("Cannot find input SPIL file: " + param1);
                return false;
            }

            SpilCodeGenerator.GenerateCodeForSpilFile( ial, param1, outputFileName, paramType, generateAllProcedures);
            
            return true;
        } // GenerateClassFile()


        /// <summary>
        /// Generate test case files based on test case definitions
        /// </summary>
        /// <returns>true if generation is successful, false otherwise</returns>
        private bool GenerateTestCaseFile()
        {
            // generate test cases
            if (testcases != null && testcases.Length > 0)
            {
                // generate new test case
                foreach(string testcasefile in testcases)
                {
                    string fileName = Path.GetFileName(testcasefile);
                    string outputFileName = Path.ChangeExtension(fileName, ".cs");
                    try
                    {
                        using(TextWriter twTestCase = new StreamWriter(outputFileName))
                        {
                            ial.SendToLog( this, LogEventLevel.Info, "Generating test case to file: \'" + outputFileName + "\'");
                            twTestCase.WriteLine("// \t Autogenerated by spiller from : {0}", fileName);
                            twTestCase.WriteLine("// \t DateTime: {0}", DateTime.Now);

                            TestCodeGenerator generator = new TestCodeGenerator(ial, param1);
                            if (!generator.GenerateTestCodeForSpil(testcasefile, twTestCase))
                                return false;
                        }
                    }
                    catch(Exception e)
                    {
                        ial.SendToLog(this, LogEventLevel.Error, "Failed to create test case: " + e.Message + "\r\n" + e.StackTrace);
                        return false;
                    }
                }
            }
            return true;
        }
        /// <summary>
        /// Generate SPIL file from database
        /// </summary>
        /// <returns></returns>
        private bool GenerateSpilFileFromDatabase( ) 
        {
            if(inputFileNames == null || inputFileNames.Count == 0)
            {
                ial.SendToLog( this, LogEventLevel.Error, "No input SQL source file specified");       
                return false;
            }

            ProcedureInterfaces pi = new ProcedureInterfaces( ial);
            ProcedureGroup procGroup = null;
            try
            {
                procGroup = pi.GenerateFromDatabase( param1, inputFileNames);
            }
            catch(Exception e)
            {
                ial.SendToLog( this, LogEventLevel.Error, e.Message);       
                return false;
            }

            if ( procGroup != null) 
            {

                //write out the XML SPIL document generated
                if ( outputFileName != null) 
                {
                    XmlHelper.WriteObjectToFile( outputFileName, procGroup, SpilConstants.SpilNamespace);
                }
                else 
                    Console.Out.WriteLine( procGroup);

                return true;
            }

            return false;
        } // GenerateSpilFileFromDatabase


        /// <summary>
        /// Generate SPIL file from source code
        /// </summary>
        /// <param name="alwaysCreate">If true, always create spil for the SQL. If false, only create spil code if the SQL
        /// file is annotated with [SqlMethod] attribute.</param>
        /// <returns></returns>
        private bool GenerateSpilFileFromSource()
        {
            if(inputFileNames == null || inputFileNames.Count == 0)
            {
                ial.SendToLog( this, LogEventLevel.Error, "No input SQL source file specified");
                return false;
            }

            ProcedureInterfaces pi = new ProcedureInterfaces( ial);
            pi.UseRegexParser = this.useRegexParser;
            pi.SuppressWarning = this.suppressWarning;

            ProcedureGroup procGroup = null;
            try
            {
                procGroup = pi.GenerateFromFiles( param1, inputFileNames);
            }
            catch(Exception e)
            {
                ial.SendToLog( this, LogEventLevel.Error, e.Message + "\n" + e.StackTrace);       
                return false;
            }

            if ( procGroup != null) 
            {
                //write out the XML SPIL document generated
                if ( outputFileName != null) 
                {
                    XmlHelper.WriteObjectToFile( outputFileName, procGroup, SpilConstants.SpilNamespace, "spil");
                }
                else 
                    Console.Out.WriteLine( procGroup);

                return true;
            }
            return false;
        }



        /// <summary>
        /// Generate SPIL file from all files in a directory
        /// </summary>
        /// <returns></returns>
        private bool GenerateSpilFileFromDirectory()
        {
            if(inputDirectory == null)
            {
                ial.SendToLog( this, LogEventLevel.Error, "No input SQL source directory specified");
                return false;
            }

            string filePattern = "*.*";
            if(inputFilePattern != null)
            {
                filePattern = inputFilePattern;
            }

            ArrayList inputSourceFiles = new ArrayList();
            if(inputFileNames != null)
            {
                foreach(string sqlFilePath in inputFileNames)
                {
                    FileInfo fileInfo = new FileInfo(sqlFilePath);
                    inputSourceFiles.Add(fileInfo.Name.ToLower());
                }
            }

            DirectoryInfo directoryInfo = new DirectoryInfo(inputDirectory);
            FileInfo[] fileInfos = directoryInfo.GetFiles(filePattern);
            ArrayList inputFiles = new ArrayList();
            foreach(FileInfo fileInfo in fileInfos)
            {
                if(inputSourceFiles.Contains(fileInfo.Name.ToLower()))
                {
                    inputFiles.Add(fileInfo.FullName);
                    Console.WriteLine("Adding " + fileInfo.FullName);
                }
            }
    
            ProcedureInterfaces pi = new ProcedureInterfaces( ial);

            ProcedureGroup procGroup = null;
            try
            {
                procGroup = pi.GenerateFromFiles( param1, inputFiles);
            }
            catch(Exception e)
            {
                ial.SendToLog( this, LogEventLevel.Error, e.Message + "\n" + e.StackTrace);       
                return false;
            }

            if ( procGroup != null) 
            {
                //write out the XML SPIL document generated
                if ( outputFileName != null) 
                {
                    XmlHelper.WriteObjectToFile( outputFileName, procGroup, SpilConstants.SpilNamespace, "spil");
                }
                else 
                    Console.Out.WriteLine( procGroup);

                return true;
            }
            return false;
        }

        /// <summary>
        /// Merge spil files into one spil file
        /// </summary>
        /// <returns></returns>
        private bool MergeSpils()
        {
            ProcedureGroup procGroupResult = new ProcedureGroup();
            ArrayList procedures = new ArrayList();

            try
            {
                #region foreach spilfile
                //Add all procedures
                foreach(string spilFile in inputFileNames)
                {
                    // Declare an object variable of the type to be deserialized.
                    ProcedureGroup procGroup;
                    // Use config xml to figure out what stored procedure to generate.
                    try
                    {
                        procGroup = (ProcedureGroup)(XmlHelper.LoadObjectFromFile( spilFile, typeof( ProcedureGroup)));
                    }
                    catch(Exception ex) 
                    {
                        ial.SendToLog( this, LogEventLevel.Fatal, "Failed to load SPIL file: " + ex.Message);
                        return false;
                    }
                    procedures.AddRange(procGroup.procedure);
                }
                #endregion
            }
            catch(Exception e)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, e.Message);       
                return false;
            }
            procGroupResult.procedure = (ProcedureDefinition[])procedures.ToArray(typeof(ProcedureDefinition));

            //Add Bindings
            ParseArgs();
            procGroupResult.binding = new ProcedureGroupBinding();
            procGroupResult.binding.storeName = storeName;
            procGroupResult.binding.@namespace = nameSpace;
            procGroupResult.binding.usingNamespace = usingNameSpace;
            procGroupResult.binding.connectionString = connString;

            //write out the XML SPIL document generated
            try
            {
                if ( outputFileName != null) 
                {
                    XmlHelper.WriteObjectToFile( outputFileName, procGroupResult, SpilConstants.SpilNamespace, "spil");
                }
                else 
                    Console.Out.WriteLine( procGroupResult);
            }
            catch(Exception ex)
            {
                ial.SendToLog( this, LogEventLevel.Fatal, "Failed to save merged SPIL file: " + ex.Message);
                return false;
            }

            return true;
        } //MergeSpils

        /// <summary>
        /// Store output file name
        /// </summary>
        /// <param name="args"></param>
        /// <param name="suffixTypeString"></param>
        private void StoreOutputFileName( string[] args, string suffixTypeString) 
        {
            for(int i = 1; i < args.Length-1; i++) 
            {
                if ( (args[i] == "-o") || (args[i] == "/o")) 
                {
                    outputFileName = args[i+1];
                    break;
                }
            }

            if ( outputFileName == null) 
            {
                // generate output file name from input file
                int lastSlash = param1.LastIndexOf( '\\');
                string lastPartName = (lastSlash >= 0) ? param1.Substring( lastSlash + 1): param1;
                int lastDot = lastPartName.LastIndexOf( '.');
                if (lastDot > 1) 
                {
                    outputFileName = lastPartName.Substring( 0, lastDot) + suffixTypeString;
                } 
                else 
                {
                    outputFileName = lastPartName + suffixTypeString;
                }
            }
            
            ial.SendToLog( this, LogEventLevel.Info, "Generating output to file: \'" + outputFileName + "\'");
        }

        /// <summary>
        /// Store input file name
        /// </summary>
        /// <param name="args"></param>
        private void StoreInputFileName( string[] args) 
        {
            // store all ".sql" file names after /i switch
            inputFileNames = new ArrayList();
            for(int i = 1; i < args.Length-1; i++) 
            {
                if ( (args[i] == "-i") || (args[i] == "/i")) 
                {
                    for( int j = i + 1; j <= args.Length - 1; j ++)
                    {
                        if( !args[j].StartsWith("-") && !args[j].StartsWith("/"))
                            inputFileNames.Add(args[j]);
                        else
                            break;
                    }
                    break;
                }
            }

            // store input directory for /a (GenerateFromDirectory) option
            for(int i = 1; i < args.Length-1; i++) 
            {
                if ( (args[i] == "-z") || (args[i] == "/z")) 
                {
                    inputDirectory = args[i+1];
                }
            }

            // store input file search pattern for /a (GenerateFromDirectory) option
            for(int i = 1; i < args.Length-1; i++) 
            {
                if ( (args[i] == "-p") || (args[i] == "/p")) 
                {
                    inputFilePattern = args[i+1];
                }
            }
        }

        /// <summary>
        /// Store generated parameter type. If "-r" is specified, generated
        /// parameter will use CLR type, otherwise, SQL native type is used.
        /// </summary>
        /// <param name="args"></param>
        private void StoreParamType( string[] args)
        {
            for(int i = 1; i < args.Length; i++) 
            {
                if ( (args[i] == "-r") || (args[i] == "/r")) 
                {
                    paramType = ParamType.ClrType;
                    return;
                }
            }
        }

        private static void PrintUsage() 
        {
            Stream usageTextStream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream( Spiller.UsageTextResource);
            char[] buffer = new char[1000];
            StreamReader srRead = new StreamReader( usageTextStream);

            srRead.BaseStream.Seek(0, SeekOrigin.Begin);
            srRead.BaseStream.Position = 0;
            while ( true) 
            { // srRead.BaseStream.Position < srRead.BaseStream.Length) {
                int iret = srRead.Read(buffer, 0, buffer.Length);
                if (iret == 0) // EOF
                    break;
                Console.Write( buffer, 0, iret);
                // srRead.BaseStream.Position++
            }
            srRead.DiscardBufferedData();
            srRead.Close();
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        public static int Main(string[] args) 
        {
            try
            {
                if ( args.Length < 2) 
                {
                    PrintUsage();
                    return 1;
                }

                if ( args[0] == "-help") 
                {
                    PrintUsage();
                    return 1;
                }

                Spiller spiller = new Spiller( args[0]);
                spiller.StoreInputFileName( args);

                switch ( args[1]) 
                { //use "-c" "-d" "-a" "-f" "-m" 
                    case "/c":
                        spiller.StoreParamType( args);
                        spiller.StoreOutputFileName( args, ".cs");
                        // generate the class file from the input SPIL file
                        if ( !spiller.GenerateClassFile())
                            return 2;
                        spiller.ParseArgs();
                        if (spiller.testcases != null && spiller.testcases.Length > 0)
                        {
                            if ( !spiller.GenerateClassFile(true))
                                return 8;
                            if ( !spiller.GenerateTestCaseFile())
                                return 10;
                        }
                        break;

                    case "/d":
                        spiller.StoreOutputFileName( args, ".spil");
                        if ( !spiller.GenerateSpilFileFromDatabase()) 
                            return 3;
                        break;

                    case "/a":
                        spiller.StoreOutputFileName( args, ".spil");
                        if ( !spiller.GenerateSpilFileFromDirectory()) 
                            return 7;
                        break;

                    case "/f":
                        spiller.StoreOutputFileName( args, ".spil");
                        if ( !spiller.GenerateSpilFileFromSource())
                            return 4;
                        break;

                    case "/m":
                        spiller.StoreOutputFileName( args, ".spil");
                        if( !spiller.MergeSpils())
                            return 6;
                        break;

                    default:
                        PrintUsage();
                        return 15;
                }

                return 0;
            }
            
            catch(Exception e)
            {
                Console.WriteLine("spiller : error : " + e.ToString());
                return 1;
            } 
        } // Main()
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\TestCodeGenerator.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections.Specialized;
using Microsoft.Subscriptions.Utility.Logging;

namespace Microsoft.Subscriptions.Data.Tools
{
	/// <summary>
	/// Generate unit test code from the spil xml file
	/// </summary>
	internal class TestCodeGenerator
	{
		#region Properties
		/// <summary>
		/// stores the database name in spil file
		/// </summary>
		private string storeName;
		/// <summary>
		/// stores the partial connection string
		/// </summary>
		private string connectionString;
		/// <summary>
		/// stores namespace
		/// </summary>
		private string nameSpace;
		/// <summary>
		/// stores the spil xml dom.
		/// </summary>
		private XmlDocument xmlDoc;
		/// <summary>
		/// Audit log
		/// </summary>
		private IAuditLog ial;
		/// <summary>
		/// Namespace manager
		/// </summary>
		private XmlNamespaceManager nsmgr;
		/// <summary>
		/// verbose output
		/// </summary>
		private bool verbose = false;
		#endregion

		#region Constructors
		/// <summary>
		/// Create a code generator for unit test case.
		/// </summary>
		/// <param name="inputSpilFile">The spil file used as blueprint to generate test cases</param>
		public TestCodeGenerator(IAuditLog ial, string inputSpilFile)
		{
			// assume ial is not null.
			this.ial = ial;
			// load spil file
			xmlDoc = new XmlDocument();
			try
			{
				xmlDoc.Load(inputSpilFile);
			}
			catch(IOException ioe)
			{
				// Failed to load input spil file
				ial.SendToLog(this, LogEventLevel.Error, "Failed to load spil file: " + ioe.Message);
				throw new SpilCodeGenerationException("Failed to load spil file.", ioe);
			}
			catch(XmlException xmle)
			{
				// Failed to load input spil file
				ial.SendToLog(this, LogEventLevel.Error, "Failed to load spil file: " + xmle.Message);
				throw new SpilCodeGenerationException("Failed to load spil file.", xmle);
			}
			nsmgr = new XmlNamespaceManager(xmlDoc.NameTable);
			nsmgr.AddNamespace("spil", "http://schemas.microsoft.com/subscriptions/spil");
			
			storeName = GetNodeValue("/spil:procedureGroup/spil:binding/spil:storeName");
			if (storeName == null)
			{
				throw new SpilCodeGenerationException("Store name is empty in definition file.");
			}
			connectionString = GetNodeValue("/spil:procedureGroup/spil:binding/spil:connectionString");
			if (connectionString == null)
			{
				throw new SpilCodeGenerationException("connection string is empty in definition file.");
			}
			nameSpace = GetNodeValue("/spil:procedureGroup/spil:binding/spil:namespace");
		}

		#endregion

		#region Public Methods
		/// <summary>
		/// Generate test code from spil file and an input test case specification file
		/// </summary>
		/// <param name="inputUnitTestFile">input unit case file</param>
		/// <param name="textWriterForOutputCode">text writer for output</param>
		/// <returns>true if generated successfully, false otherwise</returns>
        internal bool GenerateTestCodeForSpil(string inputUnitTestFile, TextWriter textWriterForOutputCode)
        {
            // load unit test case file
            XmlDocument xmlDocTestCases = new XmlDocument();
            try
            {
                xmlDocTestCases.Load(inputUnitTestFile);
            }
            catch(IOException ioe)
            {
                // Failed to load input spil file
				ial.SendToLog(this, LogEventLevel.Error, "Failed to load input unit test case file: " + ioe.Message);
                return false;
            }
            catch(XmlException xmle)
            {
                // Failed to load input spil file
				ial.SendToLog(this, LogEventLevel.Error, "Failed to load input unit test case file: " + xmle.Message);
                return false;
            }

			// TODO: validate schema.

            IndentTextWriter writer = new IndentTextWriter(textWriterForOutputCode);
			
			XmlNode rootNode = xmlDocTestCases.SelectSingleNode("/Suite");
			if (rootNode == null)
			{
				ial.SendToLog(this, LogEventLevel.Error, "Failed to load the unit tests. Missing Suite node");
				return false;
			}
			if (rootNode.Attributes["mode"] != null
				&& rootNode.Attributes["mode"].Value == "debug")
			{
				verbose = true;
			}

			// write first part of the class
			WritePreamble(writer);

			writer.WriteLine("[TestFixture]");
			writer.WriteLine("public class " + rootNode.Attributes["name"].Value);
			writer.WriteLine("{");
            writer.Indent();
            foreach(XmlNode testcaseNode in xmlDocTestCases.SelectNodes("/Suite/Case"))
            {                  
                // write test attribute
				writer.WriteLine("[Test]");
                // write expected exception attribute
				XmlNode exceptionNode = testcaseNode.SelectSingleNode("Expected/Exception");
				if (exceptionNode != null)
				{
					string exception = "DataStoreException"; // default type
					if(exceptionNode.Attributes["type"] != null)
					{
						exception = exceptionNode.Attributes["type"].Value;
					}
					
					writer.WriteLine("[ExpectedException(typeof({0}))]", exception);
				}
                // write function
                //  public void Function()
                //  {
                //      using (TransactionWrapper txWrapper = new TransactionWrapper())
                //      {
                //          InternalFunction();
                //          txWrapper.SetComplete(); // if commit transaction
                //      }
                //  }
                //
                writer.WriteLine("public void {0}()", testcaseNode.Attributes["name"].Value);
                writer.WriteLine("{");
                writer.Indent();
                writer.WriteLine("using(TransactionWrapper txWrapper = new TransactionWrapper())");
                writer.WriteLine("{");
                writer.Indent();
                writer.WriteLine("Internal{0}();" , testcaseNode.Attributes["name"].Value);
                // write commit statement
                if (testcaseNode.Attributes["transaction"] != null)
                {
                    string useTransaction = testcaseNode.Attributes["transaction"].Value.ToLower();
                    if (useTransaction == "commit")
                    {
                        writer.WriteLine("txWrapper.SetComplete();");                        
                    }
                }
                writer.Unindent();
                writer.WriteLine("}");
                writer.Unindent();
                writer.WriteLine("}");

                // write internal function
                // internal void InternalFunction()
                // {
                //     using(SimpleConnectionManager scm = new SimpleConnectionManager(\".\"))
                //     {
                //          ProcedureResults pr = null;
                //          // setup
                //          // functionbody
                //          // assertions
                //      }
                // }
                writer.WriteLine("internal void Internal{0}()", testcaseNode.Attributes["name"].Value);
                writer.WriteLine("{");
                writer.Indent();
				
                // TODO: make server name configurable!
                writer.WriteLine("using(SimpleConnectionManager scm = new SimpleConnectionManager(\".\"))");
                writer.WriteLine("{");
                writer.Indent();

				writer.WriteLine("ProcedureResults pr = null;");

				WriteSetup(xmlDoc, testcaseNode, writer);

				int procedureCount; 
				WriteFunctionBody(xmlDoc, testcaseNode, writer, out procedureCount);

				if (procedureCount == 0)
				{
					return false; // no test case is generated
				}
				// write assertions 
				XmlNode expectedNode = testcaseNode.SelectSingleNode("Expected");
				WriteExpected(writer, xmlDoc, testcaseNode, expectedNode, procedureCount);
				                
                writer.Unindent();
                writer.WriteLine("}");
                writer.Unindent();
                writer.WriteLine("}");
            }
            writer.Unindent();
			WriteEpilog(writer);
			return true;
        }

		/// <summary>
		/// Write setup portion of the function
		/// </summary>
		/// <param name="xmlDoc"></param>
		/// <param name="testcaseNode"></param>
		/// <param name="writer"></param>
		protected void WriteSetup(XmlDocument xmlDoc, XmlNode testcaseNode, IndentTextWriter writer)
		{
			XmlNode inputNode = testcaseNode.SelectSingleNode("Setup");
			if (inputNode == null)
			{
				ial.SendToLog(this, LogEventLevel.Verbose, "Input dataset not specified. Skipping.");
				return;
			}
			foreach(XmlNode setupNode in inputNode.ChildNodes)
			{
				if( setupNode.Name == "Sql")
				{
					string sql = setupNode.InnerText;
					string quotedSql = StringUtil.EscapeDoubleQuote(sql);
					WriteDebugMessage(writer, "Loading Sql: {0}", quotedSql);
					writer.WriteLine("DataLoader.LoadSql(\"{0}\",\"{1}\", scm, \"{2}\");", storeName, StringUtil.EscapeDoubleQuote(sql),
						StringUtil.EscapeDoubleQuote(connectionString));
				}
				else if (setupNode.Name == "File")
				{
					string fileName = setupNode.Attributes["name"].Value;
					string tableName = setupNode.Attributes["tablename"].Value;
					WriteDebugMessage(writer, "Loading File [{0}] To Table [{1}]", fileName, tableName);
					writer.WriteLine("DataLoader.LoadFile(\"{0}\",\"{1}\",@\"{2}\", scm, \"{3}\");", storeName, tableName, fileName,
						StringUtil.EscapeDoubleQuote(connectionString));
				}
//				else if (setupNode.Name == "Bcp")
//				{
//					string bcpText = setupNode.InnerText;
//					writer.WriteLine("DataLoader.LoadBcp(\"{1}\");", StringUtil.EscapeDoubleQuote(bcpText));
//				}	
				else
				{
					throw new NotSupportedException(String.Format("Setup type [0] is not supported.", setupNode.Name));
				}
			}
		}

		/// <summary>
		/// Write first part of the class
		/// </summary>
		/// <param name="writer"></param>
		protected void WritePreamble(IndentTextWriter writer)
		{
			writer.WriteLine("using System;");
			writer.WriteLine("using System.Data.SqlTypes;");
			writer.WriteLine("using NUnit.Framework; // for NUnit");
			writer.WriteLine("using Microsoft.Subscriptions.Data; // for SpilRun");
			writer.WriteLine("using System.Data.SqlClient; // for SqlException");
			writer.WriteLine("using System.Data;");

			if (nameSpace != null)
			{
				writer.WriteLine("namespace {0}", nameSpace);
				writer.WriteLine("{");
				writer.Indent();
			}
		}

		/// <summary>
		/// Write last part of the class
		/// </summary>
		/// <param name="writer"></param>
		protected void WriteEpilog(IndentTextWriter writer)
		{
			writer.Unindent();
			writer.WriteLine("}");

			if (nameSpace != null)
			{
				writer.Unindent();
				writer.WriteLine("}");
			}
		}
		
		/// <summary>
		/// Write a function body
		/// </summary>
		/// <param name="xmlDoc"></param>
		/// <param name="testcaseNode"></param>
		/// <param name="writer"></param>
		/// <param name="procedureCount"></param>
        protected void WriteFunctionBody(XmlDocument xmlDoc, XmlNode testcaseNode, IndentTextWriter writer, out int procedureCount)
        {
			StringCollection classNames = new StringCollection();

			int procedureIndex = 0;
            foreach(XmlNode procedureNode in testcaseNode.SelectNodes("Procedure"))
            {
                string procedureName = procedureNode.Attributes["name"].Value;
				ial.SendToLog(this, LogEventLevel.Verbose, "Generating function for " + procedureName);
                // search for the procedure in spil xml
                string xpath = String.Format("/spil:procedureGroup/spil:procedure[@name='{0}']", procedureName);
                XmlNode procedureDefNode = xmlDoc.SelectSingleNode(xpath, nsmgr);
				if (procedureDefNode == null)
				{
					//TODO: throw an error
					ial.SendToLog(this, LogEventLevel.Info, "Skipped. No procedure found with the name " + procedureName);
				}
				else
				{
					procedureIndex++;
					// get definitions, assemble parameters
					StringCollection paramNames = new StringCollection();
					foreach(XmlNode paramNode in procedureDefNode.SelectNodes("spil:param", nsmgr))
					{
						string paramName = paramNode.Attributes["name"].Value;
						string paramSpName = paramNode.Attributes["spname"].Value;
						string paramSqlType = paramNode.Attributes["type"].Value;
						bool paramIsOutput = false;
						if(paramNode.Attributes["direction"] != null &&
							paramNode.Attributes["direction"].Value == "Output")
						{
							paramIsOutput = true;
						}

						// translate the type to ADO.NET
						string paramNetType = SpilCodeGenerator.FindFrameworkSqlType(paramSqlType);
                        
                        
						// find the value from testcasenode
						string testcaseParamNodeXpath = String.Format("Param[@name='{0}']", paramSpName);
						XmlNode testcaseParamNode = procedureNode.SelectSingleNode(testcaseParamNodeXpath);
						if (testcaseParamNode == null || testcaseParamNode.Attributes["value"] == null ||
                            testcaseParamNode.Attributes["value"].Value == "[NULL]")
						{
                            if (paramNetType == "SqlString")
                            {
                                writer.WriteLine("{0} m_{1}_{2} = null; ", "string", paramSpName, procedureIndex);
                            }
                            else
                            {
                                // write default Null value
                                writer.WriteLine("{0} m_{1}_{2} = {0}.Null;", paramNetType, paramSpName, procedureIndex);
                            }
						}
						else
						{
							string paramValue = testcaseParamNode.Attributes["value"].Value;
                            if (paramNetType == "SqlString")
                            {
                                writer.WriteLine("{0} m_{1}_{3} = {2};", "string", paramSpName, GetQuotedValue(paramNetType, paramValue), procedureIndex);
                            }
                            else
                            {
                                writer.WriteLine("{0} m_{1}_{3} = new {0}({2});", paramNetType, paramSpName, GetQuotedValue(paramNetType, paramValue), procedureIndex);
                            }
						}
						if(paramIsOutput)
							paramNames.Add(String.Format("ref m_{0}_{1}", paramSpName, procedureIndex));
						else
							paramNames.Add(String.Format("m_{0}_{1}", paramSpName, procedureIndex));
					}

                    
					string className = StringUtil.CapitalizeFirstLetter(procedureDefNode.Attributes["class"].Value);
					if (!classNames.Contains(className))
					{
						writer.WriteLine("{0} m_data = new {0}();", className);
						classNames.Add(className);
					}

                    writer.WriteLine("try");
                    writer.WriteLine("{");
                    writer.Indent();
					// call procedure
					WriteDebugMessage(writer, "Calling Procedure [{0}]", procedureName);
					writer.WriteLine("pr = m_data.{0}(", procedureName);
					writer.Indent();
					writer.WriteLine("scm");
					foreach(string paramName in paramNames)
					{
						writer.WriteLine(", {0}", paramName);
					}
					writer.Unindent();
					writer.WriteLine(");");

					WriteDebugMessage(writer, "Results from [{0}]", procedureName);
					if(verbose)
					{
						writer.WriteLine("pr.Results.WriteXml(Console.Out, System.Data.XmlWriteMode.IgnoreSchema);");
					}
					WriteDebugMessage(writer, "");
                    
                    writer.Unindent();
                    writer.WriteLine("}"); // finish try
                    writer.WriteLine("catch (DataStoreException dse)");
                    writer.WriteLine("{");
                    writer.Indent();
                    // catch body
                    writer.WriteLine("if (dse.ProcedureResults != null)");
                    writer.Indent();
                    writer.WriteLine("pr = dse.ProcedureResults;");
                    writer.Unindent();
                    writer.WriteLine("throw;");
                    writer.Unindent();
                    writer.WriteLine("}");
                    writer.WriteLine("finally");
                    writer.WriteLine("{");
                    writer.Indent();
                    // finally body
                    writer.Unindent();
                    writer.WriteLine("}");
                    
				}            
            }
			procedureCount = procedureIndex;
            if(procedureCount == 0)
            {
                throw new SpilCodeGenerationException("No unit test procedure is generated.");
            }
        }

		/// <summary>
		/// Write assertions
		/// </summary>
		/// <param name="writer"></param>
		/// <param name="xmlDoc"></param>
		/// <param name="expectedNode"></param>
		/// <param name="procedureCount"></param>
		protected void WriteExpected(IndentTextWriter writer, XmlDocument xmlDoc, XmlNode testcaseNode, XmlNode expectedNode, int procedureCount)
		{
			// foreach expected node
			foreach(XmlNode node in expectedNode.ChildNodes)
			{
				if (node.Name == "ReturnValue")
				{
					string paramValue = node.InnerText;
					// return value must be an integer
					try
					{
						int.Parse(paramValue);
					}
					catch(FormatException)
					{
						ial.SendToLog(this, LogEventLevel.Error, "Return value must be an integer: " + paramValue);
					}
					WriteDebugMessage(writer, "Checking ReturnValue = {0}", paramValue);
					writer.WriteLine("Assert.AreEqual({0}, pr.ReturnValue);", paramValue);
				}
					// generate output param assertions
				else if (node.Name == "OutputParam")
				{
					string paramName = node.Attributes["name"].Value;
					string paramValue = node.Attributes["value"].Value;
					WriteDebugMessage(writer, "Checking Output Parameter [{0}] = [{1}]", paramName, paramValue);
                    if (paramValue == "[NULL]")
                    {
                        writer.WriteLine("DbAssertion.AssertDbNull({0});", "m_" + paramName + "_" + procedureCount);
                    }
                    else
                    {
                        // find procedureIndex (use the last one)
                        string paramType = FindTypeForParam(testcaseNode, paramName);
                        paramValue = GetQuotedValue(paramType, paramValue);
                        if (paramType == "SqlString")
                        {
                            writer.WriteLine("Assert.AreEqual({0},{1});", paramValue, "m_" + paramName + "_" + procedureCount);
                        }
                        else
                        {
                            writer.WriteLine("Assert.AreEqual({0},{1}.Value);", paramValue, "m_" + paramName + "_" + procedureCount);
                        }
                    }
				}
				// generate output dataset assertions
				else if (node.Name == "OutputDataSet")
				{
					bool strictCompare = false;
					if(node.Attributes["mode"] != null &&
						node.Attributes["mode"].Value == "strict")
					{
						strictCompare = true;
					}
					
					XmlNode fileNode = node.SelectSingleNode("File");
					if (fileNode != null) // use file compare
					{
						string fileName = fileNode.Attributes["name"].Value;
						string fileType = "xml";
						if (fileNode.Attributes["type"] != null)
						{
							fileType = fileNode.Attributes["type"].Value;
						}
						WriteDebugMessage(writer, "Checking Output DataSet = [0]", fileName);
						writer.WriteLine("DbAssertion.AssertDatasetEqualsFile(@\"{0}\", \"{1}\", pr.Results, {2});", fileName, fileType, strictCompare?"true":"false");
					}
					else // use table compare
					{
						string escapedXml = node.OuterXml.Replace("\"","\\\"");
                        escapedXml = escapedXml.Replace("\n"," "); //replace newline with space
						WriteDebugMessage(writer, "Checking Output DataSet = {0}", escapedXml);
						writer.WriteLine("string expectedXml = \"{0}\";", escapedXml);
						writer.WriteLine("DbAssertion.AssertDatasetEqualsXml(expectedXml, pr.Results, {0});", strictCompare?"true":"false");
					}
				}
				else if (node.Name == "Database")
				{
					bool strictCompare = false;
					if(node.Attributes["mode"] != null &&
						node.Attributes["mode"].Value == "strict")
					{
						strictCompare = true;
					}
					XmlNode filterNode = node.SelectSingleNode("Filter");
					if (filterNode == null)
					{
						throw new SpilCodeGenerationException("Filter cannot be empty.");
					}
					string filter = filterNode.InnerText;
					filter = filter.Replace("\r\n"," "); //replace newline with space

					XmlNode resultsNode = node.SelectSingleNode("Results");
					XmlNode fileNode = resultsNode.SelectSingleNode("File");
					if (fileNode != null)
					{
						string fileName = fileNode.Attributes["name"].Value;
						string fileType = "xml";
						if (fileNode.Attributes["type"] != null)
							fileType = fileNode.Attributes["type"].Value;
						// select out the value
						WriteDebugMessage(writer, "Checking database. Filter: {0}", filter);
						writer.WriteLine("DbAssertion.AssertDatabaseEquals(@\"{0}\", \"{1}\", \"{2}\", \"{3}\", scm, {4});", fileName, filter, this.storeName, this.connectionString, strictCompare?"true":"false");
					}
					else // use table compare
					{
						string escapedXml = resultsNode.InnerXml.Replace("\"","\\\"");
                        Console.WriteLine(escapedXml);
                        escapedXml = escapedXml.Replace("\r\n"," "); //replace newline with space
						WriteDebugMessage(writer, "Checking Output DataSet = {0}", escapedXml);
						writer.WriteLine("string expectedXml = \"{0}\";", escapedXml);
						writer.WriteLine("DbAssertion.AssertDatabaseEqualsXml({0}, \"{1}\", \"{2}\", \"{3}\", scm, {4});", "expectedXml", filter, this.storeName, this.connectionString, strictCompare?"true":"false");
					}
				}
			}
		}
		#endregion

		#region Utility Functions
		/// <summary>
		/// Quote the parameter value
		/// </summary>
		/// <param name="paramType"></param>
		/// <param name="paramValue"></param>
		/// <returns></returns>
		internal static string GetQuotedValue(string paramType, string paramValue)
		{
			switch(paramType)
			{
				case "string":
				case "SqlString":
				case "SqlGuid":
					return String.Format("\"{0}\"", paramValue);
                case "SqlDateTime":
                    return String.Format("DateTime.Parse(\"{0}\")", paramValue);
				default:
					return paramValue;
			}
		}

		/// <summary>
		/// Get XmlNode value
		/// </summary>
		/// <param name="xpath"></param>
		/// <returns></returns>
		internal string GetNodeValue(string xpath)
		{
			XmlNode node = xmlDoc.SelectSingleNode(xpath, nsmgr);
			if(node != null)
			{
				return node.InnerText;
			}
			else
			{
				return null;
			}
		}

		/// <summary>
		/// Find the parameter type for the given parameter name
		/// </summary>
		/// <param name="paramName"></param>
		/// <returns></returns>
		internal string FindTypeForParam(XmlNode testcaseNode, string paramName)
		{
			XmlNodeList procedureNodes = testcaseNode.SelectNodes("Procedure");
			XmlNode lastProcedureNode = procedureNodes[procedureNodes.Count - 1];
			string procedureName = lastProcedureNode.Attributes["name"].Value;
			string xpath = String.Format("/spil:procedureGroup/spil:procedure[@name='{0}']", procedureName);
			XmlNode procedureDefNode = xmlDoc.SelectSingleNode(xpath, nsmgr);
			if (procedureDefNode == null)
			{
				throw new SpilCodeGenerationException("Cannot find corresponding procedure definition: " + procedureName);
			}
			XmlNode paramNode = procedureDefNode.SelectSingleNode(string.Format("spil:param[@spname='{0}']",paramName), nsmgr);
			if (paramNode == null)
			{
				throw new SpilCodeGenerationException("Cannot find corresponding parameter definition: " + paramName);
			}
			string paramSqlType = paramNode.Attributes["type"].Value;
			return SpilCodeGenerator.FindFrameworkSqlType(paramSqlType);
		}

		internal void WriteDebugMessage(IndentTextWriter writer, string message)
		{
			if (verbose)
				writer.WriteLine("Console.WriteLine(\"{0}\");", message);
		}

		internal void WriteDebugMessage(IndentTextWriter writer, string format, params object[] args)
		{
			if (verbose)
				writer.WriteLine("Console.WriteLine(\"{0}\");", string.Format(format, args));
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\XmlHelper.cs ===
/*
 *  XmlHelper.cs
 * 
 *  Set of helper classes and methods for dealing with Xml
 * 
 * Revision History:
 *  March 2002  - MuraliK      - created for SPG Bable project
 *  Aug   2002 - MuraliK        - added namespace; cleaned up for wider use
 */

using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace Microsoft.Subscriptions.Utility
{
        /// <summary>
        ///  Helper functions for dealing with Xml input/output and objects
        /// </summary>
        public class XmlHelper
        {
                private XmlHelper()
                { 
                    // Use private constructor to prevent unintended 
                    //  instantiation for this static method-only class
                }

        /// <summary>
        /// This method loads the supplied XML file.
        ///  With help from Xml Serializer, it deserializes the input XML
        ///  into an object instance of the specified type.
        ///  
        ///  Usage:
        ///     MyObject o = XmlHelper.LoadObjectFromFile( fileName, typeof( MyObject));
        /// 
        /// TODO: Cache the serialization object so that we can reuse it for future
        ///   loads of objects. This is an optimization and hence not implemented.    
        /// </summary>
        /// <param name="fileName">input file containing the Xml serialized object instance</param>
        /// <param name="type">Runtime type to which the object is deserialized into</param>
        /// <returns> on success an object instance of the specified type is returned.
        /// on failure, an exception is returned.</returns>
        static public object LoadObjectFromFile( string fileName, System.Type type) {

            XmlSerializer serializer = new XmlSerializer( type);

            Stream reader= new FileStream(fileName, FileMode.Open, FileAccess.Read);
            object oRet = serializer.Deserialize( reader);
            reader.Close();

            return oRet;
        }


        /// <summary>
        /// Writes the specified XML Document to target file using UTF8 encoder
        /// </summary>
        /// <param name="fileName">target file in which contents are saved</param>
        /// <param name="xmldoc">document to be saved</param>
        static public void WriteXmlDocumentToFile( string fileName, XmlDocument xmldoc) {
            XmlTextWriter writer = new XmlTextWriter( fileName, System.Text.Encoding.UTF8);
            writer.Formatting = Formatting.Indented;
            xmldoc.WriteTo( writer );
            writer.Flush();
        }

        /// <summary>
        /// This function writes the supplied object to the file specified.
        /// It infers the object type from the object and uses the supplied
        ///  namesapce for the output generated. 
        ///  
        /// No backups are made during such a write. Old contents are over-written.
        /// TODO: Cache the serialization object so that we can reuse it for future
        ///   loads of objects. This is an optimization and hence not implemented.    
        /// </summary>
        /// <param name="fileName">target file in which the content is to be saved</param>
        /// <param name="objToWrite">specific object instance to write</param>
        /// <param name="contentNamespace">namespace for the XML serialized object</param>
        static public void WriteObjectToFile( string fileName, object objToWrite, string contentNamespace) {
            WriteObjectToFile( fileName, objToWrite, contentNamespace, "a");
        }

        /// <summary>
        /// This function writes the supplied object to the file specified.
        /// It infers the object type from the object and uses the supplied
        ///  namesapce for the output generated. 
        ///  
        /// No backups are made during such a write. Old contents are over-written.
        /// TODO: Cache the serialization object so that we can reuse it for future
        ///   loads of objects. This is an optimization and hence not implemented.    
        /// </summary>
        /// <param name="fileName">target file in which the content is to be saved</param>
        /// <param name="objToWrite">specific object instance to write</param>
        /// <param name="contentNamespace">namespace for the XML serialized object</param>
        /// <param name="prefixForNamespace">prefix for the namespace of content written out</param>
        static public void WriteObjectToFile( string fileName, object objToWrite, string contentNamespace, string prefixForNamespace) {

            System.Type type = objToWrite.GetType();
            XmlSerializer serializer = new XmlSerializer( type);

            XmlQualifiedName[] namespaces = new XmlQualifiedName[1];
            namespaces[0] = new XmlQualifiedName( prefixForNamespace, contentNamespace);

            // Create an XmlSerializerNamespaces object.
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces( namespaces);

            // Create an XmlTextWriter using a FileStream.
            Stream fs = new FileStream( fileName, FileMode.Create);

            XmlWriter writer = new XmlTextWriter(fs, new System.Text.UTF8Encoding());

            // Serialize using the XmlTextWriter.
            serializer.Serialize( writer, objToWrite, ns);
            writer.Close();
        }

#if TODO_WRITE_FUNCTIONS
        // TODO: Implement following modifications of writes later
        //  - Write with an XSL
        //  - Write with a backup
        //  - Write with serializer cached
        static public void WriteFile( string fileName, System.Type type, object objToWrite) {
            WriteFile( fileName, type, objToWrite, false);
        }

        static public void WriteFile( string fileName, System.Type type, object objToWrite, bool fWriteXslPI) {

            XmlSerializer serializer = new XmlSerializer( type);
            
            XmlQualifiedName[] namespaces = new XmlQualifiedName[1];
            namespaces[0] = raptorNS;
            // Create an XmlSerializerNamespaces object.
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces( namespaces);

            // Create an XmlTextWriter using a FileStream.
            Stream fs = new FileStream( fileName, FileMode.Create);

            XmlWriter writer = new XmlTextWriter(fs, new UTF8Encoding());
            if ( fWriteXslPI) {
                writer.WriteProcessingInstruction( "xml-stylesheet", CampusVisitSummary_ViewPI);
            }

            // Serialize using the XmlTextWriter.
            serializer.Serialize( writer, objToWrite, ns);
            writer.Close();
        }

        static public void BackupFile( string fileName) {
            string backupFileName = fileName + ".bak";
            

            // if the backup file exists, i need to delete that file for now.
            if ( File.Exists( backupFileName)) {
                File.Delete( backupFileName);
            }

            if ( File.Exists( fileName)) {
                System.IO.File.Move( fileName, backupFileName);
            }

            // TODO: I need to restore safe mode if i fail in making this backup!
        }
#endif // TODO_WRITE_FUNCTIONS

    } // class XmlHelper
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS SPIL Runtime")]
[assembly: AssemblyDescription("Runtime library classes for interfacing with database stored procedures")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Subscription Platform Services")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// Version Info comes from separate file!
// [assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile(@"SpilRun.snk")]
[assembly: AssemblyKeyName("")]

// It is a good thing to have CLSCompliance - hence marking it
[assembly:CLSCompliant(true)]

// Thanks a lot - i do not need COM anymore! the default is true - so mark it false
[assembly:ComVisible(false)]
//
// Require that at minimum the user should be able to read the USERNAME environment permission
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="USERNAME")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\Spiller\SpilCodeGenerator.cs ===
/*
 *  SpilCodeGenerator.cs
 * 
 *   Runtime support class to generate the .NET Framework code
 *   for an input SPIL file.
 * 
 * Revision History:
 *  Feb 2003    - TaoH - implemented CodeDom to replace XSL transfrom from SPIL to CSharp
 *  Aug 2002    - MuraliK  - created
 */

using System;
using System.IO;
using System.Xml;
using System.Reflection;
using System.Collections;
using System.Xml.Xsl;
using System.Xml.Serialization;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Data.SqlTypes;
using Microsoft.CSharp;
using Microsoft.Subscriptions.Utility;
using Microsoft.Subscriptions.Utility.Logging;
using Microsoft.Subscriptions.Data.Tools;
using System.Text;
using System.Collections.Specialized;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// specifies SPIL generated code parameter types. 
    /// </summary>
    public enum ParamType
    {
        /// <summary>
        /// use .NET framework types for generated function parameter.
        /// </summary>
        ClrType,
        /// <summary>
        /// use SqlTypes for generated function parameter.
        /// </summary>
        SqlDbType
    }
    /// <summary>
    /// class SpilCodeGenerator.
    /// o  Consists of functions to generate "code" for supplied SPIL files.
    /// Consists of purely static methods - no per-instance state is present.
    /// </summary>
    public class SpilCodeGenerator
    {
        /// <summary>
        /// Stores the class name to class method declaration type mapping
        /// </summary>
        private Hashtable classNameMap = new Hashtable();

        /// <summary>
        /// Private default constructor.
        /// </summary>
        private SpilCodeGenerator()
        {
        }


        /// <summary>
        /// This function generates the code for supplied SPIL file which is written
        ///     using the supplied TextWriter.
        /// </summary>
        /// <remarks>
        /// The function uses XSL Transforms to spit out high-level code. Provided
        /// the input document confirms to the SPIL schema and transform, valid
        /// code is generated. Generated code should be linked with SpilRun.dll and 
        /// use the objects from Microsoft.Subscriptions.Data (SPIL support functions)
        /// in order to call on the stored procedures.
        /// NOTE: It only generates code for C# right now.
        /// </remarks>
        /// <param name="ial">logger - enables this routine to log messages directly</param>
        /// <param name="inputSpilReader">text reader to fetch input contents</param>
        /// <param name="textWriterForOutputCode">TextWriter object in which generated code is written to</param>
        /// <param name="paramType">specifies whether to generate SqlDbType or Framework runtime Type for parameters.</param>
        /// <returns>On success returns true. Otherwise a failure. 
        /// Exceptions are thrown if there are failures.</returns>
        static private bool GenerateCodeForSpilFile( IAuditLog ial, TextReader inputSpilReader, TextWriter textWriterForOutputCode, ParamType paramType) 
        {

            XsltArgumentList xal = new XsltArgumentList();
            if( paramType == ParamType.ClrType)
                xal.AddParam( "paramType", "", "CLRType");
            return XformSpilToCode( ial, 
                SpilConstants.SpilToCSharpTransform, 
                xal, 
                inputSpilReader, 
                textWriterForOutputCode);
        }


        /// <summary>
        /// This function generates the code for supplied SPIL file which is written
        ///     using the supplied TextWriter.
        /// </summary>
        /// <remarks>
        /// The function uses CODEDOM to spit out high-level code. Provided
        /// the input document confirms to the SPIL schema and transform, valid
        /// code is generated. Generated code should be linked with SpilRun.dll and 
        /// use the objects from Microsoft.Subscriptions.Data (SPIL support functions)
        /// in order to call on the stored procedures.
        /// NOTE: It only generates code for C# right now.
        /// </remarks>
        /// <param name="ial">logger - enables this routine to log messages directly</param>
        /// <param name="inputSpilFile">input file containing the SPIL document.
        /// It specifies the configuration of ProcedureGroup and set of stored procedures
        /// for which we need high level code stub.</param>
        /// <param name="defaultOutputFileName">default output file name. If stored procedure is not annotated
        /// with [FileName] attribute, this file name is used.</param>
        /// <param name="paramType">specifies whether to generate SqlDbType or Framework runtime Type for parameters. </param>
        /// <param name="generateAllProcedures">if true, will generate methods for all stored procedures. if false, only generate methods
        /// for stored procedures annotated with [SqlMethod]</param>
        /// <returns>On success returns true. Otherwise a failure. 
        /// Exceptions are thrown if there are failures.</returns>
        static public bool GenerateCodeForSpilFile( IAuditLog ial, string inputSpilFile, string defaultOutputFileName, ParamType paramType, bool generateAllProcedures) 
        {
            /*
            ial.SendToLog( LogEventLevel.Verbose, "Loading input document: " + inputSpilFile);
            TextReader inputReader = new StreamReader( inputSpilFile);
            return GenerateCodeForSpilFile( ial, inputReader, textWriterForOutputCode, paramType);
            */
            Hashtable ccus = BuildCodeDom(ial, inputSpilFile, defaultOutputFileName, generateAllProcedures);
            // ignore if we cannot build code dom
            // this might happen if there's no stored procedure that's generated
            // from sql.
            if (ccus != null && ccus.Count > 0)
            {
                foreach(string outputFile in ccus.Keys)
                {
                    CodeCompileUnit ccu = (CodeCompileUnit)ccus[outputFile];
                    string outputFileName = outputFile;
                    if (generateAllProcedures)
                    {
                        outputFileName = outputFile + "_all";
                    }
                    GenerateCSharpCode(ial, inputSpilFile, outputFileName, ccu);
                }
            }
            return true;
        }

        /// <summary>
        /// Internal helper function to perform the required transformations 
        /// for input SPIL document using the XSL file stored in the 
        /// assembly manifest as a resource. It uses the supplied XsltArugmentsList
        /// to configure the transformation appropriately.
        /// 
        /// Transformed results are written to the supplied output stream.
        /// </summary>
        /// <param name="ial"></param>
        /// <param name="spilToCodeXSLResource"></param>
        /// <param name="xsltArguments"></param>
        /// <param name="inputSpilReader"></param>
        /// <param name="textWriterForOutputCode"></param>
        /// <returns></returns>
        static private bool XformSpilToCode( IAuditLog ial, string spilToCodeXSLResource, XsltArgumentList xsltArguments, TextReader inputSpilReader, TextWriter textWriterForOutputCode) 
        {
            
            XmlDocument doc = new XmlDocument();
            doc.Load( inputSpilReader);
        
            ial.SendToLog( LogEventLevel.Verbose, 
                "Fetching resource contents for: " + spilToCodeXSLResource);

            Stream transformXsl = Assembly.GetExecutingAssembly().GetManifestResourceStream( spilToCodeXSLResource);

            if ( transformXsl == null) 
            {
                throw new SpilCodeGenerationException( "Fetch of the resource failed: " + spilToCodeXSLResource);
            }

            ial.SendToLog( null, LogEventLevel.Verbose,
                "Fetching resource contents for: " + spilToCodeXSLResource + 
                " Length= " + transformXsl.Length);

            // TODO: Load the transform stream and cache it for repeated use
            XslTransform transform = new XslTransform();
            
            //.NET 1.1 
            transform.Load( new XmlTextReader( transformXsl), null, Assembly.GetCallingAssembly().Evidence);
            transform.Transform( doc, xsltArguments, textWriterForOutputCode , null);

			//.NET 1.0
			//transform.Load( new XmlTextReader( transformXsl));
			//transform.Transform( doc, xsltArguments, textWriterForOutputCode );

            return true;
        } // XformSpilToCode()
    
        
        /// <summary>
        /// Gets the procedure group object from the xml file.
        /// </summary>
        /// <param name="fileName">The xml file</param>
        /// <returns>The deserialized procedure group object</returns>
        protected static ProcedureGroup GetProcedureGroup(string fileName)
        {
            XmlSerializer serializer = new XmlSerializer( typeof(ProcedureGroup));

            Stream reader= new FileStream(fileName, FileMode.Open, FileAccess.Read);
            object oRet = serializer.Deserialize( reader);
            reader.Close();

            return (ProcedureGroup)oRet;
        }

        /// <summary>
        /// Generates C# code from the CodeCom compile unit. Writes the output into the
        /// textWriter.
        /// </summary>
        /// <param name="ial">The audit log object</param>
        /// <param name="ccu">The CodeCom compile unit</param>
        /// <param name="inputFileName">the name of the input file</param>
        /// <param name="outputFileName">the name of the output file</param>
        public static void GenerateCSharpCode(IAuditLog ial, string inputFileName, string outputFileName, CodeCompileUnit ccu)
        {
            ial.SendToLog(LogEventLevel.Verbose, "Generating C# code from code compile unit to file");
            // Generate code
            // Obtains an ICodeGenerator from a CodeDomProvider class.
            CSharpCodeProvider provider = new CSharpCodeProvider();
            ICodeGenerator gen = provider.CreateGenerator();
   
            // Assembly generator options
            CodeGeneratorOptions cgo = new CodeGeneratorOptions();
            cgo.BlankLinesBetweenMembers = true;
            // Generate source code using the code generator
            TextWriter twOutput = null;
            try 
            {
                twOutput = new StreamWriter( outputFileName + ".cs");
                twOutput.WriteLine( "//  \t Autogenerated by Spiller from :  {0}", inputFileName);
                twOutput.WriteLine( "//  \t DateTime: {0}", DateTime.Now);
                
                gen.GenerateCodeFromCompileUnit(ccu, twOutput, cgo);
            }
            catch (Exception e) 
            {
                ial.SendToLog( LogEventLevel.Fatal, 
                    "Failed to produce code for input SPIL file : " + e.Message + "\r\n" + e.StackTrace);
            }
            finally
            {
                if(twOutput != null)
                    twOutput.Close();
            }
            
            ial.SendToLog(LogEventLevel.Verbose, "C# code generation complete");
        }
        
        
        /// <summary>
        /// Build CodeDom from SPIL XML representation.
        /// </summary>
        /// <param name="ial">IAuditLog object to log events</param>
        /// <param name="inputSpilFile">input SPIL file path</param>
        /// <param name="outputFileName">output file name.</param>
        /// <param name="generateAllProcedures">if true, generate methods for all stored procedures. if false, only generate for
        /// stored procedures with [SqlMethod] method</param>
        /// <remarks></remarks>
        /// <returns>Hashtable of filename and <see cref="CodeCompileUnit"/> corresponding to each file</returns>
        public static Hashtable BuildCodeDom(IAuditLog ial, string inputSpilFile, string outputFileName, bool generateAllProcedures)
        {
            // hashtable to store file name mapping
            Hashtable fileNameMap = new Hashtable();
            // Load SPIL file into a procedure group object
            ProcedureGroup procGroup = GetProcedureGroup(inputSpilFile);
            // if we cannot load from the file, throw exception
            if( procGroup == null)
                throw new SpilCodeGenerationException("Failed to load procedure group");

            if( procGroup.procedure.Length == 0)
            {
                // no SqlMethod defined
                return fileNameMap; // just return empty hashtable
            }

            // sort and store the procedure group according to the class
            foreach(ProcedureDefinition procDefinition in procGroup.procedure)
            {
                if (generateAllProcedures || procDefinition.sqlmethod)
                {
                    CodeNamespace cns;
                    #region Create the compile unit for the file
                    // Add the type to Compile unit
                    CodeCompileUnit ccu;
                    string fileName;
                    if (procDefinition.filename != null && procDefinition.filename.Length > 0)
                    {
                        // trim the .cs if there is any
                        fileName = procDefinition.filename.ToLower();
                    }
                    else
                    {
                        // use default name
                        fileName = outputFileName;
                    }
                    if (fileName.EndsWith(".cs"))
                    {   
                        fileName = fileName.Substring(0, fileName.Length - 3);
                    }
                    // insert into map
                    if (!fileNameMap.Contains(fileName))
                    {
                        // create new ccu
                        ccu = new CodeCompileUnit();
                        fileNameMap.Add(fileName, ccu);
                    }
                    else
                    {
                        ccu = (CodeCompileUnit)fileNameMap[fileName];
                    }

                    if(ccu.Namespaces == null || ccu.Namespaces.Count == 0)
                    {
                        // Generate namespace if specified. 
                        // Generated code: namespace {mynamespace}
                        // If no namespace is specified, no namespace statement is generated
                        cns = new CodeNamespace();
                        if(procGroup.binding != null && procGroup.binding.@namespace != null)
                        {
                            cns.Name = procGroup.binding.@namespace;
                        }

                        // Generate using statements
                        // using System;
                        // using System.Data;
                        // using System.Data.SqlClient;
                        // using System.Data.SqlTypes;
                        // using System.Collections;
                        // using Microsoft.Subscriptions.Data;
                        cns.Imports.Add( new CodeNamespaceImport("System"));
                        cns.Imports.Add( new CodeNamespaceImport("System.Data"));
                        cns.Imports.Add( new CodeNamespaceImport("System.Data.SqlClient"));
                        cns.Imports.Add( new CodeNamespaceImport("System.Data.SqlTypes"));
                        cns.Imports.Add( new CodeNamespaceImport("System.Collections"));
                        cns.Imports.Add( new CodeNamespaceImport("Microsoft.Subscriptions.Data"));

                        // Generate user specified using statements
                        foreach(string s in procGroup.binding.usingNamespace)
                        {
                            cns.Imports.Add( new CodeNamespaceImport(s));
                        }
                        ccu.Namespaces.Add(cns);
                    }
                    else
                    {
                        cns = ccu.Namespaces[0];
                    }
                    #endregion

                    CodeTypeDeclaration ctd = null;
                    // if the namespace doesn't contain the class
                    // create a new CodeTypeDeclaration with the name.
                    foreach(CodeTypeDeclaration tempCtd in cns.Types)
                    {
                        if (tempCtd.Name == procDefinition.@class)
                        {
                            ctd = tempCtd;
                        }
                    }

                    if( ctd == null)
                    {
                        // create a new class declaration
                        ctd = new CodeTypeDeclaration(procDefinition.@class);
                        string[] comments = new string[]{
                                                            "<summary>",
                                                            "Class generated by Spil for DataStore access",
                                                            "</summary>"
                                                        };
                        ctd.Comments.AddRange(BuildComments(comments,true));
                        ctd.IsClass = true;
                        ctd.Name = CapitalizeFirstLetter(procDefinition.@class);
                        ctd.TypeAttributes = TypeAttributes.Public; //public class

                        // implement the IDataStore interface
                        ctd.BaseTypes.Add("IDataStore");
                        // Generate class constructor and common fields and properties
                        BuildClassBindings(ctd, procGroup.binding);
                        // add to namespace
                        cns.Types.Add(ctd);
                    }
                    
                    // Generate class method corresponding to the procedure definition 
                    BuildClassMember(ctd, procDefinition, procGroup.binding);   
                }
            }
            // return code compile unit
            ial.SendToLog(LogEventLevel.Verbose, "code compile unit created successfully");
            return fileNameMap;
        }

        /// <summary>
        /// Build a class default public constructor, common fields and properties
        /// </summary>
        /// <param name="ctd">The class type declaration in the CodeDom</param>
        /// <param name="procBinding">The procedure bindings in SPIL</param>
        protected static void BuildClassBindings(CodeTypeDeclaration ctd
            , ProcedureGroupBinding procBinding
            )
        {
            // Generate class default constructor
            CodeConstructor ccon = new CodeConstructor();
            ccon.Attributes = MemberAttributes.Public; // public constructor
            ctd.Members.Add(ccon);
            
            // Generate constructor comments
            string[] comments = new string[]{
                                                "<summary>",
                                                String.Format(@"Creates a new instance for the specified class {0}", ctd.Name),
                                                "The storeName may be the logical database name or the logical webstore application name",
                                                "The connectionString should not have the server name or catalog specified",  
                                                "i.e,",
                                                " \"data source=ServerName\"    and",
                                                " \"Initial Catalog=storeName\"",
                                                "should not be present",
                                                "An example for valid connection string is:",
                                                "Integrated Security=SSPI;persist security info=False",
                                                "</summary>"
                                            };
            CodeCommentStatementCollection ccsc = BuildComments(comments, true);
            ccon.Comments.AddRange(ccsc);

            // Generate class member fields
            // private storeName = {procBinding.storeName}
            if (procBinding.storeName == null || procBinding.storeName.Length == 0)
            {
                throw new SpilCodeGenerationException("storeName cannot be empty");
            }
            CodeMemberField cmf = new CodeMemberField(typeof(string), "storeName");
            cmf.Attributes = MemberAttributes.Private;
            cmf.InitExpression = new CodePrimitiveExpression(procBinding.storeName);
            ctd.Members.Add(cmf);

            // Generate class member fields
            // private connectionString = {procBinding.connectionString}
            if(procBinding.connectionString == null || procBinding.connectionString.Length == 0)
            {
                throw new SpilCodeGenerationException("Connection string cannot be empty");
            }
            cmf = new CodeMemberField(typeof(string), "connectionString");
            cmf.Attributes = MemberAttributes.Private;
            cmf.InitExpression = new CodePrimitiveExpression(procBinding.connectionString);
            ctd.Members.Add(cmf);

            cmf = new CodeMemberField("DataStoreContext", "dataStoreContext");
            cmf.Attributes = MemberAttributes.Private;
            cmf.CustomAttributes.Add(new CodeAttributeDeclaration("ThreadStatic"));
            ctd.Members.Add(cmf);

            // Generate class property: StoreName
            comments = new string[]{
                                       "<summary>",
                                       "The name of the DataStore",
                                       "</summary>"
                                   };
            CodeMemberProperty cmp = new CodeMemberProperty();
            cmp.Comments.AddRange(BuildComments(comments, true));
            cmp.Attributes = MemberAttributes.Public;
            cmp.Type = new CodeTypeReference(typeof(string));
            cmp.Name = "StoreName";
            cmp.HasGet = true;
            cmp.HasSet = true;
			
            cmp.GetStatements.Add(new CodeMethodReturnStatement(
                new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "storeName")));
            cmp.SetStatements.Add(new CodeAssignStatement( new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "storeName"), 
                new CodePropertySetValueReferenceExpression() ) );
            ctd.Members.Add(cmp);

            // Generate class property: ConnectionString
            comments = new string[]{
                                       "<summary>",
                                       "The connection string used to connect to the DataStore",
                                       "</summary>"
                                   };
            cmp = new CodeMemberProperty();
            cmp.Comments.AddRange(BuildComments(comments, true));
            cmp.Attributes = MemberAttributes.Public;
            cmp.Type = new CodeTypeReference(typeof(string));
            cmp.Name = "ConnectionString";
            cmp.HasGet = true;
            cmp.HasSet = true; // NOTE: Custom Xonline change. In original version, this property was only readable (cmp.HasSet = false).
            cmp.GetStatements.Add(new CodeMethodReturnStatement(
                new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "connectionString")));
            // NOTE: Next 2 lines are a custom Xonline change also. The original version did not have them.
            cmp.SetStatements.Add(new CodeAssignStatement( new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "connectionString"), 
                new CodePropertySetValueReferenceExpression() ) );
            ctd.Members.Add(cmp);

            // Generate class property: DataStoreContext
            comments = new string[]{
                                       "<summary>",
                                       "The <see cref=\"Microsoft.Subscriptions.Data.DataStoreContext\"/> for the data store",
                                       "</summary>"
                                   };
            cmp = new CodeMemberProperty();
            cmp.Comments.AddRange(BuildComments(comments, true));
            cmp.Attributes = MemberAttributes.Public;
            cmp.Type = new CodeTypeReference("DataStoreContext");
            cmp.Name = "Context";
            cmp.HasGet = true;
            cmp.HasSet = false; // only readable.
            // initialize the context if it hasn't existed yet
            // if (this.dataStoreContext == null)
            //      this.dataStoreContext = new DataStoreContext();
            cmp.GetStatements.Add(new CodeConditionStatement(new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression("dataStoreContext"),
                CodeBinaryOperatorType.IdentityEquality, new CodePrimitiveExpression(null)),
                new CodeAssignStatement(new CodeVariableReferenceExpression("dataStoreContext"), 
                new CodeObjectCreateExpression("DataStoreContext"))));
            cmp.GetStatements.Add(new CodeMethodReturnStatement(
                new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "dataStoreContext")));
            ctd.Members.Add(cmp);
        }


        /// <summary>
        /// Build class methods from SPIL bindings. Each stored procedure correspond
        /// to a class
        /// </summary>
        /// <param name="ctd">The class type declaration in CodeDom</param>
        /// <param name="procDefinition">The procedure definition in SPIL</param>
        /// <param name="procBinding">The procedure bindings in SPIL</param>
        protected static void BuildClassMember(CodeTypeDeclaration ctd
            , ProcedureDefinition procDefinition
            , ProcedureGroupBinding procBinding
            )
        {
            // get stored procedure name
            if (procDefinition.name == null || procDefinition.name.Length == 0)
            {
                throw new SpilCodeGenerationException("Procedure name cannot be empty.");
            }
            string procName = procDefinition.name;

            #region Generate Method Signature
            // Generate member method
            CodeMemberMethod cmm = new CodeMemberMethod();
            cmm.Name = procName;
            cmm.Attributes = MemberAttributes.Public; //public method
                        
            // Generate return type for the method
            // If calltype is on all partitions, returns an array of ProcedureResults
            // Otherwise, return ProcedureResults
            if ( procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
            {
                if ( procDefinition.attribute.returnType == ProcedureReturnType.ProcedureResults)
                {
                    cmm.ReturnType = new CodeTypeReference("ProcedureResults[]"); //TODO: more generic way to declare array?
                }
                else if ( procDefinition.attribute.returnType == ProcedureReturnType.NonQuery)
                {
                    cmm.ReturnType = new CodeTypeReference(typeof(int[])); //TODO: more generic way to declare array?
                }
                else if ( procDefinition.attribute.returnType == ProcedureReturnType.Scalar)
                {
                    cmm.ReturnType = new CodeTypeReference(typeof(object[])); //TODO: more generic way to declare array?
                }
                else
                {
                    throw new NotImplementedException("IDataReader return type is not supported for CallOnAllPartitions.");
                    // cmm.ReturnType = new CodeTypeReference("IDataReader"); //TODO: this is not supported now
                }
            }
            else
            {
                if ( procDefinition.attribute.returnType == ProcedureReturnType.ProcedureResults)
                {
                    cmm.ReturnType = new CodeTypeReference("ProcedureResults"); 
                }
                else if ( procDefinition.attribute.returnType == ProcedureReturnType.NonQuery)
                {
                    cmm.ReturnType = new CodeTypeReference(typeof(int)); //TODO: more generic way to declare array?
                }
                else if ( procDefinition.attribute.returnType == ProcedureReturnType.Scalar)
                {
                    cmm.ReturnType = new CodeTypeReference(typeof(object)); 
                }
                else
                {
                    cmm.ReturnType = new CodeTypeReference("IDataReader"); 
                }
                                
            }
                
            // build method comments
            StringCollection methodComments = new StringCollection();
            methodComments.Add("<summary>");
            if ( procDefinition.summary == null || procDefinition.summary.Length == 0)
            {
                StringBuilder sb = new StringBuilder(); 
                sb.Append("Execute stored procedure ").Append(procName);
                if ( procDefinition.attribute.callType == ProcedureCallType.CallOnAnyPartition)
                {
                    sb.Append(" on any partition");
                }
                else if ( procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    sb.Append(" on all partitions");
                }
                else if ( procDefinition.attribute.callType == ProcedureCallType.CallOnPartitionHash)
                {
                    sb.Append(" on key-hashed logical parition");
                }
                else if ( procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
                {
                    sb.Append(" on physical partition");
                }
                methodComments.Add(sb.ToString());
            }
            else
            {
                foreach(string s in procDefinition.summary.Split(Environment.NewLine.ToCharArray()))
                {
                    methodComments.Add(s);
                }
            }
            methodComments.Add("</summary>");

            methodComments.Add("<param name=\"scm\">Connection Manager</param>");
            if ( procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
            {
                methodComments.Add("<param name=\"physicalInstanceKey\">Physical Instance Key</param>");
            }
            if(procDefinition.param != null)
            {
                foreach(ParameterDefinition param in procDefinition.param)
                {
                    string paramDescription = param.spname;
                    if (param.description != null)
                    {
                        paramDescription = param.description;
                    }
                    methodComments.Add(String.Format(
                        "<param name=\"{0}\">{1}</param>", param.spname, paramDescription));
                }
            }
            
            string[] methodCommentsArray = new String[methodComments.Count];
            methodComments.CopyTo(methodCommentsArray, 0);
            cmm.Comments.AddRange(BuildComments(
                methodCommentsArray,true));
            #endregion

            #region Generate Parameters
            // Generate parameters declaration for the method
            // 1st parameter: ISpilConnectionManager scm 
            // if callOnPhysicalInstance, add additional parameter object physicalInstanceKey
            cmm.Parameters.Add(new CodeParameterDeclarationExpression("ISpilConnectionManager", "scm"));
            if ( procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
            {
                cmm.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "physicalInstanceKey"));
            }
            // add stored procedure parameters
            if(procDefinition.param != null)
            {
                // add parameter for each stored procedure parameter
                foreach(ParameterDefinition param in procDefinition.param)
                {
                    CodeParameterDeclarationExpression cpde = new CodeParameterDeclarationExpression();
                    // Only use SqlType for generated parameter
                    string frameworkSqlType;
                    frameworkSqlType = FindFrameworkSqlType(param.type); 
                    // Manually change SqlString type to string type.
                    if(frameworkSqlType == "SqlString")
                        cpde.Type = new CodeTypeReference(typeof(string));
                    else
                        cpde.Type = new CodeTypeReference(frameworkSqlType);
                    cpde.Name = param.spname;
                
                    // currently treat both out and ref as ref.
                    if(param.direction == SpilParameterDirection.Output ||
                        param.direction == SpilParameterDirection.InputOutput)
                    {
                        cpde.Direction = FieldDirection.Ref;    
                    }
                    cmm.Parameters.Add(cpde);
                }
            }
            #endregion

            #region Generate Method Implementation
            // Generate method contents
            // Create an initialization expression for a new array of type SqlParameter with correct number of indices
            int numParams = 0;
            if(procDefinition.param != null)
                numParams = procDefinition.param.Length;
            CodeArrayCreateExpression ca1 = new CodeArrayCreateExpression("SqlParameter", numParams);                  
            // Declare an array of type SqlParameter, using the CodeArrayCreateExpression ca1 as the initialization expression
            // SqlParameter[] callParameters = new SqlParameter[{procDefinition.param.Length}];
            CodeVariableDeclarationStatement cv1 = new CodeVariableDeclarationStatement(
                "SqlParameter[]"
                , "callParameters"
                // initial expression SqlParameter[length];
                , ca1);
            cmm.Statements.Add(cv1);

            // Assemble callParameters collection
            cmm.Statements.Add(new CodeCommentStatement("pack all parameters into Sql parameters array"));
            
            #region assemble callParameters collection
            for(int i = 0; i < numParams; i ++)
            {
                ParameterDefinition paramDef = procDefinition.param[i];
                // callParameters[i]
                CodeArrayIndexerExpression caie = new CodeArrayIndexerExpression(
                    new CodeVariableReferenceExpression("callParameters"),
                    new CodePrimitiveExpression(i)
                    );
                // callParameters[i] = new SqlParameter();
                CodeAssignStatement as1 = new CodeAssignStatement(
                    // left hand side: callParameters[i]
                    caie,
                    // right hand side: new sqlParameter()
                    new CodeObjectCreateExpression("SqlParameter", new CodeExpression[]{})
                    );
                // add statements to method
                cmm.Statements.Add(as1);

                // callParameters[i].ParameterName = "@sp_name"
                CodeAssignStatement as2 = new CodeAssignStatement(
                    // left hand side: callParameters[i].ParameterName
                    new CodePropertyReferenceExpression(caie,"ParameterName"),
                    // right hand side: @sp_name
                    new CodePrimitiveExpression("@" + paramDef.spname)
                    );
                // add statements to method
                cmm.Statements.Add(as2);
                
                // callParameters[i].IsNullable = true;
                CodeAssignStatement as3 = new CodeAssignStatement(
                    // left hand side
                    new CodePropertyReferenceExpression(caie,"IsNullable"),
                    // right hand side
                    new CodePrimitiveExpression(true)
                    );
                // add statements to method
                cmm.Statements.Add(as3);

                // callParameters[i].SqlDbType = SqlDbType.[Type]
                CodeAssignStatement as4 = new CodeAssignStatement(
                    // left hand side
                    new CodePropertyReferenceExpression(caie,"SqlDbType"),
                    // right hand side
                    new CodeTypeReferenceExpression(FindSqlType(paramDef.type))
                    );
                // add statements to method
                cmm.Statements.Add(as4);

                // callParameters[i].Direction = ParameterDirection.Input
                CodeAssignStatement as5 = new CodeAssignStatement(
                    // left hand side
                    new CodePropertyReferenceExpression(caie,"Direction"),
                    // right hand side
                    new CodeTypeReferenceExpression(FindSqlParamDirection(paramDef.direction))
                    );
                // add statements to method
                cmm.Statements.Add(as5);

                // callParameters[i].Size = size
                if(paramDef.size != null)
                {
                    CodeAssignStatement as7 = new CodeAssignStatement(
                        // left hand side
                        new CodePropertyReferenceExpression(caie,"Size"),
                        // right hand side
                        new CodeTypeReferenceExpression(paramDef.size)
                        );
                    // add statements to method
                    cmm.Statements.Add(as7);
                }

                // callParameters[i].Value = sp_name(parameter)
				
                // if parameter is string, transform it to SqlString.Null
                // if necessary
                // if parameter is SqlDecimal, transform it to 
                // if (sp_name == SqlDecimal.Null)
                //      callParameters[i].Value = DBNull.Value;
                // else
                //      callparameters[i].Value = sp_name;
                // if 
                if (FindFrameworkSqlType(paramDef.type) == "SqlString")
                {
                    CodeConditionStatement ccs = new CodeConditionStatement();
                    ccs.Condition = new CodeBinaryOperatorExpression(
                        new CodeArgumentReferenceExpression(paramDef.spname),
                        CodeBinaryOperatorType.IdentityEquality,
                        new CodePrimitiveExpression(null));
                    ccs.TrueStatements.Add(new CodeAssignStatement(
                        // left hand side
                        new CodePropertyReferenceExpression(
                        new CodeArrayIndexerExpression(
                        new CodeVariableReferenceExpression("callParameters"),
                        new CodePrimitiveExpression(i)
                        ), "Value"), //callParametrs[i].Value
                        // right hand side
                        new CodePropertyReferenceExpression(
                        new CodeTypeReferenceExpression("SqlString"),
                        "Null"))); //SqlString.Null
                    ccs.FalseStatements.Add(new CodeAssignStatement(
                        new CodePropertyReferenceExpression(
                        new CodeArrayIndexerExpression(
                        new CodeVariableReferenceExpression("callParameters"),
                        new CodePrimitiveExpression(i)
                        ), "Value"), //callParametrs[i].Value
                        // right hand side
                        new CodeCastExpression(typeof(SqlString),
                        new CodeArgumentReferenceExpression(paramDef.spname)))); // param
                    cmm.Statements.Add(ccs);     
                }
                else if (FindFrameworkSqlType(paramDef.type) == "Object")
                {
                    // Note: This is to apply a null value to sql_variant
                    //
                    // if(param == null)
                    //   callParameters[i].Value = DBNull.Value
                    // else
                    //   callParameters[i].Value = param
                    CodeConditionStatement ccs = new CodeConditionStatement();
                    ccs.Condition = new CodeBinaryOperatorExpression(
                        new CodeArgumentReferenceExpression(paramDef.spname),
                        CodeBinaryOperatorType.IdentityEquality,
                        new CodePrimitiveExpression(null));
                    ccs.TrueStatements.Add(new CodeAssignStatement(
                        // left hand side
                        new CodePropertyReferenceExpression(
                        new CodeArrayIndexerExpression(
                        new CodeVariableReferenceExpression("callParameters"),
                        new CodePrimitiveExpression(i)
                        ), "Value"), //callParametrs[i].Value
                        // right hand side
                        new CodePropertyReferenceExpression(
                        new CodeTypeReferenceExpression("DBNull"),
                        "Value"))); //DBNull.Value
                    ccs.FalseStatements.Add(new CodeAssignStatement(
                        new CodePropertyReferenceExpression(
                        new CodeArrayIndexerExpression(
                        new CodeVariableReferenceExpression("callParameters"),
                        new CodePrimitiveExpression(i)
                        ), "Value"), //callParametrs[i].Value
                        // right hand side
                        new CodeArgumentReferenceExpression(paramDef.spname))); // param
                    cmm.Statements.Add(ccs);   
                }
                else if (FindFrameworkSqlType(paramDef.type) == "SqlDecimal")
                {
                    // Note: This is to get around an ADO.NET Bug
                    // where SqlDecimal.Null causes InvalidCastException
                    // if (param.IsNull)
                    //     callParameters[i].Value = DBNull.Value
                    // else
                    //     callParameters[i].Value = param.Value;
                    CodeConditionStatement ccs = new CodeConditionStatement();
                    ccs.Condition = new CodePropertyReferenceExpression(
                        new CodeArgumentReferenceExpression(paramDef.spname),
                        "IsNull");
                    ccs.TrueStatements.Add(new CodeAssignStatement(
                        // left hand side
                        new CodePropertyReferenceExpression(
                        new CodeArrayIndexerExpression(
                        new CodeVariableReferenceExpression("callParameters"),
                        new CodePrimitiveExpression(i)
                        ), "Value"), //callParametrs[i].Value
                        // right hand side
                        new CodePropertyReferenceExpression(
                        new CodeTypeReferenceExpression("DBNull"),
                        "Value"))); //DBNull.Value
                    ccs.FalseStatements.Add(new CodeAssignStatement(
                        new CodePropertyReferenceExpression(
                        new CodeArrayIndexerExpression(
                        new CodeVariableReferenceExpression("callParameters"),
                        new CodePrimitiveExpression(i)
                        ), "Value"), //callParametrs[i].Value
                        // right hand side
                        new CodePropertyReferenceExpression(
                        new CodeArgumentReferenceExpression(paramDef.spname),
                        "Value"))); // param.Value
                    cmm.Statements.Add(ccs);   
                }
                else
                {
                    CodeAssignStatement as6 = new CodeAssignStatement(
                        // left hand side
                        new CodePropertyReferenceExpression(caie,"Value"),
                        // right hand side
                        new CodeArgumentReferenceExpression(paramDef.spname)
                        );
                    // add statements to method
                    cmm.Statements.Add(as6);
                }
            }
            #endregion

            // declare variable: results
            // because CODEDOM will translate string literal type "int" to "@int".
            // we have to duplicate some code here to get around this problem.
            if ( procDefinition.attribute.returnType == ProcedureReturnType.IDataReader)
            {
                cmm.Statements.Add(new CodeVariableDeclarationStatement(
                    "IDataReader"
                    ,"results"));
            }
            else if ( procDefinition.attribute.returnType == ProcedureReturnType.NonQuery)
            {
                if ( procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    cmm.Statements.Add(new CodeVariableDeclarationStatement(
                        typeof(int[])
                        ,"results"));
                }
                else
                {
                    cmm.Statements.Add(new CodeVariableDeclarationStatement(
                        typeof(int)
                        ,"results"));
                }
            }
            else if ( procDefinition.attribute.returnType == ProcedureReturnType.Scalar)
            {
                if ( procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    cmm.Statements.Add(new CodeVariableDeclarationStatement(
                        typeof(object[])
                        ,"results"));
                }
                else
                {
                    cmm.Statements.Add(new CodeVariableDeclarationStatement(
                        typeof(object)
                        ,"results"));
                }
            }
            else // return ProcedureResults results or ProcedureResults[] results;
            {
                if ( procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    cmm.Statements.Add(new CodeVariableDeclarationStatement(
                        "ProcedureResults[]"
                        ,"results"));
                }
                else
                {
                    cmm.Statements.Add(new CodeVariableDeclarationStatement(
                        "ProcedureResults"
                        ,"results"));
                }
            }
           
            // Assemble try/catch block
            // try {
            //    ...
            // } finally {
            //    ...
            // }
            CodeTryCatchFinallyStatement try1 = new CodeTryCatchFinallyStatement();
            cmm.Statements.Add(try1);

            // Assemble parameter reference collection for execution
            CodeExpressionCollection cec = new CodeExpressionCollection();
            cec.Add(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(),"Context"));
            cec.Add(new CodeArgumentReferenceExpression("scm"));
            cec.Add(new CodeArgumentReferenceExpression("this.StoreName"));
            cec.Add(new CodeArgumentReferenceExpression("this.ConnectionString"));
            if( procDefinition.attribute.callType == ProcedureCallType.CallOnAnyPartition)
            {
                cec.Add(new CodeArgumentReferenceExpression("DataStoreComponent.HashValueForAnyInstance"));
            }
            else if ( procDefinition.attribute.callType == ProcedureCallType.CallOnPartitionHash)
            {
                // add assign hash value
                try1.TryStatements.Add(new CodeVariableDeclarationStatement(
                    typeof(int)
                    ,"hashValue"));

                CodeExpression[] paramExpression = BuildHashParameters(procDefinition);
                try1.TryStatements.Add(new CodeAssignStatement(
                    // left
                    new CodeVariableReferenceExpression("hashValue"),
                    // right
                    new CodeMethodInvokeExpression(
                    // target object
                    null,
                    // method name
                    procDefinition.attribute.partitionBy.algorithm,
                    // parameters
                    paramExpression
                    )));

                cec.Add(new CodeArgumentReferenceExpression("hashValue"));
            }
            else if ( procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
            {
                cec.Add(new CodeArgumentReferenceExpression("physicalInstanceKey"));
            }
 
            cec.Add(new CodePrimitiveExpression(procDefinition.spname));
            cec.Add(new CodeArgumentReferenceExpression("callParameters"));
            // Add ExecuteStoredProcedure method invocation
            if( procDefinition.attribute.returnType == ProcedureReturnType.NonQuery)
            {
                if(  procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteNonQueryOnAllPartitions",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else if(  procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteNonQueryOnPhysicalInstance",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteNonQueryStoredProcedure",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
            }
            else if( procDefinition.attribute.returnType == ProcedureReturnType.Scalar)
            {
                if(  procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteScalarOnAllPartitions",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else if(  procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteScalarOnPhysicalInstance",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteScalarStoredProcedure",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
            }
            else if( procDefinition.attribute.returnType == ProcedureReturnType.IDataReader)
            {
                if(  procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    throw new NotImplementedException("IDataReader interface not supported on CallOnAllPartitions");
                }
                else if(  procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteReaderOnPhysicalInstance",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteReaderStoredProcedure",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
            }
            else // ExecuteProcedure returns ProcedureResults
            {
                if(  procDefinition.attribute.callType == ProcedureCallType.CallOnAllPartitions)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteProcedureOnAllPartitions",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else if(  procDefinition.attribute.callType == ProcedureCallType.CallOnPhysicalInstance)
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteOnPhysicalInstance",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
                else
                {
                    CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression(
                        // targetObject that contains the method to invoke.
                        new CodeTypeReferenceExpression("DataStoreComponent"),
                        // methodName indicates the method to invoke.
                        "ExecuteStoredProcedure",
                        // parameters array contains the parameters for the method.
                        CodeExpressionCollectionToArray(cec)
                        );
                    try1.TryStatements.Add(new CodeAssignStatement(
                        new CodeVariableReferenceExpression("results"),
                        cmie));
                }
            }
            //CodeCatchClause catch1 = new CodeCatchClause(, new CodeTypeReference("Exception"));
            /*
            CodeCatchClause catch1 = new CodeCatchClause();
            catch1.Statements.Add( new CodeCommentStatement("Rethrow exception") );
            catch1.Statements.Add( new CodeThrowExceptionStatement());
            try1.CatchClauses.Add( catch1 );
            */

            // Assign output parameters
            try1.FinallyStatements.Add(new CodeCommentStatement("assign output parameter values"));
            for(int i = 0; i < numParams; i ++)
            {
                ParameterDefinition param = procDefinition.param[i];
                if( param.direction == SpilParameterDirection.Output ||
                    param.direction == SpilParameterDirection.InputOutput)
                {
                    string runtimeType = FindRuntimeType(param.type);
                    // Add statements when the parameter is null
                    if( FindFrameworkSqlType(param.type) == "SqlString")
                    {
                        // Generate null value checking statement
                        CodeConditionStatement ccs = new CodeConditionStatement();
                        ccs.Condition = new CodePropertyReferenceExpression(
                            new CodeCastExpression(typeof(SqlString),
                            new CodePropertyReferenceExpression(
                            new CodeArrayIndexerExpression(
                            new CodeVariableReferenceExpression("callParameters"),
                            new CodePrimitiveExpression(i)
                            ), "Value")),
                            "IsNull");
                        // param = null
                        ccs.TrueStatements.Add(new CodeAssignStatement(
                            // left hand side 
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodePrimitiveExpression(null)));
                        // param = Convert.ToString(callParamters[i].Value))
                        ccs.FalseStatements.Add(new CodeAssignStatement(
                            // left hand side
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodeMethodInvokeExpression(
                            // targetObject that contains the method to invoke.
                            new CodeTypeReferenceExpression("Convert"),
                            // methodName indicates the method to invoke.
                            "ToString",
                            new CodeExpression[]{
                                                    new CodePropertyReferenceExpression(
                                                    new CodeArrayIndexerExpression(
                                                    new CodeVariableReferenceExpression("callParameters"),
                                                    new CodePrimitiveExpression(i)
                                                    ), "Value")})));
                        try1.FinallyStatements.Add(ccs);
                    }
                    else if( FindFrameworkSqlType(param.type) == "SqlDecimal")
                    {
                        // Generate null value checking statement
                        CodeConditionStatement ccs = new CodeConditionStatement();
                        ccs.Condition = new CodeMethodInvokeExpression(
                            // targetObject that contains the method to invoke.
                            new CodeTypeReferenceExpression("Convert"),
                            // methodName indicates the method to invoke.
                            "IsDBNull",
                            // parameters array contains the parameters for the method.
                            new CodeExpression[] { new CodePropertyReferenceExpression(
                                                     new CodeArrayIndexerExpression(
                                                     new CodeVariableReferenceExpression("callParameters"),
                                                     new CodePrimitiveExpression(i)
                                                     ), "Value") } );
                        // param = SqlDecimal.Null
                        ccs.TrueStatements.Add(new CodeAssignStatement(
                            // left hand side 
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodePropertyReferenceExpression(
                            new CodeTypeReferenceExpression(typeof(SqlDecimal)), "Null")));
                        // param = (SqlDecimal)(decimal)(callParamters[i].Value)
                        ccs.FalseStatements.Add(new CodeAssignStatement(
                            // left hand side
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodeCastExpression(
                            FindFrameworkSqlType(param.type),
                            new CodeCastExpression(
                            FindRuntimeType(param.type),
                            new CodePropertyReferenceExpression(
                            new CodeArrayIndexerExpression(
                            new CodeVariableReferenceExpression("callParameters"),
                            new CodePrimitiveExpression(i)
                            ), "Value")))));
                        try1.FinallyStatements.Add(ccs);
                    }
                    else if( FindFrameworkSqlType(param.type) == "Object")
                    {
                        // Generate null value checking statement
                        CodeConditionStatement ccs = new CodeConditionStatement();
                        ccs.Condition = new CodeMethodInvokeExpression(
                            // targetObject that contains the method to invoke.
                            new CodeTypeReferenceExpression("Convert"),
                            // methodName indicates the method to invoke.
                            "IsDBNull",
                            // parameters array contains the parameters for the method.
                            new CodeExpression[] { new CodePropertyReferenceExpression(
                                                     new CodeArrayIndexerExpression(
                                                     new CodeVariableReferenceExpression("callParameters"),
                                                     new CodePrimitiveExpression(i)
                                                     ), "Value") } );
                        // param = null
                        ccs.TrueStatements.Add(new CodeAssignStatement(
                            // left hand side 
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodePrimitiveExpression(null)));
                        // param = (object)(callParamters[i].Value)
                        ccs.FalseStatements.Add(new CodeAssignStatement(
                            // left hand side
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodeCastExpression(
                            FindFrameworkSqlType(param.type),
                            new CodePropertyReferenceExpression(
                            new CodeArrayIndexerExpression(
                            new CodeVariableReferenceExpression("callParameters"),
                            new CodePrimitiveExpression(i)
                            ), "Value"))));
                        try1.FinallyStatements.Add(ccs);
                    }
                    else
                    {
                        try1.FinallyStatements.Add(new CodeAssignStatement(
                            // left hand side
                            new CodeArgumentReferenceExpression(param.spname),
                            // right hand side
                            new CodeCastExpression(
                            FindFrameworkSqlType(param.type),
                            new CodePropertyReferenceExpression(
                            new CodeArrayIndexerExpression(
                            new CodeVariableReferenceExpression("callParameters"),
                            new CodePrimitiveExpression(i)
                            ), "Value"))));
                    }
                }
            }
            //cmm.Comments.Add(new CodeCommentStatement("assign output parameter values"));
            //cmm.Comments.Add(new CodeCommentStatement("return the procedure results"));
            
            // Add return statement
            cmm.Statements.Add(new CodeMethodReturnStatement(new CodeArgumentReferenceExpression("results")));
            // Add the method to class
            ctd.Members.Add(cmm);
            #endregion
        }


        #region Utility Functions
        static string CapitalizeFirstLetter( string name) 
        {
            string newName = Char.ToUpper( name[0]) + name.Substring(1);
            return newName;
        }

        static internal string FindRuntimeType( string type) 
        {
            string sqlRuntimeType = InternalFindType(type.ToLower());
            return sqlRuntimeType;
        }

        static internal string FindFrameworkSqlType( string type) 
        {
            string sqlRuntimeType = InternalFindFrameworkSqlType(type.ToLower());
            return sqlRuntimeType;
        }

        static string FindSqlType( string type) 
        {
            string sqlType = InternalFindSqlType(type.ToLower());
            return sqlType;
        }

        static string FindSqlParamDirection( SpilParameterDirection direction) 
        {

            switch ( direction ) 
            {
                case SpilParameterDirection.Input:
                    return "ParameterDirection.Input";
                case SpilParameterDirection.Output:
                    return "ParameterDirection.InputOutput";
                case SpilParameterDirection.InputOutput:
                    return "ParameterDirection.InputOutput";
                default:
                    return "ParameterDirection.Input";
            }
        }

        //Type mapping between SQL and .NET framework
        //see: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmappingnetdataproviderdatatypestonetframeworkdatatypes.asp
 
        static string InternalFindType( string sqlType) 
        {

            // TODO: Use a hash-array for this lookup table
            // TODO: Try to reuse code from ADO.NET for type conversions
            // TODO: Add additional types required
            string runtimeType = null;
            switch (sqlType) 
            {
                case "bigint":      // SqlDbType.BigInt
                    runtimeType = "Int64";
                    break;
        
                case "binary":      
                    runtimeType = "Byte[]";
                    break;

                case "bit":         // SqlDbType.Bit
                    runtimeType = "Boolean";
                    break;

                case "char":
                    runtimeType = "string";
                    break;
                  
                case "datetime":
                    runtimeType = "DateTime";
                    break;
        
                case "decimal":
                    runtimeType = "Decimal";
                    break;
                                                    
                case "float":
                    runtimeType = "double";
                    break;
            
                case "image":
                    runtimeType = "Byte[]";
                    break;
            
                case "int":         // SqlDbType.Int
                    runtimeType = "Int32";
                    break;
            
                case "money":
                    runtimeType = "Decimal";
                    break;
           
                case "nchar":
                    runtimeType = "string";
                    break;
            
                case "ntext":
                    runtimeType = "string";
                    break;      
        
                case "numeric":
                    runtimeType = "Decimal";
                    break;
            
                case "nvarchar":
                    runtimeType = "string";
                    break;
            
                case "real":
                    runtimeType = "Single";
                    break;

                case "rowversion":
                    runtimeType = "Byte[]";
                    break;

                case "smalldatetime":
                    runtimeType = "DateTime";
                    break;
          
                case "smallint":
                    runtimeType = "Int16";
                    break;
           
                case "smallmoney":
                    runtimeType = "Decimal";
                    break;
            
                case "sql_variant":
                    runtimeType = "Object";
                    break;
            
                case "text":
                    runtimeType = "string";
                    break;

                case "timestamp":
                    runtimeType = "Byte[]";
                    break;

                case "tinyint":
                    runtimeType = "Byte";
                    break;

                case "uniqueidentifier":
                    runtimeType = "Guid";
                    break;

                case "varbinary":
                    runtimeType = "byte[]";
                    break;

                case "varchar":
                    runtimeType = "string";
                    break;                        
                        
                default:
                    if ( sqlType.StartsWith( "varchar") || sqlType.StartsWith( "nvarchar")) 
                    {
                        runtimeType = "string";
                    }
                    else
                        throw new SpilCodeGenerationException( "Invalid Type. Unable to find suitable Runtime Type for " + sqlType);
                    break;
            }

            return runtimeType;
        } // InternalFindType()

        // Finds the relevant .Net Framework SqlTypes for specified type (in string)
        static string InternalFindFrameworkSqlType( string sqlType) 
        {
            string runtimeType = null;
            switch (sqlType) 
            {
                case "binary":
                    runtimeType = "SqlBinary";
                    break;
        
                case "bigint":
                    runtimeType = "SqlInt64";
                    break;
        
                case "bit":
                    runtimeType = "SqlBoolean";
                    break;

                case "char":
                    runtimeType = "SqlString";
                    break;
        
                case "datetime":
                    runtimeType = "SqlDateTime";
                    break;
            
                case "decimal":
                    runtimeType = "SqlDecimal";
                    break;
           
                case "float":
                    runtimeType = "SqlDouble";
                    break;
            
                case "image":
                    runtimeType = "SqlBinary";
                    break;
            
                case "int":
                    runtimeType = "SqlInt32";
                    break;
        
                case "money":
                    runtimeType = "SqlMoney";
                    break;
        
                case "nchar":
                    runtimeType = "SqlString";
                    break;
            
                case "ntext":
                    runtimeType = "SqlString";
                    break;
            
                case "nvarchar":
                    runtimeType = "SqlString";
                    break;
            
                case "numeric":
                    runtimeType = "SqlDecimal";
                    break;
        
                case "real":
                    runtimeType = "SqlSingle";
                    break;
           
                case "rowversion":
                    runtimeType = "SqlBinary";
                    break;
 
                case "smalldatetime":
                    runtimeType = "SqlDateTime";
                    break;
        
                case "smallint":
                    runtimeType = "SqlInt16";
                    break;
            
                case "smallmoney":
                    runtimeType = "SqlMoney";
                    break;
        
                case "sql_variant":
                    runtimeType = "Object";
                    break;
        
                case "sysname":
                    runtimeType = "SqlString";
                    break;
            
                case "text":
                    runtimeType = "SqlString";
                    break;
            
                case "timestamp":
                    runtimeType = "SqlBinary";
                    break;
        
                case "tinyint":
                    runtimeType = "SqlByte";
                    break;
            
                case "varbinary":
                    runtimeType = "SqlBinary";
                    break;
        
                case "varchar":
                    runtimeType = "SqlString";
                    break;
            
                case "uniqueidentifier":
                    runtimeType = "SqlGuid";
                    break;
        
                default:
                    if ( sqlType.StartsWith( "varchar")) 
                    {
                        runtimeType = "SqlString";
                    } 
                    else if ( sqlType.StartsWith( "nvarchar")) 
                    {
                        runtimeType = "SqlString";
                    }
                    else
                        throw new Exception( "Invalid Type. Unable to find suitable Runtime Type.");
                    break;      
            
            }
            return runtimeType;
        } //InternalFindFrameworkSqlType

        // Finds the relevant SqlType.* value for specified type (in string)
        static string InternalFindSqlType( string sqlType) 
        {

            // TODO: Use a hash-array for this lookup table
            // TODO: Try to reuse code from ADO.NET for type conversions
            // TODO: Add additional types required
            string runtimeType = null;
            switch (sqlType) 
            {
                case "bigint":      // SqlDbType.BigInt
                    runtimeType = "SqlDbType.BigInt";
                    break;
        
                case "binary":      
                    runtimeType = "SqlDbType.Binary";
                    break;

                case "bit":         // SqlDbType.Bit
                    runtimeType = "SqlDbType.Bit";
                    break;

                case "char":
                    runtimeType = "SqlDbType.Char";
                    break;
                  
                case "datetime":
                    runtimeType = "SqlDbType.DateTime";
                    break;
        
                case "decimal":
                    runtimeType = "SqlDbType.Decimal";
                    break;

                case "float":
                    runtimeType = "SqlDbType.Float";
                    break;
            
                case "image":
                    runtimeType = "SqlDbType.Image";
                    break;
            
                case "int":         // SqlDbType.Int
                    runtimeType = "SqlDbType.Int";
                    break;
            
                case "money":
                    runtimeType = "SqlDbType.Money";
                    break;
           
                case "nchar":
                    runtimeType = "SqlDbType.NChar";
                    break;
            
                case "ntext":
                    runtimeType = "SqlDbType.NText";
                    break;      
        
                case "numeric":
                    runtimeType = "SqlDbType.Decimal";
                    break;
            
                case "nvarchar":
                    runtimeType = "SqlDbType.NVarChar";
                    break;
            
                case "real":
                    runtimeType = "SqlDbType.Real";
                    break;

                case "rowversion":
                    runtimeType = "SqlDbType.Timestamp";
                    break;

                case "smalldatetime":
                    runtimeType = "SqlDbType.SmallDateTime";
                    break;
          
                case "smallint":
                    runtimeType = "SqlDbType.SmallInt";
                    break;
           
                case "smallmoney":
                    runtimeType = "SqlDbType.SmallMoney";
                    break;
            
                case "sql_variant":
                    runtimeType = "SqlDbType.Variant";
                    break;
            
                case "text":
                    runtimeType = "SqlDbType.Text";
                    break;

                case "timestamp":
                    runtimeType = "SqlDbType.Timestamp";
                    break;

                case "tinyint":
                    runtimeType = "SqlDbType.TinyInt";
                    break;

                case "uniqueidentifier":
                    runtimeType = "SqlDbType.UniqueIdentifier";
                    break;

                case "varbinary":
                    runtimeType = "SqlDbType.VarBinary";
                    break;

                case "varchar":
                    runtimeType = "SqlDbType.VarChar";
                    break;  
            
                default:
                    if ( sqlType.StartsWith( "varchar")) 
                    {
                        runtimeType = "SqlDbType.VarChar";
                    } 
                    else if ( sqlType.StartsWith( "nvarchar")) 
                    {
                        runtimeType = "SqlDbType.NVarChar";
                    }
                    else
                        throw new Exception( "Invalid Type. Unable to find suitable Runtime Type.");
                    break;
            }

            return runtimeType;
        } // InternalFindSqlType()
        #endregion


        /// <summary>
        /// because CodeExpressionCollection doesn't have an ToArray method, we have to implement
        /// our own.
        /// </summary>
        /// <param name="cec"></param>
        /// <returns></returns>
        protected static CodeExpression[] CodeExpressionCollectionToArray(CodeExpressionCollection cec)
        {
            int index = 0;
            CodeExpression[] result = new CodeExpression[cec.Count];        
            
            foreach (CodeExpression o in cec)
            {
                result[index] = o;
                index++;
            }
            return result;
        }

        /// <summary>
        /// Utility function to build a comment statement collection out of an array of comment string
        /// </summary>
        /// <param name="comments">the comment string array</param>
        /// <param name="docComment">true if it's document comment, false otherwise</param>
        /// <returns></returns>
        protected static CodeCommentStatementCollection BuildComments(string[] comments, bool docComment)
        {
            CodeCommentStatementCollection ccsc = new CodeCommentStatementCollection();
            foreach(string comment in comments)
            {
                ccsc.Add(new CodeCommentStatement(comment, docComment));
            }
            return ccsc;
        }

        /// <summary>
        /// Utility function to build a comment statement collection out of one string.
        /// The string can be multiline concatenated by '\n'.
        /// </summary>
        /// <param name="comments">The comment string, concatenated by '\n'</param>
        /// <param name="docComment">true if it's document comment, false otherwise</param>
        /// <returns>The comment statement collection</returns>
        protected static CodeCommentStatementCollection BuildComments(string comments, bool docComment)
        {
            CodeCommentStatementCollection ccsc = new CodeCommentStatementCollection();
            // TODO: make a more generic function
            string[] commentsArray = comments.Split('\n');
            foreach(string comment in commentsArray)
            {
                ccsc.Add(new CodeCommentStatement(comment, docComment));
            }
            return ccsc;
        }

        /// <summary>
        /// Build parameters from a string array. Each string is the name of one parameter
        /// </summary>
        /// <param name="parameters">The string parameter array</param>
        /// <returns>The code expression collections of parameter array</returns>
        protected static CodeExpression[] BuildParameters(string[] parameters)
        {
            if( parameters.Length == 0)
                return null;

            CodeExpression[] cares = 
                new CodeExpression[parameters.Length];
            int index = 0;
            foreach(string parameter in parameters)
            {
                CodeArgumentReferenceExpression care = new CodeArgumentReferenceExpression(parameter);
                cares[index] = care;
                index++;
            }
            return cares;
        }

        /// <summary>
        /// Build parameters from a string array. Each string is the name of one parameter.
        /// This method adds a property to the generated parameter in the form of param.property
        /// </summary>
        /// <param name="parameters">The string parameters</param>
        /// <param name="property">The property name</param>
        /// <returns>The code expression collection of parameters</returns>
        protected static CodeExpression[] BuildParametersWithProperty(string[] parameters, string property)
        {
            if( parameters.Length == 0)
                return null;

            CodeExpression[] cares = 
                new CodeExpression[parameters.Length];
            int index = 0;
            foreach(string parameter in parameters)
            {
                CodeArgumentReferenceExpression care = new CodeArgumentReferenceExpression(parameter);
                cares[index] = new CodePropertyReferenceExpression(
                    care, property);
                index++;
            }
            return cares;
        }

        /// <summary>
        /// Utility function to build PartitionBy argument parameters. 
        /// </summary>
        /// <param name="procDef">The procedure definition</param>
        /// <returns></returns>
        protected static CodeExpression[] BuildHashParameters(ProcedureDefinition procDef)
        {
            // initialize same number of expressions as parameter length
            CodeExpression[] cares = 
                new CodeExpression[procDef.attribute.partitionBy.paramRef.Length];
            int index = 0;
            foreach(string paramRef in procDef.attribute.partitionBy.paramRef)
            {
                string paramType = null;
                // find the parameter type in parameter array
                foreach(ParameterDefinition paramDef in procDef.param)
                {
                    if(paramDef.spname.ToLower().Equals(paramRef.ToLower()))
                    {
                        paramType = paramDef.type;
                        break;
                    }
                }

                if( paramType == null)
                    throw new SpilCodeGenerationException("partitionby argument " + paramRef +" not found in parameter");

                CodeArgumentReferenceExpression care = new CodeArgumentReferenceExpression(paramRef);
                // if the type is string, simply return the expression
                // otherwise, need to add "Value" property.
                if(FindFrameworkSqlType(paramType) == "SqlString")
                {
                    cares[index] = care;
                }
                else
                {
                    cares[index] = new CodePropertyReferenceExpression(
                        care, "Value");
                }
                index ++;
            }
            return cares;
        }
    } // class SpilCodeGenerator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\Assertion.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for Assertion.
	/// </summary>
	public class DbAssertion
	{
		private DbAssertion()
		{
			
		}

		/// <summary>
		/// Assert the data is DBNull
		/// </summary>
		/// <param name="value"></param>
		public static void AssertDbNull(object value)
		{
			if (!(value is INullable) || !((INullable)value).IsNull)
			{
				throw new DbAssertionException(String.Format("Data is not null. Expected: Null, Actual: {0}", 
					value.ToString()));
			}
	}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="filter"></param>
		/// <param name="scm"></param>
		/// <param name="connectionString"></param>
		/// <param name="databaseName"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatabaseEquals(string fileName, string filter, string databaseName, string connectionString, ISpilConnectionManager scm, bool strictCompare)
		{
			SqlCommand command = new SqlCommand(filter, (SqlConnection)scm.GetConnection(databaseName, connectionString, 0));
			IDataAdapter adapter = scm.GetDataAdapterForCommand(command);
			DataSet ds = new DataSet();
			adapter.Fill(ds);
			AssertDatasetEqualsFile(fileName, "xml", ds, strictCompare);
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="filter"></param>
        /// <param name="scm"></param>
        /// <param name="connectionString"></param>
        /// <param name="databaseName"></param>
        /// <param name="strictCompare"></param>
        public static void AssertDatabaseEqualsXml(string xml, string filter, string databaseName, string connectionString, ISpilConnectionManager scm, bool strictCompare)
        {
            SqlCommand command = new SqlCommand(filter, (SqlConnection)scm.GetConnection(databaseName, connectionString, 0));
            IDataAdapter adapter = scm.GetDataAdapterForCommand(command);
            DataSet ds = new DataSet();
            adapter.Fill(ds);
            AssertDatasetEqualsXml(xml, ds, strictCompare);
        }
		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="ds"></param>
		public static void AssertDatasetEqualsFile(string fileName, DataSet ds)
		{
			DataSet expected = new DataSet(); //ds.Clone();
			XmlFileConverter converter = new XmlFileConverter();
			converter.ReadFromFile(expected, fileName);
			AssertDatasetEquals(expected, ds, false);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="ds"></param>
		public static void AssertDatasetEqualsXml(string xml, DataSet ds)
		{
			DataSet expected = ds.Clone();
			XmlFileConverter converter = new XmlFileConverter();
			converter.ReadFromString(expected, xml);
			AssertDatasetEquals(expected, ds, false);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="ds"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatasetEqualsXml(string xml, DataSet ds, bool strictCompare)
		{
			DataSet expected = ds.Clone();
			XmlFileConverter converter = new XmlFileConverter();
			converter.ReadFromString(expected, xml);
			AssertDatasetEquals(expected, ds, strictCompare);
		}

		
		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="fileType"></param>
		/// <param name="ds"></param>
		public static void AssertDatasetEqualsFile(string fileName, string fileType, DataSet ds)
		{
			DataSet expected = ds.Clone(); // here we have to use clone
			IFileConverter converter = GetConverterFromType(fileType);
			converter.ReadFromFile(expected, fileName);
			AssertDatasetEquals(expected, ds, false);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileName"></param>
		/// <param name="fileType"></param>
		/// <param name="ds"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatasetEqualsFile(string fileName, string fileType, DataSet ds, bool strictCompare)
		{
			DataSet expected = ds.Clone(); // here we have to use clone
			IFileConverter converter = GetConverterFromType(fileType);
			converter.ReadFromFile(expected, fileName);
			AssertDatasetEquals(expected, ds, strictCompare);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="expected"></param>
		/// <param name="actual"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDatasetEquals(DataSet expected, DataSet actual, bool strictCompare)
		{
			if (strictCompare && expected.Tables.Count != actual.Tables.Count)
			{
				throw new DbAssertionException(String.Format("DataSet has different table counts. Expected: {0}, Actual: {1}", expected.Tables.Count, actual.Tables.Count));
			}
			for(int i = 0; i < expected.Tables.Count; i ++)
			{
				DataTable expectedTable = expected.Tables[i];
				DataTable actualTable = actual.Tables[expectedTable.TableName];
				if (actualTable == null)
				{
					throw new DbAssertionException("Cannot find table. Expected: " + expectedTable.TableName);
				}
				AssertDataTableEquals(expectedTable, actualTable, strictCompare);
			}
		}
			
		/// <summary>
		/// 
		/// </summary>
		/// <param name="expected"></param>
		/// <param name="actual"></param>
		/// <param name="strictCompare"></param>
		public static void AssertDataTableEquals(DataTable expected, DataTable actual, bool strictCompare)
		{
			if (strictCompare && expected.Rows.Count != actual.Rows.Count)
			{
				throw new DbAssertionException(String.Format("{0} has different row counts. Expected: {1}, Actual: {2}", expected.TableName, expected.Rows.Count, actual.Rows.Count));
			}
			if (strictCompare && expected.Columns.Count != actual.Columns.Count)
			{
				throw new DbAssertionException(String.Format("{0} has different column counts. Expected: {1}, Actual: {2}", expected.TableName, expected.Columns.Count, actual.Columns.Count));
			}
			for(int i = 0; i < expected.Rows.Count; i ++)
			{
				DataRow expectedRow = expected.Rows[i];
				DataRow actualRow = actual.Rows[i];

				for(int j = 0; j < expected.Columns.Count; j ++)
				{
					string columnName = expected.Columns[j].ColumnName;
					if(expectedRow[j].ToString() != "" && expectedRow[j].ToString().ToLower() != actualRow[columnName].ToString().ToLower())
					{
						throw new DbAssertionException(String.Format("DataSet is different at {0}[Row {1}]. Expected: {2}, Actual: {3}",
							expected.TableName, i, expectedRow[j].ToString(), actualRow[j].ToString()));
					}
				}
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="fileType"></param>
		/// <returns></returns>
		internal static IFileConverter GetConverterFromType(string fileType)
		{
			if (fileType == "xml")
			{
				return new XmlFileConverter();
			}
			else if (fileType == "csv")
			{
				return new CsvFileConverter();
			}
			else if (fileType == "excel")
			{
				return new ExcelFileConverter();
			}
			else
			{
				throw new DbAssertionException("Cannot find converter for input file type :" + fileType);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\AssertionException.cs ===
namespace Microsoft.Subscriptions.Data
{
	using System;
	using System.Runtime.Serialization;
	
	/// <summary>
	/// Thrown when an assertion failed.
	/// </summary>
	/// 
	[Serializable]
	public class DbAssertionException : System.Exception
	{
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message"></param>
		public DbAssertionException (string message) : base(message) 
		{}

		/// <summary>
		/// Standard constructor
		/// </summary>
		/// <param name="message">The error message that explains 
		/// the reason for the exception</param>
		/// <param name="inner">The exception that caused the 
		/// current exception</param>
		public DbAssertionException(string message, Exception inner) :
			base(message, inner) 
		{}

		/// <summary>
		/// Serialization Constructor
		/// </summary>
		protected DbAssertionException(SerializationInfo info, 
			StreamingContext context) : base(info,context)
		{}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\AssemblyInfoIDE.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS SPIL Runtime")]
[assembly: AssemblyDescription("Runtime library classes for interfacing with database stored procedures")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Subscription Platform Services")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// Version Info comes from separate file!
[assembly: AssemblyVersion("3.0.0800.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("..\\..\\SpilRun.snk")]
[assembly: AssemblyKeyName("")]

// It is a good thing to have CLSCompliance - hence marking it
[assembly:CLSCompliant(true)]

// Thanks a lot - i do not need COM anymore! the default is true - so mark it false
[assembly:ComVisible(false)]
//
// Require that at minimum the user should be able to read the USERNAME environment permission
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="USERNAME")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\DataStoreComponent.cs ===
/*
 *  DataStoreComponent.cs
 * 
 *  Base class for interacting with DataStores.
 *  It consists of properties and methods to call stored procedures 
 *    on associated data stores.
 * 
 * Revision History:
 *  Feb 2003    - TaoH  - Add command timeout support.
 *                      - Add IDataReader support, rearranged code structure for reuse
 *  Aug 2002    - MuraliK  - created initial version
 */

using System;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.XPath;
using System.IO;
using System.Text;
using System.Collections;
using System.Runtime.CompilerServices;
using Microsoft.Webstore.WstClient; // for webstore connectivity

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// class DataStoreComponent
    /// o  base component for interacting with the databases
    /// It stores the connection string and provides accessors to create 
    ///     new SqlConnection class for talking with the databases.
    /// 
    /// TODO: Add auding/trace logic support
    /// </summary>
    public class DataStoreComponent
    {
        /// <summary>
        /// Reserved hash value to indicate that any physical instance may be used
        ///  when dealing with partitioned instances of same logical database
        /// </summary>
        public const int HashValueForAnyInstance = -1;

        /// <summary>
        /// info message handler
        /// </summary>
        protected static SqlInfoMessageEventHandler infoMessageEventHandler;
        /// <summary>
        /// Default constructor. The class is not directly instantiable.
        /// </summary>
        private DataStoreComponent() {}


        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's client's responsibility to close
        ///     the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The data reader for the stored procedure</returns>
        static public object ExecuteScalarStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {
            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteScalarOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);
        }

        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's client's responsibility to close
        ///     the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The data reader for the stored procedure</returns>
        static public IDataReader ExecuteReaderStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {

            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteReaderOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);

        } // ExecuteReaderStoredProcedure

        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's client's responsibility to close
        ///     the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The data reader for the stored procedure</returns>
        static public int ExecuteNonQueryStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {

            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteNonQueryOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);

        } // ExecuteNonQueryStoredProcedure

        /// <summary>
        /// Executes the specified stored procedure against a single
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object to translate the 
        ///   specified logical id into physical instance and obtains a connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the procedure results are returned.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="hashValue">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results that contains the dataset and return value</returns>
        static public ProcedureResults ExecuteStoredProcedure( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            int hashValue, 
            string procedureName,
            SqlParameter[] paramList) 
        {

            object physicalInstanceId = scm.GetPhysicalInstanceId(catalogName, hashValue);
            
            return ExecuteOnPhysicalInstance(
                context,
                scm,
                catalogName,
                partialConnectionString,
                physicalInstanceId,
                procedureName,
                paramList);

        } // protected ProcedureResults ExecuteStoredProcedure()


        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns the datareader.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>Always throws NotImplementedException</returns>
        static public IDataReader ExecuteReaderOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {
            throw new NotImplementedException("ExecuteReaderOnAllPartitions is not supported.");
        } // protected ProcedureResults ExecuteReaderOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns the datareader.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>array of returned scalar objects, one for each partition</returns>
        static public object[] ExecuteScalarOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {
            if ( (procedureName == null) || (procedureName.Length == 0)) 
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");

            object[] allPhysicalInstances = scm.GetAllPhysicalInstances(catalogName);
            int numPhysicalPartitions = allPhysicalInstances.Length;
            object[] scalarObjects = new object[ numPhysicalPartitions];
            
            
            for(int i = 0; i < numPhysicalPartitions; i ++)
            {
                SqlParameter[] paramList2;
                if ( i >= 1 ) // only clone parameter list if it's after first partition.
                    paramList2 = CloneParameterList(paramList);
                else
                    paramList2 = paramList;

                scalarObjects[i] = ExecuteScalarOnPhysicalInstance(
                    context,
                    scm,
                    catalogName,
                    partialConnectionString,
                    allPhysicalInstances[i],
                    procedureName,
                    paramList2);
            }

            return scalarObjects;
        } // protected ProcedureResults ExecuteReaderOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns ALL the procedure results as an array.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results array that contains the dataset and return value
        /// for each partition.</returns>
        static public ProcedureResults[] ExecuteProcedureOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {

            if ( (procedureName == null) || (procedureName.Length == 0)) 
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");

            object[] allPhysicalInstances = scm.GetAllPhysicalInstances(catalogName);
            int numPhysicalPartitions = allPhysicalInstances.Length;
            ProcedureResults[] allProcedureResults = new ProcedureResults[ numPhysicalPartitions];
            
            
            for(int i = 0; i < numPhysicalPartitions; i ++)
            {
                SqlParameter[] paramList2;
                if ( i >= 1 ) // only clone parameter list if it's after first partition.
                    paramList2 = CloneParameterList(paramList);
                else
                    paramList2 = paramList;

                allProcedureResults[i] = ExecuteOnPhysicalInstance(
                    context,
                    scm,
                    catalogName,
                    partialConnectionString,
                    allPhysicalInstances[i],
                    procedureName,
                    paramList2);
            }

            return allProcedureResults;
        } // protected ProcedureResults ExecuteProcedureOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against ALL physical instances
        ///  of the specific logical database (this.catalogName) 
        ///  It uses the supplied connection manager object to find ALL
        ///   connections for the given logical database. Then it iterates
        ///   over each of the connection to produce results.
        ///   
        /// Finally on success it returns ALL the procedure results as an array.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="catalogName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results array that contains the dataset and return value
        /// for each partition.</returns>
        static public int[] ExecuteNonQueryOnAllPartitions( 
            DataStoreContext context,
            ISpilConnectionManager scm, 
            string catalogName,
            string partialConnectionString,
            string procedureName, 
            SqlParameter[] paramList) 
        {

            if ( (procedureName == null) || (procedureName.Length == 0)) 
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");

            object[] allPhysicalInstances = scm.GetAllPhysicalInstances(catalogName);
            int numPhysicalPartitions = allPhysicalInstances.Length;
            int[] allRowsAffected = new int[ numPhysicalPartitions];
            
            
            for(int i = 0; i < numPhysicalPartitions; i ++)
            {
                SqlParameter[] paramList2;
                if ( i >= 1 ) // only clone parameter list if it's after first partition.
                    paramList2 = CloneParameterList(paramList);
                else
                    paramList2 = paramList;

                allRowsAffected[i] = ExecuteNonQueryOnPhysicalInstance(
                    context,
                    scm,
                    catalogName,
                    partialConnectionString,
                    allPhysicalInstances[i],
                    procedureName,
                    paramList2);
            }

            return allRowsAffected;
        } // protected ProcedureResults ExecuteNonQueryOnAllPartitions()

        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the procedure results are returned.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The procedure results that contains the dataset and return value</returns>
        static public ProcedureResults ExecuteOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            return ExecuteCommandAndFetchResults(context, scm, cmd);
        } // public ProcedureResults ExecuteOnPhysicalInstance()


        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's the client's responsibility to
        ///     close the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The scalar object from the stored procedure</returns>
        static public object ExecuteScalarOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            // execute stored procedure and returns IDbReader
            object returnObject;
            int returnValue = ProcedureResults.InvalidProcedureReturnValue;
            
            try
            {
                // start query
                context.StartQuery();
                // execute
                returnObject = cmd.ExecuteScalar();
                // end query
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( sqle.Message, "SPIL");
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), sqle);
            }
            catch( Exception e) 
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            // finally return the returnObject;

            return returnObject;
        }

        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's the client's responsibility to
        ///     close the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The number of the rows affected</returns>
        static public int ExecuteNonQueryOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            // execute stored procedure and returns IDbReader
            int numberOfRowsAffected;
            int returnValue = ProcedureResults.InvalidProcedureReturnValue;
            
            try
            {
                // start query
                context.StartQuery();
                // execute
                numberOfRowsAffected = cmd.ExecuteNonQuery();
                // end query
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( sqle.Message, "SPIL");
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), sqle);
            }
            catch( Exception e) 
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            // finally return the returnObject;

            return numberOfRowsAffected;
        }
        /// <summary>
        /// Executes the specified stored procedure against a specific
        ///  physical partition/instance of the specified logical database (catalogName)
        ///  It uses the supplied connection manager object and physical instance id 
        ///   to obtain a physical connection
        ///   for the target instance database.
        /// It takes in an array of parameters for the call and on success
        ///     the data reader are returned. It's the client's responsibility to
        ///     close the reader after finishing reading from it.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The datareader from the stored procedure</returns>
        static public IDataReader ExecuteReaderOnPhysicalInstance( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            IDbCommand cmd = BuildCommand
                (
                context,
                scm, 
                logicalDatabaseName, 
                partialConnectionString, 
                physicalInstanceId, 
                procedureName, 
                paramList
                );

            // execute stored procedure and returns IDbReader
            IDataReader reader;
            int returnValue = ProcedureResults.InvalidProcedureReturnValue;
            
            try
            {
                // start query
                context.StartQuery();
                // execute
                reader = cmd.ExecuteReader();
                // end query
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( sqle.Message, "SPIL");
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), sqle);
            }
            catch( Exception e) 
            {
                returnValue = GetReturnValue(cmd.Parameters);
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            // finally return the reader;

            return reader;
        } // ExecuteReaderOnPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Builds the command for executing the stored procedure.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">interface to connection manager object to fetch the required connection for specified logical partition </param>
        /// <param name="logicalDatabaseName">name of the catalog or WebStore application for the logical data store</param>
        /// <param name="partialConnectionString">partial connection string with metadata for connecting to the target database.
        /// This connection string should NOT have the "Initial Catalog=" value specified.</param>
        /// <param name="physicalInstanceId">specifies the physical instance # of the logical database
        ///  where the method should be executed</param>
        /// <param name="procedureName">name of the stored procedure to execute</param>
        /// <param name="paramList">list of parameters for the call</param>
        /// <returns>The datareader from the stored procedure</returns>
        static public IDbCommand BuildCommand( 
            DataStoreContext context,
            ISpilConnectionManager scm,
            string logicalDatabaseName,
            string partialConnectionString,
            object physicalInstanceId, 
            string procedureName,
            IDataParameter[] paramList) 
        {
            if ((procedureName == null) || (procedureName.Length == 0)) 
            {
                throw new DataStoreException( "Invalid procedure name. Cannot be run on the data store.");
            }

            // get the connection for the specified parameters
            IDbConnection dbconn = scm.GetConnectionForPhysicalInstance(logicalDatabaseName, partialConnectionString, physicalInstanceId);
            IDbCommand cmd = scm.GetCommandForPhysicalInstance(logicalDatabaseName, partialConnectionString, physicalInstanceId);

            if (dbconn is SqlConnection)
            {
                SqlConnection sqlc = dbconn as SqlConnection;
                
                if (infoMessageEventHandler == null)
                    infoMessageEventHandler = new SqlInfoMessageEventHandler(context.SqlInfo);
                
                // KLUDGE: this is not very good but I cannot find out how to check
                // only one event handler is registered without creating a memory structure (hashtable?)
                sqlc.InfoMessage -= infoMessageEventHandler;
                sqlc.InfoMessage += infoMessageEventHandler;
            }
            // WstCommands have parameters outside the IDbCommand interface.
            if (cmd is WstCommand)
            {
                ((WstCommand)(cmd)).Partition = (int)physicalInstanceId;
                ((WstCommand)(cmd)).PartitionType = WstPartitionType.Physical;
            }

            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = procedureName;           
            //add command timeout value.
            cmd.CommandTimeout = scm.CommandTimeOut;
            // fill in the parameters for the call 
            FillInProcedureParameters( cmd.Parameters, paramList);

            // set conect command
            context.command = cmd;
            context.connection = dbconn;
            return cmd;
        } // ExecuteReaderOnPhysicalInstance

        /// <summary>
        ///  Helper function to add the set of input parameters to the command's parameter collection.
        ///  As part of the add, it also will 'clone' parameters if required. 
        ///  Cloning (or making a copy) of parameters is required to ensure that we have unique
        ///     copies for each call made to the databases. ADO.NET/WebStore insist on this unique
        ///     instance of SqlParameter per collection.
        ///  It also adds the special return value parameter at the very end of the parameters list
        /// </summary>
        /// <param name="paramCollection">Parameter collection object that belongs to a command object</param>
        /// <param name="masterParamList">array of parameters to be included in the collection</param>
        /// <remarks>
        ///  The cloning of <see cref="SqlParameter"/> is required so that when we make calls against a set of databases
        ///  with the same parameter values. ADO.NET requires unique instances 
        ///  within a collection of parameters in order to maintain unique states.
        /// </remarks>
        static private void FillInProcedureParameters( 
            IDataParameterCollection paramCollection, 
            IDataParameter[] masterParamList) 
        {
            // TODO: Is there a better way than this exhaustive add of parameters?
            for (int i = 0; i < masterParamList.Length; ++i)
            {
                 paramCollection.Add(masterParamList[i]);
            }

            // Add special parameter for the 'retval' from procedure call
            SqlParameter retvalParam = new SqlParameter();
            retvalParam.Direction = ParameterDirection.ReturnValue;
            retvalParam.SqlDbType = SqlDbType.Int;
            paramCollection.Add(retvalParam);
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Given a list of parameters, find the return value and returns the
        /// value of that parameter.
        /// </summary>
        /// <param name="context">The DataStoreContext</param>
        /// <returns>The value of the SQL return parameter</returns>
        public static int GetReturnValue(DataStoreContext context)
        {
            if (context != null && context.Command != null)
            {
                return GetReturnValue(context.Command.Parameters);
            }

            return ProcedureResults.InvalidProcedureReturnValue;
        } // GetReturnValue        

        //---------------------------------------------------------------------
        /// <summary>
        /// Given a list of parameters, find the return value and returns the
        /// value of that parameter.
        /// </summary>
        /// <param name="paramList"></param>
        /// <returns>The value of the SQL return parameter</returns>
        public static int GetReturnValue(IDataParameterCollection paramList)
        {
            // TODO: Optimize the following linear search
            // TODO: Won't it be sufficient to just fetch 
            //    the last parameter in the cmd.Parameters collection?
            foreach (IDataParameter param in paramList) 
            {
                if (param.Direction == ParameterDirection.ReturnValue && param.Value != null) 
                {
                    return (int)(param.Value);
                }    
            }

            return ProcedureResults.InvalidProcedureReturnValue;
        } // GetReturnValue

        //---------------------------------------------------------------------
        /// <summary>
        /// Helper function to execute the supplied SQL Command and fetch 
        /// results of the call.
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="scm">
        /// The connection manager object that created the command.
        /// </param>
        /// <param name="cmd">
        /// SQL command object with stored procedure and parameters for 
        /// execution.
        /// </param>
        static private ProcedureResults ExecuteCommandAndFetchResults(DataStoreContext context, ISpilConnectionManager scm, IDbCommand cmd) 
        {
            // TODO: Isn't SqlReader a better method for this fwd R/O dataset caching?
            IDataAdapter da = scm.GetDataAdapterForCommand(cmd);
            DataSet ds = new DataSet();

            // FXCOP: Set the locale to invariant as mandated by FxCOP
            ds.Locale = System.Globalization.CultureInfo.InvariantCulture;
            ProcedureResults procedureResults = null;
            int returnValue = 0;
            try 
            {
                context.StartQuery();
                da.Fill(ds);
                context.EndQuery();
                returnValue = GetReturnValue(cmd.Parameters);
            }
            catch( SqlException sqle)
            {
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                returnValue = GetReturnValue(cmd.Parameters);
                procedureResults = new ProcedureResults(returnValue, ds);
                // wrap the procedure results inside the exception
                StringBuilder sb = new StringBuilder();
                sb.Append("SPIL query failed ");
                sb.AppendFormat("on {0}-{1}-", sqle.Server, cmd.CommandText);
                sb.Append(sqle.Message);
                sb.Append("-Procedure-");
                sb.Append(sqle.Procedure);
                sb.Append("-Line-");
                sb.Append(sqle.LineNumber);
                
                throw new DataStoreException(sb.ToString(), procedureResults, sqle);
            }
            catch( Exception e) 
            {
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                returnValue = GetReturnValue(cmd.Parameters);
                procedureResults = new ProcedureResults(returnValue, ds);
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, procedureResults, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = returnValue;
                scm.ReturnValue = returnValue;
            }

            procedureResults = new ProcedureResults(returnValue, ds);

            return procedureResults;
        }

        /// <summary>
        /// Helper function to execute the supplied WST Command and fetch results of the call
        /// </summary>
        /// <param name="context">
        /// The <see cref="DataStoreContext"/> for the query
        /// </param>
        /// <param name="cmd">The command to execute</param>
        /// <param name="scm">The connection manager</param>
        static private ProcedureResults ExecuteWstCommandAndFetchResults(DataStoreContext context, ISpilConnectionManager scm, WstCommand cmd) 
        {
            int retVal = ProcedureResults.InvalidProcedureReturnValue;
            // TODO: Isn't SqlReader a better method for this fwd R/O dataset caching?
            WstDataAdapter da = new WstDataAdapter();
            da.SelectCommand = cmd;
            
            //cmd.Connection.Open();
            DataSet ds = new DataSet();

            // FXCOP: Set the locale to invariant as mandated by FxCOP
            ds.Locale = System.Globalization.CultureInfo.InvariantCulture;
            ProcedureResults procedureResults = null;
            try 
            {
                context.StartQuery();
                da.Fill( ds);
                context.EndQuery();
                retVal = GetReturnValue(cmd.Parameters);
            }
            catch( Exception e) 
            {
                // Try to retrieve the dataset and wrap it in a DataStoreException.
                // System.Diagnostics.Trace.WriteLine( e.Message, "SPIL");
                retVal = GetReturnValue(cmd.Parameters);
                context.LastReturnValue = retVal;
                procedureResults = new ProcedureResults(retVal, ds);
                // wrap the procedure results inside the exception
                throw new DataStoreException(e.Message, procedureResults, e); 
            }
            finally 
            {
                // NOTE: The close of connection is left to the calling connection manager
                context.LastReturnValue = retVal;
                scm.ReturnValue = retVal;
            }

            // retrieve return value from command object
            // TODO: Optimize the following linear search
            // TODO: Won't it be sufficient to just fetch 
            //    the last parameter in the cmd.Parameters collection?
            procedureResults = new ProcedureResults(retVal, ds);

            return procedureResults;
        }

        /// <summary>
        /// Internal utility function to make a clone of a SqlParameter array
        /// </summary>
        /// <param name="masterParamList">The sql parameter array to be copied</param>
        /// <returns>The new array containing the same copy of sqlparameters</returns>
        static private SqlParameter[] CloneParameterList(SqlParameter[] masterParamList)
        {
            SqlParameter[] newParamList = new SqlParameter[masterParamList.Length];
            for( int i = 0; i < masterParamList.Length; i++)
            {
                SqlParameter newParam = 
                    new SqlParameter( masterParamList[i].ParameterName,
                    masterParamList[i].SqlDbType);
                newParam.Value       = masterParamList[i].Value;
                newParam.IsNullable  = masterParamList[i].IsNullable;
                newParam.Direction   = masterParamList[i].Direction;
                newParamList[i] = newParam;
            }
            return newParamList;
        }

    } // class DataStoreComponent

   
    /// <summary>
    /// DataStoreException
    /// o Custom exception class that captures errors for 
    ///  stored procedure calls to the datastore calls.
    /// </summary>
    [Serializable()]
    public sealed class DataStoreException: ApplicationException 
    {

        ProcedureResults procedureResults = null;

        /// <summary>
        /// stores the procedure results when an exception is thrown.
        /// The exception handler can get the results from this property.
        /// </summary>
        public ProcedureResults ProcedureResults 
        {
            get { return  procedureResults; }
            set { procedureResults = value; }
        }

        /// <summary>
        /// default constructor for DataStoreException
        /// </summary>
        public DataStoreException()
            : base() {}

        /// <summary>
        /// constructor for DataStoreException that accepts a string message
        /// </summary>
        /// <param name="message">exception message</param>
        public DataStoreException( string message)
            : base( message) {}

        /// <summary>
        /// constructor for DataStoreException that accepts a procedure results
        /// </summary>
        /// <param name="procedureResults">the procedure results for the particular query</param>
        public DataStoreException(ProcedureResults procedureResults)
            : base()
        {
            this.procedureResults = procedureResults;
        }

        /// <summary>
        /// constructor for DataStoreException that accepts a procedure results and an inner exception
        /// </summary>
        /// <param name="procedureResults">the procedure results for the particular query</param>
        /// <param name="innerException">inner exception</param>
        /// <param name="message">exception message</param> 
        public DataStoreException(string message, ProcedureResults procedureResults, Exception innerException)
            : base( message, innerException)
        {
            this.procedureResults = procedureResults;
        }
        /// <summary>
        /// constructor for DataStoreException that accepts a string message and innerException
        /// </summary>
        /// <param name="message">exception message</param>
        /// <param name="innerException"></param>
        public DataStoreException( string message, Exception innerException) 
            : base( message, innerException) {}
        
        /// <summary>
        /// constructor for DataStoreException that supports serialization
        /// </summary>
        /// <param name="sinfo"></param>
        /// <param name="scontext"></param>
        internal DataStoreException( System.Runtime.Serialization.SerializationInfo sinfo, System.Runtime.Serialization.StreamingContext scontext)
            : base( sinfo, scontext) {}
    }

    /// <summary>
    /// class ProcedureResults
    /// o  Encapsulates return results for a stored procedure calls 
    ///  done using the DataStoreComponent (or its derivative)
    ///  
    ///  Usually an instance is created after successful execution of 
    ///   a stored procedure. A failure to execute stored procedure will
    ///   usually throw an exception and return null value for ProcedureResults.
    ///  
    ///  Notes: This does not keep track of "what" stored procedure executed 
    ///   and "what" were the input values. I believe those belong within
    ///   the ProcedureCallContext and is not required.
    /// </summary>
    public class ProcedureResults 
    {

        /// <summary>
        /// Specifies the value for errored stored procedure return value
        /// </summary>
        public const int InvalidProcedureReturnValue = -1;

        internal bool      fExecutionDone = false;
        internal int       procReturnValue = 0;     // the integer return value from call
        internal DataSet   dsResults = null;

        /// <summary>
        /// Creates an empty ProcedureResults instance.
        /// The results will be marked with execution NOT done and no results.
        /// </summary>
        public ProcedureResults() {}


        /// <summary>
        /// Creates a new ProcedureResults with the supplied return value and dataset
        /// </summary>
        /// <param name="retVal">return value from stored procedure. 
        ///     interpretation of the value is subject to individual stored procedures
        /// </param>
        /// <param name="results">DataSet returned as a result of executing stored procedure</param>
        public ProcedureResults( int retVal, DataSet results) 
        {
            SetResults( retVal, results);
        }

        /// <summary>
        /// Stores the results provided none is already stored.
        /// </summary>
        /// <param name="results">new set of results to be stored</param>
        /// <param name="retVal">return value from stored procedure.</param>
        [MethodImpl( MethodImplOptions.Synchronized)]
        private void SetResults( int retVal, DataSet results) 
        {
            if ( fExecutionDone) 
                throw new DataStoreException( "Already results are stored from a previous execution. Cannot store duplicate results.");
            fExecutionDone = true;
            dsResults = results;
            procReturnValue = retVal;
        }

        /// <summary>
        /// Method returned value - interpretation is subject to specific stored procedure executed.
        /// </summary>
        public int ReturnValue 
        {
            get { return procReturnValue; }
        }

        /// <summary>
        /// Returns the results in the form of a DataSet
        /// Returned values are organized in whatever form 
        ///     the stored procedure had returned them.
        /// No attempt is made to parse out data from this DataSet!
        /// </summary>
        public DataSet  Results 
        {
            get 
            { 
                if ( !fExecutionDone) 
                    throw new DataStoreException( "Specified Stored Procedure is NOT Executed. No results.");
                return dsResults;
            }
        }

        /// <summary>
        /// Returns the results as an XML structure using the standard DataSet to XML conversion.
        /// NOTE: for most part the caller should be pretty happy with the returned DataSet
        /// </summary>
        public string ResultsXml 
        {
            get 
            { 
                // Implements default XML Transformation of result set
                return this.Results.GetXml(); 
            }
        }

        /// <summary>
        /// Returns the results as an XML Document object.
        /// NOTE: This dynamically creates the XML Document object by linearizing
        ///  the data set into an XML document. Hence getting this value can be 
        ///  inefficient compared to the "Results" property fetch.
        /// </summary>
        public XmlDocument ResultsXmlDocument 
        {
            get 
            {
                // The only way to create a DOM for the results xml 
                //  is by loading the results XML string into a DOM.
                //  TODO: Is there a more efficient way?
                XmlDocument xd = new XmlDocument();
                xd.LoadXml( this.ResultsXml);
                return xd;
            }
        }

        /// <summary>
        /// Returns the results as an XMLDataDocument object.
        /// NOTE: This creates an XmlDataDocument directly from the data set. Any changes
        /// made to this XmlDataDocument will be reflectd in the data set as well.
        /// An exception is thrown if the execution is not done or results are null.
        /// </summary>
        public XmlDataDocument ResultsXmlDataDocument 
        {
            get 
            {
                if ( !fExecutionDone) 
                    throw new DataStoreException( "Specified Stored Procedure is NOT Executed. No results.");

                XmlDataDocument xdd = new XmlDataDocument( dsResults);
                return xdd;
            }
        }

        /// <summary>
        /// Returns the results as an XmlPathNavigator object.
        /// NOTE: This creates an XPathNavigator object directly from the data set. This
        /// property provides read-only random-access to the data set. It can also be used
        /// to perform XSL Transform efficiently.
        /// An exception is thrown if the execution is not done or results are null.
        /// </summary>
        public XPathNavigator ResultsXmlNavigator
        {
            get
            {
                if ( !fExecutionDone) 
                    throw new DataStoreException( "Specified Stored Procedure is NOT Executed. No results.");

                XmlDataDocument xdd = new XmlDataDocument( dsResults);
                return xdd.CreateNavigator();
            }
        }

        /// <summary>
        /// Merges the supplied array of ProcedureResults to produce a single
        ///  ProcedureResults object.
        /// </summary>
        /// <param name="allResults">array of ProcedureResults containing results
        /// from executing a method on ALL database instances.</param>
        /// <returns>single ProcedureResults object containing the summary of method execution</returns>
        static public ProcedureResults MergeResults( ProcedureResults[] allResults) 
        {
            
            if( allResults.Length > 0)
            {
                ProcedureResults prAll = allResults[0];
                for(int i = 1; i < allResults.Length; i ++)
                {
                    prAll.Results.Merge(allResults[i].Results);
                }
                return prAll;
            }
            return null;
        }
    } // class ProcedureResults
} // namespace Microsoft.Subscriptions.Data
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\DataStoreContext.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.Diagnostics;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// DataStoreContext exposes run time information about the current running 
    /// query.
    /// </summary>
    public sealed class DataStoreContext
    {
        // event set
        private EventHandlerSet eventSet = new EventHandlerSet();
        
        // because c# doesn't allow us to have different access permissions for getter and setter
        // we have to set the variable as internal so it can be set internally
        internal IDbCommand command;
        internal IDbConnection connection;
        private int lastReturnValue;

        #region DataStoreTraceEvent
        /// <summary>
        /// Type definining the prototype of the callback method that receivers must implement
        /// </summary>
        public delegate void DataStoreTraceEventHandler(object sender, DataStoreTraceEventArgs e);

        /// <summary>
        /// Type definining the call back method that receivers must implement
        /// </summary>
        public event DataStoreTraceEventHandler OnTraceMessage;

        private void TraceMessage(DataStoreTraceEventArgs e)
        {
            if (OnTraceMessage != null)
            {
                OnTraceMessage(this, e);
            }
        }

        internal void SqlInfo(object sender, SqlInfoMessageEventArgs e)
        {
            // trace the information
            Trace(TraceLevel.Info, e.Message, e.Source);
        }

        /// <summary>
        /// Trace a message and notify all receivers
        /// </summary>
        /// <param name="level">The trace level</param>
        /// <param name="message">The trace message</param>
        /// <param name="source">The source object of the trace message</param>
        internal void Trace(TraceLevel level, string message, string source)
        {
            DataStoreTraceEventArgs e = new DataStoreTraceEventArgs(level, message, source);
            TraceMessage(e);
        }
        #endregion

        #region QueryEndEvent
        private static readonly Object queryEndEventKey = new object();
        /// <summary>
        /// Query End Arguments
        /// </summary>
        public class QueryEndEventArgs : EventArgs {}
        /// <summary>
        /// type defining handler for Query End Event
        /// </summary>
        public delegate void QueryEndEventHandler(object sender, QueryEndEventArgs e);

        /// <summary>
        /// event for query end
        /// </summary>
        public event QueryEndEventHandler OnQueryEnd
        {
            add { eventSet.AddHandler(queryEndEventKey, value);}
            remove {eventSet.RemoveHandler(queryEndEventKey, value);}
        }
        private void QueryEnd(QueryEndEventArgs e)
        {
            eventSet.Fire(queryEndEventKey, this, e);
        }
        internal void EndQuery()
        {
            QueryEnd(new QueryEndEventArgs());
        }
        #endregion

        #region QueryStartEvent
        private static readonly Object queryStartEventKey = new object();
        /// <summary>
        /// type defining arguments for query start
        /// </summary>
        public class QueryStartEventArgs : EventArgs {}
        /// <summary>
        /// type defining delegates for query start
        /// </summary>
        public delegate void QueryStartEventHandler(object sender, QueryStartEventArgs e);
        /// <summary>
        /// type definining query start event handler
        /// </summary>
        public event QueryStartEventHandler OnQueryStart 
        {
            add { eventSet.AddHandler(queryStartEventKey, value);}
            remove {eventSet.RemoveHandler(queryStartEventKey, value);}
        }
        private void QueryStart(QueryStartEventArgs e)
        {
            eventSet.Fire(queryStartEventKey, this, e);
        }
        internal void StartQuery()
        {
            QueryStart(new QueryStartEventArgs());
        }
        #endregion

        /// <summary>
        /// Gets the current command. The command object is not thread-safe.
        /// </summary>
        public IDbCommand Command
        {
            get { return command;}
        }

        /// <summary>
        /// Gets the current connection. The connection object is not thread-safe.
        /// </summary>
        public IDbConnection Connection
        {
            get { return connection; }
        }

        /// <summary>
        /// Gets or sets the last return value
        /// </summary>
        public int LastReturnValue
        {
            get { return this.lastReturnValue; }
            set { this.lastReturnValue = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\CsvFileConverter.cs ===
using System;
using System.Data;
using System.Data.OleDb;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Convert a CSV file to <see cref="DataSet"/>
	/// </summary>
	public class CsvFileConverter : IFileConverter
	{
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="filePath"></param>
		public void ReadFromFile(DataSet ds, string filePath)
		{
			string pathName = Path.GetDirectoryName(filePath);
			string fileName = Path.GetFileName(filePath);
			using(OleDbConnection excelConnection = new OleDbConnection(@"Provider=Microsoft.Jet.OLEDB.4.0;Data Source="+pathName+";Extended Properties=Text;"))
			{
				OleDbCommand excelCommand = new OleDbCommand(@"SELECT * FROM "+fileName,excelConnection);
				OleDbDataAdapter excelAdapter = new OleDbDataAdapter(excelCommand);
				excelConnection.Open();
				excelAdapter.Fill(ds);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="xml"></param>
		public void ReadFromString(DataSet ds, string xml)
		{
			throw new NotSupportedException("csv string is not supported.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\ConnectionManagerBase.cs ===
using System;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Base class for creating Connection Manager. Defines common properties available to connection manager.
	/// 
	/// This class implements <see cref="ISpilConnectionManager"/> interface which defines the common methods available
	/// to connection manager.
	/// </summary>
	public abstract class ConnectionManagerBase : ISpilConnectionManager
	{
        #region Fields
        /// <summary>
        /// connection timeout value
        /// </summary>
        protected int connTimeOut = 30;
        /// <summary>
        /// command timeout value
        /// </summary>
        protected int commTimeOut = 30;
        /// <summary>
        /// return value
        /// </summary>
        protected int returnVal = ProcedureResults.InvalidProcedureReturnValue;
        #endregion

        #region Properties
        /// <summary>
        /// Gets or sets connection Timeout value 
        /// </summary>
        public virtual int ConnectionTimeOut
        {
            get { return this.connTimeOut; }
            set { this.connTimeOut = value; }
        }
        
        
        /// <summary>
        /// Gets or sets command Timeout value 
        /// </summary>
        public virtual int CommandTimeOut
        {
            get { return this.commTimeOut; }
            set { this.commTimeOut = value; }
        }

        /// <summary>
        /// Gets or sets the return value of the query
        /// </summary>
        public  virtual int ReturnValue
        {
            get { return this.returnVal; }
            set { this.returnVal = value ;}
        }
        #endregion

        #region ISpilConnectionManager Members

        /// <summary>
        /// 
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public abstract System.Data.IDbConnection GetConnection(string databaseName, string connectionString, int hashValue);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <returns></returns>
        public abstract System.Data.IDbConnection[] GetAllConnections(string databaseName, string connectionString);
        /// <summary>
        /// 
        /// </summary>
        public abstract void CloseConnections();
        /// <summary>
        /// 
        /// </summary>
        /// <param name="storeName"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public abstract object GetPhysicalInstanceId(string storeName, int hashValue);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="logicalStoreName"></param>
        /// <returns></returns>
        public abstract object[] GetAllPhysicalInstances(string logicalStoreName);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="logicalStoreName"></param>
        /// <param name="connectionString"></param>
        /// <param name="physicalInstanceKey"></param>
        /// <returns></returns>
        public abstract System.Data.IDbConnection GetConnectionForPhysicalInstance(string logicalStoreName, string connectionString, object physicalInstanceKey);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public abstract System.Data.IDbCommand GetCommand(string databaseName, string connectionString, int hashValue);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="logicalStoreName"></param>
        /// <param name="connectionString"></param>
        /// <param name="physicalInstanceKey"></param>
        /// <returns></returns>
        public abstract System.Data.IDbCommand GetCommandForPhysicalInstance(string logicalStoreName, string connectionString, object physicalInstanceKey);
        /// <summary>
        /// 
        /// </summary>
        /// <param name="cmd"></param>
        /// <returns></returns>
        public abstract System.Data.IDataAdapter GetDataAdapterForCommand(System.Data.IDbCommand cmd);

        #endregion

        #region IDisposable Members
        /// <summary>
        /// 
        /// </summary>
        public abstract void Dispose();
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\DataStoreInterfaces.cs ===
/*
 *  DataStoreInterfaces.cs
 * 
 *  Defines the interfaces required for any data store connection
 *  manager implementation. These Data store connection manager 
 *  interfaces support query and translation of virtual values 
 *  into required connection for the physical instance of database.
 * 
 * Revision History:
 *  Aug 2002    - MuraliK  - created initial version
 */
using System;
using System.Data;
using System.Collections;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// ISpilConnectionManager defines the interface that helps
    ///  to translate the supplied (databaseName, hashValue) into
    ///  a SQL connection object. Additional parameter of connectionString
    ///  is supplied to formulate the full connection string for a connection.
    ///  
    /// A partition aware object implementing this interface will do all it could
    ///  to use the partition id and fetch the right Sql connection.
    /// 
    /// A non-partition aware object implementing this interface may ignore
    ///  the partition id and return connection based on predefined heuristics.
    ///  
    /// In addition the object implementing this interface may also maintain a 
    ///  stateful local cache of connections associated with the object's context.
    ///  This provides a means for transactions to utilize the same connection
    ///   for the same (databaseName, hashValue) combo.
    /// 
    /// </summary>
    public interface ISpilConnectionManager : IDisposable{

        /// <summary>
        /// Provides a SQL connection based on supplied parameters.
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database.
        /// The value of DataStoreComponent.HashValueForAnyInstance (-1) is reserved to indicate ANY partition.
        /// </param>
        /// <returns></returns>
        IDbConnection GetConnection( string databaseName, string connectionString, int hashValue);

        /// <summary>
        /// Provides an array of SQL connections for the 
        ///  the individual physical partitions of a single database resource
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <returns></returns>
        IDbConnection[] GetAllConnections( string databaseName, string connectionString);

        /// <summary>
        /// Closes any open connections held by the Connection manager.
        /// The caller should call at the end of sequence of calls.
        /// Not doing such proactive means:
        ///  - connections will be drained from the connection pool 
        ///  - big memory commitment
        ///  - the system has to wait for garbage collector to search
        ///   and free the connections.
        ///  So it is best that the caller call this function proactively
        /// </summary>
        void CloseConnections();

        /// <summary>
        /// Gets the physical partition id corresponding to the logical partition id.
        /// The physical instance id can be of any type so an object is returned by this function.
        /// In most cases, it will be an integer such as physical partition number.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="hashValue">the logical partition id</param>
        /// <returns>the physical partition id</returns>
        object GetPhysicalInstanceId( string storeName, int hashValue);

        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="logicalStoreName">name of the logical database or logical Webstore application</param>
        /// <returns>a collection object consisting of a "cookie" data or handle or key
        ///  to identify the distinct physical instances</returns>
        object[] GetAllPhysicalInstances( string logicalStoreName);

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        ///  returns a connection object for accessing the specific database.
        /// </summary>
        /// <param name="logicalStoreName">name of the logical database or logical WebStore application</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceKey">Key (or cookie data) for specifying the target physical instance.
        ///  The caller cannot fabricate these values. The values passed in here should have obtained from 
        ///  a prior call to the GetAllPhysicalInstances()
        /// </param>
        /// <returns>an interface to the database connection object</returns>
        IDbConnection GetConnectionForPhysicalInstance( string logicalStoreName, string connectionString, object physicalInstanceKey); 

        //---------------------------------------------------------------------
        /// <summary>
        /// Provides a command object for the connection created with the given
        /// parameters.  Using this function rather than the GetCommand() 
        /// function of the connection object will ensure that the command will
        /// utilize any transactional support, or other features, provided by
        /// the connection manager object.
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database.
        /// The value of DataStoreComponent.HashValueForAnyInstance (-1) is reserved to indicate ANY partition.
        /// </param>
        /// <returns>an interface to the database command object</returns>
        IDbCommand GetCommand(string databaseName, string connectionString, int hashValue);

        //---------------------------------------------------------------------
        /// <summary>
        /// Given the (logical database, physical instance id/key) this 
        /// function returns a command object for the specified connection.
        /// Using this function rather than the GetCommand() function of the 
        /// connection object will ensure that the command will utilize any 
        /// transactional support, or other features, provided by the 
        /// connection manager object.
        /// </summary>
        /// <param name="logicalStoreName">name of the logical database or logical WebStore application</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceKey">Key (or cookie data) for specifying the target physical instance.
        ///  The caller cannot fabricate these values. The values passed in here should have obtained from 
        ///  a prior call to the GetAllPhysicalInstances()
        /// </param>
        /// <returns>an interface to the database command object</returns>
        IDbCommand GetCommandForPhysicalInstance( string logicalStoreName, string connectionString, object physicalInstanceKey); 

        /// <summary>
        /// Gets the timeout value(in seconds) for the connection. All
        /// connections in a connection manager share the same timeout value.
        /// </summary>
        int ConnectionTimeOut {get;}  

        /// <summary>
        /// Gets or sets the timeout value(in seconds) for the command. All
        /// commands in a connection manager share the same timeout value.
        /// </summary>
        int CommandTimeOut {get; set;}

        /// <summary>
        /// Gets or sets the return value for the command. This value is only set when the query
        /// has completed. Otherwise its value equals to <see cref="ProcedureResults.InvalidProcedureReturnValue"/>
        /// </summary>
        int ReturnValue { get; set; }
        //---------------------------------------------------------------------
        /// <summary>
        /// Creates an appropriate data adapter object for the types of 
        /// connections managed by the connection manager object.
        /// </summary>
        IDataAdapter GetDataAdapterForCommand(IDbCommand cmd);

    } // interface ISpilConnectionManager

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\DataLoader.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Text;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for DataLoader.
	/// </summary>
	public class DataLoader
	{
		private DataLoader()
		{
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="database"></param>
		/// <param name="sql"></param>
		/// <param name="scm"></param>
		/// <param name="connectionString"></param>
		public static void LoadSql(string database, string sql, ISpilConnectionManager scm, string connectionString)
		{
			SqlConnection conn = (SqlConnection)scm.GetConnection(database, connectionString, 0);
				SqlCommand cmd = new SqlCommand(sql, conn);
				cmd.CommandType = CommandType.Text;
				cmd.ExecuteNonQuery();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="database"></param>
		/// <param name="tableName"></param>
		/// <param name="fileName"></param>
		/// <param name="scm"></param>
		/// <param name="connectionString"></param>
		public static void LoadFile(string database, string tableName, string fileName, ISpilConnectionManager scm, string connectionString)
		{
			// load xml from file
			DataSet ds = new DataSet();
			ds.ReadXml(fileName, XmlReadMode.InferSchema);
			if (ds.Tables.Count != 1)
			{
				throw new DbAssertionException("Load file failed during setup. Table count is more than 1 in Xml data file");
			}
			DataTable dt = ds.Tables[0];
			StringBuilder sb = new StringBuilder();
			sb.AppendFormat("insert into [{0}] (", tableName);
			// Iterate the datatable columns
			for(int i = 0; i < dt.Columns.Count; i++)
			{
				// Add the column name
				sb.Append(dt.Columns[i].ColumnName);
				if (i != dt.Columns.Count - 1)
					sb.Append(" ,");
			}
			sb.Append(") values (");
			string header = sb.ToString();
			SqlConnection conn = (SqlConnection)scm.GetConnection(database, connectionString, 0);
			// Iterate rows in the dataset
			foreach(DataRow dr in dt.Rows)
			{
				// Create the sql insert command for each row
				sb = new StringBuilder(header);
			
				// Iterate the datatable columns
				for(int i = 0; i < dt.Columns.Count; i++)
				{
					// Add the column value for this row
					sb.Append("'").Append(dr[i].ToString().Replace("'","''")).Append("'");
					if (i != dt.Columns.Count - 1)
						sb.Append(" ,");
				}
				sb.Append(")");
				Console.WriteLine(sb.ToString());
				// Create and execute the insert command
				SqlCommand cmd = new SqlCommand(sb.ToString(), conn);
				cmd.CommandType = CommandType.Text;
				cmd.ExecuteNonQuery();
			}	
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="bcp"></param>
		public static void LoadBcp(string bcp)
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\EventHandlerSet.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Runtime.CompilerServices;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for EventHandlerSet.
	/// </summary>
	public class EventHandlerSet : IDisposable
	{
        private Hashtable events = new Hashtable();
		
        /// <summary>
        /// An index property that gets or sets the delegate associated with the hash key
        /// </summary>
        public virtual Delegate this[Object eventKey]
        {
            get { return (Delegate) events[eventKey]; }
            set { events[eventKey] = value; }
        }

        /// <summary>
        /// Add a delegate for the indicated event with given hash key
        /// </summary>
        /// <param name="eventKey"></param>
        /// <param name="handler"></param>
        public virtual void AddHandler(Object eventKey, Delegate handler)
        {
            events[eventKey] = Delegate.Combine((Delegate) events[eventKey], handler);
        }

        /// <summary>
        /// Removes a delegate for the indicated event with given hash key
        /// </summary>
        /// <param name="eventKey"></param>
        /// <param name="handler"></param>
        public virtual void RemoveHandler(Object eventKey, Delegate handler)
        {
            events[eventKey] = Delegate.Remove((Delegate) events[eventKey], handler);
        }

        /// <summary>
        /// Fire the event
        /// </summary>
        /// <param name="eventKey"></param>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public virtual void Fire(Object eventKey, Object sender, EventArgs e)
        {
            Delegate d = (Delegate) events[eventKey];
            if (d!=null) d.DynamicInvoke(new Object[]{sender, e});
        }

        /// <summary>
        /// Synchronized version
        /// </summary>
        /// <param name="eventHandlerSet"></param>
        /// <returns></returns>
        public static EventHandlerSet Synchronized(EventHandlerSet eventHandlerSet)
        {
            if (eventHandlerSet == null)
            {
                throw new ArgumentNullException("eventHandlerSet");
            }
            return new SynchronizedEventHandlerSet(eventHandlerSet);
        }
        
        private class SynchronizedEventHandlerSet : EventHandlerSet
        {
            private EventHandlerSet eventHandlerSet;

            public SynchronizedEventHandlerSet(EventHandlerSet eventHandlerSet)
            {
                this.eventHandlerSet = eventHandlerSet;
                Dispose(); // let the base type's hash table object be freed
            }

            public override Delegate this[Object eventKey]
            {
                [MethodImpl(MethodImplOptions.Synchronized)]
                get { return eventHandlerSet[eventKey];}
                [MethodImpl(MethodImplOptions.Synchronized)]
                set { eventHandlerSet[eventKey] = value;}
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public override void AddHandler(Object eventKey, Delegate handler)
            {
                eventHandlerSet.AddHandler(eventKey, handler);
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public override void RemoveHandler(Object eventKey, Delegate handler)
            {
                eventHandlerSet.RemoveHandler(eventKey, handler);
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public override void Fire(Object eventKey, Object sender, EventArgs e)
            {
                eventHandlerSet.Fire(eventKey, sender, e);
            }
        }

        #region IDisposable Members

        /// <summary>
        /// Disposing the object
        /// </summary>
        public void Dispose()
        {
            events = null;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\IFileConverter.cs ===
using System;
using System.Data;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for IFileConverter.
	/// </summary>
	public interface IFileConverter
	{
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="fileName"></param>
		void ReadFromFile(DataSet ds, string fileName);
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="input"></param>
		void ReadFromString(DataSet ds, string input);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\DataStoreTraceEventArgs.cs ===
using System;
using System.Diagnostics;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Type defining information passed to the receiver of trace message
	/// </summary>
	[Serializable]
	public class DataStoreTraceEventArgs : EventArgs
	{
        /// <summary>
        /// Constructor. Create a trace event argument with designated trace level and message
        /// </summary>
        /// <param name="level"></param>
        /// <param name="message"></param>
        /// <param name="source"></param>
        public DataStoreTraceEventArgs(TraceLevel level, string message, string source)
		{
		    this.TraceLevel = level;
	        this.Message = message;
		}

        /// <summary>
        /// Get the trace level of this message
        /// </summary>
        public readonly TraceLevel TraceLevel;
        /// <summary>
        /// Get the content of the message
        /// </summary>
        public readonly string Message;
        /// <summary>
        /// Get the source object of the event
        /// </summary>
        public readonly string Source;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\ExcelFileConverter.cs ===
using System;
using System.Data;
using System.Data.OleDb;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Convert an Excel file to <see cref="DataSet"/>
	/// </summary>
	public class ExcelFileConverter : IFileConverter
	{

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="filePath"></param>
		public void ReadFromFile(DataSet ds, string filePath)
		{
			string pathName = Path.GetDirectoryName(filePath);
			string fileName = Path.GetFileName(filePath);
			int workSheetNumber = 0; // use default 
			using(OleDbConnection excelConnection = new OleDbConnection(@"Provider=Microsoft.Jet.OLEDB.4.0;Data Source="+pathName+@"\"+fileName+";Extended Properties=Excel 8.0;"))
			{
				OleDbCommand excelCommand = new OleDbCommand();
				excelCommand.Connection = excelConnection;
				OleDbDataAdapter excelAdapter = new OleDbDataAdapter(excelCommand);

				excelConnection.Open();
				DataTable excelSheets = excelConnection.GetOleDbSchemaTable(System.Data.OleDb.OleDbSchemaGuid.Tables,new object[] {null, null, null, "TABLE"});
				string SpreadSheetName = "["+excelSheets.Rows[workSheetNumber]["TABLE_NAME"].ToString()+"]";

				excelCommand.CommandText = @"SELECT * FROM "+SpreadSheetName;
				excelAdapter.Fill(ds);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="xml"></param>
		public void ReadFromString(DataSet ds, string xml)
		{
			throw new NotSupportedException("csv string is not supported.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\IDataStore.cs ===
using System;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Interface for generated data caller
	/// </summary>
	public interface IDataStore
	{
        /// <summary>
        /// Gets the current <see cref="DataStoreContext"/>
        /// </summary>
        DataStoreContext Context {get;}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\TransactionWrapper.cs ===
using System;
using System.Runtime.InteropServices;
using System.EnterpriseServices;
using System.Reflection;
using System.Threading;
using System.Data.SqlClient;
using System.Data;
using System.Collections;

namespace Microsoft.Subscriptions.Data
{

    /// <summary>
    /// encapsulates the gross logic of having to dispense transaction from DTC directly
    /// </summary>
    internal class TransactionDispenser
    {
        internal static readonly Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

        [DllImport("XOLEHLP", PreserveSig=false)]
        internal static extern void
            DtcGetTransactionManagerEx(int pszHost, 
            int pszTmName, 
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid iid,
            int grfOptions,
            int pvConfigParams,
            [Out, MarshalAs(UnmanagedType.Interface)] out Object pDisp);


        [ DllImport( "ADVAPI32", SetLastError=true, CharSet=CharSet.Auto )]
        internal static extern bool OpenThreadToken(
            IntPtr ThreadHandle,  
            System.UInt32 DesiredAccess,  
            bool OpenAsSelf,      
            ref IntPtr TokenHandle   
            );

        [ DllImport( "ADVAPI32", SetLastError=true, CharSet=CharSet.Auto )]
        internal static extern bool SetThreadToken(
            IntPtr Thread,
            IntPtr Token   
            );

        [DllImport("ADVAPI32", SetLastError=true)]
        internal static extern bool RevertToSelf( );
        
        [ DllImport( "Kernel32", CharSet=CharSet.Auto )]
        internal static extern IntPtr GetCurrentThread();

        [DllImport("Kernel32", SetLastError=true)]
        internal static extern bool CloseHandle( IntPtr handle );

        /// <summary>
        /// This interface is implemented by the DTC to create transactions
        /// </summary>
        [
            ComImport,
            Guid("3A6AD9E1-23B9-11cf-AD60-00AA00A74CCD"),
            InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
            ]
            internal interface ITransactionDispenser
        {
            void GetOptionsObject( [Out, MarshalAs(UnmanagedType.Interface)] out Object ppoptions);

            void BeginTransaction (
                IntPtr punkOuter,
                int isoLevel,
                int isoFlags,
                IntPtr pOptions,
                [Out, MarshalAs(UnmanagedType.Interface)] out Object ppTransaction );
        }

        private ITransactionDispenser m_dispenser;

        public TransactionDispenser()
        {
            try
            {
                // first revert to impersonating the process token, otherwise DTC blows up
                const int TOKEN_IMPERSONATE = 4;
                const int TOKEN_QUERY = 8;

                IntPtr threadtoken  = IntPtr.Zero;
                OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE|TOKEN_QUERY, true, ref threadtoken);
                try
                {
                    if (threadtoken != IntPtr.Zero)
                    {
                        RevertToSelf();
                    }

                    // get the dispenser
                    Object dispenser = null;
                    DtcGetTransactionManagerEx(0, 0, IID_IUnknown, 0, 0, out dispenser);
                    m_dispenser = dispenser as ITransactionDispenser;
                }
                finally
                {
                    // go back
                    if (threadtoken != IntPtr.Zero)
                    {
                        SetThreadToken(IntPtr.Zero,threadtoken);
                        CloseHandle(threadtoken);
                    }
                }
            }
            catch(Exception)
            {
                // this keeps the exception from getting filtered, avoid a security hole in VB.Net
                throw;
            }
        }

        ~TransactionDispenser()
        {
            Marshal.ReleaseComObject(m_dispenser);
            m_dispenser = null;
        }

        public ITransaction BeginTransaction(IsolationLevel isolevel)
        {
            Object pTransaction = null;
            m_dispenser.BeginTransaction(IntPtr.Zero, (int)isolevel,0, IntPtr.Zero, out pTransaction);
            return pTransaction as ITransaction;
        }
    }

    /// <summary>TIP (transaction internet protocol) transaction interface</summary>
    [ComImport,
     Guid("17CF72D0-BAC5-11d1-B1BF-00C04FC2F3EF"),
     InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ITipTransaction
    {
        /// <summary>send TIP push command</summary>
        /// <param name="remoteTmUrl">destination transaction manager's TIP URL</param>
        /// <param name="remoteTxUrl">TIP URL</param>
        void Push(
            [In, MarshalAs(UnmanagedType.LPStr)]
            string remoteTmUrl,
            [Out, MarshalAs(UnmanagedType.LPStr)] 
            out string remoteTxUrl);

        /// <summary>Get the TIP URL of this transaction</summary>
        /// <param name="localTxUrl">the TIP URL</param>
        void GetTransactionUrl(
            [Out, MarshalAs(UnmanagedType.LPStr)] 
            out string localTxUrl);
    }


    /// <summary>
    /// Specifies the scope of transaction that is supported by the transaction wrapper. SingleSqlDatabase
    /// transactions are much faster than DTC transactions, but cannot span multiple databases.
    /// </summary>
    public enum TransactionScope
    {
        /// <summary>
        /// Does not use any transactioning within this context. This scope may be contained within other transaction scopes, but
        /// other transaction scopes may not be contained within it.
        /// </summary>
        None,
        /// <summary>
        /// Uses the DTC to coordinate the transaction commit
        /// </summary>
        DTC,
        /// <summary>
        /// Uses native SQL transactions to provide support on a single database
        /// </summary>
        SingleSqlDatabase
    }

   
    /// <summary>
    /// A smartpointer type class for creating transaction contexts. These may be nested
    /// as many levels deep as is wanted. However, only the final commit will commit if all
    /// of the nested transactions called SetComplete.
    /// 
    /// This class is designed to be used with the "using" statement in C#. Unpredictable behaviour
    /// will result if this object is created in a different manner.
    /// </summary>
    public class TransactionWrapper : IDisposable
    {
        /// <summary>
        /// Contains all the data that should be stored on the thread local context
        /// </summary>
        private class TransactionRootData
        {
            public ITransaction m_transaction = null;
            public TransactionScope m_transactionScope = TransactionScope.DTC;
            public bool m_hasAborted = false;

            public string m_singleDatabaseString = null;
            public IDbTransaction m_singleDatabaseTransaction = null;
            public IsolationLevel m_isolationLevel = IsolationLevel.ReadCommitted;
            public int m_noneReferenceCount = 0;

            /// <summary>
            /// stores all the connections we have retrieved so far
            /// </summary>
            public Hashtable m_connections;
        }

        [ThreadStatic] private static TransactionRootData ms_root;
        private static TransactionDispenser ms_dispenser = new TransactionDispenser();
        /// <summary>
        /// Records wether SetComplete was called. If the wrapper is destroyed before this flag is set, we assume that the
        /// transaction was aborted.
        /// </summary>
        private bool m_hasCommitted = false;
        /// <summary>
        /// Records whether this is the root wrapper. Only the root wrapper actually commits the transaction.
        /// </summary>
        private bool m_isRoot = false;

        /// <summary>
        /// Constructs a new TransactionWrapper with the default scope of DTC and isolation level
        /// of ReadCommitted.
        /// 
        /// TransactionWrappers should always be created with the
        /// "using" statement in order to ensure proper transactional behaviour.
        /// </summary>
        public TransactionWrapper() : this(TransactionScope.DTC)
        {
        }

        /// <summary>
        /// Constructs a new TransactionWrapper with the isolation level
        /// of ReadCommitted. 
        /// 
        /// TransactionWrappers should always be created with the
        /// "using" statement in order to ensure proper transactional behaviour.
        /// </summary>
        /// <param name="scope">Specifies the scope of the wrapper. DTC scoped transaction can
        /// contain Sql scoped transaction, but not vice versa.</param>
        public TransactionWrapper(TransactionScope scope) : this(scope, IsolationLevel.ReadCommitted)
        {
        }

        /// <summary>
        /// Constructs a new TransactionWrapper. 
        /// 
        /// TransactionWrappers should always be created with the
        /// "using" statement in order to ensure proper transactional behaviour.
        /// </summary>
        /// <param name="scope">Specifies the scope of the wrapper. DTC scoped transaction can
        /// contain Sql scoped transaction, but not vice versa. None scoped transactions can be wrapped inside any
        /// transaction, but no transactions may be wrapped inside None scoped transactions</param>
        /// <param name="isoLevel">Specifies the isolation level of the transaction. If this transaction
        /// is contained within another transaction, the isolation level must be equal or lower than the
        /// outer transaction, or we throw an exception. Ignored for None scoped transactions.</param>
        public TransactionWrapper(TransactionScope scope, IsolationLevel isoLevel)
        {
            if (ms_root == null)
            {
                ms_root = new TransactionRootData();
                ms_root.m_transactionScope = scope;
                ms_root.m_isolationLevel = isoLevel;
                m_isRoot = true;
            }
            else
            {
                if (scope != TransactionScope.None && isoLevel > ms_root.m_isolationLevel)
                {
                    throw new ApplicationException("Isolation level of outer TransactionWrapper is lower than the current transaction");
                }
                if (scope == TransactionScope.DTC &&
                    ms_root.m_transactionScope == TransactionScope.SingleSqlDatabase)
                {
                    throw new ApplicationException("Cannot have DTC transaction scope inside a single database transaction scope");
                }
                if (scope != TransactionScope.None && 
                    (ms_root.m_transactionScope == TransactionScope.None || ms_root.m_noneReferenceCount > 0) )
                {
                    throw new ApplicationException("Cannot contain transactions within a non-transacted scope");
                }
                if (scope == TransactionScope.None)
                {
                    ms_root.m_noneReferenceCount++;
                }
            }
        }

        /// <summary>
        /// Frees a TransactionWrapper. Dispose MUST be called before the finalizer happens, or very
        /// bad things will happen.
        /// </summary>
        public void Dispose()
        {
            if (ms_root == null)
                return;

            if (m_isRoot)
            {
                try
                {
                    if (ms_root.m_transaction != null)
                    {
                        // We are a DTC transaction
                        try
                        {
                            if (m_hasCommitted && !ms_root.m_hasAborted)
                            {
                                ms_root.m_transaction.Commit(0,0,0);
                            }
                            else
                            {
                                BOID boid = new BOID();
                                ms_root.m_transaction.Abort(ref boid, 0, 0);
                            }
                        }
                        finally
                        {
                            Marshal.ReleaseComObject(ms_root.m_transaction);
                            ms_root.m_transaction = null;
                        }
                    }
                    else if (ms_root.m_singleDatabaseTransaction != null)
                    {
                        // We are a SQL transaction
                        try
                        {
                            if (m_hasCommitted && !ms_root.m_hasAborted)
                            {
                                ms_root.m_singleDatabaseTransaction.Commit();
                            }
                            else
                            {
                                ms_root.m_singleDatabaseTransaction.Rollback();
                            }
                        }
                        finally
                        {
                            ms_root.m_singleDatabaseTransaction.Dispose();
                            ms_root.m_singleDatabaseTransaction = null;
                        }
                    }
                }
                finally
                {
                    // we need to close the connections after the transaction commits, or we will
                    // hang DTC
                    if (ms_root.m_connections!=null)
                    {
                        foreach(DictionaryEntry entry in ms_root.m_connections)
                        {
                            try
                            {
                                (entry.Value as IDbConnection).Close();
                            }
                            catch(Exception)
                            {
                                // ignore exceptions that happen during Close
                            }
                        }
                        ms_root.m_connections = null;
                    }

                    ms_root = null;
                }
            }
            else
            {
                if (ms_root!=null && ms_root.m_noneReferenceCount > 0)
                {
                    // none transactions can't do a setcomplete
                    ms_root.m_noneReferenceCount--;
                }
                else
                {
                    if (!m_hasCommitted && ms_root!=null)
                    {
                        ms_root.m_hasAborted = true;
                    }
                }
            }
        }

		/// <summary>
		/// Backwards compatibility wrapper for OpenConnection that returns a SqlConnection 
		/// </summary>
		/// <param name="connectionString">The connection string to use</param>
		/// <returns>The connection we have created</returns>
		public static SqlConnection OpenConnection(string connectionString)
		{
			return OpenConnection(connectionString, typeof(SqlConnection)) as SqlConnection;
		}

        /// <summary>
        /// Creates and opens a connection of user specified type, taking into account the current transactional state. 
        /// 
        /// If we are currently within a DTC transaction, the connection is automatically enlisted in 
        /// that transaction.
        /// 
        /// If we are within a Sql transaction, we begin a transaction. Note that only one unique connection
        /// is allowed within a Sql transaction (since we cannot span databases), so we throw an exception
        /// if this is called for more than one unique connection string.
        /// 
        /// If we are not within a transaction, we simply create the SqlConnection and open it.
        /// 
        /// We must use the static CloseConnection method to close the connection, otherwise DTC will hang
        /// when trying to commit the transaction.
        /// </summary>
        /// <param name="connectionString">The connection string to use</param>
        /// <param name="connectionObjectType">The type of connection to create</param>
        /// <returns>The connection we have created</returns>
        public static Object OpenConnection(string connectionString, Type connectionObjectType)
        {
			Object conn;

            // if we are not in a transaction, just act normal
            if (CurrentScope == TransactionScope.None)
            {
				conn = connectionObjectType.InvokeMember(null, BindingFlags.CreateInstance, null, null, new Object[] { connectionString } );
                ((IDbConnection)conn).Open();
                return conn;
            }

            if (ms_root.m_hasAborted)
            {
                throw new ApplicationException("Transaction has been aborted");
            }

            if (ms_root.m_connections==null)
            {
                ms_root.m_connections = new Hashtable();
            }

            conn = ms_root.m_connections[ connectionString ];
            if (conn!=null)
                return conn;

            if (ms_root.m_transactionScope == TransactionScope.SingleSqlDatabase)
            {
                if (ms_root.m_connections.Count > 0)
                {
                    throw new InvalidOperationException("Cannot use a SingleSqlDatabase transaction on more than one connection");
                }

				conn = connectionObjectType.InvokeMember(null, BindingFlags.CreateInstance, null, null, new Object[] { connectionString } );
				((IDbConnection)conn).Open();
				
				ms_root.m_connections.Add( connectionString, conn );

                ms_root.m_singleDatabaseTransaction = ((IDbConnection)conn).BeginTransaction(ms_root.m_isolationLevel);
            }
            else
            {
                if (ms_root.m_transaction == null)
                {
                    ms_root.m_transaction = ms_dispenser.BeginTransaction(ms_root.m_isolationLevel);
                }

				conn = connectionObjectType.InvokeMember(null, BindingFlags.CreateInstance, null, null, new Object[] { connectionString } );
				((IDbConnection)conn).Open();
				
				ms_root.m_connections.Add( connectionString, conn );

                // Call 1.1 Framework method to enlist in transaction. We want to bind to the 1.1 runtime if it is available,
                // but we can't compile to it, since the 1.0 framework isn't "unified"
                conn.GetType().InvokeMember("EnlistDistributedTransaction", BindingFlags.InvokeMethod, null, conn, new Object[] {ms_root.m_transaction} );
            }

            return conn;
        }

        /// <summary>
        /// Creates a new SqlCommand object. If we are within a Sql transaction, we also set the
        /// Transaction field of the SqlCommand to the current transaction object. 
        /// 
        /// If we are within a DTC transaction or not within a transaction, we just create a new 
        /// SqlCommand.
        /// </summary>
        /// <param name="command">The command to initialize</param>
        public static void InitCommand(IDbCommand command)
        {
            // if we are not in a transaction, just act normal
            if (CurrentScope == TransactionScope.None)
            {
                return;
            }

            if (ms_root.m_hasAborted)
            {
                throw new ApplicationException("Transaction has been aborted");
            }

            if (ms_root.m_transactionScope == TransactionScope.SingleSqlDatabase)
            {
                command.Transaction = ms_root.m_singleDatabaseTransaction;
            }
        }

        /// <summary>
        /// Closes the connection if we are not within a transaction. If we are in a transaction, Dispose
        /// will close the connection after it has been committed or rolled  back.
        /// </summary>
        /// <param name="conn"></param>
        public static void CloseConnection(Object conn)
        {
            if (CurrentScope == TransactionScope.None ||
                ms_root.m_connections==null || 
                !ms_root.m_connections.ContainsValue(conn))
            {
                ((IDbConnection)conn).Close();
            }
        }

        /// <summary>
        /// Returns the current scope we are running as
        /// </summary>
        public static TransactionScope CurrentScope
        {
            get
            {
                if (ms_root==null || ms_root.m_noneReferenceCount > 0)
                {
                    return TransactionScope.None;
                }
                else
                {
                    return ms_root.m_transactionScope;
                }
            }
        }


        /// <summary>
        /// Thows an exception if the current thread is running within a transaction
        /// </summary>
        public static void AssertNoTransaction()
        {
            if (CurrentScope != TransactionScope.None)
            {
                throw new InvalidOperationException("Operation cannot be run within the context of a transaction");
            }
        }

        /// <summary>
        /// This method should be called just before the end of the "using" block. It lets the TransactionWrapper
        /// know that the block completed without throwing an exception. If SetComplete was not called
        /// before Dispose was called, then we automatically abort the transaction.
        /// </summary>
        public void SetComplete()
        {
            if (CurrentScope == TransactionScope.None)
            {
                throw new InvalidOperationException("Cannot call SetComplete on a None transaction scope");
            }

            m_hasCommitted = true;
        }

        /// <summary>get the TIP url of the current DTC transaction</summary>
        /// <remarks>The current thread's transaction is used to get the TIP URL. Make
        /// sure you have a running DTC transaction before calling this method.</remarks>
        /// <returns>TIP URL</returns>
        /// <exception cref="InvalidOperationException">if no DTC transaction is running
        /// </exception>
        public static string CurrentTipUrl {
            get 
            {
                if(CurrentScope != TransactionScope.DTC)
                    throw new InvalidOperationException("no running DTC transaction");

                if(ms_root.m_transaction == null)
                {
                    ms_root.m_transaction = ms_dispenser.BeginTransaction(
                        ms_root.m_isolationLevel);
                }
                ITipTransaction tipTransaction = (ITipTransaction) ms_root.m_transaction;
                string url;
                tipTransaction.GetTransactionUrl(out url);
                return url;
            }
        }
       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\SimpleConnectionManager.cs ===
/*
 *  SimpleConnectionManager.cs
 * 
 *  This class is an implementation of ISpilConnectionManager 
 *  using ADO.NET. 
 *  SimpleConnectionManager only manages one physical server for a logical database. 
 * 
 * Revision History:
 *  Dec 2002    - TaoH   - added IDisposable interface support
 *  Sep 2002    - TaoH   - added GetPhysicalInstanceId
 *  Aug 2002    - Muralik - created.
 */
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;

namespace Microsoft.Subscriptions.Data {

    /// <summary>
    /// Provides a simple connection manager for use 
    ///  with a single physical instance of logical database.
    /// This object inherits from <see cref="ConnectionManagerBase"/> and 
    ///  supports method to translate logical (databaseName, partitionId) 
    ///  into SqlConnection object.
    /// This object implements the IDisposable interface so the users of this
    /// class can dispose the resources it uses.
    /// 
    /// No connection caching is done, although underlying ADO.NET does 
    ///  connection pooling for the connections with same connectionString
    /// NOTE: The class as a whole is NOT multi-thread safe. It is intended
    ///  that the instance of each class is used completely within a single 
    ///  thread and hence no multi-thread protection is built. However, 
    ///  different instances can be used within different threads.
    /// </summary>
    public class SimpleConnectionManager : ConnectionManagerBase
    {

        internal class CachedConnectionItem {
            internal string databaseName;
            internal string partialConnectionString;
            internal SqlConnection sqlConn;

            internal CachedConnectionItem( string databaseName, string connString, SqlConnection conn) {
                this.databaseName = databaseName;
                this.partialConnectionString = connString;
                this.sqlConn = conn;
            }
        }

        internal class CachedConnectionList {

            // TODO: May be use a hash table
            private ArrayList cachedConnections = null; // array of CachedConnectionItems

            internal CachedConnectionList() {}

            internal SqlConnection FindConnection( string databaseName, string connString) {

                if ( cachedConnections == null)
                    return null;

                for( int i =0; i < cachedConnections.Count; i++) 
                {
                    CachedConnectionItem cci = cachedConnections[i] as CachedConnectionItem;
                    if (cci.databaseName == databaseName && cci.partialConnectionString == connString)
                    {
                        return cci.sqlConn;
                    }
                }

                return null;
            }

            /// <summary>
            /// Adds the provided connection combo to the lookup table.
            /// No duplicate checks are made.
            /// </summary>
            /// <param name="databaseName"></param>
            /// <param name="connString"></param>
            /// <param name="conn"></param>
            internal void AddConnection( string databaseName, string connString, SqlConnection conn) {
                if ( cachedConnections == null) 
                    cachedConnections = new ArrayList();

                CachedConnectionItem cci = new CachedConnectionItem( databaseName, connString, conn);
                cachedConnections.Add( cci);
            }

            internal void CloseConnections() {
                if ( cachedConnections != null) {
                    for(int i = 0; i < cachedConnections.Count; i++) {
                        CachedConnectionItem cci = cachedConnections[i] as CachedConnectionItem;
                        if (cci.sqlConn != null) {
                            TransactionWrapper.CloseConnection(cci.sqlConn);
                        }
                    }
                    // also remove the cached connections array
                    cachedConnections = null;
                }
            }

        } // class CachedConnectionList

        
        private string serverName = null;
        private CachedConnectionList cachedList = null;
        
        /// <summary>
        /// Construct a connection manager that talks to localhost
        /// </summary>
        public SimpleConnectionManager() {
            this.serverName = "localhost";
        }
        /// <summary>
        /// Construct a connection manager that talks to localhost
        /// </summary>
        /// <param name="connectionTimeOut">the connection timeout value in seconds
        /// </param>
        public SimpleConnectionManager(int connectionTimeOut) : this()
        {
            this.connTimeOut = connectionTimeOut;
        }

        /// <summary>
        /// Construct a connection manager that talks to specified server 
        /// </summary>
        /// <param name="serverName">the server name the connection manager is connected to</param>
        /// <param name="connectionTimeOut">the connection timeout value in seconds
        /// </param>
        public SimpleConnectionManager(string serverName, int connectionTimeOut) : this(serverName)
        {
            this.connTimeOut = connectionTimeOut;
        }

        /// <summary>
        /// Default finalizer, called when this object is garbage collected.
        /// </summary>
        ~SimpleConnectionManager()
        {
            Dispose(false);
        }
        /// <summary>
        /// Construct a connection manager that talks to specified server
        /// </summary>
        /// <param name="serverName"></param>
        public SimpleConnectionManager( string serverName) {
            this.serverName = serverName;
        }

        private SqlConnection GetCachedConnection( string databaseName, string connectionString) {
 
            SqlConnection conn = null;
            
            if ( cachedList == null) {
                cachedList = new CachedConnectionList();
            } else {
                conn = cachedList.FindConnection( databaseName, connectionString);
            }

            if ( conn == null) {

                // create a connection and cache it
                string fullConnectionString = (( this.serverName == null)? connectionString : 
                    "data source=" + this.serverName + ";" 
                    + "Initial Catalog=" + databaseName + ";"
                    + "Connect TimeOut=" + this.connTimeOut + ";"
                    + connectionString); 

                conn = TransactionWrapper.OpenConnection(fullConnectionString);
                
                // TODO: Throw an exception if there is no connection formed!
                cachedList.AddConnection( databaseName, connectionString, conn);
            }

            return conn;
        }

        #region interface ISpilConnectionManager
        /// <summary>
        /// Provides a SQL connection based on supplied parameters.
        /// Since we only have one server for all databases and logical partitions
        ///  this function just returns a single standard connection.
        ///  The hashValue supplied will be ignored completely.
        /// If a previous connection request was made and that connection was cached,
        ///  then the same connection will be returned!
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database</param>
        /// <returns></returns>
        public override IDbConnection GetConnection( string databaseName, string connectionString, int hashValue) {

            return GetCachedConnection( databaseName, connectionString);
        }


        /// <summary>
        /// Provides an array of SQL connections for the 
        ///  the individual physical partitions of a single database resource
        /// </summary>
        /// <param name="databaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <returns></returns>
        public override IDbConnection[] GetAllConnections( string databaseName, string connectionString) {

            // since we are simple connection manager, we only have at most one physical partition.
            // just use the cached connection if any (or create new one and cache it)
            return new SqlConnection[] {
                        GetCachedConnection( databaseName, connectionString)
                    };
        }

        /// <summary>
        /// Closes any open connections held by the Connection manager.
        /// </summary>
        public override void CloseConnections() {
            if(cachedList != null)
            {
                cachedList.CloseConnections();
            }
        }

        /// <summary>
        /// Gets the physical instance id given a logical partition id
        /// </summary>
        /// <param name="storeName">name of the catalog</param>
        /// <param name="hashValue">logical partition id</param>
        /// <returns>physical instance id</returns>
        public override object GetPhysicalInstanceId( string storeName, int hashValue)
        {
            return 0;// since we have just one instance, always use 0;
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommand(string databaseName, string connectionString, int hashValue) 
        {

            IDbCommand command = this.GetCachedConnection(databaseName, connectionString).CreateCommand();
            TransactionWrapper.InitCommand(command);
            return command;
        } // GetCommand

        #endregion interface ISpilConnectionManager

        #region interface ISpilPhysicalConnectionManager
        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="logicalDatabaseName">name of the logical database</param>
        /// <returns>a collection object consisting of a set of physical instance IDs</returns>
        public override object[] GetAllPhysicalInstances( string logicalDatabaseName) {

            // since we have just one instance, just return an array with one entry in it.
            object[] physicalIDs = new object[1];
            physicalIDs[0] = 0;
            return physicalIDs;
        }

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        ///  returns a connection object for accessing the specific database.
        /// </summary>
        /// <param name="logicalDatabaseName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceId">ID or key for specifying the target physical instance</param>
        /// <returns>an interface to the database connection object</returns>
        public override IDbConnection GetConnectionForPhysicalInstance( string logicalDatabaseName, string connectionString, object physicalInstanceId) {

            int instanceId = (int ) physicalInstanceId;

            if ( instanceId == 0) {

                return GetCachedConnection( logicalDatabaseName, connectionString);
            }
            else
                throw new DataStoreException( "Invalid Physical instance ID supplied");
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommandForPhysicalInstance(string logicalDatabaseName, string connectionString, object physicalInstanceId) 
        {
            if (0 == (int)physicalInstanceId) 
            {
                IDbCommand command = this.GetCachedConnection(logicalDatabaseName, connectionString).CreateCommand();
                TransactionWrapper.InitCommand(command);
                return command;
            }

            throw new DataStoreException( "Invalid Physical instance ID supplied");
        } // GetCommandForPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDataAdapter GetDataAdapterForCommand(IDbCommand cmd)
        {
            return new SqlDataAdapter((SqlCommand)(cmd));
        } // GetDataAdapterForCommand

        #endregion interface ISpilPhysicalConnectionManager

        #region interface IDisposable
        /// <summary>
        /// This method should be called explicitly by the user to close the
        /// resources the connection manager uses.
        /// </summary>
        public override void Dispose()
        {
            // suppress the garbage collector clean up
            GC.SuppressFinalize(this);
            // Call the method that actually does the cleanup
            Dispose(true);
        }

        /// <summary>
        /// The common method that does the actual clean up. This method is protected
        /// because the connection manager can be inherited by other connection managers.
        /// </summary>
        /// <param name="disposing">the flag to indicate whether to dispose explicitly
        /// or by GC</param>
        protected void Dispose(bool disposing)
        {
            // need to synchronize the dispose
            lock(this)
            {
                if(disposing)
                {
                    //explicit clean up. It is safe here to dispose any objects
                    //referenced by this object.
                    CloseConnections();
                }
                //note: we cannot call CloseConnections here because by the time
                //the connection manager is GCed, we're not sure if the connection cache
                //and the connections are already GCed or not.
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\WebStoreConnectionManager.cs ===
/*
 *  WebStoreConnectionManager.cs
 * 
 *  This class is an implementation of ISpilConnectionManager 
 *  using WebStore. 
 * 
 * 
 * Revision History:
 *  Dec 2002    - TaoH   - added IDisposable interface support
 *  Sep 2002    - TaoH   - created
 */
using System;
using System.Data;
using System.Collections;
using System.Data.SqlTypes;
using Microsoft.Webstore.WstClient;

namespace Microsoft.Subscriptions.Data
{
    /// <summary>
    /// Provides a webstore connection manager for use 
    ///  with a webstore application.
    /// This object inherits from <see cref="ConnectionManagerBase"/> and 
    ///  supports method to translate logical (storeName, partitionId) 
    ///  into WstConnection object.
    /// This object implements the IDisposable interface so the users of this
    /// class can dispose the resources it uses.
    /// 
    /// The webstore connection is cached based on the storeName and the connection string
    /// This class is not thread-safe.
    /// </summary>
    public class WebStoreConnectionManager  : ConnectionManagerBase
    {
        // We cannot use SimpleConnectionManager.CachedConnectionItem
        // Because it only caches SqlConnection :-(
        // So we use a hashtable instead.
        /// <summary>
        /// Local connection cache.
        /// </summary>
        protected Hashtable connCache = new Hashtable();
        
        /// <summary>
        /// Default constructor
        /// </summary>
        public WebStoreConnectionManager()
        {
        }
        /// <summary>
        /// Construct a webstore connection manager
        /// </summary>
        public WebStoreConnectionManager(int connTimeOut)
        {
            this.connTimeOut = connTimeOut;
        }

        /// <summary>
        /// Default finalizer, called when this object is garbage collected.
        /// </summary>
        ~WebStoreConnectionManager()
        {
            Dispose(false);
        }

        

	    ///<summary>
	    ///Gets the Cached Connection based on Store Name and Connection String
	    ///</summary>
        protected IDbConnection GetCachedConnection( string storeName, string connectionString)
        {
            if(storeName == null)
                throw new DataStoreException(" store name cannot be null!");
            
            // build a key based on storeName 
            // connectionString is useless in WebStore connection
            string key = storeName.ToLower();
            WstConnection wstConn = connCache[key] as WstConnection;
            if(wstConn == null)
            {
                wstConn = TransactionWrapper.OpenConnection(storeName, typeof(WstConnection)) as WstConnection;
                connCache.Add(key, wstConn);
            }
            return wstConn;
        }

        #region interface ISpilConnectionManager
        /// <summary>
        /// Provides a WST connection based on supplied parameters.
        /// Since webstore handles the logical partitions at command level,
        ///  this function just returns a single webstore connection.
        ///  The hashValue supplied will be ignored completely.
        /// If a previous connection request was made and that connection was cached,
        ///  then the same connection will be returned!
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="hashValue">identifies the physical partition instance of the logical database</param>
        /// <returns>A webstore connection to the application</returns>
        public override IDbConnection GetConnection( string storeName, string connectionString, int hashValue) 
        {
            return GetCachedConnection( storeName, connectionString);
        }

        /// <summary>
        /// Returns webstore connections to an application as an array.
        /// Because webstore manages connection at the application level, only one connection is
        /// actually returned by this function. 
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <returns>A webstore connection to the application, packaged as an array for interface conformance.</returns>
        public override IDbConnection[] GetAllConnections( string storeName, string connectionString) 
        {
            return new IDbConnection[] {
                GetCachedConnection( storeName, connectionString)
            };
        }


        /// <summary>
        /// Closes any open connections held by the Connection manager.
        /// This method is not thread safe.
        /// </summary>
        public override void CloseConnections() 
        {
            if(connCache != null)
            {
                IDictionaryEnumerator ide = connCache.GetEnumerator();
                while(ide.MoveNext())
                {
                    WstConnection conn = ide.Value as WstConnection;
                    if(conn != null)
                        TransactionWrapper.CloseConnection(conn);
                }

                // also clear the connection cache
                connCache.Clear();
                // clear reference to connection cache
                connCache = null;
            }
        }

        /// <summary>
        /// Gets the physical instance id given a logical partition id and store name.
        /// </summary>
        /// <param name="storeName">name of the webstore application</param>
        /// <param name="hashValue">logical partition id</param>
        /// <returns>physical instance id corresponding to the logical hashValue</returns>
        public override object GetPhysicalInstanceId( string storeName, int hashValue)
        {
            WstConnection conn = GetCachedConnection(storeName, "") as WstConnection;
            //return conn.GetPhysicalPartition(hashValue);
            return conn.GetSqlPartition(hashValue); // NOTE: Custom Xonline change to avoid Compiler Level-2 Warning CS0618
		}

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommand(string databaseName, string connectionString, int hashValue) 
        {
            IDbCommand command = this.GetCachedConnection(databaseName, connectionString).CreateCommand();
			TransactionWrapper.InitCommand(command);
			return command;
		} // GetCommand
        #endregion

        #region interface ISpilPhysicalConnectionManager
        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <returns>a collection object consisting of a set of physical instance partition numbers.</returns>
        public override object[] GetAllPhysicalInstances( string storeName) 
        {
            if( storeName == null)
                throw new DataStoreException( " store name cannot be null!");
            // probably should use application specific mapping
            WstConnection conn = GetCachedConnection( storeName, null) as WstConnection;
            
            //int n = conn.PhysicalPartitions;
            int n = conn.SqlPartitions.Count; // NOTE: Custom Xonline change to avoid Compiler Level-2 Warning CS0618
			if( n == 0)
                throw new DataStoreException( " No physical partitions found for connection: "+storeName);
            // even though our physical instances are consecutive integers, we have to
            // package into an integer array.
            object[] physicalIds = new object[n];
            for(int i = 0; i < n; i ++)
            {
                physicalIds[i] = i;
            }
            return physicalIds;
        }

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        /// returns a connection object for accessing the specific webstore application.
        /// Because webstore maintains a connection at the logical application level, the physical
        /// instance id is ignored. 
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceId">ID or key for specifying the target physical instance</param>
        /// <returns>an interface to the database connection object</returns>
        public override IDbConnection GetConnectionForPhysicalInstance( string storeName, string connectionString, object physicalInstanceId) 
        {
             return GetCachedConnection( storeName, connectionString);
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDbCommand GetCommandForPhysicalInstance(string logicalDatabaseName, string connectionString, object physicalInstanceId) 
        {
            IDbCommand command = this.GetCachedConnection(logicalDatabaseName, connectionString).CreateCommand();
			TransactionWrapper.InitCommand(command);
			return command;
		} // GetCommandForPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public override IDataAdapter GetDataAdapterForCommand(IDbCommand cmd)
        {
            WstDataAdapter da = new WstDataAdapter();
            da.SelectCommand = (WstCommand)(cmd);
            return da;
        } // GetDataAdapterForCommand

        #endregion interface ISpilPhysicalConnectionManager

        #region interface IDisposable
        /// <summary>
        /// This method should be called explicitly by the user to close the
        /// resources the connection manager uses.
        /// </summary>
        public override void Dispose()
        {
            // suppress the garbage collector clean up
            GC.SuppressFinalize(this);
            // Call the method that actually does the cleanup
            Dispose(true);
        }

        /// <summary>
        /// The common method that does the actual clean up. This method is protected
        /// because the connection manager can be inherited by other connection managers.
        /// </summary>
        /// <param name="disposing">the flag to indicate whether to dispose explicitly
        /// or by GC</param>
        protected void Dispose(bool disposing)
        {
            // need to synchronize the dispose
            lock(this)
            {
                if(disposing)
                {
                    //explicit clean up. It is safe here to dispose any objects
                    //referenced by this object.
                    CloseConnections();
                }
                //note: we cannot call CloseConnections here because by the time
                //the connection manager is GCed, we're not sure if the connection cache
                //and the connections are already GCed or not.
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\TestSpil\TestSpil.cs ===
using System;
using System.Xml;
using System.Xml.Xsl;
using System.Xml.XPath;
using Microsoft.Subscriptions.Data;
using Microsoft.Subscriptions.DataStores;
using Microsoft.Webstore.WstClient; // for using webstore
using System.Data.SqlTypes;

namespace TestSpil
{
    /// <summary>
    /// Summary description for TestSpil.
    /// </summary>
    class TestSpil
    {

        private static void PrintUsage() {

            Console.Error.WriteLine( "Usage: TestSpil operation OperationParameters");
            Console.Error.WriteLine( "\t operation = { mapdb | mapwst | transform }");
            Console.Error.WriteLine( "\t Parameters for transform:   inputFile xslFile");
            Console.Error.WriteLine( "\t No Parameters for mapdb");
        }

        private static void RunMapDbTest() {

            // Let us add couple of passport number/names
            Random r = new Random();
            MapData mapCaller = new MapData(); // can be reused
            SimpleConnectionManager scm = new SimpleConnectionManager();

            // NOTE: I'm not using any XML here - just raw call with variables/data
            int user1_puid_high = r.Next();
            int user1_puid_low = r.Next();
            mapCaller.AddPassportToName( scm, user1_puid_high, user1_puid_low, "FooBarName1");

            // And then let us find the same passport number/names
            ProcedureResults prc = mapCaller.FindNameToPassport( scm, user1_puid_high, user1_puid_low);

            // NOTE: I can get the same old XML as shown below. BUT i can also directly manipulate the DataSet
            Console.WriteLine( " Results for user({0}:{1}) = {2}\r\n{3}",
                user1_puid_high, user1_puid_low, prc.ReturnValue, prc.ResultsXml);
            scm.CloseConnections();
        }


        private static void RunMapWstTest() 
        {
            // Let us add couple of passport number/names
            Random r = new Random();

            MapData mapCaller = new MapData(); // can be reused

            // NOTE: I'm not using any XML here - just raw call with variables/data
            int user1_puid_high = r.Next();
            int user1_puid_low = r.Next();
            WebStoreConnectionManager wscm = new WebStoreConnectionManager();
            string vc_member = "FooBar_" + r.Next(100);
            Console.WriteLine("Adding member: {0}, PUID: {1}{2}", vc_member, user1_puid_high, user1_puid_low);
            // NOTE: I can change the store name here
            mapCaller.StoreName = "map";
            mapCaller.AddPassportToName(wscm, user1_puid_high, user1_puid_low, vc_member);

            // And then let us find the same passport number/names
            ProcedureResults prc = mapCaller.FindNameToPassport(wscm, user1_puid_high, user1_puid_low);

            // NOTE: I can get the same old XML as shown below. BUT i can also directly manipulate the DataSet
            Console.WriteLine( " Results for user({0}:{1}) = {2}\r\n{3}",
                user1_puid_high, user1_puid_low, prc.ReturnValue, prc.ResultsXml);

            Console.WriteLine("Adding Account: {0}", vc_member);
            mapCaller.AddAccount(wscm,r.Next(),r.Next(), vc_member,
                r.Next(),(Int16)r.Next(),(Int16)r.Next(), new SqlGuid(Guid.NewGuid()));
            

            string vc_encrypted_concat_number = "An encrypted number.";
            byte ti_payment_method = 1;
            Console.WriteLine("Adding Binary {0}", vc_encrypted_concat_number);
            mapCaller.AddBinary(wscm, vc_encrypted_concat_number,r.Next(),(Int16)r.Next(),(Int16)r.Next(),"Citi",ti_payment_method,r.Next(),false);

            int i_PuidHigh = r.Next();
            int i_PuidLow = r.Next();
            Console.WriteLine("Adding PUID {0}-{1}",i_PuidHigh,i_PuidLow);
            mapCaller.AddId(wscm, i_PuidHigh, i_PuidLow ,r.Next(),(Int16)r.Next(),(Int16)r.Next(),new SqlGuid(Guid.NewGuid()));

            Console.WriteLine("Searching for PUID {0}-{1}",i_PuidHigh,i_PuidLow);
            ProcedureResults prc1 = mapCaller.FindId(wscm,i_PuidHigh, i_PuidLow);
            // NOTE: I can get the same old XML as shown below. BUT i can also directly manipulate the DataSet
            Console.WriteLine( " Results for user({2}:{3}) = {0}\r\n{1}\n",
                prc1.ReturnValue, prc1.ResultsXml, i_PuidHigh, i_PuidLow);

            Console.WriteLine("Finding Binary {0}", vc_encrypted_concat_number);
            ProcedureResults prc2 = mapCaller.FindBinary(wscm, vc_encrypted_concat_number, ti_payment_method, 20);
            Console.WriteLine( " Results for finding binary = {0}\r\n{1}\n",
                prc2.ReturnValue, prc2.ResultsXml);

            Console.WriteLine("Finding Passport to name: {0}", vc_member);
            ProcedureResults prc4 = mapCaller.FindPassportToName(wscm, vc_member);
            Console.WriteLine( " Results for finding binary = {0}\r\n{1}\n",
                prc4.ReturnValue, prc4.ResultsXml);

        }


        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] args)
        {
            if (args.Length < 1) {
                PrintUsage();
                return -1;
            }

            switch (args[0]) {
                case "transform":
                    if ( args.Length < 3) {
                        Console.Error.WriteLine( "Insufficient parameters for transform.");
                        PrintUsage();
                        return -2;
                    }
                    DoCustomTransform( args[1], args[2]);
                    break;

                case "mapdb":
                    RunMapDbTest();
                    break;

                case "mapwst":
                    RunMapWstTest();
                    break;

                default:
                    PrintUsage();
                    return -3;
            }
            return 0;
        } // Main


        /// <summary>
        ///  Sample code to check out how the transforms function inside .NET framework
        /// </summary>
        /// <param name="inputFile"></param>
        /// <param name="transformFile"></param>
        static void DoCustomTransform( string inputFile, string transformFile) {
            try {
                XmlDocument doc = new XmlDocument();
                doc.Load( inputFile);
            
                XslTransform transform = new XslTransform();
                transform.Load( transformFile);
                transform.Transform( doc, null, Console.Out);
            }
            catch (XsltCompileException xce) {
                Console.WriteLine( "XSLTException occured: {0}\r\nStack:\r\n{1}",
                    xce.Message, xce.StackTrace);
                Console.WriteLine( "XSLT Compiler Exception (Line: {0}, {1}), {2}", 
                    xce.LineNumber, xce.LinePosition, xce.TargetSite);
            }
            catch ( XsltException xe) {
                Console.WriteLine( "XSLTException occured: {0}\r\nStack:\r\n{1}",
                    xe.Message, xe.StackTrace);
                Console.WriteLine( "XSLT Exception (Line: {0}, {1}), {2}", 
                    xe.LineNumber, xe.LinePosition, xe.TargetSite);
            }
            catch (Exception e) {
                Console.WriteLine( "Exception occured: {0}\r\nStack:\r\n{1}\r\n Type={2}",
                    e.Message, e.StackTrace, e.GetType());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\TowerPartitionConnectionManager\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
	

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

//[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("..\\..\\..\\build\\SPGKey.snk")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\SpilRun\XmlFileConverter.cs ===
using System;
using System.Data;
using System.IO;

namespace Microsoft.Subscriptions.Data
{
	/// <summary>
	/// Summary description for XmlFileConverter.
	/// </summary>
	public class XmlFileConverter : IFileConverter
	{
		/// <summary>
		/// 
		/// </summary>
		public XmlFileConverter()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="fileName"></param>
		public void ReadFromFile(DataSet ds, string fileName)
		{
			// read a file into dataset
			ds.ReadXml(fileName, XmlReadMode.InferSchema);
			return;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="ds"></param>
		/// <param name="xml"></param>
		public void ReadFromString(DataSet ds, string xml)
		{
			using(StringReader sr = new StringReader(xml))
			{
				ds.ReadXml(sr);
			}
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\TowerPartitionConnectionManager\Globals.cs ===
using System;
using CoreSDK;

namespace Microsoft.Subscriptions.Tower
{
    /// <summary>
    /// Summary description for Globals.
    /// </summary>
    internal class Globals
    {
        static Globals()
        {
            Tracer.SetRegKey("billing");
        }

        public const String TraceClass = "TowerConfig";
        internal static TracerTag towerTag = new TracerTag(TraceClass);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\src\TestSpil\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Microsoft SPS TestSpil")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Subscription Platform Services")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]

// It is a good thing to have CLSCompliance - hence marking it
[assembly:CLSCompliant(true)]

// Thanks a lot - i do not need COM anymore! the default is true - so mark it false
[assembly:ComVisible(false)]
//
// Require that at minimum the user should be able to read the USERNAME environment permission
[assembly:EnvironmentPermissionAttribute(SecurityAction.RequestMinimum, Read="USERNAME")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\TowerPartitionConnectionManager\TowerConfig.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using Microsoft.Win32;
using System.Security.Principal;
using System.Runtime.InteropServices;
//using Microsoft.Subscriptions.Spk.Utility;
using CoreSDK;

namespace Microsoft.Subscriptions.Tower
{
    /// <summary>
    /// Stores Tower Configuration information. The configuration includes Logical Partition information,
    /// Logical to Physical Mapping and Max Logical Partition Number. The configuration is cached in memory
    /// and refreshed every 30 seconds.
    /// </summary>
    public class TowerConfig
    {
        #region Declarations
        //TODO: install eventsource and trace tag in installer
        private Hashtable logicalDBMap; // cache
        private Spk.Utility.ImpersonatedThread refreshThread; // refresh thread
        private bool isAlive; // whether refresh thread is alive
        private static int refreshInterval = 60 * 1000; //default refresh period 30 seconds

        private static String configServer = null;  // tower config server address
        private static String configDatabase = null;  // tower database name
        const string TowerServerRegKey = "TowerServer"; // tower regkey
        const string TowerDatabaseRegKey = "TowerDatabase"; // tower db regkey
        const string ConfigRefreshPeriodRegKey = "ConfigRefreshPeriod"; // config refresh regkey
        static object lockObject = new Object(); // lock object
        #endregion

        #region Constructors
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="strConfigServer">Configuration Server Name, i.e. Tower Server</param>
        /// <param name="strConfigDB">Configuration Database, i.e. Tower</param>
        public TowerConfig()
        {
            // create a synchronized hashtable to store cache
            logicalDBMap = Hashtable.Synchronized( new Hashtable());
            try
            {
                // create background refresh thread
                isAlive = true;
                ThreadStart startInfo = new ThreadStart(RefreshConfig);
                refreshThread = new Spk.Utility.ImpersonatedThread(startInfo);
                refreshThread.WorkerThread.IsBackground = true;
                refreshThread.WorkerThread.Name = "Tower Configuration Refresh Thread";
                refreshThread.Start();

                Tracer.Trace(Globals.towerTag, System.Diagnostics.TraceLevel.Info, "Tower Configuration Refresh Thread started.");
            }
            catch(Exception e)
            {
                Spk.Utility.EventLogHelper.WriteEntry(
                    Globals.TraceClass,
                    1,
                    "Failed to start config refresh thread.\r\n" + e.ToString(),
                    Spk.Utility.ErrorLevels.elSystemError);
                throw;
            }

        }

        /// <summary>
        /// Static initializer
        /// </summary>
        static TowerConfig()
        {
            try
            {
                try
                {
                    if (!EventLog.SourceExists(Globals.TraceClass))
                    {
                        EventLog.CreateEventSource(Globals.TraceClass, "Application");
                    }
                }
                catch{} // may not have permission to create event source

                bool dummy; // do not care about output value
                RetrieveRegistryValues(out dummy); // get configuration from registry
            }
            catch(Exception e)
            {
                Spk.Utility.EventLogHelper.WriteEntry(
                    Globals.TraceClass,
                    1,
                    "Failed to initialize TowerConfig static constructor.\r\n"
                    + e.ToString(),
                    Spk.Utility.ErrorLevels.elSystemWarning);
                throw;
            }
        }

        #endregion

        #region Public Functions
        /// <summary>
        /// Set up shutdown process.
        /// </summary>
        public void Shutdown()
        {
            // soft kill background thread.
            // it's not necessary to call shutdown explicitly since it's background thread
            // but having it helps doing things gracefully.
            this.isAlive = false;
            Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Refresh Thread Stopping");
        }

        /// <summary>
        /// Given store name, logical partition number(hash value),
        /// returns server and database name.
        /// </summary>
        /// <param name="strAppName"></param>
        /// <param name="iHashValue"></param>
        /// <param name="strServer"></param>
        /// <param name="strDatabase"></param>
        /// <returns></returns>
        public bool GetDBPartition( string storeName, int hashValue, out string server, out string database)
        {
            if (storeName == null)
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Invalid null data store name");
                throw new ArgumentNullException("storeName", "Data store name cannot be null.");
            }
            String serviceName = GetServiceName(storeName);
            TowerLogicalDB db = logicalDBMap[ serviceName] as TowerLogicalDB;
            if (db == null ) // try to load from database
            {
                try
                {
                    db = new TowerLogicalDB( serviceName, configServer, configDatabase);
                    db.LoadConfiguration();
                    logicalDBMap[serviceName] = db;
                }
                catch(Exception ex)
                {
                    Tracer.Trace(ex, Globals.towerTag, TraceLevel.Error, "Failed to load Tower Configuration");
                    try
                    {
                        Spk.Utility.EventLogHelper.WriteEntry(Globals.TraceClass, 1, ex, Spk.Utility.ErrorLevels.elSystemWarning);
                    }
                    catch
                    {
                    }

                }
            }
            return db.GetPhysicalPartition( hashValue, out server, out database);
        }

        /// <summary>
        /// Get all database partitions for an application
        /// </summary>
        /// <param name="strAppName"></param>
        /// <param name="rgServers"></param>
        /// <param name="rgDatabases"></param>
        /// <returns>The count of database partitions</returns>
        public int GetAllDBPartitions( string storeName, out string[] servers, out string[] databases)
        {
            String serviceName = GetServiceName(storeName);
            TowerLogicalDB db = logicalDBMap[ serviceName] as TowerLogicalDB;
            if (db == null ) // load from database
            {
                try
                {
                    db = new TowerLogicalDB( serviceName, configServer, configDatabase);
                    db.LoadConfiguration();
                    logicalDBMap[serviceName] = db;
                }
                catch(Exception ex)
                {
                    Tracer.Trace(ex, Globals.towerTag, TraceLevel.Error, "Failed to load Tower Configuration");
                    try
                    {
                        Spk.Utility.EventLogHelper.WriteEntry(Globals.TraceClass, 1, ex, Spk.Utility.ErrorLevels.elSystemWarning);
                    }
                    catch
                    {
                    }

                }

            }
            return db.GetAllPhysicalPartitions( out servers, out databases);
        }


        /// <summary>
        /// Get total database partitions for an application
        /// </summary>
        /// <param name="strAppName"></param>
        /// <returns>The count of database partitions</returns>
        public int GetTotalPhysicalPartitions( string storeName )
        {
            String serviceName = GetServiceName(storeName);
            TowerLogicalDB db = logicalDBMap[ serviceName] as TowerLogicalDB;
            if (db == null ) // load from database
            {
                try
                {
                    db = new TowerLogicalDB( serviceName, configServer, configDatabase);
                    db.LoadConfiguration();
                    logicalDBMap[serviceName] = db;
                }
                catch(Exception ex)
                {
                    Tracer.Trace(ex, Globals.towerTag, TraceLevel.Error, "Failed to load Tower Configuration");
                    try
                    {
                        Spk.Utility.EventLogHelper.WriteEntry(Globals.TraceClass, 1, ex, Spk.Utility.ErrorLevels.elSystemWarning);
                    }
                    catch
                    {
                    }                    
                }

            }       
            return db.GetTotalPhysicalPartitions();
        }
        
        /// <summary>
        /// Get total logical partitions for an application
        /// </summary>
        /// <param name="strAppName"></param>
        /// <returns>The count of database partitions</returns>
        public int GetTotalLogicalPartitions( string storeName )
        {
            String serviceName = GetServiceName(storeName);
            TowerLogicalDB db = logicalDBMap[ serviceName] as TowerLogicalDB;
            if (db == null ) // load from database
            {
                try
                {
                    db = new TowerLogicalDB( serviceName, configServer, configDatabase);
                    db.LoadConfiguration();
                    logicalDBMap[serviceName] = db;
                }
                catch(Exception ex)
                {
                    Tracer.Trace(ex, Globals.towerTag, TraceLevel.Error, "Failed to load Tower Configuration");
                    try
                    {
                        Spk.Utility.EventLogHelper.WriteEntry(Globals.TraceClass, 1, ex, Spk.Utility.ErrorLevels.elSystemWarning);
                    }
                    catch
                    {
                    }                    
                }

            }       
            return db.GetTotalLogicalPartitions();
        }

        #endregion

        #region Private Functions
        /// <summary>
        /// Get registry settings for configuration, including Tower server and the db name
        /// </summary>
        private static void RetrieveRegistryValues(out bool invalidateCache)
        {
            invalidateCache = false;

            String currentConfigServer = TowerConfigUtil.GetRegistryKeyValue(TowerServerRegKey);
            String currentConfigDatabase = TowerConfigUtil.GetRegistryKeyValue(TowerDatabaseRegKey);
            if (currentConfigServer != null && currentConfigDatabase != null)
            {
                if ((configServer == null || configDatabase == null) ||
                    (currentConfigServer.Trim().ToLower() != configServer.Trim().ToLower() ||
                    currentConfigDatabase.Trim().ToLower() != configDatabase.Trim().ToLower()))
                {
                    configServer = currentConfigServer.Trim();
                    configDatabase = currentConfigDatabase.Trim();

                    Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Tower Server Changed. Server=[{0}]", configServer);

                    // clear our cache
                    invalidateCache = true;
                }
            }
            else
            {
                Spk.Utility.EventLogHelper.WriteEntry(
                    Globals.TraceClass,
                    1,
                    @"Cannot get tower server or database name from registry! Make sure it exists at HKLM\Software\Microsoft\SPG Billing\Tower and have right permissions",
                    Spk.Utility.ErrorLevels.elSystemError);

                throw new Exception(@"Cannot get tower server or database name from registry! Make sure it exists at HKLM\Software\Microsoft\SPG Billing\Tower and have right permissions");
            }

            int refreshSeconds = 30;

            String configRefreshPeriodValue = TowerConfigUtil.GetRegistryKeyValue(ConfigRefreshPeriodRegKey);
            if (configRefreshPeriodValue != null)
            {
                try
                {
                    refreshSeconds = int.Parse(configRefreshPeriodValue);
                }
                catch(FormatException)
                {
                    Tracer.Trace(Globals.towerTag, TraceLevel.Warning, "Invalid integer value for refresh seconds: [{0}]" , configRefreshPeriodValue);
                }
            }


            refreshInterval = refreshSeconds * 1000;

            Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Tower: [{0}], Refresh Seconds: [{1}]", configServer, refreshSeconds);
        }

        /// <summary>
        /// Refresh Configuration
        /// </summary>
        private void RefreshConfig()
        {
            while(this.isAlive)
            {
                bool invalidateCache;
                // get registry values
                RetrieveRegistryValues(out invalidateCache);

                if (invalidateCache)
                {
                    logicalDBMap.Clear();
                }

                // Don't sync the hashtable but catch all possible exceptions
                // in order to save synchronization time.
                foreach(TowerLogicalDB db in logicalDBMap.Values)
                {
                    if(db != null)
                    {
                        try
                        {
                            db.LoadConfiguration();
                        }
                        catch(Exception ex)
                        {
                            Tracer.Trace(ex, Globals.towerTag, TraceLevel.Error, "Failed to load Tower Configuration");
                            try
                            {
                                Spk.Utility.EventLogHelper.WriteEntry(Globals.TraceClass, 1, ex, Spk.Utility.ErrorLevels.elSystemWarning);
                            }
                            catch
                            {
                            }
                        }
                    }
                }

                Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Refresh thread sleeps for [{0}]", refreshInterval);

                // Refresh every 30 secondss
                Thread.Sleep(refreshInterval);

            }
        }

        /// <summary>
        /// Get concorde service name from database name
        /// </summary>
        /// <param name="appName"></param>
        /// <returns></returns>
        private String GetServiceName(String storeName)
        {
            String name = storeName.ToUpper();
            switch(name)
            {
                case "AUTHORIZATION":
                    return "AcctAuthorization";
                case "PAYMENTAUTH":
                    return "FDC Authorization";
                case "MAP":
                    return "MapPportIdLow"; //Callers need to override store name for other hashes "MapEncryptCC"
                default:
                    return name;
            }
        }
        #endregion
    }

    /// <summary>
    /// Stores the Tower logical to physical mapping
    /// </summary>
    public class TowerLogicalDB
    {
        #region Declarations
        string serviceName = null;
        int numLogicalPartitions = 0;
        DataSet dsCache = null;
        string connectionString;
        const string BuildVersion = "_11_0"; // m4 build version
        object lockObject = new Object();
        Random random = new Random(); //
        #endregion

        #region Constants
        const String PhysicalResourcesTable = "PhysicalResources";
        const String LogicalToPhysicalMapTable = "LogicalToPhysicalMap";
        const String MaxLogicalPartitionNumberTable = "MaxLogicalPartitionNumber";
        #endregion

        #region Constructors
        /// <summary>
        /// Construct a logical db object
        /// </summary>
        /// <param name="serviceName"></param>
        /// <param name="configServer"></param>
        /// <param name="configDatabase"></param>
        public TowerLogicalDB( string serviceName, string configServer, string configDatabase)
        {
            this.serviceName = serviceName;
            connectionString = "Trusted_Connection=yes;Server="
                + configServer
                + ";Database="
                + configDatabase + ";";
        }

        #endregion

        #region Public Functions
        /// <summary>
        /// Load configuration from tower database.
        /// </summary>
        /// <param name="strConfigServer"></param>
        /// <param name="strConfigDB"></param>
        /// <returns></returns>
        public void LoadConfiguration()
        {
            using(SqlConnection conn = new SqlConnection( connectionString ))
            {
                DataSet tempCache = new DataSet();
                // Load set of available physical resource for the associated service
                SqlCommand cmd = conn.CreateCommand();
                cmd.CommandText = "sp_GetPhysicalPartitions" + BuildVersion;
                cmd.Parameters.Add("@vc_service_name", serviceName);
                cmd.CommandType = CommandType.StoredProcedure;
                SqlDataAdapter da = new SqlDataAdapter( cmd);
                da.Fill(tempCache, PhysicalResourcesTable);

                // Load set of available Logical resources along with there mapping to physical resource
                cmd = conn.CreateCommand();
                cmd.CommandText = "sp_GetLogicalToPhysicalMap" + BuildVersion;
                cmd.Parameters.Add("@vc_service_name", serviceName);
                cmd.CommandType = CommandType.StoredProcedure;
                da = new SqlDataAdapter( cmd);
                da.Fill( tempCache, LogicalToPhysicalMapTable);

                // Load Max Number of logical partitions
                cmd = conn.CreateCommand();
                cmd.CommandText = "sp_GetMaxLogicalPartitionNumber" + BuildVersion;
                cmd.Parameters.Add("@vc_service_name", serviceName);
                cmd.CommandType = CommandType.StoredProcedure;
                da = new SqlDataAdapter( cmd);
                da.Fill( tempCache, MaxLogicalPartitionNumberTable );

                if( tempCache.Tables[MaxLogicalPartitionNumberTable].Rows.Count != 1 )
                {
                    Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Invalid number of max logical partition number rows ["+ tempCache.Tables[MaxLogicalPartitionNumberTable].Rows.Count +"] returned from Stored Procedure sp_GetMaxLogicalPartitionNumber");
                    throw new InvalidOperationException("Invalid number of rows ["+ tempCache.Tables[MaxLogicalPartitionNumberTable].Rows.Count +"]  returned from Stored Procedure sp_GetMaxLogicalPartitionNumber");
                }

                //number of logical partitions
                lock(this)
                {
                    numLogicalPartitions = ( (int)tempCache.Tables[MaxLogicalPartitionNumberTable].Rows[0]["MaxLogicalPartition"] )
                        + 1;
                    Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Total Logical Partitions = [{0}]", numLogicalPartitions);
                    dsCache = tempCache;
                }
            }
        }

        /// <summary>
        /// Get physical partition
        /// </summary>
        /// <param name="iHashValue"></param>
        /// <param name="strServer"></param>
        /// <param name="strDatabase"></param>
        /// <returns></returns>
        public bool GetPhysicalPartition( int hashValue, out string server, out string database)
        {
            if( ( dsCache == null ) ||
                ( numLogicalPartitions == 0 ) )
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Cache not loaded from database or max logical partition number is 0");
                throw new InvalidOperationException("Configuration is not loaded or logical partition number is 0 ");
            }

            // use lock here because ReaderWriterLock has worse performance
            lock(lockObject)
            {
                int logicalPartition = hashValue % numLogicalPartitions;
                if ( hashValue == -1 /* DataStoreComponent.HashValueForAnyInstance*/  ) // hash for partition any
                {
                    // any partition
                    int randIndex = random.Next( dsCache.Tables[LogicalToPhysicalMapTable].Rows.Count);
                    logicalPartition = (int)(dsCache.Tables[LogicalToPhysicalMapTable].Rows[randIndex]["i_partition_number"]);
                }
                Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Hash Value = [{0}], Logical Partition = [{1}]", hashValue, logicalPartition);

                server = null;
                database = null;
                DataRow[] rows = dsCache.Tables[LogicalToPhysicalMapTable].Select("i_partition_number=" + logicalPartition);

                if ( rows.Length > 0 )
                {
                    int physicalResourceId = (int)rows[0]["i_physical_resource_id"];
                    DataRow[] rows2 = dsCache.Tables[0].Select("PhysicalResourceId=" + physicalResourceId);
                    if ( rows2.Length > 0)
                    {
                        server = (string)(rows2[0]["ServerName"]);
                        database = (string)(rows2[0]["ResourceName"]);

                        Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Server = [{0}], Database = [{1}]", server, database);
                        return true;
                    }
                    else
                    {
                        Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Cannot get physical resource for Physical Resource Id [{0}]", physicalResourceId);
                    }
                }
                else
                {
                    Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Cannot get logical partition for Logical Partition Number [{0}]", logicalPartition);
                }
            }
            return false;

        }

        /// <summary>
        /// Get all physical partitions
        /// </summary>
        /// <param name="rgServers"></param>
        /// <param name="rgDatabases"></param>
        /// <returns>Count of physical partitions</returns>
        public int GetAllPhysicalPartitions( out string[] servers, out string[] databases)
        {
            if (dsCache == null)
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Cache not loaded from database");
                throw new InvalidOperationException("Configuration is not loaded or logical partition number is 0 ");
            }
            lock(lockObject)
            {
                DataTable table = dsCache.Tables[PhysicalResourcesTable];
                int count = table.Rows.Count;
                servers = new string[count];
                databases = new string[count];
                for ( int i = 0; i < count;i++)
                {
                    servers[i] = (string)(table.Rows[i]["ServerName"]);
                    databases[i] = (string)(table.Rows[i]["ResourceName"]);
                }

                Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Physical Resources Count = [{0}]", count);
                return count;
            }
        }


        /// <summary>
        /// Get the total number of physical partitions
        /// </summary>
        /// <returns>Count of physical partitions</returns>
        public int GetTotalPhysicalPartitions()
        {
            int count;

            if (dsCache == null)
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Cache not loaded from database");
                throw new InvalidOperationException("Configuration is not loaded or logical partition number is 0 ");
            }
            lock(lockObject)
            {
                DataTable table = dsCache.Tables[PhysicalResourcesTable];
                count = table.Rows.Count;
            }
            
            Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Physical Resources Count = [{0}]", count);
            return count;
        }

       
        /// <summary>
        /// Get the total number of logical partitions
        /// </summary>
        /// <returns>Count of logical partitions</returns>
        public int GetTotalLogicalPartitions()
        {
            if (dsCache == null)
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Cache not loaded from database");
                throw new InvalidOperationException("Configuration is not loaded or logical partition number is 0 ");
            }

            Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Logical Resources Count = [{0}]",  numLogicalPartitions);
            return numLogicalPartitions;
        }
        
        #endregion
    }


    /// <summary>
    /// Utility functions
    /// </summary>
    internal class TowerConfigUtil
    {
        /// <summary>
        /// Retrieve registry value from given key
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        internal static String GetRegistryKeyValue(String name)
        {
            RegistryKey reg = Registry.LocalMachine;
            RegistryKey regTower = reg.OpenSubKey(@"Software\Microsoft\SPG Billing\Tower");
            if (regTower != null)
            {
                object regValue = regTower.GetValue(name);
                if (regValue != null)
                {
                    return regValue.ToString();
                }
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPIL\Spil3.0\TowerPartitionConnectionManager\TowerPartitionedConnectionManager.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using Microsoft.Subscriptions.Data;
using Microsoft.Win32;
//using Microsoft.Subscriptions.Spk.Utility;
using CoreSDK;

namespace Microsoft.Subscriptions.Tower
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    public class TowerPartitionConnectionManager: ISpilConnectionManager, IDisposable
    {
        #region Declarations
        static TowerConfig config = null;
        private int connTimeOut = 60;
        private int commTimeOut = 60;
        private readonly bool dontEnlistInTransaction = false;
        private int returnValue = ProcedureResults.InvalidProcedureReturnValue;
        
        static TowerPartitionConnectionManager()
        {
            config = new TowerConfig();
            Tracer.Trace(Globals.towerTag, TraceLevel.Info, "Configuration Initialized");
        }

        protected Hashtable connectionCache = new Hashtable();
        #endregion

        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public TowerPartitionConnectionManager()
        {
            // Pull the value from registry for Time out
            try
            {
                RegistryKey  concordeRegKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\SPG Billing\\MSNAgent");
                if( concordeRegKey != null )
                {
                    object regValue = concordeRegKey.GetValue("SQLQueryTimeOutInSeconds");
                    if( regValue != null )
                    {
                        connTimeOut = commTimeOut = (int)regValue;
                    }
                }
            }
            catch
            {
                // Ignore the failure and revert to the default value specified in the code
            }
        }
        
        /// <summary>
        /// Construct a connection manager that talks to localhost
        /// </summary>
        /// <param name="connectionTimeOut">the connection timeout value in seconds
        /// </param>
        public TowerPartitionConnectionManager(int connectionTimeOut)
        {
            this.connTimeOut = connectionTimeOut;
        }

        /// <summary>
        /// Construct a connection manager that doesn't enlist in a transaction
        /// </summary>
        /// <param name="dontEnlistInTransaction">If this flag is set to true, the connections
        /// in this connection manager instance is not enlisted in DTC always</param>
        public TowerPartitionConnectionManager(bool dontEnlistInTransaction)
        {
            this.dontEnlistInTransaction = dontEnlistInTransaction;
        }
        #endregion


        #region Destructors
        /// <summary>
        /// Default finalizer, called when this object is garbage collected.
        /// </summary> 
        ~TowerPartitionConnectionManager()
        {
            this.Dispose(false);        
        }        
        #endregion

        #region interface ISpilConnectionManager 
        /// <summary>
        /// Get database connection
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <param name="hashValue"></param>
        /// <returns></returns>
        public IDbConnection GetConnection( string databaseName, string connectionString, int hashValue)
        {
            string server, database;
            SqlConnection sqlRet = null;
            
            Tracer.Trace(Globals.towerTag, TraceLevel.Info, "GetConnection: Hash=[{0}], Database=[{1}]", hashValue, databaseName);

            if( config.GetDBPartition( databaseName, hashValue, out server, out database) )
            {
                // build key based on database name, hash value and connections tring
                String key = database + ":" + server + ":" + connectionString;
                //lookup cached connections
                sqlRet = (SqlConnection)connectionCache[key];

                if (sqlRet == null  )
                {
                    // if not found, get one from global configuration object.
                    if (!dontEnlistInTransaction)
					    sqlRet = TransactionWrapper.OpenConnection( 
                            "Data Source=" + server +
                            ";Initial Catalog=" + database + 
                            ";Connect TimeOut =" + this.connTimeOut + 
                            ";" + connectionString);
                    else
                        sqlRet = new SqlConnection(
                            "Data Source=" + server +
                            ";Initial Catalog=" + database + 
                            ";Connect TimeOut =" + this.connTimeOut + 
                            ";" + connectionString);
                    // cache connection
                    connectionCache[key] = sqlRet;
                } 
                if ( sqlRet == null) 
                {
                    Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Failed to get connection for Server=[{0}], Database=[{1}]", server, database);
                    Spk.Utility.EventLogHelper.WriteEntry(
                        Globals.TraceClass, 
                        1, 
                        "Failed to get connection for Server=[" + server + "], Database=[" + database + "]",
                        Spk.Utility.ErrorLevels.elSystemError);
                    throw new Exception ( "can't obtain sql connection for [" + key + "]");
                }
            }
            else
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error,
                    "Failed to database partition. Hash=[{0}], Database=[{1}]",
                    hashValue, databaseName);

                Spk.Utility.EventLogHelper.WriteEntry(
                    Globals.TraceClass, 
                    1, 
                    "Failed to database partition. Hash=[" + hashValue + "], Database=[" + databaseName + "]",
                    Spk.Utility.ErrorLevels.elSystemError);
                throw new Exception ( "can't obtain sql connection for [" + databaseName + ":" + hashValue + ":" + connectionString + 
                    "]");
            }


            return sqlRet;
        }

		
        /// <summary>
        /// Get all connections
        /// </summary>
        /// <param name="databaseName"></param>
        /// <param name="connectionString"></param>
        /// <returns></returns>
        public IDbConnection[] GetAllConnections( string databaseName, string connectionString)
        {
            SqlConnection[] sqlRet = null;
            string[] servers;
            string[] databases;
            
            // Get all physical partition information
            int count = config.GetAllDBPartitions( databaseName, out servers, out databases);
            if ( count > 0 ) 
            {
                sqlRet = new SqlConnection[ count];
                for ( int i = 0; i < count; i++) 
                {
                    // we have to cache all connections, otherwise, we can't close them explicitly
                    // build up unique key based on database name and physical index
                    String key = databases[i] + ":" + servers[i] + ":" + connectionString;
                    sqlRet[i] = (SqlConnection) connectionCache[key];
                    if (sqlRet[i] == null) 
                    {
                        // get new sql connection from ADO connection pool
                        // if not found, get one from global configuration object.
                        if (!dontEnlistInTransaction)
                        sqlRet[i] = TransactionWrapper.OpenConnection(
                            "Data Source=" + servers[i] +
                            ";Initial Catalog=" + databases[i] +
                            ";Connect TimeOut =" + this.connTimeOut +
                            ";" + connectionString);
                        else
                            sqlRet[i] = new SqlConnection(
                                "Data Source=" + servers[i] +
                                ";Initial Catalog=" + databases[i] + 
                                ";Connect TimeOut =" + this.connTimeOut + 
                                ";" + connectionString);
                        connectionCache[key] = sqlRet[i];
                    }

                    if ( sqlRet[i] == null) 
                    {
                        Tracer.Trace(Globals.towerTag, TraceLevel.Error,
                            "Failed to get connection for Server=[{0}], Database=[{1}]",
                            servers[i], databases[i]);
                        
                        Spk.Utility.EventLogHelper.WriteEntry(
                            Globals.TraceClass, 
                            1, 
                            "Failed to get connection for Server=[" + servers[i] + "], Database=[" + databases[i] + "]",
                            Spk.Utility.ErrorLevels.elSystemError);
                        throw new Exception ( "can't obtain sql connection for [" + key + "]");
                    }
                }
            }

            return sqlRet;
        }

        
        public void CloseConnections()
        {
            IDictionaryEnumerator ie = connectionCache.GetEnumerator();
            while(ie.MoveNext()) 
            {
                SqlConnection conn = (SqlConnection)ie.Value;
                if ( conn!= null) 
                {
                    if (!dontEnlistInTransaction)
                        TransactionWrapper.CloseConnection(conn);
                    else
                        conn.Close();
                    conn = null;
                }
            }
            connectionCache = null;
        }

        /// <summary>
        /// Get physical instance id from logical partition id and store name
        /// </summary>
        /// <param name="hashValue">Logical partition id</param>
        /// <param name="storeName">Store Name</param>
        public object GetPhysicalInstanceId(string storeName, int hashValue)
        {
            string server;
            string database;
            if( config.GetDBPartition( storeName, hashValue, out server, out database))
            {
                return database+":"+server;
            }
            else
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error,
                    "Failed to get physical instance id. Store=[{0}], Hash=[{1}]",
                    storeName, hashValue);

                Spk.Utility.EventLogHelper.WriteEntry(
                    Globals.TraceClass, 
                    1, 
                    "Failed to get physical instance id. Store=[" + storeName + "], Hash=[" + hashValue + "]",
                    Spk.Utility.ErrorLevels.elSystemError);
                throw new Exception ( "can't get physical connection id for: " + storeName + " hashValue" + hashValue);
            }
        }
        
        /// <summary>
        /// Given a logical database name it provides a collection object
        ///  that consists of "key" or "physical Instance Id" required to access
        ///  the individual physical instances.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <returns>a collection object consisting of a set of physical instance IDs</returns>
        public object[] GetAllPhysicalInstances( string storeName) 
        {
            string [] servers;
            string [] databases;
            int count = config.GetAllDBPartitions( storeName, out servers, out databases);
            object[] allPhysicalInstances = new object[count];
            for(int i = 0; i < allPhysicalInstances.Length; i ++)
            {
                allPhysicalInstances[i] = databases[i] + ":" + servers[i] ;
            }
            return allPhysicalInstances;
        }

        /// <summary>
        /// Get total physical partitions for a service.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <returns>total number of physical partitions</returns>
        public int GetTotalPhysicalPartitions(string storeName)
        {
            return config.GetTotalPhysicalPartitions( storeName );
        }

        /// <summary>
        /// Get total logical partitions for a service.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <returns>total number of logical partitions</returns>
        public int GetTotalLogicalPartitions(string storeName)
        {
            return config.GetTotalLogicalPartitions( storeName );
        }

        /// <summary>
        /// Given the (logical database, physical instance id/key) this function
        ///  returns a connection object for accessing the specific database.
        /// </summary>
        /// <param name="storeName">name of the logical database</param>
        /// <param name="connectionString">additional parameters required to access the database</param>
        /// <param name="physicalInstanceId">ID or key for specifying the target physical instance</param>
        /// <returns>an interface to the database connection object</returns>
        public IDbConnection GetConnectionForPhysicalInstance( string storeName, string connectionString, object physicalInstanceId) 
        {
            SqlConnection sqlRet;
            string server;
            string database;

            string[] physicalInstanceKeys = physicalInstanceId.ToString().Split(":".ToCharArray());
            if(physicalInstanceKeys.Length != 2)
            {
                Tracer.Trace(Globals.towerTag, TraceLevel.Error, "Physical Instance Key is invalid. Key=[{0}]", physicalInstanceId);

                Spk.Utility.EventLogHelper.WriteEntry(
                    Globals.TraceClass, 
                    1, 
                    "Physical Instance Key is invalid. Key=[" + physicalInstanceId +"]",
                    Spk.Utility.ErrorLevels.elSystemError);
                
                throw new Exception("Invalid physical instance id: " + physicalInstanceId.ToString());
            }

            server = physicalInstanceKeys[1];
            database = physicalInstanceKeys[0];


            String key = database + ":" + server + ":" + connectionString;
            sqlRet = (SqlConnection) connectionCache[key];

   	    if (sqlRet == null  )
	    {
                int i = 0;
                while(true)
                {

                    // if not found, get one from global configuration object.
                    try
                    {
                        if (!dontEnlistInTransaction)
                            sqlRet = TransactionWrapper.OpenConnection( 
                                "Data Source=" + server +
                                ";Initial Catalog=" + database + 
                                ";Connect TimeOut =" + this.connTimeOut + 
                                ";" + connectionString);
                        else
                            sqlRet = new SqlConnection(
                                "Data Source=" + server +
                                ";Initial Catalog=" + database + 
                                ";Connect TimeOut =" + this.connTimeOut + 
                                ";" + connectionString);
                        // cache connection
                        connectionCache[key] = sqlRet;
                        break;
                    }
                    catch (SqlException e )
                    {
                        // retry for three times before returning an error to the caller
                        // throw an exception if we have exeeded number of reties or we get some other 
                        // exception
                        if( ( i == 2 ) || ( e.Message.IndexOf("Timeout expired") == -1 ) )
                        {
                            throw new Exception( "Failed while connecting to the Data Source=" + server + 
                                ";Initial Catalog=" + database + 
                                ";Connect TimeOut ="
                                + this.connTimeOut + ";" + connectionString, e );
                        }

                        // Throw a event here
                        Spk.Utility.EventLogHelper.WriteEntry(
                            "BDKSVR2", "Failed while connecting to the Data Source=" + server + 
                            ";Initial Catalog=" + database + 
                            ";Connect TimeOut ="
                            + this.connTimeOut + ";" + connectionString + "Exception String " + e.Message );
                    }
                    i++;
                }
 	    } 

            return sqlRet;
        }

        //---------------------------------------------------------------------
        /// <summary>
        /// Returns a command object appropriate for the connection with the 
        /// given key values.
        /// </summary>
        public IDbCommand GetCommand(
            string databaseName, 
            string connectionString, 
            int hashValue)
        {
            IDbCommand command = this.GetConnection(databaseName, connectionString, hashValue).CreateCommand();
			if (!dontEnlistInTransaction)
                TransactionWrapper.InitCommand(command);
			return command;
        } // GetCommand

        //---------------------------------------------------------------------
        /// <summary>
        /// Returns a command object appropriate for the connection with the 
        /// given key values.
        /// </summary>
        public IDbCommand GetCommandForPhysicalInstance(
            string storeName, 
            string connectionString, 
            object physicalInstanceId)
        {
            IDbCommand command = this.GetConnectionForPhysicalInstance(storeName, connectionString, physicalInstanceId).CreateCommand();
            if (!dontEnlistInTransaction)
			    TransactionWrapper.InitCommand(command);
			return command;
        } // GetCommandForPhysicalInstance

        //---------------------------------------------------------------------
        /// <summary>
        /// Exposed from ISpilConnectionManager interface.
        /// </summary>
        public IDataAdapter GetDataAdapterForCommand(IDbCommand cmd)
        {
            return new SqlDataAdapter((SqlCommand)(cmd));
        } // GetDataAdapterForCommand
       
        #endregion

        #region interface IDisposable
        /// <summary>
        /// This method should be called explicitly by the user to close the
        /// resources the connection manager uses.
        /// </summary>
        public void Dispose()
        {
            // suppress the garbage collector clean up
            GC.SuppressFinalize(this);
            // Call the method that actually does the cleanup
            Dispose(true);
        }

        /// <summary>
        /// The common method that does the actual clean up. This method is protected
        /// because the connection manager can be inherited by other connection managers.
        /// </summary>
        /// <param name="disposing">the flag to indicate whether to dispose explicitly
        /// or by GC</param>
        protected void Dispose(bool disposing)
        {
            // need to synchronize the dispose
            lock(this)
            {
                if(disposing)
                {
                    //explicit clean up. It is safe here to dispose any objects
                    //referenced by this object.
                    CloseConnections();
                }
                //note: we cannot call CloseConnections here because by the time
                //the connection manager is GCed, we're not sure if the connection cache
                //and the connections are already GCed or not.
            }
        }
        #endregion 
        
        #region Public Properties
        /// <summary>
        /// Gets or sets connection Timeout value 
        /// </summary>
        public int ConnectionTimeOut
        {
            get { return this.connTimeOut; }
            set { this.connTimeOut = value; }
        }
        
        
        /// <summary>
        /// Gets or sets command Timeout value 
        /// </summary>
        public int CommandTimeOut
        {
            get { return this.commTimeOut; }
            set { this.commTimeOut = value; }
        }

        /// <summary>
        /// If this flag is set, the connections in this connection manager
        /// are ensured not enlisted in DTC
        /// </summary>
        public bool DontEnlistInTransaction
        {
            get { return this.dontEnlistInTransaction; }
        }
        
        /// <summary>
        /// Gets or sets the return value of the query
        /// </summary>
        public int ReturnValue
        {
            get { return this.returnValue; }
            set { this.returnValue = value ;}
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\inc\bdkerror.h ===
#ifndef __bdkerror_h__
#define __bdkerror_h__
// payauth DB error mapping
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: BDK_E_BAN_NULL_INPUT_PARAMETER
//
// MessageText:
//
//  Null input parameter passed to a "ban" API.
//
#define BDK_E_BAN_NULL_INPUT_PARAMETER   ((HRESULT)0x80047594L)

//
// MessageId: BDK_E_ALREADY_BANNED
//
// MessageText:
//
//  Already banned.
//
#define BDK_E_ALREADY_BANNED             ((HRESULT)0x80047599L)

//
// MessageId: BDK_E_NOT_BANNED
//
// MessageText:
//
//  Not banned.
//
#define BDK_E_NOT_BANNED                 ((HRESULT)0x8004759EL)

// for 2.1 compat this must remain 30140 (800475BC BDK_E_BANNEDPERSON)
//
// MessageId: BDK_E_BANNEDPERSON
//
// MessageText:
//
//  This account is banned.
//
#define BDK_E_BANNEDPERSON               ((HRESULT)0x800475BCL)

//
// MessageId: BDK_E_COUNTRY_CURRENCY_PI_MISMATCH
//
// MessageText:
//
//  Country/currency/payment instrument type mismatch.
//
#define BDK_E_COUNTRY_CURRENCY_PI_MISMATCH ((HRESULT)0x800475C1L)

//
// MessageId: BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE
//
// MessageText:
//
//  Invalid payment instrument type.
//
#define BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE ((HRESULT)0x800475C8L)

//
// MessageId: BDK_E_INVALID_CREDIT_CARD_TYPE
//
// MessageText:
//
//  Invalid credit card type.
//
#define BDK_E_INVALID_CREDIT_CARD_TYPE   ((HRESULT)0x800475CBL)

//
// MessageId: BDK_E_DECRYPTION_FAILURE
//
// MessageText:
//
//  Decryption failed. Verify that data is encrypted correctly.
//
#define BDK_E_DECRYPTION_FAILURE         ((HRESULT)0x800475D0L)

// for 2.1 compat this must remain 30150 (800475C6 BDK_E_BANNEDPERSONCCMISMATCH)
//
// MessageId: BDK_E_BANNED_PAYMENT_INSTRUMENT
//
// MessageText:
//
//  Payment instrument is banned.
//
#define BDK_E_BANNED_PAYMENT_INSTRUMENT  ((HRESULT)0x800475C6L)

//
// MessageId: BDK_E_INVALID_DD_ACCOUNT
//
// MessageText:
//
//  Direct debit account validation failed.
//
#define BDK_E_INVALID_DD_ACCOUNT         ((HRESULT)0x800475E4L)

//
// MessageId: BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24
//
// MessageText:
//
//  Concatenated direct debit account number exceeds 24 characters.
//
#define BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 ((HRESULT)0x800475E9L)

// for 2.1 compat this must remain 30000 (80047530 BDK_E_BADCARDNUMBER)
//
// MessageId: BDK_E_INVALID_CREDIT_CARD_NUMBER
//
// MessageText:
//
//  Invalid credit card number.
//
#define BDK_E_INVALID_CREDIT_CARD_NUMBER ((HRESULT)0x80047530L)

// for 2.1 compat this must remain 30001 (80047531 BDK_E_CARDEXPIRED)
//
// MessageId: BDK_E_CREDIT_CARD_EXPIRED
//
// MessageText:
//
//  Credit card has already expired or will expire this month.
//
#define BDK_E_CREDIT_CARD_EXPIRED        ((HRESULT)0x80047531L)

//
// MessageId: BDK_E_AVS_FAILED
//
// MessageText:
//
//  Address verification failed.
//
#define BDK_E_AVS_FAILED                 ((HRESULT)0x8004760CL)

//
// MessageId: BDK_E_AUTHORIZATION_FAILED
//
// MessageText:
//
//  Credit card authorization failed.
//
#define BDK_E_AUTHORIZATION_FAILED       ((HRESULT)0x80047611L)

//
// MessageId: BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED
//
// MessageText:
//
//  Unable to connect to payment provider.
//
#define BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED ((HRESULT)0x8004761BL)

//
// MessageId: BDK_E_DD_INVALID_COUNTRY
//
// MessageText:
//
//  Invalid country code.
//
#define BDK_E_DD_INVALID_COUNTRY         ((HRESULT)0x8004762FL)

//
// MessageId: BDK_E_DD_INVALID_ACCOUNT_FORMAT
//
// MessageText:
//
//  Invalid account format.
//
#define BDK_E_DD_INVALID_ACCOUNT_FORMAT  ((HRESULT)0x80047634L)

//
// MessageId: BDK_E_DD_INVALID_BANKCODE_FORMAT
//
// MessageText:
//
//  Invalid bank code format.
//
#define BDK_E_DD_INVALID_BANKCODE_FORMAT ((HRESULT)0x80047639L)

//
// MessageId: BDK_E_DD_INVALID_BRANCHCODE_FORMAT
//
// MessageText:
//
//  Invalid branch code format.
//
#define BDK_E_DD_INVALID_BRANCHCODE_FORMAT ((HRESULT)0x8004763EL)

//
// MessageId: BDK_E_DD_INVALID_CHECKDIGIT_FORMAT
//
// MessageText:
//
//  Invalid check digit format.
//
#define BDK_E_DD_INVALID_CHECKDIGIT_FORMAT ((HRESULT)0x80047643L)

//
// MessageId: BDK_E_DD_ACCOUNT_MISSING
//
// MessageText:
//
//  Account missing.
//
#define BDK_E_DD_ACCOUNT_MISSING         ((HRESULT)0x80047648L)

//
// MessageId: BDK_E_DD_BANKCODE_MISSING
//
// MessageText:
//
//  Bank code missing.
//
#define BDK_E_DD_BANKCODE_MISSING        ((HRESULT)0x8004764DL)

//
// MessageId: BDK_E_DD_BRANCHCODE_MISSING
//
// MessageText:
//
//  Branch code missing.
//
#define BDK_E_DD_BRANCHCODE_MISSING      ((HRESULT)0x80047652L)

//
// MessageId: BDK_E_DD_CHECKDIGIT_MISSING
//
// MessageText:
//
//  Check digit missing.
//
#define BDK_E_DD_CHECKDIGIT_MISSING      ((HRESULT)0x80047657L)

//
// MessageId: BDK_E_DD_ERROR_IN_FIELDS
//
// MessageText:
//
//  Some fields have errors.
//
#define BDK_E_DD_ERROR_IN_FIELDS         ((HRESULT)0x8004765CL)

//
// MessageId: BDK_E_DD_INVALID_ACCOUNT_VALUE
//
// MessageText:
//
//  Invalid account code.
//
#define BDK_E_DD_INVALID_ACCOUNT_VALUE   ((HRESULT)0x80047661L)

//
// MessageId: BDK_E_DD_INVALID_BANKCODE_VALUE
//
// MessageText:
//
//  Invalid bank code.
//
#define BDK_E_DD_INVALID_BANKCODE_VALUE  ((HRESULT)0x80047666L)

//
// MessageId: BDK_E_DD_INVALID_BRANCHCODE_VALUE
//
// MessageText:
//
//  Invalid branch code.
//
#define BDK_E_DD_INVALID_BRANCHCODE_VALUE ((HRESULT)0x8004766BL)

//
// MessageId: BDK_E_DD_INVALID_CHECKDIGIT_VALUE
//
// MessageText:
//
//  Invalid check digit.
//
#define BDK_E_DD_INVALID_CHECKDIGIT_VALUE ((HRESULT)0x80047670L)

//
// MessageId: BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME
//
// MessageText:
//
//  Direct debit account holder name cannot exceed 35 characters.
//
#define BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME ((HRESULT)0x8004767AL)

//
// MessageId: BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT
//
// MessageText:
//
//  Payment provider connection timed out.
//
#define BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT ((HRESULT)0x8004767FL)

//
// MessageId: BDK_E_INVALID_WHOLESALE_PARTNER
//
// MessageText:
//
//  The wholesale partner specified is invalid.
//
#define BDK_E_INVALID_WHOLESALE_PARTNER  ((HRESULT)0x80047684L)

//
// MessageId: BDK_E_INVALID_SESSION_KEY
//
// MessageText:
//
//  The session key passed in does not pass validation checks.
//
#define BDK_E_INVALID_SESSION_KEY        ((HRESULT)0x8004768EL)

//
// MessageId: BDK_E_PI_NOT_SUPPORTED
//
// MessageText:
//
//  PI Not Supported in this version
//
#define BDK_E_PI_NOT_SUPPORTED           ((HRESULT)0x80047693L)

//
// MessageId: BDK_E_UPS_NOT_UPDATED
//
// MessageText:
//
//  A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.
//
#define BDK_E_UPS_NOT_UPDATED            ((HRESULT)0xC004769DL)

// BEGIN Error messages mapping to subscription..global_messaqge
//
// MessageId: BDK_E_ALREADY_IN_SPECIFIED_STATE
//
// MessageText:
//
//  Object is already in the specified state.
//
#define BDK_E_ALREADY_IN_SPECIFIED_STATE ((HRESULT)0x80049C41L)

//
// MessageId: BDK_E_REQUIRED_FIELD_MISSING
//
// MessageText:
//
//  Required field missing.
//
#define BDK_E_REQUIRED_FIELD_MISSING     ((HRESULT)0x80049C45L)

//
// MessageId: BDK_E_ACTIVE_SUBSCRIPTIONS
//
// MessageText:
//
//  The account has subscriptions.
//
#define BDK_E_ACTIVE_SUBSCRIPTIONS       ((HRESULT)0x80049C46L)

//
// MessageId: BDK_E_INVALID_ACCOUNT_SOUCE
//
// MessageText:
//
//  Invalid account source.
//
#define BDK_E_INVALID_ACCOUNT_SOUCE      ((HRESULT)0x80049C4DL)

//
// MessageId: BDK_E_INVALID_CREATION_DATE
//
// MessageText:
//
//  Creation date/time cannot be later than current date/time.
//
#define BDK_E_INVALID_CREATION_DATE      ((HRESULT)0x80049C4EL)

//
// MessageId: BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS
//
// MessageText:
//
//  No more tax exemptions are allowed for this account.
//
#define BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS ((HRESULT)0x80049C55L)

//
// MessageId: BDK_E_GENERATE_NEXT_ID
//
// MessageText:
//
//  Generating next ID.
//
#define BDK_E_GENERATE_NEXT_ID           ((HRESULT)0x80049C59L)

//
// MessageId: BDK_E_INVALID_STATE_FOR_COUNTRY
//
// MessageText:
//
//  State invalid for the country.
//
#define BDK_E_INVALID_STATE_FOR_COUNTRY  ((HRESULT)0x80049C5FL)

//
// MessageId: BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH
//
// MessageText:
//
//  Country for address provided does not match existing country for account.
//
#define BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH ((HRESULT)0x80049C61L)

//
// MessageId: BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH
//
// MessageText:
//
//  The offering requested is not available in the country of this account.
//
#define BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH ((HRESULT)0x80049C62L)

//
// MessageId: BDK_E_INVALID_BILLABLE_ACCOUNT_ID
//
// MessageText:
//
//  Invalid account.
//
#define BDK_E_INVALID_BILLABLE_ACCOUNT_ID ((HRESULT)0x80049CC2L)

//
// MessageId: BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID
//
// MessageText:
//
//  Invalid account status.
//
#define BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID ((HRESULT)0x80049CC7L)

//
// MessageId: BDK_E_INVALID_PHONE_TYPE
//
// MessageText:
//
//  Invalid phone type.
//
#define BDK_E_INVALID_PHONE_TYPE         ((HRESULT)0x80049CD6L)

//
// MessageId: BDK_E_INVALID_OFFERING_ID
//
// MessageText:
//
//  Invalid offering.
//
#define BDK_E_INVALID_OFFERING_ID        ((HRESULT)0x80049CE5L)

//
// MessageId: BDK_E_INVALID_COUNTRY_CODE
//
// MessageText:
//
//  Invalid country code.
//
#define BDK_E_INVALID_COUNTRY_CODE       ((HRESULT)0x80049CEAL)

//
// MessageId: BDK_E_INVALID_ADDRESS_ID
//
// MessageText:
//
//  Invalid address ID.
//
#define BDK_E_INVALID_ADDRESS_ID         ((HRESULT)0x80049CEFL)

//
// MessageId: BDK_E_INVALID_PAYMENT_METHOD_ID
//
// MessageText:
//
//  Invalid payment instrument ID.
//
#define BDK_E_INVALID_PAYMENT_METHOD_ID  ((HRESULT)0x80049CF9L)

//
// MessageId: BDK_E_SUBSCRIPTION_ALREADY_CANCELED
//
// MessageText:
//
//  Subscription is already cancelled.
//
#define BDK_E_SUBSCRIPTION_ALREADY_CANCELED ((HRESULT)0x80049D08L)

//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_ID
//
// MessageText:
//
//  Invalid subscription ID.
//
#define BDK_E_INVALID_SUBSCRIPTION_ID    ((HRESULT)0x80049D0DL)

//
// MessageId: BDK_E_INVALID_PERIOD_TO_PROCESS
//
// MessageText:
//
//  Invalid period.
//
#define BDK_E_INVALID_PERIOD_TO_PROCESS  ((HRESULT)0x80049D2BL)

//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_STATUS
//
// MessageText:
//
//  Invalid subscription status or invalid operation for the status.
//
#define BDK_E_INVALID_SUBSCRIPTION_STATUS ((HRESULT)0x80049D3AL)

//
// MessageId: BDK_E_NON_ACTIVE_ACCOUNT
//
// MessageText:
//
//  Account is inactive.
//
#define BDK_E_NON_ACTIVE_ACCOUNT         ((HRESULT)0x80049D94L)

//
// MessageId: BDK_E_VATID_DOESNOTHAVEEXPDATE
//
// MessageText:
//
//  VATIDs do not have an expiration date.
//
#define BDK_E_VATID_DOESNOTHAVEEXPDATE   ((HRESULT)0x80049D95L)

//
// MessageId: BDK_E_TAXID_EXPDATE
//
// MessageText:
//
//  Expiration date was not specified.
//
#define BDK_E_TAXID_EXPDATE              ((HRESULT)0x80049D96L)

//
// MessageId: BDK_E_INVALID_TAX_EXEMPT_TYPE
//
// MessageText:
//
//  Invalid tax exemption type.
//
#define BDK_E_INVALID_TAX_EXEMPT_TYPE    ((HRESULT)0x80049D97L)

//
// MessageId: BDK_E_NO_ACTIVE_SUBSCRIPTION
//
// MessageText:
//
//  No active subscription for adding a service instance.
//
#define BDK_E_NO_ACTIVE_SUBSCRIPTION     ((HRESULT)0x80049D99L)

//
// MessageId: BDK_E_INVALID_SERVICE_INSTANCE
//
// MessageText:
//
//  Invalid service instance for adding a new user.
//
#define BDK_E_INVALID_SERVICE_INSTANCE   ((HRESULT)0x80049D9EL)

//
// MessageId: BDK_E_ADD_USER_TO_SERVICE_INSTANCE
//
// MessageText:
//
//  Failed to add a new user to a service instance.
//
#define BDK_E_ADD_USER_TO_SERVICE_INSTANCE ((HRESULT)0x80049DA3L)

//
// MessageId: BDK_E_INVALID_BILLABLEACCTSTATUS
//
// MessageText:
//
//  Status change not allowed.
//
#define BDK_E_INVALID_BILLABLEACCTSTATUS ((HRESULT)0x80049DA8L)

//
// MessageId: BDK_E_SERVICE_INSTANCES_NONE
//
// MessageText:
//
//  No service instances available for the billable account.
//
#define BDK_E_SERVICE_INSTANCES_NONE     ((HRESULT)0x80049DBCL)

//
// MessageId: BDK_E_ACCOUNT_CLOSED
//
// MessageText:
//
//  Account is already closed.
//
#define BDK_E_ACCOUNT_CLOSED             ((HRESULT)0x80049DD1L)

//
// MessageId: BDK_E_BILLINGPERIOD_PAST
//
// MessageText:
//
//  Period is already past.
//
#define BDK_E_BILLINGPERIOD_PAST         ((HRESULT)0x80049DD6L)

//
// MessageId: BDK_E_INVALID_ADJUSTMENTGUID
//
// MessageText:
//
//  Invalid adjustment GUID.
//
#define BDK_E_INVALID_ADJUSTMENTGUID     ((HRESULT)0x80049DD7L)

//
// MessageId: BDK_E_INVALID_ADJUSMENT_FOR_PERIOD
//
// MessageText:
//
//  Adjustment not applicable to the specified period.
//
#define BDK_E_INVALID_ADJUSMENT_FOR_PERIOD ((HRESULT)0x80049DD8L)

//
// MessageId: BDK_E_ADJUSTMENT_TOOBIG
//
// MessageText:
//
//  Adjustment amount is too large.
//
#define BDK_E_ADJUSTMENT_TOOBIG          ((HRESULT)0x80049DD9L)

//
// MessageId: BDK_E_ADJUSTMENT_TOOSMALL
//
// MessageText:
//
//  Adjustment amount is too small.
//
#define BDK_E_ADJUSTMENT_TOOSMALL        ((HRESULT)0x80049DDBL)

//
// MessageId: BDK_E_INVALID_LOCALE
//
// MessageText:
//
//  Invalid locale.
//
#define BDK_E_INVALID_LOCALE             ((HRESULT)0x80049DE5L)

//
// MessageId: BDK_E_INVALID_CUSTOMER_TYPE
//
// MessageText:
//
//  Invalid customer type.
//
#define BDK_E_INVALID_CUSTOMER_TYPE      ((HRESULT)0x80049DE6L)

//
// MessageId: BDK_E_INVALID_CURRENCY
//
// MessageText:
//
//  Invalid currency.
//
#define BDK_E_INVALID_CURRENCY           ((HRESULT)0x80049DE7L)

//
// MessageId: BDK_E_DATE_EXPIRED
//
// MessageText:
//
//  Date is already expired.
//
#define BDK_E_DATE_EXPIRED               ((HRESULT)0x80049DE8L)

//
// MessageId: BDK_E_GUID_EXISTS
//
// MessageText:
//
//  GUID already exists.
//
#define BDK_E_GUID_EXISTS                ((HRESULT)0x80049DE9L)

//
// MessageId: BDK_E_INVALID_VIOLATION_ID
//
// MessageText:
//
//  Invalid violation ID.
//
#define BDK_E_INVALID_VIOLATION_ID       ((HRESULT)0x80049DECL)

//
// MessageId: BDK_E_MISSING_VIOLATION_ID
//
// MessageText:
//
//  Violation ID is required.
//
#define BDK_E_MISSING_VIOLATION_ID       ((HRESULT)0x80049DEDL)

//
// MessageId: BDK_E_NEEDTODEPROVISION
//
// MessageText:
//
//  De-provision service instances before proceeding.
//
#define BDK_E_NEEDTODEPROVISION          ((HRESULT)0x80049DEFL)

//
// MessageId: BDK_E_PARTIALCONV_INITIATED
//
// MessageText:
//
//  Partial conversion is already initiated.
//
#define BDK_E_PARTIALCONV_INITIATED      ((HRESULT)0x80049DF0L)

//
// MessageId: BDK_E_PARTIALCONV_EXPECTED
//
// MessageText:
//
//  Subscription is expected to be in the partial state.
//
#define BDK_E_PARTIALCONV_EXPECTED       ((HRESULT)0x80049DF2L)

//
// MessageId: BDK_E_INVALID_CATEGORY_NAME
//
// MessageText:
//
//  Invalid category.
//
#define BDK_E_INVALID_CATEGORY_NAME      ((HRESULT)0x80049DF3L)

//
// MessageId: BDK_E_OFFERING_NOT_PURCHASEABLE
//
// MessageText:
//
//  Offering cannot be purchased.
//
#define BDK_E_OFFERING_NOT_PURCHASEABLE  ((HRESULT)0x80049DF5L)

//
// MessageId: BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH
//
// MessageText:
//
//  Offering currency does not match account currency.
//
#define BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH ((HRESULT)0x80049DF6L)

//
// MessageId: BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH
//
// MessageText:
//
//  Offering does not support payment instrument type.
//
#define BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH ((HRESULT)0x80049DF7L)

//
// MessageId: BDK_E_INVALID_DATE
//
// MessageText:
//
//  Invalid date.
//
#define BDK_E_INVALID_DATE               ((HRESULT)0x80049DF8L)

//
// MessageId: BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP
//
// MessageText:
//
//  Cannot exceed max ownership for the offering.
//
#define BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP ((HRESULT)0x80049DF9L)

//
// MessageId: BDK_E_INVALID_RESOURCE_ID
//
// MessageText:
//
//  Invalid resource ID.
//
#define BDK_E_INVALID_RESOURCE_ID        ((HRESULT)0x80049E02L)

//
// MessageId: BDK_E_UNIT_OF_MEASURE_MISMATCH
//
// MessageText:
//
//  Unit of measure reported in the usage event does not match the one in SPS.
//
#define BDK_E_UNIT_OF_MEASURE_MISMATCH   ((HRESULT)0x80049E03L)

//
// MessageId: BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE
//
// MessageText:
//
//  Event date is before the subscription purchase date.
//
#define BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE ((HRESULT)0x80049E04L)

//
// MessageId: BDK_E_INVALID_OFFERING_FOR_LOCALE
//
// MessageText:
//
//  Offering invalid for the locale.
//
#define BDK_E_INVALID_OFFERING_FOR_LOCALE ((HRESULT)0x80049E05L)

//
// MessageId: BDK_E_NOT_A_BASE_OFFERING
//
// MessageText:
//
//  Offering is not a base offering.
//
#define BDK_E_NOT_A_BASE_OFFERING        ((HRESULT)0x80049E06L)

//
// MessageId: BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH
//
// MessageText:
//
//  There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.
//
#define BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH ((HRESULT)0x80049E08L)

//
// MessageId: BDK_E_MEG_CONFLICT
//
// MessageText:
//
//  The offering requested conflicts with an existing subscription on this account.
//
#define BDK_E_MEG_CONFLICT               ((HRESULT)0x80049E0AL)

//
// MessageId: BDK_E_INVALID_ACCOUNT_STATUS
//
// MessageText:
//
//  Account state does not allow this operation.
//
#define BDK_E_INVALID_ACCOUNT_STATUS     ((HRESULT)0x80049E16L)

//
// MessageId: BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST
//
// MessageText:
//
//  Payment instrument has active subscriptions.
//
#define BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST ((HRESULT)0x80049E1BL)

//
// MessageId: BDK_E_PRIMARY_PHONE_REQUIRED
//
// MessageText:
//
//  Primary phone required for payment instruments.
//
#define BDK_E_PRIMARY_PHONE_REQUIRED     ((HRESULT)0x80049E25L)

//
// MessageId: BDK_E_EMAIL_REQUIRED
//
// MessageText:
//
//  Account requires an e-mail address for this operation.
//
#define BDK_E_EMAIL_REQUIRED             ((HRESULT)0x80049E2AL)

//
// MessageId: BDK_E_ACCOUNT_NOT_CLOSED
//
// MessageText:
//
//  To perform this operation, the account should be closed.
//
#define BDK_E_ACCOUNT_NOT_CLOSED         ((HRESULT)0x80049E2BL)

//
// MessageId: BDK_E_INVALID_VIOLATION
//
// MessageText:
//
//  Invalid violation ID.
//
#define BDK_E_INVALID_VIOLATION          ((HRESULT)0x80049E13L)

//
// MessageId: BDK_E_SUBSCRIPTION_IS_CANCELLED
//
// MessageText:
//
//  Subscription is cancelled and cannot change status.
//
#define BDK_E_SUBSCRIPTION_IS_CANCELLED  ((HRESULT)0x80049E14L)

//
// MessageId: BDK_E_NO_VIOLATION
//
// MessageText:
//
//  Subscription has no violations.
//
#define BDK_E_NO_VIOLATION               ((HRESULT)0x80049E15L)

//
// MessageId: BDK_E_EXISTS_VIOLATION
//
// MessageText:
//
//  Subscription has violations.
//
#define BDK_E_EXISTS_VIOLATION           ((HRESULT)0x80049E17L)

//
// MessageId: BDK_E_INVALID_SERVICE_COMPONENT_ID
//
// MessageText:
//
//  Invalid Service Component Id was passed.
//
#define BDK_E_INVALID_SERVICE_COMPONENT_ID ((HRESULT)0x80049E32L)

//
// MessageId: BDK_E_END_DATE_IN_THE_PAST
//
// MessageText:
//
//  End date is already past.
//
#define BDK_E_END_DATE_IN_THE_PAST       ((HRESULT)0x80049E33L)

//
// MessageId: BDK_E_END_DATE_BEYOND_MAX
//
// MessageText:
//
//  End date passed in is later than the latest allowable end date for this subscription.
//
#define BDK_E_END_DATE_BEYOND_MAX        ((HRESULT)0x80049E34L)

//
// MessageId: BDK_E_VIOLATION_ALREADY_SET
//
// MessageText:
//
//  Violation is already set.
//
#define BDK_E_VIOLATION_ALREADY_SET      ((HRESULT)0x80049E3EL)

//
// MessageId: BDK_E_NO_VIOLATION_SET
//
// MessageText:
//
//  Violation ID not set.
//
#define BDK_E_NO_VIOLATION_SET           ((HRESULT)0x80049E43L)

//
// MessageId: BDK_E_INVALID_CONVERSION
//
// MessageText:
//
//  Invalid conversion path.
//
#define BDK_E_INVALID_CONVERSION         ((HRESULT)0x80049E4DL)

//
// MessageId: BDK_E_SUBS_NOT_INTERMEDIATE
//
// MessageText:
//
//  Subscription is not in the partial state.
//
#define BDK_E_SUBS_NOT_INTERMEDIATE      ((HRESULT)0x80049E4EL)

//
// MessageId: BDK_E_OFFERING_NOT_PUBLISHED
//
// MessageText:
//
//  Offering is not published.
//
#define BDK_E_OFFERING_NOT_PUBLISHED     ((HRESULT)0x80049E52L)

//
// MessageId: BDK_E_CONVERSION_NEEDTODEPROVISION
//
// MessageText:
//
//  Service instances must be de-provisioned to proceed.
//
#define BDK_E_CONVERSION_NEEDTODEPROVISION ((HRESULT)0x80049E53L)

//
// MessageId: BDK_E_INVALID_MANDATE_STATUS
//
// MessageText:
//
//  Invalid mandate status.
//
#define BDK_E_INVALID_MANDATE_STATUS     ((HRESULT)0x80049E57L)

//
// MessageId: BDK_E_PI_ALREADY_GOOD
//
// MessageText:
//
//  Payment instrument status is already GOOD.
//
#define BDK_E_PI_ALREADY_GOOD            ((HRESULT)0x80049E61L)

//
// MessageId: BDK_E_PI_ALREADY_DECLINED
//
// MessageText:
//
//  Payment instrument status is already DECLINED.
//
#define BDK_E_PI_ALREADY_DECLINED        ((HRESULT)0x80049E66L)

//
// MessageId: BDK_E_PI_IS_DISABLED
//
// MessageText:
//
//  Payment instrument status is DISABLED and cannot be changed.
//
#define BDK_E_PI_IS_DISABLED             ((HRESULT)0x80049E6BL)

//
// MessageId: BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS
//
// MessageText:
//
//  Payment instrument exists or the payment instrument status is invalid or does not allow the operation.
//
#define BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS ((HRESULT)0x80049E7FL)

//
// MessageId: BDK_E_INVALID_OFFERING_GUID
//
// MessageText:
//
//  Invalid offering GUID.
//
#define BDK_E_INVALID_OFFERING_GUID      ((HRESULT)0x80049E84L)

//
// MessageId: BDK_E_OFFERING_REQUIRES_PI
//
// MessageText:
//
//  Offering requires a payment instrument.
//
#define BDK_E_OFFERING_REQUIRES_PI       ((HRESULT)0x80049E89L)

//
// MessageId: BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST
//
// MessageText:
//
//  Offering cannot be purchased because it has delayed provisioning components.
//
#define BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST ((HRESULT)0x80049E93L)

//
// MessageId: BDK_E_INVALID_AMOUNT_FOR_CURRENCY
//
// MessageText:
//
//  Amount cannot be adjusted because it does not follow guidelines for currency (JPY or KRW).
//
#define BDK_E_INVALID_AMOUNT_FOR_CURRENCY ((HRESULT)0x80049E99L)

//
// MessageId: BDK_E_INVALID_EMAIL_ADDRESS
//
// MessageText:
//
//  Invalid e-mail address.
//
#define BDK_E_INVALID_EMAIL_ADDRESS      ((HRESULT)0x80049EA2L)

//
// MessageId: BDK_E_INVALID_TAX_EXEMPT_STATUS
//
// MessageText:
//
//  Invalid tax exemption status.
//
#define BDK_E_INVALID_TAX_EXEMPT_STATUS  ((HRESULT)0x80049EACL)

//
// MessageId: BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS
//
// MessageText:
//
//  The status of the old payment instrument does not allow this operation.
//
#define BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS ((HRESULT)0x80049EB6L)

//
// MessageId: BDK_E_INVALID_END_PERIOD
//
// MessageText:
//
//  Invalid end period. Make sure the end period is not before the start period.
//
#define BDK_E_INVALID_END_PERIOD         ((HRESULT)0x80049EC5L)

//
// MessageId: BDK_E_COMPUTE_ONLY
//
// MessageText:
//
//  SPS is in compute-only mode.
//
#define BDK_E_COMPUTE_ONLY               ((HRESULT)0x80049ECAL)

//
// MessageId: BDK_E_SUBSCRIPTION_NOT_EXPIRED
//
// MessageText:
//
//  Subscription is not expired.
//
#define BDK_E_SUBSCRIPTION_NOT_EXPIRED   ((HRESULT)0x80049F43L)

//
// MessageId: BDK_E_TOOLATE_REINSTATE
//
// MessageText:
//
//  Subscription can no longer be reinstated.
//
#define BDK_E_TOOLATE_REINSTATE          ((HRESULT)0x80049F44L)

//
// MessageId: BDK_E_EXTRA_REFERRAL_DATA
//
// MessageText:
//
//  Only a single Referral node may be passed in to this API.
//
#define BDK_E_EXTRA_REFERRAL_DATA        ((HRESULT)0x80049F47L)

//
// MessageId: BDK_E_NO_REFERRAL_UPDATES_ALLOWED
//
// MessageText:
//
//  bstrReferralIDSetXML parameter must be left empty for this API.
//
#define BDK_E_NO_REFERRAL_UPDATES_ALLOWED ((HRESULT)0x80049F4CL)

//
// MessageId: BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION
//
// MessageText:
//
//  This operation is not valid for wholesale subscriptions.
//
#define BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION ((HRESULT)0x80049F65L)

//
// MessageId: BDK_E_HCI_NOT_VALID
//
// MessageText:
//
//  HCI not valid for Account Id.
//
#define BDK_E_HCI_NOT_VALID              ((HRESULT)0x80049F83L)

//
// MessageId: BDK_E_CANT_STOP_TAIWAN_TAXINV
//
// MessageText:
//
//  Taiwan users cannot opt out of hard copy tax invoices.
//
#define BDK_E_CANT_STOP_TAIWAN_TAXINV    ((HRESULT)0x80049F85L)

//
// MessageId: BDK_E_CANT_RESEND_TW_HCR
//
// MessageText:
//
//  Cannot re-issue hard copy tax invoice to TW customers. Have them contact FMP 886-02-23888650.
//
#define BDK_E_CANT_RESEND_TW_HCR         ((HRESULT)0x80049F87L)

//
// MessageId: BDK_E_INVALID_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token specified is invalid.
//
#define BDK_E_INVALID_TOKEN_TYPE         ((HRESULT)0x8004A00AL)

//
// MessageId: BDK_E_TOKEN_NOT_VALID_FOR_OFFERING
//
// MessageText:
//
//  The token Id specified is not valid for the given offering.
//
#define BDK_E_TOKEN_NOT_VALID_FOR_OFFERING ((HRESULT)0x8004A04BL)

//
// MessageId: BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED
//
// MessageText:
//
//  A token Id and a payment instrument Id cannot both be specified.
//
#define BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED ((HRESULT)0x8004A06EL)

//
// MessageId: BDK_E_TOKEN_CLASS_INVALID
//
// MessageText:
//
//  The token class is invalid or does not exist.
//
#define BDK_E_TOKEN_CLASS_INVALID        ((HRESULT)0x8004A073L)

//
// MessageId: BDK_E_PI_CANNOT_BE_SPECIFIED
//
// MessageText:
//
//  A payment instrument cannot be specified.
//
#define BDK_E_PI_CANNOT_BE_SPECIFIED     ((HRESULT)0x8004A078L)

//
// MessageId: BDK_E_SUBSCRIPTION_NOT_PREPAID
//
// MessageText:
//
//  The subscription specified is not a PrePaid subscription.
//
#define BDK_E_SUBSCRIPTION_NOT_PREPAID   ((HRESULT)0x8004A07DL)

//
// MessageId: BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO
//
// MessageText:
//
//  The total number of extended days cannot be less than zero.
//
#define BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO ((HRESULT)0x8004A082L)

//
// MessageId: BDK_E_INVALID_NUMBER_OF_DAYS
//
// MessageText:
//
//  The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.
//
#define BDK_E_INVALID_NUMBER_OF_DAYS     ((HRESULT)0x8004A087L)

//
// MessageId: BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX
//
// MessageText:
//
//  The total number of extended days is greater than the maximum allowed for the current subscription.
//
#define BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX ((HRESULT)0x8004A08CL)

//
// MessageId: BDK_E_SUBSCRIPTION_IS_PREPAID
//
// MessageText:
//
//  The operation cannot be completed because the subscription specified is a Prepaid subscritpion.
//
#define BDK_E_SUBSCRIPTION_IS_PREPAID    ((HRESULT)0x8004A091L)

//
// MessageId: BDK_E_PREPAID_TOKEN_IS_REQUIRED
//
// MessageText:
//
//  The deal specified requires a valid Prepaid Token Id to be specified.
//
#define BDK_E_PREPAID_TOKEN_IS_REQUIRED  ((HRESULT)0x8004A096L)

//
// MessageId: BDK_E_TERM_COMMIT_EXISTS
//
// MessageText:
//
//  There are remaining cycles on the current term commit.
//
#define BDK_E_TERM_COMMIT_EXISTS         ((HRESULT)0x8004A09BL)

//
// MessageId: BDK_E_TOKEN_NOT_APPLICABLE
//
// MessageText:
//
//  The specified token cannot be used for the current operation.
//
#define BDK_E_TOKEN_NOT_APPLICABLE       ((HRESULT)0x8004A0A0L)

//
// MessageId: BDK_E_TOKEN_RENEWAL_PRESENT
//
// MessageText:
//
//  Renewal is already scheduled for this subscription.
//
#define BDK_E_TOKEN_RENEWAL_PRESENT      ((HRESULT)0x8004A0A5L)

//
// MessageId: BDK_E_BLACKLIST_ACTION_NOT_PERFORMED
//
// MessageText:
//
//  BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.
//
#define BDK_E_BLACKLIST_ACTION_NOT_PERFORMED ((HRESULT)0x8004A0AAL)

//
// MessageId: BDK_E_INVALID_SUBSCRIPTION_ACTION
//
// MessageText:
//
//  BlacklistToken was called with invalid bstrSubscriptionAction parameter.
//
#define BDK_E_INVALID_SUBSCRIPTION_ACTION ((HRESULT)0x8004A0AFL)

//
// MessageId: BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID
//
// MessageText:
//
//  This object ID is not entitled to get a deliverable token.
//
#define BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID ((HRESULT)0x8004A0B4L)

//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR
//
// MessageText:
//
//  Value for returnStatementSet parameter must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR ((HRESULT)0x8004A604L)

//
// MessageId: BDK_E_BAD_BEGIN_BILLING_PERIOD
//
// MessageText:
//
//  The begin billing period is not valid for this account.
//
#define BDK_E_BAD_BEGIN_BILLING_PERIOD   ((HRESULT)0x8004A609L)

//
// MessageId: BDK_E_INVALID_END_BILLING_PERIOD
//
// MessageText:
//
//  The end billing period is not valid for this account.
//
#define BDK_E_INVALID_END_BILLING_PERIOD ((HRESULT)0x8004A60EL)

//
// MessageId: BDK_E_BILLING_PERIOD_NEGATIVE
//
// MessageText:
//
//  The billing period value cannot be negative.
//
#define BDK_E_BILLING_PERIOD_NEGATIVE    ((HRESULT)0x8004A613L)

//
// MessageId: BDK_E_BAD_START_END_BILLING_PERIOD
//
// MessageText:
//
//  The end period must be greater than start period.
//
#define BDK_E_BAD_START_END_BILLING_PERIOD ((HRESULT)0x8004A618L)

//
// MessageId: BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE
//
// MessageText:
//
//  The account history date cannot be greater than the current date.
//
#define BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE ((HRESULT)0x8004A61DL)

//
// MessageId: BDK_E_NO_NON_NULL_PARAMS
//
// MessageText:
//
//  Cannot pass null for all parameters.
//
#define BDK_E_NO_NON_NULL_PARAMS         ((HRESULT)0x8004A622L)

//
// MessageId: BDK_E_MISMATCH_SUB_ID_OFFER_GUID
//
// MessageText:
//
//  The offering guid passed in does not match offering guid on subscription.
//
#define BDK_E_MISMATCH_SUB_ID_OFFER_GUID ((HRESULT)0x8004A6FEL)

//
// MessageId: BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE
//
// MessageText:
//
//  The event time stamp is too far in future.
//
#define BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE ((HRESULT)0x8004A70DL)

// END Error messages mapping to subscription..global_messaqge
// BEGIN Error messages mapping to Policy and Agreement Signature
//
// MessageId: BDK_E_INVALID_POLICY_ID
//
// MessageText:
//
//  The policy GuidID/Version combination supplied does not exist.
//
#define BDK_E_INVALID_POLICY_ID          ((HRESULT)0x80049F88L)

//
// MessageId: BDK_E_INSERT_AGREEMENT_SIGNATURE
//
// MessageText:
//
//  Error inserting into table agreement_signature.
//
#define BDK_E_INSERT_AGREEMENT_SIGNATURE ((HRESULT)0x80049F8DL)

//
// MessageId: BDK_E_AGREEMENT_ALREADY_SIGNED
//
// MessageText:
//
//  Agreement for this subscription has already been signed by this user at a different time.
//
#define BDK_E_AGREEMENT_ALREADY_SIGNED   ((HRESULT)0x80049F92L)

//
// MessageId: BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY
//
// MessageText:
//
//  The specified policy has not been localized in the specified locale.
//
#define BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY ((HRESULT)0x80049F9CL)

//
// MessageId: BDK_E_POLICY_DEAL_COUNTRY_MISMATCH
//
// MessageText:
//
//  The policy specified exists but is not valid on the deal/country combination of the supplied subscription.
//
#define BDK_E_POLICY_DEAL_COUNTRY_MISMATCH ((HRESULT)0x80049FA1L)

//
// MessageId: BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE
//
// MessageText:
//
//  The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed.
//
#define BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE ((HRESULT)0x8004A6D1L)

//
// MessageId: BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW
//
// MessageText:
//
//  A payment instrument cannot specified when the conversion mode is RENEW.
//
#define BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW ((HRESULT)0x8004A6D6L)

//
// MessageId: BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING
//
// MessageText:
//
//  Renewing from a perpetual offering is not allowed.
//
#define BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING ((HRESULT)0x8004A6E5L)

//
// MessageId: BDK_E_INVALID_TECERTIFICATENUMBER
//
// MessageText:
//
//  Tax Exempt Certificate Number is invalid.
//
#define BDK_E_INVALID_TECERTIFICATENUMBER ((HRESULT)0x8004A6EAL)

//
// MessageId: BDK_E_NO_WHOLESALE_TO_WHOLESALE
//
// MessageText:
//
//  Conversions between wholesale offers are not allowed.
//
#define BDK_E_NO_WHOLESALE_TO_WHOLESALE  ((HRESULT)0x8004A708L)

//
// MessageId: BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS
//
// MessageText:
//
//  The status of the new payment instrument specified does not allow this operation.
//
#define BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS ((HRESULT)0x8004A712L)

//
// MessageId: BDK_E_INVALID_RENEWAL
//
// MessageText:
//
//  Renewal does not exist.
//
#define BDK_E_INVALID_RENEWAL            ((HRESULT)0x8004A71CL)

// END Error messages mapping to Policy and Agreement Signature
// BEGIN Error messages mapping to AuthDB..global_messaqge
//
// MessageId: BDK_E_LAST_ADMIN_ROLE
//
// MessageText:
//
//  Last administrator role on the account cannot be removed.
//
#define BDK_E_LAST_ADMIN_ROLE            ((HRESULT)0x8004C3C3L)

//
// MessageId: BDK_E_UPDATING_MEMBERNAME
//
// MessageText:
//
//  Error updating member name.
//
#define BDK_E_UPDATING_MEMBERNAME        ((HRESULT)0x8004C3C8L)

//
// MessageId: BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED
//
// MessageText:
//
//  Object can have a maximum of 100 roles.
//
#define BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED ((HRESULT)0x8004C3CDL)

// END Error messages mapping to AuthDB..global_messaqge
// BEGIN Provision.dll errors messages
//
// MessageId: PROVISION_E_MALFORMED_REQUEST
//
// MessageText:
//
//  Provision.dll: Provision request malformed.
//
#define PROVISION_E_MALFORMED_REQUEST    ((HRESULT)0x8004AB7DL)

//
// MessageId: PROVISION_E_WRONG_INPUT_PARAMETERS
//
// MessageText:
//
//  Provision.dll: Wrong input parameters.
//
#define PROVISION_E_WRONG_INPUT_PARAMETERS ((HRESULT)0x8004AB7EL)

//
// MessageId: PROVISION_E_MPF_CALL_FAILED
//
// MessageText:
//
//  Provision.dll: Microsoft Provisioning Framework call failed. %1
//
#define PROVISION_E_MPF_CALL_FAILED      ((HRESULT)0x8004AB7FL)

//
// MessageId: PROVISION_E_XML_OPERATION_ERROR
//
// MessageText:
//
//  Provision.dll: Error during XML manipulation. %1
//
#define PROVISION_E_XML_OPERATION_ERROR  ((HRESULT)0x8004AB80L)

//
// MessageId: PROVISION_E_MPF_CREATE
//
// MessageText:
//
//  Provision.dll: MPF client instantiation failed. %1
//
#define PROVISION_E_MPF_CREATE           ((HRESULT)0x8004AB81L)

//
// MessageId: PROVISION_E_CREATION
//
// MessageText:
//
//  Provision.dll: General error in startup code. %1
//
#define PROVISION_E_CREATION             ((HRESULT)0x8004AB82L)

// END Provision.dll errors messages
// Billing25 DB error messages go here. -50000 from the error code defined in global_message.sql
//
// MessageId: BDK_E_INCREMENT_TOTAL
//
// MessageText:
//
//  Cannot update total.
//
#define BDK_E_INCREMENT_TOTAL            ((HRESULT)0x80044E39L)

//
// MessageId: BDK_E_RES_NOT_BELONG_TO_OBJECT
//
// MessageText:
//
//  Resource does not belong to this object id.
//
#define BDK_E_RES_NOT_BELONG_TO_OBJECT   ((HRESULT)0x80044E57L)

//
// MessageId: BDK_E_DECLINING_BALANCE
//
// MessageText:
//
//  Payment instrument on the current subscription has a declining balance.
//
#define BDK_E_DECLINING_BALANCE          ((HRESULT)0x80044E5CL)

//
// MessageId: BDK_E_DUPLICATE_TRACKING_GUID
//
// MessageText:
//
//  Duplicate tracking GUID.
//
#define BDK_E_DUPLICATE_TRACKING_GUID    ((HRESULT)0x80044E75L)

//
// MessageId: BDK_E_INVALID_EXPIRATION_DATE
//
// MessageText:
//
//  Invalid credit card expiration date.
//
#define BDK_E_INVALID_EXPIRATION_DATE    ((HRESULT)0x80044EA7L)

//
// MessageId: BDK_E_UNKNOWN_MANDATE_STATUS
//
// MessageText:
//
//  Invalid mandate status.
//
#define BDK_E_UNKNOWN_MANDATE_STATUS     ((HRESULT)0x80044EACL)

//
// MessageId: BDK_E_INVALID_PAYMENT_METHOD_TYPE
//
// MessageText:
//
//  Payment method of this type can't support the action
//
#define BDK_E_INVALID_PAYMENT_METHOD_TYPE ((HRESULT)0x80044EB2L)

//
// MessageId: BDK_E_INVALID_CURRENCY2
//
// MessageText:
//
//  Invalid input currency.
//
#define BDK_E_INVALID_CURRENCY2          ((HRESULT)0x80044EC0L)

//
// MessageId: BDK_E_INVALID_AMOUNT
//
// MessageText:
//
//  Invalid amount passed in as argument.
//
#define BDK_E_INVALID_AMOUNT             ((HRESULT)0x80044EFCL)

//
// MessageId: BDK_E_INVALID_BILLING_PERIOD
//
// MessageText:
//
//  Invalid billing period.
//
#define BDK_E_INVALID_BILLING_PERIOD     ((HRESULT)0x80044F42L)

//
// MessageId: BDK_E_INVALID_ANNIV
//
// MessageText:
//
//  Invalid billing anniversary date.
//
#define BDK_E_INVALID_ANNIV              ((HRESULT)0x80044F9CL)

//
// MessageId: BDK_E_INVALID_LINEITEM_ID
//
// MessageText:
//
//  Invalid line item ID.
//
#define BDK_E_INVALID_LINEITEM_ID        ((HRESULT)0x80044FF6L)

//
// MessageId: BDK_E_LINE_ITEM_ID_NOT_OPEN
//
// MessageText:
//
//  Line item ID not associated with an open record.
//
#define BDK_E_LINE_ITEM_ID_NOT_OPEN      ((HRESULT)0x80045046L)

//
// MessageId: BDK_E_LINEITEM_ALREADY_OFFSET
//
// MessageText:
//
//  Line item has already been offset.
//
#define BDK_E_LINEITEM_ALREADY_OFFSET    ((HRESULT)0x8004504BL)

//
// MessageId: BDK_E_INVALID_OFFSET_AMOUNT
//
// MessageText:
//
//  Offset amount must be greater than zero but less than or equal to original amount. %1
//
#define BDK_E_INVALID_OFFSET_AMOUNT      ((HRESULT)0x80045050L)

//
// MessageId: BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED
//
// MessageText:
//
//  Cannot offset line item that is soft- or hard-declined.
//
#define BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED ((HRESULT)0x80045055L)

//
// MessageId: BDK_E_AMOUNT_NOT_COLLECTED_YET
//
// MessageText:
//
//  Amount has not been collected, so it cannot be offset and immediately settled.
//
#define BDK_E_AMOUNT_NOT_COLLECTED_YET   ((HRESULT)0x8004505AL)

//
// MessageId: BDK_E_CANNOT_OFFSET_ZERO_AMOUNT
//
// MessageText:
//
//  Cannot offset line item amount of zero.
//
#define BDK_E_CANNOT_OFFSET_ZERO_AMOUNT  ((HRESULT)0x8004505FL)

//
// MessageId: BDK_E_AMOUNT_IN_PROCESS
//
// MessageText:
//
//  The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.
//
#define BDK_E_AMOUNT_IN_PROCESS          ((HRESULT)0x80045064L)

//
// MessageId: BDK_E_INVALID_CREDIT_AMOUNT
//
// MessageText:
//
//  Credit amount should not be zero.
//
#define BDK_E_INVALID_CREDIT_AMOUNT      ((HRESULT)0x80045082L)

//
// MessageId: BDK_E_CREDIT_AMOUNT_OVER_LIMIT
//
// MessageText:
//
//  Credit amount should not exceed the limit.
//
#define BDK_E_CREDIT_AMOUNT_OVER_LIMIT   ((HRESULT)0x80045083L)

//
// MessageId: BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2
//
// MessageText:
//
//  Invalid amount for currency (JPY or KRW).
//
#define BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2 ((HRESULT)0x80045084L)

//
// MessageId: BDK_E_DUPLICATE_EVENT_ID
//
// MessageText:
//
//  Same event id already been used, please create a new event id and retry.
//
#define BDK_E_DUPLICATE_EVENT_ID         ((HRESULT)0x80045091L)

//
// MessageId: BDK_E_OFFSET_IMM_SETTLE_IN_PROG
//
// MessageText:
//
//  Line items in the immediate_settle_in_progress state cannot be offset.
//
#define BDK_E_OFFSET_IMM_SETTLE_IN_PROG  ((HRESULT)0x8004509BL)

//
// MessageId: BDK_E_SA_IN_STATE_UNOFFSETABLE
//
// MessageText:
//
//  Line item with this settlement amount status cannot be offset.
//
#define BDK_E_SA_IN_STATE_UNOFFSETABLE   ((HRESULT)0x800450A5L)

//
// MessageId: BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL
//
// MessageText:
//
//  Offset amount should never exceed the original item amount.
//
#define BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL ((HRESULT)0x800450AAL)

//
// MessageId: BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS
//
// MessageText:
//
//  The subscription is not active. The resource usage event is still being reported for the subscription.
//
#define BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS ((HRESULT)0x800450AFL)

//
// MessageId: BDK_E_PI_IN_DECLINE
//
// MessageText:
//
//  the payment instrument already has declines on it, transferbalance not allowed
//
#define BDK_E_PI_IN_DECLINE              ((HRESULT)0x800450C8L)

//
// MessageId: BDK_E_SA_IN_INTERMEDIATE_STATUS
//
// MessageText:
//
//  The operation is not allowed when there are Settlement Amounts in intermediate status.
//
#define BDK_E_SA_IN_INTERMEDIATE_STATUS  ((HRESULT)0x800451D1L)

//
// MessageId: BDK_E_INVALID_SETTLEMENT_AMOUNT_ID
//
// MessageText:
//
//  The specified settlement amount id is invalid.
//
#define BDK_E_INVALID_SETTLEMENT_AMOUNT_ID ((HRESULT)0x800451D6L)

//
// MessageId: BDK_E_MISMATCH_RATED_USAGE_TOTAL
//
// MessageText:
//
//  This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.
//
#define BDK_E_MISMATCH_RATED_USAGE_TOTAL ((HRESULT)0x800451E5L)

//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2
//
// MessageText:
//
//  Value for returnStatementSet parameter must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2 ((HRESULT)0x800451BDL)

//
// MessageId: BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE
//
// MessageText:
//
//  %1
//
#define BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE ((HRESULT)0x800451EAL)

//
// MessageId: BDK_E_REFUND_LINEITEM_NOT_SETTLED
//
// MessageText:
//
//  Refund failed - line item was offset but original line item was never settled.
//
#define BDK_E_REFUND_LINEITEM_NOT_SETTLED ((HRESULT)0x80045217L)

// Map DB error messages go here.
//
// MessageId: BDK_E_PMN_INSERT_FAILURE
//
// MessageText:
//
//  Passport member name could not be added.
//
#define BDK_E_PMN_INSERT_FAILURE         ((HRESULT)0x800461BCL)

//
// MessageId: BDK_E_BADSAMECARDUSEDMULTIPLETIMES
//
// MessageText:
//
//  Payment card number has been used multiple times.
//
#define BDK_E_BADSAMECARDUSEDMULTIPLETIMES ((HRESULT)0x800461D0L)

//
// MessageId: BDK_E_PI_ALREADY_ON_ACCOUNT
//
// MessageText:
//
//  Payment instrument already assigned to account.
//
#define BDK_E_PI_ALREADY_ON_ACCOUNT      ((HRESULT)0x800461DFL)

//
// MessageId: BDK_E_PUID_ROLE_LIMIT_EXCEEDED
//
// MessageText:
//
//  Passport ID can have a maximum of 100 roles.
//
#define BDK_E_PUID_ROLE_LIMIT_EXCEEDED   ((HRESULT)0x800461E4L)

//
// MessageId: BDK_E_TOOMANY_FDE_PURCHASES
//
// MessageText:
//
//  Too many fraud enticing purchases on the payment instrument
//
#define BDK_E_TOOMANY_FDE_PURCHASES      ((HRESULT)0x800461E5L)

// General BDK error messages go here.
//
// MessageId: BDK_E_XPATHOBJECT_NOTFOUND
//
// MessageText:
//
//  Select operation failed.
//
#define BDK_E_XPATHOBJECT_NOTFOUND       ((HRESULT)0x80042710L)

//
// MessageId: BDK_E_NOPERMISSION
//
// MessageText:
//
//  Access denied.
//
#define BDK_E_NOPERMISSION               ((HRESULT)0x80042711L)

//
// MessageId: BDK_E_CANNOT_REMOVE_SELF
//
// MessageText:
//
//  Cannot remove self from object.
//
#define BDK_E_CANNOT_REMOVE_SELF         ((HRESULT)0x80042712L)

//
// MessageId: BDK_E_BADXML
//
// MessageText:
//
//  XML is either malformed or incorrect for this API.
//
#define BDK_E_BADXML                     ((HRESULT)0x80042713L)

//
// MessageId: BDK_E_INVALIDCOMMENTSIZE
//
// MessageText:
//
//  Comment text length must be between 1 and 512 characters.
//
#define BDK_E_INVALIDCOMMENTSIZE         ((HRESULT)0x80042714L)

//
// MessageId: BDK_E_BADCANCELMODE
//
// MessageText:
//
//  Invalid cancellation mode.
//
#define BDK_E_BADCANCELMODE              ((HRESULT)0x80042715L)

//
// MessageId: BDK_E_INVALID_BUF_SIZE
//
// MessageText:
//
//  Input parameter is the wrong size.
//
#define BDK_E_INVALID_BUF_SIZE           ((HRESULT)0x80042716L)

//
// MessageId: BDK_E_INVALID_ROLE
//
// MessageText:
//
//  Invalid role.
//
#define BDK_E_INVALID_ROLE               ((HRESULT)0x80042717L)

//
// MessageId: BDK_E_INVALID_PPORT_ID
//
// MessageText:
//
//  Invalid Passport ID.
//
#define BDK_E_INVALID_PPORT_ID           ((HRESULT)0x80042718L)

//
// MessageId: BDK_E_INVALID_ARG
//
// MessageText:
//
//  Invalid argument.
//
#define BDK_E_INVALID_ARG                ((HRESULT)0x8004271AL)

//
// MessageId: BDK_E_UNKNOWN_SERVER_FAILURE
//
// MessageText:
//
//  Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.
//
#define BDK_E_UNKNOWN_SERVER_FAILURE     ((HRESULT)0x8004271FL)

//
// MessageId: BDK_E_INVALID_STATUS_VALUE
//
// MessageText:
//
//  Status must be ENABLED or SUSPENDED.
//
#define BDK_E_INVALID_STATUS_VALUE       ((HRESULT)0x80042720L)

//
// MessageId: BDK_E_INVALID_FILTER
//
// MessageText:
//
//  Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.
//
#define BDK_E_INVALID_FILTER             ((HRESULT)0x80042721L)

//
// MessageId: BDK_E_MISSING_CATEGORY
//
// MessageText:
//
//  Missing category.
//
#define BDK_E_MISSING_CATEGORY           ((HRESULT)0x80042722L)

//
// MessageId: BDK_E_FIELD_TOO_SHORT
//
// MessageText:
//
//  Input field is too short.
//
#define BDK_E_FIELD_TOO_SHORT            ((HRESULT)0x80042723L)

//
// MessageId: BDK_E_FIELD_TOO_LONG
//
// MessageText:
//
//  Input field is too long.
//
#define BDK_E_FIELD_TOO_LONG             ((HRESULT)0x80042724L)

//
// MessageId: BDK_E_BADZIP
//
// MessageText:
//
//  Invalid ZIP code.
//
#define BDK_E_BADZIP                     ((HRESULT)0x80042725L)

//
// MessageId: BDK_E_ONLYONENODE
//
// MessageText:
//
//  Only one of these nodes should be passed.
//
#define BDK_E_ONLYONENODE                ((HRESULT)0x80042726L)

//
// MessageId: BDK_E_CSR_AUTHZ_FAILED
//
// MessageText:
//
//  Only customer service representatives can invoke this API.
//
#define BDK_E_CSR_AUTHZ_FAILED           ((HRESULT)0x80042728L)

//
// MessageId: BDK_E_NOT_ACCOUNT_ADMIN
//
// MessageText:
//
//  Caller is not an account administrator.
//
#define BDK_E_NOT_ACCOUNT_ADMIN          ((HRESULT)0x80042729L)

//
// MessageId: BDK_E_DELEGATE_ID_UNSPECIFIED
//
// MessageText:
//
//  Delegate Passport ID must be specified for customer service representatives.
//
#define BDK_E_DELEGATE_ID_UNSPECIFIED    ((HRESULT)0x8004272AL)

//
// MessageId: BDK_E_REQUESTER_ID_UNSPECIFIED
//
// MessageText:
//
//  Requester Passport ID must be specified.
//
#define BDK_E_REQUESTER_ID_UNSPECIFIED   ((HRESULT)0x8004272BL)

//
// MessageId: BDK_E_INVALID_FLAG_VALUE
//
// MessageText:
//
//  Boolean value must be 0 or 1
//
#define BDK_E_INVALID_FLAG_VALUE         ((HRESULT)0x8004272CL)

//
// MessageId: BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION
//
// MessageText:
//
//  Subscription service instance is inactive.
//
#define BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION ((HRESULT)0x8004272DL)

//
// MessageId: BDK_E_INVALID_OBJECT_ID
//
// MessageText:
//
//  Invalid object.
//
#define BDK_E_INVALID_OBJECT_ID          ((HRESULT)0x8004272EL)

//
// MessageId: BDK_E_PARTNERNOTINBILLING
//
// MessageText:
//
//  Calling partner is not registered in SPS database.
//
#define BDK_E_PARTNERNOTINBILLING        ((HRESULT)0x80042738L)

//
// MessageId: BDK_E_RATING_FAILURE
//
// MessageText:
//
//  Rating error has occurred. Check the event log and the tracer.
//
#define BDK_E_RATING_FAILURE             ((HRESULT)0x8004273DL)

//
// MessageId: BDK_SVR2_STARTED
//
// MessageText:
//
//  BDKSVR2 started.
//
#define BDK_SVR2_STARTED                 ((HRESULT)0x40042742L)

//
// MessageId: BDK_CSR_API_CALL_MADE
//
// MessageText:
//
//  CSR call made.
//
#define BDK_CSR_API_CALL_MADE            ((HRESULT)0x40042743L)

//
// MessageId: BDK_E_CSR_CALL_FROM_NONCSR
//
// MessageText:
//
//  CSR call attempt by non-CSR caller.
//
#define BDK_E_CSR_CALL_FROM_NONCSR       ((HRESULT)0x40042744L)

//
// MessageId: BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS
//
// MessageText:
//
//  "From" and "to" payment instrument are not on the same account in TransferBalance.
//
#define BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS ((HRESULT)0x8004274CL)

//
// MessageId: BDK_E_TRANS_BALANCE_TO_PI_INVALID
//
// MessageText:
//
//  Invalid "to" payment instrument in TransferBalance.
//
#define BDK_E_TRANS_BALANCE_TO_PI_INVALID ((HRESULT)0x80042751L)

//
// MessageId: BDK_E_TRANS_BALANCE_TO_SAME_PI
//
// MessageText:
//
//  Cannot transfer to same payment instrument in TransferBalance.
//
#define BDK_E_TRANS_BALANCE_TO_SAME_PI   ((HRESULT)0x80042756L)

//
// MessageId: BDK_E_TRANS_BALANCE_NOT_ALLOW
//
// MessageText:
//
//  Cannot transfer balances between payment instrument types.
//
#define BDK_E_TRANS_BALANCE_NOT_ALLOW    ((HRESULT)0x8004275BL)

//
// MessageId: BDK_E_INTERNAL_ERROR
//
// MessageText:
//
//  Internal database inconsistencies detected.
//
#define BDK_E_INTERNAL_ERROR             ((HRESULT)0x80042760L)

//
// MessageId: BDK_E_OUTSTANDING_BALANCE
//
// MessageText:
//
//  Payment instrument has outstanding balance.
//
#define BDK_E_OUTSTANDING_BALANCE        ((HRESULT)0x80042765L)

//
// MessageId: BDK_E_INVALID_REFERRALDATA_XML
//
// MessageText:
//
//  Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).
//
#define BDK_E_INVALID_REFERRALDATA_XML   ((HRESULT)0x8004276AL)

//
// MessageId: BDK_E_INVALID_GUID
//
// MessageText:
//
//  Invalid GUID.
//
#define BDK_E_INVALID_GUID               ((HRESULT)0x8004276FL)

//
// MessageId: E_UNSUPPORTED_PAYMENT_INSTRUMENT
//
// MessageText:
//
//  Payment instrument type not supported for SettleBalance.
//
#define E_UNSUPPORTED_PAYMENT_INSTRUMENT ((HRESULT)0x80042774L)

//
// MessageId: BDK_E_SUBSCRIPTION_INACTIVE
//
// MessageText:
//
//  Subscription is inactive.
//
#define BDK_E_SUBSCRIPTION_INACTIVE      ((HRESULT)0x80042779L)

//
// MessageId: BDK_E_INVALID_PM_FOR_STOP_PAYMENTS
//
// MessageText:
//
//  Payments can only be stopped for direct debit transactions.
//
#define BDK_E_INVALID_PM_FOR_STOP_PAYMENTS ((HRESULT)0x8004277EL)

//
// MessageId: BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS
//
// MessageText:
//
//  Excessive number of usage events reported in one ReportUsageEvent() call.
//
#define BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS ((HRESULT)0x80042783L)

//
// MessageId: BDK_E_FIELD_NOT_UPDATEABLE
//
// MessageText:
//
//  Field cannot be updated.
//
#define BDK_E_FIELD_NOT_UPDATEABLE       ((HRESULT)0x80042788L)

//
// MessageId: BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED
//
// MessageText:
//
//  Calling CancelSubscription with an end date and in compute-only mode is not supported.
//
#define BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED ((HRESULT)0x8004278DL)

//
// MessageId: BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT
//
// MessageText:
//
//  The SETTLE event should be the last event in the event list for ImportSettleBillingItems.
//
#define BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT ((HRESULT)0x8004278EL)

// This is for offsetlineitem use only
//
// MessageId: BDK_E_PAYMENT_METHOD_NO_LONGER_VALID
//
// MessageText:
//
//  Line item payment method is no longer valid.
//
#define BDK_E_PAYMENT_METHOD_NO_LONGER_VALID ((HRESULT)0x8004278FL)

//
// MessageId: BDK_E_PROCESS_USAGE_EVENTS
//
// MessageText:
//
//  Failed to process all usage events.
//
#define BDK_E_PROCESS_USAGE_EVENTS       ((HRESULT)0x80042790L)

//
// MessageId: BDK_E_WRONG_OBJECT_ID_TYPE
//
// MessageText:
//
//  Object ID does not contain account and subscription information.
//
#define BDK_E_WRONG_OBJECT_ID_TYPE       ((HRESULT)0x80042791L)

//
// MessageId: BDK_E_INVALID_PHONE_VALUE
//
// MessageText:
//
//  Field contains invalid characters for a phone number.
//
#define BDK_E_INVALID_PHONE_VALUE        ((HRESULT)0x80042792L)

//
// MessageId: BDK_E_INVALID_AMOUNT_VALUE
//
// MessageText:
//
//  Invalid amount.
//
#define BDK_E_INVALID_AMOUNT_VALUE       ((HRESULT)0x80042797L)

//
// MessageId: BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE
//
// MessageText:
//
//  Payment instrument ID and line item ID do not match.
//
#define BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE ((HRESULT)0x80042793L)

//
// MessageId: BDK_E_INTERNAL_ADD_COMMENT_FAILED
//
// MessageText:
//
//  InternalAddComment failed. Escalate error to SPG development.
//
#define BDK_E_INTERNAL_ADD_COMMENT_FAILED ((HRESULT)0x80042794L)

//
// MessageId: BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE
//
// MessageText:
//
//  Immediate settle flag must be false.
//
#define BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE ((HRESULT)0x80042795L)

//
// MessageId: BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS
//
// MessageText:
//
//  No eligible records were found for ReschedulePayment API call.
//
#define BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS ((HRESULT)0x8004279CL)

//
// MessageId: BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE
//
// MessageText:
//
//  Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.
//
#define BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE ((HRESULT)0x800427A6L)

//
// MessageId: BDK_E_INVALID_TELENUMERIC_STRING
//
// MessageText:
//
//  The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.
//
#define BDK_E_INVALID_TELENUMERIC_STRING ((HRESULT)0x800427B0L)

//
// MessageId: BDK_E_NO_MATCH
//
// MessageText:
//
//  There are no matches for the requested information.
//
#define BDK_E_NO_MATCH                   ((HRESULT)0x800427BAL)

//
// MessageId: BDK_E_MULTIPLE_MATCHES
//
// MessageText:
//
//  There are multiple matches for the requested information.
//
#define BDK_E_MULTIPLE_MATCHES           ((HRESULT)0x800427C4L)

//
// MessageId: BDK_E_BAD_PUID
//
// MessageText:
//
//  Invalid PUID.
//
#define BDK_E_BAD_PUID                   ((HRESULT)0x800427CEL)

//
// MessageId: BDK_E_BAD_OBJECT_ID_LENGTH
//
// MessageText:
//
//  ObjectId length must be 16.
//
#define BDK_E_BAD_OBJECT_ID_LENGTH       ((HRESULT)0x800427D9L)

//
// MessageId: BDK_E_END_PERIOD_LESS_THAN_START_PERIOD
//
// MessageText:
//
//  Start period can never be greater than End period.
//
#define BDK_E_END_PERIOD_LESS_THAN_START_PERIOD ((HRESULT)0x800427DAL)

//
// MessageId: BDK_E_BAD_BILLING_PERIOD_LENGTH
//
// MessageText:
//
//  Billing period length must be 6.
//
#define BDK_E_BAD_BILLING_PERIOD_LENGTH  ((HRESULT)0x800427DBL)

//
// MessageId: BDK_E_BAD_RETURN_STATEMENT_SET
//
// MessageText:
//
//  Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.
//
#define BDK_E_BAD_RETURN_STATEMENT_SET   ((HRESULT)0x800427DCL)

//
// MessageId: BDK_E_NULL_DEFAULT_BILLING_PERIOD
//
// MessageText:
//
//  The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.
//
#define BDK_E_NULL_DEFAULT_BILLING_PERIOD ((HRESULT)0x800427E0L)

//
// MessageId: BDK_E_BAD_START_BILLING_PERIOD
//
// MessageText:
//
//  The start billing period is less than the currently available billing period.
//
#define BDK_E_BAD_START_BILLING_PERIOD   ((HRESULT)0x800427E1L)

//
// MessageId: BDK_E_BAD_END_BILLING_PERIOD
//
// MessageText:
//
//  The end billing period is less than the currently available billing period.
//
#define BDK_E_BAD_END_BILLING_PERIOD     ((HRESULT)0x800427E2L)

//
// MessageId: BDK_E_NEW_DUE_DATE_IS_PAST
//
// MessageText:
//
//  The new due date is in the past
//
#define BDK_E_NEW_DUE_DATE_IS_PAST       ((HRESULT)0x800427E7L)

//
// MessageId: BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED
//
// MessageText:
//
//  The new due date is more than MAXIMUM DELAY days in the future than the original due date
//
#define BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED ((HRESULT)0x800427ECL)

//
// MessageId: BDK_E_NO_NEW_DUE_DATE_SPECIFIED
//
// MessageText:
//
//  If the applydeclineEffect is off, we need a new due date specified
//
#define BDK_E_NO_NEW_DUE_DATE_SPECIFIED  ((HRESULT)0x800427F1L)

//
// MessageId: BDK_E_INVALID_TRANSACTION_TYPE
//
// MessageText:
//
//  Invalid transaction type
//
#define BDK_E_INVALID_TRANSACTION_TYPE   ((HRESULT)0x800427F6L)

//
// MessageId: BDK_E_INVALID_REASON_CODE
//
// MessageText:
//
//  Invalid reason code
//
#define BDK_E_INVALID_REASON_CODE        ((HRESULT)0x800427FBL)

//
// MessageId: BDK_E_GROUP_SID_INITIALIZATION_FAILED
//
// MessageText:
//
//  Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.
//
#define BDK_E_GROUP_SID_INITIALIZATION_FAILED ((HRESULT)0xC004280BL)

//
// MessageId: BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI
//
// MessageText:
//
//  This operation is not valid for wholesale payment instruments.
//
#define BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI ((HRESULT)0x8004280CL)

//
// MessageId: BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT
//
// MessageText:
//
//  This operation is not valid for direct debit payment instrument.
//
#define BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT ((HRESULT)0x8004280DL)

//
// MessageId: BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT
//
// MessageText:
//
//  Adjustment amount exceeds the resource credit limit.
//
#define BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT ((HRESULT)0x8004280EL)

//
// MessageId: BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS
//
// MessageText:
//
//  Adjusting a resource balance is not allowed for subscriptions that are not active.
//
#define BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS ((HRESULT)0x8004280FL)

//
// MessageId: BDK_E_FAILED_TO_CREATE_MAIL_RECORD
//
// MessageText:
//
//  Failed to create mail record for account: %1.
//
#define BDK_E_FAILED_TO_CREATE_MAIL_RECORD ((HRESULT)0x80042810L)

//
// MessageId: BDK_E_MSNIA_LATE_USAGE
//
// MessageText:
//
//  This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.
//
#define BDK_E_MSNIA_LATE_USAGE           ((HRESULT)0x80042811L)

//
// MessageId: BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB
//
// MessageText:
//
//  Failed to write asynchronous immediate settlement failure into the audit db for account: %1.
//
#define BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB ((HRESULT)0x80042812L)

//Address Validation Messages (user errors only)
//
// MessageId: BDK_E_TAXWARE_FAILURE
//
// MessageText:
//
//  Taxware error. Check the event log and the tracer.
//
#define BDK_E_TAXWARE_FAILURE            ((HRESULT)0x8004EA60L)

//
// MessageId: BDK_E_ADDRESS_VALIDATION_FAILURE
//
// MessageText:
//
//  Address validation error. Check the event log and the tracer.
//
#define BDK_E_ADDRESS_VALIDATION_FAILURE ((HRESULT)0x8004EA61L)

//
// MessageId: BDK_E_ZIP_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid ZIP code.
//
#define BDK_E_ZIP_INVALID                ((HRESULT)0x8004EA6BL)

//
// MessageId: BDK_E_STATE_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code.
//
#define BDK_E_STATE_INVALID              ((HRESULT)0x8004EA6CL)

//
// MessageId: BDK_E_ZIP_CITY_MISSING
//
// MessageText:
//
//  VERAZIP: Missing ZIP code or city name.
//
#define BDK_E_ZIP_CITY_MISSING           ((HRESULT)0x8004EA6DL)

//
// MessageId: BDK_E_STATE_ZIP_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code combination.
//
#define BDK_E_STATE_ZIP_INVALID          ((HRESULT)0x8004EA6EL)

//
// MessageId: BDK_E_STATE_CITY_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/city name combination.
//
#define BDK_E_STATE_CITY_INVALID         ((HRESULT)0x8004EA6FL)

//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
//
#define BDK_E_STATE_ZIP_CITY_INVALID     ((HRESULT)0x8004EA70L)

//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID2
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination.
//
#define BDK_E_STATE_ZIP_CITY_INVALID2    ((HRESULT)0x8004EA71L)

//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID3
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination.
//
#define BDK_E_STATE_ZIP_CITY_INVALID3    ((HRESULT)0x8004EA72L)

//
// MessageId: BDK_E_STATE_ZIP_CITY_INVALID4
//
// MessageText:
//
//  VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.
//
#define BDK_E_STATE_ZIP_CITY_INVALID4    ((HRESULT)0x8004EA73L)

//
// MessageId: BDK_E_MULTIPLE_COUNTIES_FOUND
//
// MessageText:
//
//  VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.
//
#define BDK_E_MULTIPLE_COUNTIES_FOUND    ((HRESULT)0x8004EA7DL)

//
// MessageId: BDK_E_ZIP_INVALID_FOR_ENTERED_STATE
//
// MessageText:
//
//  VERAZIP: Invalid state code for ZIP code. Changed to correct state code.
//
#define BDK_E_ZIP_INVALID_FOR_ENTERED_STATE ((HRESULT)0x8004EA7EL)

//
// MessageId: BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES
//
// MessageText:
//
//  VERAZIP: ZIP code has multiple city names.
//
#define BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES ((HRESULT)0x8004EA89L)

//
// MessageId: BDK_E_MULTIPLE_CITIES_FOUND
//
// MessageText:
//
//  VERAZIP: City has multiple ZIP codes.
//
#define BDK_E_MULTIPLE_CITIES_FOUND      ((HRESULT)0x8004EA8AL)

//
// MessageId: BDK_E_BAD_CITYNAME_LENGTH
//
// MessageText:
//
//  Incorrect city name length.
//
#define BDK_E_BAD_CITYNAME_LENGTH        ((HRESULT)0x8004EA8BL)

//
// MessageId: BDK_E_BAD_COUNTRYCODE_LENGTH
//
// MessageText:
//
//  Incorrect country code length.
//
#define BDK_E_BAD_COUNTRYCODE_LENGTH     ((HRESULT)0x8004EA8CL)

//
// MessageId: BDK_E_BAD_STATECODE_LENGTH
//
// MessageText:
//
//  Incorrect code length for state or province.
//
#define BDK_E_BAD_STATECODE_LENGTH       ((HRESULT)0x8004EA8DL)

//
// MessageId: BDK_E_BAD_ZIPCODE_LENGTH
//
// MessageText:
//
//  Incorrect zip code length.
//
#define BDK_E_BAD_ZIPCODE_LENGTH         ((HRESULT)0x8004EA8EL)

//
// MessageId: BDK_E_BAD_PRODUCTCODE_LENGTH
//
// MessageText:
//
//  Incorrect product code length.
//
#define BDK_E_BAD_PRODUCTCODE_LENGTH     ((HRESULT)0x8004EA8FL)

//
// MessageId: BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH
//
// MessageText:
//
//  Incorrect business location code length.
//
#define BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH ((HRESULT)0x8004EA90L)

//
// MessageId: BDK_E_BAD_TRANSACTIONDATE_LENGTH
//
// MessageText:
//
//  Incorrect transaction date length.
//
#define BDK_E_BAD_TRANSACTIONDATE_LENGTH ((HRESULT)0x8004EA91L)

//
// MessageId: BDK_E_BAD_VATREGISTRATION_LENGTH
//
// MessageText:
//
//  Incorrect VAT registration length.
//
#define BDK_E_BAD_VATREGISTRATION_LENGTH ((HRESULT)0x8004EA92L)

//
// MessageId: BDK_E_BAD_CURRENCYCODE_LENGTH
//
// MessageText:
//
//  Incorrect currency code length.
//
#define BDK_E_BAD_CURRENCYCODE_LENGTH    ((HRESULT)0x8004EA93L)

//
// MessageId: BDK_E_BAD_WTCODE_LENGTH
//
// MessageText:
//
//  Incorrect WorldTax code length.
//
#define BDK_E_BAD_WTCODE_LENGTH          ((HRESULT)0x8004EA94L)

//
// MessageId: BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP
//
// MessageText:
//
//  Invalid input parameter passed to TaxWare or VeraZip.
//
#define BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP ((HRESULT)0x8004EA95L)

//
// MessageId: BDK_E_UNSUPPORTED_CHAR_EXIST
//
// MessageText:
//
//  Input BSTR contains unsupported characters.
//
#define BDK_E_UNSUPPORTED_CHAR_EXIST     ((HRESULT)0x8004EA9CL)

//Token Db errors.
//
// MessageId: BDK_E_INVALID_TOKEN_SPECIFIED
//
// MessageText:
//
//  Token passed is Invalid.
//
#define BDK_E_INVALID_TOKEN_SPECIFIED    ((HRESULT)0x8004138DL)

//
// MessageId: BDK_E_TOKEN_ALREADY_BLACKLISTED
//
// MessageText:
//
//  The token is already blacklisted.
//
#define BDK_E_TOKEN_ALREADY_BLACKLISTED  ((HRESULT)0x80041392L)

//
// MessageId: BDK_E_TOKEN_ALREADY_UNBLACKLISTED
//
// MessageText:
//
//  The token is already un-blacklisted.
//
#define BDK_E_TOKEN_ALREADY_UNBLACKLISTED ((HRESULT)0x80041393L)

//
// MessageId: BDK_E_TOKEN_BLACKLISTED
//
// MessageText:
//
//  The specified token has been blacklisted.
//
#define BDK_E_TOKEN_BLACKLISTED          ((HRESULT)0x800413BFL)

//
// MessageId: BDK_E_TOKEN_RANGE_BLACKLISTED
//
// MessageText:
//
//  The specified token belongs to a blacklisted token range.
//
#define BDK_E_TOKEN_RANGE_BLACKLISTED    ((HRESULT)0x800413C4L)

//
// MessageId: BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED
//
// MessageText:
//
//  The usage for the specified token has been exceeded.
//
#define BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED ((HRESULT)0x800413C9L)

//
// MessageId: BDK_E_TOKEN_EXPIRED
//
// MessageText:
//
//  The specified token has expired.
//
#define BDK_E_TOKEN_EXPIRED              ((HRESULT)0x800413F1L)

//
// MessageId: BDK_E_TOKEN_NOT_STARTED
//
// MessageText:
//
//  The specified token cannot be used yet.
//
#define BDK_E_TOKEN_NOT_STARTED          ((HRESULT)0x800413F6L)

//
// MessageId: BDK_E_TOKEN_RANGE_NOT_ACTIVE
//
// MessageText:
//
//  The specified token has not been activated yet.
//
#define BDK_E_TOKEN_RANGE_NOT_ACTIVE     ((HRESULT)0x800413FBL)

//
// MessageId: BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE
//
// MessageText:
//
//  The reason code specified is not valid.
//
#define BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE ((HRESULT)0x8004141EL)

//
// MessageId: BDK_E_TRACKING_GUID_NODATA
//
// MessageText:
//
//  The specified action is in progress.
//
#define BDK_E_TRACKING_GUID_NODATA       ((HRESULT)0x8004145AL)

//
// MessageId: BDK_E_ALREADY_ACTIVATED
//
// MessageText:
//
//  The specified token has already been activated
//
#define BDK_E_ALREADY_ACTIVATED          ((HRESULT)0x8004146EL)

//
// MessageId: BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION
//
// MessageText:
//
//  The description specified is not valid.
//
#define BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION ((HRESULT)0x80041473L)

//
// MessageId: BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE
//
// MessageText:
//
//  Blacklist Effective date passed was prior to the order creation date.
//
#define BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE ((HRESULT)0x80041478L)

//
// MessageId: BDK_E_TOKEN_CONSUMED
//
// MessageText:
//
//  The Token has been consumed.
//
#define BDK_E_TOKEN_CONSUMED             ((HRESULT)0x8004147DL)

//
// MessageId: BDK_E_PRODUCT_KEY_NOT_AVAILABLE
//
// MessageText:
//
//  The token cannot be issued, either because the database is unavailable or there are no more unused tokens.
//
#define BDK_E_PRODUCT_KEY_NOT_AVAILABLE  ((HRESULT)0x80041488L)

//Please avoid using message id starting with 60000, reserved for TaxWare
#endif //__bdkerror_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\SampleProvider.cpp ===
// SampleProvider.cpp : Implementation of CSampleProvider
#include "stdafx.h"
#include "SPK_ISvcProvider_Sample.h"
#include "SampleProvider.h"
#include "SvcProvider_i.c"

/////////////////////////////////////////////////////////////////////////////
// CSampleProvider
HRESULT CSampleProvider::ProvisionService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrServiceInstanceFriendlyName,
            BSTR bstrBaseServiceInstanceId,
            BSTR bstrDetails,
            BSTR *pbstrResponseXML)
{
//Write Code to Provision Service here

    return S_OK;
}

HRESULT CSampleProvider::DeprovisionService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            VARIANT_BOOL RemoveServiceFlag,
            BSTR *pbstrResponseXML)
{
//Write Code to Deprovision Service here

    if (VARIANT_TRUE == RemoveServiceFlag)
    {
        //Deprovision Service
    }
    else
    {
        //Remove Role of the user
    }

    return S_OK;
}

HRESULT CSampleProvider::EnableService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR *pbstrResponseXML)
{
//Write Code to Enable Service here

    return S_OK;
}

HRESULT CSampleProvider::DisableService(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrDetails,
            BSTR *pbstrResponseXML)
{
//Write Code to Disable Service here

    return S_OK;
}

HRESULT CSampleProvider::ValidateProvisioningData(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrDetails,
            BSTR *pbstrDetailsResponse,
            BSTR *pbstrResponseXML)
{
//Write Code to Validate data here

    return S_OK;
}

HRESULT CSampleProvider::CheckProvisioningStatus(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR * pbstrResponseXML)
{
//Write Code to Check Status here

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SPK_ISvcProvider_Sample.rc
//
#define IDS_PROJNAME                    100
#define IDR_SAMPLEPROVIDER              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\inc\psomessages.h ===
#define  MAKEERROR(fac,err)   		MAKE_HRESULT(SEVERITY_ERROR,fac,err)
#define  MAKEWIN32ERROR(err)  		MAKEERROR(FACILITY_WIN32,err)
#define  GETWIN32ERROR()      		MAKEWIN32ERROR(GetLastError())
#define  MAKESCODE(fac,err)   		MAKE_HRESULT(SEVERITY_SUCCESS,fac,err)
#define  MAKEWIN32SCODE(err)  		MAKESCODE(FACILITY_WIN32,err)
#define  GETWIN32SCODE()      		MAKEWIN32SCODE(GetLastError())
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_PSOConnector            0x402
#define FACILITY_PSO                     0x401
#define FACILITY_DEFAULT                 0x100


//
// Define the severity codes
//


//
// MessageId: E_PSO_UNEXPECTED_ERROR
//
// MessageText:
//
//  Unexpected error in Partner Side Object (PSO). Contact SPG for assistance.
//
#define E_PSO_UNEXPECTED_ERROR           0x84010064L

//
// MessageId: E_PSO_HTTP_ERROR
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). Verify that the partner key provided by SPG is installed in HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that it contains an environment hive with valid WsdlLocation and WsmlLocation settings.
//
#define E_PSO_HTTP_ERROR                 0x84010065L

//
// MessageId: E_PSO_NOT_INITIALIZED
//
// MessageText:
//
//  The Partner Side Object (PSO) has not been initialized. You must first call the Initialize or the Connect method. You cannot call this function in the current state.
//
#define E_PSO_NOT_INITIALIZED            0x84010066L

//
// MessageId: E_PSO_NO_ENVIRONMENT
//
// MessageText:
//
//  Error retrieving the default partner environment name or an environment property such as WsdlLocation, WsmlLocation, or PartnerUsername. Verify that the partner key provided by SPG is installed in HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that it contains an environment hive with valid WsdlLocation and WsmlLocation settings and proper security attributes.
//
#define E_PSO_NO_ENVIRONMENT             0x84010067L

//
// MessageId: E_PSO_NO_SOAPCLIENT
//
// MessageText:
//
//  Error creating an instance of __uuidof(SoapClient). Verify that the SOAP Toolkit (version 2.0 SP2 or greater) is installed. The SOAP Toolkit is available at http://msdn.microsoft.com/xml/.
//
#define E_PSO_NO_SOAPCLIENT              0x84010068L

//
// MessageId: E_PSO_POOLCONNECTIONS
//
// MessageText:
//
//  Invalid number of PoolConnections specified. The acceptable range is between 0 and 64 connections.
//
#define E_PSO_POOLCONNECTIONS            0x84010069L

//
// MessageId: E_PSO_HTTP_ERROR_401
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). 401 - Access is denied. Check that the correct partner key MSI is installed, that the registry configuration points to the correct server, that the partner MSI package contains the correct key for the environment you are attempting to connect to, and that the server did not inadvertantly reset the partner password.
//
#define E_PSO_HTTP_ERROR_401             0x8401006AL

//
// MessageId: E_PSO_HTTP_ERROR_500
//
// MessageText:
//
//  Error retrieving WSDL and/or WSML document(s). 500 - An internal server error has occurred. This can be due to a server configuration problem.
//
#define E_PSO_HTTP_ERROR_500             0x8401006BL

//
// MessageId: E_PSO_SOAP_PROPERTY
//
// MessageText:
//
//  Error setting a property on the SoapClient connection object. Verify that the SOAP Toolkit (version 2.0 SP2 or greater) is installed, and that %ProgramFiles%\Common Files\MSSoap\Binaries\mssoap1.dll is version 1.2.814.0 or greater. The SOAP Toolkit is available at http://msdn.microsoft.com/xml/.
//
#define E_PSO_SOAP_PROPERTY              0x8401006CL

//
// MessageId: E_PSO_TEMP_PATH
//
// MessageText:
//
//  Unable to get the temporary file path.
//
#define E_PSO_TEMP_PATH                  0x8401006DL

//
// MessageId: E_PSO_TEMP_FILE
//
// MessageText:
//
//  Unable to get the temporary file name or to create a temporary file. This is generally a write permissions problem.
//  If a user has a profile, the temporary path is defined by the TEMP environment setting and is typically [HOMEPATH]\[Username]\Local Settings\Temp.
//  If a user does not have a profile, such as IWAM_Computername or IUSR_Computername, this path is either [SystemDrive]\Temp or [SystemRoot]\Temp.
//
#define E_PSO_TEMP_FILE                  0x8401006EL

//
// MessageId: E_PSO_REG_PARTNER_HIVE
//
// MessageText:
//
//  Error opening partner registry hive or hive does not exist. (Re)install the partner key.
//  Check whether HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner exists and has the proper security settings.
//  Check whether this key contains a correct Environment and PartnerHive value.
//
#define E_PSO_REG_PARTNER_HIVE           0x8401006FL

//
// MessageId: E_PSO_REG_PARTNER_VALUE
//
// MessageText:
//
//  Error reading partner registry data. (Re)install the partner key.
//  Check whether Environment and PartnerHive values exist under HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner and that the key has proper security settings.
//
#define E_PSO_REG_PARTNER_VALUE          0x84010070L

//
// MessageId: E_PSO_REG_KEY_VALUE
//
// MessageText:
//
//  Error reading partner registry password data. (Re)install the partner key.
//  Check whether HKLM\SOFTWARE\Microsoft\Subscription Platform\Partner\[Environment]\[PartnerHive]\Passwords exists and that it has proper security settings.
//
#define E_PSO_REG_KEY_VALUE              0x84010071L

//
// MessageId: S_PSOCONNECTOR_FINALCONSTRUCT
//
// MessageText:
//
//  A PSO Connector Object has been created.
//
#define S_PSOCONNECTOR_FINALCONSTRUCT    0x440200C8L

//
// MessageId: S_PSOCONNECTOR_INITIALIZED
//
// MessageText:
//
//  A PSO Connector Object has been successfully initialized.
//
#define S_PSOCONNECTOR_INITIALIZED       0x440200C9L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\SampleProvider.h ===
// SampleProvider.h : Declaration of the CSampleProvider

#ifndef __SAMPLEPROVIDER_H_
#define __SAMPLEPROVIDER_H_

#include "resource.h"       // main symbols
#include "SPK_ISvcProvider_Sample.h"

/////////////////////////////////////////////////////////////////////////////
// CSampleProvider
class ATL_NO_VTABLE CSampleProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSampleProvider, &CLSID_SampleProvider>,
	public IDispatchImpl<ISvcProvider, &IID_ISvcProvider, &LIBID_EMULATORLib>
{
public:
	CSampleProvider()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLEPROVIDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSampleProvider)
	COM_INTERFACE_ENTRY(ISvcProvider)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
// ISvcProvider
    STDMETHOD(ProvisionService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrServiceInstanceFriendlyName,
            BSTR bstrBaseServiceInstanceId,
            BSTR bstrDetails,
            BSTR * pbstrResponseXML);

    STDMETHOD(DeprovisionService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            VARIANT_BOOL RemoveServiceFlag,
            BSTR * pbstrResponseXML);
    STDMETHOD(EnableService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR * pbstrResponseXML);

    STDMETHOD(DisableService)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrServiceInstanceId,
            BSTR bstrDetails,
            BSTR * pbstrResponseXML);

    STDMETHOD(ValidateProvisioningData)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR bstrDetails,
            BSTR *pbstrDetailsResponse,
            BSTR * pbstrResponseXML);

    STDMETHOD(CheckProvisioningStatus)(
            LONG lPUIDHigh,
            LONG lPUIDLow,
            BSTR bstrServiceComponentId,
            BSTR * pbstrResponseXML);
};

#endif //__SAMPLEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\SPK_ISvcProvider_Sample.h ===
/* MIDL: this ALWAYS GENERATED file contains the definitions for the interfaces */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7DA79598_5322_4023_BE8C_7C38757E8D80__INCLUDED_)
#define AFX_STDAFX_H__7DA79598_5322_4023_BE8C_7C38757E8D80__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7DA79598_5322_4023_BE8C_7C38757E8D80__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\SPK_ISvcProvider_Sample.cpp ===
// SPK_ISvcProvider_Sample.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SPK_ISvcProvider_Sampleps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SPK_ISvcProvider_Sample.h"

#include "SPK_ISvcProvider_Sample_i.c"
#include "SampleProvider.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SampleProvider, CSampleProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SPK_ISVCPROVIDER_SAMPLELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\CSharp\demoMain.asmx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Services;

namespace demoservice
{
	/// <summary>
	/// Summary description for Service1.
	/// </summary>
	public class Service1 : System.Web.Services.WebService
	{
		public Service1()
		{
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

		#region Component Designer generated code
		
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
		
		#endregion


		// All methods support the ResponseInfo return structure which can cause three actions
		//		success, retry, or failed
		string strSuccess = "<ResponseInfo><ErrorCode/><ResponseClass>0</ResponseClass><ResponseMessage/></ResponseInfo>";
		string strRetry = "<ResponseInfo><ErrorCode/><ResponseClass>1</ResponseClass><ResponseMessage/></ResponseInfo>";
		string strFailedDontRetry = "<ResponseInfo><ErrorCode/><ResponseClass>2</ResponseClass><ResponseMessage/></ResponseInfo>";

		[WebMethod]
		public string ProvisionService( 
			int iPUIDHigh, int iPUIDLow, 
			string sServiceComponentId, 
			string sServiceInstanceId,
			string sServiceInstanceFriendlyName, 
			string sBaseServiceInstanceId,
			string sDetails )
		{
			string strReturn;
			// on failed provisioning ProvisionServices should fill in the <ErrorCode> node of ResponseInfo 
			//  can track any content errors in the sDetails XML that was passed through, this code is stored in the UPS
			//  permit for tenants to view
			strReturn = strRetry;
			strReturn = strFailedDontRetry;
			strReturn = strSuccess;

			return strReturn;
		}

		[WebMethod]
		public string DeprovisionService(
			int iPUIDHigh, int iPUIDLow, 
			string sServiceComponentId, 
			string sServiceInstanceId,
			bool bRemoveServiceFlag)
		{
			if (bRemoveServiceFlag) 
			{
				// the service is being removed
			}
			else
			{
				// merely one role of a user is being removed
			}
			return strSuccess;
		}

		[WebMethod]
		public string EnableService(
			int iPUIDHigh, int iPUIDLow, 
			string sServiceComponentId, 
			string sServiceInstanceId)
		{
			return strSuccess;
		}

		[WebMethod]
		public string DisableService(
			int iPUIDHigh, int iPUIDLow, 
			string sServiceComponentId, 
			string sServiceInstanceId,
			string sDetails)
		{
			// sDetails contains any information about why the user was Disabled
			return strSuccess;
		}

		[WebMethod]
		public string ValidateProvisioningData(
			int iPUIDHigh, int iPUIDLow, 
			string sServiceComponentId, 
			string sDetails,
			out string sDetailsResponse)
		{
			// sDetails matches the ProvisionServices sDetails and gives service a chance to tell caller
			// the data is invalid, as with ProvisionServices the ErrorCode should be filled in so the tenant
			// can translate and report the error to the caller additionally the service can fill in ResponseMessage and
			// DetailsResponse with even more data to return to the tenant.
			sDetailsResponse = "foo";
			return strSuccess;
		}
		
		[WebMethod]
		public string CheckProvisioningStatus(
			int iPUIDHigh, int iPUIDLow, 
			string sServiceComponentId)
		{
			// As with ValidateProvisiongData the ResponseMessage will be returned to the caller for more data
			return strSuccess;
		}




	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\inc\svcprovider_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for svcprovider.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISvcProvider,0x7917F8A0,0x6DCA,0x4D4E,0x91,0x59,0xBA,0x37,0x32,0xAE,0xD5,0x76);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for svcprovider.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISvcProvider,0x7917F8A0,0x6DCA,0x4D4E,0x91,0x59,0xBA,0x37,0x32,0xAE,0xD5,0x76);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\CancelSubscription.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for CancelSubscription.
	/// </summary>
	public class CancelSubscription : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        PSO.BDKProvider  PsoServer;
        XmlDocument      AmtCharged;
        XslTransform     OutXslt;
        int              iPUIDHigh, iPUIDLow, Count;
        string           ResultXML, strSubsId, strAmtCharged, strStatus, strSet;
        const string     CommentXML = "<CommentInfo xmlns='urn:schemas-microsoft-com:billing-data'>" +
                             "<CommentCode>123</CommentCode>" +
                             "<CommentText>Tired</CommentText></CommentInfo>";


            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strSubsId = (string)Request.QueryString["SubscriptionId"];

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            //Call the main function.
            PsoServer.CancelSubscription(1,
                1,
                iPUIDHigh,
                iPUIDLow,
                string.Empty,
                false,
                strSubsId,
                string.Empty,
                CommentXML,
                out ResultXML,
                out strAmtCharged,
                out strStatus,
                out Count,
                out strSet);

            if (0 == Count)
            {
                Session["ShowInfo"] = "<p>Nothing canceled for this subscription</p>";
                Response.Redirect("ShowInfo.aspx", true);
            }

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("SuccessCancelSubscription.xsl"));

            AmtCharged = new XmlDocument();
            AmtCharged.LoadXml(strAmtCharged);

            OutXslt.Transform(AmtCharged, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\BDKProvider.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using Billing.PSO;

namespace PSO
{
	/// <summary>
	/// Summary description for BDKProvider.
	/// </summary>
	public class BDKProvider : bdk
	{
        private static Billing.PSO.PsoConnectorClass mPso;
		
        static BDKProvider()
		{
            mPso = new Billing.PSO.PsoConnectorClass();
        }

        public static void Initialize()
        {
            mPso.PoolConnections = 0;
            mPso.Initialize();
        }

        public static string ErrorDescription()
        {
            return mPso.ErrorDescription;
        }

        public static int ErrorCode()
        {
            return mPso.ErrorCode;
        }

        public BDKProvider() : base()
        {
            this.Url = mPso.WsdlLocation;
            this.Credentials = new NetworkCredential(mPso.PartnerUsername,
                                                     mPso.PartnerPassword);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\inc\psoconnector.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for psoconnector.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __psoconnector_h__
#define __psoconnector_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPsoConnector_FWD_DEFINED__
#define __IPsoConnector_FWD_DEFINED__
typedef interface IPsoConnector IPsoConnector;
#endif 	/* __IPsoConnector_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mssoap.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IPsoConnector_INTERFACE_DEFINED__
#define __IPsoConnector_INTERFACE_DEFINED__

/* interface IPsoConnector */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPsoConnector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECFEB027-7719-4537-8E5D-40AA0ECE4896")
    IPsoConnector : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [retval][out] */ ISOAPClient **psoapClient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PoolConnections( 
            /* [in] */ LONG lConnectionCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PoolConnections( 
            /* [retval][out] */ LONG *lConnectionCount) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_WsdlLocation( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WsdlLocation( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerEnvironment( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerEnvironment( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerUsername( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerUsername( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PartnerPassword( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartnerPassword( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ LONG lErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ LONG *lErrorCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorDescription( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CoImpersonateClient( 
            /* [in] */ VARIANT_BOOL vImpersonate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CoImpersonateClient( 
            /* [retval][out] */ VARIANT_BOOL *vImpersonate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshConnection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPsoConnectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPsoConnector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPsoConnector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPsoConnector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPsoConnector * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPsoConnector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPsoConnector * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPsoConnector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IPsoConnector * This,
            /* [retval][out] */ ISOAPClient **psoapClient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPsoConnector * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PoolConnections )( 
            IPsoConnector * This,
            /* [in] */ LONG lConnectionCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PoolConnections )( 
            IPsoConnector * This,
            /* [retval][out] */ LONG *lConnectionCount);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WsdlLocation )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WsdlLocation )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerEnvironment )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerEnvironment )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerUsername )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerUsername )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PartnerPassword )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartnerPassword )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorCode )( 
            IPsoConnector * This,
            /* [in] */ LONG lErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IPsoConnector * This,
            /* [retval][out] */ LONG *lErrorCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorDescription )( 
            IPsoConnector * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPsoConnector * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CoImpersonateClient )( 
            IPsoConnector * This,
            /* [in] */ VARIANT_BOOL vImpersonate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CoImpersonateClient )( 
            IPsoConnector * This,
            /* [retval][out] */ VARIANT_BOOL *vImpersonate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshConnection )( 
            IPsoConnector * This);
        
        END_INTERFACE
    } IPsoConnectorVtbl;

    interface IPsoConnector
    {
        CONST_VTBL struct IPsoConnectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPsoConnector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPsoConnector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPsoConnector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPsoConnector_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPsoConnector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPsoConnector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPsoConnector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPsoConnector_Connect(This,psoapClient)	\
    (This)->lpVtbl -> Connect(This,psoapClient)

#define IPsoConnector_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IPsoConnector_get_Version(This,pbstrVal)	\
    (This)->lpVtbl -> get_Version(This,pbstrVal)

#define IPsoConnector_put_PoolConnections(This,lConnectionCount)	\
    (This)->lpVtbl -> put_PoolConnections(This,lConnectionCount)

#define IPsoConnector_get_PoolConnections(This,lConnectionCount)	\
    (This)->lpVtbl -> get_PoolConnections(This,lConnectionCount)

#define IPsoConnector_put_WsdlLocation(This,bstrVal)	\
    (This)->lpVtbl -> put_WsdlLocation(This,bstrVal)

#define IPsoConnector_get_WsdlLocation(This,pbstrVal)	\
    (This)->lpVtbl -> get_WsdlLocation(This,pbstrVal)

#define IPsoConnector_put_PartnerEnvironment(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerEnvironment(This,bstrVal)

#define IPsoConnector_get_PartnerEnvironment(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerEnvironment(This,pbstrVal)

#define IPsoConnector_put_PartnerUsername(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerUsername(This,bstrVal)

#define IPsoConnector_get_PartnerUsername(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerUsername(This,pbstrVal)

#define IPsoConnector_put_PartnerPassword(This,bstrVal)	\
    (This)->lpVtbl -> put_PartnerPassword(This,bstrVal)

#define IPsoConnector_get_PartnerPassword(This,pbstrVal)	\
    (This)->lpVtbl -> get_PartnerPassword(This,pbstrVal)

#define IPsoConnector_put_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> put_ErrorCode(This,lErrorCode)

#define IPsoConnector_get_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,lErrorCode)

#define IPsoConnector_put_ErrorDescription(This,bstrVal)	\
    (This)->lpVtbl -> put_ErrorDescription(This,bstrVal)

#define IPsoConnector_get_ErrorDescription(This,pbstrVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrVal)

#define IPsoConnector_put_CoImpersonateClient(This,vImpersonate)	\
    (This)->lpVtbl -> put_CoImpersonateClient(This,vImpersonate)

#define IPsoConnector_get_CoImpersonateClient(This,vImpersonate)	\
    (This)->lpVtbl -> get_CoImpersonateClient(This,vImpersonate)

#define IPsoConnector_RefreshConnection(This)	\
    (This)->lpVtbl -> RefreshConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_Connect_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ ISOAPClient **psoapClient);


void __RPC_STUB IPsoConnector_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_Initialize_Proxy( 
    IPsoConnector * This);


void __RPC_STUB IPsoConnector_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_Version_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PoolConnections_Proxy( 
    IPsoConnector * This,
    /* [in] */ LONG lConnectionCount);


void __RPC_STUB IPsoConnector_put_PoolConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PoolConnections_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ LONG *lConnectionCount);


void __RPC_STUB IPsoConnector_get_PoolConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_WsdlLocation_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_WsdlLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_WsdlLocation_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_WsdlLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerEnvironment_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerEnvironment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerEnvironment_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerEnvironment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerUsername_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerUsername_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_PartnerPassword_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_PartnerPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_PartnerPassword_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_PartnerPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_ErrorCode_Proxy( 
    IPsoConnector * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IPsoConnector_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_ErrorCode_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ LONG *lErrorCode);


void __RPC_STUB IPsoConnector_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_ErrorDescription_Proxy( 
    IPsoConnector * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoConnector_put_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_ErrorDescription_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoConnector_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoConnector_put_CoImpersonateClient_Proxy( 
    IPsoConnector * This,
    /* [in] */ VARIANT_BOOL vImpersonate);


void __RPC_STUB IPsoConnector_put_CoImpersonateClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoConnector_get_CoImpersonateClient_Proxy( 
    IPsoConnector * This,
    /* [retval][out] */ VARIANT_BOOL *vImpersonate);


void __RPC_STUB IPsoConnector_get_CoImpersonateClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoConnector_RefreshConnection_Proxy( 
    IPsoConnector * This);


void __RPC_STUB IPsoConnector_RefreshConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPsoConnector_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\ContactInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for ContactInfo.
	/// </summary>
	public class ContactInfo : System.Web.UI.Page
	{
        //UI Controls
        protected System.Web.UI.WebControls.Label LabFriendlyName;
        protected System.Web.UI.WebControls.Label LabExtension;
        protected System.Web.UI.WebControls.Label LabTelephone;
        protected System.Web.UI.WebControls.Label LabCountryCode;
        protected System.Web.UI.WebControls.Label LabZipCode;
        protected System.Web.UI.WebControls.Label LabStateCode;
        protected System.Web.UI.WebControls.Label LabCity;
        protected System.Web.UI.WebControls.Label LabAddLine2;
        protected System.Web.UI.WebControls.Label LabEmail;
        protected System.Web.UI.WebControls.Label LabLastName;
        protected System.Web.UI.WebControls.Label LabFirstName;
        protected System.Web.UI.WebControls.Button ButtonNext;
        protected System.Web.UI.WebControls.Label LabAddLine1;
        protected System.Web.UI.WebControls.Label LabCompany;
        protected System.Web.UI.WebControls.TextBox BoxFriendlyName;
        protected System.Web.UI.WebControls.Label LabMain;
        protected System.Web.UI.WebControls.TextBox BoxFirstName;
        protected System.Web.UI.WebControls.TextBox BoxLastName;
        protected System.Web.UI.WebControls.TextBox BoxEmail;
        protected System.Web.UI.WebControls.TextBox BoxCompany;
        protected System.Web.UI.WebControls.TextBox BoxAddLine1;
        protected System.Web.UI.WebControls.TextBox BoxAddLine2;
        protected System.Web.UI.WebControls.TextBox BoxCity;
        protected System.Web.UI.WebControls.TextBox BoxStateCode;
        protected System.Web.UI.WebControls.TextBox BoxZipCode;
        protected System.Web.UI.WebControls.TextBox BoxCountryCode;
        protected System.Web.UI.WebControls.TextBox BoxTelephone;
        protected System.Web.UI.WebControls.TextBox BoxExtension;

        //Class variables
        private XmlDocument xmlUserInfo;

		private void Page_Load(object sender, System.EventArgs e)
		{
        string UserInfoXML = "<?xml version='1.0'?><UserInfo xmlns='urn:schemas-microsoft-com:billing-data'>" +
            "<IDelegateIDHigh>1</IDelegateIDHigh><IDelegateIDLow>1</IDelegateIDLow><IRequesterIDHigh>" +
            Session["PUIDHigh"] + "</IRequesterIDHigh><IRequesterIDLow>" + Session["PUIDLow"] +
            "</IRequesterIDLow><PMN>" + Session["PMN"] + "</PMN><TrackingGUID/>" +
            "<AccountInfo><CustomerType>PERSONAL</CustomerType><FriendlyName/><FirstName/>" +
            "<LastName/><Email/><CompanyName/><Locale>en-US</Locale><Currency>USD</Currency>" +
            "<PhoneSet><Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix>" +
            "<PhoneNumber/><PhoneExtension/><CountryCode>US</CountryCode></Phone></PhoneSet>" +
            "<AddressInfoSet><AddressInfo><FriendlyName>PRIMARY</FriendlyName><Street1/><Street2/>" +
            "<City/><State/><CountryCode/><PostalCode/></AddressInfo></AddressInfoSet></AccountInfo>" +
            "<PaymentInstrumentInfo><PaymentInstrumentType>CREDITCARD</PaymentInstrumentType>" +
            "<FriendlyName>Payment Info</FriendlyName><CreditCardInfo><AccountHolderName/>" +
            "<EncryptedAccountNumber/><CardType/><ExpirationDate>112005</ExpirationDate></CreditCardInfo>" +
            "<Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber/>" +
            "<PhoneExtension/><CountryCode>US</CountryCode></Phone><AddressInfo><FriendlyName>" +
            "Credit card Address</FriendlyName><Street1/><Street2/><City/><State/><CountryCode/>" +
            "<PostalCode/></AddressInfo></PaymentInstrumentInfo></UserInfo>";

            LabMain.Text = "ContactInformation: ";
            LabFirstName.Text = "First Name: ";
            LabLastName.Text = "Last Name: ";
            LabEmail.Text = "Email Address: ";
            LabCompany.Text = "Company: ";
            LabAddLine1.Text = "Address Line 1: ";
            LabAddLine2.Text = "Address Line 2: ";
            LabCity.Text = "City: ";
            LabStateCode.Text = "State Code: ";
            LabZipCode.Text =  "Zip Code: ";
            LabCountryCode.Text = "Country Code: ";
            LabTelephone.Text = "Telephone: ";
            LabExtension.Text = "Extension: ";
            LabFriendlyName.Text = "Friendly Name for Account: ";

            BoxFriendlyName.Text = "Friendly Account Name 1";
            BoxExtension.Text = "38528";
            BoxTelephone.Text = "703-8528";
            BoxCountryCode.Text = "US";
            BoxZipCode.Text = "98052";
            BoxStateCode.Text = "WA";
            BoxCity.Text = "Redmond";
            BoxAddLine2.Text = "Bldg 116, R. No. 1624";
            BoxAddLine1.Text = "One Microsoft Way";
            BoxCompany.Text = "Microsoft Corp.";
            BoxEmail.Text = "SomeOne@SomeWhere.com";
            BoxLastName.Text = "One";
            BoxFirstName.Text = "Some";

            xmlUserInfo = new XmlDocument();
            xmlUserInfo.LoadXml(UserInfoXML);
		}

        private void ConstructXML()
        {
        XmlElement  xmlRoot;
        XmlNamespaceManager nsmgr;
        XmlNode     nodeParent, nodeChild;

            xmlRoot = xmlUserInfo.DocumentElement;

            nsmgr = new XmlNamespaceManager(xmlUserInfo.NameTable);
            nsmgr.AddNamespace("a", "urn:schemas-microsoft-com:billing-data");

            nodeParent = xmlRoot.SelectSingleNode("a:AccountInfo", nsmgr);
            nodeParent.SelectSingleNode("a:FirstName", nsmgr).InnerText = BoxFirstName.Text;
            nodeParent.SelectSingleNode("a:LastName", nsmgr).InnerText = BoxLastName.Text;
            nodeParent.SelectSingleNode("a:Email", nsmgr).InnerText = BoxEmail.Text;
            nodeParent.SelectSingleNode("a:CompanyName", nsmgr).InnerText = BoxCompany.Text;
            nodeParent.SelectSingleNode("a:FriendlyName", nsmgr).InnerText = BoxFriendlyName.Text;

            nodeChild = nodeParent.SelectSingleNode("a:PhoneSet/a:Phone", nsmgr);
            nodeChild.SelectSingleNode("a:PhoneNumber", nsmgr).InnerText = BoxTelephone.Text;
            nodeChild.SelectSingleNode("a:PhoneExtension", nsmgr).InnerText = BoxExtension.Text;

            nodeChild = nodeParent.SelectSingleNode("a:AddressInfoSet/a:AddressInfo", nsmgr);
            nodeChild.SelectSingleNode("a:Street1", nsmgr).InnerText = BoxAddLine1.Text;
            nodeChild.SelectSingleNode("a:Street2", nsmgr).InnerText = BoxAddLine2.Text;
            nodeChild.SelectSingleNode("a:City", nsmgr).InnerText = BoxCity.Text;
            nodeChild.SelectSingleNode("a:State", nsmgr).InnerText = BoxStateCode.Text;
            nodeChild.SelectSingleNode("a:CountryCode", nsmgr).InnerText = BoxCountryCode.Text;
            nodeChild.SelectSingleNode("a:PostalCode", nsmgr).InnerText = BoxZipCode.Text;

            Session["UserInfoXML"] = xmlUserInfo;
        }
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.ButtonNext.Click += new System.EventHandler(this.ButtonNext_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        private void ButtonNext_Click(object sender, System.EventArgs e)
        {
            ConstructXML();

            Response.Redirect("BillingInfo.aspx", true);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\GetBaseOfferings.aspx.cs ===
using System;
using System.IO;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for GetBaseOfferings.
	/// </summary>
	public class GetBaseOfferings : System.Web.UI.Page
	{
        //protected override HtmlTextWriter CreateHtmlTextWriter(TextWriter writer)
        //{
        //    return new MyHtmlTextWriter(writer);
        //}
        
        private void Page_Load(object sender, System.EventArgs e)
		{
        PSO.BDKProvider  PsoServer;
        XmlDocument      OfferingInfo;
        XslTransform     OutXslt;

        const string strGUID = "0";
        const string strCategory = "Free Trial";
        const string strCountry = "US";
        const string strLocale = "en-US";
        const string strCurrency = "USD";

        string ResultXML, OfferingInfoSet;
        int    Count;

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            //Call the main function.
            PsoServer.GetBaseOfferings(strGUID,
                strCategory,
                strCountry,
                strLocale,
                strCurrency,
                out ResultXML,
                out Count,
                out OfferingInfoSet);

            if (0 == Count)
            {
                Session["ShowInfo"] = "<p>This is Error: No Offerings available currently</p>";
                Response.Redirect("ShowInfo.aspx", true);
            }

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("GetBaseOfferings.xsl"));

            OfferingInfo = new XmlDocument();
            OfferingInfo.LoadXml(OfferingInfoSet);

            //Response.Write(OfferingInfoSet);
            OutXslt.Transform(OfferingInfo, null, Response.Output);
		}

#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\GetEligibleOfferings.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for GetEligibleOfferings.
	/// </summary>
	public class GetEligibleOfferings : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        string           strAcctId, strError, strOfferingInfo;
        int              iPUIDHigh, iPUIDLow, iCount;
        PSO.BDKProvider  PsoServer;
        XmlDocument      OfferingInfo;
        XslTransform     OutXslt;

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strAcctId = Request.QueryString["AccountID"];
            Session["PurchaseAccountID"] = strAcctId;

            PsoServer.GetEligibleOfferings( 1, 1, iPUIDHigh, iPUIDLow, strAcctId,
                string.Empty, "Free Trial", "BASE", out strError, out iCount,
                out strOfferingInfo);

            if (0 == iCount)
            {
                Session["ShowInfo"] = "<p>No Eligible Offerings available</p>";
                Response.Redirect("ShowInfo.aspx", true);
            }
            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("GetEligibleOfferings.xsl"));

            OfferingInfo = new XmlDocument();
            OfferingInfo.LoadXml(strOfferingInfo);

            OutXslt.Transform(OfferingInfo, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;
using PSO;

namespace SPKTenantDemo 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
        {
            PSO.BDKProvider.Initialize();
        }
 
		protected void Session_Start(Object sender, EventArgs e)
		{
            Session["PSOConnector"] =  new PSO.BDKProvider();
		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\PurchaseOfferings.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for PurchaseOfferings.
	/// </summary>
	public class PurchaseOfferings : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        PSO.BDKProvider  PsoServer;
        XmlDocument      TmpXml;
        XmlNamespaceManager nsmgr;
        XslTransform     OutXslt;
        int              iPUIDHigh, iPUIDLow, iCount;
        string           strAcctId, strError, strPayInstruSet, strPayInstruId,
                         strOfferingGuid, strSubsId, strAmountCharged,
                         strSrvInstanceSet, strSrvInstanceSetOut,
        strReferralSet = "<ReferralSet xmlns='urn:schemas-microsoft-com:billing-data'>" +
                "<Referral><ReferralType>Enter Type here</ReferralType>" +
                "<ReferralData><hello xmlns='urn:schemas-microsoft-com:dummy-data'>" +
                "embedded xml</hello></ReferralData></Referral></ReferralSet>";

            TmpXml = new XmlDocument();

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strAcctId = (string)Session["PurchaseAccountID"];
            strOfferingGuid = (string)Request.QueryString["OfferingGUID"];

            PsoServer.GetPaymentInstruments(1, 1, iPUIDHigh, iPUIDLow, strAcctId,
                                            out strError, out iCount, out strPayInstruSet);

            TmpXml.LoadXml(strPayInstruSet);
            nsmgr = new XmlNamespaceManager(TmpXml.NameTable);
            nsmgr.AddNamespace("a", "urn:schemas-microsoft-com:billing-data");
            strPayInstruId = TmpXml.SelectSingleNode("//a:PaymentInstrumentId", nsmgr).InnerText;

            PsoServer.PurchaseOffering(1, 1, iPUIDHigh, iPUIDLow, string.Empty, false, "Friendly IA Subs",
                                       strAcctId, string.Empty, strOfferingGuid, 0, strPayInstruId,
                "0", string.Empty, string.Empty, strReferralSet, out strError, out strSubsId,
                out strAmountCharged, out iCount, out strSrvInstanceSet);

            TmpXml.LoadXml(strSrvInstanceSet);

            strSrvInstanceSetOut = "<ServiceInstanceSet xmlns='urn:schemas-microsoft-com:billing-data'>" +
                "<ServiceInstance><Role>User</Role><PUIDHigh>" + iPUIDHigh.ToString() +
                "</PUIDHigh><PUIDLow>" + iPUIDLow.ToString() + "</PUIDLow><PMN>" +
                (string)Session["PMN"] + "</PMN><ServiceComponentId>" +
                TmpXml.SelectSingleNode("//a:ServiceComponentId", nsmgr).InnerText +
                "</ServiceComponentId><ServiceInstanceId>" + 
                TmpXml.SelectSingleNode("//a:ServiceInstanceId", nsmgr).InnerText +
                "</ServiceInstanceId><ServiceInstanceFriendlyName>Prov Friendly Name" +
                "</ServiceInstanceFriendlyName><BaseServiceInstanceId /><Details>" + 
                "Detail go here</Details></ServiceInstance></ServiceInstanceSet>";

            PsoServer.ProvisionServices(1, 1, iPUIDHigh, iPUIDLow, strSrvInstanceSetOut,
                                        out strError);

            TmpXml.LoadXml(strAmountCharged);

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("SuccessPurchaseOfferings.xsl"));
            OutXslt.Transform(TmpXml, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\login.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for login.
	/// </summary>
	public class login : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.Label LabMain;
        protected System.Web.UI.WebControls.Label LabName;
        protected System.Web.UI.WebControls.Label LabPassword;
        protected System.Web.UI.WebControls.TextBox BoxName;
        protected System.Web.UI.WebControls.TextBox BoxPassword;
        protected System.Web.UI.WebControls.RequiredFieldValidator ValBoxName;
        protected System.Web.UI.WebControls.RequiredFieldValidator valBoxPassword;
        protected System.Web.UI.WebControls.ValidationSummary ValSummary;
        protected System.Web.UI.WebControls.Button ButtonLogin;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
            LabMain.Text = "Please enter your passport Information:";
            LabName.Text = "User Name: ";
            LabPassword.Text = "User Password: ";
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.ButtonLogin.Click += new System.EventHandler(this.ButtonLogin_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        public void ButtonLogin_Click(object sender, System.EventArgs e)
        {
        Random r;
        int    iTmp;

            if (Page.IsValid)
            {
                //Write Authenctication code here

                if (BoxName.Text.ToLower() == "rupesh-test@microsoft.com")
                {
                    Session["PUIDHigh"] = 123456789;
                    Session["PUIDLow"] = 987654321;
                }
                else
                {
                    r = new Random();

                    iTmp = r.Next();
                    Session["PUIDHigh"] = iTmp;

                    iTmp = r.Next();
                    iTmp *= ((r.Next() % 2) == 1 ? -1 : 1); //Randomly multiply by -1
                    Session["PUIDLow"] = iTmp;
                }

                Session["PMN"] = BoxName.Text;
                FormsAuthentication.RedirectFromLoginPage(BoxName.Text, false);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\ShowInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for ShowInfo.
	/// </summary>
	public class ShowInfo : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			Response.Write((string)Session["ShowInfo"]);
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\UpdateAccountInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for UpdateAccountInfo.
	/// </summary>
	public class UpdateAccountInfo : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.Label LabFirstName;
        protected System.Web.UI.WebControls.Label LabLastName;
        protected System.Web.UI.WebControls.Label LabEmail;
        protected System.Web.UI.WebControls.Label LabCompany;
        protected System.Web.UI.WebControls.Label LabAddLine1;
        protected System.Web.UI.WebControls.Label LabAddLine2;
        protected System.Web.UI.WebControls.Label LabCity;
        protected System.Web.UI.WebControls.Label LabStateCode;
        protected System.Web.UI.WebControls.Label LabZipCode;
        protected System.Web.UI.WebControls.Label LabCountryCode;
        protected System.Web.UI.WebControls.Label LabTelephone;
        protected System.Web.UI.WebControls.Label LabExtension;
        protected System.Web.UI.WebControls.Label LabFriendlyName;
        protected System.Web.UI.WebControls.Button ButtonSubmit;
        protected System.Web.UI.WebControls.TextBox BoxFriendlyName;
        protected System.Web.UI.WebControls.TextBox BoxExtension;
        protected System.Web.UI.WebControls.TextBox BoxTelephone;
        protected System.Web.UI.WebControls.TextBox BoxCountryCode;
        protected System.Web.UI.WebControls.TextBox BoxZipCode;
        protected System.Web.UI.WebControls.TextBox BoxStateCode;
        protected System.Web.UI.WebControls.TextBox BoxCity;
        protected System.Web.UI.WebControls.TextBox BoxAddLine2;
        protected System.Web.UI.WebControls.TextBox BoxAddLine1;
        protected System.Web.UI.WebControls.TextBox BoxCompany;
        protected System.Web.UI.WebControls.TextBox BoxEmail;
        protected System.Web.UI.WebControls.TextBox BoxLastName;
        protected System.Web.UI.WebControls.TextBox BoxFirstName;
        protected System.Web.UI.WebControls.Label LabMain;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.ButtonSubmit.Click += new System.EventHandler(this.ButtonSubmit_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        private void ButtonSubmit_Click(object sender, System.EventArgs e)
        {
        int             iPUIDHigh, iPUIDLow;
        PSO.BDKProvider PsoServer;
        string          strError, strPWork;

        string strAcctInfo = "<?xml version='1.0'?><AccountInfo xmlns='urn:schemas-microsoft-com:billing-data'>" +
            "<CustomerType>PERSONAL</CustomerType><FriendlyName>" + BoxFriendlyName.Text + 
            "</FriendlyName><FirstName>" + BoxFirstName.Text + "</FirstName><LastName>" + BoxLastName.Text + 
            "</LastName><Email>" + BoxEmail.Text + "</Email><CompanyName>" + BoxCompany.Text + 
            "</CompanyName><Locale>en-US</Locale><Currency>USD</Currency>" +
            "<PhoneSet><Phone><PhoneType>WORK</PhoneType><PhonePrefix>425</PhonePrefix>" +
            "<PhoneNumber>" + BoxTelephone.Text + "</PhoneNumber><PhoneExtension>" + BoxExtension.Text +
            "</PhoneExtension><CountryCode>US</CountryCode></Phone></PhoneSet>" +
            "<AddressInfoSet><AddressInfo><FriendlyName>PRIMARY</FriendlyName><Street1>" + 
            BoxAddLine1.Text + "</Street1><Street2>" + BoxAddLine2.Text + "</Street2><City>" +
            BoxCity.Text + "</City><State>" + BoxStateCode.Text + "</State><CountryCode>" +
            BoxCountryCode.Text + "</CountryCode><PostalCode>" + BoxZipCode.Text +
            "</PostalCode></AddressInfo></AddressInfoSet></AccountInfo>";

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);
            PsoServer = (PSO.BDKProvider)Session["PsoConnector"];

            PsoServer.UpdateAccountInfo(1, 1, iPUIDHigh, iPUIDLow,
                (string)Request.QueryString["AccountID"], strAcctInfo,
                out strError, out strPWork);

            Response.Redirect("SuccessAccountUpdated.asp");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\UpdateBillingInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for UpdateBillingInfo.
	/// </summary>
	public class UpdateBillingInfo : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.Label LabFirstName;
        protected System.Web.UI.WebControls.Label LabAddLine1;
        protected System.Web.UI.WebControls.Label LabAddLine2;
        protected System.Web.UI.WebControls.Label LabCity;
        protected System.Web.UI.WebControls.Label LabStateCode;
        protected System.Web.UI.WebControls.Label LabZipCode;
        protected System.Web.UI.WebControls.Label LabCountryCode;
        protected System.Web.UI.WebControls.Label LabTelephone;
        protected System.Web.UI.WebControls.Label LabExtension;
        protected System.Web.UI.WebControls.Label LabExpDate;
        protected System.Web.UI.WebControls.Label Label1;
        protected System.Web.UI.WebControls.TextBox BoxAccName;
        protected System.Web.UI.WebControls.TextBox BoxAddLine1;
        protected System.Web.UI.WebControls.TextBox BoxAddLine2;
        protected System.Web.UI.WebControls.TextBox BoxCity;
        protected System.Web.UI.WebControls.TextBox BoxStateCode;
        protected System.Web.UI.WebControls.TextBox BoxZipCode;
        protected System.Web.UI.WebControls.TextBox BoxCountryCode;
        protected System.Web.UI.WebControls.TextBox BoxTelephone;
        protected System.Web.UI.WebControls.TextBox BoxExtension;
        protected System.Web.UI.WebControls.DropDownList DropMonth;
        protected System.Web.UI.WebControls.DropDownList DropYear;
        protected System.Web.UI.WebControls.Button ButtonSubmit;
        protected System.Web.UI.WebControls.Label LabMain;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.ButtonSubmit.Click += new System.EventHandler(this.ButtonSubmit_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        public void ButtonSubmit_Click(object sender, System.EventArgs e)
        {
            int             iPUIDHigh, iPUIDLow;
            PSO.BDKProvider PsoServer;
            string          strError;

            string strPayInstruInfo = "<?xml version='1.0'?>" + 
                "<PaymentInstrumentInfo xmlns='urn:schemas-microsoft-com:billing-data'>" +
                "<PaymentInstrumentType>CREDITCARD</PaymentInstrumentType>" +
                "<FriendlyName>Payment Info</FriendlyName><CreditCardInfo><AccountHolderName>" +
                BoxAccName.Text + "</AccountHolderName><ExpirationDate>" + DropMonth.SelectedItem.Text + 
                DropYear.SelectedItem.Text + "</ExpirationDate></CreditCardInfo>" +
                "<Phone><PhoneType>PRIMARY</PhoneType><PhonePrefix>425</PhonePrefix><PhoneNumber>" +
                BoxTelephone.Text + "</PhoneNumber><PhoneExtension>" + BoxExtension.Text +
                "</PhoneExtension><CountryCode>US</CountryCode></Phone><AddressInfo><FriendlyName>" +
                "Credit card Address</FriendlyName><Street1>" + BoxAddLine1.Text + "</Street1><Street2>" +
                BoxAddLine2.Text + "</Street2><City>" + BoxCity.Text + "</City><State>" + 
                BoxStateCode.Text + "</State><CountryCode>" + BoxCountryCode.Text + "</CountryCode><PostalCode>" +
                BoxZipCode.Text + "</PostalCode></AddressInfo></PaymentInstrumentInfo>";

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);
            PsoServer = (PSO.BDKProvider)Session["PsoConnector"];

            PsoServer.UpdatePaymentInstrumentInfo(1, 1, iPUIDHigh, iPUIDLow,
                (string)Request.QueryString["PayInstruId"], strPayInstruInfo,
                out strError);

            Response.Redirect("SuccessAccountUpdated.asp");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\UseServices.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for UseServices.
	/// </summary>
	public class UseServices : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        PSO.BDKProvider  PsoServer;
        XmlDocument      PermitSet;
        XslTransform     OutXslt;
        int              iPUIDHigh, iPUIDLow, Count;
        string           ResultXML, strPermitSet, strInstanceId;

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strInstanceId = (string)Request.QueryString["ServiceInstanceId"];

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            //Call the main function.
            PsoServer.GetPermitsForObjectId(1,
                1,
                iPUIDHigh,
                iPUIDLow,
                strInstanceId,
                true,
                out ResultXML,
                out Count,
                out strPermitSet);

            if (0 == Count)
            {
                Session["ShowInfo"] = "<p>No permits created for this subscription</p>";
                Response.Redirect("ShowInfo.aspx", true);
            }

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("SuccessGetPermits.xsl"));

            PermitSet = new XmlDocument();
            PermitSet.LoadXml(strPermitSet);

            OutXslt.Transform(PermitSet, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\UpsAuthZ.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;
using UPS;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for UpsAuthZ.
	/// </summary>
	public class UpsAuthZ : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        StoreConfigW    oStore;
        Array           oArray;
        UPSClientW      oClient;
        int             iPUIDHigh, iPUIDLow;
        string          strGUID, strTmp, strTmp1;
        string[]        ArrayDetail;
        XmlDocument     oDoc;
        XmlElement      oRoot;
        XmlNode         oCompNode, oInfoNode, oRecord, oNode;
        XslTransform     OutXslt;

            oStore = new StoreConfigW();
            oClient = oStore.GetClientObject();

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strGUID = oStore.PassportToUserId(iPUIDLow, iPUIDHigh);

            oClient.Open(strGUID);

            oClient.SetNamespace("SPGDetail_CS");
            oClient.SetNamespace("SPGSummary_CS");
            oClient.LoadNamespaces();

            oDoc = new XmlDocument();
            oNode = oDoc.CreateNode(XmlNodeType.Element, "UPSInfo", "");
            oDoc.AppendChild(oNode);
            oRoot = oDoc.DocumentElement;

            oCompNode = oDoc.CreateNode(XmlNodeType.Element, "ComponentList", "");
            oRoot.AppendChild(oCompNode);

            oInfoNode = oDoc.CreateNode(XmlNodeType.Element, "Info_A", "");
            oRoot.AppendChild(oInfoNode);

            strTmp = oClient["SPGSummary_CS.ComponentList"].ToString();

            ArrayDetail = strTmp.Split(new char[] {';'});
            foreach(string strDetail in ArrayDetail)
            {
                oNode = oDoc.CreateNode(XmlNodeType.Element, "ComponentId", "");
                oCompNode.AppendChild(oNode);

                oNode.InnerText = strDetail;
            }

            oArray = (Array)oClient["SPGDetail_CS.Info_A"];
            foreach(string strArrayInfo_A in oArray)
            {
                oRecord = oDoc.CreateNode(XmlNodeType.Element, "Record", "");
                oInfoNode.AppendChild(oRecord);

                ArrayDetail = strArrayInfo_A.Split(new char[] {';'});
                foreach(string strDetail in ArrayDetail)
                {
                    strTmp1 = String.Empty;
                    switch(strDetail.Substring(0, 3).ToUpper())
                    {
                        case "SC=": strTmp = "ServiceComponentId";
                                    strTmp1 = strDetail.Substring(3);
                                    break;
                        case "SI=": strTmp = "ServiceInstanceId";
                                    strTmp1 = strDetail.Substring(3);
                                    break;
                        case "SS=": strTmp = "SubscriptionStatus";
                                    strTmp1 = strDetail.Substring(3);
                                    break;
                        case "PS=": strTmp = "ProvisioningStatus";
                                    strTmp1 = strDetail.Substring(3);
                                    break;
                        case "EC=": strTmp = "ProvisionErrorCode";
                                    strTmp1 = strDetail.Substring(3);
                                    break;
                        case "SN=": strTmp = "ServiceFriendlyName";
                                    strTmp1 = strDetail.Substring(3);
                                    break;
                    }
                    oNode = oDoc.CreateNode(XmlNodeType.Element, strTmp, "");
                    oRecord.AppendChild(oNode);

                    oNode.InnerText = strTmp1;
                }
            }

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("UpsAuthz.xsl"));

            OutXslt.Transform(oDoc, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\inc\psoencrypter.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for psoencrypter.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __psoencrypter_h__
#define __psoencrypter_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPsoEncrypter_FWD_DEFINED__
#define __IPsoEncrypter_FWD_DEFINED__
typedef interface IPsoEncrypter IPsoEncrypter;
#endif 	/* __IPsoEncrypter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IPsoEncrypter_INTERFACE_DEFINED__
#define __IPsoEncrypter_INTERFACE_DEFINED__

/* interface IPsoEncrypter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPsoEncrypter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77298B76-8915-40c8-93E6-FBE5DDEDC5C1")
    IPsoEncrypter : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Provider( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorCode( 
            /* [in] */ LONG lErrorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ LONG *lErrorCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorDescription( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertObjectIDToAcctID( 
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateGUID( 
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConvertServiceRefIDToSubID( 
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateSessionKey( 
            /* [retval][out] */ BSTR *pbstrSessionKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR bstrEncryptedText,
            /* [in] */ BSTR bstrSessionKey,
            /* [retval][out] */ BSTR *pbstrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPsoEncrypterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPsoEncrypter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPsoEncrypter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPsoEncrypter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPsoEncrypter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPsoEncrypter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPsoEncrypter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPsoEncrypter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPsoEncrypter * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Provider )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorCode )( 
            IPsoEncrypter * This,
            /* [in] */ LONG lErrorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IPsoEncrypter * This,
            /* [retval][out] */ LONG *lErrorCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorDescription )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrBlob,
            /* [in] */ BSTR bstrKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConvertObjectIDToAcctID )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateGUID )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConvertServiceRefIDToSubID )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrVal,
            /* [retval][out] */ BSTR *pbstrValOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateSessionKey )( 
            IPsoEncrypter * This,
            /* [retval][out] */ BSTR *pbstrSessionKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )( 
            IPsoEncrypter * This,
            /* [in] */ BSTR bstrEncryptedText,
            /* [in] */ BSTR bstrSessionKey,
            /* [retval][out] */ BSTR *pbstrResult);
        
        END_INTERFACE
    } IPsoEncrypterVtbl;

    interface IPsoEncrypter
    {
        CONST_VTBL struct IPsoEncrypterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPsoEncrypter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPsoEncrypter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPsoEncrypter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPsoEncrypter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPsoEncrypter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPsoEncrypter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPsoEncrypter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPsoEncrypter_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IPsoEncrypter_get_Provider(This,pbstrVal)	\
    (This)->lpVtbl -> get_Provider(This,pbstrVal)

#define IPsoEncrypter_put_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> put_ErrorCode(This,lErrorCode)

#define IPsoEncrypter_get_ErrorCode(This,lErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,lErrorCode)

#define IPsoEncrypter_put_ErrorDescription(This,bstrVal)	\
    (This)->lpVtbl -> put_ErrorDescription(This,bstrVal)

#define IPsoEncrypter_get_ErrorDescription(This,pbstrVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrVal)

#define IPsoEncrypter_Encrypt(This,bstrBlob,bstrKey,pbstrResult)	\
    (This)->lpVtbl -> Encrypt(This,bstrBlob,bstrKey,pbstrResult)

#define IPsoEncrypter_ConvertObjectIDToAcctID(This,bstrVal,pbstrValOut)	\
    (This)->lpVtbl -> ConvertObjectIDToAcctID(This,bstrVal,pbstrValOut)

#define IPsoEncrypter_GenerateGUID(This,pbstrVal)	\
    (This)->lpVtbl -> GenerateGUID(This,pbstrVal)

#define IPsoEncrypter_ConvertServiceRefIDToSubID(This,bstrVal,pbstrValOut)	\
    (This)->lpVtbl -> ConvertServiceRefIDToSubID(This,bstrVal,pbstrValOut)

#define IPsoEncrypter_GenerateSessionKey(This,pbstrSessionKey)	\
    (This)->lpVtbl -> GenerateSessionKey(This,pbstrSessionKey)

#define IPsoEncrypter_Decrypt(This,bstrEncryptedText,bstrSessionKey,pbstrResult)	\
    (This)->lpVtbl -> Decrypt(This,bstrEncryptedText,bstrSessionKey,pbstrResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Initialize_Proxy( 
    IPsoEncrypter * This);


void __RPC_STUB IPsoEncrypter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_Provider_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_get_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_put_ErrorCode_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ LONG lErrorCode);


void __RPC_STUB IPsoEncrypter_put_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_ErrorCode_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ LONG *lErrorCode);


void __RPC_STUB IPsoEncrypter_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_put_ErrorDescription_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IPsoEncrypter_put_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_get_ErrorDescription_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Encrypt_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrBlob,
    /* [in] */ BSTR bstrKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_ConvertObjectIDToAcctID_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal,
    /* [retval][out] */ BSTR *pbstrValOut);


void __RPC_STUB IPsoEncrypter_ConvertObjectIDToAcctID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateGUID_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrVal);


void __RPC_STUB IPsoEncrypter_GenerateGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_ConvertServiceRefIDToSubID_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrVal,
    /* [retval][out] */ BSTR *pbstrValOut);


void __RPC_STUB IPsoEncrypter_ConvertServiceRefIDToSubID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_GenerateSessionKey_Proxy( 
    IPsoEncrypter * This,
    /* [retval][out] */ BSTR *pbstrSessionKey);


void __RPC_STUB IPsoEncrypter_GenerateSessionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPsoEncrypter_Decrypt_Proxy( 
    IPsoEncrypter * This,
    /* [in] */ BSTR bstrEncryptedText,
    /* [in] */ BSTR bstrSessionKey,
    /* [retval][out] */ BSTR *pbstrResult);


void __RPC_STUB IPsoEncrypter_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPsoEncrypter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\ViewAccountId.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for ViewAccountId.
	/// </summary>
	public class ViewAccountId : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
            PSO.BDKProvider  PsoServer;
            XmlDocument      AccountInfo;
            XslTransform     OutXslt;
            int              iPUIDHigh, iPUIDLow;

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            const string strBuy = "GetAccountIDFromAdminPUID_Buy.xsl";
            const string strCreate = "GetAccountIDFromAdminPUID_Create.xsl";
            const string strUse = "GetAccountIDFromAdminPUID_Use.xsl";
            const string strCancel = "GetAccountIDFromAdminPUID_Cancel.xsl";
            const string strView = "GetAccountIDFromAdminPUID_view.xsl";

            string ResultXML, AccountInfoSet, strRedirect;
            int    Count, MoreRows;

            if ((Request.QueryString["Purpose"]) == "Buy")
            {
                strRedirect = strBuy;
            }
            else if ((Request.QueryString["Purpose"]) == "Create")
            {
                strRedirect = strCreate;
            }
            else if ((Request.QueryString["Purpose"]) == "Use")
            {
                strRedirect = strUse;
            }
            else if ((Request.QueryString["Purpose"]) == "Cancel")
            {
                strRedirect = strCancel;
            }
            else
            {
                strRedirect = strView;
            }

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            //Call the main function.
            PsoServer.GetAccountIdFromAdminPUID(1,
                                                1,
                                                iPUIDHigh,
                                                iPUIDLow,
                                                false,
                                                50,
                                                out ResultXML,
                                                out MoreRows,
                                                out Count,
                                                out AccountInfoSet);

            if (0 == Count)
            {
                Response.Redirect("ContactInfo.aspx", true);
            }

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath(strRedirect));

            AccountInfo = new XmlDocument();
            AccountInfo.LoadXml(AccountInfoSet);

            OutXslt.Transform(AccountInfo, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\ViewPayInstruInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for ViewPayInstruInfo.
	/// </summary>
	public class ViewPayInstruInfo : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
            string           strAcctId, strError, strPayInfo;
            int              iPUIDHigh, iPUIDLow, iCount;
            PSO.BDKProvider  PsoServer;
            XmlDocument      PayInfo;
            XmlNode          AcctIdNode;
            XslTransform     OutXslt;

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strAcctId = Request.QueryString["AccountID"];

            PsoServer.GetPaymentInstruments(1, 1, iPUIDHigh, iPUIDLow, strAcctId,
                out strError, out iCount, out strPayInfo);

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("BillingInfo.xsl"));

            PayInfo = new XmlDocument();
            PayInfo.LoadXml(strPayInfo);

            AcctIdNode = PayInfo.CreateNode(XmlNodeType.Element, "AccountID", "urn:schemas-microsoft-com:billing-data");

            AcctIdNode.InnerText = strAcctId;

            PayInfo.DocumentElement.AppendChild(AcctIdNode);

            OutXslt.Transform(PayInfo, null, Response.Output);
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\ViewAccountInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for ViewAccountInfo.
	/// </summary>
	public class ViewAccountInfo : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        string           strAcctId, strError, strAcctInfo;
        int              iPUIDHigh, iPUIDLow;
        PSO.BDKProvider  PsoServer;
        XmlDocument      AcctInfo;
        XslTransform     OutXslt;

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strAcctId = Request.QueryString["AccountID"];

            PsoServer.GetAccountInfo(1, 1, iPUIDHigh, iPUIDLow, strAcctId,
                                     out strError, out strAcctInfo);

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath("AccountInfo.xsl"));

            AcctInfo = new XmlDocument();
            AcctInfo.LoadXml(strAcctInfo);

            OutXslt.Transform(AcctInfo, null, Response.Output);
        }
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Service_Provider_API\C++\inc\svcprovider.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for svcprovider.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __svcprovider_h__
#define __svcprovider_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISvcProvider_FWD_DEFINED__
#define __ISvcProvider_FWD_DEFINED__
typedef interface ISvcProvider ISvcProvider;
#endif 	/* __ISvcProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ISvcProvider_INTERFACE_DEFINED__
#define __ISvcProvider_INTERFACE_DEFINED__

/* interface ISvcProvider */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISvcProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7917F8A0-6DCA-4D4E-9159-BA3732AED576")
    ISvcProvider : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProvisionService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR ServiceInstanceFriendlyName,
            /* [in] */ BSTR BaseServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeprovisionService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ VARIANT_BOOL RemoveServiceFlag,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableService( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValidateProvisioningData( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR Details,
            /* [out] */ BSTR *DetailsResponse,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckProvisioningStatus( 
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [retval][out] */ BSTR *ResponseXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISvcProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISvcProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISvcProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISvcProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISvcProvider * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISvcProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISvcProvider * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISvcProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProvisionService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR ServiceInstanceFriendlyName,
            /* [in] */ BSTR BaseServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeprovisionService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ VARIANT_BOOL RemoveServiceFlag,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableService )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR ServiceInstanceId,
            /* [in] */ BSTR Details,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ValidateProvisioningData )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [in] */ BSTR Details,
            /* [out] */ BSTR *DetailsResponse,
            /* [retval][out] */ BSTR *ResponseXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckProvisioningStatus )( 
            ISvcProvider * This,
            /* [in] */ LONG PUIDHigh,
            /* [in] */ LONG PUIDLow,
            /* [in] */ BSTR ServiceComponentId,
            /* [retval][out] */ BSTR *ResponseXML);
        
        END_INTERFACE
    } ISvcProviderVtbl;

    interface ISvcProvider
    {
        CONST_VTBL struct ISvcProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISvcProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISvcProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISvcProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISvcProvider_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISvcProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISvcProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISvcProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISvcProvider_ProvisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ServiceInstanceFriendlyName,BaseServiceInstanceId,Details,ResponseXML)	\
    (This)->lpVtbl -> ProvisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ServiceInstanceFriendlyName,BaseServiceInstanceId,Details,ResponseXML)

#define ISvcProvider_DeprovisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,RemoveServiceFlag,ResponseXML)	\
    (This)->lpVtbl -> DeprovisionService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,RemoveServiceFlag,ResponseXML)

#define ISvcProvider_EnableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ResponseXML)	\
    (This)->lpVtbl -> EnableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,ResponseXML)

#define ISvcProvider_DisableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,Details,ResponseXML)	\
    (This)->lpVtbl -> DisableService(This,PUIDHigh,PUIDLow,ServiceComponentId,ServiceInstanceId,Details,ResponseXML)

#define ISvcProvider_ValidateProvisioningData(This,PUIDHigh,PUIDLow,ServiceComponentId,Details,DetailsResponse,ResponseXML)	\
    (This)->lpVtbl -> ValidateProvisioningData(This,PUIDHigh,PUIDLow,ServiceComponentId,Details,DetailsResponse,ResponseXML)

#define ISvcProvider_CheckProvisioningStatus(This,PUIDHigh,PUIDLow,ServiceComponentId,ResponseXML)	\
    (This)->lpVtbl -> CheckProvisioningStatus(This,PUIDHigh,PUIDLow,ServiceComponentId,ResponseXML)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_ProvisionService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [in] */ BSTR ServiceInstanceFriendlyName,
    /* [in] */ BSTR BaseServiceInstanceId,
    /* [in] */ BSTR Details,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_ProvisionService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_DeprovisionService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [in] */ VARIANT_BOOL RemoveServiceFlag,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_DeprovisionService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_EnableService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_EnableService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_DisableService_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR ServiceInstanceId,
    /* [in] */ BSTR Details,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_DisableService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_ValidateProvisioningData_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [in] */ BSTR Details,
    /* [out] */ BSTR *DetailsResponse,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_ValidateProvisioningData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISvcProvider_CheckProvisioningStatus_Proxy( 
    ISvcProvider * This,
    /* [in] */ LONG PUIDHigh,
    /* [in] */ LONG PUIDLow,
    /* [in] */ BSTR ServiceComponentId,
    /* [retval][out] */ BSTR *ResponseXML);


void __RPC_STUB ISvcProvider_CheckProvisioningStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISvcProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\C++\TestConnection\TestConnection.cpp ===
/*++

   Copyright (c) 2000 Microsoft Corporation

   Abstract:

       SPG PSO Partner Side Object
       TestConnection

   Author:

       Daniel Doubrovkine (ddoub)

   Project:

       SPS - Subscription Platform Service

--*/

#include <stdio.h>
#include <conio.h>
#include <atlbase.h>
#include <pso.h>
#include <psoconnector.h>

#define ChkHR(x) hr = x; if (FAILED(hr)) goto LocalCleanup;

int __cdecl main(int argc, char ** argv)
{
    HRESULT hr = S_OK;
    BOOL fCoInitialized = FALSE;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    fCoInitialized = SUCCEEDED(hr) ? TRUE : FALSE;

    {
        CComBSTR bstrVersion;

        CComBSTR bstrWsdlLocation;
        CComBSTR bstrPartnerUsername;
        CComBSTR bstrPartnerPassword;
        CComBSTR bstrPartnerEnvironment;
        LONG ulConnectionCount;
        CComVariant varArgs[2];

        CComPtr<IPsoConnector> pPsoConnector = NULL;
        CComPtr<ISOAPClient> pSoapClient = NULL;
        DISPID dwDispID = 0;
        CComBSTR bstrMethod(L"TestConnection");
        DISPPARAMS DispParams = { & varArgs[0], NULL, 2, 0 };

        printf("TestConnection: running TestConnection (ddoub)\n");

        printf("TestConnection: creating IPsoConnector\n");

        ChkHR(pPsoConnector.CoCreateInstance(__uuidof(PsoConnector)));
        ChkHR(pPsoConnector->get_Version(& bstrVersion));

        printf("TestConnection: pso version: %S\n", (LPWSTR) bstrVersion);
        printf("TestConnection: setting pool connection count to %d\n", 1);

        ChkHR(pPsoConnector->put_PoolConnections(1));

        printf("TestConnection: initializing\n");

        ChkHR(pPsoConnector->Initialize());

        printf("TestConnection: quering properties\n");

        ChkHR(pPsoConnector->get_PartnerUsername(& bstrPartnerUsername));
        ChkHR(pPsoConnector->get_PartnerPassword(& bstrPartnerPassword));
        ChkHR(pPsoConnector->get_PartnerEnvironment(& bstrPartnerEnvironment));
        ChkHR(pPsoConnector->get_WsdlLocation(& bstrWsdlLocation));
        ChkHR(pPsoConnector->get_PoolConnections(& ulConnectionCount));

        printf("TestConnection: PartnerUsername=%S\n", (LPWSTR) bstrPartnerUsername);
        // printf("TestConnection: PartnerPassword=%S\n", (LPWSTR) bstrPartnerPassword);
        printf("TestConnection: PartnerPassword=<hidden>\n");
        printf("TestConnection: PartnerEnvironment=%S\n", (LPWSTR) bstrPartnerEnvironment);
        printf("TestConnection: WsdlLocation=%S\n", (LPWSTR) bstrWsdlLocation);
        printf("TestConnection: ConnectionCount=%d\n", ulConnectionCount);

        varArgs[1] = CComBSTR(L"String");
        varArgs[0].vt = VT_EMPTY;
        varArgs[0].bstrVal = NULL;

        ChkHR(pPsoConnector->Connect(& pSoapClient));
        ChkHR(pSoapClient->GetIDsOfNames( IID_NULL, & bstrMethod, 1, LOCALE_SYSTEM_DEFAULT, & dwDispID));

        printf("TestConnection: disp id=%ld\n", dwDispID);

        ChkHR(pSoapClient->Invoke(
                  dwDispID,
                  IID_NULL,
                  LOCALE_SYSTEM_DEFAULT,
                  DISPATCH_METHOD,
                  & DispParams,
                  NULL,
                  NULL,
                  NULL));

        printf("TestConnection: retval=%ld (%S)\n", varArgs[0].vt, varArgs[0].bstrVal);

    LocalCleanup:

        if (FAILED(hr) && pSoapClient)
        {
            CComBSTR bstrFaultCode;
            CComBSTR bstrFaultString;

            if (SUCCEEDED(pSoapClient->get_faultcode(& bstrFaultCode)))
            {
                printf("TestConnection: soap fault code=%S.\n", (LPCWSTR) bstrFaultCode);
            }

            if (SUCCEEDED(pSoapClient->get_faultstring(& bstrFaultString)))
            {
                printf("TestConnection: soap fault string=%S.\n", (LPCWSTR) bstrFaultString);
            }
        }

        if (FAILED(hr) && pPsoConnector)
        {
            LONG lErrorCode = 0;
            CComBSTR bstrErrorDescription;

            if (SUCCEEDED(pPsoConnector->get_ErrorCode(& lErrorCode)))
            {
                printf("TestConnection: pso error code=%#x.\n", lErrorCode);
            }

            if (SUCCEEDED(pPsoConnector->get_ErrorDescription(& bstrErrorDescription)))
            {
                printf("TestConnection: pso error description=%S.\n", (LPCWSTR) bstrErrorDescription);
            }
        }
    }

    if (fCoInitialized)
    {
        CoUninitialize();
    }

    if (FAILED(hr))
    {
        LPSTR pszMessageBuffer = NULL;
        DWORD dwBufferLength;

        if (dwBufferLength = FormatMessageA(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
                (LPSTR) & pszMessageBuffer,
                0,
                NULL
                ))
        {
            printf("TestConnection: %s", pszMessageBuffer);
            LocalFree(pszMessageBuffer);
        }

        printf("TestConnection: error, hr=%#x\n", hr);
    }
    else
    {
        printf("TestConnection: success.\n");
    }

    {
        STARTUPINFO ProcessStartupInfo;
        GetStartupInfo(& ProcessStartupInfo);
        if (ProcessStartupInfo.dwFlags & STARTF_USESHOWWINDOW)
        {
            printf("\nPress any key to continue.");
            _getch();
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\ViewSubscriptions.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using System.Xml.Xsl;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for ViewSubscriptions.
	/// </summary>
	public class ViewSubscriptions : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
        PSO.BDKProvider  PsoServer;
        XmlDocument      SubscriptionInfo;
        XslTransform     OutXslt;
        int              iPUIDHigh, iPUIDLow, Count;
        string           ResultXML, SubscriptionInfoSet, strRedirect, strAcctId;
        const string strCancel = "ShowSubscriptionCancel.xsl";
        const string strUse = "ShowSubscriptionUse.xsl";

            iPUIDHigh = System.Convert.ToInt32(Session["PUIDHigh"]);
            iPUIDLow = System.Convert.ToInt32(Session["PUIDLow"]);

            strAcctId = (string)Request.QueryString["AccountID"];
            if ((Request.QueryString["Purpose"]) == "Cancel")
            {
                strRedirect = strCancel;
            }
            else
            {
                strRedirect = strUse;
            }

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            //Call the main function.
            PsoServer.GetSubscriptions(1,
                1,
                iPUIDHigh,
                iPUIDLow,
                strAcctId,
                out ResultXML,
                out Count,
                out SubscriptionInfoSet);

            if (0 == Count)
            {
                Session["ShowInfo"] = "<p>No subscription purchase on this account</p>";
                Response.Redirect("ShowInfo.aspx", true);
            }

            OutXslt = new XslTransform();
            OutXslt.Load(MapPath(strRedirect));

            SubscriptionInfo = new XmlDocument();
            SubscriptionInfo.LoadXml(SubscriptionInfoSet);

            OutXslt.Transform(SubscriptionInfo, null, Response.Output);
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\CSharp\TestConnection\BillingProvider.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using Billing.PSO;

public class BillingProvider : bdk
{
  // data that persists across all connections
  private static PsoConnectorClass mPso;

  // this static constructor does the key retrieval from the PSO just once,
  // before anyone uses this object
  static BillingProvider()
  {
    mPso = new PsoConnectorClass();
  }

  public static void Initialize()
  {
    // no pool connections, using C# soap interface
    mPso.PoolConnections = 0;
    // retrieve partner credentials
    mPso.Initialize();
  }

  public static String ErrorDescription()
  {
    return mPso.ErrorDescription;
  }

  public static int ErrorCode()
  {
    return mPso.ErrorCode;
  }

  public BillingProvider() : base()
  {
    // set up the bdk that we have inherited from
    this.Url = mPso.WsdlLocation;
    this.Credentials = new NetworkCredential(
     mPso.PartnerUsername,
     mPso.PartnerPassword
    );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\BillingInfo.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Xml;
using Billing.PSO;

namespace SPKTenantDemo
{
	/// <summary>
	/// Summary description for BillingInfo.
	/// </summary>
	public class BillingInfo : System.Web.UI.Page
	{
        //UI Controls
        protected System.Web.UI.WebControls.Label LabMain;
        protected System.Web.UI.WebControls.Label LabMain2;
        protected System.Web.UI.WebControls.Label LabAccName;
        protected System.Web.UI.WebControls.Label LabAddLine1;
        protected System.Web.UI.WebControls.Label LabAddLine2;
        protected System.Web.UI.WebControls.Label LabCity;
        protected System.Web.UI.WebControls.Label LabStateCode;
        protected System.Web.UI.WebControls.Label LabZipCode;
        protected System.Web.UI.WebControls.Label LabCountryCode;
        protected System.Web.UI.WebControls.Label LabTelephone;
        protected System.Web.UI.WebControls.Label LabExtension;
        protected System.Web.UI.WebControls.Label LabCreditCardNumber;
        protected System.Web.UI.WebControls.Label LabCreditCardType;
        protected System.Web.UI.WebControls.Label LabExpDate;
        protected System.Web.UI.WebControls.TextBox BoxExtension;
        protected System.Web.UI.WebControls.TextBox BoxTelephone;
        protected System.Web.UI.WebControls.TextBox BoxCountryCode;
        protected System.Web.UI.WebControls.TextBox BoxZipCode;
        protected System.Web.UI.WebControls.TextBox BoxStateCode;
        protected System.Web.UI.WebControls.TextBox BoxCity;
        protected System.Web.UI.WebControls.TextBox BoxAddLine2;
        protected System.Web.UI.WebControls.TextBox BoxAddLine1;
        protected System.Web.UI.WebControls.TextBox BoxAccName;
        protected System.Web.UI.WebControls.DropDownList DropCCard;
        protected System.Web.UI.WebControls.TextBox BoxCCNumber;
        protected System.Web.UI.WebControls.DropDownList DropMonth;
        protected System.Web.UI.WebControls.DropDownList DropYear;
        protected System.Web.UI.WebControls.Button ButtonSubmit;

        //Class variables
        private int                 iDelIdHigh, iDelIdLow, iPUIDHigh, iPUIDLow;
        private string              strPMN, strAcctInfo, strPayInfo;

        private void Page_Load(object sender, System.EventArgs e)
		{
        }

        private void ConstructXML()
        {
        XmlNamespaceManager nsmgr;
        XmlDocument         xmlUserInfo;
        XmlElement          xmlRoot;
        XmlNode             nodeParent, nodeChild;

            //Get User info from session object
            xmlUserInfo = (XmlDocument)Session["UserInfoXML"];

            //Initialize NameSpaceManager
            nsmgr = new XmlNamespaceManager(xmlUserInfo.NameTable);
            nsmgr.AddNamespace("a", "urn:schemas-microsoft-com:billing-data");

            xmlRoot = xmlUserInfo.DocumentElement;

            nodeParent = xmlRoot.SelectSingleNode("a:PaymentInstrumentInfo", nsmgr);

            nodeChild = nodeParent.SelectSingleNode("a:CreditCardInfo", nsmgr);
            nodeChild.SelectSingleNode("a:AccountHolderName", nsmgr).InnerText = BoxAccName.Text;
            nodeChild.SelectSingleNode("a:EncryptedAccountNumber", nsmgr).InnerText = BoxCCNumber.Text;
            nodeChild.SelectSingleNode("a:CardType", nsmgr).InnerText = DropCCard.SelectedItem.Text;
            nodeChild.SelectSingleNode("a:ExpirationDate", nsmgr).InnerText = (DropMonth.SelectedItem.Text + DropYear.SelectedItem.Text);

            nodeChild = nodeParent.SelectSingleNode("a:Phone", nsmgr);
            nodeChild.SelectSingleNode("a:PhoneNumber", nsmgr).InnerText = BoxTelephone.Text;
            nodeChild.SelectSingleNode("a:PhoneExtension", nsmgr).InnerText = BoxExtension.Text;

            nodeChild = nodeParent.SelectSingleNode("a:AddressInfo", nsmgr);
            nodeChild.SelectSingleNode("a:Street1", nsmgr).InnerText = BoxAddLine1.Text;
            nodeChild.SelectSingleNode("a:Street2", nsmgr).InnerText = BoxAddLine2.Text;
            nodeChild.SelectSingleNode("a:City", nsmgr).InnerText = BoxCity.Text;
            nodeChild.SelectSingleNode("a:State", nsmgr).InnerText = BoxStateCode.Text;
            nodeChild.SelectSingleNode("a:CountryCode", nsmgr).InnerText = BoxCountryCode.Text;
            nodeChild.SelectSingleNode("a:PostalCode", nsmgr).InnerText = BoxZipCode.Text;

            //Now Get the required information for CreateAccount
            iDelIdHigh = System.Convert.ToInt32(xmlRoot.SelectSingleNode("a:IDelegateIDHigh", nsmgr).InnerText);
            iDelIdLow = System.Convert.ToInt32(xmlRoot.SelectSingleNode("a:IDelegateIDLow", nsmgr).InnerText);
            iPUIDHigh = System.Convert.ToInt32(xmlRoot.SelectSingleNode("a:IRequesterIDHigh", nsmgr).InnerText);
            iPUIDLow = System.Convert.ToInt32(xmlRoot.SelectSingleNode("a:IRequesterIDLow", nsmgr).InnerText);
            strPMN = xmlRoot.SelectSingleNode("a:PMN", nsmgr).InnerText;
            strAcctInfo = xmlRoot.SelectSingleNode("a:AccountInfo", nsmgr).OuterXml;
            strPayInfo = xmlRoot.SelectSingleNode("a:PaymentInstrumentInfo", nsmgr).OuterXml;
        }

        private void EncryptCCNumber()
        {
        const string                strKeyGUID = "89BA9D19-9A04-4A15-A2A3-AF881B10FF53";

        PSO.BDKProvider             PsoServer;
        Billing.PSO.PsoEncrypterClass    PsoEncrypter;
        string                      strKeyXML, strError, strKey, strClearText, strEncText;
        XmlDocument                 KeyXML;
        XmlNamespaceManager             nsmgr;

            //Set the Pso object from session object
            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            //Get Key for Encryption
            PsoServer.GetKey(1, 1, strKeyGUID, out strError, out strKeyXML);

            //TODO check for error

            //Get Key from XML
            KeyXML = new XmlDocument();
            KeyXML.LoadXml(strKeyXML);

            nsmgr = new XmlNamespaceManager(KeyXML.NameTable);
            nsmgr.AddNamespace("a", "urn:schemas-microsoft-com:billing-data");

            strKey = KeyXML.SelectSingleNode("//a:Data", nsmgr).InnerText;

            //Encrypt the key
            strClearText = BoxCCNumber.Text;
            PsoEncrypter = new Billing.PSO.PsoEncrypterClass();
            PsoEncrypter.Initialize();
            strEncText = PsoEncrypter.Encrypt(strClearText, strKey);

            BoxCCNumber.Text = strEncText;
        }
		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.ButtonSubmit.Click += new System.EventHandler(this.ButtonSubmit_Click);
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion

        public void ButtonSubmit_Click(object sender, System.EventArgs e)
        {
        PSO.BDKProvider PsoServer;
        string strError, strAcctId, strPayId, strDate, strPWork;

            EncryptCCNumber();
            ConstructXML();

            PsoServer = (PSO.BDKProvider)Session["PSOConnector"];

            PsoServer.CreateAccount(iDelIdHigh, iDelIdLow, iPUIDHigh, iPUIDLow,
                                    strPMN, String.Empty, strAcctInfo,
                                    strPayInfo, out strError, out strAcctId,
                                    out strPayId, out strDate, out strPWork);

            Session["AccountId"] = strAcctId;

            Response.Redirect("SuccessAccountCreated.asp", true);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\CSharp\TestConnection\TestConnection.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;

public class TestConnection
{
    static void Main()
    {

        try
        {
            // initialize the provider, call this once
            System.Console.WriteLine( "success: initialize billing provider" );
            BillingProvider.Initialize();
        }
        catch (Exception eInitialize)
        {
            System.Console.WriteLine( "failure: " + eInitialize.Message );
            return;
        }

        try
        {

            string outStr;

            System.Console.WriteLine( "success: creating billing provider" );
            BillingProvider sps = new BillingProvider();

            System.Console.WriteLine( "success: running testconnection" );
            // execute the method
            sps.TestConnection( "Testing 1, 2, 3..!", out outStr );
            // show the output
            System.Console.WriteLine( "success: " + outStr );
        }
        catch (Exception eTest)
        {
            System.Console.WriteLine( "failure: " + eTest.Message );
            System.Console.WriteLine( BillingProvider.ErrorCode() );
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\ASP.Net\SPKTenantDemo\bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;

namespace PSO
{

/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol 
{
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://BDKMACHINENAME/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProcessQwestEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProcessQwestEvent(int lRequesterIdHigh, int lRequesterIdLow, string bstrEventXML) {
        this.Invoke("ProcessQwestEvent", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrEventXML});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProcessQwestEvent(int lRequesterIdHigh, int lRequesterIdLow, string bstrEventXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProcessQwestEvent", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrEventXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProcessQwestEvent(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lReasonCode, int lAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lReasonCode,
                    lAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lReasonCode, int lAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lReasonCode,
                    lAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lReasonCode, bool fImmediatelySettle, int lPercentage, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lReasonCode,
                    fImmediatelySettle,
                    lPercentage,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lReasonCode, bool fImmediatelySettle, int lPercentage, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lReasonCode,
                    fImmediatelySettle,
                    lPercentage,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\SPS\XR3\samples\Subscription_Platform_API\CSharp\TestConnection\Bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://BDKMACHINENAME/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
        object[] results = this.Invoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SignAgreement", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fReturnRemoved}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOfferingEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOfferingEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
        object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plHistoryEventCount = ((int)(results[1]));
        pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plHistoryEventCount = ((int)(results[1]));
        pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscriptionEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscriptionEx(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                string bstrPaymentInstrumentId, 
                string bstrTokenId, 
                string bstrPolicyGUID, 
                int lPolicyVersion, 
                string bstrSignatureDateTime, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML,
                    bstrPaymentInstrumentId,
                    bstrTokenId,
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrSignatureDateTime}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
        object[] results = this.Invoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID});
        pbstrErrorXML = ((string)(results[0]));
        plCount = ((int)(results[1]));
        pbstrResourcePriceSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCount = ((int)(results[1]));
        pbstrResourcePriceSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    bstrSubscriptionId,
                    lFinancialReportingCode,
                    bstrAmount,
                    fImmediatelySettle,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TestConnection(string bstrInputString, out string pbstrOutputString) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    bstrInputString});
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    bstrInputString}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrOutputString = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanUser", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lReasonCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plIsBanned = ((int)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("StopPayments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
        object[] results = this.Invoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReschedulePayment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId,
                    fApplyDeclineEffects,
                    bstrNewDueDate,
                    fStickyDueDate,
                    lTransactionType,
                    bstrSettlementDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.Invoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountActivity", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    lBillingPeriodId,
                    bstrLocale,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountActivityXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.Invoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale});
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBillingPeriods", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plBillingPeriodCount = ((int)(results[1]));
        pbstrBillingPeriodSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
        object[] results = this.Invoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet});
        errorXml = ((string)(results[0]));
        accountStatementInfoSetXml = ((string)(results[1]));
        userNotificationSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        accountStatementInfoSetXml = ((string)(results[1]));
        userNotificationSetXml = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
        object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.Invoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid});
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetKey", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrKeyGuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrKeyXml = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.Invoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId});
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAdjustments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pcAppliedAdjustmentCount = ((int)(results[1]));
        pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
        pcAvailableAdjustmentCount = ((int)(results[3]));
        pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    lBillingPeriodId,
                    bstrAdjustmentGUID,
                    bstrAmount,
                    bstrCommentTextXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CompleteConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelConversion", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAddedServiceInstanceSetCount = ((int)(results[1]));
        pbstrAddedServiceInstanceSet = ((string)(results[2]));
        plRemovedServiceInstanceSetCount = ((int)(results[3]));
        pbstrRemoveServiceInstanceSet = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
        object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML});
        pbstrResultXML = ((string)(results[0]));
        pbstrNewLineItemsXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId,
                    bstrPaymentInstrumentId,
                    bstrTaxAddressId,
                    bstrTrackingGUID,
                    bstrSettledBillingItemXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrResultXML = ((string)(results[0]));
        pbstrNewLineItemsXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
        object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        plAdminPUIDHigh = ((int)(results[1]));
        plAdminPUIDLow = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTelenumericLastName,
                    bstrZipCode,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAdminPUIDHigh = ((int)(results[1]));
        plAdminPUIDLow = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReinstateSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    lReserved,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
        object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        plPITypeCount = ((int)(results[1]));
        pbstrPITypeSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPITypeCount = ((int)(results[1]));
        pbstrPITypeSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
        this.Invoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SendHCI", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    lBillingPeriodId,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSendHCI(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
        object[] results = this.Invoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML});
        pbstrError = ((string)(results[0]));
        pbstrNewLineItemXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("OffsetLineItem2", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrLineItemId,
                    lFinancialReportingCode,
                    fImmediatelySettle,
                    bstrAmount,
                    bstrCommentInfoXML,
                    bstrReservedXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
        pbstrNewLineItemXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale});
        pbstrPolicyInfoXML = ((string)(results[0]));
        pbstrErrorXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrPolicyInfoXML = ((string)(results[0]));
        pbstrErrorXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
        object[] results = this.Invoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrNewExpirationDate = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ExtendSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    lNumberOfDays,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrNewExpirationDate = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId});
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountInfoCount = ((int)(results[1]));
        pbstrAccountInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.Invoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTokenId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
        object[] results = this.Invoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory});
        errorXml = ((string)(results[0]));
        lineItemHistorySetXml = ((string)(results[1]));
        mcv = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLineItemHistory", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    lineItemId,
                    returnHistory}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
        object[] results = this.EndInvoke(asyncResult);
        errorXml = ((string)(results[0]));
        lineItemHistorySetXml = ((string)(results[1]));
        mcv = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
        object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML});
        pbstrErrorXML = ((string)(results[0]));
        plAccountDetailCount = ((int)(results[1]));
        pbstrAccountDetailSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrCriteriaXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plAccountDetailCount = ((int)(results[1]));
        pbstrAccountDetailSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
        object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    lOffset,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
        object[] results = this.Invoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription});
        pbstrErrorXML = ((string)(results[0]));
        pbstrBlacklistActionSetXML = ((string)(results[1]));
        plBlacklistActionSetCount = ((int)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BlacklistToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType,
                    bstrEffectiveTime,
                    bstrSubscriptionAction,
                    bstrReason,
                    bstrDescription}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrBlacklistActionSetXML = ((string)(results[1]));
        plBlacklistActionSetCount = ((int)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, out string pbstrErrorXML) {
        object[] results = this.Invoke("ActivateToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrToken,
                    lTokenType}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateToken(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType});
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTokenInfoEx", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrToken,
                    lTokenType}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrTokenOrderXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeliverToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML) {
        object[] results = this.Invoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey});
        pbstrErrorXML = ((string)(results[0]));
        pbstrEncryptedTokenSetXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeliverToken", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrFilterInfoXML,
                    bstrSessionKey}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeliverToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrEncryptedTokenSetXML = ((string)(results[1]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\webstore\5.5.2421.0000\SDK\inc\WSTStore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wststore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __wststore_h__
#define __wststore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __WSTStore_FWD_DEFINED__
#define __WSTStore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSTStore WSTStore;
#else
typedef struct WSTStore WSTStore;
#endif /* __cplusplus */

#endif 	/* __WSTStore_FWD_DEFINED__ */


#ifndef __WSTSQLOLEDB_FWD_DEFINED__
#define __WSTSQLOLEDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSTSQLOLEDB WSTSQLOLEDB;
#else
typedef struct WSTSQLOLEDB WSTSQLOLEDB;
#endif /* __cplusplus */

#endif 	/* __WSTSQLOLEDB_FWD_DEFINED__ */


#ifndef __WSTFileShare_FWD_DEFINED__
#define __WSTFileShare_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSTFileShare WSTFileShare;
#else
typedef struct WSTFileShare WSTFileShare;
#endif /* __cplusplus */

#endif 	/* __WSTFileShare_FWD_DEFINED__ */


#ifndef __WSTFileStore_FWD_DEFINED__
#define __WSTFileStore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSTFileStore WSTFileStore;
#else
typedef struct WSTFileStore WSTFileStore;
#endif /* __cplusplus */

#endif 	/* __WSTFileStore_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "WSTStoreidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wststore_0000 */
/* [local] */ 

#define WebStore_TYPELIBMAJORVERSION 1
#define WebStore_TYPELIBMINORVERSION 0


extern RPC_IF_HANDLE __MIDL_itf_wststore_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststore_0000_v0_0_s_ifspec;


#ifndef __WebStore_LIBRARY_DEFINED__
#define __WebStore_LIBRARY_DEFINED__

/* library WebStore */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WebStore;

EXTERN_C const CLSID CLSID_WSTStore;

#ifdef __cplusplus

class DECLSPEC_UUID("9255D61E-4866-4E77-8E75-BF33C59E4964")
WSTStore;
#endif

EXTERN_C const CLSID CLSID_WSTSQLOLEDB;

#ifdef __cplusplus

class DECLSPEC_UUID("B7BE7E8F-4F60-40FD-997D-AF761B8C6E24")
WSTSQLOLEDB;
#endif

EXTERN_C const CLSID CLSID_WSTFileShare;

#ifdef __cplusplus

class DECLSPEC_UUID("BD5E6DF2-69A5-467f-B221-06D26E3F816D")
WSTFileShare;
#endif

EXTERN_C const CLSID CLSID_WSTFileStore;

#ifdef __cplusplus

class DECLSPEC_UUID("42A5C7DC-B0AF-4c57-B584-8C90115096F2")
WSTFileStore;
#endif
#endif /* __WebStore_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\webstore\5.5.2421.0000\SDK\inc\WSTStoreidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wststoreidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wststoreidl_h__
#define __wststoreidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSTStore_FWD_DEFINED__
#define __IWSTStore_FWD_DEFINED__
typedef interface IWSTStore IWSTStore;
#endif 	/* __IWSTStore_FWD_DEFINED__ */


#ifndef __IWSTDTC_FWD_DEFINED__
#define __IWSTDTC_FWD_DEFINED__
typedef interface IWSTDTC IWSTDTC;
#endif 	/* __IWSTDTC_FWD_DEFINED__ */


#ifndef __IWSTSession_FWD_DEFINED__
#define __IWSTSession_FWD_DEFINED__
typedef interface IWSTSession IWSTSession;
#endif 	/* __IWSTSession_FWD_DEFINED__ */


#ifndef __IWSTCommand_FWD_DEFINED__
#define __IWSTCommand_FWD_DEFINED__
typedef interface IWSTCommand IWSTCommand;
#endif 	/* __IWSTCommand_FWD_DEFINED__ */


#ifndef __IWSTHash_FWD_DEFINED__
#define __IWSTHash_FWD_DEFINED__
typedef interface IWSTHash IWSTHash;
#endif 	/* __IWSTHash_FWD_DEFINED__ */


#ifndef __IWSTProperties_FWD_DEFINED__
#define __IWSTProperties_FWD_DEFINED__
typedef interface IWSTProperties IWSTProperties;
#endif 	/* __IWSTProperties_FWD_DEFINED__ */


#ifndef __IWSTPartition_FWD_DEFINED__
#define __IWSTPartition_FWD_DEFINED__
typedef interface IWSTPartition IWSTPartition;
#endif 	/* __IWSTPartition_FWD_DEFINED__ */


#ifndef __IWSTFileShare_FWD_DEFINED__
#define __IWSTFileShare_FWD_DEFINED__
typedef interface IWSTFileShare IWSTFileShare;
#endif 	/* __IWSTFileShare_FWD_DEFINED__ */


#ifndef __IWSTFindFile_FWD_DEFINED__
#define __IWSTFindFile_FWD_DEFINED__
typedef interface IWSTFindFile IWSTFindFile;
#endif 	/* __IWSTFindFile_FWD_DEFINED__ */


#ifndef __IWSTFile_FWD_DEFINED__
#define __IWSTFile_FWD_DEFINED__
typedef interface IWSTFile IWSTFile;
#endif 	/* __IWSTFile_FWD_DEFINED__ */


#ifndef __IWSTFileStore_FWD_DEFINED__
#define __IWSTFileStore_FWD_DEFINED__
typedef interface IWSTFileStore IWSTFileStore;
#endif 	/* __IWSTFileStore_FWD_DEFINED__ */


#ifndef __IWSTSite_FWD_DEFINED__
#define __IWSTSite_FWD_DEFINED__
typedef interface IWSTSite IWSTSite;
#endif 	/* __IWSTSite_FWD_DEFINED__ */


/* header files for imported files */
#include "oledb.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_wststoreidl_0000 */
/* [local] */ 

#ifndef __WSTSTOREIDL_IDL__
#define __WSTSTOREIDL_IDL__
#if !defined(_WSTSTORE_)
#define WSTBASEAPI __declspec(dllimport)
#else
#define WSTBASEAPI __declspec(dllexport)
#endif // _WSTSTORE_
#define USE_WSTSTORE
#define ALL_DATABASES  -1
#define ANY_PARTITION  -2
#define WST_E_CONNECTIONTIMEOUT      ((HRESULT)-2001) // 0xFFFFF82F
#define WST_E_NOCONNECTIONAVAIL      ((HRESULT)-2002) // 0xFFFFF82E
#define WST_E_NOFILESHAREAVAIL       (WST_E_NOCONNECTIONAVAIL) // 0xFFFFF82E
#define WST_E_MARKEDOFFLINE          ((HRESULT)-2005) // 0xFFFFF82B
#define WST_E_MARKEDREADONLY         ((HRESULT)-2006) // 0xFFFFF82A
#define WST_E_SERVERNOTREGISTERED    ((HRESULT)-2027) // 0xFFFFF815
#define WST_E_APPLICATIONNOTEXIST    ((HRESULT)-3001) // 0xFFFFF447
#define WST_E_TRANCOUNTEXIST         ((HRESULT)-3002) // 0xFFFFF446
#define WST_E_ADMINCONSOLENOTEXIST   ((HRESULT)-3003) // 0xFFFFF445
#define WST_E_MISMATCHVERSION        ((HRESULT)-3004) // 0xFFFFF444
#define WST_E_NOSERVICEAVAIL         ((HRESULT)-3005) // 0xFFFFF443
#define WST_E_NOREGISTRY             ((HRESULT)-3006) // 0xFFFFF442
#define WST_E_APPCONFIGCHANGED       ((HRESULT)-3007) // 0xFFFFF441
#define WST_E_NAMEDPIPE              ((HRESULT)-3008) // 0xFFFFF440
#define WST_E_NOTINITIALIZED         ((HRESULT)-3009) // 0xFFFFF43F
#define WST_E_BADTICKET              ((HRESULT)-3010) // 0xFFFFF43E
#define WST_E_ALREADYINITIALIZED     ((HRESULT)-3011) // 0xFFFFF43D
#define WST_E_CONFIGEXPIRED          ((HRESULT)-3012) // 0xFFFFF43C
#define WST_E_SITENOTEXIST           ((HRESULT)-3013) // 0xFFFFF43B
#define WST_E_CONNDENIEDMAXLIMIT     ((HRESULT)-3014) // 0xFFFFF43A
#define WST_E_CONFIGSERVERDUP        ((HRESULT)-3017) // 0xFFFFF437
#define WST_E_CONFIGPOLLINCONSISTENT          ((HRESULT)-3013) // 0xFFFFF43B
typedef 
enum tagWSTCOMMANDTYPE
    {	WRITEONLY_COMMANDTYPE	= 1,
	READTHENWRITE_COMMANDTYPE	= 2,
	READONLY_COMMANDTYPE	= 3,
	WRITETHENREAD_COMMANDTYPE	= 4,
	READORWRITE_COMMANDTYPE	= 5,
	ALLDATABASES_COMMANDTYPE	= 6,
	DEFAULTREAD_COMMANDTYPE	= 7,
	DEFAULTWRITE_COMMANDTYPE	= 8,
	PRIMARYONLY_COMMANDTYPE	= WRITEONLY_COMMANDTYPE,
	SECONDARYTHENPRIMARY_COMMANDTYPE	= READTHENWRITE_COMMANDTYPE,
	SECONDARYONLY_COMMANDTYPE	= READONLY_COMMANDTYPE,
	PRIMARYTHENSECONDARY_COMMANDTYPE	= WRITETHENREAD_COMMANDTYPE,
	PRIMARYORSECONDARY_COMMANDTYPE	= READORWRITE_COMMANDTYPE,
	WRITEALLCOPIES_COMMANDTYPE	= ALLDATABASES_COMMANDTYPE,
	PRIMARYONLY_FAILOVERMODE	= PRIMARYONLY_COMMANDTYPE,
	SECONDARYTHENPRIMARY_FAILOVERMODE	= SECONDARYTHENPRIMARY_COMMANDTYPE,
	SECONDARYONLY_FAILOVERMODE	= SECONDARYONLY_COMMANDTYPE,
	PRIMARYTHENSECONDARY_FAILOVERMODE	= PRIMARYTHENSECONDARY_COMMANDTYPE,
	PRIMARYORSECONDARY_FAILOVERMODE	= PRIMARYORSECONDARY_COMMANDTYPE,
	DEFAULTREAD_FAILOVERMODE	= DEFAULTREAD_COMMANDTYPE,
	DEFAULTWRITE_FAILOVERMODE	= DEFAULTWRITE_COMMANDTYPE,
	WRITE_DBTYPE	= WRITEONLY_COMMANDTYPE,
	READ_DBTYPE	= READTHENWRITE_COMMANDTYPE
    } 	WSTCOMMANDTYPE;

typedef WSTCOMMANDTYPE WSTDBTYPE;

typedef WSTCOMMANDTYPE WSTFAILOVERMODE;

typedef struct tagWSTCOMMANDPARAM
    {
    LONG nOrdinal;
    LONG paramIO;
    LONG paramType;
    LONG paramSize;
    LONG paramOffset;
    LONG paramStatusOffset;
    LPCWSTR paramName;
    } 	WSTCOMMANDPARAM;

typedef struct tagWSTCOMMANDINFO
    {
    LONG cbParam;
    /* [size_is] */ LPVOID pParam;
    LONG nParams;
    WSTCOMMANDPARAM *rgParams;
    } 	WSTCOMMANDINFO;

typedef 
enum tagWSTSECURITYTYPE
    {	DB_SECURITY_TYPE	= 0,
	NT_SECURITY_TYPE	= 1
    } 	WSTSECURITYTYPE;

typedef 
enum tagWSTCOMMANDPROP
    {	WSTPROP_SECURITYTYPE	= 0,
	WSTPROP_USERNAME	= 1,
	WSTPROP_PASSWORD	= 2,
	WSTPROP_RESERVED	= 3,
	WSTPROP_SHOWOLEDBEVENT	= 4,
	WSTPROP_USEPHYSICALPARTITION	= 5,
	WSTPROP_PHYSICALPARTITIONS	= 6,
	WSTPROP_LOGICALPARTITIONS	= 7,
	WSTPROP_APPLICATION	= 8,
	WSTPROP_COMMANDTYPE	= 9,
	WSTPROP_PARTITIONNUMBER	= 10,
	WSTPROP_FORCEREAD	= 11
    } 	WSTCOMMANDPROP;

typedef struct tagWSTOVERLAPPED
    {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union 
        {
        struct 
            {
            DWORD Offset;
            DWORD OffsetHigh;
            } 	;
        PVOID Pointer;
        } 	;
    HANDLE hEvent;
    } 	WSTOVERLAPPED;

typedef struct tagWSTOVERLAPPED *LPWSTOVERLAPPED;

// {F9E76340-B686-4dab-9101-73D7E13D5B5B}
DEFINE_GUID(IID_IWSTStore, 0xF9E76340, 0xB686, 0x4dab, 0x91, 0x01, 0x73, 0xD7, 0xE1, 0x3D, 0x5B, 0x5B);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0000_v0_0_s_ifspec;

#ifndef __IWSTStore_INTERFACE_DEFINED__
#define __IWSTStore_INTERFACE_DEFINED__

/* interface IWSTStore */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9E76340-B686-4dab-9101-73D7E13D5B5B")
    IWSTStore : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR strAppName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeInitialize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTStore * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWSTStore * This,
            /* [in] */ LPCWSTR strAppName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeInitialize )( 
            IWSTStore * This);
        
        END_INTERFACE
    } IWSTStoreVtbl;

    interface IWSTStore
    {
        CONST_VTBL struct IWSTStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTStore_Initialize(This,strAppName)	\
    (This)->lpVtbl -> Initialize(This,strAppName)

#define IWSTStore_DeInitialize(This)	\
    (This)->lpVtbl -> DeInitialize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTStore_Initialize_Proxy( 
    IWSTStore * This,
    /* [in] */ LPCWSTR strAppName);


void __RPC_STUB IWSTStore_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTStore_DeInitialize_Proxy( 
    IWSTStore * This);


void __RPC_STUB IWSTStore_DeInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0356 */
/* [local] */ 

// {5E743039-E626-4bf0-8ED4-F5B08E33437B}
DEFINE_GUID(IID_IWSTDTC, 0x5E743039, 0xE626, 0x4bf0, 0x8E, 0xD4, 0xF5, 0xB0, 0x8E, 0x33, 0x43, 0x7B);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0356_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0356_v0_0_s_ifspec;

#ifndef __IWSTDTC_INTERFACE_DEFINED__
#define __IWSTDTC_INTERFACE_DEFINED__

/* interface IWSTDTC */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTDTC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5E743039-E626-4bf0-8ED4-F5B08E33437B")
    IWSTDTC : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [defaultvalue][in] */ LONG isoLevel = 0x1000) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CommitTransaction( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AbortTransaction( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTDTCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTDTC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTDTC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTDTC * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IWSTDTC * This,
            /* [defaultvalue][in] */ LONG isoLevel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CommitTransaction )( 
            IWSTDTC * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AbortTransaction )( 
            IWSTDTC * This);
        
        END_INTERFACE
    } IWSTDTCVtbl;

    interface IWSTDTC
    {
        CONST_VTBL struct IWSTDTCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTDTC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTDTC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTDTC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTDTC_BeginTransaction(This,isoLevel)	\
    (This)->lpVtbl -> BeginTransaction(This,isoLevel)

#define IWSTDTC_CommitTransaction(This)	\
    (This)->lpVtbl -> CommitTransaction(This)

#define IWSTDTC_AbortTransaction(This)	\
    (This)->lpVtbl -> AbortTransaction(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTDTC_BeginTransaction_Proxy( 
    IWSTDTC * This,
    /* [defaultvalue][in] */ LONG isoLevel);


void __RPC_STUB IWSTDTC_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTDTC_CommitTransaction_Proxy( 
    IWSTDTC * This);


void __RPC_STUB IWSTDTC_CommitTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTDTC_AbortTransaction_Proxy( 
    IWSTDTC * This);


void __RPC_STUB IWSTDTC_AbortTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTDTC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0357 */
/* [local] */ 

// {5C737F8A-C48D-4ffa-A2BD-9770907E5438}
DEFINE_GUID(IID_IWSTSession, 0x5C737F8A, 0xC48D, 0x4ffa, 0xA2, 0xBD, 0x97, 0x70, 0x90, 0x7E, 0x54, 0x38);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0357_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0357_v0_0_s_ifspec;

#ifndef __IWSTSession_INTERFACE_DEFINED__
#define __IWSTSession_INTERFACE_DEFINED__

/* interface IWSTSession */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C737F8A-C48D-4ffa-A2BD-9770907E5438")
    IWSTSession : public IUnknown
    {
    public:
        virtual /* [local][helpstring] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ LPCWSTR strCmd,
            /* [in] */ WSTCOMMANDINFO *pCmdInfo,
            /* [out] */ IUnknown **ppResults,
            /* [defaultvalue][in] */ IWSTDTC *pDTC = 0,
            /* [defaultvalue][in] */ REFGUID rguidCmd = ( REFGUID  )L"\0\0\0\0\0\0\0",
            /* [defaultvalue][in] */ REFIID riidResult = ( REFGUID  )L"\0\0\0\0\0\0\0") = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTSession * This);
        
        /* [local][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWSTSession * This,
            /* [in] */ LPCWSTR strCmd,
            /* [in] */ WSTCOMMANDINFO *pCmdInfo,
            /* [out] */ IUnknown **ppResults,
            /* [defaultvalue][in] */ IWSTDTC *pDTC,
            /* [defaultvalue][in] */ REFGUID rguidCmd,
            /* [defaultvalue][in] */ REFIID riidResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IWSTSession * This,
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT value);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IWSTSession * This,
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT *pValue);
        
        END_INTERFACE
    } IWSTSessionVtbl;

    interface IWSTSession
    {
        CONST_VTBL struct IWSTSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTSession_Execute(This,strCmd,pCmdInfo,ppResults,pDTC,rguidCmd,riidResult)	\
    (This)->lpVtbl -> Execute(This,strCmd,pCmdInfo,ppResults,pDTC,rguidCmd,riidResult)

#define IWSTSession_SetProperty(This,prop,value)	\
    (This)->lpVtbl -> SetProperty(This,prop,value)

#define IWSTSession_GetProperty(This,prop,pValue)	\
    (This)->lpVtbl -> GetProperty(This,prop,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local][helpstring] */ HRESULT STDMETHODCALLTYPE IWSTSession_Execute_Proxy( 
    IWSTSession * This,
    /* [in] */ LPCWSTR strCmd,
    /* [in] */ WSTCOMMANDINFO *pCmdInfo,
    /* [out] */ IUnknown **ppResults,
    /* [defaultvalue][in] */ IWSTDTC *pDTC,
    /* [defaultvalue][in] */ REFGUID rguidCmd,
    /* [defaultvalue][in] */ REFIID riidResult);


void __RPC_STUB IWSTSession_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTSession_SetProperty_Proxy( 
    IWSTSession * This,
    /* [in] */ WSTCOMMANDPROP prop,
    /* [in] */ VARIANT value);


void __RPC_STUB IWSTSession_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTSession_GetProperty_Proxy( 
    IWSTSession * This,
    /* [in] */ WSTCOMMANDPROP prop,
    /* [in] */ VARIANT *pValue);


void __RPC_STUB IWSTSession_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0358 */
/* [local] */ 

// {19D2A4E7-3074-4f32-A1CB-733A3CC33BE9}
DEFINE_GUID(IID_IWSTCommand, 0x19D2A4E7, 0x3074, 0x4f32, 0xA1, 0xCB, 0x73, 0x3A, 0x3C, 0xC3, 0x3B, 0xE9);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0358_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0358_v0_0_s_ifspec;

#ifndef __IWSTCommand_INTERFACE_DEFINED__
#define __IWSTCommand_INTERFACE_DEFINED__

/* interface IWSTCommand */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTCommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19D2A4E7-3074-4f32-A1CB-733A3CC33BE9")
    IWSTCommand : public IUnknown
    {
    public:
        virtual /* [local][helpstring] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ WSTCOMMANDTYPE cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ LPCWSTR strCmd,
            /* [in] */ WSTCOMMANDINFO *pCmdInfo,
            /* [out] */ IUnknown **ppResults,
            /* [defaultvalue][in] */ IWSTDTC *pDTC = 0,
            /* [defaultvalue][in] */ REFGUID rguidCmd = ( REFGUID  )L"\0\0\0\0\0\0\0",
            /* [defaultvalue][in] */ REFIID riidResult = ( REFGUID  )L"\0\0\0\0\0\0\0") = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ WSTCOMMANDTYPE cmdType,
            /* [in] */ LONG lHash,
            /* [out] */ IWSTSession **ppSession) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDTC( 
            /* [out] */ IWSTDTC **ppDTC) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTCommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTCommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTCommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTCommand * This);
        
        /* [local][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWSTCommand * This,
            /* [in] */ WSTCOMMANDTYPE cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ LPCWSTR strCmd,
            /* [in] */ WSTCOMMANDINFO *pCmdInfo,
            /* [out] */ IUnknown **ppResults,
            /* [defaultvalue][in] */ IWSTDTC *pDTC,
            /* [defaultvalue][in] */ REFGUID rguidCmd,
            /* [defaultvalue][in] */ REFIID riidResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IWSTCommand * This,
            /* [in] */ WSTCOMMANDTYPE cmdType,
            /* [in] */ LONG lHash,
            /* [out] */ IWSTSession **ppSession);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDTC )( 
            IWSTCommand * This,
            /* [out] */ IWSTDTC **ppDTC);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IWSTCommand * This,
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT value);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IWSTCommand * This,
            /* [in] */ WSTCOMMANDPROP prop,
            /* [in] */ VARIANT *pValue);
        
        END_INTERFACE
    } IWSTCommandVtbl;

    interface IWSTCommand
    {
        CONST_VTBL struct IWSTCommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTCommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTCommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTCommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTCommand_Execute(This,cmdType,lHash,strCmd,pCmdInfo,ppResults,pDTC,rguidCmd,riidResult)	\
    (This)->lpVtbl -> Execute(This,cmdType,lHash,strCmd,pCmdInfo,ppResults,pDTC,rguidCmd,riidResult)

#define IWSTCommand_GetSession(This,cmdType,lHash,ppSession)	\
    (This)->lpVtbl -> GetSession(This,cmdType,lHash,ppSession)

#define IWSTCommand_GetDTC(This,ppDTC)	\
    (This)->lpVtbl -> GetDTC(This,ppDTC)

#define IWSTCommand_SetProperty(This,prop,value)	\
    (This)->lpVtbl -> SetProperty(This,prop,value)

#define IWSTCommand_GetProperty(This,prop,pValue)	\
    (This)->lpVtbl -> GetProperty(This,prop,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local][helpstring] */ HRESULT STDMETHODCALLTYPE IWSTCommand_Execute_Proxy( 
    IWSTCommand * This,
    /* [in] */ WSTCOMMANDTYPE cmdType,
    /* [in] */ LONG lHash,
    /* [in] */ LPCWSTR strCmd,
    /* [in] */ WSTCOMMANDINFO *pCmdInfo,
    /* [out] */ IUnknown **ppResults,
    /* [defaultvalue][in] */ IWSTDTC *pDTC,
    /* [defaultvalue][in] */ REFGUID rguidCmd,
    /* [defaultvalue][in] */ REFIID riidResult);


void __RPC_STUB IWSTCommand_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTCommand_GetSession_Proxy( 
    IWSTCommand * This,
    /* [in] */ WSTCOMMANDTYPE cmdType,
    /* [in] */ LONG lHash,
    /* [out] */ IWSTSession **ppSession);


void __RPC_STUB IWSTCommand_GetSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTCommand_GetDTC_Proxy( 
    IWSTCommand * This,
    /* [out] */ IWSTDTC **ppDTC);


void __RPC_STUB IWSTCommand_GetDTC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTCommand_SetProperty_Proxy( 
    IWSTCommand * This,
    /* [in] */ WSTCOMMANDPROP prop,
    /* [in] */ VARIANT value);


void __RPC_STUB IWSTCommand_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTCommand_GetProperty_Proxy( 
    IWSTCommand * This,
    /* [in] */ WSTCOMMANDPROP prop,
    /* [in] */ VARIANT *pValue);


void __RPC_STUB IWSTCommand_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTCommand_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0359 */
/* [local] */ 

// {2B8D4993-F783-4ef4-979A-16D41044CB81}
DEFINE_GUID(IID_IWSTHash, 0x2B8D4993, 0xF783, 0x4ef4, 0x97, 0x9A, 0x16, 0xD4, 0x10, 0x44, 0xCB, 0x81);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0359_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0359_v0_0_s_ifspec;

#ifndef __IWSTHash_INTERFACE_DEFINED__
#define __IWSTHash_INTERFACE_DEFINED__

/* interface IWSTHash */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTHash;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8D4993-F783-4ef4-979A-16D41044CB81")
    IWSTHash : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HashBSTR( 
            /* [in] */ LPCWSTR strData,
            /* [retval][out] */ LONG *plHash) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HashLARGEINTEGER( 
            /* [in] */ LARGE_INTEGER li,
            /* [retval][out] */ LONG *plHash) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ LONG *plCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTHashVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTHash * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTHash * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTHash * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HashBSTR )( 
            IWSTHash * This,
            /* [in] */ LPCWSTR strData,
            /* [retval][out] */ LONG *plHash);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HashLARGEINTEGER )( 
            IWSTHash * This,
            /* [in] */ LARGE_INTEGER li,
            /* [retval][out] */ LONG *plHash);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IWSTHash * This,
            /* [retval][out] */ LONG *plCount);
        
        END_INTERFACE
    } IWSTHashVtbl;

    interface IWSTHash
    {
        CONST_VTBL struct IWSTHashVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTHash_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTHash_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTHash_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTHash_HashBSTR(This,strData,plHash)	\
    (This)->lpVtbl -> HashBSTR(This,strData,plHash)

#define IWSTHash_HashLARGEINTEGER(This,li,plHash)	\
    (This)->lpVtbl -> HashLARGEINTEGER(This,li,plHash)

#define IWSTHash_GetCount(This,plCount)	\
    (This)->lpVtbl -> GetCount(This,plCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTHash_HashBSTR_Proxy( 
    IWSTHash * This,
    /* [in] */ LPCWSTR strData,
    /* [retval][out] */ LONG *plHash);


void __RPC_STUB IWSTHash_HashBSTR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTHash_HashLARGEINTEGER_Proxy( 
    IWSTHash * This,
    /* [in] */ LARGE_INTEGER li,
    /* [retval][out] */ LONG *plHash);


void __RPC_STUB IWSTHash_HashLARGEINTEGER_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTHash_GetCount_Proxy( 
    IWSTHash * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IWSTHash_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTHash_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0360 */
/* [local] */ 

// {E68AC5DF-C54C-427a-A42B-416F28D54257}
DEFINE_GUID(DBPROPSET_WEBSTORE, 0xE68AC5DF, 0xC54C, 0x427a, 0xA4, 0x2B, 0x41, 0x6F, 0x28, 0xD5, 0x42, 0x57);
// {C01019FB-4BF4-4861-9D79-42BB1A8D8A69}
DEFINE_GUID(IID_IWSTProperties, 0xC01019FB, 0x4BF4, 0x4861, 0x9D, 0x79, 0x42, 0xBB, 0x1A, 0x8D, 0x8A, 0x69);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0360_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0360_v0_0_s_ifspec;

#ifndef __IWSTProperties_INTERFACE_DEFINED__
#define __IWSTProperties_INTERFACE_DEFINED__

/* interface IWSTProperties */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C01019FB-4BF4-4861-9D79-42BB1A8D8A69")
    IWSTProperties : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ REFIID riid,
            /* [out][in] */ ULONG *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET **prgPropertySets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetProperties( 
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET rgPropertySets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTProperties * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IWSTProperties * This,
            /* [in] */ REFIID riid,
            /* [out][in] */ ULONG *pcPropertySets,
            /* [size_is][size_is][out] */ DBPROPSET **prgPropertySets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetProperties )( 
            IWSTProperties * This,
            /* [in] */ REFIID riid,
            /* [in] */ ULONG cPropertySets,
            /* [size_is][unique][out][in] */ DBPROPSET rgPropertySets[  ]);
        
        END_INTERFACE
    } IWSTPropertiesVtbl;

    interface IWSTProperties
    {
        CONST_VTBL struct IWSTPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTProperties_GetProperties(This,riid,pcPropertySets,prgPropertySets)	\
    (This)->lpVtbl -> GetProperties(This,riid,pcPropertySets,prgPropertySets)

#define IWSTProperties_SetProperties(This,riid,cPropertySets,rgPropertySets)	\
    (This)->lpVtbl -> SetProperties(This,riid,cPropertySets,rgPropertySets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTProperties_GetProperties_Proxy( 
    IWSTProperties * This,
    /* [in] */ REFIID riid,
    /* [out][in] */ ULONG *pcPropertySets,
    /* [size_is][size_is][out] */ DBPROPSET **prgPropertySets);


void __RPC_STUB IWSTProperties_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTProperties_SetProperties_Proxy( 
    IWSTProperties * This,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][out][in] */ DBPROPSET rgPropertySets[  ]);


void __RPC_STUB IWSTProperties_SetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0361 */
/* [local] */ 

typedef 
enum tagWSTPARTITIONMODE
    {	LOGICAL_MODE	= 0,
	PHYSICAL_MODE	= 1
    } 	WSTPARTITIONMODE;

// {40BCAFB9-4778-4305-82E5-BA751E7B3E26}
DEFINE_GUID(IID_IWSTPartition, 0x40BCAFB9, 0x4778, 0x4305, 0x82, 0xE5, 0xBA, 0x75, 0x1E, 0x7B, 0x3E, 0x26);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0361_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0361_v0_0_s_ifspec;

#ifndef __IWSTPartition_INTERFACE_DEFINED__
#define __IWSTPartition_INTERFACE_DEFINED__

/* interface IWSTPartition */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWSTPartition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40BCAFB9-4778-4305-82E5-BA751E7B3E26")
    IWSTPartition : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLogicalCount( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPhysicalCount( 
            /* [retval][out] */ LONG *plCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ WSTPARTITIONMODE mode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMode( 
            /* [retval][out] */ WSTPARTITIONMODE *pMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPartition( 
            /* [in] */ LONG partition) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartition( 
            /* [retval][out] */ LONG *pPartition) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFailover( 
            /* [in] */ WSTCOMMANDTYPE cmdType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFailover( 
            /* [retval][out] */ WSTCOMMANDTYPE *pCmdType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPhysicalFromLogical( 
            /* [in] */ LONG logical,
            /* [retval][out] */ LONG *pPhysical) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTPartitionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTPartition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTPartition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTPartition * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLogicalCount )( 
            IWSTPartition * This,
            /* [retval][out] */ LONG *plCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPhysicalCount )( 
            IWSTPartition * This,
            /* [retval][out] */ LONG *plCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMode )( 
            IWSTPartition * This,
            /* [in] */ WSTPARTITIONMODE mode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IWSTPartition * This,
            /* [retval][out] */ WSTPARTITIONMODE *pMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPartition )( 
            IWSTPartition * This,
            /* [in] */ LONG partition);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartition )( 
            IWSTPartition * This,
            /* [retval][out] */ LONG *pPartition);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFailover )( 
            IWSTPartition * This,
            /* [in] */ WSTCOMMANDTYPE cmdType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFailover )( 
            IWSTPartition * This,
            /* [retval][out] */ WSTCOMMANDTYPE *pCmdType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPhysicalFromLogical )( 
            IWSTPartition * This,
            /* [in] */ LONG logical,
            /* [retval][out] */ LONG *pPhysical);
        
        END_INTERFACE
    } IWSTPartitionVtbl;

    interface IWSTPartition
    {
        CONST_VTBL struct IWSTPartitionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTPartition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTPartition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTPartition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTPartition_GetLogicalCount(This,plCount)	\
    (This)->lpVtbl -> GetLogicalCount(This,plCount)

#define IWSTPartition_GetPhysicalCount(This,plCount)	\
    (This)->lpVtbl -> GetPhysicalCount(This,plCount)

#define IWSTPartition_SetMode(This,mode)	\
    (This)->lpVtbl -> SetMode(This,mode)

#define IWSTPartition_GetMode(This,pMode)	\
    (This)->lpVtbl -> GetMode(This,pMode)

#define IWSTPartition_SetPartition(This,partition)	\
    (This)->lpVtbl -> SetPartition(This,partition)

#define IWSTPartition_GetPartition(This,pPartition)	\
    (This)->lpVtbl -> GetPartition(This,pPartition)

#define IWSTPartition_SetFailover(This,cmdType)	\
    (This)->lpVtbl -> SetFailover(This,cmdType)

#define IWSTPartition_GetFailover(This,pCmdType)	\
    (This)->lpVtbl -> GetFailover(This,pCmdType)

#define IWSTPartition_GetPhysicalFromLogical(This,logical,pPhysical)	\
    (This)->lpVtbl -> GetPhysicalFromLogical(This,logical,pPhysical)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_GetLogicalCount_Proxy( 
    IWSTPartition * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IWSTPartition_GetLogicalCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_GetPhysicalCount_Proxy( 
    IWSTPartition * This,
    /* [retval][out] */ LONG *plCount);


void __RPC_STUB IWSTPartition_GetPhysicalCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_SetMode_Proxy( 
    IWSTPartition * This,
    /* [in] */ WSTPARTITIONMODE mode);


void __RPC_STUB IWSTPartition_SetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_GetMode_Proxy( 
    IWSTPartition * This,
    /* [retval][out] */ WSTPARTITIONMODE *pMode);


void __RPC_STUB IWSTPartition_GetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_SetPartition_Proxy( 
    IWSTPartition * This,
    /* [in] */ LONG partition);


void __RPC_STUB IWSTPartition_SetPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_GetPartition_Proxy( 
    IWSTPartition * This,
    /* [retval][out] */ LONG *pPartition);


void __RPC_STUB IWSTPartition_GetPartition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_SetFailover_Proxy( 
    IWSTPartition * This,
    /* [in] */ WSTCOMMANDTYPE cmdType);


void __RPC_STUB IWSTPartition_SetFailover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_GetFailover_Proxy( 
    IWSTPartition * This,
    /* [retval][out] */ WSTCOMMANDTYPE *pCmdType);


void __RPC_STUB IWSTPartition_GetFailover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTPartition_GetPhysicalFromLogical_Proxy( 
    IWSTPartition * This,
    /* [in] */ LONG logical,
    /* [retval][out] */ LONG *pPhysical);


void __RPC_STUB IWSTPartition_GetPhysicalFromLogical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTPartition_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0362 */
/* [local] */ 

typedef struct _WSTCONTEXT
    {
    DWORD nLength;
    LPCWSTR lpDeploymentName;
    LONG iPartition;
    WSTPARTITIONMODE partitionMode;
    WSTFAILOVERMODE failoverMode;
    } 	WSTCONTEXT;

typedef struct _WSTCONTEXT *LPWSTCONTEXT;

// {F6ECA915-157C-4db5-892E-92B246E3B1FD}
DEFINE_GUID(IID_IWSTFileShare, 0xf6eca915, 0x157c, 0x4db5, 0x89, 0x2e, 0x92, 0xb2, 0x46, 0xe3, 0xb1, 0xfd);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0362_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0362_v0_0_s_ifspec;

#ifndef __IWSTFileShare_INTERFACE_DEFINED__
#define __IWSTFileShare_INTERFACE_DEFINED__

/* interface IWSTFileShare */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IWSTFileShare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F6ECA915-157C-4db5-892E-92B246E3B1FD")
    IWSTFileShare : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTCreateFile( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ DWORD dwCreationDisposition,
            /* [in] */ DWORD dwFlagsAndAttributes,
            /* [in] */ HANDLE hTemplateFile,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ HANDLE *phFile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTDeleteFile( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTCreateDirectory( 
            /* [in] */ LPCWSTR lpPathName,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTCreateDirectoryEx( 
            /* [in] */ LPCWSTR lpTemplateDirectory,
            /* [in] */ LPCWSTR lpNewDirectory,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTRemoveDirectory( 
            /* [in] */ LPCWSTR lpPathName,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTGetFileAttributes( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ DWORD *pdwFileAttributes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTGetFileAttributesEx( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LONG fInfoLevelId,
            /* [out] */ LPVOID lpFileInformation,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTSetFileAttributes( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ DWORD dwFileAttributes,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTFindFirstFile( 
            /* [in] */ LPCWSTR lpFileName,
            /* [out] */ LPVOID lpFindFileData,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ HANDLE *phFindFile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTFindFirstFileEx( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LONG fInfoLevelId,
            /* [out] */ LPVOID lpFindFileData,
            /* [in] */ LONG fSearchOp,
            /* [in] */ LPVOID lpSearchFilter,
            /* [in] */ DWORD dwAdditionalFlags,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ HANDLE *phFindFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTFileShareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTFileShare * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTFileShare * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTFileShare * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTCreateFile )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ DWORD dwCreationDisposition,
            /* [in] */ DWORD dwFlagsAndAttributes,
            /* [in] */ HANDLE hTemplateFile,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ HANDLE *phFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTDeleteFile )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTCreateDirectory )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpPathName,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTCreateDirectoryEx )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpTemplateDirectory,
            /* [in] */ LPCWSTR lpNewDirectory,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTRemoveDirectory )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpPathName,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTGetFileAttributes )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ DWORD *pdwFileAttributes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTGetFileAttributesEx )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LONG fInfoLevelId,
            /* [out] */ LPVOID lpFileInformation,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTSetFileAttributes )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ DWORD dwFileAttributes,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTFindFirstFile )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [out] */ LPVOID lpFindFileData,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ HANDLE *phFindFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTFindFirstFileEx )( 
            IWSTFileShare * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LONG fInfoLevelId,
            /* [out] */ LPVOID lpFindFileData,
            /* [in] */ LONG fSearchOp,
            /* [in] */ LPVOID lpSearchFilter,
            /* [in] */ DWORD dwAdditionalFlags,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ HANDLE *phFindFile);
        
        END_INTERFACE
    } IWSTFileShareVtbl;

    interface IWSTFileShare
    {
        CONST_VTBL struct IWSTFileShareVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTFileShare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTFileShare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTFileShare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTFileShare_WSTCreateFile(This,lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile,lpContext,phFile)	\
    (This)->lpVtbl -> WSTCreateFile(This,lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile,lpContext,phFile)

#define IWSTFileShare_WSTDeleteFile(This,lpFileName,lpContext)	\
    (This)->lpVtbl -> WSTDeleteFile(This,lpFileName,lpContext)

#define IWSTFileShare_WSTCreateDirectory(This,lpPathName,lpSecurityAttributes,lpContext)	\
    (This)->lpVtbl -> WSTCreateDirectory(This,lpPathName,lpSecurityAttributes,lpContext)

#define IWSTFileShare_WSTCreateDirectoryEx(This,lpTemplateDirectory,lpNewDirectory,lpSecurityAttributes,lpContext)	\
    (This)->lpVtbl -> WSTCreateDirectoryEx(This,lpTemplateDirectory,lpNewDirectory,lpSecurityAttributes,lpContext)

#define IWSTFileShare_WSTRemoveDirectory(This,lpPathName,lpContext)	\
    (This)->lpVtbl -> WSTRemoveDirectory(This,lpPathName,lpContext)

#define IWSTFileShare_WSTGetFileAttributes(This,lpFileName,lpContext,pdwFileAttributes)	\
    (This)->lpVtbl -> WSTGetFileAttributes(This,lpFileName,lpContext,pdwFileAttributes)

#define IWSTFileShare_WSTGetFileAttributesEx(This,lpFileName,fInfoLevelId,lpFileInformation,lpContext)	\
    (This)->lpVtbl -> WSTGetFileAttributesEx(This,lpFileName,fInfoLevelId,lpFileInformation,lpContext)

#define IWSTFileShare_WSTSetFileAttributes(This,lpFileName,dwFileAttributes,lpContext)	\
    (This)->lpVtbl -> WSTSetFileAttributes(This,lpFileName,dwFileAttributes,lpContext)

#define IWSTFileShare_WSTFindFirstFile(This,lpFileName,lpFindFileData,lpContext,phFindFile)	\
    (This)->lpVtbl -> WSTFindFirstFile(This,lpFileName,lpFindFileData,lpContext,phFindFile)

#define IWSTFileShare_WSTFindFirstFileEx(This,lpFileName,fInfoLevelId,lpFindFileData,fSearchOp,lpSearchFilter,dwAdditionalFlags,lpContext,phFindFile)	\
    (This)->lpVtbl -> WSTFindFirstFileEx(This,lpFileName,fInfoLevelId,lpFindFileData,fSearchOp,lpSearchFilter,dwAdditionalFlags,lpContext,phFindFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTCreateFile_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ DWORD dwCreationDisposition,
    /* [in] */ DWORD dwFlagsAndAttributes,
    /* [in] */ HANDLE hTemplateFile,
    /* [in] */ LPWSTCONTEXT lpContext,
    /* [out] */ HANDLE *phFile);


void __RPC_STUB IWSTFileShare_WSTCreateFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTDeleteFile_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileShare_WSTDeleteFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTCreateDirectory_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpPathName,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileShare_WSTCreateDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTCreateDirectoryEx_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpTemplateDirectory,
    /* [in] */ LPCWSTR lpNewDirectory,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileShare_WSTCreateDirectoryEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTRemoveDirectory_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpPathName,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileShare_WSTRemoveDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTGetFileAttributes_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ LPWSTCONTEXT lpContext,
    /* [out] */ DWORD *pdwFileAttributes);


void __RPC_STUB IWSTFileShare_WSTGetFileAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTGetFileAttributesEx_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ LONG fInfoLevelId,
    /* [out] */ LPVOID lpFileInformation,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileShare_WSTGetFileAttributesEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTSetFileAttributes_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ DWORD dwFileAttributes,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileShare_WSTSetFileAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTFindFirstFile_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [out] */ LPVOID lpFindFileData,
    /* [in] */ LPWSTCONTEXT lpContext,
    /* [out] */ HANDLE *phFindFile);


void __RPC_STUB IWSTFileShare_WSTFindFirstFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileShare_WSTFindFirstFileEx_Proxy( 
    IWSTFileShare * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ LONG fInfoLevelId,
    /* [out] */ LPVOID lpFindFileData,
    /* [in] */ LONG fSearchOp,
    /* [in] */ LPVOID lpSearchFilter,
    /* [in] */ DWORD dwAdditionalFlags,
    /* [in] */ LPWSTCONTEXT lpContext,
    /* [out] */ HANDLE *phFindFile);


void __RPC_STUB IWSTFileShare_WSTFindFirstFileEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTFileShare_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0363 */
/* [local] */ 

// {CA7B95F7-16C0-407f-ADB7-D1D8674D78DA}
DEFINE_GUID(IID_IWSTFindFile,0xca7b95f7, 0x16c0, 0x407f, 0xad, 0xb7, 0xd1, 0xd8, 0x67, 0x4d, 0x78, 0xda);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0363_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0363_v0_0_s_ifspec;

#ifndef __IWSTFindFile_INTERFACE_DEFINED__
#define __IWSTFindFile_INTERFACE_DEFINED__

/* interface IWSTFindFile */
/* [unique][helpstring][uuid][local][object] */ 

#ifndef _WINBASE_
typedef struct tagWIN32_FIND_DATAW
    {
    long dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    long nFileSizeHigh;
    long nFileSizeLow;
    long dwReserved0;
    long dwReserved1;
    WCHAR cFileName[ 260 ];
    WCHAR cAlternateFileName[ 14 ];
    } 	WIN32_FIND_DATAW;

typedef struct tagWIN32_FIND_DATAW *PWIN32_FIND_DATAW;

typedef struct tagWIN32_FIND_DATAW *LPWIN32_FIND_DATA;

#endif

EXTERN_C const IID IID_IWSTFindFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA7B95F7-16C0-407f-ADB7-D1D8674D78DA")
    IWSTFindFile : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTFindNextFile( 
            LPWIN32_FIND_DATA lpFileFindData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTFindFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTFindFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTFindFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTFindFile * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTFindNextFile )( 
            IWSTFindFile * This,
            LPWIN32_FIND_DATA lpFileFindData);
        
        END_INTERFACE
    } IWSTFindFileVtbl;

    interface IWSTFindFile
    {
        CONST_VTBL struct IWSTFindFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTFindFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTFindFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTFindFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTFindFile_WSTFindNextFile(This,lpFileFindData)	\
    (This)->lpVtbl -> WSTFindNextFile(This,lpFileFindData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFindFile_WSTFindNextFile_Proxy( 
    IWSTFindFile * This,
    LPWIN32_FIND_DATA lpFileFindData);


void __RPC_STUB IWSTFindFile_WSTFindNextFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTFindFile_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0364 */
/* [local] */ 

// {2BA62BE8-9BB6-4f7c-ACE7-60CA71FE06F0}
DEFINE_GUID(IID_IWSTFile, 0x2ba62be8, 0x9bb6, 0x4f7c, 0xac, 0xe7, 0x60, 0xca, 0x71, 0xfe, 0x6, 0xf0);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0364_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0364_v0_0_s_ifspec;

#ifndef __IWSTFile_INTERFACE_DEFINED__
#define __IWSTFile_INTERFACE_DEFINED__

/* interface IWSTFile */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IWSTFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2BA62BE8-9BB6-4f7c-ACE7-60CA71FE06F0")
    IWSTFile : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTReadFile( 
            /* [in] */ LPVOID lpBuffer,
            /* [in] */ DWORD dwNumberofBytesToRead,
            /* [out] */ DWORD *lpdwNumberofBytesRead,
            /* [in] */ LPWSTOVERLAPPED lpOverlapped,
            /* [out] */ BOOL *pfPassed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTWriteFile( 
            /* [in] */ LPVOID lpBuffer,
            /* [in] */ DWORD dwNumberofBytesToWrite,
            /* [out] */ DWORD *lpdwNumberofBytesWritten,
            /* [in] */ LPWSTOVERLAPPED lpOverlapped,
            /* [out] */ BOOL *pfPassed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTFile * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTReadFile )( 
            IWSTFile * This,
            /* [in] */ LPVOID lpBuffer,
            /* [in] */ DWORD dwNumberofBytesToRead,
            /* [out] */ DWORD *lpdwNumberofBytesRead,
            /* [in] */ LPWSTOVERLAPPED lpOverlapped,
            /* [out] */ BOOL *pfPassed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTWriteFile )( 
            IWSTFile * This,
            /* [in] */ LPVOID lpBuffer,
            /* [in] */ DWORD dwNumberofBytesToWrite,
            /* [out] */ DWORD *lpdwNumberofBytesWritten,
            /* [in] */ LPWSTOVERLAPPED lpOverlapped,
            /* [out] */ BOOL *pfPassed);
        
        END_INTERFACE
    } IWSTFileVtbl;

    interface IWSTFile
    {
        CONST_VTBL struct IWSTFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTFile_WSTReadFile(This,lpBuffer,dwNumberofBytesToRead,lpdwNumberofBytesRead,lpOverlapped,pfPassed)	\
    (This)->lpVtbl -> WSTReadFile(This,lpBuffer,dwNumberofBytesToRead,lpdwNumberofBytesRead,lpOverlapped,pfPassed)

#define IWSTFile_WSTWriteFile(This,lpBuffer,dwNumberofBytesToWrite,lpdwNumberofBytesWritten,lpOverlapped,pfPassed)	\
    (This)->lpVtbl -> WSTWriteFile(This,lpBuffer,dwNumberofBytesToWrite,lpdwNumberofBytesWritten,lpOverlapped,pfPassed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFile_WSTReadFile_Proxy( 
    IWSTFile * This,
    /* [in] */ LPVOID lpBuffer,
    /* [in] */ DWORD dwNumberofBytesToRead,
    /* [out] */ DWORD *lpdwNumberofBytesRead,
    /* [in] */ LPWSTOVERLAPPED lpOverlapped,
    /* [out] */ BOOL *pfPassed);


void __RPC_STUB IWSTFile_WSTReadFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFile_WSTWriteFile_Proxy( 
    IWSTFile * This,
    /* [in] */ LPVOID lpBuffer,
    /* [in] */ DWORD dwNumberofBytesToWrite,
    /* [out] */ DWORD *lpdwNumberofBytesWritten,
    /* [in] */ LPWSTOVERLAPPED lpOverlapped,
    /* [out] */ BOOL *pfPassed);


void __RPC_STUB IWSTFile_WSTWriteFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTFile_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0365 */
/* [local] */ 

// {0FD9C782-1120-4770-B52F-C68A3EE560D8}
DEFINE_GUID(IID_IWSTFileStore, 0xfd9c782, 0x1120, 0x4770, 0xb5, 0x2f, 0xc6, 0x8a, 0x3e, 0xe5, 0x60, 0xd8);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0365_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0365_v0_0_s_ifspec;

#ifndef __IWSTFileStore_INTERFACE_DEFINED__
#define __IWSTFileStore_INTERFACE_DEFINED__

/* interface IWSTFileStore */
/* [unique][helpstring][uuid][local][object] */ 

#ifndef _WINBASE_
typedef 
enum _WST_FINDEX_INFO_LEVELS
    {	FindExInfoStandard	= 0,
	FindExInfoMaxInfoLevel	= FindExInfoStandard + 1
    } 	FINDEX_INFO_LEVELS;

typedef 
enum _WST_FINDEX_SEARCH_OPS
    {	FindExSearchNameMatch	= 0,
	FindExSearchLimitToDirectories	= FindExSearchNameMatch + 1,
	FindExSearchLimitToDevices	= FindExSearchLimitToDirectories + 1,
	FindExSearchMaxSearchOp	= FindExSearchLimitToDevices + 1
    } 	FINDEX_SEARCH_OPS;

#endif

EXTERN_C const IID IID_IWSTFileStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FD9C782-1120-4770-B52F-C68A3EE560D8")
    IWSTFileStore : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTCreateFile( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ DWORD dwCreationDisposition,
            /* [in] */ DWORD dwFlagsAndAttributes,
            /* [in] */ HANDLE hTemplateFile,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ IWSTFile **ppWstFile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTDeleteFile( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTCreateDirectory( 
            /* [in] */ LPCWSTR lpPathName,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ LPWSTCONTEXT lpContext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WSTFindFirstFileEx( 
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ FINDEX_INFO_LEVELS fInfoLevelId,
            /* [out] */ LPVOID lpFindFileData,
            /* [in] */ FINDEX_SEARCH_OPS fSearchOp,
            /* [in] */ LPVOID lpSearchFilter,
            /* [in] */ DWORD dwAdditionalFlags,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ IWSTFindFile **ppWstFindFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSTFileStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTFileStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTFileStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTFileStore * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTCreateFile )( 
            IWSTFileStore * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ DWORD dwCreationDisposition,
            /* [in] */ DWORD dwFlagsAndAttributes,
            /* [in] */ HANDLE hTemplateFile,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ IWSTFile **ppWstFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTDeleteFile )( 
            IWSTFileStore * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTCreateDirectory )( 
            IWSTFileStore * This,
            /* [in] */ LPCWSTR lpPathName,
            /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            /* [in] */ LPWSTCONTEXT lpContext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WSTFindFirstFileEx )( 
            IWSTFileStore * This,
            /* [in] */ LPCWSTR lpFileName,
            /* [in] */ FINDEX_INFO_LEVELS fInfoLevelId,
            /* [out] */ LPVOID lpFindFileData,
            /* [in] */ FINDEX_SEARCH_OPS fSearchOp,
            /* [in] */ LPVOID lpSearchFilter,
            /* [in] */ DWORD dwAdditionalFlags,
            /* [in] */ LPWSTCONTEXT lpContext,
            /* [out] */ IWSTFindFile **ppWstFindFile);
        
        END_INTERFACE
    } IWSTFileStoreVtbl;

    interface IWSTFileStore
    {
        CONST_VTBL struct IWSTFileStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTFileStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTFileStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTFileStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWSTFileStore_WSTCreateFile(This,lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile,lpContext,ppWstFile)	\
    (This)->lpVtbl -> WSTCreateFile(This,lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile,lpContext,ppWstFile)

#define IWSTFileStore_WSTDeleteFile(This,lpFileName,lpContext)	\
    (This)->lpVtbl -> WSTDeleteFile(This,lpFileName,lpContext)

#define IWSTFileStore_WSTCreateDirectory(This,lpPathName,lpSecurityAttributes,lpContext)	\
    (This)->lpVtbl -> WSTCreateDirectory(This,lpPathName,lpSecurityAttributes,lpContext)

#define IWSTFileStore_WSTFindFirstFileEx(This,lpFileName,fInfoLevelId,lpFindFileData,fSearchOp,lpSearchFilter,dwAdditionalFlags,lpContext,ppWstFindFile)	\
    (This)->lpVtbl -> WSTFindFirstFileEx(This,lpFileName,fInfoLevelId,lpFindFileData,fSearchOp,lpSearchFilter,dwAdditionalFlags,lpContext,ppWstFindFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileStore_WSTCreateFile_Proxy( 
    IWSTFileStore * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ DWORD dwCreationDisposition,
    /* [in] */ DWORD dwFlagsAndAttributes,
    /* [in] */ HANDLE hTemplateFile,
    /* [in] */ LPWSTCONTEXT lpContext,
    /* [out] */ IWSTFile **ppWstFile);


void __RPC_STUB IWSTFileStore_WSTCreateFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileStore_WSTDeleteFile_Proxy( 
    IWSTFileStore * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileStore_WSTDeleteFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileStore_WSTCreateDirectory_Proxy( 
    IWSTFileStore * This,
    /* [in] */ LPCWSTR lpPathName,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ LPWSTCONTEXT lpContext);


void __RPC_STUB IWSTFileStore_WSTCreateDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IWSTFileStore_WSTFindFirstFileEx_Proxy( 
    IWSTFileStore * This,
    /* [in] */ LPCWSTR lpFileName,
    /* [in] */ FINDEX_INFO_LEVELS fInfoLevelId,
    /* [out] */ LPVOID lpFindFileData,
    /* [in] */ FINDEX_SEARCH_OPS fSearchOp,
    /* [in] */ LPVOID lpSearchFilter,
    /* [in] */ DWORD dwAdditionalFlags,
    /* [in] */ LPWSTCONTEXT lpContext,
    /* [out] */ IWSTFindFile **ppWstFindFile);


void __RPC_STUB IWSTFileStore_WSTFindFirstFileEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWSTFileStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0366 */
/* [local] */ 

#include "windows.h"
WSTBASEAPI
HRESULT
WINAPI
WSTInitialize(
    IN LPVOID pvReserved
    );
WSTBASEAPI
VOID
WINAPI
WSTUninitialize( );
WSTBASEAPI
HANDLE
WINAPI
WSTCreateFile(
    IN LPCWSTR lpFileName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN DWORD dwCreationDisposition,
    IN DWORD dwFlagsAndAttributes,
    IN HANDLE hTemplateFile,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
BOOL
WINAPI
WSTDeleteFile(
    IN LPCWSTR lpFileName,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
BOOL
WINAPI
WSTCreateDirectory(
    IN LPCWSTR lpPathName,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
BOOL
WINAPI
WSTCreateDirectoryEx(
    IN LPCWSTR lpTemplateDirectory,
    IN LPCWSTR lpNewDirectory,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
BOOL
WINAPI
WSTRemoveDirectory(
    IN LPCWSTR lpPathName,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
DWORD
WINAPI
WSTGetFileAttributes(
    IN LPCWSTR lpFileName,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
BOOL
WINAPI
WSTGetFileAttributesEx(
    IN LPCWSTR lpFileName,
    IN GET_FILEEX_INFO_LEVELS fInfoLevelId,
    OUT LPVOID lpFileInformation,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
BOOL
WINAPI
WSTSetFileAttributes(
    IN LPCWSTR lpFileName,
    IN DWORD dwFileAttributes,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
HANDLE
WINAPI
WSTFindFirstFile(
    IN LPCWSTR lpFileName,
    OUT LPWIN32_FIND_DATAW lpFindFileData,
    IN LPWSTCONTEXT lpContext = NULL
    );
WSTBASEAPI
HANDLE
WINAPI
WSTFindFirstFileEx(
    IN LPCWSTR lpFileName,
    IN FINDEX_INFO_LEVELS fInfoLevelId,
    OUT LPVOID lpFindFileData,
    IN FINDEX_SEARCH_OPS fSearchOp,
    IN LPVOID lpSearchFilter,
    IN DWORD dwAdditionalFlags,
    IN LPWSTCONTEXT lpContext = NULL
    );
typedef struct _SITEINFO
    {
    LPWSTR Name;
    DWORD nName;
    } 	SITEINFO;

typedef struct _SITEINFO *LPSITEINFO;

// {A6ECA915-157C-4db5-892E-92B246E3B1FD}
DEFINE_GUID(IID_IWSTSite, 0xa6eca915, 0x157c, 0x4db5, 0x89, 0x2e, 0x92, 0xb2, 0x46, 0xe3, 0xb1, 0xfd);


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0366_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0366_v0_0_s_ifspec;

#ifndef __IWSTSite_INTERFACE_DEFINED__
#define __IWSTSite_INTERFACE_DEFINED__

/* interface IWSTSite */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IWSTSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6ECA915-157C-4db5-892E-92B246E3B1FD")
    IWSTSite : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWSTSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSTSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSTSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSTSite * This);
        
        END_INTERFACE
    } IWSTSiteVtbl;

    interface IWSTSite
    {
        CONST_VTBL struct IWSTSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSTSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWSTSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWSTSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSTSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wststoreidl_0367 */
/* [local] */ 

#include "windows.h"
#endif // __WSTSTOREIDL_IDL__


extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0367_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wststoreidl_0367_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\webstore\5.5.2421.0000\SDK\inc\HashFunc.h ===
//--------------------------------------------------------------------------
//
//  @doc
//
//  @module HashFunc.h | Declaration of the Hash Function
//
//  Author: Suwat Ch.
//
//  Date:   5/1/00
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------
#ifndef __HASHFUNC_H__
#define __HASHFUNC_H__


//-----------------------------------------------------------------------------
//
//  Three prime numbers required for hashing algorithm.
//
//-----------------------------------------------------------------------------
#define PRIME_A  31415
#define PRIME_B  27183
#define PRIME_K  16381



//--------------------------------------------------------------------------
//
//  @mfunc  Hashing string
//
//  @rdesc  Return one of the following values:
//  @flag   S_OK | success
//  @flag   E_FAIL | fail
//
//--------------------------------------------------------------------------
HRESULT 
HashWSTR(
    const wchar_t *pwsz,    // @parm    String input to be hashed 
    const ULONG ulMaxHash,  // @parm    Maximum hash value
    ULONG *pulHash          // @parm    Returned hash value
    )
{
    ULONG h = 0;
    ULONG a = PRIME_A;
    const ULONG b = PRIME_B;
    const ULONG k = PRIME_K; 

    // Validate Parameters
    if (pwsz == NULL || pulHash == NULL) 
    { 
        return E_INVALIDARG;
    }

    // Assume that character array is null terminated!
    while (*pwsz) 
    {
        h = (a * h + *pwsz) % k;
        a = a * b % (k-1);
        ++pwsz;
    }
    *pulHash = (h % ulMaxHash);
    return S_OK;
}


//--------------------------------------------------------------------------
//
//  @mfunc  Hashing large integer
//
//
//  @rdesc  Return one of the following values:
//  @flag   S_OK | success
//  @flag   E_FAIL | fail
//
//--------------------------------------------------------------------------
HRESULT 
HashLARGEINTEGER(
    const LARGE_INTEGER li, // @parm    64 bit input to be hashed 
    const ULONG ulMaxHash,  // @parm    Maximum hash value
    ULONG *pulHash          // @parm    Returned hash value
    )
{
    BYTE rgby[sizeof(ULONG)*2] = {0};
    ULONG h = 0;
    ULONG a = PRIME_A;
    const ULONG b = PRIME_B;
    const ULONG k = PRIME_K; 

    // Validate Parameters
    if (pulHash == NULL) 
    { 
        return E_INVALIDARG;
    }

    memcpy(&rgby[0], &(li.HighPart), sizeof(ULONG));
    memcpy(&rgby[sizeof(ULONG)], &(li.LowPart), sizeof(ULONG));
    
    for(long j = 0; j < sizeof(ULONG)*2; j++)
    {
        h = (a * h + (ULONG)rgby[j]) % k;
        a = a * b % (k-1);
    }

    *pulHash = (h % ulMaxHash);
    return S_OK;
}


#endif // __HASHFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\webstore\5.5.2421.0000\SDK\inc\WSTStore_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wststore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_WebStore,0x6CF1D4A3,0xF8B3,0x43d6,0x83,0x2D,0xDE,0x25,0x96,0xFF,0xC3,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_WSTStore,0x9255D61E,0x4866,0x4E77,0x8E,0x75,0xBF,0x33,0xC5,0x9E,0x49,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_WSTSQLOLEDB,0xB7BE7E8F,0x4F60,0x40FD,0x99,0x7D,0xAF,0x76,0x1B,0x8C,0x6E,0x24);


MIDL_DEFINE_GUID(CLSID, CLSID_WSTFileShare,0xBD5E6DF2,0x69A5,0x467f,0xB2,0x21,0x06,0xD2,0x6E,0x3F,0x81,0x6D);


MIDL_DEFINE_GUID(CLSID, CLSID_WSTFileStore,0x42A5C7DC,0xB0AF,0x4c57,0xB5,0x84,0x8C,0x90,0x11,0x50,0x96,0xF2);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\webstore\5.5.2421.0000\SDK\inc\WSTStoreidl_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wststoreidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IWSTStore,0xF9E76340,0xB686,0x4dab,0x91,0x01,0x73,0xD7,0xE1,0x3D,0x5B,0x5B);


MIDL_DEFINE_GUID(IID, IID_IWSTDTC,0x5E743039,0xE626,0x4bf0,0x8E,0xD4,0xF5,0xB0,0x8E,0x33,0x43,0x7B);


MIDL_DEFINE_GUID(IID, IID_IWSTSession,0x5C737F8A,0xC48D,0x4ffa,0xA2,0xBD,0x97,0x70,0x90,0x7E,0x54,0x38);


MIDL_DEFINE_GUID(IID, IID_IWSTCommand,0x19D2A4E7,0x3074,0x4f32,0xA1,0xCB,0x73,0x3A,0x3C,0xC3,0x3B,0xE9);


MIDL_DEFINE_GUID(IID, IID_IWSTHash,0x2B8D4993,0xF783,0x4ef4,0x97,0x9A,0x16,0xD4,0x10,0x44,0xCB,0x81);


MIDL_DEFINE_GUID(IID, IID_IWSTProperties,0xC01019FB,0x4BF4,0x4861,0x9D,0x79,0x42,0xBB,0x1A,0x8D,0x8A,0x69);


MIDL_DEFINE_GUID(IID, IID_IWSTPartition,0x40BCAFB9,0x4778,0x4305,0x82,0xE5,0xBA,0x75,0x1E,0x7B,0x3E,0x26);


MIDL_DEFINE_GUID(IID, IID_IWSTFileShare,0xF6ECA915,0x157C,0x4db5,0x89,0x2E,0x92,0xB2,0x46,0xE3,0xB1,0xFD);


MIDL_DEFINE_GUID(IID, IID_IWSTFindFile,0xCA7B95F7,0x16C0,0x407f,0xAD,0xB7,0xD1,0xD8,0x67,0x4D,0x78,0xDA);


MIDL_DEFINE_GUID(IID, IID_IWSTFile,0x2BA62BE8,0x9BB6,0x4f7c,0xAC,0xE7,0x60,0xCA,0x71,0xFE,0x06,0xF0);


MIDL_DEFINE_GUID(IID, IID_IWSTFileStore,0x0FD9C782,0x1120,0x4770,0xB5,0x2F,0xC6,0x8A,0x3E,0xE5,0x60,0xD8);


MIDL_DEFINE_GUID(IID, IID_IWSTSite,0xA6ECA915,0x157C,0x4db5,0x89,0x2E,0x92,0xB2,0x46,0xE3,0xB1,0xFD);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\wmrmsdk\WMRM10.1\include\enrollobj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0365 */
/* Compiler settings for enrollobj.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __enrollobj_h__
#define __enrollobj_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDRMEnroll_FWD_DEFINED__
#define __IDRMEnroll_FWD_DEFINED__
typedef interface IDRMEnroll IDRMEnroll;
#endif 	/* __IDRMEnroll_FWD_DEFINED__ */


#ifndef __IDRMEnroll2_FWD_DEFINED__
#define __IDRMEnroll2_FWD_DEFINED__
typedef interface IDRMEnroll2 IDRMEnroll2;
#endif 	/* __IDRMEnroll2_FWD_DEFINED__ */


#ifndef __IDRMEnroll3_FWD_DEFINED__
#define __IDRMEnroll3_FWD_DEFINED__
typedef interface IDRMEnroll3 IDRMEnroll3;
#endif 	/* __IDRMEnroll3_FWD_DEFINED__ */


#ifndef __IDRMEnroll4_FWD_DEFINED__
#define __IDRMEnroll4_FWD_DEFINED__
typedef interface IDRMEnroll4 IDRMEnroll4;
#endif 	/* __IDRMEnroll4_FWD_DEFINED__ */


#ifndef __DRMEnroll_FWD_DEFINED__
#define __DRMEnroll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DRMEnroll DRMEnroll;
#else
typedef struct DRMEnroll DRMEnroll;
#endif /* __cplusplus */

#endif 	/* __DRMEnroll_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_enrollobj_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================


extern RPC_IF_HANDLE __MIDL_itf_enrollobj_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_enrollobj_0000_v0_0_s_ifspec;

#ifndef __IDRMEnroll_INTERFACE_DEFINED__
#define __IDRMEnroll_INTERFACE_DEFINED__

/* interface IDRMEnroll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDRMEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B3FB54C-E9A0-4E19-8960-90046139CDD3")
    IDRMEnroll : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateKeyPair( 
            /* [retval][out] */ BSTR *pbstrPubKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreCertificate( 
            /* [in] */ BSTR bstrCertName,
            /* [in] */ BSTR bstrCert) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreRevocationList( 
            /* [in] */ BSTR bstrList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportPrivateKey( 
            /* [in] */ BSTR bstrPrivKey) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreVerificationKey( 
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDRMEnroll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDRMEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDRMEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDRMEnroll * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDRMEnroll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDRMEnroll * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDRMEnroll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyPair )( 
            IDRMEnroll * This,
            /* [retval][out] */ BSTR *pbstrPubKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreCertificate )( 
            IDRMEnroll * This,
            /* [in] */ BSTR bstrCertName,
            /* [in] */ BSTR bstrCert);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreRevocationList )( 
            IDRMEnroll * This,
            /* [in] */ BSTR bstrList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportPrivateKey )( 
            IDRMEnroll * This,
            /* [in] */ BSTR bstrPrivKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreVerificationKey )( 
            IDRMEnroll * This,
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrKey);
        
        END_INTERFACE
    } IDRMEnrollVtbl;

    interface IDRMEnroll
    {
        CONST_VTBL struct IDRMEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMEnroll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMEnroll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMEnroll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMEnroll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDRMEnroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDRMEnroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDRMEnroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDRMEnroll_GenerateKeyPair(This,pbstrPubKey)	\
    (This)->lpVtbl -> GenerateKeyPair(This,pbstrPubKey)

#define IDRMEnroll_StoreCertificate(This,bstrCertName,bstrCert)	\
    (This)->lpVtbl -> StoreCertificate(This,bstrCertName,bstrCert)

#define IDRMEnroll_StoreRevocationList(This,bstrList)	\
    (This)->lpVtbl -> StoreRevocationList(This,bstrList)

#define IDRMEnroll_ImportPrivateKey(This,bstrPrivKey)	\
    (This)->lpVtbl -> ImportPrivateKey(This,bstrPrivKey)

#define IDRMEnroll_StoreVerificationKey(This,bstrVersion,bstrKey)	\
    (This)->lpVtbl -> StoreVerificationKey(This,bstrVersion,bstrKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll_GenerateKeyPair_Proxy( 
    IDRMEnroll * This,
    /* [retval][out] */ BSTR *pbstrPubKey);


void __RPC_STUB IDRMEnroll_GenerateKeyPair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll_StoreCertificate_Proxy( 
    IDRMEnroll * This,
    /* [in] */ BSTR bstrCertName,
    /* [in] */ BSTR bstrCert);


void __RPC_STUB IDRMEnroll_StoreCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll_StoreRevocationList_Proxy( 
    IDRMEnroll * This,
    /* [in] */ BSTR bstrList);


void __RPC_STUB IDRMEnroll_StoreRevocationList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll_ImportPrivateKey_Proxy( 
    IDRMEnroll * This,
    /* [in] */ BSTR bstrPrivKey);


void __RPC_STUB IDRMEnroll_ImportPrivateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll_StoreVerificationKey_Proxy( 
    IDRMEnroll * This,
    /* [in] */ BSTR bstrVersion,
    /* [in] */ BSTR bstrKey);


void __RPC_STUB IDRMEnroll_StoreVerificationKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMEnroll_INTERFACE_DEFINED__ */


#ifndef __IDRMEnroll2_INTERFACE_DEFINED__
#define __IDRMEnroll2_INTERFACE_DEFINED__

/* interface IDRMEnroll2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDRMEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E5B9F1DE-5C67-4ee1-AC44-D0BFF7E25A97")
    IDRMEnroll2 : public IDRMEnroll
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreSecurityComponentExclusionList( 
            /* [in] */ BSTR bstrList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDRMEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDRMEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDRMEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDRMEnroll2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDRMEnroll2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDRMEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDRMEnroll2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyPair )( 
            IDRMEnroll2 * This,
            /* [retval][out] */ BSTR *pbstrPubKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreCertificate )( 
            IDRMEnroll2 * This,
            /* [in] */ BSTR bstrCertName,
            /* [in] */ BSTR bstrCert);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreRevocationList )( 
            IDRMEnroll2 * This,
            /* [in] */ BSTR bstrList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportPrivateKey )( 
            IDRMEnroll2 * This,
            /* [in] */ BSTR bstrPrivKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreVerificationKey )( 
            IDRMEnroll2 * This,
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreSecurityComponentExclusionList )( 
            IDRMEnroll2 * This,
            /* [in] */ BSTR bstrList);
        
        END_INTERFACE
    } IDRMEnroll2Vtbl;

    interface IDRMEnroll2
    {
        CONST_VTBL struct IDRMEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMEnroll2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMEnroll2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMEnroll2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMEnroll2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDRMEnroll2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDRMEnroll2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDRMEnroll2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDRMEnroll2_GenerateKeyPair(This,pbstrPubKey)	\
    (This)->lpVtbl -> GenerateKeyPair(This,pbstrPubKey)

#define IDRMEnroll2_StoreCertificate(This,bstrCertName,bstrCert)	\
    (This)->lpVtbl -> StoreCertificate(This,bstrCertName,bstrCert)

#define IDRMEnroll2_StoreRevocationList(This,bstrList)	\
    (This)->lpVtbl -> StoreRevocationList(This,bstrList)

#define IDRMEnroll2_ImportPrivateKey(This,bstrPrivKey)	\
    (This)->lpVtbl -> ImportPrivateKey(This,bstrPrivKey)

#define IDRMEnroll2_StoreVerificationKey(This,bstrVersion,bstrKey)	\
    (This)->lpVtbl -> StoreVerificationKey(This,bstrVersion,bstrKey)


#define IDRMEnroll2_StoreSecurityComponentExclusionList(This,bstrList)	\
    (This)->lpVtbl -> StoreSecurityComponentExclusionList(This,bstrList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll2_StoreSecurityComponentExclusionList_Proxy( 
    IDRMEnroll2 * This,
    /* [in] */ BSTR bstrList);


void __RPC_STUB IDRMEnroll2_StoreSecurityComponentExclusionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMEnroll2_INTERFACE_DEFINED__ */


#ifndef __IDRMEnroll3_INTERFACE_DEFINED__
#define __IDRMEnroll3_INTERFACE_DEFINED__

/* interface IDRMEnroll3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDRMEnroll3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D029006B-E319-4189-9356-A7C95A56E1F4")
    IDRMEnroll3 : public IDRMEnroll2
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreNamedRevocations( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrRevocationData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreClientRevocations( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrRevocationData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMEnroll3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDRMEnroll3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDRMEnroll3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDRMEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDRMEnroll3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDRMEnroll3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDRMEnroll3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDRMEnroll3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyPair )( 
            IDRMEnroll3 * This,
            /* [retval][out] */ BSTR *pbstrPubKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreCertificate )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrCertName,
            /* [in] */ BSTR bstrCert);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreRevocationList )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportPrivateKey )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrPrivKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreVerificationKey )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreSecurityComponentExclusionList )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreNamedRevocations )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrRevocationData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreClientRevocations )( 
            IDRMEnroll3 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrRevocationData);
        
        END_INTERFACE
    } IDRMEnroll3Vtbl;

    interface IDRMEnroll3
    {
        CONST_VTBL struct IDRMEnroll3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMEnroll3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMEnroll3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMEnroll3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMEnroll3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDRMEnroll3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDRMEnroll3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDRMEnroll3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDRMEnroll3_GenerateKeyPair(This,pbstrPubKey)	\
    (This)->lpVtbl -> GenerateKeyPair(This,pbstrPubKey)

#define IDRMEnroll3_StoreCertificate(This,bstrCertName,bstrCert)	\
    (This)->lpVtbl -> StoreCertificate(This,bstrCertName,bstrCert)

#define IDRMEnroll3_StoreRevocationList(This,bstrList)	\
    (This)->lpVtbl -> StoreRevocationList(This,bstrList)

#define IDRMEnroll3_ImportPrivateKey(This,bstrPrivKey)	\
    (This)->lpVtbl -> ImportPrivateKey(This,bstrPrivKey)

#define IDRMEnroll3_StoreVerificationKey(This,bstrVersion,bstrKey)	\
    (This)->lpVtbl -> StoreVerificationKey(This,bstrVersion,bstrKey)


#define IDRMEnroll3_StoreSecurityComponentExclusionList(This,bstrList)	\
    (This)->lpVtbl -> StoreSecurityComponentExclusionList(This,bstrList)


#define IDRMEnroll3_StoreNamedRevocations(This,bstrName,bstrRevocationData)	\
    (This)->lpVtbl -> StoreNamedRevocations(This,bstrName,bstrRevocationData)

#define IDRMEnroll3_StoreClientRevocations(This,bstrName,bstrRevocationData)	\
    (This)->lpVtbl -> StoreClientRevocations(This,bstrName,bstrRevocationData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll3_StoreNamedRevocations_Proxy( 
    IDRMEnroll3 * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrRevocationData);


void __RPC_STUB IDRMEnroll3_StoreNamedRevocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll3_StoreClientRevocations_Proxy( 
    IDRMEnroll3 * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrRevocationData);


void __RPC_STUB IDRMEnroll3_StoreClientRevocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMEnroll3_INTERFACE_DEFINED__ */


#ifndef __IDRMEnroll4_INTERFACE_DEFINED__
#define __IDRMEnroll4_INTERFACE_DEFINED__

/* interface IDRMEnroll4 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDRMEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67664676-BB6A-47d3-BC67-AD76CCC7DB27")
    IDRMEnroll4 : public IDRMEnroll3
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreRevocationInformation( 
            /* [in] */ BSTR bstrRevInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StoreRevocationLists( 
            /* [in] */ BSTR bstrGuid,
            /* [in] */ BSTR bstrRevList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDRMEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDRMEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDRMEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDRMEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDRMEnroll4 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDRMEnroll4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDRMEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDRMEnroll4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateKeyPair )( 
            IDRMEnroll4 * This,
            /* [retval][out] */ BSTR *pbstrPubKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreCertificate )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrCertName,
            /* [in] */ BSTR bstrCert);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreRevocationList )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportPrivateKey )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrPrivKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreVerificationKey )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrVersion,
            /* [in] */ BSTR bstrKey);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreSecurityComponentExclusionList )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreNamedRevocations )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrRevocationData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreClientRevocations )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrRevocationData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreRevocationInformation )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrRevInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StoreRevocationLists )( 
            IDRMEnroll4 * This,
            /* [in] */ BSTR bstrGuid,
            /* [in] */ BSTR bstrRevList);
        
        END_INTERFACE
    } IDRMEnroll4Vtbl;

    interface IDRMEnroll4
    {
        CONST_VTBL struct IDRMEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDRMEnroll4_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDRMEnroll4_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDRMEnroll4_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDRMEnroll4_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDRMEnroll4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDRMEnroll4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDRMEnroll4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDRMEnroll4_GenerateKeyPair(This,pbstrPubKey)	\
    (This)->lpVtbl -> GenerateKeyPair(This,pbstrPubKey)

#define IDRMEnroll4_StoreCertificate(This,bstrCertName,bstrCert)	\
    (This)->lpVtbl -> StoreCertificate(This,bstrCertName,bstrCert)

#define IDRMEnroll4_StoreRevocationList(This,bstrList)	\
    (This)->lpVtbl -> StoreRevocationList(This,bstrList)

#define IDRMEnroll4_ImportPrivateKey(This,bstrPrivKey)	\
    (This)->lpVtbl -> ImportPrivateKey(This,bstrPrivKey)

#define IDRMEnroll4_StoreVerificationKey(This,bstrVersion,bstrKey)	\
    (This)->lpVtbl -> StoreVerificationKey(This,bstrVersion,bstrKey)


#define IDRMEnroll4_StoreSecurityComponentExclusionList(This,bstrList)	\
    (This)->lpVtbl -> StoreSecurityComponentExclusionList(This,bstrList)


#define IDRMEnroll4_StoreNamedRevocations(This,bstrName,bstrRevocationData)	\
    (This)->lpVtbl -> StoreNamedRevocations(This,bstrName,bstrRevocationData)

#define IDRMEnroll4_StoreClientRevocations(This,bstrName,bstrRevocationData)	\
    (This)->lpVtbl -> StoreClientRevocations(This,bstrName,bstrRevocationData)


#define IDRMEnroll4_StoreRevocationInformation(This,bstrRevInfo)	\
    (This)->lpVtbl -> StoreRevocationInformation(This,bstrRevInfo)

#define IDRMEnroll4_StoreRevocationLists(This,bstrGuid,bstrRevList)	\
    (This)->lpVtbl -> StoreRevocationLists(This,bstrGuid,bstrRevList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll4_StoreRevocationInformation_Proxy( 
    IDRMEnroll4 * This,
    /* [in] */ BSTR bstrRevInfo);


void __RPC_STUB IDRMEnroll4_StoreRevocationInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDRMEnroll4_StoreRevocationLists_Proxy( 
    IDRMEnroll4 * This,
    /* [in] */ BSTR bstrGuid,
    /* [in] */ BSTR bstrRevList);


void __RPC_STUB IDRMEnroll4_StoreRevocationLists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDRMEnroll4_INTERFACE_DEFINED__ */



#ifndef __ENROLLOBJLib_LIBRARY_DEFINED__
#define __ENROLLOBJLib_LIBRARY_DEFINED__

/* library ENROLLOBJLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ENROLLOBJLib;

EXTERN_C const CLSID CLSID_DRMEnroll;

#ifdef __cplusplus

class DECLSPEC_UUID("685C8DEE-7BF1-47EF-BC0A-8B451023170B")
DRMEnroll;
#endif
#endif /* __ENROLLOBJLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\wmrmsdk\WMRM10.1\include\licenseserver.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0365 */
/* Compiler settings for licenseserver.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __licenseserver_h__
#define __licenseserver_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILicenseGenerator_FWD_DEFINED__
#define __ILicenseGenerator_FWD_DEFINED__
typedef interface ILicenseGenerator ILicenseGenerator;
#endif 	/* __ILicenseGenerator_FWD_DEFINED__ */


#ifndef __LicenseGenerator_FWD_DEFINED__
#define __LicenseGenerator_FWD_DEFINED__

#ifdef __cplusplus
typedef class LicenseGenerator LicenseGenerator;
#else
typedef struct LicenseGenerator LicenseGenerator;
#endif /* __cplusplus */

#endif 	/* __LicenseGenerator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_licenseserver_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================


extern RPC_IF_HANDLE __MIDL_itf_licenseserver_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_licenseserver_0000_v0_0_s_ifspec;

#ifndef __ILicenseGenerator_INTERFACE_DEFINED__
#define __ILicenseGenerator_INTERFACE_DEFINED__

/* interface ILicenseGenerator */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ILicenseGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17B54DBC-C13A-11D2-8B0C-00C04F79EC75")
    ILicenseGenerator : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IssueLicense( 
            /* [in] */ BSTR bstrConnectionString,
            /* [in] */ BSTR bstrLicenseRequest,
            /* [in] */ LONG luserId,
            /* [in] */ VARIANT varContentId,
            /* [in] */ VARIANT varNumDaysToExpiry,
            /* [in] */ VARIANT varRights,
            /* [in] */ VARIANT varMinClientSecurity,
            /* [out][in] */ VARIANT *pvarLicenseResponse,
            /* [out][in] */ VARIANT *pvarIssueId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteIssueEntry( 
            /* [in] */ BSTR bstrConnectionString,
            /* [in] */ LONG lLicenseIssueId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ BSTR bstrAttributeName,
            /* [in] */ VARIANT varAttributeValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR bstrAttributeName,
            /* [out] */ VARIANT *pvarAttributeValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallKeys( 
            /* [in] */ BSTR bstrConnectionString,
            /* [in] */ BOOL bReuse,
            /* [out][in] */ VARIANT *pvarLicenseServerPublicKey,
            /* [out][in] */ VARIANT *pvarLicenseServerPrivateKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILicenseGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILicenseGenerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILicenseGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILicenseGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILicenseGenerator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILicenseGenerator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILicenseGenerator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILicenseGenerator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IssueLicense )( 
            ILicenseGenerator * This,
            /* [in] */ BSTR bstrConnectionString,
            /* [in] */ BSTR bstrLicenseRequest,
            /* [in] */ LONG luserId,
            /* [in] */ VARIANT varContentId,
            /* [in] */ VARIANT varNumDaysToExpiry,
            /* [in] */ VARIANT varRights,
            /* [in] */ VARIANT varMinClientSecurity,
            /* [out][in] */ VARIANT *pvarLicenseResponse,
            /* [out][in] */ VARIANT *pvarIssueId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteIssueEntry )( 
            ILicenseGenerator * This,
            /* [in] */ BSTR bstrConnectionString,
            /* [in] */ LONG lLicenseIssueId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Set )( 
            ILicenseGenerator * This,
            /* [in] */ BSTR bstrAttributeName,
            /* [in] */ VARIANT varAttributeValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            ILicenseGenerator * This,
            /* [in] */ BSTR bstrAttributeName,
            /* [out] */ VARIANT *pvarAttributeValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InstallKeys )( 
            ILicenseGenerator * This,
            /* [in] */ BSTR bstrConnectionString,
            /* [in] */ BOOL bReuse,
            /* [out][in] */ VARIANT *pvarLicenseServerPublicKey,
            /* [out][in] */ VARIANT *pvarLicenseServerPrivateKey);
        
        END_INTERFACE
    } ILicenseGeneratorVtbl;

    interface ILicenseGenerator
    {
        CONST_VTBL struct ILicenseGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILicenseGenerator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILicenseGenerator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILicenseGenerator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILicenseGenerator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILicenseGenerator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILicenseGenerator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILicenseGenerator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILicenseGenerator_IssueLicense(This,bstrConnectionString,bstrLicenseRequest,luserId,varContentId,varNumDaysToExpiry,varRights,varMinClientSecurity,pvarLicenseResponse,pvarIssueId)	\
    (This)->lpVtbl -> IssueLicense(This,bstrConnectionString,bstrLicenseRequest,luserId,varContentId,varNumDaysToExpiry,varRights,varMinClientSecurity,pvarLicenseResponse,pvarIssueId)

#define ILicenseGenerator_DeleteIssueEntry(This,bstrConnectionString,lLicenseIssueId)	\
    (This)->lpVtbl -> DeleteIssueEntry(This,bstrConnectionString,lLicenseIssueId)

#define ILicenseGenerator_Set(This,bstrAttributeName,varAttributeValue)	\
    (This)->lpVtbl -> Set(This,bstrAttributeName,varAttributeValue)

#define ILicenseGenerator_Get(This,bstrAttributeName,pvarAttributeValue)	\
    (This)->lpVtbl -> Get(This,bstrAttributeName,pvarAttributeValue)

#define ILicenseGenerator_InstallKeys(This,bstrConnectionString,bReuse,pvarLicenseServerPublicKey,pvarLicenseServerPrivateKey)	\
    (This)->lpVtbl -> InstallKeys(This,bstrConnectionString,bReuse,pvarLicenseServerPublicKey,pvarLicenseServerPrivateKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILicenseGenerator_IssueLicense_Proxy( 
    ILicenseGenerator * This,
    /* [in] */ BSTR bstrConnectionString,
    /* [in] */ BSTR bstrLicenseRequest,
    /* [in] */ LONG luserId,
    /* [in] */ VARIANT varContentId,
    /* [in] */ VARIANT varNumDaysToExpiry,
    /* [in] */ VARIANT varRights,
    /* [in] */ VARIANT varMinClientSecurity,
    /* [out][in] */ VARIANT *pvarLicenseResponse,
    /* [out][in] */ VARIANT *pvarIssueId);


void __RPC_STUB ILicenseGenerator_IssueLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILicenseGenerator_DeleteIssueEntry_Proxy( 
    ILicenseGenerator * This,
    /* [in] */ BSTR bstrConnectionString,
    /* [in] */ LONG lLicenseIssueId);


void __RPC_STUB ILicenseGenerator_DeleteIssueEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILicenseGenerator_Set_Proxy( 
    ILicenseGenerator * This,
    /* [in] */ BSTR bstrAttributeName,
    /* [in] */ VARIANT varAttributeValue);


void __RPC_STUB ILicenseGenerator_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILicenseGenerator_Get_Proxy( 
    ILicenseGenerator * This,
    /* [in] */ BSTR bstrAttributeName,
    /* [out] */ VARIANT *pvarAttributeValue);


void __RPC_STUB ILicenseGenerator_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILicenseGenerator_InstallKeys_Proxy( 
    ILicenseGenerator * This,
    /* [in] */ BSTR bstrConnectionString,
    /* [in] */ BOOL bReuse,
    /* [out][in] */ VARIANT *pvarLicenseServerPublicKey,
    /* [out][in] */ VARIANT *pvarLicenseServerPrivateKey);


void __RPC_STUB ILicenseGenerator_InstallKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILicenseGenerator_INTERFACE_DEFINED__ */



#ifndef __LICENSESERVERLib_LIBRARY_DEFINED__
#define __LICENSESERVERLib_LIBRARY_DEFINED__

/* library LICENSESERVERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_LICENSESERVERLib;

EXTERN_C const CLSID CLSID_LicenseGenerator;

#ifdef __cplusplus

class DECLSPEC_UUID("17B54DBD-C13A-11D2-8B0C-00C04F79EC75")
LicenseGenerator;
#endif
#endif /* __LICENSESERVERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\winhttp\inc\winhttp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winhttp.h

Abstract:

    Contains manifests, macros, types and prototypes for Windows HTTP Services

--*/

#if !defined(_WINHTTPX_)
#define _WINHTTPX_



/*
 * Set up Structure Packing to be 4 bytes for all winhttp structures
 */

#if defined(_WIN64)
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif



#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(_WINHTTP_INTERNAL_)
#define WINHTTPAPI DECLSPEC_IMPORT
#else
#define WINHTTPAPI

#endif

#define BOOLAPI WINHTTPAPI BOOL WINAPI
//
// types
//

typedef LPVOID HINTERNET;
typedef HINTERNET * LPHINTERNET;

typedef WORD INTERNET_PORT;
typedef INTERNET_PORT * LPINTERNET_PORT;

//
// manifests
//

#define INTERNET_DEFAULT_PORT           0           // use the protocol-specific default
#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "

// flags for WinHttpOpen():
#define WINHTTP_FLAG_ASYNC              0x10000000  // this session is asynchronous (where supported)

// flags for WinHttpOpenRequest():
#define WINHTTP_FLAG_SECURE                0x00800000  // use SSL if applicable (HTTPS)
#define WINHTTP_FLAG_ESCAPE_PERCENT        0x00000004  // if escaping enabled, escape percent as well
#define WINHTTP_FLAG_NULL_CODEPAGE         0x00000008  // assume all symbols are ASCII, use fast convertion
#define WINHTTP_FLAG_BYPASS_PROXY_CACHE    0x00000100 // add "pragma: no-cache" request header
#define	WINHTTP_FLAG_REFRESH               WINHTTP_FLAG_BYPASS_PROXY_CACHE
#define WINHTTP_FLAG_ESCAPE_DISABLE        0x00000040  // disable escaping
#define WINHTTP_FLAG_ESCAPE_DISABLE_QUERY  0x00000080  // if escaping enabled escape path part, but do not escape query


#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x00000100
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.
#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.
#define SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE   0x00000200


//
// WINHTTP_ASYNC_RESULT - this structure is returned to the application via
// the callback with WINHTTP_CALLBACK_STATUS_REQUEST_COMPLETE. It is not sufficient to
// just return the result of the async operation. If the API failed then the
// app cannot call GetLastError() because the thread context will be incorrect.
// Both the value returned by the async API and any resultant error code are
// made available. The app need not check dwError if dwResult indicates that
// the API succeeded (in this case dwError will be ERROR_SUCCESS)
//

typedef struct
{
    DWORD_PTR dwResult;  // indicates which async API has encountered an error
    DWORD dwError;       // the error code if the API failed
}
WINHTTP_ASYNC_RESULT, * LPWINHTTP_ASYNC_RESULT;


//
// HTTP_VERSION_INFO - query or set global HTTP version (1.0 or 1.1)
//

typedef struct
{
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
}
HTTP_VERSION_INFO, * LPHTTP_VERSION_INFO;


//
// INTERNET_SCHEME - URL scheme type
//

typedef int INTERNET_SCHEME, * LPINTERNET_SCHEME;

#define INTERNET_SCHEME_HTTP        (1)
#define INTERNET_SCHEME_HTTPS       (2)


//
// URL_COMPONENTS - the constituent parts of an URL. Used in WinHttpCrackUrl()
// and WinHttpCreateUrl()
//
// For WinHttpCrackUrl(), if a pointer field and its corresponding length field
// are both 0 then that component is not returned. If the pointer field is NULL
// but the length field is not zero, then both the pointer and length fields are
// returned if both pointer and corresponding length fields are non-zero then
// the pointer field points to a buffer where the component is copied. The
// component may be un-escaped, depending on dwFlags
//
// For WinHttpCreateUrl(), the pointer fields should be NULL if the component
// is not required. If the corresponding length field is zero then the pointer
// field is the address of a zero-terminated string. If the length field is not
// zero then it is the string length of the corresponding pointer field
//

#pragma warning( disable : 4121 )   // disable alignment warning

typedef struct
{
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
}
URL_COMPONENTS, * LPURL_COMPONENTS;

typedef URL_COMPONENTS URL_COMPONENTSW;
typedef LPURL_COMPONENTS LPURL_COMPONENTSW;

#pragma warning( default : 4121 )   // restore alignment warning

//
// WINHTTP_PROXY_INFO - structure supplied with WINHTTP_OPTION_PROXY to get/
// set proxy information on a WinHttpOpen() handle
//

typedef struct
{
    DWORD  dwAccessType;      // see WINHTTP_ACCESS_* types below
    LPWSTR lpszProxy;         // proxy server list
    LPWSTR lpszProxyBypass;   // proxy bypass list
}
WINHTTP_PROXY_INFO, * LPWINHTTP_PROXY_INFO;

typedef WINHTTP_PROXY_INFO WINHTTP_PROXY_INFOW;
typedef LPWINHTTP_PROXY_INFO LPWINHTTP_PROXY_INFOW;


typedef struct
{
    DWORD   dwFlags;
    DWORD   dwAutoDetectFlags;
    LPCWSTR lpszAutoConfigUrl;
    LPVOID  lpvReserved;
    DWORD   dwReserved;
    BOOL    fAutoLogonIfChallenged;
}
WINHTTP_AUTOPROXY_OPTIONS;



#define WINHTTP_AUTOPROXY_AUTO_DETECT           0x00000001
#define WINHTTP_AUTOPROXY_CONFIG_URL            0x00000002
#define WINHTTP_AUTOPROXY_RUN_INPROCESS         0x00010000
#define WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY   0x00020000
//
// Flags for dwAutoDetectFlags 
//
#define WINHTTP_AUTO_DETECT_TYPE_DHCP           0x00000001
#define WINHTTP_AUTO_DETECT_TYPE_DNS_A          0x00000002


//
// WINHTTP_CERTIFICATE_INFO lpBuffer - contains the certificate returned from
// the server
//

typedef struct
{
    //
    // ftExpiry - date the certificate expires.
    //

    FILETIME ftExpiry;

    //
    // ftStart - date the certificate becomes valid.
    //

    FILETIME ftStart;

    //
    // lpszSubjectInfo - the name of organization, site, and server
    //   the cert. was issued for.
    //

    LPWSTR lpszSubjectInfo;

    //
    // lpszIssuerInfo - the name of orgainzation, site, and server
    //   the cert was issues by.
    //

    LPWSTR lpszIssuerInfo;

    //
    // lpszProtocolName - the name of the protocol used to provide the secure
    //   connection.
    //

    LPWSTR lpszProtocolName;

    //
    // lpszSignatureAlgName - the name of the algorithm used for signing
    //  the certificate.
    //

    LPWSTR lpszSignatureAlgName;

    //
    // lpszEncryptionAlgName - the name of the algorithm used for
    //  doing encryption over the secure channel (SSL) connection.
    //

    LPWSTR lpszEncryptionAlgName;

    //
    // dwKeySize - size of the key.
    //

    DWORD dwKeySize;

}
WINHTTP_CERTIFICATE_INFO;


//
// prototypes
//

//
// constants for WinHttpTimeFromSystemTime
//

#define WINHTTP_TIME_FORMAT_BUFSIZE   62

BOOLAPI
WinHttpTimeFromSystemTime
(
    __in CONST SYSTEMTIME *pst,  // input GMT time
    __out_ecount(WINHTTP_TIME_FORMAT_BUFSIZE) LPWSTR pwszTime // output string buffer
);

BOOLAPI
WinHttpTimeToSystemTime
(
    __in LPCWSTR pwszTime,        // NULL terminated string
    __out SYSTEMTIME *pst         // output in GMT time
);


//
// flags for CrackUrl() and CombineUrl()
//

#define ICU_NO_ENCODE   0x20000000  // Don't convert unsafe characters to escape sequence
#define ICU_DECODE      0x10000000  // Convert %XX escape sequences to characters
#define ICU_NO_META     0x08000000  // Don't convert .. etc. meta path sequences
#define ICU_ENCODE_SPACES_ONLY 0x04000000  // Encode spaces only
#define ICU_BROWSER_MODE 0x02000000 // Special encode/decode rules for browser
#define ICU_ENCODE_PERCENT      0x00001000      // Encode any percent (ASCII25)
        // signs encountered, default is to not encode percent.

   
BOOLAPI
WinHttpCrackUrl
(
    __in_ecount(dwUrlLength) LPCWSTR pwszUrl,
    __in DWORD dwUrlLength,
    __in DWORD dwFlags,
    __inout LPURL_COMPONENTS lpUrlComponents
);
    
BOOLAPI
WinHttpCreateUrl
(
    __in LPURL_COMPONENTS lpUrlComponents,
    __in DWORD dwFlags,
    __out_ecount_full_opt(*lpdwUrlLength) LPWSTR pwszUrl,
    __inout LPDWORD lpdwUrlLength
);

//
// flags for WinHttpCrackUrl() and WinHttpCreateUrl()
//

#define ICU_ESCAPE      0x80000000  // (un)escape URL characters


BOOLAPI
WinHttpCheckPlatform(void);


WINHTTPAPI BOOL WINAPI WinHttpGetDefaultProxyConfiguration( IN OUT WINHTTP_PROXY_INFO * pProxyInfo);
WINHTTPAPI BOOL WINAPI WinHttpSetDefaultProxyConfiguration( IN WINHTTP_PROXY_INFO * pProxyInfo);

    
WINHTTPAPI
HINTERNET
WINAPI
WinHttpOpen
(
    IN LPCWSTR pwszUserAgent,
    IN DWORD   dwAccessType,
    IN LPCWSTR pwszProxyName   OPTIONAL,
    IN LPCWSTR pwszProxyBypass OPTIONAL,
    IN DWORD   dwFlags
);

// WinHttpOpen dwAccessType values (also for WINHTTP_PROXY_INFO::dwAccessType)
#define WINHTTP_ACCESS_TYPE_DEFAULT_PROXY               0
#define WINHTTP_ACCESS_TYPE_NO_PROXY                    1
#define WINHTTP_ACCESS_TYPE_NAMED_PROXY                 3

// WinHttpOpen prettifiers for optional parameters
#define WINHTTP_NO_PROXY_NAME     NULL
#define WINHTTP_NO_PROXY_BYPASS   NULL

BOOLAPI
WinHttpCloseHandle
(
    IN HINTERNET hInternet
);

   
WINHTTPAPI
HINTERNET
WINAPI
WinHttpConnect
(
    IN HINTERNET hSession,
    IN LPCWSTR pswzServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
);


BOOLAPI
WinHttpReadData
(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

BOOLAPI
WinHttpWriteData
(
    IN HINTERNET hRequest,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
);
    

BOOLAPI
WinHttpQueryDataAvailable
(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL
);

    
BOOLAPI
WinHttpQueryOption
(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
);
    
BOOLAPI
WinHttpSetOption
(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

BOOLAPI
WinHttpSetTimeouts
(    
    IN HINTERNET    hInternet,           // Session/Request handle.
    IN int          nResolveTimeout,
    IN int          nConnectTimeout,
    IN int          nSendTimeout,
    IN int          nReceiveTimeout
);

//
// options manifests for WinHttp{Query|Set}Option
//

#define WINHTTP_FIRST_OPTION                         WINHTTP_OPTION_CALLBACK

#define WINHTTP_OPTION_CALLBACK                       1
#define WINHTTP_OPTION_RESOLVE_TIMEOUT                2
#define WINHTTP_OPTION_CONNECT_TIMEOUT                3
#define WINHTTP_OPTION_CONNECT_RETRIES                4
#define WINHTTP_OPTION_SEND_TIMEOUT                   5
#define WINHTTP_OPTION_RECEIVE_TIMEOUT                6
#define WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT       7
#define WINHTTP_OPTION_HANDLE_TYPE                    9
#define WINHTTP_OPTION_READ_BUFFER_SIZE              12
#define WINHTTP_OPTION_WRITE_BUFFER_SIZE             13
#define WINHTTP_OPTION_PARENT_HANDLE                 21
#define WINHTTP_OPTION_EXTENDED_ERROR                24
#define WINHTTP_OPTION_SECURITY_FLAGS                31
#define WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT   32
#define WINHTTP_OPTION_URL                           34
#define WINHTTP_OPTION_SECURITY_KEY_BITNESS          36
#define WINHTTP_OPTION_PROXY                         38


#define WINHTTP_OPTION_USER_AGENT                    41
#define WINHTTP_OPTION_CONTEXT_VALUE                 45
#define WINHTTP_OPTION_CLIENT_CERT_CONTEXT           47
#define WINHTTP_OPTION_REQUEST_PRIORITY              58
#define WINHTTP_OPTION_HTTP_VERSION                  59
#define WINHTTP_OPTION_DISABLE_FEATURE               63

#define WINHTTP_OPTION_CODEPAGE                      68
#define WINHTTP_OPTION_MAX_CONNS_PER_SERVER          73
#define WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER      74
#define WINHTTP_OPTION_AUTOLOGON_POLICY              77
#define WINHTTP_OPTION_SERVER_CERT_CONTEXT           78
#define WINHTTP_OPTION_ENABLE_FEATURE                79
#define WINHTTP_OPTION_WORKER_THREAD_COUNT           80
#define WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT      81
#define WINHTTP_OPTION_PASSPORT_COBRANDING_URL       82
#define WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH       83
#define WINHTTP_OPTION_SECURE_PROTOCOLS              84
#define WINHTTP_OPTION_ENABLETRACING                 85
#define WINHTTP_OPTION_PASSPORT_SIGN_OUT             86
#define WINHTTP_OPTION_PASSPORT_RETURN_URL           87
#define WINHTTP_OPTION_REDIRECT_POLICY               88
#define WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS  89
#define WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE      90
#define WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE      91
#define WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE       92


#define WINHTTP_LAST_OPTION                          WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE

#define WINHTTP_OPTION_USERNAME                      0x1000
#define WINHTTP_OPTION_PASSWORD                      0x1001
#define WINHTTP_OPTION_PROXY_USERNAME                0x1002
#define WINHTTP_OPTION_PROXY_PASSWORD                0x1003


// manifest value for WINHTTP_OPTION_MAX_CONNS_PER_SERVER and WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER
#define WINHTTP_CONNS_PER_SERVER_UNLIMITED    0xFFFFFFFF


// values for WINHTTP_OPTION_AUTOLOGON_POLICY
#define WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM   0
#define WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW      1
#define WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH     2

#define WINHTTP_AUTOLOGON_SECURITY_LEVEL_DEFAULT        WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM

// values for WINHTTP_OPTION_REDIRECT_POLICY
#define WINHTTP_OPTION_REDIRECT_POLICY_NEVER                        0
#define WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP       1
#define WINHTTP_OPTION_REDIRECT_POLICY_ALWAYS                       2

#define WINHTTP_OPTION_REDIRECT_POLICY_LAST            WINHTTP_OPTION_REDIRECT_POLICY_ALWAYS
#define WINHTTP_OPTION_REDIRECT_POLICY_DEFAULT         WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP

#define WINHTTP_DISABLE_PASSPORT_AUTH    0x00000000
#define WINHTTP_ENABLE_PASSPORT_AUTH     0x10000000
#define WINHTTP_DISABLE_PASSPORT_KEYRING 0x20000000
#define WINHTTP_ENABLE_PASSPORT_KEYRING  0x40000000	


// values for WINHTTP_OPTION_DISABLE_FEATURE
#define WINHTTP_DISABLE_COOKIES                   0x00000001
#define WINHTTP_DISABLE_REDIRECTS                 0x00000002
#define WINHTTP_DISABLE_AUTHENTICATION            0x00000004
#define WINHTTP_DISABLE_KEEP_ALIVE                0x00000008

// values for WINHTTP_OPTION_ENABLE_FEATURE
#define WINHTTP_ENABLE_SSL_REVOCATION             0x00000001
#define WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION   0x00000002

//
// winhttp handle types
//
#define WINHTTP_HANDLE_TYPE_SESSION                  1
#define WINHTTP_HANDLE_TYPE_CONNECT                  2
#define WINHTTP_HANDLE_TYPE_REQUEST                  3

//
// values for auth schemes
//
#define WINHTTP_AUTH_SCHEME_BASIC      0x00000001
#define WINHTTP_AUTH_SCHEME_NTLM       0x00000002
#define WINHTTP_AUTH_SCHEME_PASSPORT   0x00000004
#define WINHTTP_AUTH_SCHEME_DIGEST     0x00000008
#define WINHTTP_AUTH_SCHEME_NEGOTIATE  0x00000010
    
// WinHttp supported Authentication Targets

#define WINHTTP_AUTH_TARGET_SERVER 0x00000000
#define WINHTTP_AUTH_TARGET_PROXY  0x00000001

//
// values for WINHTTP_OPTION_SECURITY_FLAGS
//

// query only
#define SECURITY_FLAG_SECURE                    0x00000001 // can query only
#define SECURITY_FLAG_STRENGTH_WEAK             0x10000000
#define SECURITY_FLAG_STRENGTH_MEDIUM           0x40000000
#define SECURITY_FLAG_STRENGTH_STRONG           0x20000000



// Secure connection error status flags
#define WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED         0x00000001
#define WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT            0x00000002
#define WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED            0x00000004
#define WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA              0x00000008
#define WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID         0x00000010
#define WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID       0x00000020
#define WINHTTP_CALLBACK_STATUS_FLAG_CERT_WRONG_USAGE        0x00000040
#define WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR  0x80000000


#define WINHTTP_FLAG_SECURE_PROTOCOL_SSL2   0x00000008
#define WINHTTP_FLAG_SECURE_PROTOCOL_SSL3   0x00000020
#define WINHTTP_FLAG_SECURE_PROTOCOL_TLS1   0x00000080
#define WINHTTP_FLAG_SECURE_PROTOCOL_ALL    (WINHTTP_FLAG_SECURE_PROTOCOL_SSL2 | \
                                             WINHTTP_FLAG_SECURE_PROTOCOL_SSL3 | \
                                             WINHTTP_FLAG_SECURE_PROTOCOL_TLS1)


//
// callback function for WinHttpSetStatusCallback
//

typedef
VOID
(CALLBACK * WINHTTP_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef WINHTTP_STATUS_CALLBACK * LPWINHTTP_STATUS_CALLBACK;


WINHTTPAPI
WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpSetStatusCallback
(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
);


//
// status manifests for WinHttp status callback
//

#define WINHTTP_CALLBACK_STATUS_RESOLVING_NAME          0x00000001
#define WINHTTP_CALLBACK_STATUS_NAME_RESOLVED           0x00000002
#define WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER    0x00000004
#define WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER     0x00000008
#define WINHTTP_CALLBACK_STATUS_SENDING_REQUEST         0x00000010
#define WINHTTP_CALLBACK_STATUS_REQUEST_SENT            0x00000020
#define WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE      0x00000040
#define WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED       0x00000080
#define WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION      0x00000100
#define WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED       0x00000200
#define WINHTTP_CALLBACK_STATUS_HANDLE_CREATED          0x00000400
#define WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING          0x00000800
#define WINHTTP_CALLBACK_STATUS_DETECTING_PROXY         0x00001000
#define WINHTTP_CALLBACK_STATUS_REDIRECT                0x00004000
#define WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE   0x00008000
#define WINHTTP_CALLBACK_STATUS_SECURE_FAILURE          0x00010000
#define WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE       0x00020000
#define WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE          0x00040000
#define WINHTTP_CALLBACK_STATUS_READ_COMPLETE           0x00080000
#define WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE          0x00100000
#define WINHTTP_CALLBACK_STATUS_REQUEST_ERROR           0x00200000
#define WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE    0x00400000


// API Enums for WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
#define API_RECEIVE_RESPONSE          (1)
#define API_QUERY_DATA_AVAILABLE      (2)
#define API_READ_DATA                 (3)
#define API_WRITE_DATA                (4)
#define API_SEND_REQUEST              (5)


#define WINHTTP_CALLBACK_FLAG_RESOLVE_NAME              (WINHTTP_CALLBACK_STATUS_RESOLVING_NAME | WINHTTP_CALLBACK_STATUS_NAME_RESOLVED)
#define WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER         (WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER | WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER)
#define WINHTTP_CALLBACK_FLAG_SEND_REQUEST              (WINHTTP_CALLBACK_STATUS_SENDING_REQUEST | WINHTTP_CALLBACK_STATUS_REQUEST_SENT)
#define WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE          (WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE | WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED)
#define WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION          (WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION | WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED)
#define WINHTTP_CALLBACK_FLAG_HANDLES                   (WINHTTP_CALLBACK_STATUS_HANDLE_CREATED | WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING)
#define WINHTTP_CALLBACK_FLAG_DETECTING_PROXY           WINHTTP_CALLBACK_STATUS_DETECTING_PROXY
#define WINHTTP_CALLBACK_FLAG_REDIRECT                  WINHTTP_CALLBACK_STATUS_REDIRECT
#define WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE     WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE
#define WINHTTP_CALLBACK_FLAG_SECURE_FAILURE            WINHTTP_CALLBACK_STATUS_SECURE_FAILURE
#define WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE      WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE
#define WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE         WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
#define WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE            WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
#define WINHTTP_CALLBACK_FLAG_READ_COMPLETE             WINHTTP_CALLBACK_STATUS_READ_COMPLETE
#define WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE            WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
#define WINHTTP_CALLBACK_FLAG_REQUEST_ERROR             WINHTTP_CALLBACK_STATUS_REQUEST_ERROR


#define WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS           (WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE   \
                                                        | WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE     \
                                                        | WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE        \
                                                        | WINHTTP_CALLBACK_STATUS_READ_COMPLETE         \
                                                        | WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE        \
                                                        | WINHTTP_CALLBACK_STATUS_REQUEST_ERROR)
#define WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS         0xffffffff

//
// if the following value is returned by WinHttpSetStatusCallback, then
// probably an invalid (non-code) address was supplied for the callback
//

#define WINHTTP_INVALID_STATUS_CALLBACK        ((WINHTTP_STATUS_CALLBACK)(-1L))


//
// WinHttpQueryHeaders info levels. Generally, there is one info level
// for each potential RFC822/HTTP/MIME header that an HTTP server
// may send as part of a request response.
//
// The WINHTTP_QUERY_RAW_HEADERS info level is provided for clients
// that choose to perform their own header parsing.
//


#define WINHTTP_QUERY_MIME_VERSION                 0
#define WINHTTP_QUERY_CONTENT_TYPE                 1
#define WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING    2
#define WINHTTP_QUERY_CONTENT_ID                   3
#define WINHTTP_QUERY_CONTENT_DESCRIPTION          4
#define WINHTTP_QUERY_CONTENT_LENGTH               5
#define WINHTTP_QUERY_CONTENT_LANGUAGE             6
#define WINHTTP_QUERY_ALLOW                        7
#define WINHTTP_QUERY_PUBLIC                       8
#define WINHTTP_QUERY_DATE                         9
#define WINHTTP_QUERY_EXPIRES                      10
#define WINHTTP_QUERY_LAST_MODIFIED                11
#define WINHTTP_QUERY_MESSAGE_ID                   12
#define WINHTTP_QUERY_URI                          13
#define WINHTTP_QUERY_DERIVED_FROM                 14
#define WINHTTP_QUERY_COST                         15
#define WINHTTP_QUERY_LINK                         16
#define WINHTTP_QUERY_PRAGMA                       17
#define WINHTTP_QUERY_VERSION                      18  // special: part of status line
#define WINHTTP_QUERY_STATUS_CODE                  19  // special: part of status line
#define WINHTTP_QUERY_STATUS_TEXT                  20  // special: part of status line
#define WINHTTP_QUERY_RAW_HEADERS                  21  // special: all headers as ASCIIZ
#define WINHTTP_QUERY_RAW_HEADERS_CRLF             22  // special: all headers
#define WINHTTP_QUERY_CONNECTION                   23
#define WINHTTP_QUERY_ACCEPT                       24
#define WINHTTP_QUERY_ACCEPT_CHARSET               25
#define WINHTTP_QUERY_ACCEPT_ENCODING              26
#define WINHTTP_QUERY_ACCEPT_LANGUAGE              27
#define WINHTTP_QUERY_AUTHORIZATION                28
#define WINHTTP_QUERY_CONTENT_ENCODING             29
#define WINHTTP_QUERY_FORWARDED                    30
#define WINHTTP_QUERY_FROM                         31
#define WINHTTP_QUERY_IF_MODIFIED_SINCE            32
#define WINHTTP_QUERY_LOCATION                     33
#define WINHTTP_QUERY_ORIG_URI                     34
#define WINHTTP_QUERY_REFERER                      35
#define WINHTTP_QUERY_RETRY_AFTER                  36
#define WINHTTP_QUERY_SERVER                       37
#define WINHTTP_QUERY_TITLE                        38
#define WINHTTP_QUERY_USER_AGENT                   39
#define WINHTTP_QUERY_WWW_AUTHENTICATE             40
#define WINHTTP_QUERY_PROXY_AUTHENTICATE           41
#define WINHTTP_QUERY_ACCEPT_RANGES                42
#define WINHTTP_QUERY_SET_COOKIE                   43
#define WINHTTP_QUERY_COOKIE                       44
#define WINHTTP_QUERY_REQUEST_METHOD               45  // special: GET/POST etc.
#define WINHTTP_QUERY_REFRESH                      46
#define WINHTTP_QUERY_CONTENT_DISPOSITION          47

//
// HTTP 1.1 defined headers
//

#define WINHTTP_QUERY_AGE                          48
#define WINHTTP_QUERY_CACHE_CONTROL                49
#define WINHTTP_QUERY_CONTENT_BASE                 50
#define WINHTTP_QUERY_CONTENT_LOCATION             51
#define WINHTTP_QUERY_CONTENT_MD5                  52
#define WINHTTP_QUERY_CONTENT_RANGE                53
#define WINHTTP_QUERY_ETAG                         54
#define WINHTTP_QUERY_HOST                         55
#define WINHTTP_QUERY_IF_MATCH                     56
#define WINHTTP_QUERY_IF_NONE_MATCH                57
#define WINHTTP_QUERY_IF_RANGE                     58
#define WINHTTP_QUERY_IF_UNMODIFIED_SINCE          59
#define WINHTTP_QUERY_MAX_FORWARDS                 60
#define WINHTTP_QUERY_PROXY_AUTHORIZATION          61
#define WINHTTP_QUERY_RANGE                        62
#define WINHTTP_QUERY_TRANSFER_ENCODING            63
#define WINHTTP_QUERY_UPGRADE                      64
#define WINHTTP_QUERY_VARY                         65
#define WINHTTP_QUERY_VIA                          66
#define WINHTTP_QUERY_WARNING                      67
#define WINHTTP_QUERY_EXPECT                       68
#define WINHTTP_QUERY_PROXY_CONNECTION             69
#define WINHTTP_QUERY_UNLESS_MODIFIED_SINCE        70



#define WINHTTP_QUERY_PROXY_SUPPORT                75
#define WINHTTP_QUERY_AUTHENTICATION_INFO          76
#define WINHTTP_QUERY_PASSPORT_URLS                77
#define WINHTTP_QUERY_PASSPORT_CONFIG              78

#define WINHTTP_QUERY_MAX                          78

//
// WINHTTP_QUERY_CUSTOM - if this special value is supplied as the dwInfoLevel
// parameter of WinHttpQueryHeaders() then the lpBuffer parameter contains the name
// of the header we are to query
//

#define WINHTTP_QUERY_CUSTOM                       65535

//
// WINHTTP_QUERY_FLAG_REQUEST_HEADERS - if this bit is set in the dwInfoLevel
// parameter of WinHttpQueryHeaders() then the request headers will be queried for the
// request information
//

#define WINHTTP_QUERY_FLAG_REQUEST_HEADERS         0x80000000

//
// WINHTTP_QUERY_FLAG_SYSTEMTIME - if this bit is set in the dwInfoLevel parameter
// of WinHttpQueryHeaders() AND the header being queried contains date information,
// e.g. the "Expires:" header then lpBuffer will contain a SYSTEMTIME structure
// containing the date and time information converted from the header string
//

#define WINHTTP_QUERY_FLAG_SYSTEMTIME              0x40000000

//
// WINHTTP_QUERY_FLAG_NUMBER - if this bit is set in the dwInfoLevel parameter of
// HttpQueryHeader(), then the value of the header will be converted to a number
// before being returned to the caller, if applicable
//

#define WINHTTP_QUERY_FLAG_NUMBER                  0x20000000



//
// HTTP Response Status Codes:
//

#define HTTP_STATUS_CONTINUE            100 // OK to continue with request
#define HTTP_STATUS_SWITCH_PROTOCOLS    101 // server has switched protocols in upgrade header

#define HTTP_STATUS_OK                  200 // request completed
#define HTTP_STATUS_CREATED             201 // object created, reason = new URI
#define HTTP_STATUS_ACCEPTED            202 // async completion (TBS)
#define HTTP_STATUS_PARTIAL             203 // partial completion
#define HTTP_STATUS_NO_CONTENT          204 // no info to return
#define HTTP_STATUS_RESET_CONTENT       205 // request completed, but clear form
#define HTTP_STATUS_PARTIAL_CONTENT     206 // partial GET fulfilled
#define HTTP_STATUS_WEBDAV_MULTI_STATUS 207 // WebDAV Multi-Status

#define HTTP_STATUS_AMBIGUOUS           300 // server couldn't decide what to return
#define HTTP_STATUS_MOVED               301 // object permanently moved
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_STATUS_REDIRECT_METHOD     303 // redirection w/ new access method
#define HTTP_STATUS_NOT_MODIFIED        304 // if-modified-since was not modified
#define HTTP_STATUS_USE_PROXY           305 // redirection to proxy, location header specifies proxy to use
#define HTTP_STATUS_REDIRECT_KEEP_VERB  307 // HTTP/1.1: keep same verb

#define HTTP_STATUS_BAD_REQUEST         400 // invalid syntax
#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_PAYMENT_REQ         402 // payment required
#define HTTP_STATUS_FORBIDDEN           403 // request forbidden
#define HTTP_STATUS_NOT_FOUND           404 // object not found
#define HTTP_STATUS_BAD_METHOD          405 // method is not allowed
#define HTTP_STATUS_NONE_ACCEPTABLE     406 // no response acceptable to client found
#define HTTP_STATUS_PROXY_AUTH_REQ      407 // proxy authentication required
#define HTTP_STATUS_REQUEST_TIMEOUT     408 // server timed out waiting for request
#define HTTP_STATUS_CONFLICT            409 // user should resubmit with more info
#define HTTP_STATUS_GONE                410 // the resource is no longer available
#define HTTP_STATUS_LENGTH_REQUIRED     411 // the server refused to accept request w/o a length
#define HTTP_STATUS_PRECOND_FAILED      412 // precondition given in request failed
#define HTTP_STATUS_REQUEST_TOO_LARGE   413 // request entity was too large
#define HTTP_STATUS_URI_TOO_LONG        414 // request URI too long
#define HTTP_STATUS_UNSUPPORTED_MEDIA   415 // unsupported media type
#define HTTP_STATUS_RETRY_WITH          449 // retry after doing the appropriate action.

#define HTTP_STATUS_SERVER_ERROR        500 // internal server error
#define HTTP_STATUS_NOT_SUPPORTED       501 // required not supported
#define HTTP_STATUS_BAD_GATEWAY         502 // error response received from gateway
#define HTTP_STATUS_SERVICE_UNAVAIL     503 // temporarily overloaded
#define HTTP_STATUS_GATEWAY_TIMEOUT     504 // timed out waiting for gateway
#define HTTP_STATUS_VERSION_NOT_SUP     505 // HTTP version not supported

#define HTTP_STATUS_FIRST               HTTP_STATUS_CONTINUE
#define HTTP_STATUS_LAST                HTTP_STATUS_VERSION_NOT_SUP

//
// prototypes
//
    
WINHTTPAPI
HINTERNET
WINAPI
WinHttpOpenRequest
(
    IN HINTERNET hConnect,
    IN LPCWSTR pwszVerb,
    IN LPCWSTR pwszObjectName,
    IN LPCWSTR pwszVersion,
    IN LPCWSTR pwszReferrer OPTIONAL,
    IN LPCWSTR FAR * ppwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
);

// WinHttpOpenRequest prettifers for optional parameters
#define WINHTTP_NO_REFERER             NULL
#define WINHTTP_DEFAULT_ACCEPT_TYPES   NULL
    
BOOLAPI
WinHttpAddRequestHeaders
(
    IN HINTERNET hRequest,
    IN LPCWSTR pwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);

//
// values for dwModifiers parameter of WinHttpAddRequestHeaders()
//

#define WINHTTP_ADDREQ_INDEX_MASK      0x0000FFFF
#define WINHTTP_ADDREQ_FLAGS_MASK      0xFFFF0000

//
// WINHTTP_ADDREQ_FLAG_ADD_IF_NEW - the header will only be added if it doesn't
// already exist
//

#define WINHTTP_ADDREQ_FLAG_ADD_IF_NEW 0x10000000

//
// WINHTTP_ADDREQ_FLAG_ADD - if WINHTTP_ADDREQ_FLAG_REPLACE is set but the header is
// not found then if this flag is set, the header is added anyway, so long as
// there is a valid header-value
//

#define WINHTTP_ADDREQ_FLAG_ADD        0x20000000

//
// WINHTTP_ADDREQ_FLAG_COALESCE - coalesce headers with same name. e.g.
// "Accept: text/*" and "Accept: audio/*" with this flag results in a single
// header: "Accept: text/*, audio/*"
//

#define WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       0x40000000
#define WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   0x01000000
#define WINHTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA

//
// WINHTTP_ADDREQ_FLAG_REPLACE - replaces the specified header. Only one header can
// be supplied in the buffer. If the header to be replaced is not the first
// in a list of headers with the same name, then the relative index should be
// supplied in the low 8 bits of the dwModifiers parameter. If the header-value
// part is missing, then the header is removed
//

#define WINHTTP_ADDREQ_FLAG_REPLACE    0x80000000

    
BOOLAPI
WinHttpSendRequest
(
    IN HINTERNET hRequest,
    IN LPCWSTR pwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
);

// WinHttpSendRequest prettifiers for optional parameters.
#define WINHTTP_NO_ADDITIONAL_HEADERS   NULL
#define WINHTTP_NO_REQUEST_DATA         NULL


BOOLAPI WinHttpSetCredentials
(
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from WinHttpQueryAuthSchemes()
    
    IN LPCWSTR     pwszUserName,    // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCWSTR     pwszPassword,    // 1) "" == Blank Password; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID      pAuthParams
);


BOOLAPI WinHttpQueryAuthSchemes
(
    IN  HINTERNET   hRequest,             // HINTERNET handle returned by WinHttpOpenRequest   
    OUT LPDWORD     lpdwSupportedSchemes, // a bitmap of available Authentication Schemes
    OUT LPDWORD     lpdwFirstScheme,      // returns the first auth scheme returned by the server
    OUT LPDWORD     pdwAuthTarget  
);

BOOLAPI WinHttpQueryAuthParams(
    IN  HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest   
    IN  DWORD       AuthScheme,
    OUT LPVOID*     pAuthParams      // Scheme-specific Advanced auth parameters
    );

  
WINHTTPAPI
BOOL
WINAPI
WinHttpReceiveResponse
(
    IN HINTERNET hRequest,
    IN LPVOID lpReserved
);



BOOLAPI
WinHttpQueryHeaders
(
    IN     HINTERNET hRequest,
    IN     DWORD     dwInfoLevel,
    IN     LPCWSTR   pwszName OPTIONAL, 
       OUT LPVOID    lpBuffer OPTIONAL,
    IN OUT LPDWORD   lpdwBufferLength,
    IN OUT LPDWORD   lpdwIndex OPTIONAL
);

// WinHttpQueryHeaders prettifiers for optional parameters.
#define WINHTTP_HEADER_NAME_BY_INDEX           NULL
#define WINHTTP_NO_OUTPUT_BUFFER               NULL
#define WINHTTP_NO_HEADER_INDEX                NULL


BOOLAPI
WinHttpDetectAutoProxyConfigUrl
(
    __in  DWORD     dwAutoDetectFlags,
    __out LPWSTR *  ppwszAutoConfigUrl
);

BOOLAPI
WinHttpGetProxyForUrl
(
    IN  HINTERNET                   hSession,
    IN  LPCWSTR                     lpcwszUrl,
    IN  WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    OUT WINHTTP_PROXY_INFO *        pProxyInfo  
);


typedef struct
{
    BOOL    fAutoDetect;
    LPWSTR  lpszAutoConfigUrl;
    LPWSTR  lpszProxy;
    LPWSTR  lpszProxyBypass;
} WINHTTP_CURRENT_USER_IE_PROXY_CONFIG;


BOOLAPI
WinHttpGetIEProxyConfigForCurrentUser
(
    IN OUT WINHTTP_CURRENT_USER_IE_PROXY_CONFIG * pProxyConfig
);


//#if !defined(_WINERROR_)

//
// WinHttp API error returns
//

#define WINHTTP_ERROR_BASE                     12000

#define ERROR_WINHTTP_OUT_OF_HANDLES           (WINHTTP_ERROR_BASE + 1)
#define ERROR_WINHTTP_TIMEOUT                  (WINHTTP_ERROR_BASE + 2)
#define ERROR_WINHTTP_INTERNAL_ERROR           (WINHTTP_ERROR_BASE + 4)
#define ERROR_WINHTTP_INVALID_URL              (WINHTTP_ERROR_BASE + 5)
#define ERROR_WINHTTP_UNRECOGNIZED_SCHEME      (WINHTTP_ERROR_BASE + 6)
#define ERROR_WINHTTP_NAME_NOT_RESOLVED        (WINHTTP_ERROR_BASE + 7)
#define ERROR_WINHTTP_INVALID_OPTION           (WINHTTP_ERROR_BASE + 9)
#define ERROR_WINHTTP_OPTION_NOT_SETTABLE      (WINHTTP_ERROR_BASE + 11)
#define ERROR_WINHTTP_SHUTDOWN                 (WINHTTP_ERROR_BASE + 12)


#define ERROR_WINHTTP_LOGIN_FAILURE            (WINHTTP_ERROR_BASE + 15)
#define ERROR_WINHTTP_OPERATION_CANCELLED      (WINHTTP_ERROR_BASE + 17)
#define ERROR_WINHTTP_INCORRECT_HANDLE_TYPE    (WINHTTP_ERROR_BASE + 18)
#define ERROR_WINHTTP_INCORRECT_HANDLE_STATE   (WINHTTP_ERROR_BASE + 19)
#define ERROR_WINHTTP_CANNOT_CONNECT           (WINHTTP_ERROR_BASE + 29)
#define ERROR_WINHTTP_CONNECTION_ERROR         (WINHTTP_ERROR_BASE + 30)
#define ERROR_WINHTTP_RESEND_REQUEST           (WINHTTP_ERROR_BASE + 32)

#define ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED  (WINHTTP_ERROR_BASE + 44)

//
// WinHttpRequest Component errors
//
#define ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN	(WINHTTP_ERROR_BASE + 100)
#define ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND	(WINHTTP_ERROR_BASE + 101)
#define ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND	(WINHTTP_ERROR_BASE + 102)
#define ERROR_WINHTTP_CANNOT_CALL_AFTER_OPEN	(WINHTTP_ERROR_BASE + 103)


//
// HTTP API errors
//

#define ERROR_WINHTTP_HEADER_NOT_FOUND             (WINHTTP_ERROR_BASE + 150)
#define ERROR_WINHTTP_INVALID_SERVER_RESPONSE      (WINHTTP_ERROR_BASE + 152)
#define ERROR_WINHTTP_INVALID_QUERY_REQUEST        (WINHTTP_ERROR_BASE + 154)
#define ERROR_WINHTTP_HEADER_ALREADY_EXISTS        (WINHTTP_ERROR_BASE + 155)
#define ERROR_WINHTTP_REDIRECT_FAILED              (WINHTTP_ERROR_BASE + 156)



//
// additional WinHttp API error codes
//

//
// additional WinHttp API error codes
//
#define ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR  (WINHTTP_ERROR_BASE + 178)
#define ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT     (WINHTTP_ERROR_BASE + 166)
#define ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT (WINHTTP_ERROR_BASE + 167)

#define ERROR_WINHTTP_NOT_INITIALIZED          (WINHTTP_ERROR_BASE + 172)
#define ERROR_WINHTTP_SECURE_FAILURE           (WINHTTP_ERROR_BASE + 175)


//
// Certificate security errors. These are raised only by the WinHttpRequest
// component. The WinHTTP Win32 API will return ERROR_WINHTTP_SECURE_FAILE and
// provide additional information via the WINHTTP_CALLBACK_STATUS_SECURE_FAILURE
// callback notification.
//
#define ERROR_WINHTTP_SECURE_CERT_DATE_INVALID    (WINHTTP_ERROR_BASE + 37)
#define ERROR_WINHTTP_SECURE_CERT_CN_INVALID      (WINHTTP_ERROR_BASE + 38)
#define ERROR_WINHTTP_SECURE_INVALID_CA           (WINHTTP_ERROR_BASE + 45)
#define ERROR_WINHTTP_SECURE_CERT_REV_FAILED      (WINHTTP_ERROR_BASE + 57)
#define ERROR_WINHTTP_SECURE_CHANNEL_ERROR        (WINHTTP_ERROR_BASE + 157)
#define ERROR_WINHTTP_SECURE_INVALID_CERT         (WINHTTP_ERROR_BASE + 169)
#define ERROR_WINHTTP_SECURE_CERT_REVOKED         (WINHTTP_ERROR_BASE + 170)
#define ERROR_WINHTTP_SECURE_CERT_WRONG_USAGE     (WINHTTP_ERROR_BASE + 179)


#define ERROR_WINHTTP_AUTODETECTION_FAILED                  (WINHTTP_ERROR_BASE + 180)
#define ERROR_WINHTTP_HEADER_COUNT_EXCEEDED                 (WINHTTP_ERROR_BASE + 181)
#define ERROR_WINHTTP_HEADER_SIZE_OVERFLOW                  (WINHTTP_ERROR_BASE + 182)
#define ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW (WINHTTP_ERROR_BASE + 183)
#define ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW               (WINHTTP_ERROR_BASE + 184)

#define WINHTTP_ERROR_LAST                                  (WINHTTP_ERROR_BASE + 184)


//#endif // !defined(_WINERROR_)



#if defined(__cplusplus)
}
#endif


/*
 * Return packing to whatever it was before we
 * entered this file
 */
#include <poppack.h>


#endif // !defined(_WINHTTPX_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\wmrmsdk\WMRM10.1\include\wmrmobjs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0365 */
/* Compiler settings for wmrmobjs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmrmobjs_h__
#define __wmrmobjs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMRMProtect_FWD_DEFINED__
#define __IWMRMProtect_FWD_DEFINED__
typedef interface IWMRMProtect IWMRMProtect;
#endif 	/* __IWMRMProtect_FWD_DEFINED__ */


#ifndef __IWMRMHeader_FWD_DEFINED__
#define __IWMRMHeader_FWD_DEFINED__
typedef interface IWMRMHeader IWMRMHeader;
#endif 	/* __IWMRMHeader_FWD_DEFINED__ */


#ifndef __IWMRMHeader2_FWD_DEFINED__
#define __IWMRMHeader2_FWD_DEFINED__
typedef interface IWMRMHeader2 IWMRMHeader2;
#endif 	/* __IWMRMHeader2_FWD_DEFINED__ */


#ifndef __IWMRMCoding_FWD_DEFINED