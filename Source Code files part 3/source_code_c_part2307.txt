n type for
// the current platform.
//

#ifndef __cplusplus
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_IA64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT     __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

// end_winnt

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif

#if (_MSC_VER >= 1200) && defined(_M_IX86)
#define FORCEINLINE static __forceinline
#else
#define FORCEINLINE __inline
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR PCTSTR, LPCTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;


#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ntos.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntos.h

Abstract:

    Top level include file for the NTOS component.

Author:

    Steve Wood (stevewo) 28-Feb-1989


Revision History:

--*/

#ifndef _NTOS_
#define _NTOS_

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>

/* disable undesirable warnings at warning level 4 */
#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057 4127)

#include "ntosdef.h"
#include "exboosts.h"
#include "bugcodes.h"
#include "init.h"

#ifdef _X86_
#include "i386.h"
#endif

#include "ke.h"
#include "kd.h"
#include "ex.h"
#include "ps.h"
#include "io.h"
#include "ob.h"
#include "mm.h"
#include "fscache.h"
#include "xpcicfg.h"
#include "hal.h"

#define _NTDDK_

//
// Temp. Until we define a header file for types
// Outside of the kernel these are exported by reference
//

#if !defined(_NTSYSTEM_)
extern POBJECT_TYPE ExEventObjectType;
extern POBJECT_TYPE ExMutantObjectType;
extern POBJECT_TYPE ExSemaphoreObjectType;
extern POBJECT_TYPE ExTimerObjectType;
extern POBJECT_TYPE PsProcessObjectType;
extern POBJECT_TYPE PsThreadObjectType;
extern POBJECT_TYPE IoCompletionObjectType;
extern POBJECT_TYPE IoDeviceObjectType;
extern POBJECT_TYPE IoFileObjectType;
extern POBJECT_TYPE ObDirectoryObjectType;
extern POBJECT_TYPE ObSymbolicLinkObjectType;
#else
extern OBJECT_TYPE ExEventObjectType;
extern OBJECT_TYPE ExMutantObjectType;
extern OBJECT_TYPE ExSemaphoreObjectType;
extern OBJECT_TYPE ExTimerObjectType;
extern OBJECT_TYPE PsProcessObjectType;
extern OBJECT_TYPE PsThreadObjectType;
extern OBJECT_TYPE IoCompletionObjectType;
extern OBJECT_TYPE IoDeviceObjectType;
extern OBJECT_TYPE IoFileObjectType;
extern OBJECT_TYPE ObDirectoryObjectType;
extern OBJECT_TYPE ObSymbolicLinkObjectType;
#endif

#ifdef __cplusplus
}
#endif

#endif // _NTOS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\pci.h ===
/*++

Module Name:

    pci.h

Abstract:

    This is the PCI bus specific header file used by device drivers.

Author:

Revision History:

--*/

#ifndef _PCI_
#define _PCI_

// begin_ntddk

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_ntminiport

// end_ntddk end_wdm

//
// PCI definitions for IOBase & IOLimit
// PCIBridgeIO2Base(a,b)  - convert IOBase  & IOBaseUpper16 to ULONG IOBase
// PCIBridgeIO2Limit(a,b) - convert IOLimit & IOLimitUpper6 to ULONG IOLimit
//

#define PciBridgeIO2Base(a,b)   \
        ( ((a >> 4) << 12) + (((a & 0xf) == 1) ? (b << 16) : 0) )

#define PciBridgeIO2Limit(a,b)  (PciBridgeIO2Base(a,b) | 0xfff)

#define PciBridgeMemory2Base(a)  (ULONG) ((a & 0xfff0) << 16)
#define PciBridgeMemory2Limit(a) (PciBridgeMemory2Base(a) | 0xfffff)

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1/2.BridgeControl
//

#define PCI_ENABLE_BRIDGE_PARITY_ERROR        0x0001
#define PCI_ENABLE_BRIDGE_SERR                0x0002
#define PCI_ENABLE_BRIDGE_ISA                 0x0004
#define PCI_ENABLE_BRIDGE_VGA                 0x0008
#define PCI_ENABLE_BRIDGE_MASTER_ABORT_SERR   0x0020
#define PCI_ASSERT_BRIDGE_RESET               0x0040

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1.BridgeControl
//

#define PCI_ENABLE_BRIDGE_FAST_BACK_TO_BACK   0x0080

//
// Bit encodes for PCI_COMMON_CONFIG.u.type2.BridgeControl
//

#define PCI_ENABLE_CARDBUS_IRQ_ROUTING        0x0080
#define PCI_ENABLE_CARDBUS_MEM0_PREFETCH      0x0100
#define PCI_ENABLE_CARDBUS_MEM1_PREFETCH      0x0200
#define PCI_ENABLE_CARDBUS_WRITE_POSTING      0x0400

//
//  Definitions needed for Access to Hardware Type 1
//

#define PCI_TYPE1_ADDR_PORT     ((PULONG) 0xCF8)
#define PCI_TYPE1_DATA_PORT     0xCFC

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


//
//  Definitions needed for Access to Hardware Type 2
//

#define PCI_TYPE2_CSE_PORT              ((PUCHAR) 0xCF8)
#define PCI_TYPE2_FORWARD_PORT          ((PUCHAR) 0xCFA)
#define PCI_TYPE2_ADDRESS_BASE          0xC


typedef struct _PCI_TYPE2_CSE_BITS {
    union {
        struct {
            UCHAR   Enable:1;
            UCHAR   FunctionNumber:3;
            UCHAR   Key:4;
        } bits;
        UCHAR   AsUCHAR;
    } u;
} PCI_TYPE2_CSE_BITS, PPCI_TYPE2_CSE_BITS;


typedef struct _PCI_TYPE2_ADDRESS_BITS {
    union {
        struct {
            USHORT  RegisterNumber:8;
            USHORT  Agent:4;
            USHORT  AddressBase:4;
        } bits;
        USHORT  AsUSHORT;
    } u;
} PCI_TYPE2_ADDRESS_BITS, *PPCI_TYPE2_ADDRESS_BITS;


//
// Definitions for the config cycle format on the PCI bus.
//

typedef struct _PCI_TYPE0_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   Reserved2:21;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE0_CFG_CYCLE_BITS, *PPCI_TYPE0_CFG_CYCLE_BITS;

typedef struct _PCI_TYPE1_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:8;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_CYCLE_BITS, *PPCI_TYPE1_CFG_CYCLE_BITS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\mm.h ===
/*-- BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mm.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the memory management system.

Author:

    Lou Perazzoli (loup) 20-Mar-1989

Revision History:

--*/

#ifndef _MM_
#define _MM_

//
// The allocation granularity is 64k.
//

#define MM_ALLOCATION_GRANULARITY ((ULONG)0x10000)

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//++
//
// ULONG_PTR
// ROUND_TO_PAGES(
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES(
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// ULONG
// BYTE_OFFSET_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the large page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET_LARGE(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE_LARGE - 1)))

//++
//
// PVOID
// PAGE_ALIGN(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN_LARGE(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE_LARGE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES(
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
   (((((Size) - 1) >> PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(PAGE_SIZE-1)) + (PtrToUlong(Va) & (PAGE_SIZE -1)))) >> PAGE_SHIFT)) + 1L)

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))

// end_ntddk end_wdm end_nthal end_ntifs

//++
//
// BOOLEAN
// IS_SYSTEM_ADDRESS
//     IN PVOID Va,
//     )
//
// Routine Description:
//
//     This macro takes a virtual address and returns TRUE if the virtual address
//     is within system space, FALSE otherwise.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns TRUE is the address is in system space.
//
//--

#define IS_SYSTEM_ADDRESS(VA) ((VA) >= MM_SYSTEM_RANGE_START)

//
// Number of physical pages.
//

extern PFN_COUNT MmNumberOfPhysicalPages;

//
// Page frame number of the lowest physically addressable RAM page.
//

extern PFN_NUMBER MmLowestPhysicalPage;

//
// Page frame number of the highest physically addressable RAM page.
//

extern PFN_NUMBER MmHighestPhysicalPage;

//
// Memory management initialization routine.
//

VOID
MmInitSystem(
    VOID
    );

VOID
MmDiscardInitSection(
    VOID
    );

VOID
MmRelocatePersistentMemory(
    VOID
    );

VOID
MmPrepareToQuickRebootSystem(
    VOID
    );

#ifdef DEVKIT

VOID
MmReleaseDeveloperKitMemory(
    VOID
    );

#endif

//
// Shutdown routine - flushes dirty pages, etc for system shutdown.
//

BOOLEAN
MmShutdownSystem(
    VOID
    );

//
// Pool support routines to allocate complete pages, not for
// general consumption, these are only used by the executive pool allocator.
//

PVOID
MmAllocatePoolPages(
    IN SIZE_T NumberOfBytes
    );

ULONG
MmFreePoolPages(
    IN PVOID StartingAddress
    );

//
// First level fault routine.
//

NTSTATUS
MmAccessFault(
    IN BOOLEAN StoreInstruction,
    IN PVOID VirtualAddress,
    IN PVOID TrapInformation
    );

//
// Process Support Routines.
//

NTKERNELAPI
PVOID
MmCreateKernelStack(
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN DebuggerThread
    );

NTKERNELAPI
VOID
MmDeleteKernelStack(
    IN PVOID KernelStackBase,
    IN PVOID KernelStackLimit
    );

//
// Debugger support routines.
//

#define MmDbgReadCheck(VirtualAddress) (MmIsAddressValid(VirtualAddress) ? VirtualAddress : NULL)

NTKERNELAPI
PVOID
MmDbgWriteCheck(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    );

NTKERNELAPI
VOID
MmDbgReleaseAddress(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    );

NTKERNELAPI
PVOID64
MmDbgTranslatePhysicalAddress64(
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

NTKERNELAPI
PVOID
MmDbgAllocateMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
ULONG
MmDbgFreeMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PFN_COUNT
MmDbgQueryAvailablePages(
    VOID
    );

VOID
MmDbgAllocateDebugMonitorBase(
    PFN_COUNT NumberOfPages
    );

// begin_ntddk begin_ntifs begin_nthal

NTKERNELAPI
VOID
MmLockUnlockBufferPages(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN UnlockPages
    );

NTKERNELAPI
VOID
MmLockUnlockPhysicalPage(
    IN ULONG_PTR PhysicalAddress,
    IN BOOLEAN UnlockPage
    );

// begin_wdm

NTKERNELAPI
PVOID
MmMapIoSpace(
    IN ULONG_PTR PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

// end_wdm end_ntddk end_ntifs

NTSTATUS
MmLockSelectedIoPages(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OUT PIRP Irp,
    IN BOOLEAN MapUserBuffer
    );

VOID
MmUnlockSelectedIoPages(
    IN PIRP Irp
    );

// begin_ntddk begin_ntifs

NTKERNELAPI
ULONG_PTR
MmGetPhysicalAddress(
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemoryEx(
    IN SIZE_T NumberOfBytes,
    IN ULONG_PTR LowestAcceptableAddress,
    IN ULONG_PTR HighestAcceptableAddress,
    IN ULONG_PTR Alignment,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory(
    IN PVOID BaseAddress
    );

NTKERNELAPI
VOID
MmPersistContiguousMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN Persist
    );

NTKERNELAPI
PVOID
MmAllocateSystemMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
ULONG
MmFreeSystemMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
SIZE_T
MmQueryAllocationSize(
    IN PVOID BaseAddress
    );

NTKERNELAPI
ULONG
MmQueryAddressProtect(
    IN PVOID VirtualAddress
    );

NTKERNELAPI
VOID
MmSetAddressProtect(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid(
    IN PVOID VirtualAddress
    );

// end_ntddk end_nthal end_ntifs

//
// Memory manager statistics.
//

typedef struct _MM_STATISTICS {
    ULONG Length;
    ULONG TotalPhysicalPages;
    ULONG AvailablePages;
    ULONG VirtualMemoryBytesCommitted;
    ULONG VirtualMemoryBytesReserved;
    ULONG CachePagesCommitted;
    ULONG PoolPagesCommitted;
    ULONG StackPagesCommitted;
    ULONG ImagePagesCommitted;
} MM_STATISTICS, *PMM_STATISTICS;

NTKERNELAPI
NTSTATUS
MmQueryStatistics(
    IN OUT PMM_STATISTICS MemoryStatistics
    );

NTKERNELAPI
PVOID
MmClaimGpuInstanceMemory(
    IN SIZE_T NumberOfBytes,
    OUT SIZE_T *NumberOfPaddingBytes
    );

#endif  // MM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\phy.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    phy.h

Abstract:

    Interface to Ethernet transceiver code inside the ROM

Revision History:

    04/05/2001 davidx
        Created it.

--*/

#ifndef _PHY_H_
#define _PHY_H_

//
// Initialize the PHY
//
NTKERNELAPI
NTSTATUS
PhyInitialize(
    BOOL forceReset,
    VOID* param OPTIONAL
    );

//
// Get the current link state
//
NTKERNELAPI
DWORD
PhyGetLinkState(
    BOOL update
    );

#define BIT(n)                  (1u << (n))

//
// MII/PHY related declarations
//
#define MIIREG_CONTROL 0
#define MIIREG_STATUS  1
#define MIIREG_ANAR    4
#define MIIREG_LPANAR  5

#define MIICONTROL_RESET                        BIT(15)
#define MIICONTROL_LOOPBACK_ENABLED             BIT(14)
#define MIICONTROL_SPEED_SELECTION_BIT1         BIT(13)
#define MIICONTROL_ENABLE_AUTO_NEGOTIATION      BIT(12)
#define MIICONTROL_POWER_DOWN                   BIT(11)
#define MIICONTROL_ELECTRICALLY_ISOLATE_PHY     BIT(10)
#define MIICONTROL_RESTART_AUTO_NEGOTIATION     BIT(9)
#define MIICONTROL_FULL_DUPLEX_MODE             BIT(8)
#define MIICONTROL_ENABLE_COLLISION_SIGNAL_TEST BIT(7)
#define MIICONTROL_SPEED_SELECTION_BIT0         BIT(6)

#define MIISTATUS_100MBS_T4_CAPABLE             BIT(15)
#define MIISTATUS_100MBS_X_FULL_DUPLEX_CAPABLE  BIT(14)
#define MIISTATUS_100MBS_X_HALF_DUPLEX_CAPABLE  BIT(13)
#define MIISTATUS_10MBS_FULL_DUPLEX_CAPABLE     BIT(12)
#define MIISTATUS_10MBS_HALF_DUPLEX_CAPABLE     BIT(11)
#define MIISTATUS_100MBS_T2_FULL_DUPLEX_CAPABLE BIT(10)
#define MIISTATUS_100MBS_T2_HALF_DUPLEX_CAPABLE BIT(9)
#define MIISTATUS_EXTENDED_STATUS_AVAILABLE     BIT(8)
#define MIISTATUS_PREAMBLE_SUPPRESSED_FRAME_OK  BIT(6)
#define MIISTATUS_AUTO_NEGOTIATION_COMPLETE     BIT(5)
#define MIISTATUS_REMOTE_FAULT_DETECTED         BIT(4)
#define MIISTATUS_AUTO_NEGOTIATION_CAPABLE      BIT(3)
#define MIISTATUS_LINK_IS_UP                    BIT(2)
#define MIISTATUS_JABBER_DETECTED               BIT(1)
#define MIISTATUS_EXTENDED_CAPABILITIES_PRESENT BIT(0)

#define MII4_MULTIPLE_PAGES                     BIT(15)
#define MII4_REMOTE_FAULT                       BIT(13)
#define MII4_ASYMETRIC_PAUSE                    BIT(11)
#define MII4_PAUSE                              BIT(10)
#define MII4_100BASE_T4                         BIT(9)
#define MII4_100BASE_T_FULL_DUPLEX              BIT(8)
#define MII4_100BASE_T_HALF_DUPLEX              BIT(7)
#define MII4_10BASE_T_FULL_DUPLEX               BIT(6)
#define MII4_10BASE_T_HALF_DUPLEX               BIT(5)

#define XNET_ETHERNET_LINK_ACTIVE               0x01    // Ethernet cable is connected and active
#define XNET_ETHERNET_LINK_100MBPS              0x02    // Ethernet link is set to 100 Mbps
#define XNET_ETHERNET_LINK_10MBPS               0x04    // Ethernet link is set to 10 Mbps
#define XNET_ETHERNET_LINK_FULL_DUPLEX          0x08    // Ethernet link is in full duplex mode
#define XNET_ETHERNET_LINK_HALF_DUPLEX          0x10    // Ethernet link is in half duplex mode

typedef struct                              // base address 0xFEF00000
{
    DWORD intr;                             // 000
        // Interrupt register
        //  bit 7: reserved
        //  bit 6 (MINT): MII interrupt
        //  bit 5 (STINT): software timer interrupt
        //  bit 4 (TCINT): transmit complete w/o error interrupt
        //  bit 3 (TEINT): transmit complete with error interrupt
        //  bit 2 (MISS): missed a frame
        //  bit 1 (RCINT): receive complete w/o error interrupt
        //  bit 0 (REINT): receive complete with error interrupt

    #define INTR_MINT   BIT(6)
    #define INTR_STINT  BIT(5)
    #define INTR_TCINT  BIT(4)
    #define INTR_TEINT  BIT(3)
    #define INTR_MISS   BIT(2)
    #define INTR_RCINT  BIT(1)
    #define INTR_REINT  BIT(0)

    #define INTR_ALL    (INTR_MINT | \
                         INTR_TCINT | \
                         INTR_TEINT | \
                         INTR_MISS | \
                         INTR_RCINT | \
                         INTR_REINT)
    
    DWORD intr_mk;                          // 004
        // Master interrupt mask
        //  bit 7: reserved
        //  bit 6: MINT mask - 1 = enable and 0 = disable
        //  bit 5: STINT mask
        //  bit 4: TCINT mask
        //  bit 3: TEINT mask
        //  bit 2: MISS mask
        //  bit 1: RCINT mask
        //  bit 0: REINT mask

    DWORD swtr_cntl;                        // 008
        // Software timer control register
        //  bit 1 (STEN): software timer enable
        //  bit 0 (STREN): software timer reload enable

    DWORD swtr_itc;                         // 00c
        // Software timer register
        //  bit 31-16: current software timer count
        //  bit 15-0: software timer interval

    BYTE gap1[0x80 - 0x10];

    DWORD tx_cntl;                          // 080
        // Transmit control register
        //  bit 31-22: reserved
        //  bit 21 (UFLOM): underflow error mask
        //  bit 20 (TCOLM): transmit late collision mask
        //  bit 19 (LCARM): loss of carrier mask
        //  bit 18 (DEFM): deferred mask
        //  bit 17 (EXDEFM): excessive deferral mask
        //  bit 16 (RTRYM): retry error mask
        //  bit 15-12: reserved
        //  bit 11-8: maximum number of retries on collisions
        //  bit 7-6: MAC-PHY interface
        //  bit 5 (TDEFEN): two-part deferral enable
        //  bit 4 (FCSEN): FCS append enable
        //  bit 3 (PADEN): pad enable
        //  bit 2 (RTRYEN): retry enable
        //  bit 1 (HDEN): half-duplex enable
        //  bit 0: reserved
    
    #define TXCNTL_UFLOM    BIT(21)
    #define TXCNTL_TCOLM    BIT(20)
    #define TXCNTL_LCARM    BIT(19)
    #define TXCNTL_DEFM     BIT(18)
    #define TXCNTL_EXDEFM   BIT(17)
    #define TXCNTL_RTRYM    BIT(16)
    #define TXCNTL_RCSHIFT  8
    #define TXCNTL_PHYSHIFT 6
    #define TXCNTL_TDEFEN   BIT(5)
    #define TXCNTL_FCSEN    BIT(4)
    #define TXCNTL_PADEN    BIT(3)
    #define TXCNTL_RTRYEN   BIT(2)
    #define TXCNTL_HDEN     BIT(1)

    #define PHY_TYPE_MII    0
    #define TXCNTL_DEFAULT  (TXCNTL_UFLOM | \
                             TXCNTL_TCOLM | \
                             TXCNTL_LCARM | \
                             TXCNTL_EXDEFM | \
                             TXCNTL_RTRYM | \
                             TXCNTL_TDEFEN | \
                             TXCNTL_FCSEN | \
                             TXCNTL_PADEN | \
                             TXCNTL_RTRYEN | \
                             TXCNTL_HDEN | \
                             (PHY_TYPE_MII << TXCNTL_PHYSHIFT) | \
                             (15 << TXCNTL_RCSHIFT))

    DWORD tx_en;                            // 084
        // Transmit enable register
        //  bit 1: transmit enable

    #define TXEN_ENABLE     BIT(0)

    DWORD tx_sta;                           // 088
        // Transmit status register
        //  bit 31-22: reserved
        //  bit 21 (UFLO): underflow error
        //  bit 20 (TCOL): transmit late collision
        //  bit 19 (LCAR): loss of carrier
        //  bit 18 (DEF): deferred
        //  bit 17 (EXDEF): excessive deferral
        //  bit 16 (RTRY): retry error
        //  bit 15-1: reserved
        //  bit 0: transmit channel idle status
    
    #define TXSTA_UFLO      BIT(21)
    #define TXSTA_TCOL      BIT(20)
    #define TXSTA_LCAR      BIT(19)
    #define TXSTA_DEF       BIT(18)
    #define TXSTA_EXDEF     BIT(17)
    #define TXSTA_RTRY      BIT(16)
    #define TXSTA_BUSY      BIT(0)

    DWORD rx_cntl_0;                        // 08c
        // Receive control
        //  bit 31-23: reserved
        //  bit 22 (FRAMM): frame alignment error mask
        //  bit 21 (OFOLM): overflow error mask
        //  bit 20 (CRCM): FCS error mask
        //  bit 19 (LFERM): length error mask
        //  bit 18 (MAXM): maximum length error mask
        //  bit 17 (RLCOLM): receive late collision mask
        //  bit 16 (RUNTM): runt receive mask
        //  bit 15-9: reserved
        //  bit 8 (RDEFEN): receive deferral enable
        //  bit 7 (BRDIS): broadcast receive disable
        //  bit 6 (RUNTEN): runt packet receive enable
        //  bit 5 (AFEN): address filtering enable
        //  bit 4 (LBEN): loopback enable
        //  bit 3 (PAEN): pause enable
        //  bit 2 (FCSREN): FCS relay enable
        //  bit 1 (PADSEN): pad strip enable
        //  bit 0: reserved

    #define RXCNTL_FRAMM    BIT(22)
    #define RXCNTL_OFLOM    BIT(21)
    #define RXCNTL_CRCM     BIT(20)
    #define RXCNTL_LFERM    BIT(19)
    #define RXCNTL_MAXM     BIT(18)
    #define RXCNTL_RLCOLM   BIT(17)
    #define RXCNTL_RUNTM    BIT(16)
    #define RXCNTL_RDEFEN   BIT(8)
    #define RXCNTL_BRDIS    BIT(7)
    #define RXCNTL_RUNTEN   BIT(6)
    #define RXCNTL_AFEN     BIT(5)
    #define RXCNTL_LBEN     BIT(4)
    #define RXCNTL_PAEN     BIT(3)
    #define RXCNTL_FCSREN   BIT(2)
    #define RXCNTL_PADSEN   BIT(1)

    #define RXCNTL_DEFAULT  (RXCNTL_FRAMM | \
                             RXCNTL_OFLOM | \
                             RXCNTL_CRCM | \
                             RXCNTL_LFERM | \
                             RXCNTL_MAXM | \
                             RXCNTL_RLCOLM | \
                             RXCNTL_RUNTM | \
                             RXCNTL_AFEN)

    DWORD rx_cntl_1;                        // 090
        // Maximum receive frame size register

    DWORD rx_en;                            // 094
        // Receive enable register
        //  bit 1: receive enable

    #define RXEN_ENABLE     BIT(0)

    DWORD rx_sta;                           // 098
        // Receive status register
        //  bit 31-23: reserved
        //  bit 22 (FRAM): frame alignment error
        //  bit 21 (OFOL): overflow error
        //  bit 20 (CRC): FCS error
        //  bit 19 (LFER): length error
        //  bit 18 (MAX): maximum length error
        //  bit 17 (RLCOL): receive late collision
        //  bit 16 (RUNT): runt receive
        //  bit 15-1: reserved
        //  bit 0: receive channel idle status
    
    #define RXSTA_FRAM      BIT(22)
    #define RXSTA_OFLO      BIT(21)
    #define RXSTA_CRC       BIT(20)
    #define RXSTA_LFER      BIT(19)
    #define RXSTA_MAX       BIT(18)
    #define RXSTA_RLCOL     BIT(17)
    #define RXSTA_RUNT      BIT(16)
    #define RXSTA_BUSY      BIT(0)

    DWORD bkoff_cntl;                       // 09c
        // Backoff control register (for HomePNA)
        //  bit 31-16: reserved
        //  bit 15-8: slot time, 127 for IEEE 802.3
        //  bit 7-0: random seed

    #define BKOFFCNTL_RSSHIFT   0
    #define BKOFFCNTL_STSHIFT   8

    #define BKOFFCNTL_DEFAULT   ((8 << BKOFFCNTL_RSSHIFT) | \
                                 (127 << BKOFFCNTL_STSHIFT))

    DWORD tx_def;                           // 0a0
        // Transmit deferral timing register
        //  bit 31-24: reserved
        //  bit 23-16 (TIFG): number of clocks for inter-frame gap
        //      when two-part deferral is disabled
        //  bit 15-8 (TIFG2): number of clocks for the second part
        //      inter-frame gap for two-part deferral
        //  bit 7-0 (TIFG1): number of clocks for the first part
        //      inter-frame gap for two-part deferral

    #define TXDEF_GSHIFT    16
    #define TXDEF_G2SHIFT   8
    #define TXDEF_G1SHIFT   0

    // Default values for IEEE 802.3
    #define TXDEF_DEFAULT   ((15 << TXDEF_G1SHIFT) | \
                             (7 << TXDEF_G2SHIFT) | \
                             (22 << TXDEF_GSHIFT))

    DWORD rx_def;                           // 0a4
        // Receive deferral register
        //  bit 7-0 (RIFG): number of clocks for inter-frame gap
        //      when receive deferral is enabled

    #define RXDEF_DEFAULT   0x16

    DWORD uni0;                             // 0a8
        // Lower 32-bits of the unicast address

    DWORD uni1;                             // 0ac
        // Higher 16-bits of the unicast address

    DWORD mult0;                            // 0b0
        // Lower 32-bits of the multicast address

    DWORD mult1;                            // 0b4
        // Higher 16-bits of the multicast address

    DWORD mult_mk0;                         // 0b8
        // Lower 32-bits of the multicast address mask

    DWORD mult_mk1;                         // 0bc
        // Higher 16-bits of the multicast address mask

    BYTE gap2[0x100 - 0xc0];

    DWORD tx_dadr;                          // 100
        // Transmit descriptor ring physical address

    DWORD rx_dadr;                          // 104
        // Receive descriptor ring physical address

    DWORD dlen;                             // 108
        // Descriptor ring length register
        //  bit 31-26: reserved
        //  bit 25-16 (RDLEN): receive descriptor block length (-1)
        //  bit 15-10: reserved
        //  bit 9-0 (TDLEN): transmit descriptor block length (-1)

    DWORD tx_poll;                          // 10c
        // Transmit descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (TPEN): transmit poll enable
        //  bit 15-0: transmit poll interval

    DWORD rx_poll;                          // 110
        // Receive descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (RPEN): receive poll enable
        //  bit 15-0: receive poll interval
        //      this is measured in 66MHz / 15ns clock cycles

    #define RXPOLL_EN           BIT(16)
    #define RXPOLL_FREQ_100MPS  100
    #define RXPOLL_FREQ_10MPS   1000

    DWORD tx_pcnt;                          // 114
        // Current transmit poll count

    DWORD rx_pcnt;                          // 118
        // Current receive poll count

    DWORD tx_cur_dadr;                      // 11c
        // Current transmit descriptor physical address

    DWORD rx_cur_dadr;                      // 120
        // Current receive descriptor physical address

    DWORD tx_cur_prd0;                      // 124
        // Current transmit physical address

    DWORD tx_cur_prd1;                      // 128
        // bit 31-16: current status of actively transmited frame
        // bit 15-0: current number of bytes remaining

    DWORD rx_cur_prd0;                      // 12c
        // Current receive physical address

    DWORD rx_cur_prd1;                      // 130
        // bit 31-16: current status of actively received frame
        // bit 15-0: current number of bytes remaining

    DWORD tx_nxt_dadr;                      // 134
        // Next transmit descriptor physical address

    DWORD rx_nxt_dadr;                      // 138
        // Next receive descriptor physical address

    DWORD tx_fifo_wm;                       // 13c
        // Transmit FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define TXFIFOWM_HWSHIFT    16
    #define TXFIFOWM_LWSHIFT    0

    #define TXFIFOWM_DEFAULT    ((0x10 << TXFIFOWM_LWSHIFT) | \
                                 (0x30 << TXFIFOWM_HWSHIFT))

    DWORD rx_fifo_wm;                       // 140
        // Receive FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define RXFIFOWM_HWSHIFT    16
    #define RXFIFOWM_LWSHIFT    0

    #define RXFIFOWM_DEFAULT    ((0x10 << RXFIFOWM_LWSHIFT) | \
                                 (0x30 << RXFIFOWM_HWSHIFT))
    DWORD mode;                             // 144
        // Mode register
        //  bit 4: buffer management reset
        //      need to be set for >= 3.2us before it's cleared
        //  bit 3: there is no active DMA transfer in progress
        //  bit 2: disable DMA transfer
        //  bit 1 (RXDM): receive demand
        //  bit 0 (TXDM): transmit demand

    #define MODE_RESET_BUFFERS  BIT(4)
    #define MODE_DMA_IDLE       BIT(3)
    #define MODE_DISABLE_DMA    BIT(2)
    #define MODE_RXDM           BIT(1)
    #define MODE_TXDM           BIT(0)

    BYTE gap3[0x180 - 0x148];

    DWORD mintr;                            // 180
        // MII interrupt register
        //  bit 7-5: reserved
        //  bit 4 (MPDI): MII PHY detect interrupt
        //  bit 3 (MAPI): MII auto-polling interrupt
        //  bit 2 (MCCI): MII command complete interrupt
        //  bit 1 (MCCII): MII command complete internal interrupt
        //  bit 0 (MREI): MII read error interrupt
    
    #define MINTR_MPDI  BIT(4)
    #define MINTR_MAPI  BIT(3)
    #define MINTR_MCCI  BIT(2)
    #define MINTR_MCCII BIT(1)
    #define MINTR_MREI  BIT(0)

    DWORD mintr_mk;                         // 184
        // MII interrupt mask register
        //  bit 7-5: reserved
        //  bit 4: MPDI mask - 1 to enable and 0 to disable
        //  bit 3: MAPI mask
        //  bit 2: MCCI mask
        //  bit 1: MCCII mask
        //  bit 0: MREI mask

    DWORD mii_cs;                           // 188
        // MII control and status register
        //  bit 31-29: reserved
        //  bit 28-24: PHY address
        //  bit 23-21: reserved
        //  bit 20 (APEN): auto-polling enable
        //  bit 19-16 (APTI): auto-polling time interval
        //  bit 15 (T4): 100BASE-T4
        //  bit 14 (XFD): 100BASE-X full duplex
        //  bit 13 (XHD): 100BASE-X half duplex
        //  bit 12 (10FD): 10Mb/s full-duplex
        //  bit 11 (10HD): 10Mb/s half-duplex
        //  bit 10 (ET2FD): 100BASE-T2 full-duplex
        //  bit 9 (T2HD): 100BASE-T2 half-duplex
        //  bit 8 (EXST): extended status
        //  bit 7: reserved
        //  bit 6 (MFPS): MF preamble suppression
        //  bit 5 (ANC): auto negotiation complete
        //  bit 4 (RF): remote fault
        //  bit 3 (ANA): auto-negotiation ability
        //  bit 2 (LS): link status
        //  bit 1 (JD): Jabber detect
        //  bit 0 (EC): extended capability
    
    #define MIICS_PADRSHIFT 24
    #define MIICS_APEN      BIT(20)
    #define MIICS_APSHIFT   16
    #define MIICS_T4        BIT(15)
    #define MIICS_XFD       BIT(14)
    #define MIICS_XHD       BIT(13)
    #define MIICS_10FD      BIT(12)
    #define MIICS_10HD      BIT(11)
    #define MIICS_ET2FD     BIT(10)
    #define MIICS_T2HD      BIT(9)
    #define MIICS_EXST      BIT(8)
    #define MIICS_MFPS      BIT(6)
    #define MIICS_ANC       BIT(5)
    #define MIICS_RF        BIT(4)
    #define MIICS_ANA       BIT(3)
    #define MIICS_LS        BIT(2)
    #define MIICS_JD        BIT(1)
    #define MIICS_EC        BIT(0)

    #define PHY_ADDR        1
    #define MIICS_DEFAULT   ((PHY_ADDR << MIICS_PADRSHIFT) | \
                             (4 << MIICS_APSHIFT) | \
                             MIICS_APEN)

    DWORD mii_tm;                           // 18c
        // MII clock timer register
        //  bit 15: MII timer status
        //  bit 14-9: reserved
        //  bit 8: MII timer enable
        //  bit 7-0: MII timer interval

    #define MIITM_BUSY      BIT(15)
    #define MIITM_EN        BIT(8)
    #define MIITM_TISHIFT   0

    #define MIITM_INTERVAL  5
    #define MIITM_DEFAULT   ((MIITM_INTERVAL << MIITM_TISHIFT) | MIITM_EN)
    #define PHYRW_TIMEOUT   ((64*2*2*400*MIITM_INTERVAL/1000)*16)

    DWORD mdio_adr;                         // 190
        // MDIO address register
        //  bit 15 (MDLK): MDIO lock
        //  bit 14-11: reserved
        //  bit 10 (MDRW): MDIO read/write
        //  bit 9-5 (PHYADR): physical address of the PHY to be accessed
        //  bit 4-0 (PHYREG): register address of the PHY to be accessed

    #define MDIOADR_LOCK        BIT(15)
    #define MDIOADR_WRITE       BIT(10)
    #define MDIOADR_PHYSHIFT    5
    #define MDIOADR_REGSHIFT    0

    DWORD mdio_data;                        // 194
        // MDIO data register
        //  bit 15-0 (PHYD): data for the last PHY read/write access

    BYTE gap4[0x200 - 0x198];

    DWORD pm_cntl;                          // 200
        // Power management control register

    struct {
        DWORD crc;
        DWORD mask0;
        DWORD mask1;
        DWORD mask2;
        DWORD mask3;
    } pmc_crc[5];
        // Pattern match CRC registers

    DWORD pmc_alias;
        // PCI power management register 0 alias

    DWORD pmcsr_alias;
        // PCI power management register 1 alias
} volatile * PNICCSR;

#define PNicCsr() ((PNICCSR)XPCICFG_NIC_MEMORY_REGISTER_BASE_0)

#endif // !_PHY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\segalpc.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    segalpc.h

Abstract:

    This module defines the constants used for accessing the SEGA LPC register
    space.

--*/

#ifndef _SEGALPC_
#define _SEGALPC_

//
// Define the base address of the SEGA LPC register space.
//

#define SEGA_REGISTER_BASE                          0x4000

//
// Define the layout of the SEGA LPC register space.
//

#define SEGA_REGISTER_RUAP                          (SEGA_REGISTER_BASE + 0x00)
#define SEGA_REGISTER_RLAP                          (SEGA_REGISTER_BASE + 0x02)
#define SEGA_REGISTER_RDP                           (SEGA_REGISTER_BASE + 0x04)
#define SEGA_REGISTER_DMUAP                         (SEGA_REGISTER_BASE + 0x06)
#define SEGA_REGISTER_DMLAP                         (SEGA_REGISTER_BASE + 0x08)
#define SEGA_REGISTER_LAN_GR0                       (SEGA_REGISTER_BASE + 0x1E)
#define SEGA_REGISTER_LAN_GR1                       (SEGA_REGISTER_BASE + 0x20)
#define SEGA_REGISTER_LAN_GR2                       (SEGA_REGISTER_BASE + 0x22)
#define SEGA_REGISTER_LAN_GR3                       (SEGA_REGISTER_BASE + 0x24)
#define SEGA_REGISTER_LAN_CNT0                      (SEGA_REGISTER_BASE + 0x26)
#define SEGA_REGISTER_INTERRUPT_MASK                (SEGA_REGISTER_BASE + 0x80)
#define SEGA_REGISTER_LED                           (SEGA_REGISTER_BASE + 0x82)
#define SEGA_REGISTER_DIP_SWITCH                    (SEGA_REGISTER_BASE + 0x84)
#define SEGA_REGISTER_G1_PIO_CTRL                   (SEGA_REGISTER_BASE + 0x86)
#define SEGA_REGISTER_G1_DMA_CTRL                   (SEGA_REGISTER_BASE + 0x88)
#define SEGA_REGISTER_DMAAP_WRITE_MASK              (SEGA_REGISTER_BASE + 0x8A)
#define SEGA_REGISTER_INTERRUPT_SELECT              (SEGA_REGISTER_BASE + 0x8E)
#define SEGA_REGISTER_DIMM_RESET                    (SEGA_REGISTER_BASE + 0x90)
#define SEGA_REGISTER_CHIP_REVISION                 (SEGA_REGISTER_BASE + 0xF0)
#define SEGA_REGISTER_DIMM_SIZE                     (SEGA_REGISTER_BASE + 0xF4)

//
// Define the register masks for SEGA_REGISTER_CHIP_REVISION.
//

#define SEGA_CHIP_REVISION_CHIP_ID_MASK             0xFF00
#define SEGA_CHIP_REVISION_REVISION_ID_MASK         0x00FF

//
// Define the chip identifier codes.
//

#define SEGA_CHIP_REVISION_FPGA_CHIP_ID             0x0000
#define SEGA_CHIP_REVISION_ASIC_CHIP_ID             0x0100

//
// Define the register masks for SEGA_REGISTER_DIMM_SIZE.
//

#define SEGA_DIMM_SIZE_SIZE_MASK                    0x0003

//
// Define the memory size codes.
//

#define SEGA_DIMM_SIZE_128M                         0x0000
#define SEGA_DIMM_SIZE_256M                         0x0001
#define SEGA_DIMM_SIZE_512M                         0x0002
#define SEGA_DIMM_SIZE_1024M                        0x0003

#endif  // SEGALPC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\v86emul.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    v86emul.h

Abstract:

    This module contains the V86 instruction emulator interface definitions
    used by kernel device drivers.

Author:

    Andre Vachon (andreva) 8-Jan-1992

Revision History:


--*/

#ifndef _V86EMUL_
#define _V86EMUL_


// begin_ntminiport

//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

// end_ntminiport

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data,
    IN ULONG DataLength
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data,
    IN ULONG DataLength // number of words
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data,
    IN ULONG DataLength  // number of dwords
    );

#endif // _V86EMUL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\ps.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ps.h

Abstract:

    This module contains the process structure public data structures and
    procedure prototypes to be used within the NT system.

Author:

    Mark Lucovsky       16-Feb-1989

Revision History:

--*/

#ifndef _PS_
#define _PS_

//
// Specifies the base address of XBOXKRNL.EXE.
//

#define PsNtosImageBase ((PVOID)0x80010000)

//
// Thread Object
//
// Thread object body.  A pointer to this structure is returned when a handle
// to a thread object is referenced.  This structure contains a thread control
// block (TCB) which is the kernel's representation of a thread.
//
// If you remove a field from this structure, please also
// remove the reference to it from within the kernel debugger
// (nt\private\sdktools\ntsd\ntkext.c)
//

typedef struct _ETHREAD {
    KTHREAD Tcb;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;

    union {
        NTSTATUS ExitStatus;
        PVOID OfsChain;       // needed for the nt build of the C runtime
    };
    union {
        LIST_ENTRY ReaperListEntry;
        LIST_ENTRY ActiveTimerListHead;
    };
    HANDLE UniqueThread;
    PVOID StartAddress;

    //
    // Io
    //

    LIST_ENTRY IrpList;

#ifdef DEVKIT
    //
    // Dm
    //
    // keep this at the end so kd exts don't get confused
    //

    PVOID DebugData;
#endif
} ETHREAD, *PETHREAD;

//
// Global Variables
//

extern LIST_ENTRY PsReaperListHead;
extern KDPC PsReaperDpc;

BOOLEAN
PsInitSystem (
    VOID
    );

//
// Get Gurrent Prototypes
//

#define THREAD_TO_PROCESS(thread) ((thread)->Tcb.ApcState.Process)

#define PsGetCurrentProcess() (KeGetCurrentThread()->ApcState.Process)

#define PsGetCurrentThread() (CONTAINING_RECORD((KeGetCurrentThread()),ETHREAD,Tcb))

#define PsGetCurrentThreadId() (PsGetCurrentThread()->UniqueThread)

// begin_ntddk begin_wdm
//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN DebuggerThread
    );

NTKERNELAPI
NTSTATUS
PsCreateSystemThreadEx(
    OUT PHANDLE ThreadHandle,
    IN SIZE_T ThreadExtensionSize,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN CreateSuspended,
    IN BOOLEAN DebuggerThread,
    IN PKSYSTEM_ROUTINE SystemRoutine OPTIONAL
    );

DECLSPEC_NORETURN
NTKERNELAPI
VOID
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

// end_ntddk end_wdm

// begin_ntddk

typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN PETHREAD Thread,
    IN HANDLE ThreadId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

// end_ntddk

//
// BOOLEAN
// PsIsThreadTerminating(
//   IN PETHREAD Thread
//   )
//
//  Returns TRUE if thread is in the process of terminating.
//

#define PsIsThreadTerminating(T)                                            \
    (T)->Tcb.HasTerminated

//
// Cid
//

#if !defined(_NTSYSTEM_)
#define PsLookupThreadByThreadId(ThreadId, Thread) \
    ObReferenceObjectByHandle(ThreadId, PsThreadObjectType, Thread);
#else
#define PsLookupThreadByThreadId(ThreadId, Thread) \
    ObReferenceObjectByHandle(ThreadId, &PsThreadObjectType, Thread);
#endif

//
// Process statistics.
//

typedef struct _PS_STATISTICS {
    ULONG Length;
    ULONG ThreadCount;
    ULONG HandleCount;
} PS_STATISTICS, *PPS_STATISTICS;

NTKERNELAPI
NTSTATUS
PsQueryStatistics(
    IN OUT PPS_STATISTICS ProcessStatistics
    );

#endif // _PS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\vid.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    vid.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for video APIs exported from NTOS


--*/

#ifndef _VID_H
#define _VID_H


#define VID_NVNOTIFICATION_SIZE               (16)
#define VID_NVNOTIFICATION_DMA_BUFFER_SIZE    (VID_NVNOTIFICATION_SIZE * 32)


//
// Structure to describe video mode information
//

typedef struct _VIDEO_MODE_DATA
{
    LONG  Width; 
    LONG  Height; 
    LONG  BitDepth;
    ULONG PushBase;
    ULONG PushLimit;
    ULONG NotificationBase; 
    ULONG NotificationLimit;
    ULONG HostMemoryBase;
    ULONG HostMemoryLimit;

    PVOID VidMemAddress;   // returned by VidSetVideoMode
    PVOID NvBase;          // returned by VidSetVideoMode

} VIDEO_MODE_DATA, *PVIDEO_MODE_DATA;



NTSTATUS
VidSetVideoMode(
    IN OUT PVIDEO_MODE_DATA ModeData,
    OUT PVOID* DevFlatDma
    );


#endif // _VID_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\smcdef.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    smcdef.h

Abstract:

    This module defines the constants used for accessing the System Management
    Controller (SMC).

--*/

#ifndef _SMCDEF_
#define _SMCDEF_

//
// Define the SMBus slave address of the System Management Controller.
//

#define SMC_SLAVE_ADDRESS                           0x20

//
// Define the command codes for the System Management Controller.
//

#define SMC_COMMAND_FIRMWARE_REVISION               0x01
#define SMC_COMMAND_RESET                           0x02
#define SMC_COMMAND_TRAY_STATE                      0x03
#define SMC_COMMAND_VIDEO_MODE                      0x04
#define SMC_COMMAND_FAN_OVERRIDE                    0x05
#define SMC_COMMAND_REQUEST_FAN_SPEED               0x06
#define SMC_COMMAND_LED_OVERRIDE                    0x07
#define SMC_COMMAND_LED_STATES                      0x08
#define SMC_COMMAND_CPU_TEMPERATURE                 0x09
#define SMC_COMMAND_AIR_TEMPERATURE                 0x0A
#define SMC_COMMAND_AUDIO_CLAMP                     0x0B
#define SMC_COMMAND_DVD_TRAY_OPERATION              0x0C
#define SMC_COMMAND_OS_RESUME                       0x0D
#define SMC_COMMAND_WRITE_ERROR_CODE                0x0E
#define SMC_COMMAND_READ_ERROR_CODE                 0x0F
#define SMC_COMMAND_READ_FAN_SPEED                  0x10
#define SMC_COMMAND_INTERRUPT_REASON                0x11
#define SMC_COMMAND_WRITE_RAM_TEST_RESULTS          0x12
#define SMC_COMMAND_WRITE_RAM_TYPE                  0x13
#define SMC_COMMAND_READ_RAM_TEST_RESULTS           0x14
#define SMC_COMMAND_READ_RAM_TYPE                   0x15
#define SMC_COMMAND_LAST_REGISTER_WRITTEN           0x16
#define SMC_COMMAND_LAST_BYTE_WRITTEN               0x17
#define SMC_COMMAND_SOFTWARE_INTERRUPT              0x18
#define SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN     0x19
#define SMC_COMMAND_OS_READY                        0x1A
#define SMC_COMMAND_SCRATCH                         0x1B

//
// Define the register flags for SMC_COMMAND_RESET.
//

#define SMC_RESET_ASSERT_RESET                      0x01
#define SMC_RESET_ASSERT_POWERCYCLE                 0x40
#define SMC_RESET_ASSERT_SHUTDOWN                   0x80

//
// Define the register flags for SMC_COMMAND_TRAY_STATE.
//

#define SMC_TRAY_STATE_ACTIVITY                     0x01
#define SMC_TRAY_STATE_STATE_MASK                   0x70
#define SMC_TRAY_STATE_CLOSED                       0x00
#define SMC_TRAY_STATE_OPEN                         0x10
#define SMC_TRAY_STATE_UNLOADING                    0x20
#define SMC_TRAY_STATE_OPENING                      0x30
#define SMC_TRAY_STATE_NO_MEDIA                     0x40
#define SMC_TRAY_STATE_CLOSING                      0x50
#define SMC_TRAY_STATE_MEDIA_DETECT                 0x60
#define SMC_TRAY_STATE_RESET                        0x70

//
// Define the register flags for SMC_COMMAND_VIDEO_MODE.
//

#define SMC_VIDEO_MODE_VMODE_MASK                   0x07
#define SMC_VIDEO_MODE_VMODE0                       0x01
#define SMC_VIDEO_MODE_VMODE1                       0x02
#define SMC_VIDEO_MODE_VMODE2                       0x04
#define SMC_VIDEO_MODE_SCART                        0x00
#define SMC_VIDEO_MODE_HDTV                         0x01
#define SMC_VIDEO_MODE_VGA                          0x02
#define SMC_VIDEO_MODE_RFU                          0x03
#define SMC_VIDEO_MODE_SVIDEO                       0x04
#define SMC_VIDEO_MODE_STANDARD                     0x06
#define SMC_VIDEO_MODE_NONE                         0x07

//
// Define the register flags for SMC_COMMAND_FAN_OVERRIDE.
//

#define SMC_FAN_OVERRIDE_DEFAULT                    0x00
#define SMC_FAN_OVERRIDE_USE_REQUESTED_FAN_SPEED    0x01

//
// Define the register flags for SMC_COMMAND_LED_OVERRIDE.
//

#define SMC_LED_OVERRIDE_DEFAULT                    0x00
#define SMC_LED_OVERRIDE_USE_REQUESTED_LED_STATES   0x01

//
// Define the register flags for SMC_COMMAND_LED_STATES.
//

#define SMC_LED_STATES_GREEN_STATE0                 0x01
#define SMC_LED_STATES_GREEN_STATE1                 0x02
#define SMC_LED_STATES_GREEN_STATE2                 0x04
#define SMC_LED_STATES_GREEN_STATE3                 0x08
#define SMC_LED_STATES_RED_STATE0                   0x10
#define SMC_LED_STATES_RED_STATE1                   0x20
#define SMC_LED_STATES_RED_STATE2                   0x40
#define SMC_LED_STATES_RED_STATE3                   0x80

//
// Define the register flags for SMC_COMMAND_AUDIO_CLAMP.
//

#define SMC_AUDIO_CLAMP_RELEASE                     0x00
#define SMC_AUDIO_CLAMP_CLAMP                       0x01

//
// Define the register flags for SMC_COMMAND_DVD_TRAY_OPERATION.
//

#define SMC_DVD_TRAY_OPERATION_OPEN                 0x00
#define SMC_DVD_TRAY_OPERATION_CLOSE                0x01

//
// Define the register flags for SMC_COMMAND_OS_RESUME.
//

#define SMC_OS_RESUME_SHUTDOWN_COMPLETE             0x01
#define SMC_OS_RESUME_SHUTDOWN_IN_PROGRESS          0x02
#define SMC_OS_RESUME_RESUME                        0x04
#define SMC_OS_RESUME_REBOOT                        0x08

//
// Define the register flags for SMC_COMMAND_INTERRUPT_REASON.
//

#define SMC_INTERRUPT_REASON_SHUTDOWN               0x01
#define SMC_INTERRUPT_REASON_TRAY_DETECTED          0x02
#define SMC_INTERRUPT_REASON_TRAY_OPENED            0x04
#define SMC_INTERRUPT_REASON_NEW_AV_PACK            0x08
#define SMC_INTERRUPT_REASON_NO_AV_PACK             0x10
#define SMC_INTERRUPT_REASON_TRAY_EJECT             0x20
#define SMC_INTERRUPT_REASON_TRAY_CLOSED            0x40

//
// Define the register values for SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN.
//

#define SMC_RESET_ON_TRAY_OPEN_SECURE_MODE          0x00
#define SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE       0x01

//
// Define the register flags for SMC_COMMAND_OS_READY.
//

#define SMC_OS_READY_READY                          0x01

//
// Define the register flags for SMC_COMMAND_SCRATCH.  This register is defined
// by the operating system, so these flags can be freely added to or modified.
//

#define SMC_SCRATCH_TRAY_EJECT_PENDING              0x01
#define SMC_SCRATCH_DISPLAY_FATAL_ERROR             0x02
#define SMC_SCRATCH_SHORT_ANIMATION                 0x04
#define SMC_SCRATCH_DASHBOARD_BOOT                  0x08

#endif  // SMCDEF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\videoagp.h ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    videoagp.h

Abstract:
    Video miniport AGP support.

Notes:

Revision History:

--*/

#ifndef __VIDEOAGP_H__
#define __VIDEOAGP_H__

typedef
PHYSICAL_ADDRESS
(*PAGP_RESERVE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext
    );

typedef
BOOLEAN
(*PAGP_COMMIT_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
PVOID
(*PAGP_RESERVE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext
    );

typedef
PVOID
(*PAGP_COMMIT_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef struct _VIDEO_PORT_AGP_SERVICES
{
    PAGP_RESERVE_PHYSICAL AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL  AgpCommitPhysical;
    PAGP_FREE_PHYSICAL    AgpFreePhysical;

    PAGP_RESERVE_VIRTUAL  AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL  AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL   AgpCommitVirtual;
    PAGP_FREE_VIRTUAL     AgpFreeVirtual;
    ULONGLONG AllocationLimit;

} VIDEO_PORT_AGP_SERVICES, *PVIDEO_PORT_AGP_SERVICES;

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_PORT_AGP_SERVICES AgpServices
    );

#endif // ifndef __VIDEOAGP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\shahmac.h ===
/*++

Copyright (c) Microsoft Corporation

Description:
	Definition of routines to calculate an SHA HMAC
	given a material key and a series of piecemeal 
	data blobs

Module Name:

	shahmac.h

--*/

#ifndef __SHAHMAC_H__
#define __SHAHMAC_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <xcrypt.h>

typedef BYTE XSHAHMAC_CONTEXT[XC_SERVICE_SHA_CONTEXT_SIZE];

XBOXAPI
VOID 
WINAPI 
XShaHmacInitialize(
	IN PBYTE				pbKey,
	IN DWORD				cbKey,
	IN OUT XSHAHMAC_CONTEXT	Shactx
	);

XBOXAPI
VOID
WINAPI 
XShaHmacUpdate(
	IN XSHAHMAC_CONTEXT	Shactx,
	IN PBYTE			pbData,
	IN DWORD			cbData
	);

XBOXAPI
VOID 
WINAPI 
XShaHmacComputeFinal(
	IN XSHAHMAC_CONTEXT	Shactx,
	IN PBYTE			pbKey,
	IN DWORD			cbKey,
	OUT PBYTE			pbHmac
	);

#ifdef __cplusplus
}
#endif

#endif // __SHAHMAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\bldnum.c ===
#include <xboxverp.h>

#pragma data_seg(".XBLD$V")

#if DBG
unsigned short XboxKrnlBuildNumber[8] = { 'X' | ('B' << 8), 'O' | ('X' << 8), 'K' | ('R' << 8), 'N' | ('L' << 8),
                                           VER_PRODUCTVERSION | 0x8000 };
#else
unsigned short XboxKrnlBuildNumber[8] = { 'X' | ('B' << 8), 'O' | ('X' << 8), 'K' | ('R' << 8), 'N' | ('L' << 8),
                                           VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\xdisk.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xdisk.h

Abstract:

    This module defines the disk configuration for an XBOX hard disk.

--*/

#ifndef _XDISK_
#define _XDISK_

//
// Define the size of a sector on an XBOX hard disk.
//

#define XDISK_SECTOR_SIZE                   512

//
// Define the number of unpartitioned sectors reserved at the start of the disk.
// These sectors are used for various purposes such as storing data that should
// not be visible from the file system.
//

#define XDISK_UNPARTITIONED_SECTORS         1024
#define XDISK_UNPARTITIONED_SIZE            (XDISK_UNPARTITION_SECTORS * XDISK_SECTOR_SIZE)

//
// Define the number of sectors in the shell partition (partition 2).
//

#define XDISK_SHELL_PARTITION_SECTORS       1024000
#define XDISK_SHELL_PARTITION_SIZE          (XDISK_SHELL_PARTITION_SECTORS * XDISK_SECTOR_SIZE)

//
// Define the number of sectors in each cache partition (partitions 3 to N).
//

#define XDISK_CACHE_PARTITION_SECTORS       1536000
#define XDISK_CACHE_PARTITION_SIZE          (XDISK_CACHE_PARTITION_SECTORS * XDISK_SECTOR_SIZE)

//
// Define the formula used to compute the number of cache partitions given the
// number of user addressable sectors for the disk.
//

#define XDISK_NUMBER_OF_CACHE_PARTITIONS(UserAddressableSectors) \
    ((((UserAddressableSectors) / 200 * 73) - \
    (XDISK_UNPARTITIONED_SECTORS + XDISK_SHELL_PARTITION_SECTORS)) / \
    XDISK_CACHE_PARTITION_SECTORS)

//
// Define the static partition numbers.
//

#define XDISK_DATA_PARTITION                1
#define XDISK_SHELL_PARTITION               2
#define XDISK_FIRST_CACHE_PARTITION         3

//
// Define the static number of sectors allowed for an XBOX hard disk.
//

#define XDISK_FIXED_SECTOR_COUNT            15633072

#endif  // XDISK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\xlaunch.h ===
#ifndef _XLAUNCH_H_
#define _XLAUNCH_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif  // ! PAGE_SIZE

#define MAX_LAUNCH_PATH       (260 + 100)
#define TITLE_PATH_DELIMITER  OTEXT(';')

//
// This is also defined in xbox.h
//

#define MAX_LAUNCH_DATA_SIZE 3072

#define LDT_LAUNCH_DASHBOARD 1
#define LDT_NONE             0xFFFFFFFF

#define LDF_HAS_BEEN_READ    0x00000001

typedef struct _LAUNCH_DATA_HEADER
{
    ULONG dwLaunchDataType;
    ULONG dwTitleId;
    CHAR  szLaunchPath[520];
    ULONG dwFlags;
} LAUNCH_DATA_HEADER, *PLAUNCH_DATA_HEADER;

typedef struct _LAUNCH_DATA_PAGE
{
    LAUNCH_DATA_HEADER Header;
    UCHAR Pad[PAGE_SIZE - MAX_LAUNCH_DATA_SIZE - sizeof(LAUNCH_DATA_HEADER)];
    UCHAR LaunchData[MAX_LAUNCH_DATA_SIZE];
} LAUNCH_DATA_PAGE, *PLAUNCH_DATA_PAGE;

#if !defined(_NTSYSTEM_)
extern PLAUNCH_DATA_PAGE *LaunchDataPage;
#else
extern PLAUNCH_DATA_PAGE LaunchDataPage;
#endif

#ifdef __cplusplus
}
#endif

#endif // ! _XLAUNCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\xapidrv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xapidrv.h

Abstract:

    XAPI methods exposed for use of drivers.

--*/

#ifndef _XAPIDRV_H_
#define _XAPIDRV_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_XAPI_)
#define XAPIDRVAPI DECLSPEC_IMPORT
#else
#define XAPIDRVAPI
#endif

//---------------------------------------------------------------------------------------------------------------
//  XAPI Driver APIS for reporting USB devices
//---------------------------------------------------------------------------------------------------------------
XAPIDRVAPI
VOID XdReportDeviceInsertionRemoval(
    PXPP_DEVICE_TYPE XppDeviceType,
    ULONG PortBit,
    BOOLEAN fInserted
    );

#define XDEVICE_ILLEGAL_PORT 32

#ifdef __cplusplus
}
#endif

#endif //_XAPIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\fatal.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    fatal.c

Abstract:

    This module implements the ExDisplayFatalError (aka UEM) and supporting routines.

--*/

#pragma code_seg("INIT")
#pragma data_seg("INIT_RW")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

#include "ntos.h"
#include "ani.h"

#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <smcdef.h>

#ifndef ARCADE

#pragma pack(1)

typedef struct _IMAGE_RUN1 {
    UINT fOne : 1;
    UINT Size : 3;
    UINT Intensity : 4;
} IMAGE_RUN1;

typedef struct _IMAGE_RUN2 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 10;
    UINT Intensity : 4;
} IMAGE_RUN2;

typedef struct _IMAGE_RUN3 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 18;
    UINT Intensity : 4;
} IMAGE_RUN3;

typedef struct _LED_VERT_TYPE {
    float x,y,z; 
    float w;
    ULONG color; 
} LED_VERT_TYPE;


#pragma pack()

#include "image.h"

const struct TheVerts { float x,y,z,w; float u, v; } Verts[] =
{
    {  0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    {640.0f, 480.0f, 0.5f, 1.0f, 320.0f, 240.0f},
    {  0.0f, 480.0f, 0.5f, 1.0f,   0.0f, 240.0f},
    {640.0f,   0.0f, 0.5f, 1.0f, 320.0f,   0.0f},
    {640.0f, 480.0f, 0.5f, 1.0f, 320.0f, 240.0f},
    {  0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
};


//
// Macros to define LED line segments and characters
//

#define LEDSEGDEF(x1,y1,x2,y2)           ((x2<<6) | (y2<<4) | (x1<<2) | y1)
#define LEDCHARDEF(s0,s1,s2,s3,s4,s5,s6) ((s6 << 6) | (s5 << 5) | (s4 << 4) | (s3 << 3) | \
                                          (s2 << 2) | (s1 << 1) | s0)
                                          

//
// Define the line segments of the LED font
//
//   --0--
//   1   2
//   --3--
//   4   5
//   --6--
//

UCHAR LEDSegmentDef[] = {
    LEDSEGDEF(0,0, 1,0),
    LEDSEGDEF(0,0, 0,1),
    LEDSEGDEF(1,0, 1,1),
    LEDSEGDEF(0,1, 1,1),
    LEDSEGDEF(0,1, 0,2),
    LEDSEGDEF(1,1, 1,2),
    LEDSEGDEF(0,2, 1,2)
};

//
// Define the LED characters based on what line segments 
// should be turned on or off
//

UCHAR LEDCharDef[] = {
    LEDCHARDEF(1,1,1,0,1,1,1),    
    LEDCHARDEF(0,0,1,0,0,1,0),
    LEDCHARDEF(1,0,1,1,1,0,1),
    LEDCHARDEF(1,0,1,1,0,1,1),
    LEDCHARDEF(0,1,1,1,0,1,0),
    LEDCHARDEF(1,1,0,1,0,1,1),
    LEDCHARDEF(1,1,0,1,1,1,1),
    LEDCHARDEF(1,0,1,0,0,1,0),
    LEDCHARDEF(1,1,1,1,1,1,1),
    LEDCHARDEF(1,1,1,1,0,1,0)
};



IDirect3DDevice8* InitD3D(void)
{
    D3DPRESENT_PARAMETERS d3dpp;
    IDirect3DDevice8 *pDev;
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    if (pD3D == NULL)
    {
        return NULL;
    }

    pDev = NULL;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz      = 60;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    IDirect3D8_CreateDevice(pD3D,
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &pDev);

    IDirect3D8_Release(pD3D);

    return pDev;
}

BOOL InitVB(IDirect3DDevice8 *pDev)
{
    IDirect3DVertexBuffer8 *pVB;
    void *pVerts;

    if (FAILED(IDirect3DDevice8_CreateVertexBuffer(pDev,
            sizeof(Verts),
            D3DUSAGE_WRITEONLY,
            D3DFVF_XYZRHW | D3DFVF_TEX1,
            D3DPOOL_MANAGED,
            &pVB)))
    {
        return FALSE;
    }

    IDirect3DVertexBuffer8_Lock(pVB, 0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof(Verts));
    IDirect3DVertexBuffer8_Unlock(pVB);

    IDirect3DDevice8_SetStreamSource(pDev, 0, pVB, sizeof(Verts[0]));
    IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_TEX1);

    return TRUE;
}

COLORREF ColorFromIntensity(UINT intensity4bits)
{
    UINT BaseR = 0x00;
    UINT BaseG = 0xFF;
    UINT BaseB = 0x00;

    UINT r = (UINT)((BaseR * intensity4bits) / 15.0f + 0.5f);
    UINT g = (UINT)((BaseG * intensity4bits) / 15.0f + 0.5f);
    UINT b = (UINT)((BaseB * intensity4bits) / 15.0f + 0.5f);

    return D3DCOLOR_ARGB(0xFF, r, g, b);
}

BOOL InitTexture(IDirect3DDevice8 *pDev)
{
    IDirect3DTexture8* pTex;
    D3DLOCKED_RECT lock;
    UINT x = 0, i, j;
    DWORD dwLine;
    DWORD dwAddr;
    IMAGE_RUN1 *pRun1;
    IMAGE_RUN2 *pRun2;
    IMAGE_RUN3 *pRun3;
    UINT Size;
    UINT Intensity;

    if (FAILED(IDirect3DDevice8_CreateTexture(pDev,
            320,
            240,
            1,
            0,
            D3DFMT_LIN_X8R8G8B8,
            0,
            &pTex)))
    {
        return FALSE;
    }

    IDirect3DTexture8_LockRect(pTex, 0, &lock, NULL, 0);
    dwLine = (DWORD)lock.pBits;
    dwAddr = dwLine;
    i = 0;

    while(i < sizeof(g_Image))
    {
        pRun1 = (IMAGE_RUN1*)&g_Image[i];
        if (pRun1->fOne)
        {
            Size = pRun1->Size;
            Intensity = pRun1->Intensity;
            i += 1;
        }
        else
        {
            pRun2 = (IMAGE_RUN2*)&g_Image[i];
            if (pRun2->fTwo)
            {
                Size = pRun2->Size;
                Intensity = pRun2->Intensity;
                i += 2;
            }
            else
            {
                pRun3 = (IMAGE_RUN3*)&g_Image[i];
                Size = pRun3->Size;
                Intensity = pRun3->Intensity;
                i += 3;
            }
        }

        for (j = 0; j < Size; j++)
        {
            if (Intensity == 0)
            {
                *(DWORD*)dwAddr = 0xFF000000;
            }
            else
            {
                *(DWORD*)dwAddr = ColorFromIntensity(Intensity);
            }

            x++;

            if (x >= 320)
            {
                x = 0;
                dwLine += lock.Pitch;
                dwAddr = dwLine;
            }
            else
            {
                dwAddr += sizeof(DWORD);
            }
        }
    }

    IDirect3DTexture8_UnlockRect(pTex, 0);

    IDirect3DDevice8_SetTexture(pDev, 0, (D3DBaseTexture*)pTex);

    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

    return TRUE;
}

#endif

VOID
ExDisplayFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine displays a fatal error message (AKA UEM).

Arguments:

    ErrorCode - The error code to be displayed 

Return Value:

    None.

--*/
{
    IDirect3DDevice8 *pDev;
    ULONG Segment;
    ULONG VertexNumber;
    UCHAR SegDef;
    UCHAR CharDef;
    ULONG Digit;
    ULONG Position;
    ULONG Scratch;
    EEPROM_LAYOUT EEPROMData;
    NTSTATUS Status;
    ULONG SettingType;
    ULONG SettingLength;
    XBOX_UEM_INFO* UEMInfo;
    BOOL PowerCycle;

    RtlZeroMemory(XboxCERTKey, XBOX_KEY_LENGTH);

    AniSetLogo(NULL, 0);
    AniTerminateAnimation();

    //
    // Read the EEPROM to get the UEM info
    //

    UEMInfo = (XBOX_UEM_INFO*)&(EEPROMData.UEMInfo[0]);

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &SettingType, &EEPROMData,
        sizeof(EEPROMData), &SettingLength);

    if (NT_SUCCESS(Status)) {

        PowerCycle = FALSE;

        //
        // If the last UEM code stored in EEPROM is zero, write the current UEM
        // code (manufacturing only), set the matching bit in the UEM history,
        // and power cycle (manufacturing only).  Otherwise, clear the last code
        // and display the error.
        //

        if (UEMInfo->LastCode == FATAL_ERROR_NONE) {

            if (XboxGameRegion & XC_GAME_REGION_MANUFACTURING) {

                UEMInfo->LastCode = (UCHAR)ErrorCode;
                PowerCycle = TRUE;
            }

            //
            // Update the history bitmap for errors 5 and above
            //
            
            if (ErrorCode >= 5) {
                UEMInfo->History |= (1 << (ErrorCode - 5));
            }

        } else {

            UEMInfo->LastCode = FATAL_ERROR_NONE;
        }

        //
        // Write the EEPROM back out
        //

        ExSaveNonVolatileSetting(XC_MAX_ALL, SettingType, &EEPROMData, SettingLength);

        //
        // If a power cycle is required, ask the SMC to perform the power cycle
        //

        if (PowerCycle) {
            Status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET,
                SMC_RESET_ASSERT_POWERCYCLE);
        }
    }

#ifndef ARCADE
    pDev = InitD3D();

    if (pDev != NULL) {
        if (InitVB(pDev) && InitTexture(pDev)) {

            IDirect3DDevice8_BeginScene(pDev);

            //
            // Display the texture with the multilingual text
            //

            IDirect3DDevice8_DrawPrimitive(pDev, D3DPT_TRIANGLELIST, 0,
                (sizeof(Verts) / sizeof(Verts[0])) / 3);

            //
            // Setup the state to display the error code
            //

            IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
            IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
            
            //
            // Display the two digit error code
            //

            for (Digit = 0; Digit < 2; Digit++) {
                
                Position = 80 - Digit * 25;
                CharDef = LEDCharDef[ErrorCode % 10];

                for (Segment = 0; Segment < 7; Segment++) {
                    
                    SegDef = LEDSegmentDef[Segment];
                     
                    if ((CharDef & (1 << Segment)) != 0) {
                        
                        //
                        // Draw the line segment 
                        //

                        IDirect3DDevice8_Begin(pDev, D3DPT_LINELIST);

                        for (VertexNumber = 0; VertexNumber < 2; VertexNumber++) {
                            
                            IDirect3DDevice8_SetVertexData4f(pDev, D3DVSDE_VERTEX,  
                                (float)(Position + ((SegDef >> (VertexNumber * 4 + 2)) & 0x3) * 12),
                                (float)(50 + ((SegDef >> (VertexNumber * 4)) & 0x3) * 16),
                                0.5f, 2.0f);
                        }

                        IDirect3DDevice8_End(pDev);
                    }
                }

                ErrorCode /= 10;
            }

            IDirect3DDevice8_EndScene(pDev);

            IDirect3DDevice8_Present(pDev, NULL, NULL, NULL, NULL);

            IDirect3DDevice8_PersistDisplay(pDev);
        }
    }
#endif

    //
    // Keep the system alive so that we can continue to handle the tray eject
    // interrupt.
    //

    PsTerminateSystemThread(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\xpcicfg.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xpcicfg.h

Abstract:

    This module defines the static PCI configuration for an XBOX.

--*/

#ifndef _XPCICFG_
#define _XPCICFG_

//
// Note that the Advanced Programmable Interrupt Controller (APIC) defaults to
// location 0xFEE00000 and consumes one page.  The kernel turns off the APIC,
// but debugger extensions (VTune) may reenable it.
//

// Bus 0, device 0, function 0.
#define XPCICFG_HOSTBRIDGE_DEVICE_ID                        0
#define XPCICFG_HOSTBRIDGE_FUNCTION_ID                      0

// Bus 0, device 1, function 0.
#define XPCICFG_LPCBRIDGE_DEVICE_ID                         1
#define XPCICFG_LPCBRIDGE_FUNCTION_ID                       0
#define XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0                0x8000
#define XPCICFG_LPCBRIDGE_IO_REGISTER_LENGTH_0              0x0100

// Bus 0, device 1, function 1.
#define XPCICFG_SMBUS_DEVICE_ID                             1
#define XPCICFG_SMBUS_FUNCTION_ID                           1
#define XPCICFG_SMBUS_IO_REGISTER_BASE_1                    0xC000
#define XPCICFG_SMBUS_IO_REGISTER_LENGTH_1                  0x0010
#define XPCICFG_SMBUS_IO_REGISTER_BASE_2                    0xC200
#define XPCICFG_SMBUS_IO_REGISTER_LENGTH_2                  0x0020

// Bus 0, device 2, function 0.
#define XPCICFG_USB0_DEVICE_ID                              2
#define XPCICFG_USB0_FUNCTION_ID                            0
#define XPCICFG_USB0_IRQ                                    1
#define XPCICFG_USB0_MEMORY_REGISTER_BASE_0                 0xFED00000
#define XPCICFG_USB0_MEMORY_REGISTER_LENGTH_0               0x00001000

// Bus 0, device 3, function 0.
#define XPCICFG_USB1_DEVICE_ID                              3
#define XPCICFG_USB1_FUNCTION_ID                            0
#define XPCICFG_USB1_IRQ                                    9
#define XPCICFG_USB1_MEMORY_REGISTER_BASE_0                 0xFED08000
#define XPCICFG_USB1_MEMORY_REGISTER_LENGTH_0               0x00001000

// Bus 0, device 4, function 0.
#define XPCICFG_NIC_DEVICE_ID                               4
#define XPCICFG_NIC_FUNCTION_ID                             0
#define XPCICFG_NIC_IRQ                                     4
#define XPCICFG_NIC_MEMORY_REGISTER_BASE_0                  0xFEF00000
#define XPCICFG_NIC_MEMORY_REGISTER_LENGTH_0                0x00000400
#define XPCICFG_NIC_IO_REGISTER_BASE_1                      0xE000
#define XPCICFG_NIC_IO_REGISTER_LENGTH_1                    0x0008

// Bus 0, device 5, function 0.
#define XPCICFG_APU_DEVICE_ID                               5
#define XPCICFG_APU_FUNCTION_ID                             0
#define XPCICFG_APU_IRQ                                     5
#define XPCICFG_APU_MEMORY_REGISTER_BASE_0                  0xFE800000
#define XPCICFG_APU_MEMORY_REGISTER_LENGTH_0                0x00080000

// Bus 0, device 6, function 0.
#define XPCICFG_ACI_DEVICE_ID                               6
#define XPCICFG_ACI_FUNCTION_ID                             0
#define XPCICFG_ACI_IRQ                                     6
#define XPCICFG_ACI_IO_REGISTER_BASE_0                      0xD000
#define XPCICFG_ACI_IO_REGISTER_LENGTH_0                    0x0100
#define XPCICFG_ACI_IO_REGISTER_BASE_1                      0xD200
#define XPCICFG_ACI_IO_REGISTER_LENGTH_1                    0x0080
#define XPCICFG_ACI_MEMORY_REGISTER_BASE_2                  0xFEC00000
#define XPCICFG_ACI_MEMORY_REGISTER_LENGTH_2                0x00001000

// Bus 0, device 9, function 0.
#define XPCICFG_IDE_DEVICE_ID                               9
#define XPCICFG_IDE_FUNCTION_ID                             0
#define XPCICFG_IDE_IRQ                                     14
#define XPCICFG_IDE_IO_REGISTER_BASE_4                      0xFF60
#define XPCICFG_IDE_IO_REGISTER_LENGTH_4                    0x0010

// Bus 0, device 30, function 0.
#define XPCICFG_AGPBRIDGE_DEVICE_ID                         30
#define XPCICFG_AGPBRIDGE_FUNCTION_ID                       0

// Bus 1, device 0, device 0.
#define XPCICFG_GPU_DEVICE_ID                               0
#define XPCICFG_GPU_FUNCTION_ID                             0
#define XPCICFG_GPU_IRQ                                     3
#define XPCICFG_GPU_MEMORY_REGISTER_BASE_0                  0xFD000000
#define XPCICFG_GPU_MEMORY_REGISTER_LENGTH_0                0x01000000

// Map a device name to PCI slot number
#define XPCI_SLOT_NUMBER(device) \
        ((XPCICFG_##device##_DEVICE_ID) | ((XPCICFG_##device##_FUNCTION_ID) << 5))

#endif  // XPCICFG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\xconfig.h ===
#ifndef _XCONFIG_H_
#define _XCONFIG_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Define the FAT32 X-Box config sector
//
typedef struct _XBOX_CONFIG_SECTOR {
    ULONG SectorBeginSignature;                     // offset = 0x000   0
    ULONG Version;                                  // offset = 0x004   4
    ULONG SectorCount;                              // offset = 0x008   8
    UCHAR Data[492];                                // offset = 0x00c  12
    ULONG Checksum;                                 // offset = 0x1f8 504
    ULONG SectorEndSignature;                       // offset = 0x1fc 508
} XBOX_CONFIG_SECTOR, *PXBOX_CONFIG_SECTOR;

#define XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE   0x79132568
#define XBOX_CONFIG_SECTOR_END_SIGNATURE     0xAA550000
#define XBOX_CONFIG_VERSION                  0x00000001
#define XBOX_CONFIG_SECTOR_COUNT             0x00000001

#define XBOX_CONFIG_DATA_SIZE      (sizeof(((PXBOX_CONFIG_SECTOR) 0)->Data))
#define XBOX_HD_SECTOR_SIZE        512

#define XBOX_BOOT_SECTOR_INDEX     0

#define XBOX_CACHE_DB_SECTOR_INDEX 4
#define XBOX_CONFIG_SECTOR_INDEX   8
#define XBOX_NUM_CONFIG_SECTORS    8

//
// Compute 32-bit 1's complement sum
//  NOTE: It'd be nice to make this a __fastcall.
//  But it doesn't work because of some compiler problems.
//
#pragma warning(push)
#pragma warning(disable:4035)
__inline ULONG XConfigChecksum(const VOID* data, ULONG count) {
    __asm {
        mov     ecx, data
        mov     edx, count
        xor     eax, eax
        xor     ebx, ebx
        shr     edx, 2      // count /= sizeof(ULONG)
        test    edx, edx
        jz      L2
    L1: add     eax, [ecx]  // eax += *data++
        adc     ebx, 0      // ebx += carry
        add     ecx, 4
        dec     edx
        jnz     L1          // while (--count)
    L2: add     eax, ebx    // take care of accumulated carries
        adc     eax, 0
    }
}
#pragma warning(pop)

//
// Refurb information sector
//
#define XBOX_REFURB_INFO_SECTOR_INDEX 3
#define XBOX_REFURB_INFO_SIGNATURE 'RFRB'

typedef struct _XBOX_REFURB_INFO {
    ULONG Signature;
    ULONG PowerCycleCount;
    LARGE_INTEGER FirstSetTime;
} XBOX_REFURB_INFO;

//
// Data layout of the non-volatile memory (EEPROM)
//
//  encrypted factory settings section:
//      programmed at factory and never changes
//      data is encrypted
//  factory settings section:
//      programmed at factory and never changes
//  user settings section:
//      can be modified by the user
//
// !!! NOTE:
//  Each section should start at 8-byte aligned EEPROM page boundary.
//  When you change the structures below in the future,
//  make sure you don't disturb the existing fields.
//
#include <PshPack1.h>

#define FIELD_SIZE(type, field) (sizeof(((type *) 0)->field))

typedef struct _XBOX_FACTORY_SETTINGS {
    ULONG Checksum;                         //  0 +  4
    UCHAR SerialNumber[12];                 //  4 + 12
    UCHAR EthernetAddr[6];                  // 16 +  6
    UCHAR Reserved1[2];                     // 22 +  2
    UCHAR OnlineKey[16];                    // 24 + 16
    ULONG AVRegion;                         // 40 +  4
    ULONG Reserved2;                        // 44 +  4
} XBOX_FACTORY_SETTINGS;                    // 48

// Compressed timezone date representation
// (4 bytes instead of 16 bytes for SYSTEMTIME)
typedef struct _XBOX_TIMEZONE_DATE {
    UCHAR Month;            // 0 = unspecified time zone info
    UCHAR Day;
    UCHAR DayOfWeek;
    UCHAR Hour;
} XBOX_TIMEZONE_DATE;

#define XC_TZNAMELEN 4
typedef struct _XBOX_USER_SETTINGS {
    ULONG Checksum;                         //  0 +  4
    LONG TimeZoneBias;                      //  4 +  4
    CHAR TimeZoneStdName[XC_TZNAMELEN];     //  8 +  4
    CHAR TimeZoneDltName[XC_TZNAMELEN];     // 12 +  4
    ULONG Reserved1[2];                     // 16 +  8
    XBOX_TIMEZONE_DATE TimeZoneStdDate;     // 24 +  4
    XBOX_TIMEZONE_DATE TimeZoneDltDate;     // 28 +  4
    ULONG Reserved2[2];                     // 32 +  8
    LONG TimeZoneStdBias;                   // 40 +  4
    LONG TimeZoneDltBias;                   // 44 +  4
    ULONG Language;                         // 48 +  4
    ULONG VideoFlags;                       // 52 +  4
    ULONG AudioFlags;                       // 56 +  4
    ULONG ParentalControlGames;             // 60 +  4
    ULONG ParentalControlPassword;          // 64 +  4
    ULONG ParentalControlMovies;            // 68 +  4
    ULONG OnlineIpAddress;                  // 72 +  4
    ULONG OnlineDnsAddress;                 // 76 +  4
    ULONG OnlineDefaultGatewayAddress;      // 80 +  4
    ULONG OnlineSubnetMask;                 // 84 +  4
    ULONG MiscFlags;                        // 88 +  4
    ULONG DvdRegion;                        // 92 +  4
} XBOX_USER_SETTINGS;                       // 96


typedef struct _XBOX_UEM_INFO {
    UCHAR  LastCode;
    UCHAR  Reserved1;
    USHORT History;
} XBOX_UEM_INFO;


#define EEPROM_ENCRYPTED_SECTION_START      FIELD_OFFSET(EEPROM_LAYOUT, EncryptedSection)
#define EEPROM_ENCRYPTED_SECTION_SIZE       48
#define EEPROM_FACTORY_SECTION_START        FIELD_OFFSET(EEPROM_LAYOUT, FactorySection)
#define EEPROM_FACTORY_SECTION_SIZE         sizeof(XBOX_FACTORY_SETTINGS)
#define EEPROM_USER_SECTION_START           FIELD_OFFSET(EEPROM_LAYOUT, UserConfigSection)
#define EEPROM_USER_SECTION_SIZE            sizeof(XBOX_USER_SETTINGS)
#define EEPROM_TOTAL_MEMORY_SIZE            256
#define EEPROM_PAGE_ALIGNMENT               8

typedef struct _EEPROM_LAYOUT {
    UCHAR EncryptedSection[EEPROM_ENCRYPTED_SECTION_SIZE];
    UCHAR FactorySection[EEPROM_FACTORY_SECTION_SIZE];
    UCHAR UserConfigSection[EEPROM_USER_SECTION_SIZE];
    UCHAR Unused[58];
    UCHAR UEMInfo[4];
    UCHAR Reserved1[2];   // Reserved for manufacturing
} EEPROM_LAYOUT;

// Check if the time zone information is invalid
#define XBOX_INVALID_TIMEZONE_SETTING(userSettings) \
        ((userSettings).TimeZoneStdName[0] == '\0')

// Convert the timezone name stored in the EEPROM to/from Unicode string
__inline VOID XboxTimeZoneNameToWstr(const CHAR* tzname, WCHAR* wstr)
{
    ULONG count = XC_TZNAMELEN;
    while (count--)
        *wstr++ = (WCHAR) ((UCHAR) *tzname++);
    *wstr = L'\0';
}

__inline VOID WstrToXboxTimeZoneName(const WCHAR* wstr, CHAR* tzname)
{
    ULONG count = XC_TZNAMELEN;
    while (count--)
        *tzname++ = (CHAR) *wstr++;
}

//
// Encrypted section of the EEPROM
//
typedef struct _XBOX_ENCRYPTED_SETTINGS {
    UCHAR Checksum[20];                     //  0 + 20
    UCHAR Confounder[8];                    // 20 +  8
    UCHAR HDKey[XBOX_KEY_LENGTH];           // 28 + 16
    ULONG GameRegion;                       // 44 +  4
} XBOX_ENCRYPTED_SETTINGS;                  // 48

//
// Duplicated constants from xboxp.h so that the kernel proper doesn't have to
// include XTL headers.
//

#define XC_GAME_REGION_NA             0x00000001
#define XC_GAME_REGION_JAPAN          0x00000002
#define XC_GAME_REGION_RESTOFWORLD    0x00000004
#define XC_GAME_REGION_INTERNAL_TEST  0x40000000
#define XC_GAME_REGION_MANUFACTURING  0x80000000

#include <PopPack.h>

//
// Private kernel functions for querying or saving non-volatile settings
//
NTSTATUS
ExQueryNonVolatileSetting(
    IN ULONG ValueIndex,
    OUT ULONG* Type,
    OUT VOID* Value,
    IN ULONG ValueLength,
    OUT ULONG* ResultLength
    );

NTSTATUS
ExSaveNonVolatileSetting(
    IN ULONG ValueIndex,
    IN ULONG Type,
    IN const VOID* Value,
    IN ULONG ValueLength
    );

//
// Private function for reading/writing refurb information
//
NTSTATUS
ExReadWriteRefurbInfo(
    OUT XBOX_REFURB_INFO* RefurbInfo,
    IN ULONG ValueLength,
    BOOLEAN DoWrite
    );

#ifdef __cplusplus
}
#endif

#endif // ! _XCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\inc\xprofp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xprofp.h

Abstract:

    Kernel profiler functions

--*/

#ifndef _XPROFP_H
#define _XPROFP_H

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
XProfpControl(
    ULONG Action,
    ULONG Param
    );

#define XPROF_START             1
#define XPROF_STOP              2
#define XPROF_COMMENT           4
#define XPROF_THREAD_SWITCH     5
#define XPROF_DPC_BEGIN         6
#define XPROF_DPC_END           7

#define XPROF_DPC_ENABLED       0x80000000

/*
    action: XPROF_START
    param: size of profiling data buffer in MB, default = 32

    action: XPROF_STOP
    param: none

    action: XPROF_COMMENT
    param: user-defined parameter

 */

/*
 !!! Profiling data record format:
    timestamp: bits 63-32
    timestamp: bits 31-0
    type-specific data

    Bits 63-61 of the timestamp are used as flags.

    000 - fastcap start: just before calling a function
        caller function: ULONG
        callee function: ULONG

    001 - fastcap end: just after calling a function
        caller function: ULONG

    010 - _penter:
        caller function: ULONG
        ESP: ULONG

    011 - _pexit:
        caller function: ULONG
        ESP: ULONG

    100 - callcap start:
        caller function: ULONG

    101 - callcap exit:
        caller function: ULONG

    110 - reserved

    111 - control records:
        record type: ULONG
        param: ULONG

    If type is XPROF_START or XPROF_STOP, param is the current thread ID
    If type is XPROF_COMMENT, param is the user-defined parameter.
    If type is XPROF_THREAD_SWITCH, param is the new thread ID.
    If type is XPROF_DPC_START or XPROF_DPC_END, param is the DPC function address.

    We don't need to record thread ID in each record because we can always derive
    the current thread ID from the XPROF_START and XPROF_THREAD_SWITCH records.

 */

#define XPROFREC_TYPEMASK       0xE0000000
#define XPROFREC_FASTCAP_START  0x00000000
#define XPROFREC_FASTCAP_END    0x20000000
#define XPROFREC_PENTER         0x40000000
#define XPROFREC_PEXIT          0x60000000
#define XPROFREC_CALLCAP_START  0x80000000
#define XPROFREC_CALLCAP_END    0xA0000000
#define XPROFREC_CONTROL        0xE0000000

//
// Maximum size for all types of profile data records.
// Note that we're setting this to be a larger value than necessary
// in case we need to add new types of profiling data records
// in the future.
//
#define XPROFREC_MAXSIZE (32*sizeof(ULONG))

//
// Profile data file header
//
#define XPROF_FILE_VERSION 0x00000001
#define XPROF_FILE_HEADER_SIZE sizeof(XProfpFileHeader)
#define XPROF_MAX_MODULES 16
#define XPROF_MAX_MODULE_NAMELEN 48

typedef struct {
    ULONG version;                              // 0x000 + 0x004
    ULONG module_count;                         // 0x004 + 0x004
    struct {                                    // 0x008 + 0x010 * 0x040
        ULONG loadaddr;
        ULONG size;
        ULONG reserved[2];
        CHAR name[XPROF_MAX_MODULE_NAMELEN];
    } modules[XPROF_MAX_MODULES];
    UCHAR reserved[0x1000-0x408];               // ..... = 0x1000
} XProfpFileHeader;


//
// Global data structures maintained by the profiler
//
// NOTE: Do NOT change the first two fields of this structure,
// unless you also change the offsets in the assembly functions
// CAP_Start_Profiling and CAP_End_Profiling.
//
typedef struct {
    ULONG* bufnext;
        // Points to the next available space in the profiling data buffer

    ULONG* bufend;
        // End of profiling data buffer

    ULONG* bufnext_stopped;
        // Value of bufnext when the profiling session is stopped
        // NULL if profiling session is active or hasn't been stopped

    ULONG* bufstart;
        // Start of profiling data buffer
        // NULL if profiling session isn't active

    ULONG start_type;
        // Unused

    ULONG start_param;
        // Parameter that was passed to XPROF_START_x

    LONG lock;
        // Global access lock:
        //  0 if the lock is free
        //  otherwise, the lock is busy

    LONG reserved;
} XProfpGlobals;

//
// Retrieve kernel profiling global data structure
//
XProfpGlobals*
XProfpGetData();

//
// Runtime support function for sweeping BBT data into a file
//
NTSTATUS IrtSweep(HANDLE file);

#ifdef __cplusplus
}
#endif

#endif // !_XPROFP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\arcade\anistub.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    anistub.c

Abstract:

    This module implements empty boot animation stub routines for the ARCADE
    build.

--*/

#include <ntos.h>
#include <ani.h>
#include <av.h>
#include <avmode.h>
#include <xpcicfg.h>
#include <xtl.h>

#pragma code_seg("INIT")

VOID AniStartAnimation(BOOLEAN fShort)
{
    ULONG Step;

    //
    // D3D8.LIB assumes that D3D8NTPR.LIB initially set the display mode.  The
    // ARCADE kernel doesn't use D3D8NTPR.LIB, so we need to set the display
    // mode ourselves.  We set the display mode to OFF with the same D3DFORMAT
    // and pitch that the console boot animation would use.
    //

    Step = 0;

    do {
        Step = AvSetDisplayMode((PVOID)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, 0,
            AV_MODE_OFF, D3DFMT_LIN_A8R8G8B8, 640 * 4, 0);
    } while (Step);
}

VOID AniTerminateAnimation()
{
    NOTHING;
}

VOID AniBlockOnAnimation()
{
    NOTHING;
}

VOID AniSetLogo(PVOID pv, ULONG Size)
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\arcade\makefile.inc ===
BOOTXFILES=..\..\obj\i386

obj\$(TARGET_DIRECTORY)\$(NTTEST).def: ..\ntoskrnl.src
    copy ..\ntoskrnl.src obj\$(TARGET_DIRECTORY)\$(NTTEST).pp
    $(TARGET_CPP) -nologo -EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(WIN32_DEFINE) $(C_DEFINES) obj\$(TARGET_DIRECTORY)\$(NTTEST).pp > obj\$(TARGET_DIRECTORY)\$(NTTEST).def
    -del obj\$(TARGET_DIRECTORY)\$(NTTEST).pp

$(O)\$(NTTEST).exp: obj\$(TARGET_DIRECTORY)\$(NTTEST).def \
        $(KERNEL_LIBS)
    -lib @<<
$(LINK_LIB_IGNORE_FLAG)
-def:obj\$(TARGET_DIRECTORY)\$(NTTEST).def
-debugtype:cv
-out:$(@R).lib
-machine:$(MACHINE_TYPE)
$(KERNEL_LIBS)
<<NOKEEP

..\init.c: $(BASEDIR)\private\inc\xboxverp.h

!IF DEFINED(RETAILXM3)
ROMBLDSYS=xm3
!ELSE
ROMBLDSYS=xdk
!ENDIF

obj\i386\arcdrom_dvt6.bin: obj\i386\arcdkrnl.exe $(BOOTXFILES)\inittbl_dvt6.bin $(BOOTXFILES)\xboxbldr.bin $(BOOTXFILES)\romdec32.bin
    rombld /config:<<
    /out:obj\i386\arcdrom_dvt6.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\arcdrom_dvt6_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(BOOTXFILES)\inittbl_dvt6.bin
    /bldr:$(BOOTXFILES)\xboxbldr.bin
    /preldr:$(BOOTXFILES)\xpreldr.bin
    /kernel:obj\i386\arcdkrnl.exe
    /romdec:$(BOOTXFILES)\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\arcdrom_dvt6_ext.bin
!ENDIF
!ENDIF

!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\arcdkrnl.map
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\console\makefile.inc ===
obj\$(TARGET_DIRECTORY)\$(NTTEST).def: ..\ntoskrnl.src
    copy ..\ntoskrnl.src obj\$(TARGET_DIRECTORY)\$(NTTEST).pp
    $(TARGET_CPP) -nologo -EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(WIN32_DEFINE) $(C_DEFINES) obj\$(TARGET_DIRECTORY)\$(NTTEST).pp > obj\$(TARGET_DIRECTORY)\$(NTTEST).def
    -del obj\$(TARGET_DIRECTORY)\$(NTTEST).pp

$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\xboxkrnl.lib : $(O)\xboxkrnl.lib
    copy $** $@

$(O)\$(NTTEST).lib $(O)\$(NTTEST).exp: obj\$(TARGET_DIRECTORY)\$(NTTEST).def $(O)\bldnum.obj \
        $(KERNEL_LIBS)
    -lib @<<
$(LINK_LIB_IGNORE_FLAG)
-def:obj\$(TARGET_DIRECTORY)\$(NTTEST).def
-debugtype:cv
-out:$(@R).lib
-machine:$(MACHINE_TYPE)
$(KERNEL_LIBS)
<<NOKEEP
    -lib -out:$(@R).lib @<<
$(@R).lib
$(O)\bldnum.obj
<<NOKEEP

..\init.c: $(BASEDIR)\private\inc\xboxverp.h

{}bldnum.c{$O\}bldnum.obj:
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$O/" $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

$(XDK_LIB_PATH)\xboxkrnl.lib: $(SDK_LIB_PATH)\xboxkrnl.lib
    copy $** $@
    
!IF DEFINED(RETAILXM3)
ROMBLDSYS=xm3
!ELSE
ROMBLDSYS=xdk
!ENDIF

obj\i386\xboxrom_dvt4.bin: obj\i386\xboxkrnl.exe $(TARGETPATH2)\i386\inittbl_dvt4.bin $(TARGETPATH2)\i386\xboxbldr.bin $(TARGETPATH2)\i386\romdec32.bin
    rombld /config:<<
    /out:obj\i386\xboxrom_dvt4.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\xboxrom_dvt4_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(TARGETPATH2)\i386\inittbl_dvt4.bin
    /bldr:$(TARGETPATH2)\i386\xboxbldr.bin
    /preldr:$(TARGETPATH2)\i386\xpreldr.bin
    /kernel:obj\i386\xboxkrnl.exe
    /romdec:$(TARGETPATH2)\i386\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxrom_dvt4_ext.bin
!ENDIF
!ENDIF


obj\i386\xboxrom_dvt6.bin: obj\i386\xboxkrnl.exe $(TARGETPATH2)\i386\inittbl_dvt6.bin $(TARGETPATH2)\i386\xboxbldr.bin $(TARGETPATH2)\i386\romdec32.bin
    rombld /config:<<
    /out:obj\i386\xboxrom_dvt6.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\xboxrom_dvt6_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(TARGETPATH2)\i386\inittbl_dvt6.bin
    /bldr:$(TARGETPATH2)\i386\xboxbldr.bin
    /preldr:$(TARGETPATH2)\i386\xpreldr.bin
    /kernel:obj\i386\xboxkrnl.exe
    /romdec:$(TARGETPATH2)\i386\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxrom_dvt6_ext.bin
!ENDIF
!ENDIF


obj\i386\xboxrom_qt.bin: obj\i386\xboxkrnl.exe $(TARGETPATH2)\i386\inittbl_qt.bin $(TARGETPATH2)\i386\xboxbldr.bin $(TARGETPATH2)\i386\romdec32.bin
    rombld /config:<<
    /out:obj\i386\xboxrom_qt.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\xboxrom_qt_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(TARGETPATH2)\i386\inittbl_qt.bin
    /bldr:$(TARGETPATH2)\i386\xboxbldr.bin
    /preldr:$(TARGETPATH2)\i386\xpreldr.bin
    /kernel:obj\i386\xboxkrnl.exe
    /romdec:$(TARGETPATH2)\i386\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxrom_qt_ext.bin
!ENDIF
!ENDIF


!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxkrnl.map
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=init

TARGETNAME=init
TARGETPATH=obj
TARGETTYPE=LIBRARY

TARGETPATH2=..\..\obj

SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\genx\ntos\nls\$(O);$(BASEDIR)\private\inc\crypto;$(BASEDIR)\private\inc\aug01
GPSIZE=32

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\xboxkrnl.c \
        ..\init.c \
        ..\fatal.cpp

EXPORT_FILE=$(O)\$(NTTEST).exp

!IF defined(ARCADE)
KERNEL_LIB_SUFFIX=arc
!ELSE
KERNEL_LIB_SUFFIX=con
!ENDIF

KERNEL_LIBS = \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ex.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\halx.lib \
    $(TARGETPATH)\$(TARGET_DIRECTORY)\init.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\io.lib \
!IF !defined(NODEVKIT)
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\kd.lib \
!ELSE
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\kdlite.lib \
!ENDIF
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ke.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\mm$(KERNEL_LIB_SUFFIX).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ob.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ps.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ntosrtl.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\idex$(KERNEL_LIB_SUFFIX).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\raw.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\fatx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\gdfx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\udfx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\phy.lib \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\libcntpr$(D).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ldr$(KERNEL_LIB_SUFFIX).lib \
    $(BASEDIR)\private\lib\$(TARGET_DIRECTORY)\rsa32k.lib      \
    $(BASEDIR)\private\lib\$(TARGET_DIRECTORY)\xcryptk.lib     \
    $(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\randlibk.lib \
!IF !defined(ARCADE)
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ani.lib \
!ENDIF
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\av.lib

LINKLIBS = $(EXPORT_FILE)

!IF !defined(ARCADE)
LINKLIBS = $(LINKLIBS) \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\d3d8ntpr$(D).lib \
    $(BASEDIR)\public\xdk\lib-aug01\xgraphics$(D).lib\
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\bootsnd$(D).lib
!ENDIF

LINKER_FLAGS=$(LINKER_FLAGS) /map
LINKER_FLAGS=$(LINKER_FLAGS) /merge:.edata=.text /merge:.XBLD=INIT
LINKER_FLAGS=$(LINKER_FLAGS) /merge:PAGER32C=.text /merge:PAGER32R=.rdata /merge:PAGER32D=.data
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\xboxkrnl.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    xboxkrnl.c

Abstract:

    Entry point for the kernel.

--*/

#include "ntos.h"
#include <bldr.h>

VOID
__cdecl
main(
    IN PUCHAR LoadOptions,
    IN const UCHAR* CryptKeys
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, main)
#endif

VOID
__cdecl
main(
    IN PUCHAR LoadOptions,
    IN const UCHAR* CryptKeys
    )
{
#ifdef DEVKIT
    //
    // Copy the load options from the boot loader to a local buffer and then
    // parse the various options and convert them to boot flags.
    //

    UCHAR buf[64];
    strncpy(buf, LoadOptions, 64);
    buf[63] = '\0';
    _strupr(buf);

    if (strstr(buf, "SHADOW") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_SHADOW;

    if (strstr(buf, "/HDBOOT") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_HDBOOT;

    if (strstr(buf, "/CDBOOT") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_CDBOOT;

    if (strstr(buf, "/DBBOOT") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_DASHBOARDBOOT;
#endif

    //
    // Save the encryption keys that have been passed in from the boot loader.
    //

    RtlCopyMemory(XboxEEPROMKey, CryptKeys, XBOX_KEY_LENGTH);
    RtlCopyMemory(XboxCERTKey, CryptKeys + XBOX_KEY_LENGTH, XBOX_KEY_LENGTH);

    //
    // Zero out the memory used by the boot loader at its relocated origin.  The
    // original origin of the boot loader has already been overwritten by the
    // kernel image.
    //

    RtlZeroMemory((PUCHAR)MM_SYSTEM_RANGE_START + BLDR_RELOCATED_ORIGIN,
        BLDR_BLOCK_SIZE);

    //
    // Initialize the system.
    //

    KiSystemStartup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\init.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Main source file the NTOS system initialization subcomponent.

--*/

#include "ntos.h"
#include <ntimage.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntverp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ldr.h>
#include <xbeimage.h>
#include <dm.h>
#include <xlaunch.h>
#include <ani.h>
#include <xprofp.h>
#include <bldr.h>
#include <rc4.h>
#include <xcrypt.h>
#include <smcdef.h>

#include <wtypes.h>
#include <xconfig.h>
#include <xbox.h>
#include <xboxp.h>

VOID
IdexChannelCreate(
    VOID
    );

#ifdef DEVKIT

VOID
ExpTryToBootMediaROM(
    VOID
    );

#endif

VOID
ExpDecryptEEPROM(
    VOID
    );

ULONG
ExpDetectSettingsError(
    VOID
    );

VOID
ExpCopyLastUEMError(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpDecryptEEPROM)
#pragma alloc_text(INIT, ExpCopyLastUEMError)
#pragma alloc_text(INIT, ExpDetectSettingsError)
#ifdef DEVKIT
#pragma alloc_text(INIT, ExpTryToBootMediaROM)
#endif
#endif

//
// Define global static data used during initialization.
//

#if DBG
const XBOX_KRNL_VERSION XboxKrnlVersion = { VER_PRODUCTVERSION | 0x8000 };
#else
const XBOX_KRNL_VERSION XboxKrnlVersion = { VER_PRODUCTVERSION };
#endif

XBOX_HARDWARE_INFO XboxHardwareInfo;
DECLSPEC_STICKY PLAUNCH_DATA_PAGE LaunchDataPage = NULL;
DECLSPEC_STICKY ULONG XboxBootFlags;

#ifdef DEVKIT
PVOID KiDbgClockInt;
PVOID KiDbgProfInt;
PSWAP_CONTEXT_NOTIFY_ROUTINE KiDbgCtxSwapNotify;
PVOID KiDpcDispatchNotify;
DECLSPEC_STICKY BOOLEAN ExpDisableDebugMonitor;
XProfpGlobals ExpCallAttributedProfileData;

INITIALIZED_OBJECT_STRING_RDATA(ExpDVDXbdmDLL, "\\Device\\CdRom0\\xbdm.dll");
INITIALIZED_OBJECT_STRING_RDATA(ExpHDXbdmDLL, "\\Device\\Harddisk0\\Partition1\\xbdm.dll");
INITIALIZED_OBJECT_STRING_RDATA(ExpCdRomBootROMString, "\\Device\\CdRom0\\XBOXROM.BIN");
INITIALIZED_OBJECT_STRING_RDATA(ExpHardDiskBootROMString, "\\Device\\Harddisk0\\Partition1\\XBOXROM.BIN");
#endif // DEVKIT

//
// Various encryption keys used by Xbox:
//
//  EEPROM key -
//      This key is stored in the boot loader (encrypted by the master key in MCPX).
//      The boot loader passes it to the kernel on a cold reboot.
//      The kernel uses it to decrypt the encryption section of the EEPROM
//      and then throws it away (except that we need to let the manufacturing
//      program access it during the final system integration stage).
//
//  Hard disk key -
//      This key is stored in the EEPROM (encrypted by the EEPROM key above).
//
//  LAN key -
//      This key's raw data is stored in the first XBE that is run from a cold
//      boot and modified by the CERT key.
//
//  Signature key -
//      This key's raw data is stored in the first XBE that is run from a cold
//      boot and modified by the CERT key.
//
//  CERT key -
//      This key is stored in the boot loader (encrypted by the master key in MCPX).
//      The boot loader passes it to the kernel on a cold reboot.
//      It's used to decrypt keys in the title CERT header.
//
DECLSPEC_STICKY XBOX_KEY_DATA XboxEEPROMKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxHDKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxLANKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxSignatureKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxAlternateSignatureKeys[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];
DECLSPEC_STICKY XBOX_KEY_DATA XboxCERTKey;

//
// Game region setting is stored in the encrypted section
// of the EEPROM and is read into a global variable during the boot process.
//
DECLSPEC_STICKY ULONG XboxGameRegion = XC_GAME_REGION_MANUFACTURING;

VOID
ExpInitializeExecutive(
    VOID
    )
/*++

Routine Description:

    This routine is called from the kernel initialization routine during
    bootstrap to initialize the executive and all of its subcomponents.
    Each subcomponent is potentially called twice to perform phase 0, and
    then phase 1 initialization. During phase 0 initialization, the only
    activity that may be performed is the initialization of subcomponent
    specific data. Phase 0 initilaization is performed in the context of
    the kernel start up routine with initerrupts disabled. During phase 1
    initialization, the system is fully operational and subcomponents may
    do any initialization that is necessary.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the hardware information flags.
    //

#ifdef DEVKIT
    XboxHardwareInfo.Flags |= XBOX_HW_FLAG_DEVKIT_KERNEL;
#endif

#ifdef FOCUS
    XboxHardwareInfo.Flags |= XBOX_480P_MACROVISION_ENABLED;
#endif

#ifdef ARCADE
    XboxHardwareInfo.Flags |= XBOX_HW_FLAG_ARCADE;
#endif

    //
    // Initialize the Hardware Architecture Layer (HAL).
    //

    if (KeHasQuickBooted) {
        HalInitSystemPhase0Quick();
    } else {
        HalInitSystemPhase0();
    }

    //
    // Initialize the memory manager.
    //

    HalPulseHardwareMonitorPin();
    MmInitSystem();

    //
    // Initialize the object manager.
    //

    if (!ObInitSystem()) {
        KeBugCheck(OBJECT_INITIALIZATION_FAILED);
    }

    if (!PsInitSystem()) {
        KeBugCheck(PROCESS_INITIALIZATION_FAILED);
    }
}

VOID
ExpDecryptEEPROM(
    VOID
    )
{
    NTSTATUS Status;
    ULONG Type, Length;
    XBOX_ENCRYPTED_SETTINGS EncryptedSettings;
    ULONG Temp;

    ASSERT(sizeof(EncryptedSettings) == EEPROM_ENCRYPTED_SECTION_SIZE);
    ASSERT(sizeof(EncryptedSettings.Checksum) == XC_SERVICE_DIGEST_SIZE);

    //
    // Read the encrypted section of the EEPROM
    //
    Status = ExQueryNonVolatileSetting(
                XC_ENCRYPTED_SECTION,
                &Type,
                &EncryptedSettings,
                sizeof(EncryptedSettings),
                &Length);

    if (!NT_SUCCESS(Status)) {
        goto DecryptEEPROMError;
    }
#ifdef DEVKIT
    //
    // On DEVKIT box, the data can be either encrypted or unencrypted.
    // On retail box, it's always encrypted.
    //
    // NOTE: We treat the EEPROM as unencrypted if the confounder
    // field is all 0's.
    //
    if (((PULONG) EncryptedSettings.Confounder)[0] | ((PULONG) EncryptedSettings.Confounder)[1])
#endif
    {
        #define RC4_CONFOUNDER_LEN FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, Confounder)

        UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
        UCHAR Confounder[RC4_CONFOUNDER_LEN];
        UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
        UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
        UCHAR* Data;
        ULONG DataSize;

        Data = EncryptedSettings.HDKey;
        DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);
        memcpy(Confounder, EncryptedSettings.Confounder, RC4_CONFOUNDER_LEN);

        //
        // HMAC the checksum into the key
        //
        XcHMAC(
            XboxEEPROMKey,
            XBOX_KEY_LENGTH,
            EncryptedSettings.Checksum,
            XC_SERVICE_DIGEST_SIZE,
            NULL,
            0,
            LocalKey);

        //
        // Use the generated key as the RC4 encryption key
        //
        XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

        //
        // Decrypt confounder and data
        //
        XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, Confounder);
        XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

        //
        // Now verify the checksum.
        //
        XcHMAC(
            XboxEEPROMKey,
            XBOX_KEY_LENGTH,
            Confounder,
            RC4_CONFOUNDER_LEN,
            Data,
            DataSize,
            Checksum);

        //
        // Decrypt is successful only if checksum matches
        //
        if (memcmp(Checksum, EncryptedSettings.Checksum, XC_SERVICE_DIGEST_SIZE) != 0) {
            Status = STATUS_IMAGE_CHECKSUM_MISMATCH;
            goto DecryptEEPROMError;
        }
    }

    memcpy(XboxHDKey, EncryptedSettings.HDKey, XBOX_KEY_LENGTH);
    XboxGameRegion = EncryptedSettings.GameRegion;

#ifdef DEVKIT
    //
    // For now, force a valid game region
    //
    if (XboxGameRegion == 0) {
        XboxGameRegion = XC_GAME_REGION_MANUFACTURING;
    }

#endif

    //
    // Verify that only one game region bit is set, ignoring the manufacturing
    // region.
    //

    Temp = XboxGameRegion & (~XC_GAME_REGION_MANUFACTURING);
    if ((Temp & (Temp - 1)) != 0) {
        Status = STATUS_IMAGE_GAME_REGION_VIOLATION;
        goto DecryptEEPROMError;
    }

    return;

DecryptEEPROMError:
    KdPrint(("INIT: failed to decrypt EEPROM settings (status=%08x).\n", Status));

#ifndef DEVKIT
    //
    // Write LED state to indicate that there was a problem with the EEPROM
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_RED_STATE1 | SMC_LED_STATES_RED_STATE3);

    PsTerminateSystemThread(STATUS_SUCCESS);
#endif
}

#ifdef DEVKIT

DECLSPEC_INITDATA UCHAR ExpBldrEncryptionKey[] = {
    0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
    0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
};

VOID
ExpTryToBootMediaROM(
    VOID
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID RelocatedBootLoader;
    PVOID ROMShadow;
    struct RC4_KEYSTRUCT RC4KeyStruct;
    BOOLEAN LoadedFromCdRom;
    PUCHAR BootOptions;
    PBLDR_LOAD_MEDIA_ROM_ROUTINE LoadMediaROMRoutine;

    //
    // Attempt to open a ROM from the CD-ROM.
    //

    LoadedFromCdRom = TRUE;

    InitializeObjectAttributes(&ObjectAttributes, &ExpCdRomBootROMString,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&FileHandle, GENERIC_READ, &ObjectAttributes,
        &IoStatusBlock, 0, FILE_SYNCHRONOUS_IO_NONALERT |
        FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {

        //
        // Attempt to open a ROM from the hard drive.
        //

        LoadedFromCdRom = FALSE;

        ObjectAttributes.ObjectName = &ExpHardDiskBootROMString;

        status = NtOpenFile(&FileHandle, GENERIC_READ, &ObjectAttributes,
            &IoStatusBlock, 0, FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING);
    }

    //
    // If no ROM file was found, then use the current ROM to boot.
    //

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Allocate the boot loader memory at the boot loader's relocated base
    // physical address.
    //

    RelocatedBootLoader = MmAllocateContiguousMemoryEx(BLDR_BLOCK_SIZE,
        BLDR_RELOCATED_ORIGIN, BLDR_RELOCATED_ORIGIN + BLDR_BLOCK_SIZE - 1, 0,
        PAGE_READWRITE);

    if (RelocatedBootLoader == NULL) {
        DbgPrint("INIT: Failed to allocate boot loader memory.\n");
        NtClose(FileHandle);
        return;
    }

    //
    // Allocate the media ROM memory.  If we cannot allocate a block of this
    // size at this early phase of initialization, then something's wrong, but
    // we'll attempt to continue initializing the system.  We limit the top
    // address of the allocation so that we don't run into the bottom of the
    // PFN database where we may try to place a copy of the kernel's initialized
    // data section.
    //

    ROMShadow = MmAllocateContiguousMemoryEx(ROM_SHADOW_SIZE, 0, 48 * 1024 * 1024,
        0, PAGE_READWRITE);

    if (ROMShadow == NULL) {
        DbgPrint("INIT: Failed to allocate shadow ROM memory.\n");
        NtClose(FileHandle);
        return;
    }

    //
    // Read the media ROM into memory.  If this fails, we'll take our chances
    // and continue booting with the current ROM.
    //

    status = NtReadFile(FileHandle, NULL, NULL, NULL, &IoStatusBlock,
        ROMShadow, ROM_SHADOW_SIZE, NULL);

    NtClose(FileHandle);

    if (!NT_SUCCESS(status) || (IoStatusBlock.Information != ROM_SHADOW_SIZE)) {
        DbgPrint("INIT: Failed to read ROM from media.\n");
        MmFreeContiguousMemory(ROMShadow);
        MmFreeContiguousMemory(RelocatedBootLoader);
        return;
    }

    //
    // This is an ugly hack to prevent downgrading to the July release - we refuse
    // to load the xboxrom.bin on its CD based on the absence of a number in the
    // "trim values version" part of the init table (at DWORD 0x1B == offset 0x6C)
    //

    if (LoadedFromCdRom &&
        (((PULONG)ROMShadow)[0x1B] == 0x00000000)) {
        DbgPrint("INIT: Failed to load ROM from media because it is too old.\n");
        MmFreeContiguousMemory(ROMShadow);
        MmFreeContiguousMemory(RelocatedBootLoader);
        return;
    }

    //
    // Decrypt the boot loader in the media ROM image.
    //

    rc4_key(&RC4KeyStruct, sizeof(ExpBldrEncryptionKey), ExpBldrEncryptionKey);
    rc4(&RC4KeyStruct, BLDR_BLOCK_SIZE, (PUCHAR)ROMShadow + ROM_SHADOW_SIZE -
        ROM_DEC_SIZE - BLDR_BLOCK_SIZE);

    //
    // Copy the boot loader to its relocated base physical address.
    //

    RtlCopyMemory(RelocatedBootLoader, (PUCHAR)ROMShadow + ROM_SHADOW_SIZE -
        ROM_DEC_SIZE - BLDR_BLOCK_SIZE, BLDR_BLOCK_SIZE);

    //
    // Modify the load options to indicate where the media ROM was loaded from.
    //

    BootOptions = (PUCHAR)(KSEG0_BASE + BLDR_RELOCATED_ORIGIN + sizeof(ULONG));

    if (LoadedFromCdRom) {
        strcat(BootOptions, " /SHADOW /CDBOOT");
        DbgPrint("INIT: Loaded kernel image from CD-ROM.\n");
    } else {
        strcat(BootOptions, " /SHADOW /HDBOOT");
        DbgPrint("INIT: Loaded kernel image from hard disk.\n");
    }

    if ((XboxBootFlags & XBOX_BOOTFLAG_DASHBOARDBOOT) != 0) {
        strcat(BootOptions, " /DBBOOT");
    }

    //
    // Compute the address of the load media ROM routine.  The pointer to the
    // routine is located immediately before the start address of the boot
    // loader.
    //

    LoadMediaROMRoutine =
        *((PBLDR_LOAD_MEDIA_ROM_ROUTINE*)((PUCHAR)RelocatedBootLoader +
        (*((PULONG_PTR)RelocatedBootLoader) - BLDR_BOOT_ORIGIN -
        sizeof(ULONG_PTR))));
    LoadMediaROMRoutine = (PBLDR_LOAD_MEDIA_ROM_ROUTINE)
        (MM_SYSTEM_PHYSICAL_MAP + (ULONG_PTR)LoadMediaROMRoutine);

    //
    // Stop the boot animation.
    //

    AniSetLogo(NULL, 0);
    AniTerminateAnimation();

    //
    // Notify the debugger that we're "rebooting".
    //

    DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);

    //
    // Load the kernel from the media ROM.
    //

    LoadMediaROMRoutine(MmGetPhysicalAddress(ROMShadow));
}

NTSTATUS
ExpStartDebugMonitor(
    VOID
    )
/*++

Routine Description:

    This routine starts the debug monitor on a development kit system.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    PVOID pvBase;
    NTSTATUS st;
    DMINIT dminit;
    ULONG (__stdcall *EntryPoint)(PVOID, PVOID, ULONG);
    extern PKDEBUG_ROUTINE KiDebugRoutine;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    FILE_NETWORK_OPEN_INFORMATION fni;
    IO_STATUS_BLOCK iosb;
    ULONG cPages;
    BOOLEAN fLoadCanFail;
    POBJECT_STRING postLoadFrom;

    memset(&dminit, 0, sizeof dminit);
    /* We insist on loading from the same location as the kernel.  If the
     * kernel loaded from ROM, we'll try to load from the HD, but we'll
     * allow the load to fail */
    if(XboxBootFlags & XBOX_BOOTFLAG_HDBOOT) {
        fLoadCanFail = FALSE;
        postLoadFrom = &ExpHDXbdmDLL;
    } else if(XboxBootFlags & XBOX_BOOTFLAG_CDBOOT) {
        dminit.Flags |= DMIFLAG_CDBOOT;
        fLoadCanFail = FALSE;
        postLoadFrom = &ExpDVDXbdmDLL;
    } else {
        fLoadCanFail = TRUE;
        postLoadFrom = &ExpHDXbdmDLL;
    }

    // Load the dm dll
    InitializeObjectAttributes(&oa, postLoadFrom, OBJ_CASE_INSENSITIVE, NULL,
        NULL);
    st = NtOpenFile(&h, FILE_EXECUTE, &oa, &iosb, 0,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(!NT_SUCCESS(st)) {
        goto ErrRet;
    }

    st = NtQueryInformationFile(h, &iosb, &fni, sizeof fni,
        FileNetworkOpenInformation);
    if(!NT_SUCCESS(st))
        goto ErrClose;
    pvBase = MmDbgAllocateMemory(fni.EndOfFile.LowPart, PAGE_READWRITE);
    if(pvBase == NULL) {
        st = STATUS_NO_MEMORY;
        goto ErrClose;
    }
    st = NtReadFile(h, NULL, NULL, NULL, &iosb, pvBase, fni.EndOfFile.LowPart,
        NULL);
    if(!NT_SUCCESS(st))
        goto ErrClose;
    try {
        st = LdrRelocateImage(pvBase, "xbdm", STATUS_SUCCESS,
            STATUS_CONFLICTING_ADDRESSES, STATUS_INVALID_IMAGE_FORMAT);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        st = GetExceptionCode();
    }
    if(!NT_SUCCESS(st)) {
        MmDbgFreeMemory(pvBase, fni.EndOfFile.LowPart);
ErrClose:
        NtClose(h);
ErrRet:
        if(fLoadCanFail) {
            DbgPrint("Failed to load any xbdm.dll!\n");
            return STATUS_SUCCESS;
        }
        return st;
    }
    NtClose(h);

    // The whole thing is finally loaded.  Set up the init parameters
    dminit.DebugRoutine = &KiDebugRoutine;
    dminit.LoadedModuleList = &KdLoadedModuleList;
    dminit.CtxSwapNotifyRoutine = (VOID**) &KiDbgCtxSwapNotify;
    dminit.DpcDispatchNotifyRoutine = (VOID**)&KiDpcDispatchNotify;
    dminit.XProfpDataPtr = &ExpCallAttributedProfileData;
    dminit.ClockIntRoutine = &KiDbgClockInt;
    dminit.ProfIntRoutine = &KiDbgProfInt;
    dminit.HalStartProfileRoutine = HalStartProfileInterrupt;
    dminit.HalStopProfileRoutine = HalStopProfileInterrupt;
    dminit.HalProfileIntervalRoutine = HalSetProfileInterval;
    dminit.DisallowXbdm = &ExpDisableDebugMonitor;

    EntryPoint = (PVOID)((ULONG_PTR) pvBase +
        RtlImageNtHeader(pvBase)->OptionalHeader.AddressOfEntryPoint);

    return (EntryPoint)(pvBase, &dminit, 0);
}

#endif // DEVKIT

ULONG
ExpDetectSettingsError(
    VOID
    )
/*++

Routine Description:

    Detect if clock/timezone/language settings are invalid

Arguments:

    None.

Return Value:

    0 if everything is ok
    Otherwise, a bit flag indicating which settings are bad

--*/
{
    ULONG errors = 0;
    NTSTATUS status;
    ULONG type, length;
    XBOX_USER_SETTINGS userSettings;

    //
    // Check if the CMOS data is valid.
    //
    if (!HalIsCmosValid()) {
        errors |= XLD_SETTINGS_CLOCK;
    } else {
        //
        // NOTE: Workaround for RTC hardware problem
        // Sometimes the clock would lose power but the flag bit isn't set.
        // We query the RTC time here and do a sanity check.
        // If the time is before 1/1/2001 or after 1/1/2101,
        // we'll assume the clock has gone bad.
        //
        LARGE_INTEGER time;
        KeQuerySystemTime(&time);
        if (time.QuadPart < 0x01c07385c89dc000i64 ||
            time.QuadPart > 0x02309034f02ac000i64) {
            KdPrint(("Bad real-time clock value: %08x%08x\n", time.HighPart, time.LowPart));
            errors |= XLD_SETTINGS_CLOCK;
        }
    }

    //
    // Read the user settings inside the EEPROM
    //
    status = ExQueryNonVolatileSetting(
                XC_MAX_OS,
                &type,
                &userSettings,
                sizeof(userSettings),
                &length);

    if (NT_SUCCESS(status)) {
        //
        // Check the language setting
        //
        if (userSettings.Language == XC_LANGUAGE_UNKNOWN)
            errors |= XLD_SETTINGS_LANGUAGE;

        //
        // Check the time zone setting
        //  NOTE: we assume the time zone isn't set if the name is empty.
        //
        if (XBOX_INVALID_TIMEZONE_SETTING(userSettings))
            errors |= XLD_SETTINGS_TIMEZONE;
    } else {
        //
        // Assume both language/timezone are invalid
        // if there is an EEPROM read error.
        //
        errors |= XLD_SETTINGS_TIMEZONE|XLD_SETTINGS_LANGUAGE;
    }

#if DBG
    if (errors) {
        DbgPrint("INIT: invalid clock/timezone/language settings - %x\n", errors);
    }
#endif

    return errors;
}


VOID
ExpCopyLastUEMError(
    VOID
    )
/*++

Routine Description:

    This rotutine copies the Last UEM error code from the EEPROM to the
    SMC error register.  This routine is called only when we are in the
    Manufacturing region.

Arguments:

    None.

Return Value:

    None

--*/
{
    EEPROM_LAYOUT EEPROMData;
    NTSTATUS Status;
    ULONG SettingType;
    ULONG SettingLength;
    XBOX_UEM_INFO* UEMInfo;

    UEMInfo = (XBOX_UEM_INFO*)&(EEPROMData.UEMInfo[0]);

    //
    // Read the EEPROM
    //

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &SettingType, &EEPROMData,
        sizeof(EEPROMData), &SettingLength);

    if (NT_SUCCESS(Status)) {

        //
        // If the last code is non-zero, write it to the SMC and then clear
        // it in the EEPROM
        //

        if (UEMInfo->LastCode != FATAL_ERROR_NONE) {

            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_WRITE_ERROR_CODE, UEMInfo->LastCode);

            UEMInfo->LastCode = 0;

            ExSaveNonVolatileSetting(XC_MAX_ALL, SettingType, &EEPROMData, SettingLength);
        }
    }
}



VOID
Phase1Initialization(
    IN PVOID Context
    )
{
    NTSTATUS status;
    LARGE_INTEGER UniversalTime;
    LARGE_INTEGER CmosTime;
    LARGE_INTEGER OldTime;
    TIME_FIELDS TimeFields;
    ULONG SettingsError;

    //
    // Initialize the Hardware Architecture Layer (HAL).
    //

    HalInitSystemPhase1();

    //
    // Initialize the system time and set the time the system was booted.
    //
    // N.B. This cannot be done until after the phase one initialization
    //      of the HAL Layer.
    //

    if (HalQueryRealTimeClock(&TimeFields) != FALSE) {

        if(TimeFields.Year < 2000 || TimeFields.Year > 2100 ||
            !RtlTimeFieldsToTime(&TimeFields, &CmosTime))
        {
            // use a bogus time value to indicate bogus clock
            CmosTime.HighPart = 0x20000001;
            CmosTime.LowPart = 0;
        }
        UniversalTime = CmosTime;
        KeSetSystemTime(&UniversalTime, &OldTime);

        KeBootTime = UniversalTime;
        KeBootTimeBias = 0;
    }

    //
    // Read the MCPX revision number.
    //

    HalReadPCISpace(
        0,
        XPCI_SLOT_NUMBER(LPCBRIDGE),
        8,
        &XboxHardwareInfo.McpRevision,
        sizeof(XboxHardwareInfo.McpRevision));

    //
    // NOTE: NV2A revision number is not found in the PCI config space.
    // Rather, it's in the LSB of the very first NV2A register.
    //

    XboxHardwareInfo.GpuRevision = (UCHAR) *((ULONG*) XPCICFG_GPU_MEMORY_REGISTER_BASE_0);

    //
    // Set the USB flag based on the MCP revision.  If the MCP is B03 (rev=b3) or
    // earlier, we are using a USB daughterboard.  For later revs, we don't use it.
    //

    if (XboxHardwareInfo.McpRevision <= 0xB3) {
        XboxHardwareInfo.Flags |= XBOX_HW_FLAG_INTERNAL_USB_HUB;
    }

    //
    // If the kernel is cold-booting, then do some additional work before
    // initializing the rest of the kernel.
    //

    if (!KeHasQuickBooted) {

        //
        // Decrypt the encrypted section of the EEPROM and save the hard disk
        // key and the game region information into global variables.
        //

        HalPulseHardwareMonitorPin();
        ExpDecryptEEPROM();

        //
        // Block if no AV pack is attached to the system.
        //

        HalPulseHardwareMonitorPin();
        HalBlockIfNoAVPack();

        //
        // Display the fatal error message if we've been rebooted for that
        // purpose.
        //

        if ((XboxBootFlags & XBOX_BOOTFLAG_DISPLAYFATALERROR) != 0) {

            HalWriteSMCLEDStates(SMC_LED_STATES_GREEN_STATE0 | SMC_LED_STATES_RED_STATE1 |
                SMC_LED_STATES_RED_STATE2 | SMC_LED_STATES_RED_STATE3);

            ExDisplayFatalError(FATAL_ERROR_REBOOT_ROUTINE);
        }

        //
        // Start the boot animation if this isn't a shadow boot.
        //

        if ((XboxBootFlags & XBOX_BOOTFLAG_SHADOW) == 0) {
            HalPulseHardwareMonitorPin();
            AniStartAnimation((XboxBootFlags & XBOX_BOOTFLAG_SHORTANIMATION) != 0);
        }
    }

    //
    // Initialize the IDE driver.
    //

    IdexChannelCreate();

#ifdef DEVKIT
    //
    // Try to load a ROM from the media.  Only do this if we haven't already
    // tried in an earlier boot from the system's real ROM or if we haven't
    // already been loaded from a shadow ROM.
    //

    if (!KeHasQuickBooted && !(XboxBootFlags & XBOX_BOOTFLAG_SHADOW)) {
        ExpTryToBootMediaROM();
    }

    //
    // Start the debug monitor.
    //

    if (!ExpDisableDebugMonitor) {

        status = ExpStartDebugMonitor();

        if (!NT_SUCCESS(status)) {
            KdPrint(("INIT: Debug monitor failed to start (status=%08x).\n", status));
            KeBugCheckEx(PHASE1_INITIALIZATION_FAILED, status, 0, 0, 0);
        }
    }
#endif

    //
    // If the kernel is cold-booting, and we're not booting from a kernel loaded
    // from the CD-ROM and the console isn't configured for the manufacturing
    // content, then check if we should force a boot into the dashboard.  If we
    // detect a settinngs error, we'll try to bring up a title anyway, because
    // titles signed in the manufacturing region are allowed to run with
    // invalid settings; we'll fall back to the dash if we don't find such a
    // title.
    //

    if (!KeHasQuickBooted &&
        ((XboxBootFlags & XBOX_BOOTFLAG_CDBOOT) == 0) &&
        ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0)) {

        HalPulseHardwareMonitorPin();

        if ((SettingsError = ExpDetectSettingsError()) != 0) {
            XeLoadTitleImage(SettingsError);
        } else if ((XboxBootFlags & XBOX_BOOTFLAG_DASHBOARDBOOT) != 0) {
            XeLoadDashboardImageWithReason(XLD_LAUNCH_DASHBOARD_BOOT, 0);
        } else if ((XboxBootFlags & XBOX_BOOTFLAG_TRAYEJECT) != 0) {
            XeLoadImageAfterTrayEjectBoot();
        } else if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) {
            XeLoadDashboardImage();
        } else {
            XeLoadTitleImage(0);
        }

    } else {
        XeLoadTitleImage(0);
    }

    //
    // If the kernel is cold-booting, then do some additional work before
    // handing control over to the XBE image.
    //

    if (!KeHasQuickBooted) {

        HalPulseHardwareMonitorPin();

        //
        // Notify the SMC that we've finished initializing the system.  The SMC
        // uses this as a signal to know whether or not we need to be notified
        // when the user powers down the system.  After this point, we do need
        // to be notified because we may have I/O buffers that need to be
        // flushed.
        //

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_READY,
            SMC_OS_READY_READY);

        //
        // Stop the boot animation.
        //

        AniTerminateAnimation();

        //
        // If we are in manufacturing mode and have not quickbooted, handle the
        // copying the last UEM error code from EEPROM to SMC error code register.
        //

        if (XboxGameRegion & XC_GAME_REGION_MANUFACTURING) {
            ExpCopyLastUEMError();
        }

        //
        // Discard the kernel's initialization code section.  All of the code in
        // the INIT section applies to a cold boot only.
        //

        MmDiscardInitSection();
    }

    //
    // Relocate persistent contiguous memory allocations in order to present
    // roughly the same physical memory layout to an XBE image.
    //

    MmRelocatePersistentMemory();

    //
    // Invoke the entry point of the XBE image.
    //

    XeImageHeader()->AddressOfEntryPoint();

    //
    // The XBE startup code runs the main title thread on a new thread, so
    // terminate this initialization thread.
    //

    PsTerminateSystemThread(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\init\image.h ===
const BYTE g_Image[] =
{

0x7C, 0x7E, 0x00, 0xA3, 0x07, 0xA3, 0x4A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x96, 0x00, 0xA3, 0x92, 0x00, 0xA3, 0x62, 0x03, 0xA3, 0x07, 0xA3, 
0x4A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x92, 0x04, 0xA3, 0x03, 0xA3, 
0x05, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 0x0B, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA7, 0x03, 0xA5, 0x07, 0xA9, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA7, 0x03, 0xA5, 0x07, 0xA7, 0x0B, 0xA7, 0x05, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x42, 0x03, 
0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x22, 0x00, 0xA3, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x3E, 0x03, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x0F, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x05, 0xA5, 0x0D, 
0xA5, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x09, 0xA9, 0x3E, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x0F, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x4A, 0x03, 0xA3, 0x07, 0xA7, 0x07, 0xAB, 0x0D, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 
0xA7, 0x05, 0xA9, 0x05, 0xAB, 0x05, 0xA3, 0x07, 0xA7, 0x03, 0xA7, 0x0B, 
0xA7, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 
0xA7, 0x05, 0xA3, 0x16, 0x04, 0xA3, 0xFE, 0x04, 0xA3, 0xD2, 0x0D, 0xA7, 
0x05, 0xA3, 0x8A, 0x00, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x4E, 0x00, 0xA7, 0x32, 0x00, 0xA3, 0x76, 0x00, 0xA5, 0x6E, 0x00, 
0xA3, 0xAE, 0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x8A, 0x00, 0xA3, 0x05, 
0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 0xA3, 0x07, 0xA3, 
0x2E, 0x00, 0xA3, 0x72, 0x00, 0xA3, 0x05, 0xA3, 0x6A, 0x00, 0xA3, 0xAE, 
0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA7, 0x07, 0xA7, 
0x05, 0xA5, 0x0B, 0xA5, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x0D, 0xA5, 
0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 
0x07, 0xA3, 0x03, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA7, 0x03, 0xA5, 
0x07, 0xA5, 0x05, 0xA7, 0x09, 0xA3, 0x09, 0xA3, 0x07, 0xAB, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xAB, 0xAA, 0x02, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x0B, 0xA3, 0x0B, 0xA3, 0x07, 0xA5, 0x09, 
0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0xAE, 
0x02, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA9, 
0x07, 0xA3, 0x0B, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0D, 0xA5, 0x05, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x0B, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0xAE, 0x02, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0x0B, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0xAE, 0x02, 0xA3, 0x09, 0xA3, 0x07, 0xA7, 0x05, 0xA7, 0x03, 
0xA7, 0x07, 0xA7, 0x09, 0xA5, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 
0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x0B, 
0xA7, 0x07, 0xAF, 0x05, 0xA5, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x0F, 0xA5, 0x07, 0x22, 0xA0, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 0x9E, 0x04, 0xA3, 0x0B, 
0xA3, 0xE6, 0x04, 0xA3, 0x0B, 0xA3, 0xF4, 0x43, 0x00, 0xA3, 0x03, 0xA3, 
0x42, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x1A, 0x01, 0xA3, 0x0F, 0xA3, 
0x62, 0x00, 0xA3, 0xFE, 0x02, 0xA3, 0x03, 0xA3, 0x42, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x1A, 0x01, 0xA3, 0x0F, 0xA3, 0x62, 0x00, 0xA3, 0xFE, 
0x02, 0xA3, 0x03, 0xA9, 0x03, 0xA7, 0x05, 0xA5, 0x0D, 0xA5, 0x05, 0xA9, 
0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA7, 0x03, 0xA5, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA7, 0x0B, 0xA9, 0x03, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA9, 0x05, 0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 
0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA9, 
0x03, 0xA5, 0x05, 0xA9, 0xDA, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x05, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x09, 0xA3, 0x0F, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA9, 0x0B, 0xA5, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x07, 0xA5, 
0x0B, 0xA3, 0x07, 0xAB, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA7, 
0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xAB, 0x03, 0xA3, 
0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x0F, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x0D, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0D, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x09, 
0xA3, 0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xA7, 
0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xAF, 0x05, 0xA7, 0x0D, 0xA9, 
0x03, 0xA7, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA7, 0x03, 0xA5, 0x0B, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 
0x09, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0xDE, 0x03, 
0xA3, 0x07, 0xA3, 0xF2, 0x04, 0xA7, 0xBA, 0x0D, 0xA9, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x3A, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x4E, 0x00, 0xA3, 0x07, 0xA3, 0x3E, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 
0x03, 0xA3, 0x46, 0x00, 0xA3, 0x62, 0x00, 0xA5, 0xAE, 0x02, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x3A, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x4E, 0x00, 0xA3, 0x05, 0xA3, 0x42, 0x00, 0xA3, 0x3E, 
0x00, 0xA3, 0x4E, 0x00, 0xA3, 0x62, 0x00, 0xA3, 0xB2, 0x02, 0xA3, 0x07, 
0xA5, 0x05, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 0xA5, 0x05, 
0xA9, 0x0D, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xAB, 0x05, 0xA9, 0x05, 0xA5, 0x05, 
0xA9, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA5, 0x07, 0xA9, 0x05, 0xA7, 0x03, 
0xA5, 0x09, 0xA7, 0x05, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA7, 0x05, 
0xA5, 0x05, 0xA9, 0x86, 0x02, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x0D, 0xA5, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 
0x22, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x82, 0x02, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA9, 0x09, 0xA3, 0x07, 0xAB, 0x03, 0xA3, 
0x07, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x03, 0xA3, 0x03, 0xA9, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 
0x0D, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 
0x03, 0xA3, 0x07, 0xA3, 0x82, 0x02, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x0D, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 
0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 
0xA3, 0x07, 0xA3, 0x82, 0x02, 0xA9, 0x03, 0xA3, 0x05, 0xA5, 0x03, 0xA5, 
0x05, 0xA7, 0x0B, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 
0x07, 0xA3, 0x05, 0xAB, 0x07, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 
0x05, 0xA5, 0x0B, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xAB, 0x07, 0xA7, 
0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0xC0, 0x4A, 0x00, 0xA3, 0x76, 0x02, 
0xA3, 0x9A, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x96, 
0x00, 0xA3, 0x6E, 0x00, 0xA3, 0x0F, 0xA3, 0x46, 0x00, 0xA3, 0x26, 0x00, 
0xA3, 0x07, 0xA3, 0x3A, 0x00, 0xA3, 0x3E, 0x02, 0xA3, 0x9A, 0x00, 0xA3, 
0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x26, 0x01, 0xA3, 0x6E, 0x00, 
0xA3, 0x8A, 0x02, 0xA3, 0x07, 0xA7, 0x0D, 0xA5, 0x07, 0xA7, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA7, 0x05, 0xA3, 0x03, 0xA7, 0x0F, 0xA5, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA7, 0x05, 0xA5, 0x07, 0xAB, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x09, 0xA7, 
0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 
0x05, 0xA5, 0x05, 0xA3, 0x05, 0xA7, 0x09, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x1A, 0x02, 0xA3, 0x0D, 
0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x0F, 0xA3, 0x05, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x0D, 0xA3, 0x03, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x16, 0x02, 0xA3, 0x09, 0xA7, 0x09, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA9, 0x09, 0xA7, 
0x05, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x07, 0xA5, 0x09, 0xA3, 0x07, 0xA7, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x0B, 0xA7, 0x16, 0x02, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x0D, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x16, 
0x02, 0xA9, 0x03, 0xA7, 0x0B, 0xA5, 0x07, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 
0x07, 0xA7, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 
0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 0xA7, 0x05, 0xA9, 
0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x09, 0xA7, 0x09, 0xA7, 
0x03, 0xA7, 0x05, 0xA3, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 0x07, 0xA7, 0x07, 0xA5, 0x05, 0xA7, 
0x05, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA5, 0x07, 0xA7, 
0x05, 0xA3, 0x62, 0x03, 0xA3, 0xFE, 0x04, 0xA3, 0x82, 0x0D, 0xA3, 0x07, 
0xA3, 0x72, 0x00, 0xA3, 0x5A, 0x00, 0xA3, 0x0F, 0xA3, 0x36, 0x00, 0xA3, 
0x86, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x32, 
0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x22, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0xFA, 0x01, 0xA3, 0x07, 0xA3, 0x72, 0x00, 0xA3, 0xB2, 
0x00, 0xA3, 0x86, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x3A, 
0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x22, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0xFA, 0x01, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x05, 0xA7, 
0x03, 0xA5, 0x07, 0xA5, 0x0B, 0xA7, 0x05, 0xA3, 0x0B, 0xA7, 0x05, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA7, 
0x0B, 0xA9, 0x05, 0xA5, 0x0B, 0xA7, 0x05, 0xA7, 0x05, 0xA9, 0x05, 0xA7, 
0x05, 0xAB, 0x05, 0xA5, 0x0B, 0xA7, 0x05, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 
0x03, 0xA5, 0x0B, 0xA3, 0x03, 0xA7, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 
0x05, 0xA3, 0x05, 0xA3, 0xC2, 0x01, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x03, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 
0xA3, 0x09, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA5, 0xC6, 0x01, 0xA3, 0x07, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x0B, 0xA7, 0x03, 0xA3, 0x0B, 0xA5, 0x05, 0xA9, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x09, 0xA5, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA9, 0x0B, 0xA7, 0x03, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 
0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 0x09, 0xA3, 
0x07, 0xAB, 0x09, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0xC6, 0x01, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x0F, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x0F, 0xA3, 
0x07, 0xA5, 0x0F, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0xC6, 0x01, 0xAB, 0x07, 
0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA7, 0x03, 
0xA3, 0x09, 0xA7, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA9, 0x05, 0xA7, 0x07, 0xA7, 0x07, 
0xA7, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x0B, 
0xA7, 0x03, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 
0xA3, 0x07, 0xA7, 0x05, 0xA7, 0x0B, 0xA9, 0x03, 0xA7, 0x09, 0xA3, 0x05, 
0xA7, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x3E, 0x03, 0xA3, 0xFE, 0x04, 0xA3, 0xEC, 0x44, 0x00, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0x09, 
0xA3, 0x8E, 0x00, 0xA5, 0x76, 0x00, 0xA3, 0x46, 0x00, 0xA3, 0x02, 0x03, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0xA2, 
0x00, 0xA3, 0x7A, 0x00, 0xA3, 0x4E, 0x03, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA9, 0x03, 0xA7, 0x0B, 0xA9, 0x03, 0xA3, 
0x07, 0xA7, 0x05, 0xA7, 0x05, 0xA9, 0x03, 0xA9, 0x05, 0xA7, 0x0B, 0xAB, 
0x0B, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 
0x05, 0xA9, 0x05, 0xA5, 0xCE, 0x02, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0xC6, 
0x02, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 
0x0B, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 
0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xAB, 0xC2, 0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 
0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0xCE, 0x02, 0xA3, 0x05, 0xA3, 
0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 
0x03, 0xA7, 0x09, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x07, 0xA7, 0x05, 0xA9, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x0B, 0xAB, 0x0B, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA5, 
0x05, 0xA7, 0x03, 0xA3, 0x07, 0xAB, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA3, 0x92, 0x03, 0xA3, 0x07, 0xA3, 0xF2, 
0x04, 0xA7, 0x06, 0x0E, 0xA7, 0x03, 0xA3, 0x0B, 0xA3, 0x7E, 0x00, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x3A, 0x00, 0xA3, 0x0D, 0xA3, 0x6E, 0x00, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x32, 0x00, 0xA3, 0x05, 0xA3, 0x22, 0x00, 0xA5, 
0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0xC2, 0x02, 0xA3, 0x07, 0xA5, 0x96, 
0x00, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x52, 0x00, 0xA3, 0x6A, 
0x00, 0xA3, 0x07, 0xA5, 0x3E, 0x00, 0xA3, 0x2E, 0x00, 0xA3, 0x0D, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0xC2, 0x02, 0xA3, 0x09, 0xA9, 0x05, 0xA3, 0x03, 
0xA7, 0x07, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA7, 0x03, 0xA5, 0x0B, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x09, 0xA7, 0x05, 0xA7, 0x03, 0xA3, 0x05, 
0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xAF, 0x0D, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x03, 0xA3, 0x0B, 
0xAB, 0x0D, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x8A, 
0x02, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x07, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x07, 0xA5, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x8E, 0x02, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x05, 
0xA9, 0x09, 0xA3, 0x09, 0xA7, 0x09, 0xA5, 0x07, 0xA5, 0x05, 0xA3, 0x05, 
0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x07, 
0xA7, 0x0B, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x0D, 0xA5, 0x05, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x8E, 0x02, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x0F, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 
0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x92, 0x02, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 
0xA7, 0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x05, 0xA7, 0x05, 
0xA3, 0x03, 0xA7, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA9, 0x03, 0xA7, 0x0D, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x03, 0xA3, 0x0B, 0xAB, 0x0B, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x40, 
0x4D, 0x00, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x7A, 0x00, 0xA5, 0x46, 0x00, 0xA3, 0x05, 0xA3, 0x1E, 0x01, 
0xA3, 0x6A, 0x00, 0xA3, 0x22, 0x02, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x3A, 
0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 0xA3, 0x4A, 0x00, 0xA3, 
0x2A, 0x01, 0xA3, 0x6A, 0x00, 0xA3, 0x26, 0x02, 0xA3, 0x05, 0xA3, 0x03, 
0xA7, 0x05, 0xA5, 0x03, 0xA7, 0x03, 0xA5, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 
0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA9, 0x07, 0xA5, 0x09, 0xA5, 0x05, 
0xA7, 0x05, 0xA9, 0x05, 0xA5, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x03, 
0xA9, 0x05, 0xA9, 0x05, 0xA5, 0x0B, 0xA9, 0x03, 0xA7, 0x07, 0xA7, 0x0B, 
0xA5, 0x07, 0xA7, 0x03, 0xA7, 0x03, 0xA7, 0x03, 0xA5, 0x07, 0xA5, 0x05, 
0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA9, 0x05, 
0xA5, 0x22, 0x02, 0xA3, 0x05, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x26, 0x02, 0xA3, 0x05, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA9, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x07, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xAB, 0x09, 0xA3, 0x07, 0xA3, 0x03, 
0xA7, 0x05, 0xA5, 0x0B, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA9, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x2A, 0x02, 0xA5, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x22, 0x00, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x0F, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x2A, 0x02, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 
0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x07, 0xA3, 0x07, 0xA7, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x09, 0xA9, 0x05, 0xA7, 
0x03, 0xA7, 0x0D, 0xA5, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA7, 
0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 0xCE, 0x03, 
0xA3, 0xFE, 0x04, 0xA3, 0x1E, 0x0A, 0xA3, 0xA2, 0x00, 0xA3, 0x5E, 0x02, 
0xA3, 0x09, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0x36, 0x00, 0xA3, 0x2E, 0x00, 0xA5, 0x6E, 0x00, 
0xA3, 0x0F, 0xA3, 0x09, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x32, 0x00, 
0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x0E, 0x02, 0xA3, 0x09, 0xA3, 0x36, 0x00, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0x36, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 
0x6A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 
0x0F, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x12, 0x02, 0xA3, 
0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA9, 0x09, 0xA5, 0x07, 0xA7, 0x03, 0xA9, 0x05, 0xA5, 
0x03, 0xA7, 0x07, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x07, 0xA3, 
0x05, 0xA5, 0x0D, 0xA3, 0x09, 0xA3, 0x07, 0xAB, 0x05, 0xA9, 0x05, 0xA7, 
0x05, 0xAB, 0x09, 0xA7, 0x09, 0xA3, 0x05, 0xA7, 0x0B, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA3, 
0x05, 0xA5, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 
0xDA, 0x01, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x0B, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x22, 0x00, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0xDE, 0x01, 
0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA9, 0x05, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x03, 
0xA3, 0x0B, 0xA3, 0x03, 0xA9, 0x22, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x0D, 0xA7, 0x07, 0xA3, 0x07, 0xA7, 0x07, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x03, 0xA9, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 
0xE2, 0x01, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x22, 
0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 
0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x22, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA5, 0xE2, 0x01, 0xA5, 0x07, 0xA7, 0x05, 0xAB, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA9, 0x09, 0xA5, 0x07, 0xA7, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA5, 
0x05, 0xA7, 0x03, 0xA3, 0x0B, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x07, 0x22, 
0xA0, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x0B, 0xA7, 0x07, 
0xA3, 0x07, 0xA7, 0x09, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA7, 0x0B, 
0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x5A, 0x03, 0xA3, 0x0B, 0xA3, 0xE6, 0x04, 0xA3, 0x0B, 0xA3, 0x94, 
0x3F, 0x00, 0x2A, 0xA0, 0x09, 0xAD, 0x22, 0x00, 0xA5, 0x26, 0x00, 0xA5, 
0x05, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 
0xA5, 0x26, 0x00, 0xA5, 0x46, 0x00, 0xA5, 0x2E, 0x00, 0xA7, 0x09, 0xAF, 
0x56, 0x00, 0xA5, 0x22, 0x00, 0xA5, 0x05, 0xA7, 0x52, 0x02, 0xA5, 0x22, 
0x00, 0xA5, 0x05, 0xA5, 0x0F, 0xA9, 0x22, 0x00, 0xA5, 0x22, 0x00, 0xA5, 
0x03, 0xA5, 0x0F, 0xA5, 0x05, 0xA7, 0x05, 0xAD, 0x0B, 0xA5, 0x26, 0x00, 
0xA5, 0x46, 0x00, 0xA5, 0x05, 0xA5, 0x07, 0xAB, 0x22, 0x00, 0xA5, 0x03, 
0xA5, 0x0D, 0x26, 0xA0, 0x05, 0x26, 0xA0, 0x0B, 0xA5, 0x62, 0x02, 0xA5, 
0x26, 0x00, 0xAD, 0x0D, 0xA5, 0x05, 0xA5, 0x0B, 0xAB, 0x03, 0xA5, 0x09, 
0x26, 0xA0, 0x07, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x0F, 0xAD, 0x36, 
0x00, 0xAD, 0x03, 0xA5, 0x0B, 0xA5, 0x0D, 0x2A, 0xA0, 0x0F, 0xA5, 0x26, 
0x00, 0xA5, 0x0D, 0xAB, 0x03, 0xA5, 0x4E, 0x02, 0xAD, 0x0D, 0xA5, 0x05, 
0xA5, 0x09, 0x2A, 0xA0, 0x09, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 
0x05, 0xA5, 0x0F, 0xA5, 0x0F, 0xAF, 0x09, 0xA5, 0x26, 0x00, 0xA5, 0x46, 
0x00, 0xA5, 0x0F, 0x22, 0xA0, 0x07, 0x26, 0xA0, 0x0F, 0xA5, 0x03, 0xA7, 
0x09, 0xA9, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x46, 0x02, 0xA5, 0x03, 
0xA5, 0x03, 0xA5, 0x0B, 0xAD, 0x4A, 0x00, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 
0x0D, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 
0x03, 0xAB, 0x32, 0x00, 0xAD, 0x0D, 0xA5, 0x22, 0x00, 0xA9, 0x03, 0xA5, 
0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 
0xA5, 0x42, 0x02, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x3E, 0x00, 0x22, 0xA0, 
0x0B, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x07, 0x22, 0xA0, 0x09, 0xA5, 0x2A, 
0x00, 0xA5, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x46, 0x00, 0xA7, 0x07, 0xA5, 
0x03, 0x2A, 0xA0, 0x05, 0x26, 0xA0, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x03, 
0xA5, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x52, 0x02, 0xA5, 0x0D, 0x2A, 
0xA0, 0x07, 0xA5, 0x09, 0xA5, 0x09, 0xA5, 0x05, 0xAB, 0x0D, 0xA5, 0x0F, 
0xA5, 0x07, 0xA5, 0x05, 0xAB, 0x0D, 0xA5, 0x07, 0xA5, 0x07, 0xA5, 0x22, 
0x00, 0xA5, 0x0D, 0xA9, 0x07, 0xA5, 0x0B, 0xA5, 0x0F, 0xA9, 0x03, 0xA5, 
0x0F, 0xA5, 0x26, 0x00, 0xA9, 0x0D, 0xA5, 0x05, 0xAB, 0x52, 0x02, 0xA5, 
0x22, 0x00, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x09, 0xA5, 0x09, 0xA5, 0x05, 
0xA5, 0x26, 0x00, 0xA5, 0x0F, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 
0x0B, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x09, 0xA9, 0x0B, 0xAD, 
0x03, 0xA5, 0x0B, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA9, 0x0F, 0xA5, 0x2A, 
0x00, 0xA5, 0x0D, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x42, 0x02, 0xA5, 0x0F, 
0xA5, 0x09, 0xA5, 0x09, 0x22, 0xA0, 0x09, 0xAB, 0x0D, 0x2A, 0xA0, 0x09, 
0xA9, 0x09, 0xA9, 0x03, 0xA5, 0x0B, 0xA9, 0x09, 0xA5, 0x05, 0xAB, 0x05, 
0xA5, 0x0F, 0xA7, 0x03, 0xA7, 0x0B, 0xA7, 0x0D, 0xAD, 0x05, 0xA5, 0x0F, 
0xA7, 0x0B, 0xA9, 0x0F, 0xAB, 0x0F, 0xA5, 0x28, 0x25, 0x00, 0xA5, 0x4E, 
0x00, 0xA5, 0x8A, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA7, 
0x36, 0x00, 0xA5, 0x0F, 0xA5, 0x2E, 0x00, 0xA5, 0x0D, 0x2A, 0xA0, 0x46, 
0x00, 0xA5, 0x26, 0x00, 0xA5, 0x2A, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA5, 
0x0B, 0xA5, 0x2A, 0x00, 0xA5, 0x52, 0x01, 0xA5, 0x07, 0xA5, 0x03, 0xA5, 
0x5E, 0x00, 0xA5, 0x22, 0x00, 0xAF, 0x09, 0xAD, 0x05, 0x26, 0xA0, 0x4E, 
0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA7, 0x36, 0x00, 0xA5, 
0x0F, 0xA5, 0x03, 0xAD, 0x09, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x03, 0xA9, 
0x03, 0xA5, 0x05, 0xA5, 0x32, 0x00, 0xA9, 0x22, 0x00, 0xA5, 0x2A, 0x00, 
0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x0D, 0xA5, 0x05, 0xA7, 0x0B, 0xA5, 0x07, 
0xA5, 0x42, 0x01, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x56, 0x00, 0x22, 0xA0, 
0x26, 0x00, 0xA5, 0x07, 0xA5, 0x07, 0xA5, 0x26, 0x00, 0xA5, 0x4A, 0x00, 
0x26, 0xA0, 0x07, 0x22, 0xA0, 0x3A, 0x00, 0xA5, 0x0F, 0xA5, 0x26, 0x00, 
0xAD, 0x03, 0xA5, 0x03, 0x2A, 0xA0, 0x05, 0xA5, 0x09, 0xA5, 0x0B, 0xA5, 
0x05, 0xA5, 0x0B, 0x22, 0xA0, 0x0D, 0xAF, 0x07, 0xA5, 0x0B, 0xAD, 0x0B, 
0x2A, 0xA0, 0x09, 0xA5, 0x2E, 0x01, 0xA7, 0x07, 0xA9, 0x07, 0xA9, 0x05, 
0xA5, 0x05, 0xA5, 0x0D, 0xA5, 0x05, 0xA5, 0x26, 0x00, 0xA5, 0x07, 0xA5, 
0x07, 0xA5, 0x22, 0x00, 0xA5, 0x52, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 
0xA5, 0x46, 0x00, 0xA9, 0x0B, 0xA5, 0x2E, 0x00, 0xA5, 0x0D, 0xA5, 0x0D, 
0xA5, 0x05, 0xA5, 0x09, 0xA5, 0x07, 0x2A, 0xA0, 0x0B, 0xA7, 0x05, 0xA5, 
0x07, 0xA9, 0x05, 0xA5, 0x07, 0xA5, 0x22, 0x00, 0xA5, 0x2E, 0x00, 0xA5, 
0x05, 0xA5, 0x09, 0xA5, 0x2E, 0x01, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 0x03, 
0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x0F, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 
0x07, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x09, 0x22, 
0xA0, 0x26, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 0xA5, 0x07, 0x22, 
0xA0, 0x07, 0xA5, 0x03, 0xA7, 0x07, 0xA5, 0x2E, 0x00, 0xAD, 0x05, 0xA5, 
0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x46, 0x00, 0xA5, 0x07, 
0xA5, 0x0B, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x0F, 0xA5, 0x03, 0xAB, 0x0D, 
0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x2A, 0x01, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 
0x03, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x0F, 0xA5, 0x07, 0xA5, 0x0F, 0xA7, 
0x0F, 0xA7, 0x0B, 0xA9, 0x5A, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 
0xA5, 0x3A, 0x00, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA7, 0x07, 0xA5, 0x03, 
0xA5, 0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x07, 0x22, 0xA0, 
0x0B, 0xA7, 0x07, 0xA5, 0x0B, 0xA5, 0x03, 0xA7, 0x09, 0xA5, 0x0D, 0xA5, 
0x26, 0x00, 0xAD, 0x03, 0xA5, 0x0B, 0xA5, 0x26, 0x01, 0xA5, 0x03, 0xA5, 
0x05, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x0D, 0xA5, 
0x07, 0xA5, 0x0D, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x0D, 0xA5, 0x6E, 0x00, 
0xA5, 0x0B, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x36, 0x00, 0xA5, 0x0F, 0xA5, 
0x03, 0xA5, 0x0D, 0xA9, 0x07, 0xA5, 0x03, 0xA5, 0x03, 0xA9, 0x03, 0xA5, 
0x05, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x09, 0xA5, 0x09, 0xA9, 0x07, 0xA5, 
0x0B, 0xA5, 0x26, 0x00, 0xA5, 0x0B, 0xA5, 0x22, 0x00, 0xA5, 0x07, 0xA5, 
0x03, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x0E, 0x01, 0xA5, 0x07, 0xA5, 0x03, 
0xA9, 0x07, 0xA9, 0x05, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x0B, 
0xA5, 0x07, 0xA5, 0x09, 0xAB, 0x0D, 0xA5, 0x66, 0x00, 0xA5, 0x0D, 0xA5, 
0x03, 0xA5, 0x05, 0xA5, 0x36, 0x00, 0xA5, 0x0F, 0xA5, 0x03, 0xAD, 0x05, 
0xAD, 0x03, 0xA5, 0x03, 0xA5, 0x0D, 0xA5, 0x05, 0xA5, 0x03, 0xA5, 0x0F, 
0xA5, 0x09, 0xA5, 0x0D, 0xA5, 0x07, 0xA5, 0x0B, 0xA5, 0x2A, 0x00, 0xA5, 
0x07, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x0D, 0xA5, 0x03, 0xA5, 0x0D, 0xA9, 
0x86, 0x01, 0xA5, 0x03, 0xA9, 0x09, 0xA7, 0x09, 0xA5, 0x05, 0xA7, 0x2A, 
0x00, 0xA5, 0x5E, 0x00, 0xA7, 0x26, 0x00, 0xA7, 0x46, 0x00, 0xA5, 0x0F, 
0xA5, 0x2A, 0x00, 0xA7, 0x03, 0xA7, 0x05, 0xA5, 0x0B, 0xA7, 0x07, 0xA7, 
0x22, 0x00, 0x22, 0xA0, 0x0D, 0xA5, 0x03, 0xA7, 0x0F, 0xAD, 0x0D, 0xA5, 
0x05, 0xA5, 0x05, 0xAB, 0x07, 0xAB, 0x07, 0xA7, 0x22, 0x00, 0xA5, 0x84, 
0x82, 0x00, 

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\complete.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    complete.c

Abstract:

   This module implements the executive I/O completion object. Functions are
   provided to create, open, query, and wait for I/O completion objects.

Author:

    David N. Cutler (davec) 25-Feb-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "iop.h"

#define IopFreeMiniPacket(MiniPacket) ExFreePool(MiniPacket)

NTSTATUS
NtCreateIoCompletion (
    IN PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Count OPTIONAL
    )

/*++

Routine Description:

    This function creates an I/O completion object, sets the maximum
    target concurrent thread count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    IoCompletionHandle - Supplies a pointer to a variable that receives
        the I/O completion object handle.

    DesiredAccess - Supplies the desired types of access for the I/O
        completion object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    Count - Supplies the target maximum  number of threads that should
        be concurrently active. If this parameter is not specified, then
        the number of processors is used.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    HANDLE Handle;
    PVOID IoCompletion;
    NTSTATUS Status;

    //
    // Allocate I/O completion object.
    //

    Status = ObCreateObject(&IoCompletionObjectType,
                            ObjectAttributes,
                            sizeof(KQUEUE),
                            (PVOID *)&IoCompletion);

    //
    // If the I/O completion object was successfully allocated, then
    // initialize the object and attempt to insert it in the handle
    // table of the current process.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeQueue((PKQUEUE)IoCompletion, Count);
        Status = ObInsertObject(IoCompletion,
                                ObjectAttributes,
                                0,
                                &Handle);

        //
        // If the I/O completion object was successfully inserted in
        // the handle table of the current process, then attempt to
        // write the handle value. If the write attempt fails, then
        // do not report an error. When the caller attempts to access
        // the handle value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            *IoCompletionHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PIO_COMPLETION_BASIC_INFORMATION IoCompletionInformation
    )

/*++

Routine Description:

    This function queries the state of an I/O completion object and returns
    the requested information in the specified record structure.

Arguments:

    IoCompletionHandle - Supplies a handle to an I/O completion object.

    IoCompletionInformation - Supplies a pointer to a record that receives
        the requested information.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PVOID IoCompletion;
    LONG Depth;
    NTSTATUS Status;

    //
    // Reference the I/O completion object by handle.
    //

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       &IoCompletionObjectType,
                                       &IoCompletion);

    //
    // If the reference was successful, then read the current state of
    // the I/O completion object, dereference the I/O completion object,
    // fill in the information structure, and return the structure length
    // if specified. If the write of the I/O completion information or
    // the return length fails, then do not report an error. When the
    // caller accesses the information structure or length an access
    // violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Depth = KeReadStateQueue((PKQUEUE)IoCompletion);
        ObDereferenceObject(IoCompletion);

        IoCompletionInformation->Depth = Depth;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    )
/*++

Routine Description:

    This function allows the caller to queue an Irp to an I/O completion
    port and specify all of the information that is returned out the other
    end using NtRemoveIoCompletion.

Arguments:

    IoCompletionHandle - Supplies a handle to the io completion port
        that the caller intends to queue a completion packet to

    KeyContext - Supplies the key context that is returned during a call
        to NtRemoveIoCompletion

    ApcContext - Supplies the apc context that is returned during a call
        to NtRemoveIoCompletion

    IoStatus - Supplies the IoStatus->Status data that is returned during
        a call to NtRemoveIoCompletion

    IoStatusInformation - Supplies the IoStatus->Information data that
        is returned during a call to NtRemoveIoCompletion

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{
    PVOID IoCompletion;
    NTSTATUS Status;

    PAGED_CODE();

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       &IoCompletionObjectType,
                                       &IoCompletion);

    if (NT_SUCCESS(Status)) {
        Status = IoSetIoCompletion(IoCompletion,
                                   KeyContext,
                                   ApcContext,
                                   IoStatus,
                                   IoStatusInformation);

        ObDereferenceObject(IoCompletion);
        }
    return Status;

}

NTSTATUS
NtRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function removes an entry from an I/O completion object. If there
    are currently no entries available, then the calling thread waits for
    an entry.

Arguments:

    Completion - Supplies a handle to an I/O completion object.

    KeyContext - Supplies a pointer to a variable that receives the key
        context that was specified when the I/O completion object was
        assoicated with a file object.

    ApcContext - Supplies a pointer to a variable that receives the
        context that was specified when the I/O operation was issued.

    IoStatus - Supplies a pointer to a variable that receives the
        I/O completion status.

    Timeout - Supplies a pointer to an optional time out value.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PLARGE_INTEGER CapturedTimeout;
    PLIST_ENTRY Entry;
    PVOID IoCompletion;
    PIRP Irp;
    NTSTATUS Status;
    PVOID LocalApcContext;
    PVOID LocalKeyContext;
    IO_STATUS_BLOCK LocalIoStatusBlock;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;

    //
    // Get previous processor mode and probe the I/O context, status,
    // and timeout if necessary.
    //

    CapturedTimeout = NULL;
    if (ARGUMENT_PRESENT(Timeout)) {
        CapturedTimeout = Timeout;
    }

    //
    // Reference the I/O completion object by handle.
    //

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       &IoCompletionObjectType,
                                       &IoCompletion);

    //
    // If the reference was successful, then attempt to remove an entry
    // from the I/O completion object. If an entry is removed from the
    // I/O completion object, then capture the completion information,
    // release the associated IRP, and attempt to write the completion
    // inforamtion. If the write of the completion infomation fails,
    // then do not report an error. When the caller attempts to access
    // the completion information, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Entry = KeRemoveQueue((PKQUEUE)IoCompletion,
                              KernelMode,
                              CapturedTimeout);

        //
        // N.B. The entry value returned can be the address of a list
        //      entry, STATUS_USER_APC, or STATUS_TIMEOUT.
        //

        if (((LONG_PTR)Entry == STATUS_TIMEOUT) ||
            ((LONG_PTR)Entry == STATUS_USER_APC)) {
            Status = (NTSTATUS)((LONG_PTR)Entry);

        } else {

            //
            // Set the completion status, capture the completion
            // information, deallocate the associated IRP, and
            // attempt to write the completion information.
            //

            Status = STATUS_SUCCESS;

            MiniPacket = CONTAINING_RECORD(Entry,
                                           IOP_MINI_COMPLETION_PACKET,
                                           ListEntry);

            if ( MiniPacket->PacketType == IopCompletionPacketIrp ) {
                Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
                LocalApcContext = Irp->Overlay.AsynchronousParameters.UserApcContext;
                LocalKeyContext = (PVOID)Irp->Tail.CompletionKey;
                LocalIoStatusBlock = Irp->IoStatus;
                IoFreeIrp(Irp);

            } else {

                LocalApcContext = MiniPacket->ApcContext;
                LocalKeyContext = (PVOID)MiniPacket->KeyContext;
                LocalIoStatusBlock.Status = MiniPacket->IoStatus;
                LocalIoStatusBlock.Information = MiniPacket->IoStatusInformation;
                IopFreeMiniPacket(MiniPacket);
            }

            *ApcContext = LocalApcContext;
            *KeyContext = LocalKeyContext;
            *IoStatusBlock = LocalIoStatusBlock;
        }

        //
        // Deference I/O completion object.
        //

        ObDereferenceObject(IoCompletion);
    }

    //
    // Return service status.
    //

    return Status;
}

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    )
/*++

Routine Description:

    This function allows the caller to queue an Irp to an I/O completion
    port and specify all of the information that is returned out the other
    end using NtRemoveIoCompletion.

Arguments:

    IoCompletion - Supplies a a pointer to the completion port that the caller
        intends to queue a completion packet to.

    KeyContext - Supplies the key context that is returned during a call
        to NtRemoveIoCompletion.

    ApcContext - Supplies the apc context that is returned during a call
        to NtRemoveIoCompletion.

    IoStatus - Supplies the IoStatus->Status data that is returned during
        a call to NtRemoveIoCompletion.

    IoStatusInformation - Supplies the IoStatus->Information data that
        is returned during a call to NtRemoveIoCompletion.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PIOP_MINI_COMPLETION_PACKET MiniPacket;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Attempt to allocate the minpacket from the per processor lookaside list.
    //

    MiniPacket = ExAllocatePoolWithTag(sizeof(*MiniPacket), ' pcI');

    //
    // If a minipacket was successfully allocated, then initialize and
    // queue the packet to the specified I/O completion queue.
    //

    if (MiniPacket != NULL) {
        MiniPacket->PacketType = IopCompletionPacketMini;
        MiniPacket->KeyContext = KeyContext;
        MiniPacket->ApcContext = ApcContext;
        MiniPacket->IoStatus = IoStatus;
        MiniPacket->IoStatusInformation = IoStatusInformation;
        KeInsertQueue((PKQUEUE)IoCompletion, &MiniPacket->ListEntry);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
IopDeleteIoCompletion (
    IN PVOID Object
    )

/*++

Routine Description:

    This function is the delete routine for I/O completion objects. Its
    function is to release all the entries in the repsective completion
    queue and to rundown all threads that are current associated.

Arguments:

    Object - Supplies a pointer to an executive I/O completion object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY FirstEntry;
    PIRP Irp;
    PLIST_ENTRY NextEntry;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;

    //
    // Rundown threads associated with the I/O completion object and get
    // the list of unprocessed I/O completion IRPs.
    //

    FirstEntry = KeRundownQueue((PKQUEUE)Object);
    if (FirstEntry != NULL) {
        NextEntry = FirstEntry;
        do {
            MiniPacket = CONTAINING_RECORD(NextEntry,
                                           IOP_MINI_COMPLETION_PACKET,
                                           ListEntry);

            NextEntry = NextEntry->Flink;
            if (MiniPacket->PacketType == IopCompletionPacketIrp) {
                Irp = CONTAINING_RECORD(MiniPacket, IRP, Tail.Overlay.ListEntry);
                IoFreeIrp(Irp);

            } else {
                IopFreeMiniPacket(MiniPacket);
            }

        } while (FirstEntry != NextEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\devctrl.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module contains the code to implement the NtDeviceIoControlFile and
    NtFsControlFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 16-Oct-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iop.h"

NTSTATUS
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the device driver associated with the file
    handle.  It is up to the driver to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        device driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the device driver.  Whether or not the buffer is actually optional
        is dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    //
    // Simply invoke the common routine that implements both device and file
    // system I/O controls.
    //

    return IopXxxControlFile( FileHandle,
                              Event,
                              ApcRoutine,
                              ApcContext,
                              IoStatusBlock,
                              IoControlCode,
                              InputBuffer,
                              InputBufferLength,
                              OutputBuffer,
                              OutputBufferLength,
                              TRUE );
}

NTSTATUS
NtFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the file system associated with the file
    handle.  It is up to the file system to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        file system.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the file system.  Whether or not the buffer is actually optional
        is dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    //
    // Simply invoke the common routine that implements both device and file
    // system I/O controls.
    //

    return IopXxxControlFile( FileHandle,
                              Event,
                              ApcRoutine,
                              ApcContext,
                              IoStatusBlock,
                              IoControlCode,
                              InputBuffer,
                              InputBufferLength,
                              OutputBuffer,
                              OutputBufferLength,
                              FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract

    This module contains the code to implement the NtCreateFile
    and NtOpenFile system services.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iop.h"

NTSTATUS
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )

/*++

Routine Description:

    This service opens or creates a file, or opens a device.  It is used to
    establish a file handle to the open device/file that can then be used
    in subsequent operations to perform I/O operations on.  For purposes of
    readability, files and devices are treated as "files" throughout the
    majority of this module and the system service portion of the I/O system.
    The only time a distinction is made is when it is important to determine
    which is really being accessed.  Then a distinction is also made in the
    comments.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.  This
        parameter only has an affect if the file is created.  Further, if
        not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    CreateDisposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to do the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         AllocationSize,
                         FileAttributes,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         0 );
}

NTSTATUS
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )

/*++

Routine Description:

    This service opens a file or a device.  It is used to establish a file
    handle to the open device/file that can then be used in subsequent
    operations to perform I/O operations on.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    OpenOptions - Caller options for how to perform the open.

Return Value:

    The function value is the final completion status of the open/create
    operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         FILE_OPEN,
                         OpenOptions,
                         0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\dir.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module contains the code to implement the NtQueryDirectoryFile
    system service for the NT I/O system.

--*/

#include "iop.h"

NTSTATUS
NtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN POBJECT_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service operates on a directory file specified by the FileHandle
    parameter.  The service returns information about files in the directory
    specified by the file handle.  The ReturnSingleEntry parameter specifies
    that only a single entry should be returned rather than filling the buffer.
    The actual number of files whose information is returned, is the smallest
    of the following:

        o  One entry, if the ReturnSingleEntry parameter is TRUE.

        o  The number of files whose information fits into the specified
           buffer.

        o  The number of files that exist.

        o  One entry if the optional FileName parameter is specified.

    If the optional FileName parameter is specified, then the only information
    that is returned is for that single file, if it exists.  Note that the
    file name may not specify any wildcard characters according to the naming
    conventions of the target file system.  The ReturnSingleEntry parameter is
    simply ignored.

    The information that is obtained about the files in the directory is based
    on the FileInformationClass parameter.  The legal values are as follows:

        o  FileNamesInformation

        o  FileDirectoryInformation

        o  FileFullDirectoryInformation

Arguments:

    FileHandle - Supplies a handle to the directory file for which information
        should be returned.

    Event - Supplies an optional event to be set to the Signaled state when
        the query is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        query is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the contents of the directory.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specfies the type of information that is to be
        returned about the files in the specified directory.

    ReturnSingleEntry - Supplies a BOOLEAN value that, if TRUE, indicates that
        only a single entry should be returned.

    FileName - Optionally supplies a file name within the specified directory.

    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the
        scan should be restarted from the beginning.  This parameter must be
        set to TRUE by the caller the first time the service is invoked.

Return Value:

    The status returned is success if the query operation was properly queued
    to the I/O system.  Once the operation completes, the status of the query
    can be determined by examining the Status field of the I/O status block.

--*/

{
    NTSTATUS status;
    BOOLEAN synchronousIo;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    PIRP irp;
    PKEVENT eventObject = (PKEVENT) NULL;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->FileObject = fileObject;

    //
    // Pass the address of the user's buffer so the driver has access to
    // it.  It is now the driver's responsibility to do everything.
    //

    irp->UserBuffer = FileInformation;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryDirectory.Length = Length;
    irpSp->Parameters.QueryDirectory.FileInformationClass = FileInformationClass;
    irpSp->Parameters.QueryDirectory.FileName = FileName;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\fsrtl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsrtl.c

Abstract:

    This module implements shared file system driver routines.

--*/

#include "iop.h"

BOOLEAN
IopCopyTemplateFileName(
    IN POBJECT_STRING TargetTemplateFileName,
    OUT POBJECT_STRING SourceTemplateFileName
    )
/*++

Routine Description:

    This routine copies the template file name from the source to the
    destination and validates that the template string is valid (for example,
    an asterisk must be followed by the end of the string or a period).

Arguments:

    TargetTemplateFileName - Specifies the target template file name.

    SourceTemplateFileName - Specifies the source template file name.

Return Value:

    Returns TRUE if the source template file name is valid, else FALSE.

--*/
{
    BOOLEAN SeenAsterisk;
    POSTR SourceTemplateFileNameCurrent;
    POSTR SourceTemplateFileNameEnd;
    POSTR TargetTemplateFileNameCurrent;
    OCHAR Char;

    SeenAsterisk = FALSE;

    SourceTemplateFileNameCurrent = SourceTemplateFileName->Buffer;
    SourceTemplateFileNameEnd = (POSTR)((PUCHAR)SourceTemplateFileNameCurrent +
        SourceTemplateFileName->Length);
    TargetTemplateFileNameCurrent = TargetTemplateFileName->Buffer;

    while (SourceTemplateFileNameCurrent < SourceTemplateFileNameEnd) {

        Char = *SourceTemplateFileNameCurrent++;

        //
        // Force an asterisk to be followed by a period.
        //

        if (SeenAsterisk) {

            if (Char != OTEXT('.')) {
                return FALSE;
            }

            SeenAsterisk = FALSE;
        }

        if (Char == OTEXT('*')) {
            SeenAsterisk = TRUE;
        } else if (Char >= OTEXT('a') && Char <= OTEXT('z')) {
            Char = (OCHAR)(Char - (OTEXT('a') - OTEXT('A')));
        }

        *TargetTemplateFileNameCurrent++ = Char;
    }

    return TRUE;
}

NTSTATUS
IoCreateDirectoryEnumContext(
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRECTORY_ENUM_CONTEXT *ReturnedDirectoryEnumContext
    )
/*++

Routine Description:

    This routine allocates and prepares a directory enumeration context given
    the supplied template file name.  The template file name is also validated.

Arguments:

    TemplateFileName - Specifies the template file name for the enumeration.

    ReturnedDirectoryEnumContext - Specifies the location to receive the
        allocated directory enumeration context.

Return Value:

    Status of operation.

--*/
{
    ULONG TemplateFileNameLength;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;

    if ((TemplateFileName == NULL) || (TemplateFileName->Length == 0) ||
        (TemplateFileName->Length == sizeof(OCHAR)) &&
            (TemplateFileName->Buffer[0] == OTEXT('*'))) {

        //
        // No template name was specified or else "*" was specified, so we'll
        // match all file names.
        //

        TemplateFileNameLength = 0;

    } else {
        TemplateFileNameLength = TemplateFileName->Length;
    }

    //
    // Allocate and zero initialize the directory enumeration context.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)ExAllocatePoolWithTag(
        sizeof(DIRECTORY_ENUM_CONTEXT) + TemplateFileNameLength, 'eDoI');

    if (DirectoryEnumContext == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(DirectoryEnumContext, sizeof(DIRECTORY_ENUM_CONTEXT));

    if (TemplateFileNameLength != 0) {

        //
        // A template name was specified.  Convert the name to uppercase and
        // store it in the directory enumeration context.
        //

        DirectoryEnumContext->TemplateFileName.Length =
            (USHORT)TemplateFileNameLength;
        DirectoryEnumContext->TemplateFileName.MaximumLength =
            (USHORT)TemplateFileNameLength;
        DirectoryEnumContext->TemplateFileName.Buffer =
            (POSTR)((PUCHAR)DirectoryEnumContext +
            sizeof(DIRECTORY_ENUM_CONTEXT));

        if (!IopCopyTemplateFileName(&DirectoryEnumContext->TemplateFileName,
            TemplateFileName)) {
            ExFreePool(DirectoryEnumContext);
            return STATUS_INVALID_PARAMETER;
        }
    }

    *ReturnedDirectoryEnumContext = DirectoryEnumContext;

    return STATUS_SUCCESS;
}

BOOLEAN
IoIsNameInExpression(
    IN POBJECT_STRING TemplateFileName,
    IN POBJECT_STRING FileName
    )
/*++

Routine Description:

    This routine checks if the supplied file name matches the supplied search
    specification template.

Arguments:

    TemplateFileName - Specifies the search specification.

    FileName - Specifies the file name to match against the template.

Return Value:

    Returns TRUE if the file name matches the template file name, else FALSE.

--*/
{
    POSTR TemplateFileNameCurrent;
    POSTR TemplateFileNameEnd;
    POSTR FileNameCurrent;
    POSTR FileNameEnd;
    OCHAR Char;
    OCHAR TemplateChar;

    ASSERT(TemplateFileName->Length > 0);

    //
    // If we somehow get a name with no characters in it, reject it.
    //

    if (FileName->Length == 0) {
        return FALSE;
    }

    TemplateFileNameCurrent = TemplateFileName->Buffer;
    TemplateFileNameEnd = (POSTR)((PUCHAR)TemplateFileNameCurrent +
        TemplateFileName->Length);
    FileNameCurrent = FileName->Buffer;
    FileNameEnd = (POSTR)((PUCHAR)FileNameCurrent + FileName->Length);

    while (TemplateFileNameCurrent < TemplateFileNameEnd) {

        TemplateChar = *TemplateFileNameCurrent++;

        if (TemplateChar == OTEXT('*')) {

            //
            // If the asterisk is the last character in the string, then consume
            // the rest of the file name.
            //

            if (TemplateFileNameCurrent == TemplateFileNameEnd) {
                return TRUE;
            }

            //
            // Only allow an asterisk to be followed by the start of an
            // extension.  This has already been verified by
            // IoCopyTemplateFileName.
            //

            ASSERT(*TemplateFileNameCurrent == OTEXT('.'));
            TemplateFileNameCurrent++;

            //
            // Consume characters from the file name until we find the start of
            // an extension or the end of the string.
            //

            do {

                if (FileNameCurrent == FileNameEnd) {
                    break;
                }

                Char = *FileNameCurrent++;

            } while (Char != OTEXT('.'));

            continue;
        }

        //
        // If we're out of characters to match in the file name, then the
        // template is longer than the name, so fail the match.
        //

        if (FileNameCurrent == FileNameEnd) {
            return FALSE;
        }

        Char = *FileNameCurrent++;

        if (TemplateChar != OTEXT('?')) {

            //
            // Upcase the character if necessary.
            //

            if (Char >= OTEXT('a') && Char <= OTEXT('z')) {
                Char = (OCHAR)(Char - (OTEXT('a') - OTEXT('A')));
            }

            //
            // If the character doesn't match the template, then we're done.
            //

            if (Char != TemplateChar) {
                return FALSE;
            }
        }
    }

    //
    // We ran out of characters in the template.  If we consumed the entire
    // file name, then this is a match.
    //

    return (BOOLEAN)(FileNameCurrent == FileNameEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\internal.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    internal.c

Abstract:

    This module contains the internal subroutines used by the I/O system.

--*/

#include "iop.h"

VOID
IopUserRundown(
    IN PKAPC Apc
    );

NTSTATUS
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked internally by those system services that attempt
    to allocate an IRP and fail.  This routine cleans up the file object
    and any event object that has been references and releases any locks
    that were taken out.

Arguments:

    FileObject - Pointer to the file object being worked on.

    EventObject - Optional pointer to a referenced event to be dereferenced.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    PAGED_CODE();

    //
    // Begin by dereferencing the event, if one was specified.
    //

    if (ARGUMENT_PRESENT( EventObject )) {
        ObDereferenceObject( EventObject );
    }

    //
    // Release the synchronization semaphore if it is currently held and
    // dereference the file object.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopReleaseFileObjectLock( FileObject );
    }

    ObDereferenceObject( FileObject );

    return STATUS_INSUFFICIENT_RESOURCES;
}

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine is invoked to allocate an IRP when there are no appropriate
    packets remaining on the look-aside list, and no memory was available
    from the general non-paged pool, and yet, the code path requiring the
    packet has no way of backing out and simply returning an error.  There-
    fore, it must allocate an IRP.  Hence, this routine is called to allocate
    that packet.

Arguments:

    StackSize - Supplies the number of IRP I/O stack locations that the
        packet must have when allocated.

Return Value:

    A pointer to the allocated I/O Request Packet.

--*/

{
    PIRP irp;
    LARGE_INTEGER interval;

    //
    // Keeping attemting to allocate the IRP normally.
    //

    irp = IoAllocateIrp(StackSize);
    while (!irp) {
        interval.QuadPart = -1000 * 1000 * 50; // 50 Msec.
        KeDelayExecutionThread(KernelMode, FALSE, &interval);
        irp = IoAllocateIrp(StackSize);
    }

    return irp;
}

VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked when the reference count on a device object
    transitions to a zero and the driver is mark for unload or device has
    been marked for delete. This means that it may be possible to actually
    unload the driver or delete the device object.  If all
    of the devices have a reference count of zero, then the driver is
    actually unloaded.  Note that in order to ensure that this routine is
    not invoked twice, at the same time, on two different processors, the
    I/O database spin lock is still held at this point.

Arguments:

    DeviceObject - Supplies a pointer to one of the driver's device objects,
        namely the one whose reference count just went to zero.

    Irql - Specifies the IRQL of the processor at the time that the I/O
        database lock was acquired.

Return Value:

    None.

--*/

{
    if (DeviceObject->DeletePending) {

        KeLowerIrql(Irql);

        //
        // Remove this device object from the driver object's list.
        //

        if (DeviceObject->DriverObject->DriverDeleteDevice != NULL) {

            DeviceObject->DriverObject->DriverDeleteDevice( DeviceObject );

        } else {

            //
            // Finally, dereference the object so it is deleted.
            //

            ObDereferenceObject( DeviceObject );
        }
    }
}

VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine executes as a special kernel APC routine in the context of
    the thread which originally requested the I/O operation which is now
    being completed.

    This routine performs the following tasks:

        o   A check is made to determine whether the specified request ended
            with an error status.  If so, and the error code qualifies as one
            which should be reported to an error port, then an error port is
            looked for in the thread/process.   If one exists, then this routine
            will attempt to set up an LPC to it.  Otherwise, it will attempt to
            set up an LPC to the system error port.

        o   Copy I/O status.

        o   Set event, if any and dereference if appropriate.

        o   Dequeue the IRP from the thread queue as pending I/O request.

        o   Queue APC to thread, if any.

        o   If no APC is to be queued, then free the packet now.


Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1 - Supplies a pointer to an argument that contains the
        address of the original file object for this I/O operation.

    SystemArgument2 - Supplies a pointer to an argument that contains an
        argument that is used by this routine only in the case of STATUS_REPARSE.

Return Value:

    None.

--*/
{
#define SynchronousIo( Irp, FileObject ) (  \
    (Irp->Flags & IRP_SYNCHRONOUS_API) ||   \
    (FileObject == NULL ? 0 : FileObject->Flags & FO_SYNCHRONOUS_IO) )

    PIRP irp;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );

    //
    // Begin by getting the address of the I/O Request Packet.  Also, get
    // the address of the current thread and the address of the original file
    // object for this I/O operation.
    //

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );
    thread = PsGetCurrentThread();
    fileObject = (PFILE_OBJECT) *SystemArgument1;

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( irp->IoStatus.Status != 0xffffffff );

    //
    // Check to see whether or not the I/O operation actually completed.  If
    // it did, then proceed normally.  Otherwise, cleanup everything and get
    // out of here.
    //

    if (!NT_ERROR( irp->IoStatus.Status ) ||
        (NT_ERROR( irp->IoStatus.Status ) &&
        irp->PendingReturned &&
        !SynchronousIo( irp, fileObject ))) {

        PVOID port = NULL;
        PVOID key;
        BOOLEAN createOperation = FALSE;

        //
        // If there is an I/O completion port object associated w/this request,
        // save it here so that the file object can be dereferenced.
        //

        if (fileObject && fileObject->CompletionContext) {
            port = fileObject->CompletionContext->Port;
            key = fileObject->CompletionContext->Key;
        }

        //
        // Copy the I/O status from the IRP into the caller's I/O status
        // block.
        //
        //
        // Since HasOverlappedIoCompleted and GetOverlappedResult only
        // look at the Status field of the UserIosb to determine if the
        // IRP has completed, the Information field must be written
        // before the Status field.
        //

        irp->UserIosb->Information = irp->IoStatus.Information;
        irp->UserIosb->Status = irp->IoStatus.Status;

        //
        // Determine whether the caller supplied an event that needs to be set
        // to the Signaled state.  If so, then set it; otherwise, set the event
        // in the file object to the Signaled state.
        //
        // It is possible for the event to have been specified as a PKEVENT if
        // this was an I/O operation hand-built for an FSP or an FSD, or
        // some other types of operations such as synchronous I/O APIs.  In
        // any of these cases, the event was not referenced since it is not an
        // object manager event, so it should not be dereferenced.
        //
        // Also, it is possible for there not to be a file object for this IRP.
        // This occurs when an FSP is doing I/O operations to a device driver on
        // behalf of a process doing I/O to a file.  The file object cannot be
        // dereferenced if this is the case.  If this operation was a create
        // operation then the object should not be dereferenced either.  This
        // is because the reference count must be one or it will go away for
        // the caller (not much point in making an object that just got created
        // go away).
        //

        if (irp->UserEvent) {
            (VOID) KeSetEvent( irp->UserEvent, 0, FALSE );
            if (fileObject) {
                if (!(irp->Flags & IRP_SYNCHRONOUS_API)) {
                    ObDereferenceObject( irp->UserEvent );
                }
                if (fileObject->Flags & FO_SYNCHRONOUS_IO && !(irp->Flags & IRP_OB_QUERY_NAME)) {
                    (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
                    fileObject->FinalStatus = irp->IoStatus.Status;
                }
                if (irp->Flags & IRP_CREATE_OPERATION) {
                    createOperation = TRUE;
                    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
                }
            }
        } else if (fileObject) {
            (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
            fileObject->FinalStatus = irp->IoStatus.Status;
            if (irp->Flags & IRP_CREATE_OPERATION) {
                createOperation = TRUE;
                irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
            }
        }

        //
        // Dequeue the packet from the thread's pending I/O request list.
        //

        IopDequeueThreadIrp( irp );

        //
        // If the caller requested an APC, queue it to the thread.  If not, then
        // simply free the packet now.
        //

        if (irp->Overlay.AsynchronousParameters.UserApcRoutine) {
            KeInitializeApc( &irp->Tail.Apc,
                             &thread->Tcb,
                             IopUserCompletion,
                             (PKRUNDOWN_ROUTINE) IopUserRundown,
                             (PKNORMAL_ROUTINE) irp->Overlay.AsynchronousParameters.UserApcRoutine,
                             IopApcRoutineMode(irp->Overlay.AsynchronousParameters.UserApcRoutine),
                             irp->Overlay.AsynchronousParameters.UserApcContext );

            KeInsertQueueApc( &irp->Tail.Apc,
                              irp->UserIosb,
                              NULL,
                              2 );

        } else if (port && irp->Overlay.AsynchronousParameters.UserApcContext) {

            //
            // If there is a completion context associated w/this I/O operation,
            // send the message to the port. Tag completion packet as an Irp.
            //

            irp->Tail.CompletionKey = key;
            irp->Tail.Overlay.PacketType = IopCompletionPacketIrp;

            KeInsertQueue( (PKQUEUE) port,
                           &irp->Tail.Overlay.ListEntry );

        } else {

            //
            // Free the IRP now since it is no longer needed.
            //

            IoFreeIrp( irp );
        }

        if (fileObject && !createOperation) {

            //
            // Dereference the file object now.
            //

            ObDereferenceObject( fileObject );
        }

    } else {

        if (irp->PendingReturned && fileObject) {

            //
            // This is an I/O operation that completed as an error for
            // which a pending status was returned and the I/O operation
            // is synchronous.  For this case, the I/O system is waiting
            // on behalf of the caller.  If the reason that the I/O was
            // synchronous is that the file object was opened for synchronous
            // I/O, then the event associated with the file object is set
            // to the signaled state.  If the I/O operation was synchronous
            // because this is a synchronous API, then the event is set to
            // the signaled state.
            //
            // Note also that the status must be returned for both types
            // of synchronous I/O.  If this is a synchronous API, then the
            // I/O system supplies its own status block so it can simply
            // be written;  otherwise, the I/O system will obtain the final
            // status from the file object itself.
            //

            if (irp->Flags & IRP_SYNCHRONOUS_API) {
                *irp->UserIosb = irp->IoStatus;
                if (irp->UserEvent) {
                    (VOID) KeSetEvent( irp->UserEvent, 0, FALSE );
                } else {
                    (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
                }
            } else {
                fileObject->FinalStatus = irp->IoStatus.Status;
                (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
            }
        }

        //
        // The operation was incomplete.  Perform the general cleanup.  Note
        // that everything is basically dropped on the floor without doing
        // anything.  That is:
        //
        //     IoStatusBlock - Do nothing.
        //     Event - Dereference without setting to Signaled state.
        //     FileObject - Dereference without setting to Signaled state.
        //     ApcRoutine - Do nothing.
        //

        if (fileObject) {
            if (!(irp->Flags & IRP_CREATE_OPERATION)) {
                ObDereferenceObject( fileObject );
            }
        }

        if (irp->UserEvent &&
            fileObject &&
            !(irp->Flags & IRP_SYNCHRONOUS_API)) {
            ObDereferenceObject( irp->UserEvent );
        }

        IopDequeueThreadIrp( irp );
        IoFreeIrp( irp );
    }
}

VOID
IopDisassociateThreadIrp(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the I/O requests for a thread are being
    cancelled, but there is a packet at the end of the thread's queue that
    has not been completed for such a long period of time that it has timed
    out.  It is this routine's responsibility to try to disassociate that
    IRP with this thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL irql;
    KIRQL spIrql;
    PIRP irp;
    PETHREAD thread;
    PLIST_ENTRY entry;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Begin by ensuring that the packet has not already been removed from
    // the thread's queue.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    thread = PsGetCurrentThread();

    //
    // If there are no packets on the IRP list, then simply return now.
    // All of the packets have been fully completed, so the caller will also
    // simply return to its caller.
    //

    if (IsListEmpty( &thread->IrpList )) {
        KeLowerIrql( irql );
        return;
    }

    //
    // Get a pointer to the first packet on the queue, and begin examining
    // it.  Note that because the processor is at raised IRQL, and because
    // the packet can only be removed in the context of the currently
    // executing thread, that it is not possible for the packet to be removed
    // from the list.  On the other hand, it IS possible for the packet to
    // be queued to the thread's APC list at this point, and this must be
    // blocked/synchronized in order to examine the request.
    //
    // Begin, therefore, by acquiring the I/O completion spinlock, so that
    // the packet can be safely examined.
    //

    spIrql = IopAcquireCompletionLock();

    //
    // Check to see whether or not the packet has been completed (that is,
    // queued to the current thread).  If not, change threads.
    //

    entry = thread->IrpList.Flink;
    irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );

    if (irp->CurrentLocation == irp->StackCount + 2) {

        //
        // The request has just gone through enough of completion that
        // queueing it to the thread is inevitable.  Simply release the
        // lock and return.
        //

        IopReleaseCompletionLock(spIrql);
        KeLowerIrql( irql );
        return;
    }

    //
    // The packet has been located, and it is not going through completion
    // at this point.  Switch threads, so that it will not complete through
    // this thread, remove the request from this thread's queue, and release
    // the spinlock.  Final processing of the IRP will occur when I/O
    // completion notices that there is no thread associated with the
    // request.  It will essentially drop the I/O on the floor.
    //
    // Also, while the request is still held, attempt to determine on which
    // device object the operation is being performed.
    //

    irp->Tail.Overlay.Thread = (PETHREAD) NULL;
    entry = RemoveHeadList( &thread->IrpList );

    // Initialize the thread entry. Otherwise the assertion in IoFreeIrp
    // called via IopDeadIrp will fail.
    InitializeListHead (&(irp)->ThreadListEntry);

    irpSp = IoGetCurrentIrpStackLocation( irp );
    if (irp->CurrentLocation <= irp->StackCount) {
        deviceObject = irpSp->DeviceObject;
    } else {
        deviceObject = (PDEVICE_OBJECT) NULL;
    }
    IopReleaseCompletionLock(spIrql);
    KeLowerIrql( irql );

    return;
}

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine attempts to drop everything about the specified IRP on the
    floor.

Arguments:

    Irp - Supplies the I/O Request Packet to be completed to the bit bucket.

    FileObject - Supplies the file object for which the I/O Request Packet was
        bound.

Return Value:

    None.

--*/

{
    //
    // Free the resources associated with the IRP.
    //

    if (Irp->UserEvent &&
        FileObject &&
        !(Irp->Flags & IRP_SYNCHRONOUS_API)) {
        ObDereferenceObject( Irp->UserEvent );
    }

    if (FileObject && !(Irp->Flags & IRP_CREATE_OPERATION)) {
        ObDereferenceObject( FileObject );
    }

    //
    // Finally, free the IRP itself.
    //

    IoFreeIrp( Irp );
}

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs generalized cleanup for the I/O system services when
    an exception occurs during caller parameter processing.  This routine
    performs the following steps:

        o   If a system buffer was allocated it is freed.

        o   If an MDL was allocated it is freed.

        o   The IRP is freed.

        o   If the file object is opened for synchronous I/O, the semaphore
            is released.

        o   If an event object was referenced it is dereferenced.

        o   The file object is dereferenced.

Arguments:

    FileObject - Pointer to the file object currently being worked on.

    Irp - Pointer to the IRP allocated to handle the I/O request.

    EventObject - Optional pointer to a referenced event object.

    KernelEvent - Optional pointer to an allocated kernel event.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Free the I/O Request Packet.
    //

    IoFreeIrp( Irp );

    //
    // Finally, release the synchronization semaphore if it is currently
    // held, dereference the event if one was specified, and dereference
    // the file object.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopReleaseFileObjectLock( FileObject );
    }

    if (ARGUMENT_PRESENT( EventObject )) {
        ObDereferenceObject( EventObject );
    }

    ObDereferenceObject( FileObject );

    return;
}

VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    The routine decrements the reference count on a device object.  If the
    reference count goes to zero and the device object is a candidate for deletion
    then IopCompleteUnloadOrDelete is called.  A device object is subject for
    deletion if the device object is pending deletion or the driver is pending
    unload.

Arguments:

    DeviceObject - Supplies the device object whose reference count is to be
                   decremented.

Return Value:

    None.

--*/
{
    KIRQL irql;

    //
    // Decrement the reference count on the device object.  If this is the last
    // last reason that this mini-file system recognizer needs to stay around,
    // then unload it.
    //

    irql = KeRaiseIrqlToDpcLevel();

    ASSERT( DeviceObject->ReferenceCount > 0 );

    DeviceObject->ReferenceCount--;

    if (!DeviceObject->ReferenceCount && DeviceObject->DeletePending) {
        IopCompleteUnloadOrDelete( DeviceObject, irql );
    } else {
        KeLowerIrql(irql);
    }
}

NTSTATUS
IopOpenRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PFILE_RENAME_INFORMATION RenameBuffer,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked by the rename code in the I/O system's
    NtSetInformationFile system service when the caller has specified a fully
    qualified file name as the target of a rename operation.  This routine
    attempts to open the parent of the specified file and checks the following:

        o   If the file itself exists, then the caller must have specified that
            the target is to be replaced, otherwise an error is returned.

        o   Ensures that the target file specification refers to the same volume
            upon which the source file exists.

Arguments:

    TargetHandle - Supplies the address of a variable to return the handle to
        the opened target file if no errors have occurred.

    Irp - Supplies a pointer to the IRP that represents the current rename
        request.

    RenameBuffer - Supplies a pointer to the system intermediate buffer that
        contains the caller's rename parameters.

    FileObject - Supplies a pointer to the file object representing the file
        being renamed.

Return Value:

    The function value is the final status of the operation.

Note:

    This function assumes that the layout of a rename, set link and set
    copy-on-write information structure are exactly the same.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT targetFileObject;

    PAGED_CODE();

    //
    // A fully qualified file name was specified.  Begin by attempting to open
    // the parent directory of the specified target file.
    //

    InitializeObjectAttributes( &objectAttributes,
                                &RenameBuffer->FileName,
                                OBJ_CASE_INSENSITIVE,
                                RenameBuffer->RootDirectory,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = IoCreateFile( &handle,
                           FILE_WRITE_DATA | SYNCHRONIZE,
                           &objectAttributes,
                           &ioStatus,
                           (PLARGE_INTEGER) NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_FOR_BACKUP_INTENT,
                           IO_NO_PARAMETER_CHECKING |
                           IO_OPEN_TARGET_DIRECTORY |
                           IO_FORCE_ACCESS_CHECK );
    if (NT_SUCCESS( status )) {

        //
        // Everything up to this point is fine, so dereference the handle
        // to a pointer to the file object and ensure that the two file
        // specifications refer to the same device.
        //

        status = ObReferenceObjectByHandle( handle,
                                          &IoFileObjectType,
                                          (PVOID *) &targetFileObject );
        if (NT_SUCCESS( status )) {

            ObDereferenceObject( targetFileObject );

            if (targetFileObject->DeviceObject != FileObject->DeviceObject) {

                //
                // The two files refer to different devices.  Clean everything
                // up and return an appropriate error.
                //

                NtClose( handle );
                status = STATUS_NOT_SAME_DEVICE;

            } else {

                //
                // Otherwise, everything worked, so allow the rename operation
                // to continue.
                //

                irpSp = IoGetNextIrpStackLocation( Irp );
                irpSp->Parameters.SetFile.FileObject = targetFileObject;
                *TargetHandle = handle;
                status = STATUS_SUCCESS;
            }

        } else {

            //
            // There was an error referencing the handle to what should
            // have been the target directory.  This generally means that
            // there was a resource problem or the handle was invalid, etc.
            // Simply attempt to close the handle and return the error.
            //

            NtClose( handle );
        }
    }

    //
    // Return the final status of the operation.
    //

    return status;
}

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
        is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then initialize the local event.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(FileObject);
        KeClearEvent( &FileObject->Event );
        synchronousIo = TRUE;
    } else {
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = FileObject->DeviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( FileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = Information;
    if (!synchronousIo) {
        irp->UserEvent = &event;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->UserIosb = &localIoStatus;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)(FileInformation ? IRP_MJ_QUERY_INFORMATION :
        IRP_MJ_QUERY_VOLUME_INFORMATION);
    irpSp->FileObject = FileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    if (FileInformation) {
        irpSp->Parameters.QueryFile.Length = Length;
        irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;
    } else {
        irpSp->Parameters.QueryVolume.Length = Length;
        irpSp->Parameters.QueryVolume.FsInformationClass = InformationClass;
    }

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (synchronousIo) {
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &FileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
            status = FileObject->FinalStatus;
        }
        IopReleaseFileObjectLock( FileObject );

    } else {

        //
        // This is a normal synchronous I/O operation, as opposed to a
        // serialized synchronous I/O operation.  For this case, wait
        // for the local event and copy the final status information
        // back to the caller.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = localIoStatus.Status;
        }
    }

    *ReturnedLength = (ULONG) localIoStatus.Information;
    return status;
}

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine is invoked when a synchronous API is invoked for a file
    that has been opened for asynchronous I/O.  This function synchronizes
    the completion of the I/O operation on the file.

Arguments:

    ReturnedStatus - Supplies the status that was returned from the call to
        IoCallDriver.

    Event - Address of the stack allocated kernel event to be used for
        synchronization of the I/O operation.

    Irp - Address of the I/O Request Packet submitted to the driver.

    LocalIoStatus - Address of the I/O status block used to capture the final
        status by the service itself.

    IoStatusBlock - Address of the I/O status block supplied by the caller of
        the system service.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // This is a normal synchronous I/O operation, as opposed to a
    // serialized synchronous I/O operation.  For this case, wait for
    // the local event and copy the final status information back to
    // the caller.
    //

    status = ReturnedStatus;

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );

        status = LocalIoStatus->Status;
    }

    *IoStatusBlock = *LocalIoStatus;

    return status;
}

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN BOOLEAN SynchronousIo
    )

/*++

Routine Description:

    This routine is invoked to complete the operation of a system service.
    It queues the IRP to the thread's queue, updates the transfer count,
    calls the driver, and finally synchronizes completion of the I/O.

Arguments:

    DeviceObject - Device on which the I/O is to occur.

    Irp - I/O Request Packet representing the I/O operation.

    FileObject - File object for this open instantiation.

    DeferredIoCompletion - Indicates whether deferred completion is possible.

    SynchronousIo - Indicates whether the operation is to be synchronous.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( Irp );

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, Irp );

    //
    // If deferred I/O completion is possible, check for pending returned
    // from the driver.  If the driver did not return pending, then the
    // packet has not actually been completed yet, so complete it here.
    //

    if (DeferredIoCompletion) {

        if (status != STATUS_PENDING) {

            //
            // The I/O operation was completed without returning a status of
            // pending.  This means that at this point, the IRP has not been
            // fully completed.  Complete it now.
            //

            PKNORMAL_ROUTINE normalRoutine;
            PVOID normalContext;
            KIRQL irql;

            ASSERT( !Irp->PendingReturned );

            KeRaiseIrql( APC_LEVEL, &irql );
            IopCompleteRequest( &Irp->Tail.Apc,
                                &normalRoutine,
                                &normalContext,
                                (PVOID *) &FileObject,
                                &normalContext );
            KeLowerIrql( irql );
        }
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (SynchronousIo) {

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject( &FileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = FileObject->FinalStatus;
        }

        IopReleaseFileObjectLock( FileObject );
    }

    return status;
}

VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine is invoked in the final processing of an IRP.  Everything has
    been completed except that the caller's APC routine must be invoked.  The
    system will do this as soon as this routine exits.  The only processing
    remaining to be completed by the I/O system is to free the I/O Request
    Packet itself.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

Note:

    If no other processing is ever needed, and the APC can be placed at the
    beginning of the IRP, then this routine could be replaced by simply
    specifying the address of the pool deallocation routine in the APC instead
    of the address of this routine.

Caution:

    This routine is also invoked as a general purpose rundown routine for APCs.
    Should this code ever need to directly access any of the other parameters
    other than Apc, this routine will need to be split into two separate
    routines.  The rundown routine should perform exactly the following code's
    functionality.

--*/

{
    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    PAGED_CODE();

    //
    // Free the packet.
    //

    IoFreeIrp( CONTAINING_RECORD( Apc, IRP, Tail.Apc ) );
}

VOID
IopUserRundown(
    IN PKAPC Apc
    )

/*++

Routine Description:

    This routine is invoked during thread termination as the rundown routine
    for it simply calls IopUserCompletion.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

Return Value:

    None.


--*/

{
    PAGED_CODE();

    //
    // Free the packet.
    //

    IoFreeIrp( CONTAINING_RECORD( Apc, IRP, Tail.Apc ) );
}

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the driver associated with the file handle.
    handle.  It is up to the driver to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        driver.  Whether or not the buffer is actually optional is dependent
        on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

    DeviceIoControl - Determines whether this is a Device or File System
        Control function.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT eventObject = (PKEVENT) NULL;
    PIO_STACK_LOCATION irpSp;
    ULONG method;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.

    irp = IoAllocateIrp( deviceObject->StackSize );

    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = OutputBuffer;
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)(DeviceIoControl ? IRP_MJ_DEVICE_CONTROL :
        IRP_MJ_FILE_SYSTEM_CONTROL);
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBuffer = InputBuffer;

    //
    // Based on the method that the buffer are being passed, lock down the
    // output buffer.
    //

    if (OutputBufferLength != 0) {

        method = IoControlCode & 3;

        if ((method == METHOD_IN_DIRECT) || (method == METHOD_OUT_DIRECT)) {
            IoLockUserBuffer(irp, OutputBufferLength);
        }
    }

    //
    // Defer I/O completion for FSCTL requests, but not for IOCTL requests,
    // since file systems set pending properly but device driver do not.
    //

    if (!DeviceIoControl) {
        irp->Flags |= IRP_DEFER_IO_COMPLETION;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      (BOOLEAN)!DeviceIoControl,
                                      synchronousIo );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\iop.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    iop.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

--*/

#ifndef _IOP_
#define _IOP_

#ifndef FAR
#define FAR
#endif

#include "ntos.h"

//
// Define the global data for the I/O system.
//

extern GENERIC_MAPPING IopFileMapping;

//
// Define a dummy file object for use on stack for fast open operations.
//

typedef struct _DUMMY_FILE_OBJECT {
    OBJECT_HEADER ObjectHeader;
    CHAR FileObjectBody[ sizeof( FILE_OBJECT ) ];
} DUMMY_FILE_OBJECT, *PDUMMY_FILE_OBJECT;

//
// Define the structures private to the I/O system.
//

#define OPEN_PACKET_PATTERN  0xbeaa0251

//
// Define an Open Packet (OP).  An OP is used to communicate information
// between the NtCreateFile service executing in the context of the caller
// and the device object parse routine.  It is the parse routine who actually
// creates the file object for the file.
//

typedef struct _OPEN_PACKET {
    CSHORT Type;
    CSHORT Size;
    PFILE_OBJECT FileObject;
    NTSTATUS FinalStatus;
    ULONG_PTR Information;
    ULONG ParseCheck;
    PFILE_OBJECT RelatedFileObject;

    //
    // The following are the open-specific parameters.  Notice that the desired
    // access field is passed through to the parse routine via the object
    // management architecture, so it does not need to be repeated here.  Also
    // note that the same is true for the file name.
    //

    LARGE_INTEGER AllocationSize;
    ULONG CreateOptions;
    USHORT FileAttributes;
    USHORT ShareAccess;
    ULONG Options;
    ULONG Disposition;
    ULONG DesiredAccess;

    //
    // The following is used when performing a fast network query during open
    // to get back the network file attributes for a file.
    //

    PFILE_NETWORK_OPEN_INFORMATION NetworkInformation;

    //
    // The following pointer is used when a fast open operation for a fast
    // delete or fast query attributes call is being made rather than a
    // general file open.  The dummy file object is actually stored on the
    // the caller's stack rather than allocated pool to speed things up.
    //

    PDUMMY_FILE_OBJECT LocalFileObject;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of querying its attributes.  This causes a considerable
    // number of shortcuts to be taken in the parse, query, and close paths.
    //

    BOOLEAN QueryOnly;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of deleting it.  This causes a considerable number of
    // shortcurs to be taken in the parse and close paths.
    //

    BOOLEAN DeleteOnly;

} OPEN_PACKET, *POPEN_PACKET;

//
// Define I/O completion packet types.
//

typedef enum _COMPLETION_PACKET_TYPE {
    IopCompletionPacketIrp,
    IopCompletionPacketMini
} COMPLETION_PACKET_TYPE, *PCOMPLETION_PACKET_TYPE;

//
// Define the type for completion packets inserted onto completion ports when
// there is no full I/O request packet that was used to perform the I/O
// operation.  This occurs when the fast I/O path is used, and when the user
// directly inserts a completion message.
//
typedef struct _IOP_MINI_COMPLETION_PACKET {

    //
    // The following unnamed structure must be exactly identical
    // to the unnamed structure used in the IRP overlay section used
    // for completion queue entries.
    //

    struct {

        //
        // List entry - used to queue the packet to completion queue, among
        // others.
        //

        LIST_ENTRY ListEntry;

        union {

            //
            // Current stack location - contains a pointer to the current
            // IO_STACK_LOCATION structure in the IRP stack.  This field
            // should never be directly accessed by drivers.  They should
            // use the standard functions.
            //

            struct _IO_STACK_LOCATION *CurrentStackLocation;

            //
            // Minipacket type.
            //

            ULONG PacketType;
        };
    };

    PVOID KeyContext;
    PVOID ApcContext;
    NTSTATUS IoStatus;
    ULONG_PTR IoStatusInformation;
} IOP_MINI_COMPLETION_PACKET, *PIOP_MINI_COMPLETION_PACKET;

extern const UCHAR IopQueryOperationLength[];
extern const UCHAR IopSetOperationLength[];
extern const ULONG IopQueryOperationAccess[];
extern const ULONG IopSetOperationAccess[];
extern const UCHAR IopQueryFsOperationLength[];
extern const ULONG IopQueryFsOperationAccess[];

#define IopAcquireCompletionLock()          KeRaiseIrqlToDpcLevel()
#define IopReleaseCompletionLock(OldIrql)   KeLowerIrql(OldIrql)

//
// Define routines private to the I/O system.
//

VOID
FASTCALL
IopAcquireFileObjectLock(
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    );

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    );

VOID
IopCloseFile(
    IN PVOID Object,
    IN ULONG SystemHandleCount
    );

VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN KIRQL Irql
    );

VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopDeleteFile(
    IN PVOID Object
    );

VOID
IopDeleteIoCompletion(
    IN PVOID Object
    );

//+
//
// VOID
// IopDequeueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine dequeues the specified I/O Request Packet (IRP) from the
//     thread IRP queue which it is currently queued.
//
//     In checked we set Flink == Blink so we can assert free's of queue'd IRPs
//
// Arguments:
//
//     Irp - Specifies the IRP that is dequeued.
//
// Return Value:
//
//     None.
//
//-

#define IopDequeueThreadIrp( Irp ) \
   { \
   RemoveEntryList( &Irp->ThreadListEntry ); \
   InitializeListHead( &Irp->ThreadListEntry ) ; \
   }


#ifdef  _WIN64
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT((ULONG_PTR)(ApcRoutine) & ~1)
#else
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT((ULONG_PTR)(ApcRoutine))
#endif

#define IopApcRoutineMode(ApcRoutine) \
    ((KPROCESSOR_MODE)((ApcRoutine == NtUserIoApcDispatcher) ? UserMode : KernelMode))

VOID
IopDisassociateThreadIrp(
    VOID
    );

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL
    );

NTSTATUS
IopGetFileName(
    IN PFILE_OBJECT FileObject,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

//++
//
// VOID
// IopInitializeIrp(
//     IN OUT PIRP Irp,
//     IN USHORT PacketSize,
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Initializes an IRP.
//
// Arguments:
//
//     Irp - a pointer to the IRP to initialize.
//
//     PacketSize - length, in bytes, of the IRP.
//
//     StackSize - Number of stack locations in the IRP.
//
// Return Value:
//
//     None.
//
//--

#define IopInitializeIrp( Irp, PacketSize, StackSize ) {          \
    RtlZeroMemory( (Irp), (PacketSize) );                         \
    (Irp)->Type = (CSHORT) IO_TYPE_IRP;                           \
    (Irp)->Size = (USHORT) ((PacketSize));                        \
    (Irp)->StackCount = (CCHAR) ((StackSize));                    \
    (Irp)->CurrentLocation = (CCHAR) ((StackSize) + 1);           \
    InitializeListHead (&(Irp)->ThreadListEntry);                 \
    (Irp)->Tail.Overlay.CurrentStackLocation =                    \
        ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) +                  \
            sizeof( IRP ) +                                       \
            ( (StackSize) * sizeof( IO_STACK_LOCATION )))); }

NTSTATUS
IopOpenRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PFILE_RENAME_INFORMATION RenameBuffer,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    );

//+
// VOID
// IopQueueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine queues the specified I/O Request Packet (IRP) to the thread
//     whose TCB address is stored in the packet.
//
// Arguments:
//
//     Irp - Supplies the IRP to be queued for the specified thread.
//
// Return Value:
//
//     None.
//
//-

#define IopQueueThreadIrp( Irp ) {                      \
    KIRQL irql;                                         \
    KeRaiseIrql( APC_LEVEL, &irql );                    \
    InsertHeadList( &Irp->Tail.Overlay.Thread->IrpList, \
                    &Irp->ThreadListEntry );            \
    KeLowerIrql( irql );                                \
    }

BOOLEAN
FASTCALL
IopReleaseFileObjectLock(
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN BOOLEAN SynchronousIo
    );

VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    );

#endif // _IOP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\iodata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iodata.c

Abstract:

    This module contains the global read/write data for the I/O system.

Author:

    Darryl E. Havens (darrylh) April 27, 1989

Revision History:


--*/

#include "iop.h"

//
// The following are the global pointers for the Object Type Descriptors that
// are created when each of the I/O specific object types are created.
//

DECLSPEC_RDATA OBJECT_TYPE IoCompletionObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    IopDeleteIoCompletion,
    NULL,
    &ObpDefaultObject,
    'pmoC'
};

DECLSPEC_RDATA OBJECT_TYPE IoDeviceObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    IoParseDevice,
    &ObpDefaultObject,
    'iveD'
};

DECLSPEC_RDATA OBJECT_TYPE IoFileObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    IopCloseFile,
    IopDeleteFile,
    IopParseFile,
    (PVOID)FIELD_OFFSET(FILE_OBJECT, Event.Header),
    'eliF'
};

//
// The following array specifies the minimum length of the FileInformation
// buffer for an NtQueryInformationFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQueryOperationLength[] =
          {
            0,
            0,                                         //  1 FileDirectoryInformation
            0,                                         //  2 FileFullDirectoryInformation
            0,                                         //  3 FileBothDirectoryInformation
            sizeof( FILE_BASIC_INFORMATION ),          //  4 FileBasicInformation
            sizeof( FILE_STANDARD_INFORMATION ),       //  5 FileStandardInformation
            sizeof( FILE_INTERNAL_INFORMATION ),       //  6 FileInternalInformation
            sizeof( FILE_EA_INFORMATION ),             //  7 FileEaInformation
            0,                                         //  8 FileAccessInformation
            sizeof( FILE_NAME_INFORMATION ),           //  9 FileNameInformation
            0,                                         // 10 FileRenameInformation
            0,                                         // 11 FileLinkInformation
            0,                                         // 12 FileNamesInformation
            0,                                         // 13 FileDispositionInformation
            sizeof( FILE_POSITION_INFORMATION ),       // 14 FilePositionInformation
            0,                                         // 15 FileFullEaInformation
            sizeof( FILE_MODE_INFORMATION ),           // 16 FileModeInformation
            sizeof( FILE_ALIGNMENT_INFORMATION ),      // 17 FileAlignmentInformation
            sizeof( FILE_ALL_INFORMATION ),            // 18 FileAllInformation
            0,                                         // 19 FileAllocationInformation
            0,                                         // 20 FileEndOfFileInformation
            sizeof( FILE_NAME_INFORMATION ),           // 21 FileAlternateNameInformation
            sizeof( FILE_STREAM_INFORMATION ),         // 22 FileStreamInformation
            0,                                         // 23 FilePipeInformation
            0,                                         // 24 FilePipeLocalInformation
            0,                                         // 25 FilePipeRemoteInformation
            0,                                         // 26 FileMailslotQueryInformation
            0,                                         // 27 FileMailslotSetInformation
            0,                                         // 28 FileCompressionInformation
            0,                                         // 29 FileObjectIdInformation
            0,                                         // 30 FileCompletionInformation
            0,                                         // 31 FileMoveClusterInformation
            0,                                         // 32 FileQuotaInformation
            0,                                         // 33 FileReparsePointInformation
            sizeof( FILE_NETWORK_OPEN_INFORMATION),    // 34 FileNetworkOpenInformation
            sizeof( FILE_ATTRIBUTE_TAG_INFORMATION),   // 35 FileAttributeTagInformation
            0,                                         // 36 FileTrackingInformation
            0xff                                       //    FileMaximumInformation
          };

//
// The following array specifies the minimum length of the FileInformation
// buffer for an NtSetInformationFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopSetOperationLength[] =
          {
            0,
            0,                                       //  1 FileDirectoryInformation
            0,                                       //  2 FileFullDirectoryInformation
            0,                                       //  3 FileBothDirectoryInformation
            sizeof( FILE_BASIC_INFORMATION ),        //  4 FileBasicInformation
            0,                                       //  5 FileStandardInformation
            0,                                       //  6 FileInternalInformation
            0,                                       //  7 FileEaInformation
            0,                                       //  8 FileAccessInformation
            0,                                       //  9 FileNameInformation
            sizeof( FILE_RENAME_INFORMATION ),       // 10 FileRenameInformation
            sizeof( FILE_LINK_INFORMATION ),         // 11 FileLinkInformation
            0,                                       // 12 FileNamesInformation
            sizeof( FILE_DISPOSITION_INFORMATION ),  // 13 FileDispositionInformation
            sizeof( FILE_POSITION_INFORMATION ),     // 14 FilePositionInformation
            0,                                       // 15 FileFullEaInformation
            sizeof( FILE_MODE_INFORMATION ),         // 16 FileModeInformation
            0,                                       // 17 FileAlignmentInformation
            0,                                       // 18 FileAllInformation
            sizeof( FILE_ALLOCATION_INFORMATION ),   // 19 FileAllocationInformation
            sizeof( FILE_END_OF_FILE_INFORMATION ),  // 20 FileEndOfFileInformation
            0,                                       // 21 FileAlternateNameInformation
            0,                                       // 22 FileStreamInformation
            0,                                       // 23 FilePipeInformation
            0,                                       // 24 FilePipeLocalInformation
            0,                                       // 25 FilePipeRemoteInformation
            0,                                       // 26 FileMailslotQueryInformation
            0,                                       // 27 FileMailslotSetInformation
            0,                                       // 28 FileCompressionInformation
            0,                                       // 29 FileObjectIdInformation
            sizeof( FILE_COMPLETION_INFORMATION ),   // 30 FileCompletionInformation
            sizeof( FILE_MOVE_CLUSTER_INFORMATION ), // 31 FileMoveClusterInformation
            0,                                       // 32 FileQuotaInformation
            0,                                       // 33 FileReparsePointInformation
            0,                                       // 34 FileNetworkOpenInformation
            0,                                       // 35 FileAttributeTagInformation
            0,                                       // 36 FileTrackingInformation
            0xff                                     //    FileMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtQueryXxxFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopQueryOperationAccess[] =
         {
            0,
            0,                    //  1 FileDirectoryInformation
            0,                    //  2 FileFullDirectoryInformation
            0,                    //  3 FileBothDirectoryInformation
            FILE_READ_ATTRIBUTES, //  4 FileBasicInformation
            0,                    //  5 FileStandardInformation
            0,                    //  6 FileInternalInformation
            0,                    //  7 FileEaInformation
            0,                    //  8 FileAccessInformation
            0,                    //  9 FileNameInformation
            0,                    // 10 FileRenameInformation
            0,                    // 11 FileLinkInformation
            0,                    // 12 FileNamesInformation
            0,                    // 13 FileDispositionInformation
            0,                    // 14 FilePositionInformation
            FILE_READ_EA,         // 15 FileFullEaInformation
            0,                    // 16 FileModeInformation
            0,                    // 17 FileAlignmentInformation
            FILE_READ_ATTRIBUTES, // 18 FileAllInformation
            0,                    // 19 FileAllocationInformation
            0,                    // 20 FileEndOfFileInformation
            0,                    // 21 FileAlternateNameInformation
            0,                    // 22 FileStreamInformation
            FILE_READ_ATTRIBUTES, // 23 FilePipeInformation
            FILE_READ_ATTRIBUTES, // 24 FilePipeLocalInformation
            FILE_READ_ATTRIBUTES, // 25 FilePipeRemoteInformation
            0,                    // 26 FileMailslotQueryInformation
            0,                    // 27 FileMailslotSetInformation
            0,                    // 28 FileCompressionInformation
            0,                    // 29 FileObjectIdInformation
            0,                    // 30 FileCompletionInformation
            0,                    // 31 FileMoveClusterInformation
            0,                    // 32 FileQuotaInformation
            0,                    // 33 FileReparsePointInformation
            FILE_READ_ATTRIBUTES, // 34 FileNetworkOpenInformation
            FILE_READ_ATTRIBUTES, // 35 FileAttributeTagInformation
            0,                    // 36 FileTrackingInformation
            0xffffffff            //    FileMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtSetXxxFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FILE_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopSetOperationAccess[] =
         {
            0,
            0,                     //  1 FileDirectoryInformation
            0,                     //  2 FileFullDirectoryInformation
            0,                     //  3 FileBothDirectoryInformation
            FILE_WRITE_ATTRIBUTES, //  4 FileBasicInformation
            0,                     //  5 FileStandardInformation
            0,                     //  6 FileInternalInformation
            0,                     //  7 FileEaInformation
            0,                     //  8 FileAccessInformation
            0,                     //  9 FileNameInformation
            DELETE,                // 10 FileRenameInformation
            0,                     // 11 FileLinkInformation
            0,                     // 12 FileNamesInformation
            DELETE,                // 13 FileDispositionInformation
            0,                     // 14 FilePositionInformation
            FILE_WRITE_EA,         // 15 FileFullEaInformation
            0,                     // 16 FileModeInformation
            0,                     // 17 FileAlignmentInformation
            0,                     // 18 FileAllInformation
            FILE_WRITE_DATA,       // 19 FileAllocationInformation
            FILE_WRITE_DATA,       // 20 FileEndOfFileInformation
            0,                     // 21 FileAlternateNameInformation
            0,                     // 22 FileStreamInformation
            FILE_WRITE_ATTRIBUTES, // 23 FilePipeInformation
            0,                     // 24 FilePipeLocalInformation
            FILE_WRITE_ATTRIBUTES, // 25 FilePipeRemoteInformation
            0,                     // 26 FileMailslotQueryInformation
            0,                     // 27 FileMailslotSetInformation
            0,                     // 28 FileCompressionInformation
            0,                     // 29 FileObjectIdInformation
            0,                     // 30 FileCompletionInformation
            FILE_WRITE_DATA,       // 31 FileMoveClusterInformation
            0,                     // 32 FileQuotaInformation
            0,                     // 33 FileReparsePointInformation
            0,                     // 34 FileNetworkOpenInformation
            0,                     // 35 FileAttributeTagInformation
            FILE_WRITE_DATA,       // 36 FileTrackingInformation
            0xffffffff             //    FileMaximumInformation
          };

//
// The following array specifies the minimum length of the FsInformation
// buffer for an NtQueryVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQueryFsOperationLength[] =
          {
            0,
            sizeof( FILE_FS_VOLUME_INFORMATION ),    // 1 FileFsVolumeInformation
            0,                                       // 2 FileFsLabelInformation
            sizeof( FILE_FS_SIZE_INFORMATION ),      // 3 FileFsSizeInformation
            sizeof( FILE_FS_DEVICE_INFORMATION ),    // 4 FileFsDeviceInformation
            sizeof( FILE_FS_ATTRIBUTE_INFORMATION ), // 5 FileFsAttributeInformation
            sizeof( FILE_FS_CONTROL_INFORMATION ),   // 6 FileFsControlInformation
            sizeof( FILE_FS_FULL_SIZE_INFORMATION ), // 7 FileFsFullSizeInformation
            sizeof( FILE_FS_OBJECTID_INFORMATION ),  // 8 FileFsObjectIdInformation
            0xff                                     //   FileFsMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtQueryVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopQueryFsOperationAccess[] =
         {
            0,
            0,              // 1 FileFsVolumeInformation [any access to file or volume]
            0,              // 2 FileFsLabelInformation [query is invalid]
            0,              // 3 FileFsSizeInformation [any access to file or volume]
            0,              // 4 FileFsDeviceInformation [any access to file or volume]
            0,              // 5 FileFsAttributeInformation [any access to file or vol]
            FILE_READ_DATA, // 6 FileFsControlInformation [vol read access]
            0,              // 7 FileFsFullSizeInformation [any access to file or volume]
            0,              // 8 FileFsObjectIdInformation [any access to file or volume]
            0xffffffff      //   FileFsMaximumInformation
          };

DECLSPEC_RDATA GENERIC_MAPPING IopFileMapping = {
    STANDARD_RIGHTS_READ |
        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_EXECUTE,
    FILE_ALL_ACCESS
};

ULONG IoPendingMustCompletePackets;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\parse.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains the code to implement the device object parse routine.

--*/

#include "iop.h"

//
// Define external procedures not in common header files
//

NTSTATUS
RawxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FatxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GdfxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UdfxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopMountVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    )

/*++

Routine Description:

    This routine is used to mount a volume on the specified device.

Arguments:

    DeviceObject - Pointer to device object on which the volume is to be
        mounted.

    AllowRawMount - This parameter tells us if we should continue our
        filesystem search to include the Raw file system.  This flag will
        only be passed in as TRUE as a result of a DASD open.

Return Value:

    The function value is a successful status code if a volume was successfully
    mounted on the device.  Otherwise, an error code is returned.

--*/

{
    NTSTATUS status;

    //
    // Obtain the lock for the device to be mounted.  This guarantees that
    // only one thread is attempting to mount this particular device at a time.
    //

    status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL );

    //
    // Check if the device is still in the unmounted state.
    //

    if (DeviceObject->MountedOrSelfDevice == NULL) {

        //
        // Check if the device supports high level file systems and if so,
        // attempt to mount an appropriate file system.
        //

        if ((DeviceObject->Flags & DO_RAW_MOUNT_ONLY) == 0) {

            if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM) {

                status = GdfxMountVolume(DeviceObject);

                if (status == STATUS_UNRECOGNIZED_VOLUME) {
                    status = UdfxMountVolume(DeviceObject);
                }

            } else {
                status = FatxMountVolume(DeviceObject);
            }

        } else {
            status = STATUS_UNRECOGNIZED_VOLUME;
        }

        //
        // If the volume hasn't been recognized yet and we're allowed to mount
        // the volume as a RAW device, then do so.
        //

        if (!NT_SUCCESS(status) && AllowRawMount) {
            status = RawxMountVolume(DeviceObject);
        }

    } else {

        //
        // The volume for this device has already been mounted.  Return a
        // success code.
        //

        status = STATUS_SUCCESS;
    }

    //
    // Release the synchronization event for the device.
    //

    KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );

    return status;
}

NTSTATUS
IoParseDevice(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and the
    name translates to a device object.  This routine is specified as the parse
    routine for all device objects.

    In the normal case of an NtCreateFile, the user specifies either the name
    of a device or of a file.  In the former situation, this routine is invoked
    with a pointer to the device and a null ("") string.  For this case, the
    routine simply allocates an IRP, fills it in, and passes it to the driver
    for the device.  The driver will then perform whatever rudimentary functions
    are necessary and will return a status code indicating whether an error was
    incurred.  This status code is remembered in the Open Packet (OP).

    In the latter situation, the name string to be opened/created is non-null.
    That is, it contains the remainder of the pathname to the file that is to
    be opened or created.  For this case, the routine allocates an IRP, fills
    it in, and passes it to the driver for the device.  The driver may then
    need to take further action or it may complete the request immediately.  If
    it needs to perform some work asynchronously, then it can queue the request
    and return a status of STATUS_PENDING.  This allows this routine and its
    caller to return to the user so that he can continue.  Otherwise, the open/
    create is basically finished.

    If the driver supports symbolic links, then it is also possible for the
    driver to return a new name.  This name will be returned to the Object
    Manager as a new name to look up.  The parsing will then begin again from
    the start.

    It is also the responsibility of this routine to create a file object for
    the file, if the name specifies a file.  The file object's address is
    returned to the NtCreateFile service through the OP.

Arguments:

    ParseObject - Pointer to the device object the name translated into.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    POPEN_PACKET op;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT parseDeviceObject;
    PDUMMY_FILE_OBJECT localFileObject;
    LOGICAL realFileObjectRequired;
    KIRQL OldIrql;

    PAGED_CODE();

    //
    // Assume failure by setting the returned object pointer to NULL.
    //

    *Object = (PVOID) NULL;

    //
    // Get the address of the Open Packet (OP).
    //

    op = Context;

    //
    // If no open packet was specified and there's no more name to parse, then
    // return the device object itself.
    //
    // We hit this path if somebody calls ObReferenceObjectByName (or
    // equivalent).  This allows the client to access a device object without
    // going through a file system.
    //

    if (op == NULL && RemainingName->Length == 0) {
        ObReferenceObject(ParseObject);
        *Object = ParseObject;
        return STATUS_SUCCESS;
    }

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Obtain a pointer to the parse object as a device object, which is the
    // actual type of the object anyway.
    //

    parseDeviceObject = (PDEVICE_OBJECT) ParseObject;

    //
    // If this is a relative open, then get the device on which the file
    // is really being opened from the related file object and use that for
    // the remainder of this function and for all operations performed on
    // the file object that is about to be created.
    //

    if (op->RelatedFileObject) {
        parseDeviceObject = op->RelatedFileObject->DeviceObject;
    }

    //
    // Make sure that the device and its driver are really there.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    if (parseDeviceObject->DeletePending ||
        parseDeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        status = STATUS_NO_SUCH_DEVICE;

    } else if (parseDeviceObject->Flags & DO_EXCLUSIVE &&
               parseDeviceObject->ReferenceCount != 0 &&
               op->RelatedFileObject == NULL) {

        status = STATUS_ACCESS_DENIED;

    } else {

        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status)) {
        KeLowerIrql(OldIrql);
        return op->FinalStatus = status;
    }

    //
    // Get the address of the mounted or self device object.  If the pointer
    // is null, then the device has not been mounted yet, so do it now.
    //

    while ((deviceObject = parseDeviceObject->MountedOrSelfDevice) == NULL) {

        KeLowerIrql(OldIrql);

        status = IopMountVolume( parseDeviceObject,
                                 (BOOLEAN) (!RemainingName->Length && !op->RelatedFileObject));

        if (!NT_SUCCESS(status)) {
            return op->FinalStatus = status;
        }

        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    deviceObject->ReferenceCount++;
    KeLowerIrql(OldIrql);

    //
    // After this point, we shouldn't touch parseDeviceObject.  The device that
    // we're going to send the IRP_MJ_CREATE to is deviceObject.  That may be a
    // file system device.  A file system device could be unmounted by another
    // thread while we're trying to create a file.  We have a stable reference
    // to the file system device, but the link between the original
    // parseDeviceObject and deviceObject may no longer exist.
    //

    parseDeviceObject = NULL;

    //
    // Since ObOpenObjectByName is called without being passed
    // any object type information, we need to map the generic
    // bits in the DesiredAccess mask here.
    //

    RtlMapGenericMask( &op->DesiredAccess, &IopFileMapping );

    //
    // Allocate and fill in the I/O Request Packet (IRP) to use in interfacing
    // to the driver.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {
        IopDecrementDeviceObjectRef(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Flags = IRP_CREATE_OPERATION | IRP_SYNCHRONOUS_API | IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This is where
    // the original function codes and parameters are passed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // This is a normal file open or create function.
    //

    irpSp->MajorFunction = IRP_MJ_CREATE;
    irpSp->Flags = (UCHAR) op->Options;
    if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
        irpSp->Flags |= SL_CASE_SENSITIVE;
    }

    //
    // Also fill in the NtCreateFile service's caller's parameters.
    //

    irp->Overlay.AllocationSize = op->AllocationSize;
    irpSp->Parameters.Create.Options = (op->Disposition << 24) | (op->CreateOptions & 0x00ffffff);
    irpSp->Parameters.Create.FileAttributes = op->FileAttributes;
    irpSp->Parameters.Create.ShareAccess = op->ShareAccess;
    irpSp->Parameters.Create.DesiredAccess = op->DesiredAccess;
    irpSp->Parameters.Create.RemainingName = RemainingName;

    //
    // Fill in local parameters so this routine can determine when the I/O is
    // finished, and the normal I/O completion code will not get any errors.
    //

    irp->UserIosb = &ioStatus;

    //
    // Allocate and initialize the file object that will be used in dealing
    // with the device for the remainder of this session with the user.  How
    // the file object is allocated is based on whether or not a real file
    // object is actually required.  It is not required for the query and
    // delete only operations.
    //

    realFileObjectRequired = !(op->QueryOnly || op->DeleteOnly);

    if (realFileObjectRequired) {

        OBJECT_ATTRIBUTES objectAttributes;

        //
        // A real, full-blown file object is actually required.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    (POBJECT_STRING) NULL,
                                    Attributes,
                                    (HANDLE) NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                  );

        status = ObCreateObject( &IoFileObjectType,
                                 &objectAttributes,
                                 (ULONG) sizeof( FILE_OBJECT ),
                                 (PVOID *) &fileObject );

        if (!NT_SUCCESS( status )) {
            IoFreeIrp( irp );
            IopDecrementDeviceObjectRef(deviceObject);
            return op->FinalStatus = status;
        }

        RtlZeroMemory( fileObject, sizeof( FILE_OBJECT ) );
        fileObject->Type = IO_TYPE_FILE;
        fileObject->RelatedFileObject = op->RelatedFileObject;
        if (op->CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
            fileObject->Flags = FO_SYNCHRONOUS_IO;
            if (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) {
                fileObject->Flags |= FO_ALERTABLE_IO;
            }
        }

        //
        // Now fill in the file object as best is possible at this point and set
        // a pointer to it in the IRP so everyone else can find it.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            fileObject->LockCount = -1;
            KeInitializeEvent( &fileObject->Lock, SynchronizationEvent, FALSE );
        }
        if (op->CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) {
            fileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
        }
        if (op->CreateOptions & FILE_SEQUENTIAL_ONLY) {
            fileObject->Flags |= FO_SEQUENTIAL_ONLY;
        }
        if (op->CreateOptions & FILE_RANDOM_ACCESS) {
            fileObject->Flags |= FO_RANDOM_ACCESS;
        }

    } else {

        //
        // This is either a quick delete or query operation.  For these cases,
        // it is possible to optimize the Object Manager out of the picture by
        // simply putting together something that "looks" like a file object,
        // and then operating on it.
        //

        localFileObject = op->LocalFileObject;
        RtlZeroMemory( localFileObject, sizeof( DUMMY_FILE_OBJECT ) );
        fileObject = (PFILE_OBJECT) &localFileObject->ObjectHeader.Body;
        localFileObject->ObjectHeader.Type = &IoFileObjectType;
        localFileObject->ObjectHeader.PointerCount = 1;
    }

    fileObject->Type = IO_TYPE_FILE;
    fileObject->RelatedFileObject = op->RelatedFileObject;
    fileObject->DeviceObject = deviceObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Finally, initialize the file object's event to the Not Signaled state
    // and remember that a file object was created.
    //

    KeInitializeEvent( &fileObject->Event, NotificationEvent, FALSE );
    op->FileObject = fileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now invoke the driver itself to open the file.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // One of three things may have happened when the driver was invoked:
    //
    //    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can
    //        occur on devices which need to perform some sort of device
    //        manipulation (such as opening a file for a file system).
    //
    //    2.  The driver returned an error (Status < 0). This occurs when either
    //        a supplied parameter was in error, or the device or file system
    //        incurred or discovered an error.
    //
    //    3.  The operation is complete and was successful (Status ==
    //        STATUS_SUCCESS).  Note that for this case the only action is to
    //        return a pointer to the file object.
    //

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &fileObject->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;

    } else {

        //
        // The I/O operation was completed without returning a status of
        // pending.  This means that at this point, the IRP has not been
        // fully completed.  Complete it now.
        //

        KIRQL irql;

        ASSERT( !irp->PendingReturned );

        KeRaiseIrql( APC_LEVEL, &irql );

        //
        // Note that normally the system would simply call IopCompleteRequest
        // here to complete the packet.  However, because this is a create
        // operation, several assumptions can be made that make it much faster
        // to perform the couple of operations that completing the request
        // would perform.  These include:  copying the I/O status block,
        // dequeueing the IRP and freeing it, and setting the file object's
        // event to the signalled state.  The latter is done here by hand,
        // since it is known that it is not possible for any thread to be
        // waiting on the event.
        //

        ioStatus = irp->IoStatus;
        status = ioStatus.Status;

        fileObject->Event.Header.SignalState = 1;

        IopDequeueThreadIrp( irp );

        IoFreeIrp( irp );

        KeLowerIrql( irql );
    }

    ASSERT(status != STATUS_REPARSE);

    //
    // Copy the information field of the I/O status block back to the
    // original caller in case it is required.
    //

    op->Information = ioStatus.Information;

    if (!NT_SUCCESS( status )) {

        //
        // The operation ended in an error.  Kill the file object, dereference
        // the device object, and return a null pointer.
        //

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef(deviceObject);

        return op->FinalStatus = status;
    }

    //
    // The operation was successful. If this is not a query or a delete,
    // but rather a normal open/create, return the address of the
    // FileObject to the caller and set the information returned in the
    // original requestor's I/O status block. Also set the value of the
    // parse check field in the open packet to a value which will let
    // the caller know that this routine was successful in creating the
    // file object. Finally, return the status of the operation to the
    // caller.
    //

    if (realFileObjectRequired) {

        *Object = fileObject;
        op->ParseCheck = OPEN_PACKET_PATTERN;

        //
        // Add a reference so the file object cannot go away before
        // the create routine gets chance to flag the object for handle
        // create.
        //

        ObReferenceObject( fileObject );

        return op->FinalStatus = ioStatus.Status;

    } else {

        //
        // This is either a quick query or delete operation.  Determine
        // which it is and quickly perform the operation.
        //

        if (op->QueryOnly) {

            ULONG returnedLength;

            //
            // This is a full attribute query.  Attempt to obtain the
            // full network attributes for the file.  This includes
            // both the basic and standard information about the
            // file.
            //

            status = IoQueryFileInformation(
                        fileObject,
                        FileNetworkOpenInformation,
                        sizeof( FILE_NETWORK_OPEN_INFORMATION ),
                        op->NetworkInformation,
                        &returnedLength
                        );

        } else {

            //
            // There is nothing to do for a quick delete since the caller
            // set the FILE_DELETE_ON_CLOSE CreateOption so it is already
            // set in the file system.
            //

            NOTHING;
        }

        op->ParseCheck = OPEN_PACKET_PATTERN;
        IopDeleteFile( fileObject );
        op->FileObject = (PFILE_OBJECT) NULL;
        op->FinalStatus = status;

        //
        // Return an error code here so that the object manager doesn't
        // think that we actually created an object.  The query and delete
        // code end up looking at the open packet to determine whether or
        // not the operation actually worked.
        //

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
}

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and is
    also given a handle to a directory file object that the operation is to be
    performed relative to.  This routine is specified as the parse routine for
    all file objects.

    This routine simply invokes the parse routine for the appropriate device
    that is associated with the file object.  It is the responsibility of that
    routine to perform the operation.

Arguments:

    ParseObject - Pointer to the file object that the name is to be opened or
        created relative to.

    ObjectType - Type of the object being opened.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{
    PFILE_OBJECT fileObject;
    POPEN_PACKET op;

    PAGED_CODE();

    //
    // Get the address of the Open Packet (OP).
    //

    op = (POPEN_PACKET) Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    fileObject = (PFILE_OBJECT) ParseObject;

    //
    // Pass the related file object to the device object parse routine.
    //

    op->RelatedFileObject = fileObject;

    //
    // Open or create the specified file.
    //

    return IoParseDevice( fileObject->DeviceObject,
                          ObjectType,
                          Attributes,
                          CompleteName,
                          RemainingName,
                          Context,
                          Object );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\qsfs.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    qsfs.c

Abstract:

    This module contains the code to implement the NtQueryVolumeInformationFile
    and NtSetVolumeInformationFile system services for the NT I/O system.

--*/

#include "iop.h"

NTSTATUS
NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service returns information about the volume associated with the
    FileHandle parameter.  The information returned in the buffer is defined
    by the FsInformationClass parameter.  The legal values for this parameter
    are as follows:

        o  FileFsVolumeInformation

        o  FileFsSizeInformation

        o  FileFsDeviceInformation

        o  FileFsAttributeInformation

Arguments:

    FileHandle - Supplies a handle to an open volume, directory, or file
        for which information about the volume is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Ensure that the FsInformationClass parameter is legal for querying
    // information about the volume.
    //

    if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
        IopQueryFsOperationLength[FsInformationClass] == 0) {
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    // Finally, ensure that the supplied buffer is large enough to contain
    // the information associated with the specified query operation that
    // is to be performed.
    //

    if (Length < (ULONG) IopQueryFsOperationLength[FsInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if ((IopQueryFsOperationAccess[FsInformationClass] & FILE_READ_DATA) &&
        !fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get a pointer to the device object for the target device.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // If this I/O operation is not being performed as synchronous I/O,
    // then allocate an event that will be used to synchronize the
    // completion of this operation.  That is, this system service is
    // a synchronous API being invoked for a file that is opened for
    // asynchronous I/O.
    //

    if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.  The allocation is performed with an exception handler
    // in case the caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an
        // appropriate error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = FsInformation;
    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryVolume.Length = Length;
    irpSp->Parameters.QueryVolume.FsInformationClass = FsInformationClass;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               &localEvent,
                                               irp,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\iosubs.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    iosubs.c

Abstract:

    This module contains the subroutines for the I/O system.

--*/

#include "iop.h"

PIRP
IoAllocateIrp(
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine allocates an I/O Request Packet from the system nonpaged pool.
    The packet will be allocated to contain StackSize stack locations.  The IRP
    will also be initialized.

Arguments:

    StackSize - Specifies the maximum number of stack locations required.

Return Value:

    The function value is the address of the allocated/initialized IRP,
    or NULL if one could not be allocated.

--*/

{
    USHORT packetSize;
    PIRP irp;

    packetSize = IoSizeOfIrp(StackSize);

    //
    // Attempt to allocate the IRP from non-paged pool.
    //

    irp = ExAllocatePoolWithTag(packetSize, ' prI');

    if (!irp) {
        return NULL;
    }

    //
    // Initialize the packet.
    //

    IopInitializeIrp(irp, packetSize, StackSize);

    return irp;
}

PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    IoStatusBlock - Pointer to the I/O status block for completion status
        information.  This parameter is optional since most asynchronous FSD
        requests will be synchronized by using completion routines, and so the
        I/O status block will not be written.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    //
    // Begin by allocating the IRP for this request.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize );
    if (!irp) {
        return irp;
    }
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code.
    //

    irpSp->MajorFunction = (UCHAR) MajorFunction;

    if (MajorFunction != IRP_MJ_FLUSH_BUFFERS &&
        MajorFunction != IRP_MJ_SHUTDOWN) {

        irp->UserBuffer = Buffer;

        //
        // Now determine whether or not we should automatically lock the user's
        // buffer for direct I/O.
        //

        if ((DeviceObject->Flags & DO_DIRECT_IO) && (Length != 0)) {
            IoLockUserBuffer(irp, Length);
        }

        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            irpSp->Parameters.Write.Length = Length;
            irpSp->Parameters.Write.ByteOffset = *StartingOffset;
        } else {
            irpSp->Parameters.Read.Length = Length;
            irpSp->Parameters.Read.ByteOffset = *StartingOffset;
        }
    }

    //
    // Finally, set the address of the I/O status block and return a pointer
    // to the IRP.
    //

    irp->UserIosb = IoStatusBlock;
    return irp;
}

PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) that can be used to
    perform a synchronous internal or normal device I/O control function.

Arguments:

    IoControlCode - Specifies the device I/O control code that is to be
        performed by the target device driver.

    DeviceObject - Specifies the target device on which the I/O control
        function is to be performed.

    InputBuffer - Optional pointer to an input buffer that is to be passed
        to the device driver.

    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-
        Buffer parameter is not passed, this parameter must be zero.

    OutputBuffer - Optional pointer to an output buffer that is to be passed
        to the device driver.

    OutputBufferLength - Length of the OutputBuffer in bytes.  If the
        OutputBuffer parameter is not passed, this parameter must be zero.

    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether
        the packet that gets generated should have a major function code
        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or
        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).

    Event - Supplies a pointer to a kernel event that is to be set to the
        Signaled state when the I/O operation is complete.  Note that the
        Event must already be set to the Not-Signaled state.

    IoStatusBlock - Supplies a pointer to an I/O status block that is to
        be filled in with the final status of the operation once it
        completes.

Return Value:

    The function value is a pointer to the generated IRP suitable for calling
    the target device driver.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG method;
    NTSTATUS status;

    //
    // Begin by allocating the IRP for this request.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize );
    if (!irp) {
        return irp;
    }
    irp->UserBuffer = OutputBuffer;

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code based on the type of device I/O control
    // function the caller has specified.
    //

    if (InternalDeviceIoControl) {
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    } else {
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all four methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBuffer = InputBuffer;

    //
    // Based on the method that the buffer are being passed, lock down the
    // output buffer.
    //

    if (OutputBufferLength != 0) {

        method = IoControlCode & 3;

        if ((method == METHOD_IN_DIRECT) || (method == METHOD_OUT_DIRECT)) {
            IoLockUserBuffer(irp, OutputBufferLength);
        }
    }

    //
    // Finally, set the address of the I/O status block and the address of
    // the kernel event object.  Note that I/O completion will not attempt
    // to dereference the event since there is no file object associated
    // with this operation.
    //

    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;

    //
    // Also set the address of the current thread in the packet so the
    // completion code will have a context to execute in.  The IRP also
    // needs to be queued to the thread since the caller is going to set
    // the file object pointer.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IopQueueThreadIrp( irp );

    //
    // Simply return a pointer to the packet.
    //

    return irp;
}

PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

    The IRP created by this function causes the I/O system to complete the
    request by setting the specified event to the Signaled state.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    Event - Pointer to a kernel event structure for synchronization.  The event
        will be set to the Signaled state when the I/O has completed.

    IoStatusBlock - Pointer to I/O status block for completion status info.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;

    //
    // Do all of the real work in real IRP build routine.
    //

    irp = IoBuildAsynchronousFsdRequest( MajorFunction,
                                         DeviceObject,
                                         Buffer,
                                         Length,
                                         StartingOffset,
                                         IoStatusBlock );
    if (irp == NULL) {
        return irp;
    }

    //
    // Now fill in the event to the completion code will do the right thing.
    // Notice that because there is no FileObject, the I/O completion code
    // will not attempt to dereference the event.
    //

    irp->UserEvent = Event;

    //
    // There will be a file object associated w/this packet, so it must be
    // queued to the thread.
    //

    IopQueueThreadIrp( irp );
    return irp;
}

NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to pass an I/O Request Packet (IRP) to another
    driver at its dispatch routine.

Arguments:

    DeviceObject - Pointer to device object to which the IRP should be passed.

    Irp - Pointer to IRP for request.

Return Value:

    Return status from driver's dispatch routine.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVER_OBJECT driverObject;
    NTSTATUS status;

    //
    // Ensure that this is really an I/O Request Packet.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Update the IRP stack to point to the next location.
    //
    Irp->CurrentLocation--;

    if (Irp->CurrentLocation <= 0) {
        KeBugCheckEx( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, 0, 0, 0 );
    }

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    //
    // Save a pointer to the device object for this request so that it can
    // be used later in completion.
    //

    irpSp->DeviceObject = DeviceObject;

    //
    // Invoke the driver at its dispatch routine entry point.
    //

    driverObject = DeviceObject->DriverObject;

    status = driverObject->MajorFunction[irpSp->MajorFunction]( DeviceObject,
                                                              Irp );

    return status;
}

VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine cancels all of the I/O operations for the specified thread.
    This is accomplished by walking the list of IRPs in the thread IRP list
    and canceling each one individually.  No other I/O operations can be
    started for the thread since this routine has control of the thread itself.

Arguments:

    Tcb - Pointer to the Thread Control Block for the thread.

Return Value:

    None.

--*/

{
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;
    PIRP irp;
    ULONG count;
    LARGE_INTEGER interval;

    PAGED_CODE();

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC and so that we can mark all of the IRPs as canceled without being
    // interrupted by IofCompleteRequest.
    //

    irql = KeRaiseIrqlToDpcLevel();

    header = &Thread->IrpList;
    entry = Thread->IrpList.Flink;

    //
    // Walk the list of pending IRPs, canceling each of them.
    //

    while (header != entry) {
        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        irp->Cancel = TRUE;
        entry = entry->Flink;
    }

    //
    // Wait for the requests to complete.  Note that waiting may eventually
    // timeout, in which case more work must be done.
    //

    count = 0;
    interval.QuadPart = -10 * 1000 * 100;

    while (!IsListEmpty( &Thread->IrpList )) {

        //
        // Lower the IRQL so that the thread APC can fire which will complete
        // the requests.  Delay execution for a time and let the request
        // finish.  The delay time is 100ms.
        //

        KeLowerIrql( irql );
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        if (count++ > 3000) {

            //
            // This I/O request has timed out, as it has not been completed
            // for a full 5 minutes. Attempt to remove the packet's association
            // with this thread.  Note that by not resetting the count, the
            // next time through the loop the next packet, if there is one,
            // which has also timed out, will be dealt with, although it
            // will be given another 100ms to complete.
            //

            IopDisassociateThreadIrp();
        }

        KeRaiseIrql( APC_LEVEL, &irql );
    }

    KeLowerIrql( irql );
}

NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not a new accessor to
    a file actually has shared access to it.  The check is made according
    to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    If the open should succeed, then the access information about how the
    file is currently opened is updated, according to the Update parameter.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

    Update - Specifies whether or not the share access information for the
        file is to be updated.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,
    STATUS_SHARING_VIOLATION is returned.

Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    UCHAR ocount;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // Now check to see whether or not the desired accesses are compatible
        // with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ( (ocount == MAXUCHAR)
             ||
             (FileObject->ReadAccess && (ShareAccess->SharedRead < ocount))
             ||
             (FileObject->WriteAccess && (ShareAccess->SharedWrite < ocount))
             ||
             (FileObject->DeleteAccess && (ShareAccess->SharedDelete < ocount))
             ||
             ((ShareAccess->Readers != 0) && !FileObject->SharedRead)
             ||
             ((ShareAccess->Writers != 0) && !FileObject->SharedWrite)
             ||
             ((ShareAccess->Deleters != 0) && !FileObject->SharedDelete)
           ) {

            //
            // The check failed.  Simply return to the caller indicating that the
            // current open cannot access the file.
            //

            return STATUS_SHARING_VIOLATION;

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        } else if (Update) {

            ShareAccess->OpenCount++;

            ShareAccess->Readers += FileObject->ReadAccess;
            ShareAccess->Writers += FileObject->WriteAccess;
            ShareAccess->Deleters += FileObject->DeleteAccess;

            ShareAccess->SharedRead += FileObject->SharedRead;
            ShareAccess->SharedWrite += FileObject->SharedWrite;
            ShareAccess->SharedDelete += FileObject->SharedDelete;
        }
    }
    return STATUS_SUCCESS;
}

VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is invoked to complete an I/O request.  It is invoked by the
    driver in its DPC routine to perform the final completion of the IRP.  The
    functions performed by this routine are as follows.

        1.  A check is made to determine whether the packet's stack locations
            have been exhausted.  If not, then the stack location pointer is set
            to the next location and if there is a routine to be invoked, then
            it will be invoked.  This continues until there are either no more
            routines which are interested or the packet runs out of stack.

            If a routine is invoked to complete the packet for a specific driver
            which needs to perform work a lot of work or the work needs to be
            performed in the context of another process, then the routine will
            return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.
            This indicates that this completion routine should simply return to
            its caller because the operation will be "completed" by this routine
            again sometime in the future.

        2.  A check is made to determine whether this IRP is an associated IRP.
            If it is, then the count on the master IRP is decremented.  If the
            count for the master becomes zero, then the master IRP will be
            completed according to the steps below taken for a normal IRP being
            completed.  If the count is still non-zero, then this IRP (the one
            being completed) will simply be deallocated.

        3.  If this is paging I/O or a close operation, then simply write the
            I/O status block and set the event to the signaled state, and
            dereference the event.  If this is paging I/O, deallocate the IRP
            as well.

        4.  Unlock the pages, if any, specified by the MDL by calling
            MmUnlockPages.

        5.  A check is made to determine whether or not completion of the
            request can be deferred until later.  If it can be, then this
            routine simply exits and leaves it up to the originator of the
            request to fully complete the IRP.  By not initializing and queueing
            the special kernel APC to the calling thread (which is the current
            thread by definition), a lot of interrupt and queueing processing
            can be avoided.

        6.  The final rundown routine is invoked to queue the request packet to
            the target (requesting) thread as a special kernel mode APC.

Arguments:

    Irp - Pointer to the I/O Request Packet to complete.

    PriorityBoost - Supplies the amount of priority boost that is to be given
        to the target thread when the special kernel APC is queued.

Return Value:

    None.

--*/

#define ZeroIrpStackLocation( IrpSp ) {         \
    (IrpSp)->MinorFunction = 0;                 \
    (IrpSp)->Flags = 0;                         \
    (IrpSp)->Control = 0 ;                      \
    (IrpSp)->Parameters.Others.Argument1 = 0;   \
    (IrpSp)->Parameters.Others.Argument2 = 0;   \
    (IrpSp)->Parameters.Others.Argument3 = 0;   \
    (IrpSp)->Parameters.Others.Argument4 = 0;   \
    (IrpSp)->FileObject = (PFILE_OBJECT) NULL; }

{
    NTSTATUS status;
    PIO_STACK_LOCATION stackPointer;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    //
    // Begin by ensuring that this packet has not already been completed
    // by someone.
    //

    if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1) ||
        Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }

    //
    // Ensure that the packet being completed really is still an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Ensure that the packet is not being completed with a thoroughly
    // confusing status code.  Actually completing a packet with a pending
    // status probably means that someone forgot to set the real status in
    // the packet.
    //

    ASSERT( Irp->IoStatus.Status != STATUS_PENDING );

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( Irp->IoStatus.Status != 0xffffffff );

    //
    // Now check to see whether this is the last driver that needs to be
    // invoked for this packet.  If not, then bump the stack and check to
    // see whether the driver wishes to see the completion.  As each stack
    // location is examined, invoke any routine which needs to be invoked.
    // If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the
    // processing of this packet.
    //

    for (stackPointer = IoGetCurrentIrpStackLocation( Irp ),
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++;
         Irp->CurrentLocation <= (CCHAR) (Irp->StackCount + 1);
         stackPointer++,
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++) {

        //
        // Check if the stack location is marked as a must complete packet.  If
        // so, decrement the number of pending must complete packets.
        //

        if (stackPointer->Control & SL_MUST_COMPLETE) {

            ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

            if ((--IoPendingMustCompletePackets == 0) &&
                HalIsResetOrShutdownPending()) {
                HalMustCompletePacketsFinished();
            }
        }

        //
        // A stack location was located.  Check to see whether or not it
        // has a completion routine and if so, whether or not it should be
        // invoked.
        //
        // Begin by saving the pending returned flag in the current stack
        // location in the fixed part of the IRP.
        //

        Irp->PendingReturned = (BOOLEAN)(stackPointer->Control & SL_PENDING_RETURNED);

        if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
             (!NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_ERROR)
           ) {

            //
            // This driver has specified a completion routine.  Invoke the
            // routine passing it a pointer to its device object and the
            // IRP that is being completed.
            //

            ZeroIrpStackLocation( stackPointer );

            status = stackPointer->CompletionRoutine( (PDEVICE_OBJECT) (Irp->CurrentLocation == (CCHAR) (Irp->StackCount + 1) ?
                                                      (PDEVICE_OBJECT) NULL :
                                                      IoGetCurrentIrpStackLocation( Irp )->DeviceObject),
                                                      Irp,
                                                      stackPointer->Context );

            if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                //
                // Note:  Notice that if the driver has returned the above
                //        status value, it may have already DEALLOCATED the
                //        packet!  Therefore, do NOT touch any part of the
                //        IRP in the following code.
                //

                return;
            }

        } else {
            if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
                IoMarkIrpPending( Irp );
            }
            ZeroIrpStackLocation( stackPointer );
        }
    }

    //
    // Check to see if this is paging I/O or a close operation.  If either,
    // then special processing must be performed.  The reasons that special
    // processing must be performed is different based on the type of
    // operation being performed.  The biggest reasons for special processing
    // on paging operations are that using a special kernel APC for an in-
    // page operation cannot work since the special kernel APC can incur
    // another pagefault.  Likewise, all paging I/O uses MDLs that belong
    // to the memory manager, not the I/O system.
    //
    // Close operations are special because the close may have been invoked
    // because of a special kernel APC (some IRP was completed which caused
    // the reference count on the object to become zero while in the I/O
    // system's special kernel APC routine).  Therefore, a special kernel APC
    // cannot be used since it cannot execute until the close APC finishes.
    //
    // The special steps are as follows for a synchronous paging operation
    // and close are:
    //
    //     1.  Copy the I/O status block (it is in SVAS, nonpaged).
    //     2.  Signal the event
    //     3.  If paging I/O, deallocate the IRP
    //
    // The special steps taken for asynchronous paging operations (out-pages)
    // are as follows:
    //
    //     1.  Initialize a special kernel APC just for page writes.
    //     1.  Queue the special kernel APC.
    //
    // It should also be noted that the logic for completing a Mount request
    // operation is exactly the same as a Page Read.  No assumptions should be
    // made here about this being a Page Read operation w/o carefully checking
    // to ensure that they are also true for a Mount.  That is:
    //
    //     IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION
    //
    // are the same flag in the IRP.
    //
    // Also note that the last time the IRP is touched for a close operation
    // must be just before the event is set to the signaled state.  Once this
    // occurs, the IRP can be deallocated by the thread waiting for the event.
    //

    if (Irp->Flags & (IRP_MOUNT_COMPLETION | IRP_CLOSE_OPERATION)) {
        ULONG flags;
        flags = Irp->Flags & IRP_MOUNT_COMPLETION;
        *Irp->UserIosb = Irp->IoStatus;
        KeSetEvent( Irp->UserEvent, PriorityBoost, FALSE );
        if (flags) {
            IoFreeIrp( Irp );
        }
        return;
    }

    //
    // Check to see whether any pages need to be unlocked.
    //

    if ((Irp->Flags & IRP_UNLOCK_USER_BUFFER) != 0) {
        MmLockUnlockBufferPages(Irp->UserBuffer, Irp->LockedBufferLength, TRUE);
        Irp->Flags &= ~IRP_UNLOCK_USER_BUFFER;
    } else if (Irp->SegmentArray != NULL) {
        MmUnlockSelectedIoPages(Irp);
    }

    //
    // Make a final check here to determine whether or not this is a
    // synchronous I/O operation that is being completed in the context
    // of the original requestor.  If so, then an optimal path through
    // I/O completion can be taken.
    //

    if (Irp->Flags & IRP_DEFER_IO_COMPLETION && !Irp->PendingReturned) {
        return;
    }

    //
    // Finally, initialize the IRP as an APC structure and queue the special
    // kernel APC to the target thread.
    //

    thread = Irp->Tail.Overlay.Thread;
    fileObject = Irp->Tail.Overlay.OriginalFileObject;

    if (!Irp->Cancel) {

        KeInitializeApc( &Irp->Tail.Apc,
                         &thread->Tcb,
                         IopCompleteRequest,
                         (PKRUNDOWN_ROUTINE) NULL,
                         (PKNORMAL_ROUTINE) NULL,
                         KernelMode,
                         (PVOID) NULL );

        (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                 fileObject,
                                 (PVOID) NULL,
                                 PriorityBoost );
    } else {

        //
        // This request has been cancelled.  Ensure that access to the thread
        // is synchronized, otherwise it may go away while attempting to get
        // through the remainder of completion for this request.  This happens
        // when the thread times out waiting for the request to be completed
        // once it has been cancelled.
        //
        // Note that it is safe to capture the thread pointer above, w/o having
        // the lock because the cancel flag was not set at that point, and
        // the code that disassociates IRPs must set the flag before looking to
        // see whether or not the packet has been completed, and this packet
        // will appear to be completed because it no longer belongs to a driver.
        //

        irql = IopAcquireCompletionLock();

        thread = Irp->Tail.Overlay.Thread;

        if (thread) {

            KeInitializeApc( &Irp->Tail.Apc,
                             &thread->Tcb,
                             IopCompleteRequest,
                             (PKRUNDOWN_ROUTINE) NULL,
                             (PKNORMAL_ROUTINE) NULL,
                             KernelMode,
                             (PVOID) NULL );

            (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                     fileObject,
                                     (PVOID) NULL,
                                     PriorityBoost );

            IopReleaseCompletionLock(irql);

        } else {

            //
            // This request has been aborted from completing in the caller's
            // thread.  This can only occur if the packet was cancelled, and
            // the driver did not complete the request, so it was timed out.
            // Attempt to drop things on the floor, since the originating thread
            // has probably exited at this point.
            //

            IopReleaseCompletionLock(irql);

            ASSERT( Irp->Cancel );

            //
            // Drop the IRP on the floor.
            //

            IopDropIrp( Irp, fileObject );
        }
    }
}

NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN POBJECT_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine creates a device object and links it into the I/O database.

Arguments:

    DriverObject - A pointer to the driver object for this device.

    DeviceExtensionSize - Size, in bytes, of extension to device object;
        i.e., the size of the driver-specific data for this device object.

    DeviceName - The name that should be associated with this device.

    DeviceType - The type of device that the device object should represent.

    Exclusive - Indicates that the device object should be created with using
        the exclusive object attribute.

        NOTE: This flag should not be used for WDM drivers.  Since only the
        PDO is named, it is the only device object in a devnode attachment
        stack that is openable.  However, since this device object is created
        by the underlying bus driver (which has no knowledge about what type
        of device this is), there is no way to know whether this flag should
        be set.  Therefore, this parameter should always be FALSE for WDM
        drivers.  Drivers attached to the PDO (e.g., the function driver) must
        enforce any exclusivity rules.

    DeviceObject - Pointer to the device object pointer we will return.

Return Value:

    The function value is the final status of the operation.


--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PDEVICE_OBJECT deviceObject;
    HANDLE handle;
    BOOLEAN deviceHasName;
    ULONG RoundedSize;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Remember whether or not this device was created with a name so that
    // it can be deallocated later.
    //

    deviceHasName = (BOOLEAN) (ARGUMENT_PRESENT( DeviceName ) ? TRUE : FALSE);

    //
    // Initialize the object attributes structure in preparation for creating
    // device object.  Note that the device may be created as an exclusive
    // device so that only one open can be done to it at a time.  This saves
    // single user devices from having drivers that implement special code to
    // make sure that only one connection is ever valid at any given time.
    //

    InitializeObjectAttributes( &objectAttributes,
                                DeviceName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );


    if (Exclusive) {
        objectAttributes.Attributes |= OBJ_EXCLUSIVE;
    } else {
        objectAttributes.Attributes |= 0;
    }

    if (deviceHasName) {
        objectAttributes.Attributes |= OBJ_PERMANENT;
    }

    //
    // Create the device object itself.
    //

    RoundedSize = (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize)
                   % sizeof (LONGLONG);
    if (RoundedSize) {
        RoundedSize = sizeof (LONGLONG) - RoundedSize;
    }

    RoundedSize += DeviceExtensionSize;

    status = ObCreateObject( &IoDeviceObjectType,
                             &objectAttributes,
                             (ULONG) sizeof( DEVICE_OBJECT ) +
                                     RoundedSize,
                             (PVOID *) &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        // Creating the device object was not successful.  Clean everything
        // up and indicate that the object was not created.
        //

        deviceObject = (PDEVICE_OBJECT) NULL;

    } else {

        //
        // The device was successfully created.  Initialize the object so
        // that it can be inserted into the object table.  Begin by zeroing
        // the memory for the device object.
        //

        RtlZeroMemory( deviceObject,
                       sizeof( DEVICE_OBJECT ) + RoundedSize );

        //
        // Set the type and size of this device object.
        //

        deviceObject->Type = IO_TYPE_DEVICE;
        deviceObject->Size = (USHORT) (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize);

        //
        // The device type field in the device object was shrunk to a single
        // byte.  All of the valid types defined in devioctl.h fall well below
        // this limit.
        //

        ASSERT(DeviceType == (DEVICE_TYPE)(UCHAR)DeviceType);

        //
        // Set the device type field in the object so that later code can
        // check the type.  Likewise, set the device characteristics.
        //

        deviceObject->DeviceType = (UCHAR)DeviceType;

        //
        // If this device is a storage device, set the MountedOrSelfDevice field
        // to NULL so that IoParseDevice forces a mount for the device.  All
        // other devices do not require a mount, so set the MountedOrSelfDevice
        // field to the device itself.
        //

        if ((DeviceType == FILE_DEVICE_DISK) ||
            (DeviceType == FILE_DEVICE_MEMORY_UNIT) ||
            (DeviceType == FILE_DEVICE_CD_ROM) ||
            (DeviceType == FILE_DEVICE_MEDIA_BOARD)) {

            KeInitializeEvent( &deviceObject->DeviceLock,
                               SynchronizationEvent,
                               TRUE );

            deviceObject->MountedOrSelfDevice = NULL;

        } else {

            deviceObject->MountedOrSelfDevice = deviceObject;
        }

        //
        // Initialize the remainder of the device object.
        //
        deviceObject->AlignmentRequirement = 0;
        deviceObject->Flags = DO_DEVICE_INITIALIZING;

        if (Exclusive) {
            deviceObject->Flags |= DO_EXCLUSIVE;
        }
        if (deviceHasName) {
            deviceObject->Flags |= DO_DEVICE_HAS_NAME;
        }

        if(DeviceExtensionSize) {
            deviceObject->DeviceExtension = deviceObject + 1;
        } else {
            deviceObject->DeviceExtension = NULL;
        }

        deviceObject->StackSize = 1;

        //
        // This is a real device of some sort.  Allocate a spin lock
        // and initialize the device queue object in the device object.
        //

        KeInitializeDeviceQueue( &deviceObject->DeviceQueue );

        //
        // Insert the device object into the table.
        //

        status = ObInsertObject( deviceObject,
                                 &objectAttributes,
                                 1,
                                 &handle );

        if (NT_SUCCESS( status )) {

            //
            // The insert completed successfully.  Link the device object
            // and driver objects together.  Close the handle so that if
            // the driver is unloaded, the device object can go away.
            //

            deviceObject->DriverObject = DriverObject;

            NtClose( handle );

        } else {

            //
            // The insert operation failed.  Fortunately it dropped the
            // reference count on the device - since that was the last one
            // all the cleanup should be done for us.
            //

            //
            // indicate that no device object was created.
            //

            deviceObject = (PDEVICE_OBJECT) NULL;
        }
    }

    *DeviceObject = deviceObject;
    return status;
}

NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN ULONG Options
    )

/*++

Routine Description:

    This is the common routine for both NtCreateFile and NtOpenFile to allow
    a user to create or open a file.  This procedure is also used internally
    by kernel mode components, such as the network server, to perform the
    same type of operation, but allows kernel mode code to force checking
    arguments and access to the file, rather than bypassing these checks
    because the code is running in kernel mode.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    DesiredAccess - Supplies the types of access that the caller would like
        to the file.

    ObjectAttributes - Supplies the attributes to be used for the file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.
        This parameter only has an affect if the file is created.  Further,
        if not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    Disposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    Options - Specifies the options that are to be used during generation
        of the create IRP.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    OPEN_PACKET openPacket;
    BOOLEAN SuccessfulIoParse;
    LARGE_INTEGER initialAllocationSize;

    PAGED_CODE();

    if (Options & IO_CHECK_CREATE_PARAMETERS) {

        //
        // Check for any invalid parameters.
        //

        if (

            //
            // Check that no invalid file attributes flags were specified.
            //

//          (FileAttributes & ~FILE_ATTRIBUTE_VALID_SET_FLAGS)
            (FileAttributes & ~FILE_ATTRIBUTE_VALID_FLAGS)

            ||

            //
            // Check that no invalid share access flags were specified.
            //

            (ShareAccess & ~FILE_SHARE_VALID_FLAGS)

            ||

            //
            // Ensure that the disposition value is in range.
            //

            (Disposition > FILE_MAXIMUM_DISPOSITION)

            ||

            //
            // Check that no invalid create options were specified.
            //

            (CreateOptions & ~FILE_VALID_OPTION_FLAGS)

            ||

            //
            // If the caller specified synchronous I/O, then ensure that
            // (s)he also asked for synchronize desired access to the
            // file.
            //

            (CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT) &&
            (!(DesiredAccess & SYNCHRONIZE)))

            ||

            //
            // Also, if the caller specified that the file is to be deleted
            // on close, then ensure that delete is specified as one of the
            // desired accesses requested.
            //

            (CreateOptions & FILE_DELETE_ON_CLOSE &&
            (!(DesiredAccess & DELETE)))

            ||

            //
            // Likewise, ensure that if one of the synchronous I/O modes
            // is specified that the other one is not specified as well.
            //

            ((CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ==
                              (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT))

            ||

            //
            // If this create or open is for a directory operation, check
            // that all of the other flags, dispositions, and desired
            // access parameters were also specified correctly.
            //
            // These are as follows:
            //
            //     o  No other flags other than the synchronous I/O flags,
            //        write-through, or open by file ID are set.
            //
            //     o  The disposition value is one of create, open, or
            //        open-if.
            //
            //     o  No non-directory accesses have been specified.
            //

            ((CreateOptions & FILE_DIRECTORY_FILE)
             && !(CreateOptions & FILE_NON_DIRECTORY_FILE)
             && ((CreateOptions & ~(FILE_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_ALERT |
                                    FILE_SYNCHRONOUS_IO_NONALERT |
                                    FILE_WRITE_THROUGH |
                                    FILE_COMPLETE_IF_OPLOCKED |
                                    FILE_OPEN_FOR_BACKUP_INTENT |
                                    FILE_DELETE_ON_CLOSE |
                                    FILE_OPEN_FOR_FREE_SPACE_QUERY |
                                    FILE_OPEN_BY_FILE_ID |
                                    FILE_OPEN_REPARSE_POINT))
                 || ((Disposition != FILE_CREATE)
                     && (Disposition != FILE_OPEN)
                     && (Disposition != FILE_OPEN_IF))
                )
            )

            ||

            //
            //  FILE_COMPLETE_IF_OPLOCK and FILE_RESERVE_OPFILTER are
            //  incompatible options.
            //

            ((CreateOptions & FILE_COMPLETE_IF_OPLOCKED) &&
             (CreateOptions & FILE_RESERVE_OPFILTER))

            ||

            //
            // Finally, if the no intermediate buffering option was
            // specified, ensure that the caller did not also request
            // append access to the file.
            //

            (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING &&
            (DesiredAccess & FILE_APPEND_DATA)) ) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // The caller's mode is kernel.  Copy the input parameters to their
    // expected locations for later use.
    //

    if (ARGUMENT_PRESENT( AllocationSize )) {
        initialAllocationSize = *AllocationSize;
    } else {
        initialAllocationSize.QuadPart = 0;
    }

    //
    // Now fill in an Open Packet (OP) to be used in calling the device object
    // parse routine.  This packet will allow information to be passed between
    // this routine and the parse routine so that a common context may be kept.
    // For most services this would be done with an I/O Request Packet (IRP),
    // but this cannot be done here because the number of stack entries which
    // need to be allocated in the IRP is not yet known.
    //

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ParseCheck = 0L;
    openPacket.AllocationSize = initialAllocationSize;
    openPacket.CreateOptions = CreateOptions;
    openPacket.FileAttributes = (USHORT) FileAttributes;
    openPacket.ShareAccess = (USHORT) ShareAccess;
    openPacket.Disposition = Disposition;
    openPacket.QueryOnly = FALSE;
    openPacket.DeleteOnly = FALSE;
    openPacket.Options = Options;
    openPacket.RelatedFileObject = (PFILE_OBJECT) NULL;
    openPacket.DesiredAccess = DesiredAccess;

    //
    // Assume that the operation is going to be successful.
    //

    openPacket.FinalStatus = STATUS_SUCCESS;

    //
    // Zero the file object field in the OP so the parse routine knows that
    // this is the first time through.  For reparse operations it will continue
    // to use the same file object that it allocated the first time.
    //

    openPacket.FileObject = (PFILE_OBJECT) NULL;

    //
    // Attempt to open the file object by name.  This will yield the handle
    // that the user is to use as his handle to the file in all subsequent
    // calls, if it works.
    //
    // This call performs a whole lot of the work for actually getting every-
    // thing set up for the I/O system.  The object manager will take the name
    // of the file and will translate it until it reaches a device object (or
    // it fails).  If the former, then it will invoke the parse routine set up
    // by the I/O system for device objects.  This routine will actually end
    // up creating the file object, allocating an IRP, filling it in, and then
    // invoking the driver's dispatch routine with the packet.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 &openPacket,
                                 &handle );

    //
    // Check the status of the open.  If it was not successful, cleanup and
    // get out.  Notice that it is also possible, because this code does not
    // explicitly request that a particular type of object (because the Object
    // Manager does not check when a parse routine is present and because the
    // name first refers to a device object and then a file object), a check
    // must be made here to ensure that what was returned was really a file
    // object.  The check is to see whether the device object parse routine
    // believes that it successfully returned a pointer to a file object.  If
    // it does, then OK;  otherwise, something went wrong somewhere.
    //

    SuccessfulIoParse = (BOOLEAN) (openPacket.ParseCheck == OPEN_PACKET_PATTERN);

    if (!NT_SUCCESS( status ) || !SuccessfulIoParse) {

        if (NT_SUCCESS( status )) {

            //
            // The operation was successful as far as the object system is
            // concerned, but the I/O system device parse routine was never
            // successfully completed so this operation has actually completed
            // with an error because of an object mismatch.  Therefore, this is
            // the wrong type of object so dereference whatever was actually
            // referenced by closing the handle that was created for it.
            // We have to do a NtClose as this handle can be a kernel handle if
            // IoCreateFile was called by a driver.
            //

            NtClose( handle );
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        //
        // If the final status according to the device parse routine
        // indicates that the operation was not successful, then use that
        // routine's final status because it is more descriptive than the
        // status which was returned by the object manager.
        //

        if (!NT_SUCCESS( openPacket.FinalStatus )) {
            status = openPacket.FinalStatus;

            if (NT_WARNING( status )) {

                IoStatusBlock->Status = openPacket.FinalStatus;
                IoStatusBlock->Information = openPacket.Information;
            }

        } else if (openPacket.FileObject != NULL && !SuccessfulIoParse) {

            //
            // Otherwise, one of two things occurred:
            //
            //     1)  The parse routine was invoked at least once and a
            //         reparse was performed but the parse routine did not
            //         actually complete.
            //
            //     2)  The parse routine was successful so everything worked
            //         but the object manager incurred an error after the
            //         parse routine completed.
            //
            // For case #1, there is an outstanding file object that still
            // exists.  This must be cleaned up.
            //
            // For case #2, nothing must be done as the object manager has
            // already dereferenced the file object.  Note that this code is
            // not invoked if the parse routine completed with a successful
            // status return (SuccessfulIoParse is TRUE).
            //

            openPacket.FileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            ObDereferenceObject( openPacket.FileObject );
        }

    } else {

        //
        // At this point, the open/create operation has been successfully
        // completed.  There is a handle to the file object, which has been
        // created, and the file object has been signaled.
        //
        // The remaining work to be done is to complete the operation.  This is
        // performed as follows:
        //
        //    1.  The file object has been signaled, so no work needs to be done
        //        for it.
        //
        //    2.  The file handle is returned to the user.
        //
        //    3.  The I/O status block is written with the final status.
        //

        openPacket.FileObject->Flags |= FO_HANDLE_CREATED;

        ASSERT( openPacket.FileObject->Type == IO_TYPE_FILE );

        //
        // Return the file handle.
        //

        *FileHandle = handle;

        //
        // Write the I/O status into the caller's buffer.
        //

        IoStatusBlock->Information = openPacket.Information;
        IoStatusBlock->Status = openPacket.FinalStatus;
        status = openPacket.FinalStatus;
    }

    //
    // If the parse routine successfully created a file object then
    // derefence it here.
    //

    if (SuccessfulIoParse && openPacket.FileObject != NULL) {
        ObDereferenceObject( openPacket.FileObject );
    }

    return status;
}

NTSTATUS
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    )

/*++

Routine Description:

    This routine is invoked to assign a symbolic link name to a device.

Arguments:

    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.

    DeviceName - Supplies the name to which the symbolic link name refers.

Return Value:

    The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Note that the following assignment can fail (because it is not system
    // initialization time and therefore the \ARCname directory does not
    // exist - if this is really a call to IoAssignArcName), but that is fine.
    //

    status = NtCreateSymbolicLinkObject( &linkHandle,
                                         &objectAttributes,
                                         DeviceName );
    if (NT_SUCCESS( status )) {
        NtClose( linkHandle );
    }

    return status;
}

VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine deletes the specified device object from the system so that
    it may no longer be referenced.  It is invoked when either the device
    driver is being unloaded from the system, or the driver's initialization
    routine failed to properly initialize the device or a fatal driver
    initialization error was encountered, or when the device is being removed
    from the system.

Arguments:

    DeviceObject - Pointer to the device object that is to be deleted.

Return Value:

    None.

--*/

{
    KIRQL irql;

    //
    // If this device has a name, then mark the
    // object as temporary so that when it is dereferenced it will be
    // deleted.
    //

    if (DeviceObject->Flags & DO_DEVICE_HAS_NAME) {
        ObMakeTemporaryObject( DeviceObject );
    }

    //
    // Mark the device object as deleted.
    //

    irql = KeRaiseIrqlToDpcLevel();

    DeviceObject->DeletePending = TRUE;

    if (!DeviceObject->ReferenceCount) {
        IopCompleteUnloadOrDelete( DeviceObject, irql );
    } else {
        KeLowerIrql(irql);
    }
}

NTSTATUS
IoDeleteSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is invoked to remove a symbolic link from the system.  This
    generally occurs whenever a driver that has assigned a symbolic link needs
    to exit.  It can also be used when a driver no longer needs to redirect
    a name.

Arguments:

    SymbolicLinkName - Provides the Unicode name string to be deassigned.

Return Values:

    Status of operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Open the symbolic link itself so that it can be marked temporary and
    // closed.
    //

    status = NtOpenSymbolicLinkObject( &linkHandle,
                                       &objectAttributes );
    if (NT_SUCCESS( status )) {

        //
        // The symbolic link was successfully opened.  Attempt to make it a
        // temporary object, and then close the handle.  This will cause the
        // object to go away.
        //

        status = NtMakeTemporaryObject( linkHandle );
        if (NT_SUCCESS( status )) {
            NtClose( linkHandle );
        }
    }


    return status;
}

NTSTATUS
IoDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine dismounts the file system volume attached to the supplied
    device.

Arguments:

    DeviceObject - Specifies the device to be dismounted.

Return Value:

    Status of operation.

--*/

{
    NTSTATUS status;
    KIRQL OldIrql;
    PDEVICE_OBJECT MountedDeviceObject;

    //
    // Synchronize access to MountedOrSelfDevice with IoParseDevice by raising
    // to DISPATCH_LEVEL.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    MountedDeviceObject = DeviceObject->MountedOrSelfDevice;

    if (MountedDeviceObject != NULL) {

        if (MountedDeviceObject->DriverObject->DriverDismountVolume != NULL) {
            MountedDeviceObject->ReferenceCount++;
            status = STATUS_SUCCESS;
        } else {
            MountedDeviceObject = NULL;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

    } else {
        status = STATUS_VOLUME_DISMOUNTED;
    }

    KeLowerIrql(OldIrql);

    //
    // If the supplied device has been mounted by a device with a dismount
    // volume routine, then invoke that routine.
    //

    if (MountedDeviceObject != NULL) {
        status = MountedDeviceObject->DriverObject->DriverDismountVolume(MountedDeviceObject);
        IopDecrementDeviceObjectRef(MountedDeviceObject);
    }

    return status;
}

NTSTATUS
IoDismountVolumeByName(
    IN POBJECT_STRING DeviceName
    )

/*++

Routine Description:

    This routine dismounts the file system volume attached to the device with
    supplied name.

Arguments:

    DeviceName - Specifies the name of the device to be dismounted.

Return Value:

    Status of operation.

--*/

{
    NTSTATUS status;
    PVOID DeviceObject;

    status = ObReferenceObjectByName(DeviceName, 0, &IoDeviceObjectType, NULL,
        &DeviceObject);

    if (NT_SUCCESS(status)) {
        status = IoDismountVolume((PDEVICE_OBJECT)DeviceObject);
        ObDereferenceObject(DeviceObject);
    }

    return status;
}

VOID
IoFreeIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deallocates the specified I/O Request Packet.

Arguments:

    Irp - I/O Request Packet to deallocate.

Return Value:

    None.

--*/

{
    //
    // Ensure that the data structure being freed is really an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    if (Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }

    ASSERT(IsListEmpty(&(Irp)->ThreadListEntry));
    Irp->Type = 0;

    //
    // Ensure that all of the owners of the IRP have at least been notified
    // that the request is going away.
    //

    ASSERT( Irp->CurrentLocation >= Irp->StackCount );

    //
    // Deallocate the IRP.
    //

    ExFreePool( Irp );
}

VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    Initializes an IRP.

Arguments:

    Irp - a pointer to the IRP to initialize.

    PacketSize - length, in bytes, of the IRP.

    StackSize - Number of stack locations in the IRP.

Return Value:

    None.

--*/

{
    IopInitializeIrp(Irp, PacketSize, StackSize);
}

NTSTATUS
IoInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is the default dispatch routine for all driver entries
    not implemented by drivers that have been loaded into the system.  Its
    responsibility is simply to set the status in the packet to indicate
    that the operation requested is invalid for this device type, and then
    complete the packet.

Arguments:

    DeviceObject - Specifies the device object for which this request is
        bound.  Ignored by this routine.

    Irp - Specifies the address of the I/O Request Packet (IRP) for this
        request.

Return Value:

    The final status is always STATUS_INVALID_DEVICE_REQUEST.


--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Simply store the appropriate status, complete the request, and return
    // the same status stored in the packet.
    //

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_INVALID_DEVICE_REQUEST;
}

VOID
IoLockUserBuffer(
    IN OUT PIRP Irp,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine locks Irp->UserBuffer using MmLockUnlockBufferPages and marks
    the IRP so that on packet cleanup, the buffer is unlocked.

Arguments:

    Irp - Pointer to IRP that describes the buffer to be locked.

    Length - Length, in bytes, of the buffer to be locked.

Return Value:

    None.

--*/

{
    ASSERT(Length != 0);

    //
    // If this is a scatter/gather operation or if the user buffer has already
    // been locked down, then we don't need to do anything.
    //

    if ((Irp->Flags & (IRP_SCATTER_GATHER_OPERATION | IRP_UNLOCK_USER_BUFFER)) == 0) {

        //
        // This isn't a scatter/gather operation, so the user buffer should have
        // been set to a valid pointer.
        //

        ASSERT(Irp->UserBuffer != NULL);

        MmLockUnlockBufferPages(Irp->UserBuffer, Length, FALSE);

        Irp->LockedBufferLength = Length;
        Irp->Flags |= IRP_UNLOCK_USER_BUFFER;

    } else {

        ASSERT(Irp->LockedBufferLength == Length);
    }
}

VOID
IoMarkIrpMustComplete(
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine marks the IRP as a must complete packet.  Must complete packets
    delay a system reset or shutdown until they are complete.

    This routine can only be called as DISPATCH_LEVEL.  The HAL code that relies
    on this variable only runs as a DPC.

Arguments:

    Irp - Pointer to IRP.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Only mark the current stack location once.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((IrpSp->Control & SL_MUST_COMPLETE) == 0) {

        //
        // Mark the IRP so that we know that on completion of this IRP that the
        // must complete packet should be decremented.
        //

        IrpSp->Control |= SL_MUST_COMPLETE;

        //
        // Increment the number of must complete packets.
        //

        IoPendingMustCompletePackets++;
    }
}

NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FileInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FileInformationClass,
                                   Length,
                                   FileInformation,
                                   ReturnedLength,
                                   TRUE );
}

NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified volume.
    The information returned is determined by the FsInformationClass that
    is specified, and it is placed into the caller's FsInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

    Length - Supplies the length of the FsInformation buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FsInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FsInformationClass,
                                   Length,
                                   FsInformation,
                                   ReturnedLength,
                                   FALSE );
}

VOID
IoQueueThreadIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine queues the specified I/O Request Packet (IRP) to the current
    thread's IRP pending queue.  This queue locates all of the outstanding
    I/O requests for the thread.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) to be queued.

Return Value:

    None.

--*/

{
    //
    // Simply queue the packet using the internal queueing routine.
    //

    IopQueueThreadIrp( Irp );
}

VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    FileObject - Pointer to the file object of the current access being closed.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        //
        // For each access type, decrement the appropriate count in the Share
        // Access structure.
        //

        if (FileObject->ReadAccess) {
            ShareAccess->Readers--;
        }

        if (FileObject->WriteAccess) {
            ShareAccess->Writers--;
        }

        if (FileObject->DeleteAccess) {
            ShareAccess->Deleters--;
        }

        //
        // For each shared access type, decrement the appropriate count in the
        // Share Access structure.
        //

        if (FileObject->SharedRead) {
            ShareAccess->SharedRead--;
        }

        if (FileObject->SharedWrite) {
            ShareAccess->SharedWrite--;
        }

        if (FileObject->SharedDelete) {
            ShareAccess->SharedDelete--;
        }
    }
}

VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to set the access and share access information
    in a file system Share Access structure for the first open.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // Check to see whether the current file opener would like to read,
    // write, or delete the file.  If so, account for it in the share access
    // structure; otherwise, skip it.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Only update the share modes if the user wants to read, write or
        // delete the file.
        //

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // Set the Share Access structure open count.
        //

        ShareAccess->OpenCount = 1;

        //
        // Set the number of readers, writers, and deleters in the Share Access
        // structure.
        //

        ShareAccess->Readers = FileObject->ReadAccess;
        ShareAccess->Writers = FileObject->WriteAccess;
        ShareAccess->Deleters = FileObject->DeleteAccess;

        //
        // Set the number of shared readers, writers, and deleters in the Share
        // Access structure.
        //

        ShareAccess->SharedRead = FileObject->SharedRead;
        ShareAccess->SharedWrite = FileObject->SharedWrite;
        ShareAccess->SharedDelete = FileObject->SharedDelete;

    } else {

        //
        // No read, write, or delete access has been requested.  Simply zero
        // the appropriate fields in the structure so that the next accessor
        // sees a consistent state.
        //

        ShareAccess->OpenCount = 0;
        ShareAccess->Readers = 0;
        ShareAccess->Writers = 0;
        ShareAccess->Deleters = 0;
        ShareAccess->SharedRead = 0;
        ShareAccess->SharedWrite = 0;
        ShareAccess->SharedDelete = 0;
    }
}

VOID
IopStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.  If the Cancelable paramter is TRUE, then the update of
    current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/

{
    PIRP irp;
    PKDEVICE_QUEUE_ENTRY packet;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Remove the next packet from the head of the queue.  If a packet was
    // found, then process it.
    //

    packet = KeRemoveDeviceQueue( &DeviceObject->DeviceQueue );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was located so make it the current packet for this
        // device.
        //

        DeviceObject->CurrentIrp = irp;

        //
        // Mark the device object as busy so that nested calls to
        // IoStartNextPacket(ByKey) cause the requested to be deferred until
        // we're out of this StartIo call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_BUSY;

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

        //
        // The device object's start I/O routine is no longer busy.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_BUSY;
    }
}

VOID
IopStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    PIRP                 irp;
    PKDEVICE_QUEUE_ENTRY packet;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Attempt to remove the indicated packet according to the key from the
    // device queue.  If one is found, then process it.
    //

    packet = KeRemoveByKeyDeviceQueue( &DeviceObject->DeviceQueue, Key );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was successfully located.  Make it the current packet
        // and invoke the driver's start I/O routine for it.
        //

        DeviceObject->CurrentIrp = irp;

        //
        // Mark the device object as busy so that nested calls to
        // IoStartNextPacket(ByKey) cause the requested to be deferred until
        // we're out of this StartIo call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_BUSY;

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

        //
        // The device object's start I/O routine is no longer busy.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_BUSY;
    }
}

VOID
IopStartNextPacketDeferred(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.

    This routine is invoked for deferred requests.  Deferred StartIo requests
    are used to prevent stack overflows that can occur when a StartIo routine
    calls IoStartNextPacket(ByKey) which recursively calls the StartIo routine.
    The nested IoStartNextPacket(ByKey) call is deferred until the topmost
    IoStartPacket or IoStartNextPacket(ByKey) is finished.

Arguments:

    DeviceObject - Pointer to device object itself.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_BUSY));
    ASSERT(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED);

    do {

        //
        // Clear the request for a deferred StartIo call.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_REQUESTED;

        //
        // Make the deferred StartIo call.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED_BYKEY) {
            IopStartNextPacketByKey(DeviceObject, DeviceObject->StartIoKey);
        } else {
            IopStartNextPacket(DeviceObject);
        }

    } while (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED);
}

VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.

Arguments:

    DeviceObject - Pointer to device object itself.

Return Value:

    None.

--*/

{
    //
    // Check if we're nested inside a IoStartPacket or IoStartNextPacket(ByKey)
    // call.
    //

    if (!(DeviceObject->StartIoFlags & DO_STARTIO_BUSY)) {

        //
        // Any requests for a StartIo call should have already been handled in
        // the exit path for IoStartPacket and IoStartNextPacket(ByKey).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // We're not nested.  Start the next packet now.
        //

        IopStartNextPacket(DeviceObject);

        //
        // If IoStartNextPacket(ByKey) was called while we were in the above
        // call, then process the deferred StartIo request.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED) {
            IopStartNextPacketDeferred(DeviceObject);
        }

    } else {

        //
        // A device can only call IoStartNextPacket(ByKey) once per StartIo
        // call (there can only be one current IRP).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // Set up the StartIo flags for a deferred call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_REQUESTED;
        DeviceObject->StartIoFlags &= ~DO_STARTIO_REQUESTED_BYKEY;
    }
}

VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    //
    // Check if we're nested inside a IoStartPacket or IoStartNextPacket(ByKey)
    // call.
    //

    if (!(DeviceObject->StartIoFlags & DO_STARTIO_BUSY)) {

        //
        // Any requests for a StartIo call should have already been handled in
        // the exit path for IoStartPacket and IoStartNextPacket(ByKey).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // We're not nested.  Start the next packet now.
        //

        IopStartNextPacketByKey(DeviceObject, Key);

        //
        // If IoStartNextPacket(ByKey) was called while we were in the above
        // call, then process the deferred StartIo request.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED) {
            IopStartNextPacketDeferred(DeviceObject);
        }

    } else {

        //
        // A device can only call IoStartNextPacket(ByKey) once per StartIo
        // call (there can only be one current IRP).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // Set up the StartIo flags for a deferred call.
        //

        DeviceObject->StartIoFlags |= (DO_STARTIO_REQUESTED |
            DO_STARTIO_REQUESTED_BYKEY);

        DeviceObject->StartIoKey = Key;
    }
}

VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to start the specified packet request (IRP) on the
    specified device.  If the device is already busy, then the packet is
    simply queued to the device queue.

Arguments:

    DeviceObject - Pointer to device object itself.

    Irp - I/O Request Packet which should be started on the device.

    Key - Key to be used in inserting packet into device queue;  optional
        (if not specified, then packet is inserted at the tail).

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    BOOLEAN i;

    //
    // Raise the IRQL of the processor to dispatch level for synchronization.
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    // If a key parameter was specified, then insert the request into the
    // work queue according to the key;  otherwise, simply insert it at the
    // tail.
    //

    if (Key) {
        i = KeInsertByKeyDeviceQueue( &DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry,
                                      *Key );
    } else {
        i = KeInsertDeviceQueue( &DeviceObject->DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry );
    }

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!i) {

        DeviceObject->CurrentIrp = Irp;

        //
        // Mark the device object as busy so that nested calls to
        // IoStartNextPacket(Ex) cause the requested to be deferred until we're
        // out of this StartIo call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_BUSY;

        //
        // Invoke the driver's start I/O routine to get the request going on the device.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, Irp );

        //
        // The device object's start I/O routine is no longer busy.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_BUSY;

        //
        // If IoStartNextPacket(ByKey) was called while we were in the above
        // call, then process the deferred StartIo request.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED) {
            IopStartNextPacketDeferred(DeviceObject);
        }
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller.
    //

    KeLowerIrql( oldIrql );
}

NTSTATUS
IoSynchronousDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnedOutputBufferLength OPTIONAL,
    IN BOOLEAN InternalDeviceIoControl
    )
/*++

Routine Description:

    This routine builds an IRP for a device I/O control function and sends it
    to the supplied device object.

Arguments:

    IoControlCode - Specifies the device I/O control code that is to be
        performed by the target device driver.

    DeviceObject - Specifies the target device on which the I/O control
        function is to be performed.

    InputBuffer - Optional pointer to an input buffer that is to be passed
        to the device driver.

    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-
        Buffer parameter is not passed, this parameter must be zero.

    OutputBuffer - Optional pointer to an output buffer that is to be passed
        to the device driver.

    OutputBufferLength - Length of the OutputBuffer in bytes.  If the
        OutputBuffer parameter is not passed, this parameter must be zero.

    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether
        the packet that gets generated should have a major function code
        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or
        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).

Return Value:

    The function value is the final status of the operation.

--*/
{
    NTSTATUS status;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP Irp;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(IoControlCode, DeviceObject, InputBuffer,
        InputBufferLength, OutputBuffer, OutputBufferLength,
        InternalDeviceIoControl, &Event, &IoStatusBlock);

    if (Irp != NULL) {

        status = IoCallDriver(DeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            status = IoStatusBlock.Status;
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (ReturnedOutputBufferLength != NULL) {
        *ReturnedOutputBufferLength = IoStatusBlock.Information;
    }

    return status;
}

NTSTATUS
IoSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL
    )
/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver
    and sends it to the supplied device object.

    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    OverrideVerifyVolume - A BOOLEAN parmeter that specifies whether the packet
        that gets generated should have the SL_OVERRIDE_VERIFY_VOLUME flag set.

Return Value:

    The function value is the final status of the operation.

--*/
{
    NTSTATUS status;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP Irp;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest(MajorFunction, DeviceObject, Buffer,
        Length, StartingOffset, &Event, &IoStatusBlock);

    if (Irp != NULL) {

        status = IoCallDriver(DeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            status = IoStatusBlock.Status;
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\objsup.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    objsup.c

Abstract:

    This module contains the object support routine for the NT I/O system.

--*/

#include "iop.h"

VOID
IopCloseFile(
    IN PVOID Object,
    IN ULONG SystemHandleCount
    )

/*++

Routine Description:

    This routine is invoked whenever a handle to a file is deleted.  If the
    handle being deleted is the last handle to the file (the ProcessHandleCount
    parameter is one), then all locks for the file owned by the specified
    process must be released.

    Likewise, if the SystemHandleCount is one then this is the last handle
    for this for file object across all processes.  For this case, the file
    system is notified so that it can perform any necessary cleanup on the
    file.

Arguments:

    Object - A pointer to the file object that the handle referenced.

    SystemHandleCount - Count of handles outstanding to the object for the
        entire system.  If the count is one then this is the last handle
        to this file in the system.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    KEVENT event;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    PAGED_CODE();

    fileObject = (PFILE_OBJECT) Object;

    if (SystemHandleCount == 1) {

        //
        // The last handle to this file object for all of the processes in the
        // system has just been closed, so invoke the driver's "cleanup" handler
        // for this file.  This is the file system's opportunity to remove any
        // share access information for the file, to indicate that if the file
        // is opened for a caching operation and this is the last file object
        // to the file, then it can do whatever it needs with memory management
        // to cleanup any information.
        //
        // Begin by getting the address of the target device object.
        //

        deviceObject = fileObject->DeviceObject;

        //
        // Ensure that the I/O system believes that this file has a handle
        // associated with it in case it doesn't actually get one from the
        // Object Manager.  This is done because sometimes the Object Manager
        // actually creates a handle, but the I/O system never finds out
        // about it so it attempts to send two cleanups for the same file.
        //

        fileObject->Flags |= FO_HANDLE_CREATED;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopAcquireFileObjectLock(fileObject);
        }

        //
        // Initialize the local event that will be used to synchronize access
        // to the driver completing this I/O operation.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->UserEvent = &event;
        irp->UserIosb = &irp->IoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
        irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.  No
        // function-specific parameters are required for this operation.
        //

        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_CLEANUP;
        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If no error was incurred, wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // The following code tears down the IRP by hand since it may not
        // either be possible to it to be completed (because this code was
        // invoked as APC_LEVEL in the first place - or because the reference
        // count on the object cannot be incremented due to this routine
        // being invoked by the delete file procedure below).  Cleanup IRPs
        // therefore use close sematics (the close operation flag is set
        // in the IRP) so that the I/O complete request routine itself sets
        // the event to the Signaled state.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        //
        // Also, free the IRP.
        //

        IoFreeIrp( irp );

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return;
}

VOID
IopDeleteFile(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine is invoked when the last handle to a specific file handle is
    being closed and the file object is going away.  It is the responsibility
    of this routine to perform the following functions:

        o  Notify the device driver that the file object is open on that the
           file is being closed.

        o  Dereference the user's error port for the file object, if there
           is one associated with the file object.

        o  Decrement the device object reference count.

Arguments:

    Object - Pointer to the file object being deleted.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL irql;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KEVENT event;

    //
    // Obtain a pointer to the file object.
    //

    fileObject = (PFILE_OBJECT) Object;

    //
    // Get a pointer to the first device driver which should be notified that
    // this file is going away.  If the device driver field is NULL, then this
    // file is being shut down due to an error attempting to get it open in the
    // first place, so do not do any further processing.
    //

    if (fileObject->DeviceObject) {

        deviceObject = fileObject->DeviceObject;

        //
        // If this file has never had a file handle created for it, and yet
        // it exists, invoke the close file procedure so that the file system
        // gets the cleanup IRP it is expecting before sending the close IRP.
        //

        if (!(fileObject->Flags & FO_HANDLE_CREATED)) {
            IopCloseFile( Object, 1 );
        }

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now.  The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopAcquireFileObjectLock(fileObject);
        }

        //
        // Reset a local event that can be used to wait for the device driver
        // to close the file.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );

        //
        // Get a pointer to the stack location for the first driver.  This is
        // where the function codes and parameters are placed.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Fill in the IRP, indicating that this file object is being deleted.
        //

        irpSp->MajorFunction = IRP_MJ_CLOSE;
        irpSp->FileObject = fileObject;
        irp->UserIosb = &ioStatusBlock;
        irp->UserEvent = &event;
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

        //
        // Place this packet in the thread's I/O pending queue.
        //

        IopQueueThreadIrp( irp );

        //
        // Give the device driver the packet.  If this request does not work,
        // there is nothing that can be done about it.  This is unfortunate
        // because the driver may have had problems that it was about to
        // report about other operations (e.g., write behind failures, etc.)
        // that it can no longer report.  The reason is that this routine
        // is really initially invoked by NtClose, which has already closed
        // the caller's handle, and that's what the return status from close
        // indicates:  the handle has successfully been closed.
        //

        status = IoCallDriver( deviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // Perform any completion operations that need to be performed on
        // the IRP that was used for this request.  This is done here as
        // as opposed to in normal completion code because there is a race
        // condition between when this routine executes if it was invoked
        // from a special kernel APC (e.g., some IRP was just completed and
        // dereferenced this file object for the last time), and when the
        // special kernel APC because of this packet's completion executing.
        //
        // This problem is solved by not having to queue a special kernel
        // APC routine for completion of this packet.  Rather, it is treated
        // much like a synchronous paging I/O operation, except that the
        // packet is not even freed during I/O completion.  This is because
        // the packet is still in this thread's queue, and there is no way
        // to get it out except at APC_LEVEL.  Unfortunately, the part of
        // I/O completion that needs to dequeue the packet is running at
        // DISPATCH_LEVEL.
        //
        // Hence, the packet must be removed from the queue (synchronized,
        // of course), and then it must be freed.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        IoFreeIrp( irp );

        //
        // If there was an completion port associated w/this file object, dereference
        // it now, and deallocate the completion context pool.
        //

        if (fileObject->CompletionContext) {
            ObDereferenceObject( fileObject->CompletionContext->Port );
            ExFreePool( fileObject->CompletionContext );
        }

        //
        // Decrement the reference count on the device object.  Note that
        // if the driver has been marked for an unload operation, and the
        // reference count goes to zero, then the driver may need to be
        // unloaded at this point.
        //

        IopDecrementDeviceObjectRef( deviceObject );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\qsinfo.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    qsinfo.c

Abstract:

    This module contains the code to implement the NtQueryInformationFile and
    NtSetInformationFile system services for the NT I/O system.

--*/

#include "iop.h"

//
// Create local definitions for long flag names to make code slightly more
// readable.
//

#define FSIO_A  FILE_SYNCHRONOUS_IO_ALERT
#define FSIO_NA FILE_SYNCHRONOUS_IO_NONALERT

ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This encapsulates extracting and translating the mode bits from
    the passed file object, to be returned from a query information call.

Arguments:

    FileObject - Specifies the file object for which to return Mode info.

Return Value:

    The translated mode information is returned.

--*/

{
    ULONG mode = 0;

    if (FileObject->Flags & FO_SEQUENTIAL_ONLY) {
        mode |= FILE_SEQUENTIAL_ONLY;
    }
    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        mode |= FILE_NO_INTERMEDIATE_BUFFERING;
    }
    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        if (FileObject->Flags & FO_ALERTABLE_IO) {
            mode |= FILE_SYNCHRONOUS_IO_ALERT;
        } else {
            mode |= FILE_SYNCHRONOUS_IO_NONALERT;
        }
    }
    return mode;
}

NTSTATUS
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file about which the requested
        information should be returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    BOOLEAN skipDriver;

    PAGED_CODE();

    //
    // The caller's mode is kernel.  Ensure that at least the information
    // class and lengths are appropriate.
    //

    if ((ULONG) FileInformationClass >= FileMaximumInformation ||
        !IopQueryOperationLength[FileInformationClass]) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    if ((IopQueryOperationAccess[FileInformationClass] & FILE_READ_DATA) &&
        !fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to query the file position pointer.  If so, then
        // return it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested the current file position context
            // information.  This is a relatively frequent call, so it is
            // optimized here to cut through the normal IRP path.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;

            //
            // Return the current position information.
            //

            fileInformation->CurrentByteOffset = fileObject->CurrentByteOffset;

            //
            // Write the I/O status block.
            //

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_POSITION_INFORMATION );

            //
            // Note that the state of the event in the file object has not yet
            // been reset, so it need not be set either.  Therefore, simply
            // cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = FileInformation;
    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // is device independent.  If this is the case, then the request can
    // be satisfied here without having to have all of the drivers implement
    // the same code.  Note that having the IRP is still necessary since
    // the I/O completion code requires it.
    //

    skipDriver = FALSE;

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Return the mode information for this file.
        //

        modeBuffer->Mode = IopGetModeInformation( fileObject );

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_MODE_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAlignmentInformation) {

        PFILE_ALIGNMENT_INFORMATION alignmentInformation = FileInformation;

        //
        // Return the alignment information for this file.
        //

        alignmentInformation->AlignmentRequirement = deviceObject->AlignmentRequirement;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ALIGNMENT_INFORMATION );
        skipDriver = TRUE;
    }

    if (skipDriver) {

        //
        // The requested operation has already been performed.  Simply
        // set the final status in the packet and the return state.
        //

        status = STATUS_SUCCESS;
        irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        //
        // This is not a request that can be [completely] performed here, so
        // invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            KeWaitForSingleObject( &fileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            KeWaitForSingleObject( &localEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = localIoStatus.Status;

            *IoStatusBlock = localIoStatus;
        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return status;
}

NTSTATUS
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the information which should
        be changed on the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        changed about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    HANDLE targetHandle = (HANDLE) NULL;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // The caller's mode is kernel.  Ensure that at least the information
    // class and lengths are appropriate.
    //

    if ((ULONG) FileInformationClass >= FileMaximumInformation ||
        FileInformationClass == FileTrackingInformation ||
        !IopSetOperationLength[FileInformationClass]) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Negative file offsets are illegal.
    //

    ASSERT((FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION, EndOfFile) |
            FIELD_OFFSET(FILE_ALLOCATION_INFORMATION, AllocationSize) |
            FIELD_OFFSET(FILE_POSITION_INFORMATION, CurrentByteOffset)) == 0);

    if (((FileInformationClass == FileEndOfFileInformation) ||
         (FileInformationClass == FileAllocationInformation) ||
         (FileInformationClass == FilePositionInformation)) &&
        (((PFILE_POSITION_INFORMATION)FileInformation)->CurrentByteOffset.HighPart < 0)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if ((IopSetOperationAccess[FileInformationClass] & FILE_WRITE_DATA) &&
        !fileObject->WriteAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to set the file position pointer information.  If so,
        // then set it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested setting the current file position
            // context information.  This is a relatively frequent call, so
            // it is optimized here to cut through the normal IRP path.
            //
            // Begin by checking to see whether the file was opened with no
            // intermediate buffering.  If so, then the file pointer must be
            // set in a manner consistent with the alignment requirement of
            // read and write operations to a non-buffered file.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;
            LARGE_INTEGER currentByteOffset;

            //
            // Attempt to read the position information from the buffer.
            //

            currentByteOffset.QuadPart = fileInformation->CurrentByteOffset.QuadPart;

            if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING &&
                 (deviceObject->SectorSize &&
                 (currentByteOffset.LowPart &
                 (deviceObject->SectorSize - 1)))) ||
                 currentByteOffset.HighPart < 0) {

                    status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set the current file position information.
                //

                fileObject->CurrentByteOffset.QuadPart = currentByteOffset.QuadPart;

                //
                // Write the I/O status block.
                //

                IoStatusBlock->Status = STATUS_SUCCESS;
                IoStatusBlock->Information = 0;
            }

            //
            // Note that the file object's event has not yet been reset,
            // so it is not necessary to set it to the Signaled state, since
            // that is it's state at this point by definition.  Therefore,
            // simply cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = FileInformation;
    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // to set is device independent.  If this is the case, then the request
    // can be satisfied here without having to have all of the drivers
    // implement the same code.  Note that having the IRP is still necessary
    // since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Set the various flags in the mode field for the file object, if
        // they are reasonable.  There are 4 different invalid combinations
        // that the caller may not specify:
        //
        //     1)  An invalid flag was set in the mode field.  Not all Create/
        //         Open options may be changed.
        //
        //     2)  The caller set one of the synchronous I/O flags (alert or
        //         nonalert), but the file is not opened for synchronous I/O.
        //
        //     3)  The file is opened for synchronous I/O but the caller did
        //         not set either of the synchronous I/O flags (alert or non-
        //         alert).
        //
        //     4)  The caller set both of the synchronous I/O flags (alert and
        //         nonalert).
        //

        if ((modeBuffer->Mode & ~FILE_VALID_SET_FLAGS) ||
            ((modeBuffer->Mode & (FSIO_A | FSIO_NA)) && (!(fileObject->Flags & FO_SYNCHRONOUS_IO))) ||
            ((!(modeBuffer->Mode & (FSIO_A | FSIO_NA))) && (fileObject->Flags & FO_SYNCHRONOUS_IO)) ||
            (((modeBuffer->Mode & FSIO_A) && (modeBuffer->Mode & FSIO_NA) ))) {
            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Set or clear the appropriate flags in the file object.
            //

            if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
                fileObject->Flags |= FO_SEQUENTIAL_ONLY;
            } else {
                fileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
            }

            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                if (modeBuffer->Mode & FSIO_A) {
                    fileObject->Flags |= FO_ALERTABLE_IO;
                } else {
                    fileObject->Flags &= ~FO_ALERTABLE_IO;
                }
            }

            status = STATUS_SUCCESS;
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0L;

    } else if (FileInformationClass == FileRenameInformation) {

        PFILE_RENAME_INFORMATION renameBuffer = FileInformation;

        //
        // Check to see whether or not a fully qualified pathname was
        // supplied.  If so, then more processing is required.
        //

        if ((renameBuffer->FileName.Length > 0 &&
            renameBuffer->FileName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) ||
            renameBuffer->RootDirectory != NULL) {

            //
            // A fully qualified file name was specified as the target of
            // the rename operation.  Attempt to open the target file and
            // ensure that the replacement policy for the file is consistent
            // with the caller's request, and ensure that the file is on the
            // same volume.
            //

            status = IopOpenRenameTarget( &targetHandle,
                                          irp,
                                          renameBuffer,
                                          fileObject );
            if (!NT_SUCCESS( status )) {
                irp->IoStatus.Status = status;

            } else {

                //
                // The fully qualified file name specifies a file on the
                // same volume and if it exists, then the caller specified
                // that it should be replaced.
                //

                status = IoCallDriver( deviceObject, irp );
            }

        } else {

            //
            // This is a simple rename operation, so call the driver and
            // let it perform the rename operation within the same directory
            // as the source file.
            //

            status = IoCallDriver( deviceObject, irp );
        }

    } else if (FileInformationClass == FileCompletionInformation) {

        PFILE_COMPLETION_INFORMATION completion = FileInformation;
        PIO_COMPLETION_CONTEXT context;
        PVOID portObject;

        //
        // It is an error if this file object already has an LPC port associated
        // with it.
        //

        if (fileObject->CompletionContext || fileObject->Flags & FO_SYNCHRONOUS_IO) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Attempt to reference the port object by its handle and convert it
            // into a pointer to the port object itself.
            //

            status = ObReferenceObjectByHandle( completion->Port,
                                                &IoCompletionObjectType,
                                                (PVOID *) &portObject );
            if (NT_SUCCESS( status )) {

                //
                // Allocate the memory to be associated w/this file object
                //

                context = ExAllocatePoolWithTag( sizeof( IO_COMPLETION_CONTEXT ),
                                                 'cCoI' );
                if (!context) {

                    ObDereferenceObject( portObject );
                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Everything was successful.  Capture the completion port
                    // and the key.
                    //

                    context->Port = portObject;
                    context->Key = completion->Key;

                    if (!InterlockedCompareExchangePointer( &fileObject->CompletionContext, context, NULL )) {

                        status = STATUS_SUCCESS;

                    } else {

                        //
                        // Someone set the completion context after the check.
                        // Simply drop everything on the floor and return an
                        // error.
                        //

                        ExFreePool( context );
                        ObDereferenceObject( portObject );
                        status = STATUS_INVALID_PARAMETER;
                    }
                }
            }
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            KeWaitForSingleObject( &fileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( &localEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            status = localIoStatus.Status;

            *IoStatusBlock = localIoStatus;
        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    //
    // If there was a target handle generated because of a rename operation,
    // close it now.
    //

    if (targetHandle) {
        NtClose( targetHandle );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\misc.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the code to implement the NtFlushBuffersFile,
    NtSetNewSizeFile, and NtCancelIoFile system services for the NT I/O system.

--*/

#include "iop.h"

//
// Local copies of the Win32 types that are defined in terms of the NT types.
// Needed for NtUserIoApcDispatcher.
//

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    ULONG   Offset;
    ULONG   OffsetHigh;
    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef
VOID
(NTAPI *LPOVERLAPPED_COMPLETION_ROUTINE)(
    ULONG dwErrorCode,
    ULONG dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

NTSTATUS
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This service deletes the specified file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    HANDLE handle;

    PAGED_CODE();

    //
    // Build a parse open packet that tells the parse method to open the file
    // for open for delete access w/the delete bit set, and then close it.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.CreateOptions = FILE_DELETE_ON_CLOSE;
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.DeleteOnly = TRUE;
    openPacket.LocalFileObject = &localFileObject;
    openPacket.DesiredAccess = DELETE;

    //
    // Open the object by its name.  Because of the special DeleteOnly flag
    // set in the open packet, the parse routine will open the file, and
    // then realize that it is only deleting the file, and will therefore
    // immediately dereference the file.  This will cause the cleanup and
    // the close to be sent to the file system, thus causing the file to
    // be deleted.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 &IoFileObjectType,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        return openPacket.FinalStatus;
    }
}

NTSTATUS
NtFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This service causes all buffered data to the file to be written.

Arguments:

    FileHandle - Supplies a handle to the file whose buffers should be flushed.

    IoStatusBlock - Address of the caller's I/O status block.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An exception was incurred while attempting to allocate the IRP.
        // Cleanup and return an appropriate error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }

    //
    // Get a pointer to the stack location for the first driver.  This is used
    // to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = fileObject;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        synchronousIo );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               &localEvent,
                                               irp,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )

/*++

Routine Description:

    This service queries the network attributes information for a specified
    file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    FileInformation - Supplies an output buffer to receive the returned file
        attributes information.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    HANDLE handle;

    PAGED_CODE();

    //
    // Build a parse open packet that tells the parse method to open the file,
    // query the file's full attributes, and close the file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.QueryOnly = TRUE;
    openPacket.LocalFileObject = &localFileObject;
    openPacket.NetworkInformation = FileInformation;
    openPacket.DesiredAccess = FILE_READ_ATTRIBUTES;

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file, and then
    // realize that it is only performing a query.  It will therefore perform
    // the query, and immediately close the file.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 &IoFileObjectType,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        status = openPacket.FinalStatus;
    }

    return status;
}

VOID
NtUserIoApcDispatcher(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/
{
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    ULONG dwErrorCode;
    ULONG dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    dwErrorCode = 0;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
        }
    else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (ULONG)IoStatusBlock->Information;
        }

    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE)(ULONG_PTR)ApcContext;
    lpOverlapped = (LPOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,OVERLAPPED,Internal);

    (CompletionRoutine)(dwErrorCode,dwNumberOfBytesTransfered,lpOverlapped);

    UNREFERENCED_PARAMETER( Reserved );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\i386\filelock.asm ===
TITLE   "File Object Lock Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     filelock.asm
;
;  Abstract:
;
;     This module implements functions to support locking FILE_OBJECTs for
;     synchronous I/O operations.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

        EXTRNP  _KeSetEvent,3
        EXTRNP  _KeWaitForSingleObject,5

_TEXT SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; FASTCALL
; IopAcquireFileObjectLock(
;     IN PFILE_OBJECT FileObject
;     )
;
; Routine Description:
;
;     This function acquires a file object's synchronous I/O lock.
;
; Arguments:
;
;     FileObject - Specifies the file object to lock.
;
; Return Value:
;
;     None.
;
;--
cPublicFastCall IopAcquireFileObjectLock, 1

;
; Increment the lock count.  If the count doesn't transition from negative one
; to zero, then another thread already owns the lock and we need to block.
;

        inc     dword ptr FoLockCount[ecx]
        jnz     AcquireContention
        fstRET  IopAcquireFileObjectLock

AcquireContention:
        xor     eax, eax
        add     ecx, FoLock
.errnz (WrExecutive - 0)
        stdCall _KeWaitForSingleObject,<ecx,eax,eax,eax,eax>
        fstRET  IopAcquireFileObjectLock

fstENDP IopAcquireFileObjectLock

;++
;
; VOID
; FASTCALL
; IopReleaseFileObjectLock(
;     IN PFILE_OBJECT FileObject
;     )
;
; Routine Description:
;
;     This function releases a file object's synchronous I/O lock.
;
; Arguments:
;
;     FileObject - Specifies the file object to unlock.
;
; Return Value:
;
;     None.
;
;--
cPublicFastCall IopReleaseFileObjectLock, 1

;
; Decrement the lock count.  If the lock count is greater than or equal to zero,
; then there are waiters for this lock, so release a waiter.
;

        dec     dword ptr FoLockCount[ecx]
        jge     ReleaseWaiter
        fstRET  IopReleaseFileObjectLock

ReleaseWaiter:
        add     ecx, FoLock
        stdCall _KeSetEvent,<ecx,0,0>
        fstRET  IopReleaseFileObjectLock

fstENDP IopReleaseFileObjectLock

_TEXT ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdcomio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcomio.c

Abstract:

    This module implements the I/O comunications for the portable kernel
    debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"

ULONG
KdpComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine computes the checksum for the string passed in.

Arguments:

    Buffer - Supplies a pointer to the string.

    Length - Supplies the length of the string.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/

{

    ULONG Checksum = 0;

    while (Length > 0) {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }
    return Checksum;
}

USHORT
KdpReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    )

/*++

Routine Description:

    This routine waits for a packet header leader.

Arguments:

    PacketType - supplies the type of packet we are expecting.

    PacketLeader - supplies a pointer to a ulong variable to receive
                   packet leader bytes.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input, PreviousByte = 0;
    ULONG PacketId = 0;
    ULONG Index;
    ULONG ReturnCode;
    BOOLEAN BreakinDetected = FALSE;

    //
    // NOTE - With all the interrupts being off, it is very hard
    // to implement the actual timeout code. (Maybe, by reading the CMOS.)
    // Here we use a loop count to wait about 3 seconds.  The CpGetByte
    // will return with error code = CP_GET_NODATA if it cannot find data
    // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
    //

    Index = 0;
    do {
        ReturnCode = KdPortGetByte(&Input);
        if (ReturnCode == CP_GET_NODATA) {
            if (BreakinDetected) {
                KdpControlCPending = TRUE;
                return KDP_PACKET_RESEND;
            } else {
                return KDP_PACKET_TIMEOUT;
            }
        } else if (ReturnCode == CP_GET_ERROR) {
            Index = 0;
            continue;
        } else {                    // if (ReturnCode == CP_GET_SUCCESS)
            if ( Input == PACKET_LEADER_BYTE ||
                 Input == CONTROL_PACKET_LEADER_BYTE ) {
                if ( Index == 0 ) {
                    PreviousByte = Input;
                    Index++;
                } else if (Input == PreviousByte ) {
                    Index++;
                } else {
                    PreviousByte = Input;
                    Index = 1;
                }
            } else {

                //
                // If we detect breakin character, we need to verify it
                // validity.  (It is possible that we missed a packet leader
                // and the breakin character is simply a data byte in the
                // packet.)
                // Since kernel debugger send out breakin character ONLY
                // when it is waiting for State Change packet.  The breakin
                // character should not be followed by any other character
                // except packet leader byte.
                //

                if ( Input == BREAKIN_PACKET_BYTE ) {
                    BreakinDetected = TRUE;
                } else {

                    //
                    // The following statement is ABSOLUTELY necessary.
                    //

                    BreakinDetected = FALSE;
                }
                Index = 0;
            }
        }
    } while ( Index < 4 );

    if (BreakinDetected) {
        KdpControlCPending = TRUE;
    }

    //
    // return the packet leader and FALSE to indicate no resend is needed.
    //

    if ( Input == PACKET_LEADER_BYTE ) {
        *PacketLeader = PACKET_LEADER;
    } else {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }

    KdDebuggerNotPresent = FALSE;
    return KDP_PACKET_RECEIVED;
}

ULONG
KdpReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads a string from the kernel debugger port.

Arguments:

    Destination - Supplies a pointer to the input string.

    Length - Supplies the length of the string to be read.

Return Value:

    CP_GET_SUCCESS is returned if string is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{

    UCHAR Input;
    ULONG ReturnCode;

    //
    // Read bytes until either a error is encountered or the entire string
    // has been read.
    //
    while (Length > 0) {
        ReturnCode = KdPortGetByte(&Input);
        if (ReturnCode != CP_GET_SUCCESS) {
            return ReturnCode;
        } else {
            *Destination++ = Input;
            Length -= 1;
        }
    }
    return CP_GET_SUCCESS;
}

VOID
KdpSendString (
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes a string to the kernel debugger port.

Arguments:

    Source - Supplies a pointer to the output string.

    Length - Supplies the length of the string to be written.

Return Value:

    None.

--*/

{

    UCHAR Output;

    //
    // Write bytes to the kernel debugger port.
    //

    while (Length > 0) {
        Output = *Source++;
        KdPortPutByte(Output);
        Length -= 1;
    }
    return;
}

VOID
KdpSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) PacketId )) {
        PacketHeader.PacketId = PacketId;
    }
    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;
    KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

    return;
}

ULONG
KdpReceivePacket (
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    )

/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is KdPrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input;
    ULONG MessageLength;
    KD_PACKET PacketHeader;
    ULONG ReturnCode;
    ULONG Checksum;

WaitForPacketLeader:

    //
    // Read Packet Leader
    //

    ReturnCode = KdpReceivePacketLeader(PacketType, &PacketHeader.PacketLeader);

    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //

    if (ReturnCode != KDP_PACKET_TIMEOUT) {
        KdpNumberRetries = KdpRetryCount;
    }
    if (ReturnCode != KDP_PACKET_RECEIVED) {
        return ReturnCode;
    }

    //
    // Read packet type.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketType,
                                  sizeof(PacketHeader.PacketType));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

            //
            // If read error and it is for a control packet, simply
            // preptend that we have not seen this packet.  Hopefully
            // we will receive the packet we desire which automatically acks
            // the packet we just sent.
            //

            goto WaitForPacketLeader;
        } else {

            //
            // if read error while reading data packet, we have to ask
            // kernel debugger to resend us the packet.
            //

            goto SendResendPacket;
        }
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //

    if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {
        return KDP_PACKET_RESEND;
    }

    //
    // Read data length.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.ByteCount,
                                  sizeof(PacketHeader.ByteCount));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read Packet Id.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketId,
                                  sizeof(PacketHeader.PacketId));

    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read packet checksum.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.Checksum,
                                  sizeof(PacketHeader.Checksum));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // A complete packet header is received.  Check its validity and
    // perform appropriate action depending on packet type.
    //

    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {
        if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (PacketHeader.PacketId !=
                (KdpNextPacketIdToSend & ~SYNC_PACKET_ID))  {
                goto WaitForPacketLeader;
            } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {
                KdpNextPacketIdToSend ^= 1;
                return KDP_PACKET_RECEIVED;
            } else {
                goto WaitForPacketLeader;
            }
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            KdpNextPacketIdToSend = INITIAL_PACKET_ID;
            KdpPacketIdExpected = INITIAL_PACKET_ID;
            KdpSendControlPacket(PACKET_TYPE_KD_RESET, 0L);
            return KDP_PACKET_RESEND;
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {
            return KDP_PACKET_RESEND;
        } else {

            //
            // Invalid packet header, ignore it.
            //

            goto WaitForPacketLeader;
        }

    //
    // The packet header is for data packet (not control packet).
    //

    } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

        //
        // if we are waiting for ACK packet ONLY
        // and we receive a data packet header, check if the packet id
        // is what we expected.  If yes, assume the acknowledge is lost (but
        // sent), ask sender to resend and return with PACKET_RECEIVED.
        //

        if (PacketHeader.PacketId == KdpPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdpNextPacketIdToSend ^= 1;
            return KDP_PACKET_RECEIVED;
        } else {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    //
    // Check ByteCount received is valid
    //

    MessageLength = MessageHeader->MaximumLength;
    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {
        goto SendResendPacket;
    }
    *DataLength = PacketHeader.ByteCount - MessageLength;

    //
    // Read the message header.
    //

    ReturnCode = KdpReceiveString(MessageHeader->Buffer, MessageLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Read the message data.
    //

    ReturnCode = KdpReceiveString(MessageData->Buffer, *DataLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageData->Length = (USHORT)*DataLength;

    //
    // Read packet trailing byte
    //

    ReturnCode = KdPortGetByte(&Input);
    if (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE) {
        goto SendResendPacket;
    }

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType != PacketHeader.PacketType) {
        KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                             PacketHeader.PacketId
                             );
        goto WaitForPacketLeader;
    }

    //
    // Check PacketId is valid.
    //

    if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {
        if (PacketHeader.PacketId != KdpPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    } else {
        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //

    Checksum = KdpComputeChecksum(
                            MessageHeader->Buffer,
                            MessageHeader->Length
                            );

    Checksum += KdpComputeChecksum(
                            MessageData->Buffer,
                            MessageData->Length
                            );
    if (Checksum != PacketHeader.Checksum) {
        goto SendResendPacket;
    }

    //
    // Send Acknowledge byte and the Id of the packet received.
    // Then, update the ExpectId for next incoming packet.
    //

    KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                         PacketHeader.PacketId
                         );

    //
    // We have successfully received the packet so update the
    // packet control variables and return sucess.
    //

    KdpPacketIdExpected ^= 1;
    return KDP_PACKET_RECEIVED;

SendResendPacket:
    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
}

VOID
KdpSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    )

/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;
    ULONG MessageDataLength;
    ULONG ReturnCode;
    PDBGKD_DEBUG_IO DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64 StateChange;

    if ( ARGUMENT_PRESENT(MessageData) ) {
        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = KdpComputeChecksum(
                                        MessageData->Buffer,
                                        MessageData->Length
                                        );
    } else {
        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += KdpComputeChecksum (
                                    MessageHeader->Buffer,
                                    MessageHeader->Length
                                    );

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;
    KdpNumberRetries = KdpRetryCount;
    do {
        if (KdpNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //

            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {
                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;
                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {
                    KdDebuggerNotPresent = TRUE;
                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdpPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {
                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;
                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {
                    KdDebuggerNotPresent = TRUE;
                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdpPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            }
        }

        //
        // Setting PacketId has to be in the do loop in case Packet Id was
        // reset.
        //

        PacketHeader.PacketId = KdpNextPacketIdToSend;
        KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

        //
        // Output message header.
        //

        KdpSendString(MessageHeader->Buffer, MessageHeader->Length);

        //
        // Output message data.
        //

        if ( MessageDataLength ) {
            KdpSendString(MessageData->Buffer, MessageData->Length);
        }

        //
        // Output a packet trailing byte
        //

        KdPortPutByte(PACKET_TRAILING_BYTE);

        //
        // Wait for the Ack Packet
        //

        ReturnCode = KdpReceivePacket(
                         PACKET_TYPE_KD_ACKNOWLEDGE,
                         NULL,
                         NULL,
                         NULL
                         );
        if (ReturnCode == KDP_PACKET_TIMEOUT) {
            KdpNumberRetries--;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);

    //
    // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
    //

    KdpNextPacketIdToSend &= ~SYNC_PACKET_ID;

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //

    KdpRetryCount = MAXIMUM_RETRIES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdapi.c

Abstract:

    Implementation of Kernel Debugger portable remote APIs.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

    John Vert (jvert) 28-May-1991

        Added APIs for reading and writing physical memory
        (KdpReadPhysicalMemory and KdpWritePhysicalMemory)

    Wesley Witt (wesw) 18-Aug-1993

        Added KdpGetVersion, KdpWriteBreakPointEx, & KdpRestoreBreakPointEx


--*/

#include "kdp.h"
#include <ntverp.h>

extern LARGE_INTEGER Magic10000;
#define SHIFT10000   13
#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

//
// Define forward referenced function prototypes.
//

VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    );

VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    );

LOGICAL
KdpSearchPhysicalPageRange (
    VOID
    );


#if i386
VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

ULONG_PTR
KdpGetReturnAddress(
    IN PCONTEXT ContextRecord
    );

ULONG_PTR
KdpGetCallNextOffset (
    ULONG_PTR Pc,
    IN PCONTEXT ContextRecord
    );

LONG
KdpLevelChange (
    ULONG_PTR Pc,
    PCONTEXT ContextRecord,
    IN OUT PBOOLEAN SpecialCall
    );

#endif // i386

#if DBG
VOID
KdpDprintf(
    IN PCHAR f,
    ...
    )
/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    f - Supplies printf format

Return Value:

    None

--*/
{
    char    buf[100];
    STRING  Output;
    va_list mark;

    va_start(mark, f);
    _vsnprintf(buf, 100, f, mark);
    va_end(mark);

    Output.Buffer = buf;
    Output.Length = (USHORT)strlen(Output.Buffer);
    KdpPrintString(&Output);
}
#endif // DBG

BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function is used to enter the kernel debugger. Its purpose
    is to freeze all other processors and aqcuire the kernel debugger
    comm port.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to an exception frame that
        describes the trap.

Return Value:

    Returns the previous interrupt enable.

--*/

{

    BOOLEAN Enable;
    TIME_FIELDS TimeFields;

    //
    // HACKHACK - do some crude timer support
    //            but not if called from KdSetOwedBreakpoints()
    //

    if (TrapFrame) {
        KdTimerStop = KdpQueryPerformanceCounter (TrapFrame);
        KdTimerDifference.QuadPart = KdTimerStop.QuadPart - KdTimerStart.QuadPart;
    } else {
        KdTimerStop.QuadPart = 0;
    }

    //
    // Freeze all other processors, raise IRQL to HIGH_LEVEL, and save debug
    // port state.  We lock the port so that KdPollBreakin and a debugger
    // operation don't interfere with each other.
    //

    Enable = KiDisableInterrupts();

    KdpPortLock();
    KdEnteredDebugger = TRUE;

    return Enable;
}

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function is used to exit the kernel debugger. It is the reverse
    of KdEnterDebugger.

Arguments:

    Enable - Supplies the previous interrupt enable which is to be restored.

Return Value:

    None.

--*/

{
    ULONG ElapsedTime;
    ULARGE_INTEGER TimeDifference;
    TIME_FIELDS TimeFields;
    ULONG Pending;

    //
    // restore stuff and exit
    //

    KdpPortUnlock();

    //
    // Flush the current TB.
    //

    KeFlushCurrentTb();

    //
    // Lower IRQL and restore interrupt enable
    //

    KiRestoreInterrupts(Enable);

    //
    // Do some crude timer support.  If KdEnterDebugger didn't
    // Query the performance counter, then don't do it here either.
    //

    if (KdTimerStop.QuadPart == 0) {
        KdTimerStart = KdTimerStop;
    } else {
        KdTimerStart = KeQueryPerformanceCounter();
    }

    return;
}

#if i386
VOID
InternalBreakpointCheck (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    LARGE_INTEGER dueTime;
    ULONG i;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
    dueTime.HighPart = -1;

    KeSetTimer(
        &InternalBreakpointTimer,
        dueTime,
        &InternalBreakpointCheckDpc
        );

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {

            PDBGKD_INTERNAL_BREAKPOINT b = KdpInternalBPs + i;
            ULONG callsThisPeriod;

            callsThisPeriod = b->Calls - b->CallsLastCheck;
            if ( callsThisPeriod > b->MaxCallsPerPeriod ) {
                b->MaxCallsPerPeriod = callsThisPeriod;
            }
            b->CallsLastCheck = b->Calls;
        }
    }

    return;

} // InternalBreakpointCheck

VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function sets an internal breakpoint.  "Internal breakpoint"
    means one in which control is not returned to the kernel debugger at
    all, but rather just update internal counting routines and resume.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    ULONG savedFlags;

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( KdpInternalBPs[i].Addr ==
                            m->u.SetInternalBreakpoint.BreakpointAddress ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
            if ( KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
                bp = &KdpInternalBPs[i];
                break;
            }
        }
    }

    if ( !bp ) {
        if ( KdpNumInternalBreakpoints >= DBGKD_MAX_INTERNAL_BREAKPOINTS ) {
            return; // no space.  Probably should report error.
        }
        bp = &KdpInternalBPs[KdpNumInternalBreakpoints++];
        bp->Flags |= DBGKD_INTERNAL_BP_FLAG_INVALID; // force initialization
    }

    if ( bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
        if ( m->u.SetInternalBreakpoint.Flags &
                                        DBGKD_INTERNAL_BP_FLAG_INVALID ) {
            return; // tried clearing a non-existant BP.  Ignore the request
        }
        bp->Calls = bp->MaxInstructions = bp->TotalInstructions = 0;
        bp->CallsLastCheck = bp->MaxCallsPerPeriod = 0;
        bp->MinInstructions = 0xffffffff;
        bp->Handle = 0;
        bp->Thread = 0;
    }

    savedFlags = bp->Flags;
    bp->Flags = m->u.SetInternalBreakpoint.Flags; // this could possibly invalidate the BP
    bp->Addr = m->u.SetInternalBreakpoint.BreakpointAddress;

    if ( bp->Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                      DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {

        if ( (bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (bp->Thread != 0) ) {
            // The breakpoint is active; defer its deletion
            bp->Flags &= ~DBGKD_INTERNAL_BP_FLAG_INVALID;
            bp->Flags |= DBGKD_INTERNAL_BP_FLAG_DYING;
        }

        // This is really a CLEAR bp request.

        if ( bp->Handle != 0 ) {
            KdpDeleteBreakpoint( bp->Handle );
        }
        bp->Handle = 0;

        return;
    }

    // now set the real breakpoint and remember its handle.

    if ( savedFlags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                       DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
        // breakpoint was invalid; activate it now
        bp->Handle = KdpAddBreakpoint( (PVOID)bp->Addr );
    }

    if ( BreakpointsSuspended ) {
        KdpSuspendBreakpoint( bp->Handle );
    }

} // KdSetInternalBreakpoint

NTSTATUS
KdGetTraceInformation(
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    in a buffer provided for it.  It is designed to be called from
    NTQuerySystemInformation.  It is morally equivalent to GetInternalBP
    except that it communicates locally, and returns all the breakpoints
    at once.

Arguments:

    SystemInforamtion - the buffer into which to write the result.
    SystemInformationLength - the maximum length to write
    RetrunLength - How much data was really written

Return Value:

    None.

--*/

{
    ULONG numEntries = 0;
    ULONG i = 0;
    PDBGKD_GET_INTERNAL_BREAKPOINT64 outPtr;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            numEntries++;
        }
    }

    *ReturnLength = numEntries * sizeof(DBGKD_GET_INTERNAL_BREAKPOINT64);
    if ( *ReturnLength > SystemInformationLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // We've got enough space.  Copy it in.
    //

    outPtr = (PDBGKD_GET_INTERNAL_BREAKPOINT64)SystemInformation;
    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            outPtr->BreakpointAddress = KdpInternalBPs[i].Addr;
            outPtr->Flags = KdpInternalBPs[i].Flags;
            outPtr->Calls = KdpInternalBPs[i].Calls;
            outPtr->MaxCallsPerPeriod = KdpInternalBPs[i].MaxCallsPerPeriod;
            outPtr->MinInstructions = KdpInternalBPs[i].MinInstructions;
            outPtr->MaxInstructions = KdpInternalBPs[i].MaxInstructions;
            outPtr->TotalInstructions = KdpInternalBPs[i].TotalInstructions;
            outPtr++;
        }
    }

    return STATUS_SUCCESS;

} // KdGetTraceInformation

VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    to the calling debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    STRING messageHeader;

    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                                          DBGKD_INTERNAL_BP_FLAG_SUSPENDED)) &&
             (KdpInternalBPs[i].Addr ==
                        m->u.GetInternalBreakpoint.BreakpointAddress) ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        m->u.GetInternalBreakpoint.Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;
        m->u.GetInternalBreakpoint.Calls = 0;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = 0;
        m->u.GetInternalBreakpoint.MinInstructions = 0;
        m->u.GetInternalBreakpoint.MaxInstructions = 0;
        m->u.GetInternalBreakpoint.TotalInstructions = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->u.GetInternalBreakpoint.Flags = bp->Flags;
        m->u.GetInternalBreakpoint.Calls = bp->Calls;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = bp->MaxCallsPerPeriod;
        m->u.GetInternalBreakpoint.MinInstructions = bp->MinInstructions;
        m->u.GetInternalBreakpoint.MaxInstructions = bp->MaxInstructions;
        m->u.GetInternalBreakpoint.TotalInstructions = bp->TotalInstructions;
        m->ReturnStatus = STATUS_SUCCESS;
    }

    m->ApiNumber = DbgKdGetInternalBreakPointApi;

    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                    &messageHeader,
                    NULL
                    );

    return;

} // KdGetInternalBreakpoint
#endif // i386

KCONTINUE_STATUS
KdpSendWaitContinue (
    IN ULONG OutPacketType,
    IN PSTRING OutMessageHeader,
    IN PSTRING OutMessageData OPTIONAL,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sends a packet, and then waits for a continue message.
    BreakIns received while waiting will always cause a resend of the
    packet originally sent out.  While waiting, manipulate messages
    will be serviced.

    A resend always resends the original event sent to the debugger,
    not the last response to some debugger command.

Arguments:

    OutPacketType - Supplies the type of packet to send.

    OutMessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    OutMessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    ContextRecord - Exception context

Return Value:

    A value of TRUE is returned if the continue message indicates
    success, Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_MANIPULATE_STATE64 ManipulateState;
    ULONG ReturnCode;
    NTSTATUS Status;
    KCONTINUE_STATUS ContinueStatus;

    //
    // Loop servicing state manipulation message until a continue message
    // is received.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)&ManipulateState;
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
    MessageData.Buffer = (PCHAR)KdpMessageBuffer;

ResendPacket:

    //
    // Send event notification packet to debugger on host.  Come back
    // here any time we see a breakin sequence.
    //

    KdpSendPacket(
                  OutPacketType,
                  OutMessageHeader,
                  OutMessageData
                  );

    //
    // After sending packet, if there is no response from debugger
    // AND the packet is for reporting symbol (un)load, the debugger
    // will be declared to be not present.  Note If the packet is for
    // reporting exception, the KdpSendPacket will never stop.
    //

    if (KdDebuggerNotPresent) {
        return ContinueSuccess;
    }

    while (TRUE) {

        //
        // Wait for State Manipulate Packet without timeout.
        //

        do {

            ReturnCode = KdpReceivePacket(
                            PACKET_TYPE_KD_STATE_MANIPULATE,
                            &MessageHeader,
                            &MessageData,
                            &Length
                            );
            if (ReturnCode == (USHORT)KDP_PACKET_RESEND) {
                goto ResendPacket;
            }
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        //
        // Switch on the return message API number.
        //

        switch (ManipulateState.ApiNumber) {

        case DbgKdReadVirtualMemoryApi:
            KdpReadVirtualMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteVirtualMemoryApi:
            KdpWriteVirtualMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdCheckLowMemoryApi:
            KdpCheckLowMemory (&ManipulateState);
            break;

        case DbgKdReadPhysicalMemoryApi:
            KdpReadPhysicalMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdWritePhysicalMemoryApi:
            KdpWritePhysicalMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdGetContextApi:
            KdpGetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSetContextApi:
            KdpSetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteBreakPointApi:
            KdpWriteBreakpoint(&ManipulateState,&MessageData);
            break;

        case DbgKdRestoreBreakPointApi:
            KdpRestoreBreakpoint(&ManipulateState,&MessageData);
            break;

        case DbgKdReadControlSpaceApi:
            KdpReadControlSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteControlSpaceApi:
            KdpWriteControlSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdReadIoSpaceApi:
            KdpReadIoSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteIoSpaceApi:
            KdpWriteIoSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdContinueApi:
            if (NT_SUCCESS(ManipulateState.u.Continue.ContinueStatus) != FALSE) {
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdContinueApi2:
            if (NT_SUCCESS(ManipulateState.u.Continue2.ContinueStatus) != FALSE) {
                KdpGetStateChange(&ManipulateState,ContextRecord);
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdRebootApi:
            HalReturnToFirmware(HalKdRebootRoutine);
            break;

#if i386
        case DbgKdReadMachineSpecificRegister:
            KdpReadMachineSpecificRegister(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteMachineSpecificRegister:
            KdpWriteMachineSpecificRegister(&ManipulateState,&MessageData);
            break;

        case DbgKdSetSpecialCallApi:
            KdSetSpecialCall(&ManipulateState,ContextRecord);
            break;

        case DbgKdClearSpecialCallsApi:
            KdClearSpecialCalls();
            break;

        case DbgKdSetInternalBreakPointApi:
            KdSetInternalBreakpoint(&ManipulateState);
            break;

        case DbgKdGetInternalBreakPointApi:
            KdGetInternalBreakpoint(&ManipulateState);
            break;
#endif

        case DbgKdGetVersionApi:
            KdpGetVersion(&ManipulateState);
            break;

        case DbgKdCauseBugCheckApi:
            KdpCauseBugCheck(&ManipulateState);
            break;

        case DbgKdPageInApi:
            KdpNotSupported(&ManipulateState);
            break;

        case DbgKdWriteBreakPointExApi:
            Status = KdpWriteBreakPointEx(&ManipulateState,&MessageData);
            if (Status) {
                ManipulateState.ApiNumber = DbgKdContinueApi;
                ManipulateState.u.Continue.ContinueStatus = Status;
                return ContinueError;
            }
            break;

        case DbgKdRestoreBreakPointExApi:
            KdpRestoreBreakPointEx(&ManipulateState,&MessageData);
            break;

        case DbgKdSwitchProcessor:
            return ContinueProcessorReselected;

        case DbgKdSearchMemoryApi:
            KdpSearchMemory(&ManipulateState, &MessageData);
            break;

            //
            // Invalid message.
            //

        default:
            MessageData.Length = 0;
            ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
            KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, &MessageData);
            break;
        }
    }
}

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response to a read virtual memory 32-bit
    state manipulation message. Its function is to read virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to read.

Return Value:

    None.

--*/

{
    ULONG Length;
    STRING MessageHeader;

    //
    // Trim the transfer count to fit in a single message.
    //

    Length = m->u.ReadMemory.TransferCount;
    if (Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    }

    //
    // Move the data to the destination buffer.
    //

    AdditionalData->Length = (USHORT)KdpMoveMemory(AdditionalData->Buffer,
                                                   (PVOID)m->u.ReadMemory.TargetBaseAddress,
                                                   Length);

    //
    // If all the data is read, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes read, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.ReadMemory.ActualBytesRead = AdditionalData->Length;

    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData);

    return;
}

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write virtual memory 32-bit
    state manipulation message. Its function is to write virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to write.

Return Value:

    None.

--*/

{

    ULONG Length;
    STRING MessageHeader;
    HARDWARE_PTE Opaque;

    //
    // Move the data to the destination buffer.
    //

    Length = KdpMoveMemory((PVOID)m->u.WriteMemory.TargetBaseAddress,
                           AdditionalData->Buffer,
                           AdditionalData->Length);

    //
    // If all the data is written, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes written, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.WriteMemory.ActualBytesWritten = Length;
    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL);

    return;
}

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a get context state
    manipulation message.  Its function is to return the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_CONTEXT a = &m->u.GetContext;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (m->Processor >= (USHORT)1) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        AdditionalData->Length = sizeof(*Context);
        KdpQuickMoveMemory(AdditionalData->Buffer, (PCHAR)Context, sizeof(*Context));
    }

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );
}

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a set context state
    manipulation message.  Its function is set the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_SET_CONTEXT a = &m->u.SetContext;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == sizeof(*Context));

    if (m->Processor >= (USHORT)1) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        KdpQuickMoveMemory((PCHAR)Context, AdditionalData->Buffer, sizeof(*Context));
    }

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state
    manipulation message.  Its function is to write a breakpoint
    and return a handle to the breakpoint.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_BREAKPOINT64 a = &m->u.WriteBreakPoint;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    a->BreakPointHandle = KdpAddBreakpoint((PVOID)a->BreakPointAddress);
    if (a->BreakPointHandle != 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state
    manipulation message.  Its function is to restore a breakpoint
    using the specified handle.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_RESTORE_BREAKPOINT a = &m->u.RestoreBreakPoint;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);
    if (KdpDeleteBreakpoint(a->BreakPointHandle)) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

#if i386
long
SymNumFor(
    ULONG pc
    )
{
    ULONG index;

    for (index = 0; index < NumTraceDataSyms; index++) {
        if ((TraceDataSyms[index].SymMin <= pc) &&
            (TraceDataSyms[index].SymMax > pc)) return(index);
    }
    return(-1);
}

void PotentialNewSymbol (ULONG pc)
{
    if (!TraceDataBufferFilled &&
        -1 != SymNumFor(pc)) {     // we've already seen this one
        return;
    }

    TraceDataBufferFilled = FALSE;

    // OK, we've got to start up a TraceDataRecord
    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange = 0;

    if (-1 != SymNumFor(pc)) {
        int sym = SymNumFor(pc);
        TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) sym;
        KdpCurrentSymbolStart = TraceDataSyms[sym].SymMin;
        KdpCurrentSymbolEnd = TraceDataSyms[sym].SymMax;

        return;  // we've already seen this one
    }

    TraceDataSyms[NextTraceDataSym].SymMin = KdpCurrentSymbolStart;
    TraceDataSyms[NextTraceDataSym].SymMax = KdpCurrentSymbolEnd;

    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = NextTraceDataSym;

    // Bump the "next" pointer, wrapping if necessary.  Also bump the
    // "valid" pointer if we need to.
    NextTraceDataSym = (NextTraceDataSym + 1) % 256;
    if (NumTraceDataSyms < NextTraceDataSym) {
        NumTraceDataSyms = NextTraceDataSym;
    }

}

void DumpTraceData(PSTRING MessageData)
{

 TraceDataBuffer[0].LongNumber = TraceDataBufferPosition;
 MessageData->Length = (USHORT)(sizeof(TraceDataBuffer[0]) * TraceDataBufferPosition);
 MessageData->Buffer = (PVOID)TraceDataBuffer;
 TraceDataBufferPosition = 1;
}

BOOLEAN
TraceDataRecordCallInfo(
    ULONG InstructionsTraced,
    LONG CallLevelChange,
    ULONG pc
    )
{
    // We've just exited a symbol scope.  The InstructionsTraced number goes
    // with the old scope, the CallLevelChange goes with the new, and the
    // pc fills in the symbol for the new TraceData record.

    long SymNum = SymNumFor(pc);

    if (KdpNextCallLevelChange != 0) {
        TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =
                                                (char) KdpNextCallLevelChange;
        KdpNextCallLevelChange = 0;
    }


    if (InstructionsTraced >= TRACE_DATA_INSTRUCTIONS_BIG) {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           TRACE_DATA_INSTRUCTIONS_BIG;
       TraceDataBuffer[TraceDataBufferPosition+1].LongNumber =
           InstructionsTraced;
       TraceDataBufferPosition += 2;
    } else {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           (unsigned short)InstructionsTraced;
       TraceDataBufferPosition++;
    }

    if ((TraceDataBufferPosition + 2 >= TRACE_DATA_BUFFER_MAX_SIZE) ||
        (-1 == SymNum)) {
        if (TraceDataBufferPosition +2 >= TRACE_DATA_BUFFER_MAX_SIZE) {
            TraceDataBufferFilled = TRUE;
        }
       KdpNextCallLevelChange = CallLevelChange;
       return FALSE;
    }

    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =(char)CallLevelChange;
    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) SymNum;
    KdpCurrentSymbolStart = TraceDataSyms[SymNum].SymMin;
    KdpCurrentSymbolEnd = TraceDataSyms[SymNum].SymMax;

    return TRUE;
}

BOOLEAN
SkippingWhichBP (
    PVOID thread,
    PULONG BPNum
    )

/*
 * Return TRUE iff the pc corresponds to an internal breakpoint
 * that has just been replaced for execution.  If TRUE, then return
 * the breakpoint number in BPNum.
 */

{
    ULONG index;

    if (!IntBPsSkipping) return FALSE;

    for (index = 0; index < KdpNumInternalBreakpoints; index++) {
        if (!(KdpInternalBPs[index].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
            (KdpInternalBPs[index].Thread == thread)) {
            *BPNum = index;
            return TRUE;
        }
    }
    return FALSE; // didn't match any
}

NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    ULONG Length,
    PULONG RequiredLength
    )
{
    *RequiredLength = sizeof(DBGKD_MANIPULATE_STATE64) +
                        (sizeof(ULONG) * KdNumberOfSpecialCalls);

    if ( Length < *RequiredLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    m->u.QuerySpecialCalls.NumberOfSpecialCalls = KdNumberOfSpecialCalls;
        RtlCopyMemory(
        m + 1,
        KdSpecialCalls,
        sizeof(ULONG) * KdNumberOfSpecialCalls
        );

    return STATUS_SUCCESS;

} // KdQuerySpecialCalls

VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sets the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    if ( KdNumberOfSpecialCalls >= DBGKD_MAX_SPECIAL_CALLS ) {
        return; // too bad
    }

    KdSpecialCalls[KdNumberOfSpecialCalls++] = (ULONG_PTR)m->u.SetSpecialCall.SpecialCall;

    NextTraceDataSym = 0;
    NumTraceDataSyms = 0;
    KdpNextCallLevelChange = 0;
    if (ContextRecord && !InstrCountInternal) {
        InitialSP = ContextRecord->Esp;
    }

} // KdSetSpecialCall

VOID
KdClearSpecialCalls (
    VOID
    )

/*++

Routine Description:

    This function clears the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KdNumberOfSpecialCalls = 0;
    return;

} // KdClearSpecialCalls

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )
{
    ULONG pc = (ULONG)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    LONG BpNum;
    ULONG SkippedBPNum;
    BOOLEAN AfterSC = FALSE;

    if (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) {
        if (WatchStepOverSuspended) {
            //
            //  For background, see the comment below where WSOThread is
            //  wrong.  We've now stepped over the breakpoint in the non-traced
            //  thread, and need to replace it and restart the non-traced
            //  thread at full speed.
            //

            WatchStepOverHandle = KdpAddBreakpoint((PVOID)WatchStepOverBreakAddr);
            WatchStepOverSuspended = FALSE;
            ContextRecord->EFlags &= ~0x100L; /* clear trace flag */
            return TRUE; // resume non-traced thread at full speed
        }

        if ((!SymbolRecorded) && (KdpCurrentSymbolStart != 0) && (KdpCurrentSymbolEnd != 0)) {
            //
            //  We need to use oldpc here, because this may have been
            //  a 1 instruction call.  We've ALREADY executed the instruction
            //  that the new symbol is for, and if the pc has moved out of
            //  range, we might screw up.  Hence, use the pc from when
            //  SymbolRecorded was set.  Yuck.
            //

            PotentialNewSymbol(oldpc);
            SymbolRecorded = TRUE;
        }

        if (!InstrCountInternal &&
            SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum)) {

            //
            //  We just single-stepped over a temporarily removed internal
            //  breakpoint.
            //  If it's a COUNTONLY breakpoint:
            //      Put the breakpoint instruction back and resume
            //      regular execution.
            //

            if (KdpInternalBPs[SkippedBPNum].Flags &
                DBGKD_INTERNAL_BP_FLAG_COUNTONLY) {

                IntBPsSkipping --;

                KdpRestoreAllBreakpoints();

                ContextRecord->EFlags &= ~0x100L;  // Clear trace flag
                KdpInternalBPs[SkippedBPNum].Thread = 0;

                if (KdpInternalBPs[SkippedBPNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_DYING) {
                    KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                    KdpInternalBPs[SkippedBPNum].Flags |=
                            DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
                }

                return TRUE;
            }

            //
            //  If it's not:
            //      set up like it's a ww, by setting Begin and KdpCurrentSymbolEnd
            //      and bop off into single step land.  We probably ought to
            //      disable all breakpoints here, too, so that we don't do
            //      anything foul like trying two non-COUNTONLY's at the
            //      same time or something...
            //

            KdpCurrentSymbolEnd = 0;
            KdpCurrentSymbolStart = (ULONG_PTR) KdpInternalBPs[SkippedBPNum].ReturnAddress;

            ContextRecord->EFlags |= 0x100L; /* Trace on. */
            InitialSP = ContextRecord->Esp;

            InstructionsTraced = 1;  /* Count the initial call instruction. */
            InstrCountInternal = TRUE;
        }

    } /* if single step */
    else if (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) {
        if (WatchStepOver && pc == WatchStepOverBreakAddr) {
            //
            //  This is a breakpoint after completion of a "special call"
            //

            if ((WSOThread != (PVOID)KeGetCurrentThread()) ||
                (WSOEsp + 0x20 < ContextRecord->Esp) ||
                (ContextRecord->Esp + 0x20 < WSOEsp)) {
                //
                //  Here's the story up to this point: the traced thread
                //  cruised along until it it a special call.  The tracer
                //  placed a breakpoint on the instruction immediately after
                //  the special call returns and restarted the traced thread
                //  at full speed.  Then, some *other* thread hit the
                //  breakpoint.  So, to correct for this, we're going to
                //  remove the breakpoint, single step the non-traced
                //  thread one instruction, replace the breakpoint,
                //  restart the non-traced thread at full speed, and wait
                //  for the traced thread to get to this breakpoint, just
                //  like we were when this happened.  The assumption
                //  here is that the traced thread won't hit the breakpoint
                //  while it's removed, which I believe to be true, because
                //  I don't think a context switch can occur during a single
                //  step operation.
                //
                //  For extra added fun, it's possible to execute interrupt
                //  routines IN THE SAME THREAD!!!  That's why we need to keep
                //  the stack pointer as well as the thread address: the APC
                //  code can result in pushing on the stack and doing a call
                //  that's really part on an interrupt service routine in the
                //  context of the current thread.  Lovely, isn't it?
                //

                WatchStepOverSuspended = TRUE;
                KdpDeleteBreakpoint(WatchStepOverHandle);
                ContextRecord->EFlags |= 0x100L; // Set trace flag
                return TRUE; // single step "non-traced" thread
            }

            //
            //  we're in the thread we started in; resume in single-step mode
            //  to continue the trace.
            //

            WatchStepOver = FALSE;
            KdpDeleteBreakpoint(WatchStepOverHandle);
            ContextRecord->EFlags |= 0x100L; // back to single step mode
            AfterSC = TRUE; // put us into the regular watchStep code

        } else {

            for ( BpNum = 0; BpNum < (LONG) KdpNumInternalBreakpoints; BpNum++ ) {
                if ( !(KdpInternalBPs[BpNum].Flags &
                       (DBGKD_INTERNAL_BP_FLAG_INVALID |
                        DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) &&
                     (KdpInternalBPs[BpNum].Addr == pc) ) {
                    break;
                }
            }

            if ( BpNum < (LONG) KdpNumInternalBreakpoints ) {

                //
                //  This is an internal monitoring breakpoint.
                //  Restore the instruction and start in single-step
                //  mode so that we can retore the breakpoint once the
                //  instruction executes, or continue stepping if this isn't
                //  a COUNTONLY breakpoint.
                //

                KdpProcessInternalBreakpoint( BpNum );
                KdpInternalBPs[BpNum].Thread = (PVOID)KeGetCurrentThread();
                IntBPsSkipping ++;

                KdpSuspendAllBreakpoints();

                ContextRecord->EFlags |= 0x100L;  // Set trace flag
                if (!(KdpInternalBPs[BpNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_COUNTONLY)) {
                    KdpInternalBPs[BpNum].ReturnAddress =
                                    KdpGetReturnAddress( ContextRecord );
                }
                return TRUE;
            }
        }
    } /* if breakpoint */

//  if (AfterSC) {
//      DPRINT(( "1: KdpCurrentSymbolStart %x  KdpCurrentSymbolEnd %x\n", KdpCurrentSymbolStart, KdpCurrentSymbolEnd ));
//  }

    if ((AfterSC || ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) &&
        KdpCurrentSymbolStart != 0 &&
        ((KdpCurrentSymbolEnd == 0 && ContextRecord->Esp <= InitialSP) ||
         (KdpCurrentSymbolStart <= pc && pc < KdpCurrentSymbolEnd))) {
        ULONG lc;
        BOOLEAN IsSpecialCall;

        //
        //  We've taken a step trace, but are still executing in the current
        //  function.  Remember that we executed an instruction and see if the
        //  instruction changes the call level.
        //

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced++;
        CallLevelChange += lc;

        //
        //  See if instruction is a transfer to a special routine, one that we
        //  cannot trace through since it may swap contexts
        //

        if (IsSpecialCall) {

//  DPRINT( ("2: pc=%x, level change %d\n", pc, lc) );

            //
            //  We are about to transfer to a special call routine.  Since we
            //  cannot trace through this routine, we execute it atomically by
            //  setting a breakpoint at the next logical offset.
            //
            //  Note in the case of an indirect jump to a special call routine, the
            //  level change will be -1 and the next offset will be the ULONG that's
            //  on the top of the stack.
            //
            //  However, we've already adjusted the level based on this
            //  instruction.  We need to undo this except for the magic -1 call.
            //

            if (lc != -1) {
                CallLevelChange -= lc;
            }

            //
            //  Set up for stepping over a procedure
            //

            WatchStepOver = TRUE;
            WatchStepOverBreakAddr = KdpGetCallNextOffset( pc, ContextRecord );
            WSOThread = (PVOID)KeGetCurrentThread( );
            WSOEsp = ContextRecord->Esp;

            //
            //  Establish the breakpoint
            //

            WatchStepOverHandle = KdpAddBreakpoint( (PVOID)WatchStepOverBreakAddr );


            //
            //  Note that we are continuing rather than tracing and rely on hitting
            //  the breakpoint in the current thread context to resume the watch
            //  action.
            //

            ContextRecord->EFlags &= ~0x100L;
            return TRUE;
        }

        //
        //  Resume execution with the trace flag set.  Avoid going over the wire to
        //  the remote debugger.
        //

        ContextRecord->EFlags |= 0x100L;  // Set trace flag

        return TRUE;
    }

    if ((AfterSC || (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)) &&
        (KdpCurrentSymbolStart != 0)) {
        //
        // We're WatchTracing, but have just changed symbol range.
        // Fill in the call record and return to the debugger if
        // either we're full or the pc is outside of the known
        // symbol scopes.  Otherwise, resume stepping.
        //
        int lc;
        BOOLEAN IsSpecialCall;

        InstructionsTraced++; // don't forget to count the call/ret instruction.

//  if (AfterSC) {
//      DPRINT(( "3: InstrCountInternal: %x\n", InstrCountInternal ));
//  }

        if (InstrCountInternal) {

            // We've just finished processing a non-COUNTONLY breakpoint.
            // Record the appropriate data and resume full speed execution.

            SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum);

            KdpInternalBPs[SkippedBPNum].Calls++;


            if (KdpInternalBPs[SkippedBPNum].MinInstructions > InstructionsTraced) {
                KdpInternalBPs[SkippedBPNum].MinInstructions = InstructionsTraced;
            }
            if (KdpInternalBPs[SkippedBPNum].MaxInstructions < InstructionsTraced) {
                KdpInternalBPs[SkippedBPNum].MaxInstructions = InstructionsTraced;
            }
            KdpInternalBPs[SkippedBPNum].TotalInstructions += InstructionsTraced;

            KdpInternalBPs[SkippedBPNum].Thread = 0;

            IntBPsSkipping--;
            InstrCountInternal = FALSE;
            KdpCurrentSymbolStart = 0;
            KdpRestoreAllBreakpoints();

            if (KdpInternalBPs[SkippedBPNum].Flags &
                    DBGKD_INTERNAL_BP_FLAG_DYING) {
                KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                KdpInternalBPs[SkippedBPNum].Flags |=
                        DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
            }

            ContextRecord->EFlags &= ~0x100L; // clear trace flag
            return TRUE; // Back to normal execution.
        }

        if (TraceDataRecordCallInfo( InstructionsTraced, CallLevelChange, pc)) {

            //
            //  Everything was cool internally.  We can keep executing without
            //  going back to the remote debugger.
            //
            //  We have to compute lc after calling
            //  TraceDataRecordCallInfo, because LevelChange relies on
            //  KdpCurrentSymbolStart and KdpCurrentSymbolEnd corresponding to
            //  the pc.
            //

            lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
            InstructionsTraced = 0;
            CallLevelChange = lc;

            //
            //  See if instruction is a transfer to a special routine, one that we
            //  cannot trace through since it may swap contexts
            //

            if (IsSpecialCall) {

//  DPRINT(( "4: pc=%x, level change %d\n", pc, lc));

                //
                //  We are about to transfer to a special call routine.  Since we
                //  cannot trace through this routine, we execute it atomically by
                //  setting a breakpoint at the next logical offset.
                //
                //  Note in the case of an indirect jump to a special call routine, the
                //  level change will be -1 and the next offset will be the ULONG that's
                //  on the top of the stack.
                //
                //  However, we've already adjusted the level based on this
                //  instruction.  We need to undo this except for the magic -1 call.
                //

                if (lc != -1) {
                    CallLevelChange -= lc;
                }

                //
                //  Set up for stepping over a procedure
                //

                WatchStepOver = TRUE;
                WSOThread = (PVOID)KeGetCurrentThread();

                //
                //  Establish the breakpoint
                //

                WatchStepOverHandle =
                    KdpAddBreakpoint( (PVOID)KdpGetCallNextOffset( pc, ContextRecord ));

                //
                //  Resume execution with the trace flag set.  Avoid going over the wire to
                //  the remote debugger.
                //

                ContextRecord->EFlags &= ~0x100L;
                return TRUE;
            }

            ContextRecord->EFlags |= 0x100L; // Set trace flag
            return TRUE; // Off we go
        }

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced = 0;
        CallLevelChange = lc;

        // We need to go back to the remote debugger.  Just fall through.

        if ((lc != 0) && IsSpecialCall) {
            // We're hosed
            DPRINT(( "Special call on first entry to symbol scope @ %x\n", pc ));
        }
    }

    SymbolRecorded = FALSE;
    oldpc = pc;

    return FALSE;
}
#endif // i386

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine sends an exception state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{
    STRING MessageData;
    STRING MessageHeader;
    X86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetStateChange(&WaitStateChange,
                            ExceptionRecord,
                            ContextRecord,
                            SecondChance
                            );

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

#if i386
        //
        // Construct the wait state change data and data descriptor.
        //

        DumpTraceData(&MessageData);
#else
        MessageData.Length = 0;
#endif

        //
        // Send packet to the kernel debugger on the host machine,
        // wait for answer.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    &MessageData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected) ;

    return (BOOLEAN) Status;
}

BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a load symbols state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    PathName - Supplies a pointer to the pathname of the image whose
        symbols are to be loaded.

    BaseOfDll - Supplies the base address where the image was loaded.

    ProcessId - Unique 32-bit identifier for process that is using
        the symbols.  -1 for system process.

    CheckSum - Unique 32-bit identifier from image header.

    UnloadSymbol - TRUE if the symbols that were previously loaded for
        the named image are to be unloaded from the debugger.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    PSTRING AdditionalData;
    STRING MessageData;
    STRING MessageHeader;
    X86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        WaitStateChange.NewState = DbgKdLoadSymbolsStateChange;
        WaitStateChange.ProcessorLevel = 6;
        WaitStateChange.Processor = (USHORT)0;
        WaitStateChange.NumberProcessors = (ULONG)1;
        WaitStateChange.Thread = (ULONG64)(LONG64)(LONG_PTR) KeGetCurrentThread();
        WaitStateChange.ProgramCounter = (ULONG64)(LONG64)(LONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
        KdpSetLoadState(&WaitStateChange, ContextRecord);
        WaitStateChange.u.LoadSymbols.UnloadSymbols = UnloadSymbols;
        WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo->BaseOfDll;
        WaitStateChange.u.LoadSymbols.ProcessId = (ULONG) SymbolInfo->ProcessId;
        WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo->CheckSum;
        WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo->SizeOfImage;
        if (ARGUMENT_PRESENT( PathName )) {
            WaitStateChange.u.LoadSymbols.PathNameLength =
                KdpMoveMemory(
                    (PCHAR)KdpPathBuffer,
                    (PCHAR)PathName->Buffer,
                    PathName->Length
                    ) + 1;

            MessageData.Buffer = KdpPathBuffer;
            MessageData.Length = (USHORT)WaitStateChange.u.LoadSymbols.PathNameLength;
            MessageData.Buffer[MessageData.Length-1] = '\0';
            AdditionalData = &MessageData;
        } else {
            WaitStateChange.u.LoadSymbols.PathNameLength = 0;
            AdditionalData = NULL;
        }

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    AdditionalData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected);

    return (BOOLEAN) Status;
}

VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response to a read physical memory
    state manipulation message. Its function is to read physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID64 VirtualAddress;
    PHYSICAL_ADDRESS Source;
    UCHAR UNALIGNED *Destination;
    ULONG NumberBytes;
    ULONG BytesLeft;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // make sure that nothing but a read memory message was transmitted
    //

    ASSERT(AdditionalData->Length == 0);

    //
    // Trim transfer count to fit in a single message
    //

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }

    //
    // Since the MmDbgTranslatePhysicalAddress64 only maps in one physical
    // page at a time (on non-alpha systems),
    // we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  It is important that we
    // access physical memory on naturally-aligned boundaries and with the
    // largest size possible.  (We could be accessing memory-mapped I/O
    // space).  These rules allow kdexts to read physical memory reliably.
    //

    Source.QuadPart = a->TargetBaseAddress;
    Destination = AdditionalData->Buffer;
    while (Length > 0) {
        VirtualAddress = MmDbgTranslatePhysicalAddress64(Source);
        if (VirtualAddress == NULL64) {
            break;
        }
        NumberBytes = PAGE_SIZE - BYTE_OFFSET(Source.LowPart);
        if (NumberBytes > Length) {
            NumberBytes = Length;
        }

        KdpMoveMemory(Destination, VirtualAddress, NumberBytes);
        Destination += NumberBytes;

        Source.QuadPart += NumberBytes;
        Length -= NumberBytes;
        AdditionalData->Length += (USHORT)NumberBytes;
    }

    if (Length == 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    a->ActualBytesRead = AdditionalData->Length;

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );
}

VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response to a write physical memory
    state manipulation message. Its function is to write physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    STRING MessageHeader;
    ULONG Length;
    PVOID64 VirtualAddress;
    PHYSICAL_ADDRESS Destination;
    UCHAR UNALIGNED *Source;
    ULONG NumberBytes;
    ULONG BytesLeft;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;


    Length = a->TransferCount;

    //
    // The following code depends on the existence of the
    // MmDbgTranslatePhysicalAddress64() routine.  This has only been
    // implemented for Alpha.
    //

    //
    // Since the MmDbgTranslatePhysicalAddress64 only maps in one physical
    // page at a time, we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  It is important that we
    // access physical memory on naturally-aligned boundaries and with the
    // largest size possible.  (We could be accessing memory-mapped I/O
    // space).  These rules allow kdexts to write physical memory reliably.
    //

    Source = AdditionalData->Buffer;
    Destination.QuadPart = a->TargetBaseAddress;
    while (Length > 0) {
        VirtualAddress = MmDbgTranslatePhysicalAddress64(Destination);
        if (VirtualAddress == NULL64) {
            break;
        }
        NumberBytes = PAGE_SIZE - BYTE_OFFSET(Destination.LowPart);
        if (NumberBytes > Length) {
            NumberBytes = Length;
        }

        KdpMoveMemory(VirtualAddress, Source, NumberBytes);
        Source += NumberBytes;

        Destination.QuadPart += NumberBytes;
        Length -= NumberBytes;
        a->ActualBytesWritten += NumberBytes;
    }

    if (Length == 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

#if i386
VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    )
{
    static BOOLEAN timerStarted = FALSE;
    LARGE_INTEGER dueTime;

    if ( !(KdpInternalBPs[BreakpointNumber].Flags &
           DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
        return;     // We only deal with COUNTONLY breakpoints
    }

    //
    // We've hit a real internal breakpoint; make sure the timeout is
    // kicked off.
    //

    if ( !timerStarted ) { // ok, maybe there's a prettier way to do this.
        dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
        dueTime.HighPart = -1;
        KeInitializeDpc(
            &InternalBreakpointCheckDpc,
            &InternalBreakpointCheck,
            NULL
            );
        KeInitializeTimer( &InternalBreakpointTimer );
        KeSetTimer(
            &InternalBreakpointTimer,
            dueTime,
            &InternalBreakpointCheckDpc
            );
        timerStarted = TRUE;
    }

    KdpInternalBPs[BreakpointNumber].Calls++;

} // KdpProcessInternalBreakpoint
#endif

VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    STRING                   messageHeader;


    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    RtlZeroMemory(&m->u.GetVersion64, sizeof(m->u.GetVersion64));
    //
    // the current build number (0x0100 in the major version marks us as xbox)
    //
    m->u.GetVersion64.MinorVersion = VER_PRODUCTBUILD;
#if DBG
    m->u.GetVersion64.MajorVersion = (0x000C | 0x0100);
#else  // DBG
    m->u.GetVersion64.MajorVersion = (0x000F | 0x0100);
#endif // DBG

    //
    // kd protocol version number.  this should be incremented if the
    // protocol changes.
    //
    m->u.GetVersion64.ProtocolVersion = 5;
    m->u.GetVersion64.Flags = DBGKD_VERS_FLAG_DATA;

#if !defined(NT_UP)
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_MP;
#endif

#if defined(_M_IX86)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_MRX000)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_R4000;
#elif defined(_M_ALPHA)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_ALPHA;
#if defined(_AXP64_)
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;
#endif
#elif defined(_M_PPC)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_POWERPC;
#elif defined(_M_IA64)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_IA64;
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;
#else
#error( "unknown target machine" );
#endif

    //
    // address of the loader table
    //
    m->u.GetVersion64.PsLoadedModuleList = (ULONG64)(LONG64)(LONG_PTR)&KdLoadedModuleList;

    m->u.GetVersion64.KernBase = (ULONG64)(LONG64)(LONG_PTR)PsNtosImageBase;

    m->u.GetVersion64.DebuggerDataList = (ULONG64)(LONG64)(LONG_PTR)&KdpDebuggerDataListHead;

    //
    // the usual stuff
    //
    m->ReturnStatus = STATUS_SUCCESS;
    m->ApiNumber = DbgKdGetVersionApi;

    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &messageHeader,
                  NULL
                 );

    return;
} // KdGetVersion

NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine returns STATUS_UNSUCCESSFUL to the debugger

Arguments:

    m - Supplies a DBGKD_MANIPULATE_STATE64 struct to answer with

Return Value:

    0, to indicate that the system should not continue

--*/

{
    STRING          MessageHeader;

    //
    // setup packet
    //
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    m->ReturnStatus = STATUS_UNSUCCESSFUL;

    //
    // send back our response
    //
    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return 0;
} // KdpNotSupported

VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine causes a bugcheck.  It is used for testing the debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{

    KeBugCheckEx( MANUALLY_INITIATED_CRASH, 0, 0, 0, 0 );

} // KdCauseBugCheck

NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state 'ex'
    manipulation message.  Its function is to clear breakpoints, write
    new breakpoints, and continue the target system.  The clearing of
    breakpoints is conditional based on the presence of breakpoint handles.
    The setting of breakpoints is conditional based on the presence of
    valid, non-zero, addresses.  The continueing of the target system
    is conditional based on a non-zero continuestatus.

    This api allows a debugger to clear breakpoints, add new breakpoint,
    and continue the target system all in one api packet.  This reduces the
    amount of traffic across the wire and greatly improves source stepping.


Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX       a = &m->u.BreakPointEx;
    PDBGKD_WRITE_BREAKPOINT64 b;
    STRING                    MessageHeader;
    ULONG                     i;
    DBGKD_WRITE_BREAKPOINT64  BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
                         a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdpSendPacket(
                      PACKET_TYPE_KD_STATE_MANIPULATE,
                      &MessageHeader,
                      AdditionalData
                      );
        return m->ReturnStatus;
    }

    KdpMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    //
    // assume success
    //
    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointHandle) {
            if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
            b->BreakPointHandle = 0;
        }
    }

    //
    // loop thru the breakpoint addesses passed in from the debugger and
    // add any new breakpoints that have a non-zero address
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointAddress) {
            b->BreakPointHandle = KdpAddBreakpoint( (PVOID)b->BreakPointAddress );
            if (!b->BreakPointHandle) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // send back our response
    //

    KdpMoveMemory(AdditionalData->Buffer,
                  (PUCHAR)BpBuf,
                  a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return a->ContinueStatus;
}

VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state 'ex'
    manipulation message.  Its function is to clear a list of breakpoints.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX         a = &m->u.BreakPointEx;
    PDBGKD_RESTORE_BREAKPOINT   b;
    STRING                      MessageHeader;
    ULONG                       i;
    DBGKD_RESTORE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
                       a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdpSendPacket(
                      PACKET_TYPE_KD_STATE_MANIPULATE,
                      &MessageHeader,
                      AdditionalData
                      );
        return;
    }

    KdpMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT));

    //
    // assume success
    //
    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }

    //
    // send back our response
    //
    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );
}

VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function implements a memory pattern searcher.  This will
    find an instance of a pattern that begins in the range
    SearchAddress..SearchAddress+SearchLength.  The pattern may
    end outside of the range.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies the pattern to search for

Return Value:

    None.

--*/

{
    PUCHAR Pattern = AdditionalData->Buffer;
    ULONG_PTR StartAddress = (ULONG_PTR)m->u.SearchMemory.SearchAddress;
    ULONG_PTR EndAddress = (ULONG_PTR)(StartAddress + m->u.SearchMemory.SearchLength);
    ULONG PatternLength = m->u.SearchMemory.PatternLength;

    STRING MessageHeader;
    ULONG MaskIndex;
    PUCHAR PatternTail;
    PUCHAR DataTail;
    ULONG TailLength;
    ULONG Data;
    ULONG FirstWordPattern[4];
    ULONG FirstWordMask[4];


    //
    // On failure, return STATUS_NO_MORE_ENTRIES.  DON'T RETURN
    // STATUS_UNSUCCESSFUL!  That return status indicates that the
    // operation is not supported, and the debugger will fall back
    // to a debugger-side search.
    //

    m->ReturnStatus = STATUS_NO_MORE_ENTRIES;

    //
    // Do a fast search for the beginning of the pattern
    //

    if (PatternLength > 3) {
        FirstWordMask[0] = 0xffffffff;
    } else {
        FirstWordMask[0] = 0xffffffff >> (8*(4-PatternLength));
    }

    FirstWordMask[1] = FirstWordMask[0] << 8;
    FirstWordMask[2] = FirstWordMask[1] << 8;
    FirstWordMask[3] = FirstWordMask[2] << 8;

    FirstWordPattern[0] = 0;
    KdpQuickMoveMemory((PVOID)FirstWordPattern,
                       Pattern,
                       PatternLength < 5 ? PatternLength : 4);

    FirstWordPattern[1] = FirstWordPattern[0] << 8;
    FirstWordPattern[2] = FirstWordPattern[1] << 8;
    FirstWordPattern[3] = FirstWordPattern[2] << 8;


/*
{
    int i;
    for (i = 0; i < (int)PatternLength; i++) {
        KdpDprintf("%08x: %02x\n", &Pattern[i], Pattern[i]);
    }
    for (i = 0; i < 4; i++) {
        KdpDprintf("%d: %08x %08x\n", i, FirstWordPattern[i], FirstWordMask[i]);
    }
}
*/



    //
    // Get starting mask
    //

    MaskIndex = (ULONG) (StartAddress & 3);
    StartAddress = StartAddress & ~3;

    //
    // check that the starting page is available
    //

    if (MmDbgReadCheck((PVOID)StartAddress) == NULL) {
        StartAddress = (StartAddress + PAGE_SIZE) & ~(PAGE_SIZE-1);
        MaskIndex = 0;
    }

    while (StartAddress < EndAddress) {

        //
        // check when starting a new page
        //
        if ((StartAddress & (PAGE_SIZE-1)) == 0) {
            if (MmDbgReadCheck((PVOID)StartAddress) == NULL) {
                StartAddress = StartAddress + PAGE_SIZE;
                continue;
            }
        }

        //
        // search for a match in each of the 4 starting positions
        //

        Data = *(ULONG*)StartAddress;
//KdpDprintf("\n%08x: %08x ", StartAddress, Data);

        for ( ; MaskIndex < 4; MaskIndex++) {
//KdpDprintf(" %d", MaskIndex);

            if ( (Data & FirstWordMask[MaskIndex]) == FirstWordPattern[MaskIndex]) {

                //
                // first word matched
                //

                if ( (4-MaskIndex) >= PatternLength ) {

                    //
                    // string is all in this word; good match
                    //
//KdpDprintf(" %d hit, complete\n", MaskIndex);

                    m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                    m->ReturnStatus = STATUS_SUCCESS;
                    goto done;

                } else {

                    //
                    // string is longer; see if tail matches
                    //
//KdpDprintf(" %d hit, check tail\n", MaskIndex);

                    PatternTail = Pattern + 4 - MaskIndex;
                    DataTail = (PUCHAR)StartAddress + 4;
                    TailLength = PatternLength - 4 + MaskIndex;

//KdpDprintf("Pattern == %08x\n", Pattern);
//KdpDprintf("PatternTail == %08x\n", PatternTail);
//KdpDprintf("DataTail == %08x\n", DataTail);

                    while (TailLength) {
                        if ( ((ULONG_PTR)DataTail & (PAGE_SIZE-1)) == 0 &&
                             MmDbgReadCheck(DataTail) == FALSE) {
//KdpDprintf("Tail failed: page not present at %08x\n", DataTail);
                            break;
                        } else
{
//KdpDprintf("D: %02x  P: %02x\n", *DataTail, *PatternTail);

                        if (*DataTail != *PatternTail) {
//KdpDprintf("Tail failed at %08x\n", DataTail);
                            break;
                        } else {
                            DataTail++;
                            PatternTail++;
                            TailLength--;
                        }
}
                    }

                    if (TailLength == 0) {

                        //
                        // A winner
                        //

                        m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                        m->ReturnStatus = STATUS_SUCCESS;
                        goto done;

                    }
                }
            }
        }

        StartAddress += 4;
        MaskIndex = 0;
    }

done:
//KdpDprintf("\n");
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );

}


VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 Message
    )

/*++

Routine Description:


Arguments:

    Message - Supplies the state manipulation message.

Return Value:

    None.

Description:

    This function gets called when the !chklowmem
    debugger extension is used.

--*/

{
//+silviuc: move to a header
#if defined (_X86PAE_)
    LOGICAL
        MiCheckPhysicalPagePattern (
        PFN_NUMBER Page,
        PULONG CorruptionOffset
        );

    extern PFN_NUMBER MmLowestPhysicalPage;
    extern PFN_NUMBER MmHighestPhysicalPage;
    extern LOGICAL MiNoLowMemory;
#endif // #if defined (_X86PAE_)
//-silviuc

    STRING MessageHeader;
    PFN_NUMBER Page;
    PHYSICAL_ADDRESS P;
    PVOID64 VirtualAddress;
    ULONG CorruptionOffset;

    Message->ReturnStatus = STATUS_SUCCESS;
    MessageHeader.Length = sizeof(*Message);
    MessageHeader.Buffer = (PCHAR)Message;

    if (KdpSearchPhysicalMemoryRequested()) {

        //
        // This is a !search kd extension call.
        //

        KdpSearchPhysicalPageRange();
    }
    else {

        //
        // Check PAE low physical memory
        //

#if defined (_X86PAE_)

        if (MiNoLowMemory) {

            for (Page = MmLowestPhysicalPage;
                Page < MmHighestPhysicalPage && Page < 1024 * 1024;
                Page += 1) {


                if (! MiCheckPhysicalPagePattern (Page, &CorruptionOffset)) {
                    Message->ReturnStatus = Page;
                    break;
                }
            }
        }

#endif // #if defined (_X86PAE_)
    }

    //
    // Acknowledge the packet received.
    //

    KdpSendPacket (
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

//
// !search support routines
//

ULONG
KdpSearchHammingDistance (
    ULONG_PTR Left,
    ULONG_PTR Right
    )
/*++

Routine Description:

    This routine computes the Hamming distance (# of positions where the
    values are different).

    If this function becomes a bottleneck we should switch to a function
    table version.

Arguments:

    Left, Right operand.

Return Value:

    Hamming distance.

Environment:

    Any.

--*/

{
    ULONG_PTR Value;
    ULONG Index;
    ULONG Distance;

    Value = Left ^ Right;
    Distance = 0;

    for (Index = 0; Index < 8 * sizeof(ULONG_PTR); Index++) {

        if ((Value & (ULONG_PTR)0x01)) {

            Distance += 1;
        }

        Value >>= 1;
    }

    return Distance;
}

LOGICAL
KdpSearchPhysicalPage (
    IN PFN_NUMBER PageFrameIndex,
    ULONG_PTR RangeStart,
    ULONG_PTR RangeEnd,
    ULONG Flags
    )
/*++

Routine Description:

    This routine searches the physical page corresponding to a
    certain PFN index for any ULONG_PTR values in range [Start..End].

Arguments:

    PageFrameIndex - PFN index

    RangeStart - lowest possible value searched for

    RangeEnd - highest possible value searched for

    Flags - flags to control the search

Return Value:

    TRUE if a hit has been found, FALSE otherwise.
    The function stops after the first hit in the page is
    encountered and the infromation related to the hit (PFN index,
    offset, corrsponding VA) is registered in the hit database.

Environment:

    Call triggered only from Kd extension.

--*/

{
    PCHAR Va;
    ULONG Index;
    PHYSICAL_ADDRESS Pa;
    ULONG_PTR Value;

    //
    // Map the physical page using the debug PTE.
    //

    Pa.QuadPart = ((ULONGLONG)PageFrameIndex) << PAGE_SHIFT;

    Va = (PCHAR) MmDbgTranslatePhysicalAddress64 (Pa);

    for (Index = 0; Index < PAGE_SIZE - sizeof(ULONG_PTR); Index += 1, Va += 1) {

        Value = *((PULONG_PTR)Va);

        if ((Value >= RangeStart && Value <= RangeEnd)
            || KdpSearchHammingDistance(Value, RangeStart) == 1) {

            if (KdpSearchPageHitIndex < SEARCH_PAGE_HIT_DATABASE_SIZE) {

                KdpSearchPageHits[KdpSearchPageHitIndex] = PageFrameIndex;
                KdpSearchPageHitOffsets[KdpSearchPageHitIndex] = Index;

                KdpSearchPageHitIndex += 1;
            }

            if ((Flags & KDP_SEARCH_ALL_OFFSETS_IN_PAGE)) {

                continue;
            }
            else {

                return TRUE;
            }
        }
    }

    return FALSE;
}

LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    )
/*++

Routine Description:

    This routine determines if a physical range search has been
    requested. This is controlled by a global variable set in
    the `!search' debug extension.

Arguments:

    None

Return Value:

    TRUE if physical range search was requested.


Environment:

    Call triggered only from Kd extension.

--*/
{
    if (KdpSearchInProgress) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}

LOGICAL
KdpSearchPhysicalPageRange (
    VOID
    )
/*++

Routine Description:

    This routine will start a search in a range of physical pages in case
    `KdpSearchInProgress' is true. the parameters for the search are picked up
    from global vairiables that are set inside a kernel debugger extension.

Arguments:

    None

Return Value:

    TRUE if the function executed a search and FALSE otherwise.
    The results of the search are specified in the KdpSearchPageHits
    and related variables. this global variables offers the mechanism
    for the debugger extension to pickup the results of the search.


Environment:

    Call triggered only from Kd extension.

    Note. The !search extension make sure that the range requested
    is part of the system memory therefore we do not have to
    worry about sparse PFN databases here.

--*/

{
    PFN_NUMBER CurrentFrame;
    ULONG Flags;

    //
    // The debugger extension is supposed to set KdpSearchInProgress
    // to TRUE if a search is requested.
    //

    if (!KdpSearchInProgress) {

        return FALSE;
    }


    Flags = 0;

    //
    // If the search range is only one page we will give all
    // hits inside a page. By default we get only the first hit inside
    // a page.
    //

    if (KdpSearchEndPageFrame == KdpSearchStartPageFrame) {

        KdpSearchEndPageFrame += 1;

        Flags |= KDP_SEARCH_ALL_OFFSETS_IN_PAGE;
    }

    for (CurrentFrame = KdpSearchStartPageFrame;
         CurrentFrame < KdpSearchEndPageFrame;
         CurrentFrame += 1) {

        KdpSearchPhysicalPage (CurrentFrame,
                              KdpSearchAddressRangeStart,
                              KdpSearchAddressRangeEnd,
                              Flags);

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\read.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code to implement the NtReadFile system service.

--*/

#include "iop.h"

NTSTATUS
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    Buffer.  If the end of the file is reached before Length bytes have
    been read, then the operation will terminate.  The actual length of
    the data read from the file will be returned in the second longword
    of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Address of buffer to receive the data read from the file.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    LARGE_INTEGER fileOffset = {0,0};

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = Buffer;
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether or not we should automatically lock the user's
    // buffer for direct I/O.
    //

    if ((deviceObject->Flags & DO_DIRECT_IO) && (Length != 0)) {
        IoLockUserBuffer(irp, Length);
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.BufferOffset = 0;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         synchronousIo );

    return status;
}

NTSTATUS
NtReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    buffer segments.  The buffer segments are not virtually contiguous,
    but are 8 KB in length and alignment. If the end of the file is reached
    before Length bytes have been read, then the operation will terminate.
    The actual length of the data read from the file will be returned in
    the second longword of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be placed.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:

    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Verify this is a valid scatter read request.  In particular it must be
    // non-cached and and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES(Length);

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;
    irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION |
        IRP_SCATTER_GATHER_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // This is a direct I/O operation.  Lock down and clone the pages in the
    // segment array.  If the target device doesn't support scatter/gather I/O,
    // then also map a virtual buffer that describes the pages.
    //

    if (Length != 0) {

        status = MmLockSelectedIoPages(SegmentArray, Length, irp,
            (BOOLEAN)((deviceObject->Flags & DO_SCATTER_GATHER_IO) == 0));

        if (!NT_SUCCESS(status)) {
            IopExceptionCleanup(fileObject, irp, eventObject);
            return status;
        }
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.BufferOffset = 0;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\io\write.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code to implement the NtWriteFile system service.

--*/

#include "iop.h"

NTSTATUS
NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    file associated with FileHandle starting at StartingBlock|ByteOffset.
    The actual number of bytes written to the file will be returned in the
    second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    Buffer - Supplies the address of the buffer containing data to be written
        to the file.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    LARGE_INTEGER fileOffset = {0,0};

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->WriteAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = Buffer;
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether or not we should automatically lock the user's
    // buffer for direct I/O.
    //

    if ((deviceObject->Flags & DO_DIRECT_IO) && (Length != 0)) {
        IoLockUserBuffer(irp, Length);
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.BufferOffset = 0;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}

NTSTATUS
NtWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's segment
    buffers to the file associated with FileHandle starting at
    StartingBlock|ByteOffset. The actual number of bytes written to the file
    will be returned in the second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be read from.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:
    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->WriteAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Verify this is a valid gather write request.  In particular it must
    // be non-cached and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES( Length );

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;
    irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION |
        IRP_SCATTER_GATHER_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;

    //
    // This is a direct I/O operation.  Lock down and clone the pages in the
    // segment array.  If the target device doesn't support scatter/gather I/O,
    // then also map a virtual buffer that describes the pages.
    //

    if (Length != 0) {

        status = MmLockSelectedIoPages(SegmentArray, Length, irp,
            (BOOLEAN)((deviceObject->Flags & DO_SCATTER_GATHER_IO) == 0));

        if (!NT_SUCCESS(status)) {
            IopExceptionCleanup(fileObject, irp, eventObject);
            return status;
        }
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.BufferOffset = 0;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kddata.c ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    kddata.c

Abstract:

    This module contains global data for the portable kernel debgger.

--*/

#include "kdp.h"
#include "mi.h"
#include "pool.h"

//
// Miscellaneous data from all over the kernel
//

extern ULONG KiBugCheckData[];

extern POBJECT_DIRECTORY ObpRootDirectoryObject;
extern POBJECT_HANDLE_TABLE ObpObjectHandleTable;

extern SIZE_T PoolTrackTableSize;
extern PPOOL_TRACKER_TABLE PoolTrackTable;
extern POOL_DESCRIPTOR NonPagedPoolDescriptor;

extern PMMPFN MmPfnDatabase;

extern LIST_ENTRY FscLruList;

//
// Highest user address.
//

PVOID KdHighestUserAddress = MM_HIGHEST_USER_ADDRESS;

//
// Start of system address range.
//

PVOID KdSystemRangeStart = MM_SYSTEM_RANGE_START;

//
// User probe address.
//

ULONG_PTR KdUserProbeAddress = MM_USER_PROBE_ADDRESS;

//
// Lowest physical page number in the system.
//

PFN_NUMBER KdLowestPhysicalPage = MM_LOWEST_PHYSICAL_PAGE;

//
// Pointer to the default system process.
//

PKPROCESS KdActiveProcessHead = &KiSystemProcess;

//
// Storage for the processor state.
//

X86_NT5_KPROCESSOR_STATE KdProcessorState;

//
// This block of data needs to always be present because crashdumps
// need the information.  Otherwise, things like PAGE_SIZE are not available
// in crashdumps, and extensions like !pool fail.
//

KDDEBUGGER_DATA64 KdDebuggerDataBlock = {
    {0},                                    //  DBGKD_DEBUG_DATA_HEADER Header;
    (ULONG64)0,
    (ULONG64)RtlpBreakWithStatusInstruction,
    (ULONG64)0,
    (USHORT)0,                                      //  USHORT  ThCallbackStack;
    (USHORT)0,                                      //  USHORT  NextCallback;
    (USHORT)0,                                      //  USHORT  FramePointer;
    (USHORT)0,                                      //  USHORT  PaeEnabled;

    (ULONG64)NULL,
    (ULONG64)0,

    (ULONG64)&KdLoadedModuleList,
    (ULONG64)&KdActiveProcessHead,
    (ULONG64)NULL,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,

    (ULONG64)&KeTimeIncrement,
    (ULONG64)NULL,
    (ULONG64)KiBugCheckData,

    (ULONG64)NULL,

    (ULONG64)&ObpRootDirectoryObject,
    (ULONG64)NULL,

    (ULONG64)&KeSystemTime,
    (ULONG64)&KeInterruptTime,
    (ULONG64)&KiTimerTableListHead,

    (ULONG64)&MmPfnDatabase,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,

    (ULONG64)&KdLowestPhysicalPage,
    (ULONG64)&MmHighestPhysicalPage,
    (ULONG64)&MmNumberOfPhysicalPages,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)PAGE_SIZE,
    (ULONG64)NULL,

    (ULONG64)MmAllocatedPagesByUsage,
    (ULONG64)&ObpObjectHandleTable,
    (ULONG64)&MmVadRoot,
    (ULONG64)&FscLruList,
    (ULONG64)&FscNumberOfCachePages,
    (ULONG64)&FscElementArray,
    (ULONG64)NULL,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)&MmAvailablePages,

#ifdef NO_POOL_TAG_TRACKING
    (ULONG64)NULL,
    (ULONG64)NULL,
#else
    (ULONG64)&PoolTrackTableSize,
    (ULONG64)&PoolTrackTable,
#endif
    (ULONG64)&NonPagedPoolDescriptor,

    (ULONG64)&KdHighestUserAddress,
    (ULONG64)&KdSystemRangeStart,
    (ULONG64)&KdUserProbeAddress,

    (ULONG64)KdPrintCircularBuffer,
    (ULONG64)KdPrintCircularBuffer+sizeof(KdPrintCircularBuffer),

    (ULONG64)&KdPrintWritePointer,
    (ULONG64)&KdPrintRolloverCount,

    (ULONG64)NULL,
};

UCHAR  KdPrintCircularBuffer[KDPRINTBUFFERSIZE];
PUCHAR KdPrintWritePointer = KdPrintCircularBuffer;
ULONG  KdPrintRolloverCount;

BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE];
UCHAR KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE];
UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE];
DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS];

LARGE_INTEGER  KdPerformanceCounterRate;
LARGE_INTEGER  KdTimerStart;
LARGE_INTEGER  KdTimerStop;
LARGE_INTEGER  KdTimerDifference;

ULONG_PTR KdpCurrentSymbolStart;
ULONG_PTR KdpCurrentSymbolEnd;
LONG      KdpNextCallLevelChange;   // used only over returns to the debugger.

ULONG_PTR KdSpecialCalls[DBGKD_MAX_SPECIAL_CALLS];
ULONG     KdNumberOfSpecialCalls;
ULONG_PTR InitialSP;
ULONG     KdpNumInternalBreakpoints;
KTIMER    InternalBreakpointTimer;
KDPC      InternalBreakpointCheckDpc;


DBGKD_TRACE_DATA TraceDataBuffer[TRACE_DATA_BUFFER_MAX_SIZE];
ULONG            TraceDataBufferPosition = 1; // Element # to write next
                                   // Recall elt 0 is a length

TRACE_DATA_SYM   TraceDataSyms[256];
BOOLEAN TraceDataBufferFilled;
UCHAR NextTraceDataSym;     // what's the next one to be replaced
UCHAR NumTraceDataSyms;     // how many are valid?

ULONG IntBPsSkipping;       // number of exceptions that are being skipped now

BOOLEAN   WatchStepOver;
PVOID     WSOThread;                // thread doing stepover
ULONG_PTR WSOEsp;                   // stack pointer of thread doing stepover (yes, we need it)
ULONG     WatchStepOverHandle;
ULONG_PTR WatchStepOverBreakAddr;   // where the WatchStepOver break is set
BOOLEAN   WatchStepOverSuspended;
ULONG     InstructionsTraced;
BOOLEAN   SymbolRecorded;
LONG      CallLevelChange;
LONG_PTR  oldpc;
BOOLEAN   InstrCountInternal;       // Processing a non-COUNTONLY?

BOOLEAN   BreakpointsSuspended;

//
// KdpRetryCount controls the number of retries before we give up and
//   assume kernel debugger is not present.
// KdpNumberRetries is the number of retries left.  Initially, it is set
//   to 5 such that booting NT without debugger won't be delayed to long.
//

ULONG KdpRetryCount = 5;
ULONG KdpNumberRetries = 5;
BOOLEAN KdpControlCPending;
BOOLEAN KdpControlCPressed;

KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
ULONG KdpNextPacketIdToSend;
ULONG KdpPacketIdExpected;

//
// KdDebugParameters contains the debug port address and baud rate
//     used to initialize kernel debugger port.
//
// (They both get initialized to zero to indicate using default settings.)
// If SYSTEM hive contains the parameters, i.e. port and baud rate, system
// init code will fill in these variable with the values stored in the hive.
//

DEBUG_PARAMETERS KdDebugParameters;

LIST_ENTRY      KdpDebuggerDataListHead;

//
// !search support variables (page hit database)
//

PFN_NUMBER KdpSearchPageHits [SEARCH_PAGE_HIT_DATABASE_SIZE];
ULONG KdpSearchPageHitOffsets [SEARCH_PAGE_HIT_DATABASE_SIZE];
ULONG KdpSearchPageHitIndex;

LOGICAL KdpSearchInProgress;

PFN_NUMBER KdpSearchStartPageFrame;
PFN_NUMBER KdpSearchEndPageFrame;

ULONG_PTR KdpSearchAddressRangeStart;
ULONG_PTR KdpSearchAddressRangeEnd;

ULONG KdpSearchCheckPoint = KDP_SEARCH_SYMBOL_CHECK;

BOOLEAN KdDebuggerNotPresent;
BOOLEAN KdDebuggerEnabled;
BOOLEAN KdpDebuggerStructuresInitialized;
ULONG KdpOweBreakpoint;
ULONG KdEnteredDebugger;
ULONG KdGlobalFlag;

//
// Static loader data table entry for XBOXKRNL.EXE.
//
LDR_DATA_TABLE_ENTRY KdpNtosDataTableEntry;

//
// List of modules that have been loaded.
//
INITIALIZED_LIST_ENTRY(KdLoadedModuleList);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kddbgio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kddbgio.c

Abstract:

    This module implements kernel debugger based Dbg I/O. This
    is the foundation for DbgPrint and DbgPrompt.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    )

/*++

Routine Description:

    This routine prints a string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

Return Value:

    TRUE if Control-C present in input buffer after print is done.
    FALSE otherwise.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;

    //
    // Move the output string to the message buffer.
    //

    Length = KdpMoveMemory(
                (PCHAR)KdpMessageBuffer,
                (PCHAR)Output->Buffer,
                Output->Length
                );

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the print string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdPrintStringApi;
    DebugIo.ProcessorLevel = 6;
    DebugIo.Processor = (USHORT)0;
    DebugIo.u.PrintString.LengthOfString = Length;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdpSendPacket(
                  PACKET_TYPE_KD_DEBUG_IO,
                  &MessageHeader,
                  &MessageData
                  );

    return KdpPollBreakInWithPortLock();
}

BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

    Input - Supplies a pointer to a string descriptor for the input string.
            (Length stored/returned in Input->Length)

Return Value:

    TRUE - A Breakin sequence was seen, caller should breakpoint and retry
    FALSE - No Breakin seen.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;
    ULONG ReturnCode;

    //
    // Move the output string to the message buffer.
    //

    Length = KdpMoveMemory(
                (PCHAR)KdpMessageBuffer,
                (PCHAR)Output->Buffer,
                Output->Length
                );

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the prompt string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdGetStringApi;
    DebugIo.ProcessorLevel = 6;
    DebugIo.Processor = (USHORT)0;
    DebugIo.u.GetString.LengthOfPromptString = Length;
    DebugIo.u.GetString.LengthOfStringRead = Input->MaximumLength;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the prompt string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdpSendPacket(
                  PACKET_TYPE_KD_DEBUG_IO,
                  &MessageHeader,
                  &MessageData
                  );


    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_DEBUG_IO);
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;

    do {
        ReturnCode = KdpReceivePacket(
                                      PACKET_TYPE_KD_DEBUG_IO,
                                      &MessageHeader,
                                      &MessageData,
                                      &Length
                                      );
        if (ReturnCode == KDP_PACKET_RESEND) {
            return TRUE;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);


    if (Length > Input->MaximumLength) {
        Length = Input->MaximumLength;
    }

    Input->Length = (USHORT)KdpMoveMemory(
                                (PCHAR)Input->Buffer,
                                (PCHAR)KdpMessageBuffer,
                                Length
                                );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdbreak.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdbreak.c

Abstract:

    This module implements machine dependent functions to add and delete
    breakpoints from the kernel debugger breakpoint table.

Author:

    David N. Cutler 2-Aug-1990

Revision History:

--*/

#include "kdp.h"

ULONG
KdpAddBreakpoint (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine adds an entry to the breakpoint table and returns a handle
    to the breakpoint table entry.

Arguments:

    Address - Supplies the address where to set the breakpoint.

Return Value:

    A value of zero is returned if the specified address is already in the
    breakpoint table, there are no free entries in the breakpoint table, the
    specified address is not correctly aligned, or the specified address is
    not valid. Otherwise, the index of the assigned breakpoint table entry
    plus one is returned as the function value.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    ULONG Index;
    HARDWARE_PTE Opaque;
    PVOID AccessAddress;

    //DPRINT(("KD: Setting breakpoint at 0x%08x\n", Address));

    //
    // If the specified address is not properly aligned, then return zero.
    //

    if (((ULONG_PTR)Address & KDP_BREAKPOINT_ALIGN) != 0) {
        return 0;
    }


    //
    // Don't allow setting the same breakpoint twice.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) != 0 &&
            KdpBreakpointTable[Index].Address == Address) {

            if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) != 0) {

                //
                // Breakpoint was set, the page was written out and was not
                // accessible when the breakpoint was cleared.  Now the breakpoint
                // is being set again.  Just clear the defer flag:
                //
                KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
                return Index + 1;

            } else {

                DPRINT(("KD: Attempt to set breakpoint %08x twice!\n", Address));
                return 0;

            }
        }
    }

    //
    // Search the breakpoint table for a free entry.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags == 0) {
            break;
        }
    }

    //
    // If a free entry was found, then write breakpoint and return the handle
    // value plus one. Otherwise, return zero.
    //

    if (Index == BREAKPOINT_TABLE_SIZE) {
        DPRINT(("KD: ran out of breakpoints!\n"));
        return 0;
    }


    //DPRINT(("KD: using Index %d\n", Index));

    //
    // Get the instruction to be replaced. If the instruction cannot be read,
    // then mark breakpoint as not accessible.
    //

    if (KdpMoveMemory(
            (PCHAR)&Content,
            (PCHAR)Address,
            sizeof(KDP_BREAKPOINT_TYPE) ) != sizeof(KDP_BREAKPOINT_TYPE)) {
        AccessAddress = NULL;
        //DPRINT(("KD: memory inaccessible\n"));
    } else {
        //DPRINT(("KD: memory readable...\n"));

        //
        // If the specified address is not write accessible, then return zero.
        // All references must be made through AccessAddress.
        //

        AccessAddress = MmDbgWriteCheck((PVOID)Address, &Opaque);
        if (AccessAddress == NULL) {
            DPRINT(("KD: memory not writable!\n"));
            return 0;
        }
    }

    if ( AccessAddress != NULL ) {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Content = Content;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
        if (KdpMoveMemory(
                (PCHAR)AccessAddress,
                (PCHAR)&KdpBreakpointInstruction,
                sizeof(KDP_BREAKPOINT_TYPE)
                ) != sizeof(KDP_BREAKPOINT_TYPE)) {

            DPRINT(("KD: KdpMoveMemory failed writing BP!\n"));
        }
        MmDbgReleaseAddress(AccessAddress, &Opaque);
    } else {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE | KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        //DPRINT(("KD: breakpoint write deferred\n"));
    }

    return Index + 1;

}

VOID
KdSetOwedBreakpoints(
    VOID
    )

/*++

Routine Description:

    This function is called after returning from memory management calls
    that may cause an inpage.  Its purpose is to store pending
    breakpoints in pages just made valid.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    BOOLEAN Enable;
    LONG Index;
    HARDWARE_PTE Opaque;
    PVOID AccessAddress;

    //
    // If we don't owe any breakpoints then return
    //

    if ( !KdpOweBreakpoint ) {
        return;
    }

    //
    // Freeze all other processors, disable interrupts, and save debug
    // port state.
    //

    Enable = KdEnterDebugger(NULL, NULL);
    KdpOweBreakpoint = FALSE;
    AccessAddress = NULL;

    //
    // Search the breakpoint table for breakpoints that need to be
    // written or replaced.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags &
                (KD_BREAKPOINT_NEEDS_WRITE | KD_BREAKPOINT_NEEDS_REPLACE) ) {

            //
            // Breakpoint needs to be written
            //
            //DPRINT(("KD: Breakpoint %d at 0x%08x: trying to %s after page in.\n",
            //    Index,
            //    KdpBreakpointTable[Index].Address,
            //    (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) ?
            //        "set" : "clear"));

            //
            // Check to see if we have write access to the memory
            //

            AccessAddress = MmDbgWriteCheck((PVOID)KdpBreakpointTable[Index].Address, &Opaque);

            if (AccessAddress == NULL) {
                KdpOweBreakpoint = TRUE;
                //DPRINT(("KD: address not writeable.\n"));
                break;
            }

            //
            // Breakpoint is global, or its directory base matches
            //

            if (KdpMoveMemory(
                    (PCHAR)&Content,
                    (PCHAR)AccessAddress,
                    sizeof(KDP_BREAKPOINT_TYPE)
                    ) != sizeof(KDP_BREAKPOINT_TYPE)) {

                //
                // Memory is still inaccessible (is this possible after
                // the call above to MmDbgWriteCheck?)
                //

                DPRINT(("KD: read from 0x%08x failed\n", KdpBreakpointTable[Index].Address));

                KdpOweBreakpoint = TRUE;

            } else {
                if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {
                    KdpBreakpointTable[Index].Content = Content;
                    if (KdpMoveMemory(
                            (PCHAR)AccessAddress,
                            (PCHAR)&KdpBreakpointInstruction,
                            sizeof(KDP_BREAKPOINT_TYPE)
                            ) != sizeof(KDP_BREAKPOINT_TYPE)) {
                        KdpOweBreakpoint = TRUE;
                        DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                    } else {
                        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
                        DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                    }
                } else {
                    if (KdpMoveMemory(
                            (PCHAR)AccessAddress,
                            (PCHAR)&KdpBreakpointTable[Index].Content,
                            sizeof(KDP_BREAKPOINT_TYPE)
                            ) != sizeof(KDP_BREAKPOINT_TYPE)) {
                        KdpOweBreakpoint = TRUE;
                        DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                    } else {
                        //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                        if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                            KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE;
                        } else {
                            KdpBreakpointTable[Index].Flags = 0;
                        }
                    }
                }
            }

            if (AccessAddress != NULL) {
                MmDbgReleaseAddress(
                        AccessAddress,
                        &Opaque
                        );
                AccessAddress = NULL;
            }
        }
    }

    if (AccessAddress != NULL) {
        MmDbgReleaseAddress(
                AccessAddress,
                &Opaque
                );
    }

    KdExitDebugger(Enable);
    return;
}

BOOLEAN
KdpLowWriteContent (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to replace the code that a breakpoint is
    written over.  This routine, KdpAddBreakpoint,
    KdpLowRestoreBreakpoint and KdSetOwedBreakpoints are responsible
    for getting data written as requested.  Callers should not
    examine or use KdpOweBreakpoints, and they should not set the
    NEEDS_WRITE or NEEDS_REPLACE flags.

    Callers must still look at the return value from this function,
    however: if it returns FALSE, the breakpoint record must not be
    reused until KdSetOwedBreakpoints has finished with it.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be deleted.

Return Value:

    Returns TRUE if the breakpoint was removed, FALSE if it was deferred.

--*/

{
    //
    // Do the contents need to be replaced at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {

        //
        // The breakpoint was never written out.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: Breakpoint at 0x%08x never written; flag cleared.\n",
        //    KdpBreakpointTable[Index].Address));
        return TRUE;
    }

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        //DPRINT(("KD: Breakpoint at 0x%08x; instr is really BP; flag cleared.\n",
        //    KdpBreakpointTable[Index].Address));

        return TRUE;
    }

    //
    // Restore the instruction contents.
    //

    if (KdpMoveMemory( (PCHAR)KdpBreakpointTable[Index].Address,
                        (PCHAR)&KdpBreakpointTable[Index].Content,
                        sizeof(KDP_BREAKPOINT_TYPE) ) != sizeof(KDP_BREAKPOINT_TYPE)) {

        KdpOweBreakpoint = TRUE;
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
        //DPRINT(("KD: Breakpoint at 0x%08x; unable to clear, flag set.\n",
            //KdpBreakpointTable[Index].Address));
        return FALSE;
    } else {
        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
            //KdpBreakpointTable[Index].Address));
        return TRUE;
    }
}

BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    )

/*++

Routine Description:

    This routine deletes an entry from the breakpoint table.

Arguments:

    Handle - Supplies the index plus one of the breakpoint table entry
        which is to be deleted.

Return Value:

    A value of FALSE is returned if the specified handle is not a valid
    value or the breakpoint cannot be deleted because the old instruction
    cannot be replaced. Otherwise, a value of TRUE is returned.

--*/

{
    ULONG Index = Handle - 1;

    //
    // If the specified handle is not valid, then return FALSE.
    //

    if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {
        DPRINT(("KD: Breakpoint %d invalid.\n", Index));
        return FALSE;
    }

    //
    // If the specified breakpoint table entry is not valid, then return FALSE.
    //

    if (KdpBreakpointTable[Index].Flags == 0) {
        //DPRINT(("KD: Breakpoint %d already clear.\n", Index));
        return FALSE;
    }

    //
    // If the breakpoint is already suspended, just delete it from the table.
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
        //DPRINT(("KD: Deleting suspended breakpoint %d \n", Index));
        if ( !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) ) {
            //DPRINT(("KD: already clear.\n"));
            KdpBreakpointTable[Index].Flags = 0;
            return TRUE;
        }
    }

    //
    // Replace the instruction contents.
    //

    if (KdpLowWriteContent(Index)) {

        //
        // Delete breakpoint table entry
        //

        //DPRINT(("KD: Breakpoint %d deleted successfully.\n", Index));
        KdpBreakpointTable[Index].Flags = 0;
    }

    return TRUE;
}

BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine deletes all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to remove BPs.

    Upper - include upper address of range from which to remove BPs.

Return Value:

    TRUE if any breakpoints removed, FALSE otherwise.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++)
    {
        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper)) )
        {

            //
            // Breakpoint is in use and falls in range, clear it.
            //

            if (KdpDeleteBreakpoint(Index+1))
            {
                ReturnStatus = TRUE;
            }
        }
    }

    return ReturnStatus;

}

VOID
KdpSuspendBreakpoint (
    ULONG Handle
    )
{
    ULONG Index = Handle - 1;

    if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
        !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_SUSPENDED;
        KdpLowWriteContent(Index);
    }

    return;

} // KdpSuspendBreakpoint

VOID
KdpSuspendAllBreakpoints (
    VOID
    )
{
    ULONG Handle;

    BreakpointsSuspended = TRUE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpSuspendBreakpoint(Handle);
    }

    return;

} // KdpSuspendAllBreakpoints

BOOLEAN
KdpLowRestoreBreakpoint (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to write a breakpoint instruction.
    The old contents must have already been stored in the
    breakpoint record.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be written.

Return Value:

    Returns TRUE if the breakpoint was written, FALSE if it was
    not and has been marked for writing later.

--*/

{
    KDP_BREAKPOINT_TYPE Content;

    //
    // Does the breakpoint need to be written at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) {

        //
        // The breakpoint was never removed.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
        return TRUE;
    }

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }

    //
    // Replace the instruction contents.
    //

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }

    //
    // Replace the instruction contents.
    //

    if (KdpMoveMemory( (PCHAR)KdpBreakpointTable[Index].Address,
                       (PCHAR)&KdpBreakpointInstruction,
                       sizeof(KDP_BREAKPOINT_TYPE) ) != sizeof(KDP_BREAKPOINT_TYPE)) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;

    } else {

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        return TRUE;
    }
}

VOID
KdpRestoreAllBreakpoints (
    VOID
    )
{
    ULONG Index;

    BreakpointsSuspended = FALSE;

    for ( Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++ ) {

        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
            (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

            KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_SUSPENDED;
            KdpLowRestoreBreakpoint(Index);
        }
    }

    return;

} // KdpRestoreAllBreakpoints

VOID
KdDeleteAllBreakpoints(
    VOID
    )
{
    ULONG Handle;

    if (KdDebuggerEnabled == FALSE) {
        return;
    }

    BreakpointsSuspended = FALSE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpDeleteBreakpoint(Handle);
    }

    return;
} // KdDeleteAllBreakpoints
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdinit.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    kdinit.c

Abstract:

    This module implements the initialization for the portable kernel debgger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"

#define ROM_BASE_ADDRESS            0xFFF00000
#define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
#define ROM_VERSION_KDDELAY_FLAG    0x80000000

VOID
KdInitSystem(
    BOOLEAN InitializingSystem
    )
/*++

Routine Description:

    This routine initializes the portable kernel debugger.

Arguments:

    InitializingSystem - Supplies a boolean value that determines whether we're
        called in the context of system initialization or bugcheck code.

Return Value:

    None.

--*/

{

    ULONG Index;
    BOOLEAN SuperIoInitialized;
    BOOLEAN Initialize;
    STRING NameString;

    //
    // If kernel debugger is already initialized, then return.
    //

    if (KdDebuggerEnabled != FALSE) {
        return;
    }

    KiDebugRoutine = KdpStub;

    //
    // Determine whether or not the debugger should be enabled.
    //
    // Note that if InitializingSystem == FALSE, then KdInitSystem was called
    // from BugCheck code. For this case the debugger is always enabled
    // to report the bugcheck if possible.
    //

    if (InitializingSystem) {

        //
        // Initialize the loader data table entry for XBOXKRNL.EXE and attach it
        // to the loaded module list.
        //

        KdpNtosDataTableEntry.DllBase = PsNtosImageBase;
        KdpNtosDataTableEntry.SizeOfImage =
            RtlImageNtHeader(PsNtosImageBase)->OptionalHeader.SizeOfImage;
        KdpNtosDataTableEntry.LoadedImports = (PVOID)MAXULONG_PTR;
        RtlInitUnicodeString(&KdpNtosDataTableEntry.FullDllName, L"xboxkrnl.exe");
        RtlInitUnicodeString(&KdpNtosDataTableEntry.BaseDllName, L"xboxkrnl.exe");

        InsertTailList(&KdLoadedModuleList, &KdpNtosDataTableEntry.InLoadOrderLinks);

        //
        // Initialize the debugger data block list when called at startup time.
        //

        InitializeListHead(&KdpDebuggerDataListHead);

        //
        // Fill in and register the debugger's debugger data block.
        // Most fields are already initialized, some fields will not be
        // filled in until later.
        //

        KdDebuggerDataBlock.KernBase = (ULONG_PTR) PsNtosImageBase;

        KdRegisterDebuggerDataBlock(KDBG_TAG,
                                    &KdDebuggerDataBlock.Header,
                                    sizeof(KdDebuggerDataBlock));

        //
        // Always initialize the kernel debugger if the system has a super I/O
        // controller that we can communicate with.
        //

        HalPulseHardwareMonitorPin();
        Initialize = HalInitializeSuperIo();

    } else {
        Initialize = TRUE;
    }

    if ((KdPortInitialize(&KdDebugParameters, Initialize) == FALSE) ||
        (Initialize == FALSE)) {
        return;
    }

    //
    // If we're going to delay the kernel debugger setup, then mark the debugger
    // as not present for now.
    //

    if (((PULONG)ROM_BASE_ADDRESS)[ROM_VERSION_OFFSET] & ROM_VERSION_KDDELAY_FLAG) {
        KdDebuggerNotPresent = TRUE;
    }

    //
    // Set address of kernel debugger trap routine.
    //

    KiDebugRoutine = KdpTrap;

    if (!KdpDebuggerStructuresInitialized) {

        KdpBreakpointInstruction = KDP_BREAKPOINT_VALUE;
        KdpOweBreakpoint = FALSE;

        //
        // Initialize the breakpoint table.
        //

        for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
            KdpBreakpointTable[Index].Flags = 0;
            KdpBreakpointTable[Index].Address = NULL;
        }

        KdpDebuggerStructuresInitialized = TRUE ;
    }

    //
    //  Initialize timer facility - HACKHACK
    //

    KdPerformanceCounterRate = KeQueryPerformanceFrequency();
    KdTimerStart.HighPart = 0L;
    KdTimerStart.LowPart = 0L;

    //
    // Initialize ID for NEXT packet to send and Expect ID of next incoming
    // packet.
    //

    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
    KdpPacketIdExpected = INITIAL_PACKET_ID;

    //
    // Mark debugger enabled.
    //
    KdDebuggerEnabled = TRUE;

    //
    // Notify the debugger that XBOXKRNL.EXE is loaded.
    //

    if (InitializingSystem) {
        RtlInitAnsiString(&NameString, "xboxkrnl.exe");
        DbgLoadImageSymbols(&NameString, PsNtosImageBase, (ULONG)-1);
    }
}

BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    )
/*++

Routine Description:

    This routine is called by a component or driver to register a
    debugger data block.  The data block is made accessible to the
    kernel debugger, thus providing a reliable method of exposing
    random data to debugger extensions.

Arguments:

    Tag - Supplies a unique 4 byte tag which is used to identify the
            data block.

    DataHeader - Supplies the address of the debugger data block header.
            The OwnerTag field must contain a unique value, and the Size
            field must contain the size of the data block, including the
            header.  If this block is already present, or there is
            already a block with the same value for OwnerTag, this one
            will not be inserted.  If Size is incorrect, this code will
            not notice, but the usermode side of the debugger might not
            function correctly.

    Size - Supplies the size of the data block, including the header.

Return Value:

    TRUE if the block was added to the list, FALSE if not.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY List;
    PDBGKD_DEBUG_DATA_HEADER64 Header;

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Look for a record with the same tag or address
    //

    List = KdpDebuggerDataListHead.Flink;

    while (List != &KdpDebuggerDataListHead) {

        Header = CONTAINING_RECORD(List, DBGKD_DEBUG_DATA_HEADER64, List);

        List = List->Flink;

        if ((Header == DataHeader) || (Header->OwnerTag == Tag)) {
            KeLowerIrql(OldIrql);
            return FALSE;
        }
    }

    //
    // It wasn't already there, so add it.
    //

    DataHeader->OwnerTag = Tag;
    DataHeader->Size = Size;

    InsertTailList(&KdpDebuggerDataListHead, (PLIST_ENTRY)(&DataHeader->List));

    KeLowerIrql(OldIrql);

    return TRUE;
}

VOID
KdLogDbgPrint(
    IN PSTRING String
    )
{
    KIRQL OldIrql;
    ULONG Length;
    ULONG LengthCopied;

    KeRaiseIrql (HIGH_LEVEL, &OldIrql);

    if (KdPrintCircularBuffer) {
        Length = String->Length;
        //
        // truncate ridiculous strings
        //
        if (Length > KDPRINTBUFFERSIZE) {
            Length = KDPRINTBUFFERSIZE;
        }

        if (KdPrintWritePointer + Length <= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
            LengthCopied = KdpMoveMemory(KdPrintWritePointer, String->Buffer, Length);
            KdPrintWritePointer += LengthCopied;
            if (KdPrintWritePointer >= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
                KdPrintWritePointer = KdPrintCircularBuffer;
                KdPrintRolloverCount++;
            }
        } else {
            ULONG First = (ULONG)(KdPrintCircularBuffer + KDPRINTBUFFERSIZE - KdPrintWritePointer);
            LengthCopied = KdpMoveMemory(KdPrintWritePointer,
                                         String->Buffer,
                                         First);
            if (LengthCopied == First) {
                LengthCopied += KdpMoveMemory(KdPrintCircularBuffer,
                                              String->Buffer + First,
                                              Length - First);
            }
            if (LengthCopied > First) {
                KdPrintWritePointer = KdPrintCircularBuffer + LengthCopied - First;
                KdPrintRolloverCount++;
            } else {
                KdPrintWritePointer += LengthCopied;
                if (KdPrintWritePointer >= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
                    KdPrintWritePointer = KdPrintCircularBuffer;
                    KdPrintRolloverCount++;
                }
            }
        }
    }

    KeLowerIrql(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdlock.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kdlock.c

Abstract:

    This module contains code to synchronize the usage of the port
    used by the kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "kdp.h"
#include "dm.h"

BOOLEAN
KdPollBreakIn(
    VOID
    )

/*++

Routine Description:

    This procedure raises IRQL to high_level, seizes the Debug port
    spinlock, and checks to see if a breakin packet is pending.
    If a packet is present, return TRUE, else FALSE.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{
    BOOLEAN BreakIn;
    BOOLEAN Enable;
    UCHAR   Input;
    KIRQL   OldIrql;
    ULONG   Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        Enable = KiDisableInterrupts();
#ifndef _X86_
        KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif
        if (KdpControlCPending != FALSE) {
            KdpControlCPressed = TRUE;
            BreakIn = TRUE;
            KdpControlCPending = FALSE;

        } else {
            KdpPortLock();
            Status = KdPortPollByte(&Input);
            if ((Status == CP_GET_SUCCESS) &&
                (Input == BREAKIN_PACKET_BYTE)) {
                BreakIn = TRUE;
                KdpControlCPressed = TRUE;
            }
            KdpPortUnlock();
        }

#ifndef _X86_
        KeLowerIrql(OldIrql);
#endif
        KiRestoreInterrupts(Enable);
    }

    if(BreakIn)
        /* We can probably assume that the debugger is reconnected */
        KdDebuggerNotPresent = FALSE;

#ifdef DEVKIT
    /* If we're going to break in, give the debug monitor a chance to do its
     * own version of break in */
    if(BreakIn && KeGetCurrentPrcb())
        DmTell(DMTELL_ENTERDEBUGGER, NULL);
#endif

    return BreakIn;
}

BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    )

/*++

Routine Description:

    This procedure same as KdPollBreakIn, but assumes the caller
    already holds the port lock.  Returns TRUE if a breakin packet
    is pending.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{

    BOOLEAN BreakIn;
    BOOLEAN Enable;
    UCHAR Input;
    ULONG Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        if (KdpControlCPending != FALSE) {
            BreakIn = TRUE;
            KdpControlCPending = FALSE;

        } else {
            Status = KdPortPollByte(&Input);
            if ((Status == CP_GET_SUCCESS) &&
                (Input == BREAKIN_PACKET_BYTE)) {
                BreakIn = TRUE;
            }
        }
    }

    return BreakIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdp.h

Abstract:

    Private include file for the Kernel Debugger subcomponent
    of the NTOS project

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#include "ntos.h"
#include "ki.h"
#include "string.h"
#include "stdlib.h"

//
// Put all of the kernel debugger code in one section and the read-write data
// into another section.  Do this before including wdbgexts.h and ntdbg.h as
// these declare inline functions that shouldn't be placed in the normal code
// section.
//
// The kernel debugger data section needs to be merged into the main data
// section so that it's properly reinitialized across a quick reboot.
//

#pragma code_seg("KDCODE")
#pragma const_seg("KDDATA_RD")
#pragma data_seg("KDDATA_RW")
#pragma bss_seg("KDDATA_URW")
#pragma comment(linker, "/merge:KDDATA_RD=KDCODE")
#pragma comment(linker, "/merge:KDDATA_RW=.data")
#pragma comment(linker, "/merge:KDDATA_URW=.bss")

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"

#define KDP_BREAKPOINT_TYPE  UCHAR
#define KDP_BREAKPOINT_ALIGN 0
#define KDP_BREAKPOINT_VALUE 0xcc

//
// Define constants.
//

//
// Addresses above GLOBAL_BREAKPOINT_LIMIT are either in system space
// or part of dynlink, so we treat them as global.
//

#define GLOBAL_BREAKPOINT_LIMIT 1610612736L // 1.5gigabytes

//
// Define breakpoint table entry structure.
//

#define KD_BREAKPOINT_IN_USE        0x00000001
#define KD_BREAKPOINT_NEEDS_WRITE   0x00000002
#define KD_BREAKPOINT_SUSPENDED     0x00000004
#define KD_BREAKPOINT_NEEDS_REPLACE 0x00000008
// IA64 specific defines
#define KD_BREAKPOINT_STATE_MASK    0x0000000f

//
// status Constants for Packet waiting
//

#define KDP_PACKET_RECEIVED 0
#define KDP_PACKET_TIMEOUT 1
#define KDP_PACKET_RESEND 2


typedef struct _BREAKPOINT_ENTRY {
    UCHAR Flags;
    KDP_BREAKPOINT_TYPE Content;
    PVOID Address;
} BREAKPOINT_ENTRY, *PBREAKPOINT_ENTRY;


//
// Misc defines
//

#define MAXIMUM_RETRIES 20

#define DBGKD_MAX_SPECIAL_CALLS 10

typedef struct _TRACE_DATA_SYM {
    ULONG SymMin;
    ULONG SymMax;
} TRACE_DATA_SYM, *PTRACE_DATA_SYM;

//
//
//

typedef struct _X86_NT5_DBGKD_WAIT_STATE_CHANGE64 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
    } u;
    DBGKD_CONTROL_REPORT ControlReport;
    X86_NT5_CONTEXT Context;
} X86_NT5_DBGKD_WAIT_STATE_CHANGE64, *PX86_NT5_DBGKD_WAIT_STATE_CHANGE64;

//
// Kernel debugger port functions.
//

BOOLEAN
KdPortInitialize (
    PDEBUG_PARAMETERS DebugParameters,
    BOOLEAN Initialize
    );

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    );

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    );

VOID
KdPortPutByte (
    IN UCHAR Output
    );

//
// Define function prototypes.
//

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    );

BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

ULONG
KdpAddBreakpoint (
    IN PVOID Address
    );

BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    );

BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

#if i386

NTSTATUS
KdGetTraceInformation (
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength
    );

VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    );

#endif

NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN ULONG Length,
    OUT PULONG RequiredLength
    );

VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdClearSpecialCalls (
    VOID
    );

ULONG
KdpMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

ULONG
KdpReceivePacket (
    IN ULONG ExpectedPacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    );

VOID
KdpSetLoadState(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdpSetStateChange(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdpSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    );

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord64,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    );

KCONTINUE_STATUS
KdpSendWaitContinue(
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    );

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    );

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpSuspendBreakpoint (
    ULONG Handle
    );

VOID
KdpSuspendAllBreakpoints (
    VOID
    );

VOID
KdpRestoreAllBreakpoints (
    VOID
    );

VOID
KdpSaveProcessorControlState (
    IN PX86_NT5_KPROCESSOR_STATE ProcessorState
    );

VOID
KdpRestoreProcessorControlState (
    IN PX86_NT5_KPROCESSOR_STATE ProcessorState
    );

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

//
// Define dummy prototype so the address of the standard breakpoint instruction
// can be captured.
//
// N.B. This function is NEVER called.
//

VOID
RtlpBreakWithStatusInstruction (
    VOID
    );

//
// Define external references.
//

#define KDP_MESSAGE_BUFFER_SIZE 4096

extern BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE];
extern BOOLEAN KdpControlCPending;
extern PKDEBUG_ROUTINE KiDebugRoutine;
extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern UCHAR KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern ULONG KdpOweBreakpoint;
extern ULONG KdpNextPacketIdToSend;
extern ULONG KdpPacketIdExpected;

extern LARGE_INTEGER KdPerformanceCounterRate;
extern LARGE_INTEGER KdTimerStart;
extern LARGE_INTEGER KdTimerStop;
extern LARGE_INTEGER KdTimerDifference;

extern BOOLEAN BreakpointsSuspended;
extern LIST_ENTRY KdpDebuggerDataListHead;

typedef struct {
    ULONG64 Addr;                 // pc address of breakpoint
    ULONG Flags;                // Flags bits
    ULONG Calls;                // # of times traced routine called
    ULONG CallsLastCheck;       // # of calls at last periodic (1s) check
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;      // largest number of instructions for 1 call
    ULONG MaxInstructions;      // smallest # of instructions for 1 call
    ULONG TotalInstructions;    // total instructions for all calls
    ULONG Handle;               // handle in (regular) bpt table
    PVOID Thread;               // Thread that's skipping this BP
    ULONG64 ReturnAddress;        // return address (if not COUNTONLY)
} DBGKD_INTERNAL_BREAKPOINT, *PDBGKD_INTERNAL_BREAKPOINT;


#define DBGKD_MAX_INTERNAL_BREAKPOINTS 20
extern DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS];

extern X86_NT5_KPROCESSOR_STATE KdProcessorState;

extern ULONG_PTR   KdpCurrentSymbolStart;
extern ULONG_PTR   KdpCurrentSymbolEnd;
extern LONG    KdpNextCallLevelChange;
extern ULONG_PTR   KdSpecialCalls[];
extern ULONG   KdNumberOfSpecialCalls;
extern ULONG_PTR   InitialSP;
extern ULONG   KdpNumInternalBreakpoints;
extern KTIMER  InternalBreakpointTimer;
extern KDPC    InternalBreakpointCheckDpc;
extern LARGE_INTEGER   KdpTimeEntered;

extern DBGKD_TRACE_DATA TraceDataBuffer[];
extern ULONG            TraceDataBufferPosition;
extern TRACE_DATA_SYM   TraceDataSyms[];
extern BOOLEAN          TraceDataBufferFilled;
extern UCHAR NextTraceDataSym;
extern UCHAR NumTraceDataSyms;
extern ULONG IntBPsSkipping;
extern BOOLEAN WatchStepOver;
extern PVOID WSOThread;
extern ULONG_PTR WSOEsp;
extern ULONG WatchStepOverHandle;
extern ULONG_PTR WatchStepOverBreakAddr;
extern BOOLEAN WatchStepOverSuspended;
extern ULONG InstructionsTraced;
extern BOOLEAN SymbolRecorded;
extern LONG CallLevelChange;
extern LONG_PTR oldpc;
extern BOOLEAN InstrCountInternal;
extern BOOLEAN BreakpointsSuspended;
extern BOOLEAN KdpControlCPending;
extern BOOLEAN KdpControlCPressed;
extern ULONG KdpRetryCount;
extern ULONG KdpNumberRetries;

extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern ULONG KdpOweBreakpoint;
extern ULONG KdpNextPacketIdToSend;
extern ULONG KdpPacketIdExpected;
extern UCHAR  KdPrintCircularBuffer[KDPRINTBUFFERSIZE];
extern PUCHAR KdPrintWritePointer;
extern ULONG  KdPrintRolloverCount;
extern DEBUG_PARAMETERS KdDebugParameters;
extern LIST_ENTRY KdpDebuggerDataListHead;
extern KDDEBUGGER_DATA64 KdDebuggerDataBlock;
extern BOOLEAN KdpDebuggerStructuresInitialized;
extern ULONG KdEnteredDebugger;
extern ULONG KdGlobalFlag;

extern LDR_DATA_TABLE_ENTRY KdpNtosDataTableEntry;

//
// !search support (page hit database)
//

//
// Hit database where search results are stored (kddata.c). 
// The debugger extensions know how to extract the information 
// from here.
//
// Note that the size of the hit database is large enough to
// accomodate any searches because the !search extension works
// in batches of pages < PAGE_SIZE and for every page we register only 
// one hit.
//

#define SEARCH_PAGE_HIT_DATABASE_SIZE PAGE_SIZE

extern PFN_NUMBER KdpSearchPageHits[SEARCH_PAGE_HIT_DATABASE_SIZE];
extern ULONG KdpSearchPageHitOffsets[SEARCH_PAGE_HIT_DATABASE_SIZE];

extern ULONG KdpSearchPageHitIndex;

//
// Set to true while a physical memory search is in progress.
// Reset at the end of the search. This is done in the debugger
// extension and it is a flag used by KdpCheckLowMemory to get
// onto a different code path.
//

extern LOGICAL KdpSearchInProgress;

//
// These variables store the current state of the search operation.
// They can be used to restore an interrupted search.
//

extern PFN_NUMBER KdpSearchStartPageFrame;
extern PFN_NUMBER KdpSearchEndPageFrame;

extern ULONG_PTR KdpSearchAddressRangeStart;
extern ULONG_PTR KdpSearchAddressRangeEnd;

//
// Checkpoint variable used to test if we have the right
// debugging symbols.
//

#define KDP_SEARCH_SYMBOL_CHECK 0xABCDDCBA

extern ULONG KdpSearchCheckPoint;

//
// Page search flags
//

#define KDP_SEARCH_ALL_OFFSETS_IN_PAGE 0x0001


//
// Define macros to lock and unlock the debug port.  The caller must have the
// proper IRQL before using these macros.
//

#define KdpPortLock()                   NOTHING
#define KdpPortUnlock()                 NOTHING


//
// Private procedure prototypes
//

VOID
KdpInitCom(
    VOID
    );

BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    );

USHORT
KdpReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    );

#if DBG

#define DPRINT(s) KdpDprintf s

VOID
KdpDprintf(
    IN PCHAR f,
    ...
    );

#else

#define DPRINT(s)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\ixkdcom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.c

Abstract:

    This module contains a very simply package to do com I/O on machines
    with standard AT com-ports.  It is C code derived from the debugger's
    com code.  Likely does not work on a PS/2.  (Only rewrote the thing
    into C so we wouldn't have to deal with random debugger macros.)

    Procedures to init a com object, set and query baud rate, output
    character, input character.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 12-Jun-1991
        Added ability to check for com-port's existence and hook onto the
        highest com-port available.

    John Vert (jvert) 19-Jul-1991
        Moved into HAL

--*/

#include    "kdp.h"
#include    "ixkdcom.h"
// timeout was 1024 * 500, but at 115200 baud, this should be enough
#define     TIMEOUT_COUNT  1024 * 100

UCHAR CpReadLsr (PCPPORT, UCHAR);

BOOLEAN KdDbgPortsPresent = TRUE;
UCHAR   KdDbgErrorCount;

#define DBG_ACCEPTABLE_ERRORS   25

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR  Address,
    ULONG  Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{
    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    _outp(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    _outp(hwport, ier);
}

VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG   Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{
    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = (UCHAR)_inp(hwport);

    lcr |= LC_DLAB;
    _outp(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    _outp(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    _outp(hwport, (UCHAR)(divisorlatch & 0xff));


    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    _outp(hwport, 3);


    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR   waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/
{
    UCHAR   lsr;

    lsr = (UCHAR)_inp(Port->Address + COM_LSR);

    //
    // Check to see if the port still exists.
    //
    if (lsr == SERIAL_LSR_NOT_PRESENT) {

        KdDbgErrorCount++;

        if (KdDbgErrorCount >= DBG_ACCEPTABLE_ERRORS) {
            KdDbgPortsPresent = FALSE;
            KdDbgErrorCount = 0;
        }
        return SERIAL_LSR_NOT_PRESENT;
    }

    if (lsr & waiting) {
        return lsr;
    }

    return lsr;
}

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{
    if (KdDbgPortsPresent == FALSE) {
        return;
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    _outp(Port->Address + COM_DAT, Byte);
}

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.

    Return Value:

        CP_GET_SUCCESS if data returned.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{
    UCHAR   lsr;
    UCHAR   value;
    ULONG   limitcount;

    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //

    if (Port->Address == NULL) {
        return(CP_GET_NODATA);
    }

    if (KdDbgPortsPresent == FALSE) {

        if (CpReadLsr(Port, COM_DATRDY) == SERIAL_LSR_NOT_PRESENT) {

            return(CP_GET_NODATA);
        } else {

            CpSetBaud(Port, Port->Baud);
            KdDbgPortsPresent = TRUE;
        }
    }

    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);

        if (lsr == SERIAL_LSR_NOT_PRESENT) {
            return(CP_GET_NODATA);
        }

        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //
            if (lsr & (COM_FE | COM_PE | COM_OE)) {
                *Byte = 0;
                return(CP_GET_ERROR);
            }

            //
            // fetch the byte
            //

            value = (UCHAR)_inp(Port->Address + COM_DAT);

            *Byte = value & (UCHAR)0xff;
            return CP_GET_SUCCESS;
        }
    }

    CpReadLsr (Port, 0);
    return CP_GET_NODATA;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\kdmove.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdmove.c

Abstract:

    This module contains code to implement the portable kernel debugger
    memory mover.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

ULONG
KdpMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine moves data to or from the message buffer and returns the
    actual length of the information that was moved. As data is moved, checks
    are made to ensure that the data is resident in memory and a page fault
    will not occur. If a page fault would occur, then the move is truncated.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    The actual length of the move is returned as the fucntion value.

--*/

{

    PVOID Address1;
    PVOID Address2;
    ULONG ActualLength;
    HARDWARE_PTE Opaque;

    //
    // If the length is greater than the size of the message buffer, then
    // reduce the length to the size of the message buffer.
    //

    if (Length > KDP_MESSAGE_BUFFER_SIZE) {
        Length = KDP_MESSAGE_BUFFER_SIZE;
    }

    //
    // Move the source information to the destination address.
    //

    ActualLength = Length;
    Address1 = NULL;

    while (((ULONG_PTR)Source & 3) && (Length > 0)) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = MmDbgWriteCheck((PVOID)Destination, &Opaque);
        Address2 = MmDbgReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }
        *(PCHAR)Address1 = *(PCHAR)Address2;
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;

        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    if (Address1 != NULL) {
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;
    }

    while (Length > 3) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = MmDbgWriteCheck((PVOID)Destination, &Opaque);
        Address2 = MmDbgReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }
        *(ULONG UNALIGNED *)Address1 = *(PULONG)Address2;
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;

        Destination += 4;
        Source += 4;
        Length -= 4;

    }

    if (Address1 != NULL) {
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;
    }

    while (Length > 0) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = MmDbgWriteCheck((PVOID)Destination, &Opaque);
        Address2 = MmDbgReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }
        *(PCHAR)Address1 = *(PCHAR)Address2;
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;

        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    if (Address1 != NULL) {
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;
    }

    return ActualLength - Length;
}

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine does the exact same thing as RtlMoveMemory, BUT it is
    private to the debugger.  This allows folks to set breakpoints and
    watch points in RtlMoveMemory without risk of recursive debugger
    entry and the accompanying hang.

    N.B.  UNLIKE KdpMoveMemory, this routine does NOT check for accessability
      and may fault!  Use it ONLY in the debugger and ONLY where you
      could use RtlMoveMemory.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    None.

--*/
{
    while (Length > 0) {
        *Destination = *Source;
        Destination++;
        Source++;
        Length--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\kdcmsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcmsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

--*/

#include "kdp.h"

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

    Routine Description:

        This function optionaly calls KeQueryPerformanceCounter for
        the debugger.  If the trap had interrupts off, then no call
        to KeQueryPerformanceCounter is possible and a NULL is returned.

    Return Value:

        returns KeQueryPerformanceCounter if possible.
        otherwise 0
--*/
{

    if (!(TrapFrame->EFlags & EFLAGS_INTERRUPT_MASK)) {
        LARGE_INTEGER LargeIntegerZero;

        LargeIntegerZero.QuadPart = 0;
        return LargeIntegerZero;
    } else {
        return KeQueryPerformanceCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\kdcpuapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

    24-sep-90   bryanwi

        Port to the x86.

--*/

#include "kdp.h"
#define END_OF_CONTROL_SPACE

extern ULONG KdpCurrentSymbolStart, KdpCurrentSymbolEnd;
extern ULONG KdSpecialCalls[];
extern ULONG KdNumberOfSpecialCalls;

BOOLEAN
KdpIsSpecialCall (
    ULONG Pc,
    PCONTEXT ContextRecord,
    UCHAR opcode,
    UCHAR ModRM
    );

/**** KdpIsTryFinallyReturn - detect finally optimization
*
*  Input:
*       pc - program counter of instruction to check
*       ContextRecord - machine specific context
*
*  Output:
*       returns TRUE if this is a try-finally returning to the same
*       scope
***************************************************************************/


BOOLEAN
KdpIsTryFinallyReturn (
    ULONG Pc,
    PCONTEXT ContextRecord
    )
{
    ULONG retaddr;
    ULONG calldisp;
    UCHAR inst;

    //
    //  The complier generates code for a try-finally that involves having
    //  a ret instruction that does not match with a call instruction.
    //  This ret never returns a value (ie, it's a c3 return and not a
    //  c2).  It always returns into the current symbol scope.  It is never
    //  preceeded by a leave, which (hopefully) should differentiate it
    //  from recursive returns.  Check for this, and if we find it count
    //  it as *0* level change.
    //
    //  As an optimization, the compiler will often change:
    //      CALL
    //      RET
    //  into:
    //      JMP
    //  In either case, we figure out the return address.  It's the first 4 bytes
    //  on the stack.
    //

    KdpMoveMemory( (PCHAR)&retaddr, (PCHAR)ContextRecord->Esp, 4 );

//  DPRINT(( "Start %x return %x end %x\n", KdpCurrentSymbolStart, retaddr, KdpCurrentSymbolEnd ));

    if ( (KdpCurrentSymbolStart < retaddr) && (retaddr < KdpCurrentSymbolEnd) ) {

        //
        //  Well, things aren't this nice.  We may have transferred but not yet
        //  updated the start/end.  This case occurs in a call to a thunk.  We
        //  look to see if the instruction before the return address is a call.
        //  Gross and not 100% reliable.
        //

        KdpMoveMemory( (PCHAR)&inst, (PCHAR)retaddr - 5, 1 );
        KdpMoveMemory( (PCHAR)&calldisp, (PCHAR)retaddr - 4, 4 );

        if (inst == 0xe8 && calldisp + retaddr == Pc) {
//  DPRINT(( "call to thunk @ %x\n", Pc ));
            return FALSE;
        }

        //
        //  returning to the current function.  Either a finally
        //  or a recursive return.  Check for a leave.  This is not 100%
        //  reliable since we are betting on an instruction longer than a byte
        //  and not ending with 0xc9.
        //

        KdpMoveMemory( (PCHAR)&inst, (PCHAR)Pc-1, 1 );

        if ( inst != 0xc9 ) {
            // not a leave.  Assume a try-finally.
//  DPRINT(( "transfer at %x is try-finally\n", Pc ));
            return TRUE;
        }
    }

    //
    //  This appears to be a true RET instruction
    //

    return FALSE;
}

/**** KdpLevelChange - say how the instruction affects the call level
*
*  Input:
*       pc - program counter of instruction to check
*       ContextRecord - machine specific context
*       SpecialCall - pointer to returned boolean indicating if the
*           instruction is a transfer to a special routine
*
*  Output:
*       returns -1 for a level pop, 1 for a push and 0 if it is
*       unchanged.
*  NOTE: This function belongs in some other file.  I should move it.
***************************************************************************/


LONG
KdpLevelChange (
    ULONG Pc,
    PCONTEXT ContextRecord,
    PBOOLEAN SpecialCall
    )
{
    UCHAR membuf[2];
    ULONG Addr;

    KdpMoveMemory( (PCHAR)membuf, (PCHAR)Pc, 2 );

    switch (membuf[0]) {
    case 0xe8:  //  CALL direct w/32 bit displacement
        //
        //  For try/finally, the compiler may, in addition to the push/ret trick
        //  below, use a call to the finally thunk.  Since we treat a RET to
        //  within the same symbol scope as not changing levels, we will also
        //  treat such a call as not changing levels either
        //

        KdpMoveMemory( (PCHAR)&Addr, (PCHAR)Pc+1, 4 );
        Addr += Pc + 5;

        if ((KdpCurrentSymbolStart <= Addr) && (Addr < KdpCurrentSymbolEnd)) {
            *SpecialCall = FALSE;
            return 0;
        }


    case 0x9a:  //  CALL segmented 16:32

        *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );
        return 1;

    case 0xff:
        //
        //  This is a compound instruction.  Dispatch on operation
        //
        switch (membuf[1] & 0x38) {
        case 0x10:  //  CALL with mod r/m
            *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );
            return 1;
        case 0x20:  //  JMP with mod r/m
            *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );

            //
            //  If this is a try/finally, we'd like to treat it as call since the
            //  return inside the destination will bring us back to this context.
            //  However, if it is a jmp to a special routine, we must treat it
            //  as a no-level change operation since we won't see the special
            //  routines's return.
            //
            //  If it is not a try/finally, we'd like to treat it as a no-level
            //  change, unless again, it is a transfer to a special call which
            //  views this as a level up.
            //

            if (KdpIsTryFinallyReturn( Pc, ContextRecord )) {
                if (*SpecialCall) {
                    //
                    //  We won't see the return, so pretend it is just
                    //  inline code
                    //

                    return 0;

                } else {
                    //
                    //  The destinations return will bring us back to this
                    //  context
                    //

                    return 1;
                }
            } else if (*SpecialCall) {
                //
                //  We won't see the return but we are, indeed, doing one.
                //
                return -1;
            } else {
                return 0;
            }

        default:
            *SpecialCall = FALSE;
            return 0;
        }

    case 0xc3:  //  RET

        //
        //  If we are a try/finally ret, then we indicate that it is NOT a level
        //  change
        //

        if (KdpIsTryFinallyReturn( Pc, ContextRecord )) {
            *SpecialCall = FALSE;
            return 0;
        }

    case 0xc2:  //  RET  w/16 bit esp change
    case 0xca:  //  RETF w/16 bit esp change
    case 0xcb:  //  RETF
        *SpecialCall = FALSE;
        return -1;

    default:
        *SpecialCall = FALSE;
        return 0;
    }

} // KdpLevelChange

LONG
regValue(
    UCHAR reg,
    PCONTEXT ContextRecord
    )
{
    switch (reg) {
    case 0x0:
        return(ContextRecord->Eax);
        break;
    case 0x1:
        return(ContextRecord->Ecx);
        break;
    case 0x2:
        return(ContextRecord->Edx);
        break;
    case 0x3:
        return(ContextRecord->Ebx);
        break;
    case 0x4:
        return(ContextRecord->Esp);
        break;
    case 0x5:
        return(ContextRecord->Ebp);
        break;
    case 0x6:
        return(ContextRecord->Esi);
        break;
    case 0x7:
        return(ContextRecord->Edi);
        break;
    }

    return 0; // we should never get here.

}

BOOLEAN
KdpIsSpecialCall (
    ULONG Pc,
    PCONTEXT ContextRecord,
    UCHAR opcode,
    UCHAR modRM
    )

/*++

Routine Description:

    Check to see if the instruction at pc is a call to one of the
    SpecialCall routines.

Argument:

    Pc - program counter of instruction in question.

--*/
{
    UCHAR sib;
    USHORT twoBytes;
    ULONG callAddr;
    ULONG addrAddr;
    LONG offset;
    ULONG i;
    char d8;

    if ( opcode == 0xe8 ) {

        //
        // Signed offset from pc
        //

        KdpMoveMemory( (PCHAR)&offset, (PCHAR)Pc+1, 4 );

        callAddr = Pc + offset + 5; // +5 for instr len.

    } else if ( opcode == 0xff ) {

        if ( ((modRM & 0x38) != 0x10) && ((modRM & 0x38) != 0x20) ) {
            // not call or jump
            return FALSE;
        }
        if ( (modRM & 0x08) == 0x08 ) {
            // m16:16 or m16:32 -- we don't handle this
            return FALSE;
        }

        if ( (modRM & 0xc0) == 0xc0 ) {

            /* Direct register addressing */
            callAddr = regValue( (UCHAR)(modRM&0x7), ContextRecord );

        } else if ( (modRM & 0xc7) == 0x05 ) {
            //
            // Calls across dll boundaries involve a call into a jump table,
            // wherein the jump address is set to the real called routine at DLL
            // load time.  Check to see if we're calling such an instruction,
            // and if so, compute its target address and set callAddr there.
            //
            //  ff15 or ff25 -- call or jump indirect with disp32.  Get
            //  address of address
            //
            KdpMoveMemory( (PCHAR)&addrAddr, (PCHAR)Pc+2, 4 );

            //
            //  Get real destination address
            //
            KdpMoveMemory( (PCHAR)&callAddr, (PCHAR)addrAddr, 4 );
//  DPRINT(( "Indirect call/jmp @ %x\n", Pc ));
        } else if ( (modRM & 0x7) == 0x4 ) {

            LONG indexValue;

            /* sib byte present */
            KdpMoveMemory( (PCHAR)&sib, (PCHAR)Pc+2, 1 );
            indexValue = regValue( (UCHAR)((sib & 0x31) >> 3), ContextRecord );
            switch ( sib&0xc0 ) {
            case 0x0:  /* x1 */
                break;
            case 0x40:
                indexValue *= 2;
                break;
            case 0x80:
                indexValue *= 4;
                break;
            case 0xc0:
                indexValue *= 8;
                break;
            } /* switch */

            switch ( modRM & 0xc0 ) {

            case 0x0: /* no displacement */
                if ( (sib & 0x7) == 0x5 ) {
//                  DPRINT(("funny call #1 at %x\n", Pc));
                    return FALSE;
                }
                callAddr = indexValue + regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0x40:
                if ( (sib & 0x6) == 0x4 ) {
//                  DPRINT(("Funny call #2\n")); /* calling into the stack */
                    return FALSE;
                }
                KdpMoveMemory( &d8, (PCHAR)Pc+3,1 );
                callAddr = indexValue + d8 +
                                    regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0x80:
                if ( (sib & 0x6) == 0x4 ) {
//                  DPRINT(("Funny call #3\n")); /* calling into the stack */
                    return FALSE;
                }
                KdpMoveMemory( (PCHAR)&offset, (PCHAR)Pc+3, 4 );
                callAddr = indexValue + offset +
                                    regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0xc0:
                ASSERT( FALSE );
                break;

            }

        } else {
            //KdPrint(( "undecoded call at %x\n",
            //            CONTEXT_TO_PROGRAM_COUNTER(ContextRecord) ));
            return FALSE;
        }

    } else if ( opcode == 0x9a ) {

        /* Absolute address call (best I can tell, cc doesn't generate this) */
        KdpMoveMemory( (PCHAR)&callAddr, (PCHAR)Pc+1, 4 );

    } else {
        return FALSE;
    }

    //
    // Calls across dll boundaries involve a call into a jump table,
    // wherein the jump address is set to the real called routine at DLL
    // load time.  Check to see if we're calling such an instruction,
    // and if so, compute its target address and set callAddr there.
    //

#if 0
    KdpMoveMemory( (PCHAR)&twoBytes, (PCHAR)callAddr, 2 );
    if ( twoBytes == 0x25ff ) { /* i386 is little-Endian; really 0xff25 */

        //
        // This is a 'jmp dword ptr [mem]' instruction, which is the sort of
        // jump used for a dll-boundary crossing call.  Fixup callAddr.
        //

        KdpMoveMemory( (PCHAR)&addrAddr, (PCHAR)callAddr+2, 4 );
        KdpMoveMemory( (PCHAR)&callAddr, (PCHAR)addrAddr, 4 );
    }
#endif

    for ( i = 0; i < KdNumberOfSpecialCalls; i++ ) {
        if ( KdSpecialCalls[i] == callAddr ) {
            return TRUE;
        }
    }
    return FALSE;

}

VOID
KdpSetLoadState(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record for the load symbol case.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    ULONG Count;
    PVOID End;

    //
    // Store the special x86 register into the control report structure.
    //

    WaitStateChange->ControlReport.Dr6 = KdProcessorState.SpecialRegisters.KernelDr6;
    WaitStateChange->ControlReport.Dr7 = KdProcessorState.SpecialRegisters.KernelDr7;

    //
    // Copy the immediate instruction stream into the control report structure.
    //

    Count = KdpMoveMemory((PCHAR)(&(WaitStateChange->ControlReport.InstructionStream[0])),
                          (PCHAR)(WaitStateChange->ProgramCounter),
                          DBGKD_MAXSTREAM);

    WaitStateChange->ControlReport.InstructionCount = (USHORT)Count;

    //
    // Clear breakpoints in the copied instruction stream. If any breakpoints
    // are cleared, then recopy the instruction stream.
    //

    End = (PVOID)((PUCHAR)(WaitStateChange->ProgramCounter) + Count - 1);
    if (KdpDeleteBreakpointRange((PVOID)WaitStateChange->ProgramCounter, End) != FALSE) {
        KdpMoveMemory(&WaitStateChange->ControlReport.InstructionStream[0],
                      (PVOID)WaitStateChange->ProgramCounter,
                      Count);
    }

    //
    // Store the segment registers into the control report structure and set the
    // control flags.
    //

    WaitStateChange->ControlReport.SegCs = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegEs = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegFs = KGDT_R0_PCR;
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;
    WaitStateChange->ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;

    //
    //  Copy context record into wait state change structure.
    //

    KdpMoveMemory((PCHAR)(&WaitStateChange->Context),
                  (PCHAR)ContextRecord,
                  sizeof(*ContextRecord));

    return;
}

VOID
KdpSetStateChange(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    None.

--*/

{
    BOOLEAN status;

    //
    //  Set up description of event, including exception record
    //

    WaitStateChange->NewState = DbgKdExceptionStateChange;
    WaitStateChange->ProcessorLevel = 6;
    WaitStateChange->Processor = (USHORT)0;
    WaitStateChange->NumberProcessors = (ULONG)1;
    WaitStateChange->Thread = (ULONG64)(LONG64)(LONG_PTR) KeGetCurrentThread();
    WaitStateChange->ProgramCounter = (ULONG64)(LONG64)(LONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    if (sizeof(EXCEPTION_RECORD) == sizeof(WaitStateChange->u.Exception.ExceptionRecord)) {
        KdpQuickMoveMemory((PCHAR)&WaitStateChange->u.Exception.ExceptionRecord,
                           (PCHAR)ExceptionRecord,
                           sizeof(EXCEPTION_RECORD));
    } else {
        ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
                              &WaitStateChange->u.Exception.ExceptionRecord
                              );
    }
    WaitStateChange->u.Exception.FirstChance = !SecondChance;

    //
    //  Copy instruction stream immediately following location of event
    //

    WaitStateChange->ControlReport.InstructionCount =
        (USHORT)KdpMoveMemory(
            (PCHAR)(&(WaitStateChange->ControlReport.InstructionStream[0])),
            (PCHAR)(WaitStateChange->ProgramCounter),
            DBGKD_MAXSTREAM
            );

    //
    //  Copy context record immediately following instruction stream
    //

    KdpMoveMemory(
        (PCHAR)(&WaitStateChange->Context),
        (PCHAR)ContextRecord,
        sizeof(*ContextRecord)
        );

    //
    //  Clear breakpoints in copied area
    //

    status = KdpDeleteBreakpointRange(
        (PVOID)WaitStateChange->ProgramCounter,
        (PVOID)((PUCHAR)WaitStateChange->ProgramCounter +
            WaitStateChange->ControlReport.InstructionCount - 1)
        );

    //
    //  If there were any breakpoints cleared, recopy the area without them
    //

    if (status == TRUE) {
        KdpMoveMemory(
            (PUCHAR) &(WaitStateChange->ControlReport.InstructionStream[0]),
            (PUCHAR) WaitStateChange->ProgramCounter,
            WaitStateChange->ControlReport.InstructionCount
            );
    }

    //
    //  Special registers for the x86
    //

    WaitStateChange->ControlReport.Dr6 =
        KdProcessorState.SpecialRegisters.KernelDr6;

    WaitStateChange->ControlReport.Dr7 =
        KdProcessorState.SpecialRegisters.KernelDr7;

    WaitStateChange->ControlReport.SegCs  = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs  = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegEs  = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegFs  = KGDT_R0_PCR;
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;

    WaitStateChange->ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;

}

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    Extract continuation control data from Manipulate_State message

Arguments:

    ManipulateState - supplies pointer to Manipulate_State packet

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) == TRUE) {

        //
        // If NT_SUCCESS returns TRUE, then the debugger is doing a
        // continue, and it makes sense to apply control changes.
        // Otherwise the debugger is saying that it doesn't know what
        // to do with this exception, so control values are ignored.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag == TRUE) {
            ContextRecord->EFlags |= 0x100L;

        } else {
            ContextRecord->EFlags &= ~0x100L;

        }

        KdProcessorState.SpecialRegisters.KernelDr7 =
            ManipulateState->u.Continue2.ControlSet.Dr7;
        KdProcessorState.SpecialRegisters.KernelDr6 = 0L;

        if (ManipulateState->u.Continue2.ControlSet.CurrentSymbolStart != 1) {
            KdpCurrentSymbolStart = ManipulateState->u.Continue2.ControlSet.CurrentSymbolStart;
            KdpCurrentSymbolEnd = ManipulateState->u.Continue2.ControlSet.CurrentSymbolEnd;
        }
    }
}

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a read control space state
    manipulation message.  Its function is to read implementation
    specific system data.

    IMPLEMENTATION NOTE:

        On the X86, control space is defined as follows:

            0:  Base of KPROCESSOR_STATE structure. (KPRCB.ProcessorState)
                    This includes CONTEXT record,
                    followed by a SPECIAL_REGISTERs record

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    STRING MessageHeader;
    ULONG Length, t;
    PVOID StartAddr;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }
    if ((a->TargetBaseAddress < (ULONG64)(sizeof(KdProcessorState))) &&
        (m->Processor < (USHORT)1)) {
        t = (ULONG)(sizeof(KdProcessorState)) - (ULONG)(a->TargetBaseAddress);
        if (t < Length) {
            Length = t;
        }
        StartAddr = (PVOID)((ULONG)a->TargetBaseAddress +
                            (ULONG)&KdProcessorState);
        AdditionalData->Length = (USHORT)KdpMoveMemory(
                                    AdditionalData->Buffer,
                                    StartAddr,
                                    Length
                                    );

        if (Length == AdditionalData->Length) {
            m->ReturnStatus = STATUS_SUCCESS;
        } else {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
        a->ActualBytesRead = AdditionalData->Length;

    } else {
        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesRead = 0;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData
        );
}

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write control space state
    manipulation message.  Its function is to write implementation
    specific system data.

    Control space for x86 is as defined above.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID StartAddr;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    if ((((PUCHAR)a->TargetBaseAddress + a->TransferCount) <=
        (PUCHAR)(sizeof(KdProcessorState))) && (m->Processor < (USHORT)1)) {

        StartAddr = (PVOID)((ULONG)a->TargetBaseAddress +
                            (ULONG)&KdProcessorState);

        Length = KdpMoveMemory(
                            StartAddr,
                            AdditionalData->Buffer,
                            AdditionalData->Length
                            );

        if (Length == AdditionalData->Length) {
            m->ReturnStatus = STATUS_SUCCESS;
        } else {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
        a->ActualBytesWritten = Length;

    } else {
        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesWritten = 0;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData
        );
}

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a read io space state
    manipulation message.  Its function is to read system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    //
    // Check Size and Alignment
    //

    switch ( a->DataSize ) {
        case 1:
            a->DataValue = (ULONG)(UCHAR)_inp((PUCHAR)a->IoAddress);
            break;
        case 2:
            if ((ULONG)a->IoAddress & 1 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                a->DataValue = (ULONG)(USHORT)_inpw((PUSHORT)a->IoAddress);
            }
            break;
        case 4:
            if ((ULONG)a->IoAddress & 3 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                a->DataValue = _inpd((PULONG)a->IoAddress);
            }
            break;
        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write io space state
    manipulation message.  Its function is to write to system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    //
    // Check Size and Alignment
    //

    switch ( a->DataSize ) {
        case 1:
            _outp((PUCHAR)a->IoAddress, (UCHAR)a->DataValue);
            break;
        case 2:
            if ((ULONG)a->IoAddress & 1 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                _outpw((PUSHORT)a->IoAddress, (USHORT)a->DataValue);
            }
            break;
        case 4:
            if ((ULONG)a->IoAddress & 3 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                _outpd((PULONG)a->IoAddress, a->DataValue);
            }
            break;
        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a read MSR
    manipulation message.  Its function is to read the MSR.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    LARGE_INTEGER l;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    try {
        l.QuadPart = RDMSR(a->Msr);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        l.QuadPart = 0;
        m->ReturnStatus = STATUS_NO_SUCH_DEVICE;
    }

    a->DataValueLow  = l.LowPart;
    a->DataValueHigh = l.HighPart;

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write of a MSR
    manipulation message.  Its function is to write to the MSR

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    LARGE_INTEGER l;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    l.HighPart = a->DataValueHigh;
    l.LowPart = a->DataValueLow;

    try {
        WRMSR (a->Msr, l.QuadPart);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        m->ReturnStatus = STATUS_NO_SUCH_DEVICE;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

/*
 * Find the return address of the current function.  Only works when
 * locals haven't yet been pushed (ie, on the first instruction of the
 * function).
 */

ULONG
KdpGetReturnAddress (
    PCONTEXT ContextRecord
    )
{
    ULONG retaddr;

    KdpMoveMemory((PCHAR)(&retaddr), (PCHAR)(ContextRecord->Esp), 4 );
    return retaddr;

} // KdpGetReturnAddress

/*** KdpGetCallNextOffset - compute "next" instruction on a call-like instruction
*
*   Purpose:
*       Compute how many bytes are in a call-type instruction
*       so that a breakpoint can be set upon this instruction's
*       return.  Treat indirect jmps as if they were call/ret/ret
*
*   Returns:
*       offset to "next" instruction, or 0 if it wasn't a call instruction.
*
*************************************************************************/

ULONG
KdpGetCallNextOffset (
    ULONG Pc,
    PCONTEXT ContextRecord
    )
{
    UCHAR membuf[2];
    UCHAR opcode;
    ULONG sib;
    ULONG disp;

    KdpMoveMemory( membuf, (PVOID)Pc, 2 );
    opcode = membuf[0];

    if ( opcode == 0xe8 ) {         //  CALL 32 bit disp
        return Pc+5;
    } else if ( opcode == 0x9a ) {  //  CALL 16:32
        return Pc+7;
    } else if ( opcode == 0xff ) {
        if ( membuf[1] == 0x25) {   //  JMP indirect
            return KdpGetReturnAddress( ContextRecord );
        }
        sib = ((membuf[1] & 0x07) == 0x04) ? 1 : 0;
        disp = (membuf[1] & 0xc0) >> 6;
        switch (disp) {
        case 0:
            if ( (membuf[1] & 0x07) == 0x05 ) {
                disp = 4; // disp32 alone
            } else {
                // disp = 0; // no displacement with reg or sib
            }
            break;
        case 1:
            // disp = 1; // disp8 with reg or sib
            break;
        case 2:
            disp = 4; // disp32 with reg or sib
            break;
        case 3:
            disp = 0; // direct register addressing (e.g., call esi)
            break;
        }
        return Pc + 2 + sib + disp;
    }

    return 0;

} // KdpGetCallNextOffset
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\ixkdcom.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.h

Abstract:

    This module contains the header file for a very simple com port package.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 19-Jul-1991
        Moved into HAL
--*/

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8
#define COM3_PORT   0x03e8
#define COM4_PORT   0x02e8

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_56000    56000
#define BD_57600    57600

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01


//
// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
//
#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//
#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//
#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//
#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//
#define SERIAL_MSR_DCD      0x80

#define SERIAL_LSR_NOT_PRESENT  0xff

typedef struct _CPPORT {
    PUCHAR  Address;
    ULONG  Baud;
    USHORT  Flags;
    TIME_FIELDS     CarrierLostTime;
//    ULONG   LockVar;
//    KSPIN_LOCK Lock;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default

VOID
CpInitialize (
    PCPPORT  Port,
    PUCHAR  Address,
    ULONG Rate
    );

VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG  Rate
    );

USHORT
CpQueryBaud (
    PCPPORT  Port
    );

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    );

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR  Byte,
    BOOLEAN WaitForData
    );

VOID
CpLockPort (
    PCPPORT Port
    );

VOID
CpUnlockPort (
    PCPPORT Port
    );

VOID
CpStallExecution (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\procstat.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    procstat.asm
;
; Abstract:
;
;    This module implements procedures for saving and restoring
;    processor control state, and processor run&control state.
;    These procedures support debugging of UP and MP systems.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 30-Aug-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.586p
        .xlist
include ks386.inc
include callconv.inc
        .list

        page ,132
KDCODE  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page    ,132
        subttl  "Save Processor Control State"
;++
;
; KdpSaveProcessorControlState(
;       PX86_NT5_KPROCESSOR_STATE   ProcessorState
;       );
;
; Routine Description:
;
;    This routine saves the control subset of the processor state.
;    (Saves the same information as KdpSaveProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT saved.)
;    Called by the debug subsystem, and KdpSaveProcessorState()
;
;   N.B.  This procedure will save Dr7, and then 0 it.  This prevents
;         recursive hardware trace breakpoints and allows debuggers
;         to work.
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KdpSaveProcessorControlState   ,1

        mov     edx, [esp+4]                    ; ProcessorState

;
; Save special registers for debugger
;
        xor     ecx,ecx

        mov     eax, cr0
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr0, eax
        mov     eax, cr2
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr2, eax
        mov     eax, cr3
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr3, eax
        mov     eax, cr4
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr4, eax

        mov     eax,dr0
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr0,eax
        mov     eax,dr1
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr1,eax
        mov     eax,dr2
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr2,eax
        mov     eax,dr3
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr3,eax
        mov     eax,dr6
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr6,eax

        mov     eax,dr7
        mov     dr7,ecx
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr7,eax

        sgdt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Gdtr
        sidt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Idtr

        str     word ptr [edx].PsNT5SpecialRegisters.SrNT5Tr
        sldt    word ptr [edx].PsNT5SpecialRegisters.SrNT5Ldtr

        stdRET    _KdpSaveProcessorControlState

stdENDP _KdpSaveProcessorControlState

        page    ,132
        subttl  "Restore Processor Control State"
;++
;
; KdpRestoreProcessorControlState(
;       PX86_NT5_KPROCESSOR_STATE   ProcessorState
;       );
;
; Routine Description:
;
;    This routine restores the control subset of the processor state.
;    (Restores the same information as KdpRestoreProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT restored.)
;    Called by the debug subsystem, and KdpRestoreProcessorState()
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KdpRestoreProcessorControlState,1

        mov     edx, [esp+4]                    ; (edx)->ProcessorState

;
; Restore special registers for debugger
;

        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr0
        mov     cr0, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr2
        mov     cr2, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr3
        mov     cr3, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr4
        mov     cr4, eax

        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr0
        mov     dr0, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr1
        mov     dr1, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr2
        mov     dr2, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr3
        mov     dr3, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr6
        mov     dr6, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr7
        mov     dr7, eax

        lgdt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Gdtr
        lidt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Idtr

;
; Force the TSS descriptor into a non-busy state, so we don't fault
; when we load the TR.
;

        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Gdtr+2  ; (eax)->GDT base
        xor     ecx, ecx
        mov     cx,  word ptr [edx].PsNT5SpecialRegisters.SrNT5Tr
        add     eax, 5
        add     eax, ecx                                ; (eax)->TSS Desc. Byte
        and     byte ptr [eax],NOT 2
        ltr     word ptr [edx].PsNT5SpecialRegisters.SrNT5Tr

        lldt    word ptr [edx].PsNT5SpecialRegisters.SrNT5Ldtr

        stdRET    _KdpRestoreProcessorControlState

stdENDP _KdpRestoreProcessorControlState

KDCODE  ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kdlite\kdlitep.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    kdlitep.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the Xbox lite kernel debugger.

--*/

#ifndef _KDLITEP_
#define _KDLITEP_

#include <ntos.h>
#include "ki.h"

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

//
// Define the base address of the serial port.
//

#define KDLITE_DEBUG_BASE_ADDRESS   0x3F8

//
// Define the baud rate for transmission over the serial port.
//

#define KDLITE_DEBUG_BAUD_RATE      19200

//
// Define various constants related to the serial port.
//

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// External symbols.
//

extern PKDEBUG_ROUTINE KiDebugRoutine;

#endif  // KDLITEP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\kdtrap.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdtrap.c

Abstract:

    This module contains code to implement the target side of the portable
    kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 25-Sep-90

Revision History:

--*/

#include "kdp.h"

VOID
KdpContextToNt5Context(
    IN PCONTEXT Context,
    OUT PX86_NT5_CONTEXT Nt5Context
    );

VOID
KdpContextFromNt5Context(
    OUT PCONTEXT Context,
    IN PX86_NT5_CONTEXT Nt5Context
    );

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    BOOLEAN Enable;
    BOOLEAN UnloadSymbols = FALSE;
    ULONG   RetValue;
    STRING  String, AssertString, ReplyString;
    PUCHAR  Buffer;
    PKD_SYMBOLS_INFO SymbolInfo;
    PVOID   SavedEsp;
    ULONG   OldEip;
	char	AssertBuffer[2];

    _asm {
        //
        // Save esp on ebp frame so c-runtime registers are restored correctly
        //

        mov     SavedEsp, esp
    }

    //
    // Print, Prompt, Load symbols, Unload symbols, are all special
    // cases of STATUS_BREAKPOINT
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // We have one of the support functions.
        //

        if (KdDebuggerNotPresent  &&
            ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_PROMPT &&
            ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_RTLASSERT &&
            ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_RIP) {
            ContextRecord->Eip++;
            return(TRUE);
        }


        //
        // Since some of these functions can be entered from user mode,
        // we hold off entering the debugger until the user mode buffers
        // are copied.  (Because they may not be present in memory, and
        // they must be paged in before we raise Irql to the
        // Highest level.)
        //
        //

        OldEip = ContextRecord->Eip;

        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            //  ExceptionInformation[1] is PSTRING to print
            //

            case BREAKPOINT_KDPRINT:
            case BREAKPOINT_PRINT:
                String = *((PSTRING)ExceptionRecord->ExceptionInformation[1]);

                KdLogDbgPrint(&String);

                if ((KdGlobalFlag & FLG_DISABLE_DBGPRINT) == 0) {
                    Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
                    if (KdpPrintString(&String)) {
                        ContextRecord->Eax = (ULONG)(STATUS_BREAKPOINT);
                    } else {
                        ContextRecord->Eax = STATUS_SUCCESS;
                    }
                    KdExitDebugger(Enable);
                }

                Completion = TRUE;
                break;

			//
			// ExceptionInformation[1] is the string to print as the assert
			//   message
			//

            case BREAKPOINT_RTLASSERT:
                String = *((PSTRING)ExceptionRecord->ExceptionInformation[1]);
				RtlInitAnsiString(&AssertString,
					"Break, Ignore, or Terminate Thread (bit)? ");
				ReplyString.Buffer = AssertBuffer;
				ReplyString.MaximumLength = 2;

				Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
				KdpPrintString(&String);
				do {
					RetValue = KdpPromptString(&AssertString, &ReplyString);
				} while (RetValue == TRUE);

				ContextRecord->Eax = AssertBuffer[0];
				KdExitDebugger(Enable);

                Completion = TRUE;
                break;

			//
			// ExceptionInformation[1] is the null-terminated string to
			// send
			//

			case BREAKPOINT_RIP:
				{
				char szRipText[] = "\n***RIP: ";
				char szNL[] = "\n";

				String.Buffer = szRipText;
				String.Length = sizeof szRipText - 1;
				String.MaximumLength = sizeof szRipText;
				KdpPrintString(&String);

				String.Buffer = (LPSTR)ExceptionRecord->ExceptionInformation[1];
				String.Length = (USHORT)strlen(String.Buffer);
				String.MaximumLength = String.Length + 1;
				KdpPrintString(&String);

				String.Buffer = szNL;
				String.Length = 1;
				String.MaximumLength = 2;
				KdpPrintString(&String);

				// now we stop as if at a breakpoint
	            Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
				goto RipBreak;
				}

            //
            //  ExceptionInformation[1] is prompt string,
            //  ExceptionInformation[2] is return string
            //

            case BREAKPOINT_PROMPT:
                String = *((PSTRING)ExceptionRecord->ExceptionInformation[1]);
                ReplyString = *((PSTRING)ExceptionRecord->ExceptionInformation[2]);

                //
                // Prompt, keep prompting until no breakin seen.
                //

                KdLogDbgPrint(&String);

                Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
                do {
                    RetValue = KdpPromptString(&String, &ReplyString);
                } while (RetValue == TRUE);

                ContextRecord->Eax = ReplyString.Length;
                KdExitDebugger(Enable);

                Completion = TRUE;
                break;

            //
            //  ExceptionInformation[1] is file name of new module
            //  ExceptionInformaiton[2] is the base of the dll
            //

            case BREAKPOINT_UNLOAD_SYMBOLS:
                UnloadSymbols = TRUE;

                //
                // Fall through
                //

            case BREAKPOINT_LOAD_SYMBOLS:

                Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

                //
                // Save and restore the processor context in case the
                // kernel debugger has been configured to stop on dll
                // loads.
                //

                KdpSaveProcessorControlState(&KdProcessorState);
                KdpContextToNt5Context(ContextRecord, &KdProcessorState.ContextFrame);

                SymbolInfo = (PKD_SYMBOLS_INFO)ExceptionRecord->ExceptionInformation[2];
                Completion =
                    KdpReportLoadSymbolsStateChange((PSTRING)ExceptionRecord->ExceptionInformation[1],
                                                    SymbolInfo,
                                                    UnloadSymbols,
                                                    &KdProcessorState.ContextFrame);

                KdpContextFromNt5Context(ContextRecord, &KdProcessorState.ContextFrame);
                KdpRestoreProcessorControlState(&KdProcessorState);

                KdExitDebugger(Enable);
                break;

            case BREAKPOINT_LOAD_XESECTION:
            case BREAKPOINT_UNLOAD_XESECTION:
            case BREAKPOINT_CREATE_FIBER:
            case BREAKPOINT_DELETE_FIBER:
                // we don't actually pay attention to these
                Completion = TRUE;
                break;

            //
            //  Unknown command
            //

            default:
                // return FALSE
                break;
        }
        //
        // If the kernel debugger did not update the EIP, then increment
        // past the breakpoint instruction.
        //

        if (ContextRecord->Eip == OldEip) {
            ContextRecord->Eip++;
        }


    } else {

        if  ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) ||
             (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)  ||
             (KdGlobalFlag & FLG_STOP_ON_EXCEPTION) ||
             SecondChance) {

            if (!SecondChance &&
                (ExceptionRecord->ExceptionCode == STATUS_PORT_DISCONNECTED ||
                 NT_SUCCESS( ExceptionRecord->ExceptionCode )
                )
               ) {
                //
                // User does not really want to see these either.
                // so do NOT report it to debugger.
                //

                return FALSE;
                }

            //
            // Report state change to kernel debugger on host
            //

            Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

            Completion = KdpCheckTracePoint(ExceptionRecord,ContextRecord);
            if (!Completion) {

RipBreak:
                KdpSaveProcessorControlState(&KdProcessorState);
                KdpContextToNt5Context(ContextRecord, &KdProcessorState.ContextFrame);

                Completion =
                    KdpReportExceptionStateChange(ExceptionRecord,
                                                  &KdProcessorState.ContextFrame,
                                                  SecondChance);

                KdpContextFromNt5Context(ContextRecord, &KdProcessorState.ContextFrame);
                KdpRestoreProcessorControlState(&KdProcessorState);
            }

            KdExitDebugger(Enable);

            KdpControlCPressed = FALSE;

        } else {

            //
            // This is real exception that user doesn't want to see,
            // so do NOT report it to debugger.
            //

            // return FALSE;
        }
    }

    _asm {
        mov     esp, SavedEsp
    }
    return Completion;
}

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints in a checked system when the kernel debugger is not active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{
    PULONG  SymbolArgs;
    //
    // If the breakpoint is a debug print, then return TRUE. Otherwise,
    // return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_KDPRINT)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {

        ContextRecord->Eip++;
        return(TRUE);
    } else if (KdDebuggerEnabled == FALSE) {
        return(FALSE);
    } else {
        return(KdpCheckTracePoint(ExceptionRecord,ContextRecord));
    }
}

#define NUMBER_OF_FP_REGISTERS  8
#define BYTES_PER_FP_REGISTER   10
#define BYTES_PER_FX_REGISTER   16

VOID
KdpContextToNt5Context(
    IN PCONTEXT Context,
    OUT PX86_NT5_CONTEXT Nt5Context
    )
{
    ULONG i;

    Nt5Context->ContextFlags = Context->ContextFlags;

    //
    // CONTEXT_CONTROL
    //

    Nt5Context->Ebp = Context->Ebp;
    Nt5Context->Eip = Context->Eip;
    Nt5Context->SegCs = Context->SegCs;
    Nt5Context->EFlags = Context->EFlags;
    Nt5Context->Esp = Context->Esp;
    Nt5Context->SegSs = Context->SegSs;

    //
    // CONTEXT_SEGMENTS
    //

    Nt5Context->SegGs = 0;
    Nt5Context->SegFs = KGDT_R0_PCR;
    Nt5Context->SegEs = KGDT_R0_DATA;
    Nt5Context->SegDs = KGDT_R0_DATA;

    //
    // CONTEXT_INTEGER
    //

    Nt5Context->Edi = Context->Edi;
    Nt5Context->Esi = Context->Esi;
    Nt5Context->Ebx = Context->Ebx;
    Nt5Context->Edx = Context->Edx;
    Nt5Context->Ecx = Context->Ecx;
    Nt5Context->Eax = Context->Eax;

    //
    // CONTEXT_EXTENDED_REGISTERS
    //

    RtlCopyMemory(Nt5Context->ExtendedRegisters, &Context->FloatSave,
        MAXIMUM_SUPPORTED_EXTENSION);

    //
    // CONTEXT_FLOATING_POINT
    //

    Nt5Context->FloatSave.ControlWord = (USHORT)Context->FloatSave.ControlWord;
    Nt5Context->FloatSave.StatusWord = (USHORT)Context->FloatSave.StatusWord;
    Nt5Context->FloatSave.TagWord = (USHORT)Context->FloatSave.TagWord;
    Nt5Context->FloatSave.ErrorOffset = Context->FloatSave.ErrorOffset;
    Nt5Context->FloatSave.ErrorSelector = Context->FloatSave.ErrorSelector;
    Nt5Context->FloatSave.DataOffset = Context->FloatSave.DataOffset;
    Nt5Context->FloatSave.DataSelector = Context->FloatSave.DataSelector;
    Nt5Context->FloatSave.Cr0NpxState = Context->FloatSave.Cr0NpxState;

    for (i = 0; i < NUMBER_OF_FP_REGISTERS; i++) {
        RtlCopyMemory(&Nt5Context->FloatSave.RegisterArea[i*BYTES_PER_FP_REGISTER],
            &Context->FloatSave.RegisterArea[i*BYTES_PER_FX_REGISTER],
            BYTES_PER_FP_REGISTER);
    }
}

VOID
KdpContextFromNt5Context(
    OUT PCONTEXT Context,
    IN PX86_NT5_CONTEXT Nt5Context
    )
{
    ULONG i;

    Context->ContextFlags = Nt5Context->ContextFlags;

    //
    // CONTEXT_CONTROL
    //

    Context->Ebp = Nt5Context->Ebp;
    Context->Eip = Nt5Context->Eip;
    Context->SegCs = Nt5Context->SegCs;
    Context->EFlags = Nt5Context->EFlags;
    Context->Esp = Nt5Context->Esp;
    Context->SegSs = Nt5Context->SegSs;

    //
    // CONTEXT_INTEGER
    //

    Context->Edi = Nt5Context->Edi;
    Context->Esi = Nt5Context->Esi;
    Context->Ebx = Nt5Context->Ebx;
    Context->Edx = Nt5Context->Edx;
    Context->Ecx = Nt5Context->Ecx;
    Context->Eax = Nt5Context->Eax;

    //
    // CONTEXT_EXTENDED_REGISTERS
    //

    RtlCopyMemory(&Context->FloatSave, Nt5Context->ExtendedRegisters,
        MAXIMUM_SUPPORTED_EXTENSION);

    //
    // CONTEXT_FLOATING_POINT
    //

    Context->FloatSave.ControlWord = (USHORT)Nt5Context->FloatSave.ControlWord;
    Context->FloatSave.StatusWord = (USHORT)Nt5Context->FloatSave.StatusWord;
    Context->FloatSave.TagWord = (USHORT)Nt5Context->FloatSave.TagWord;
    Context->FloatSave.ErrorOffset = Nt5Context->FloatSave.ErrorOffset;
    Context->FloatSave.ErrorSelector = Nt5Context->FloatSave.ErrorSelector;
    Context->FloatSave.DataOffset = Nt5Context->FloatSave.DataOffset;
    Context->FloatSave.DataSelector = Nt5Context->FloatSave.DataSelector;
    Context->FloatSave.Cr0NpxState = Nt5Context->FloatSave.Cr0NpxState;

    for (i = 0; i < NUMBER_OF_FP_REGISTERS; i++) {
        RtlCopyMemory(&Context->FloatSave.RegisterArea[i*BYTES_PER_FX_REGISTER],
            &Nt5Context->FloatSave.RegisterArea[i*BYTES_PER_FP_REGISTER],
            BYTES_PER_FP_REGISTER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kd64\i386\xxkdsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xxkdsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

    John Vert (jvert) 11-Jul-1991
        Moved from KD/i386 to HAL

--*/

#include "kdp.h"
#include "ixkdcom.h"

//
// This MUST be initialized to zero so we know not to do anything when
// CpGetByte is called when the kernel debugger is disabled.
//

CPPORT KdPort = {NULL, 0, PORT_DEFAULTRATE };

//
// Remember the debugger port information
//

CPPORT KdPortInformation = {NULL, 0, PORT_DEFAULTRATE};

BOOLEAN
KdPortInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    BOOLEAN Initialize
    )

/*++

Routine Description:

    This procedure checks for which COM port should be used by kernel
    debugger.  If DebugParameter specifies a COM port, we will use it
    even if we can not find it (we trust user).  Otherwise, if COM2
    is present and there is no mouse attaching to it, we use COM2.
    If COM2 is not availabe, we check COM1.  If both COM1 and COM2 are
    not present, we give up and return false.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    Initialize - Specifies a boolean value that determines whether the
        debug port is initialized or just the debug port parameters
        are captured.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    ULONG i;
    ULONG BaudRate = 115200;
    PUCHAR PortAddress = (PUCHAR)COM1_PORT;

    //
    // Check if Port and baudrate have been determined.
    //

    if (KdPortInformation.Address == NULL) {

        //
        // Initialize the port structure.
        //

        KdPortInformation.Address = PortAddress;
        KdPortInformation.Baud = BaudRate;
    }

    if (Initialize == TRUE) {
        CpInitialize(&KdPort,
                     KdPortInformation.Address,
                     KdPortInformation.Baud
                     );
    }
    return(TRUE);
}

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&KdPort, Input, TRUE);
}

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&KdPort, Input, FALSE);
}

VOID
KdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the debug port.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    CpPutByte(&KdPort, Output);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\apcobj.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    apcobj.c

Abstract:

    This module implements the kernel APC object. Functions are provided
    to initialize, flush, insert, and remove APC objects.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input apc is
// really a kapc and not something else, like deallocated pool.
//

#define ASSERT_APC(E) {             \
    ASSERT((E)->Type == ApcObject); \
}


VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ApcMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    )

/*++

Routine Description:

    This function initializes a kernel APC object. The thread, kernel
    routine, and optionally a normal routine, processor mode, and normal
    context parameter are stored in the APC object.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelRoutine - Supplies a pointer to a function that is to be
        executed at IRQL APC_LEVEL in kernel mode.

    RundownRoutine - Supplies an optional pointer to a function that is to be
        called if the APC is in a thread's APC queue when the thread terminates.

    NormalRoutine - Supplies an optional pointer to a function that is
        to be executed at IRQL 0 in the specified processor mode. If this
        parameter is not specified, then the ProcessorMode and NormalContext
        parameters are ignored.

    ApcMode - Supplies the processor mode in which the function specified
        by the NormalRoutine parameter is to be executed.

    NormalContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the NormalRoutine parameter.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    Apc->Type = ApcObject;

    //
    // Initialize the APC environment, thread address, kernel routine address,
    // rundown routine address, normal routine address, processor mode, and
    // normal context parameter. If the normal routine address is null, then
    // the processor mode is defaulted to KernelMode and the APC is a special
    // APC. Otherwise, the processor mode is taken from the argument list.
    //

    Apc->Thread = Thread;
    Apc->KernelRoutine = KernelRoutine;
    Apc->RundownRoutine = RundownRoutine;
    Apc->NormalRoutine = NormalRoutine;
    if (ARGUMENT_PRESENT(NormalRoutine)) {
        Apc->ApcMode = ApcMode;
        Apc->NormalContext = NormalContext;

    } else {
        Apc->ApcMode = KernelMode;
        Apc->NormalContext = NIL;
    }

    Apc->Inserted = FALSE;
    return;
}

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ApcMode
    )

/*++

Routine Description:

    This function flushes the APC queue selected by the specified processor
    mode for the specified thread. An APC queue is flushed by removing the
    listhead from the list, scanning the APC entries in the list, setting
    their inserted variables to FALSE, and then returning the address of the
    doubly linked list as the function value.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    ApcMode - Supplies the processor mode of the APC queue that is to
        be flushed.

Return Value:

    The address of the first entry in the list of APC objects that were flushed
    from the specified APC queue.

--*/

{

    PKAPC Apc;
    PLIST_ENTRY FirstEntry;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and
    // lock the APC queue.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // Get address of first APC in the list and check if the list is
    // empty or contains entries that should be flushed. If entries
    // should be flushed, then scan the list of APC objects and set their
    // inserted state to FALSE.
    //

    FirstEntry = Thread->ApcState.ApcListHead[ApcMode].Flink;
    if (FirstEntry == &Thread->ApcState.ApcListHead[ApcMode]) {
        FirstEntry = (PLIST_ENTRY)NULL;

    } else {
        RemoveEntryList(&Thread->ApcState.ApcListHead[ApcMode]);
        NextEntry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            Apc->Inserted = FALSE;
            NextEntry = NextEntry->Flink;
        } while (NextEntry != FirstEntry);
    }

    //
    // Unlock the APC queue, unlock the dispatcher database, lower IRQL to
    // its previous value, and return address of first entry in list of APC
    // objects that were flushed.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return FirstEntry;
}

BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into the APC queue specifed by the
    thread and processor mode fields of the APC object. If the APC object
    is already in an APC queue or APC queuing is disabled, then no operation
    is performed. Otherwise the APC object is inserted in the specified queue
    and appropriate scheduling decisions are made.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    SystemArgument1, SystemArgument2 - Supply a set of two arguments that
        contain untyped data provided by the executive.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue or APC queuing is disabled,
    then a value of FALSE is returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If APC queuing is disabled, then set inserted to FALSE. Else save
    // system parameter values in APC object, and attempt to queue APC.
    //

    Thread = Apc->Thread;
    if (Thread->ApcState.ApcQueueable == FALSE) {
        Inserted = FALSE;

    } else {
        Apc->SystemArgument1 = SystemArgument1;
        Apc->SystemArgument2 = SystemArgument2;
        Inserted = KiInsertQueueApc(Apc, Increment);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value,
    // and return whether APC object was inserted in APC queue.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    )

/*++

Routine Description:

    This function removes an APC object from an APC queue. If the APC object
    is not in an APC queue, then no operation is performed. Otherwise the
    APC object is removed from its current queue and its inserted state is
    set FALSE.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

Return Value:

    If the APC object is not in an APC queue, then a value of FALSE is returned.
    Otherwise a value of TRUE is returned.

--*/

{

    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and
    // lock the APC queue.
    //

    Thread = Apc->Thread;
    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // If the APC object is in an APC queue, then remove it from the queue
    // and set its inserted state to FALSE. If the queue becomes empty, set
    // the APC pending state to FALSE.
    //

    Inserted = Apc->Inserted;
    if (Inserted != FALSE) {
        Apc->Inserted = FALSE;
        ApcState = &Thread->ApcState;
        RemoveEntryList(&Apc->ApcListEntry);
        if (IsListEmpty(&ApcState->ApcListHead[Apc->ApcMode]) != FALSE) {
            if (Apc->ApcMode == KernelMode) {
                ApcState->KernelApcPending = FALSE;

            } else {
                ApcState->UserApcPending = FALSE;
            }
        }
    }

    //
    // Unlock the APC queue, unlock the dispatcher database, lower IRQL to
    // its previous value, and return whether an APC object was removed from
    // the APC queue.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\bugcheck.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    bugcheck.c

Abstract:

    This module implements bug check and system shutdown code.

Author:

    Mark Lucovsky (markl) 30-Aug-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "dm.h"

//
// Define bug count recursion counter and a context buffer.
//

#ifdef DEVKIT
ULONG KeBugCheckCount = 1;
#endif

ULONG_PTR KiBugCheckData[5];

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/
{
    KeBugCheckEx(BugCheckCode,0,0,0,0);
}

VOID
KiBugCheckDebugBreak (
    IN ULONG    BreakStatus
    )
{
    do {
        try {

            //
            // Issue a breakpoint
            //

            DbgBreakPointWithStatus (BreakStatus);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Failure to issue breakpoint, halt the system
            //

            try {

                HalHaltSystem();

            } except(EXCEPTION_EXECUTE_HANDLER) {

                for (;;) {
                }
            }

            for (;;) {
            }
        }
    } while (BreakStatus != DBG_STATUS_BUGCHECK_FIRST);
}

VOID
KeBugCheckEx (
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

    BugCheckParameter1-4 - Supplies additional bug check information

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

#if defined(i386)
    KiSetHardwareTrigger();
#else
    KiHardwareTrigger = 1;
#endif

    KiBugCheckData[0] = BugCheckCode;
    KiBugCheckData[1] = BugCheckParameter1;
    KiBugCheckData[2] = BugCheckParameter2;
    KiBugCheckData[3] = BugCheckParameter3;
    KiBugCheckData[4] = BugCheckParameter4;

#ifdef DEVKIT
    //
    // Once we bugcheck, the debug monitor isn't going to have much luck with
    // anything, so we'll tell it to disable itself.
    //

    if (DmGetCurrentDmi() != NULL) {
        DmGetCurrentDmi()->Flags |= DMIFLAG_BUGCHECK;
    }
#endif

    //
    // If the user manually crashed the machine, skips the DbgPrints and
    // go to the crashdump.
    // Trying to do DbgPrint causes us to reeeter the debugger which causes
    // some problems.
    //
    // Otherwise, if the debugger is enabled, print out the information and
    // stop.
    //

    if ((BugCheckCode != MANUALLY_INITIATED_CRASH) &&
        (KdDebuggerEnabled)) {

        DbgPrint("\n*** Fatal System Error: 0x%08lx\n"
                 "                       (0x%p,0x%p,0x%p,0x%p)\n\n",
                 BugCheckCode,
                 BugCheckParameter1,
                 BugCheckParameter2,
                 BugCheckParameter3,
                 BugCheckParameter4);

        //
        // If the debugger is not actually connected, or the user manually
        // crashed the machine by typing .crash in the debugger, proceed to
        // "blue screen" the system.
        //
        // The call to DbgPrint above will have set the state of
        // KdDebuggerNotPresent if the debugger has become disconnected
        // since the system was booted.
        //

        if (KdDebuggerNotPresent == FALSE) {
            KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_FIRST);
        }
    }

#ifdef DEVKIT
    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KiDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    if (InterlockedDecrement (&KeBugCheckCount) == 0) {
        if (KdDebuggerEnabled == FALSE) {
            KdInitSystem(FALSE);
        }
    }

    //
    // Attempt to enter the kernel debugger.
    //

    KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_SECOND);
#else
    //
    // Halt the system.  If a real debugger is not attached, then we cannot
    // safely use KiBugCheckDebugBreak.  That routine will generate a breakpoint
    // exception inside an exception handler.  RtlDispatchException will check
    // if the exception handler is within the bounds of the current thread's
    // stack.  If we entered this routine as a result of a fault from a stack
    // overflow exception, or a non-maskable interrupt, then we'll be executing
    // on a different stack.  RtlDispatchException will not be able to dispatch
    // the exception and will raise another bug check.
    //

    HalHaltSystem();
#endif
}

#ifdef DEVKIT

VOID
KeEnterKernelDebugger (
    VOID
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner attempting
    to invoke the kernel debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(i386)
    KIRQL OldIrql;
#endif

    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KiHardwareTrigger = 1;
    KiDisableInterrupts();
#if !defined(i386)
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif
    if (InterlockedDecrement (&KeBugCheckCount) == 0) {
        if (KdDebuggerEnabled == FALSE) {
            KdInitSystem(FALSE);
        }
    }

    KiBugCheckDebugBreak (DBG_STATUS_FATAL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\kdlite\kdlite.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kdlite.c

Abstract:

    This module implements the Xbox lite kernel debugger.

--*/

#include "kdlitep.h"

//
// Stores whether or not the debugger is enabled.  The debugger is only enabled
// if a super I/O controller is present.
//
DECLSPEC_STICKY BOOLEAN KdDebuggerEnabled;

//
// Hardwired to TRUE, since a real debugger is never really present.
//
BOOLEAN KdDebuggerNotPresent = TRUE;

//
// Local support.
//

VOID
KdpConfigureSerialPort(
    VOID
    );

VOID
KdpInitializeLoadedModuleList(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, KdpConfigureSerialPort)
#endif

VOID
KdpConfigureSerialPort(
    VOID
    )
/*++

Routine Description:

    This routine configures the serial port for the desired baud rate and port
    options.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG DivisorLatch;

    DivisorLatch = CLOCK_RATE / KDLITE_DEBUG_BAUD_RATE;

    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_LCR, 0x83);
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_DLM, (UCHAR)(DivisorLatch >> 8));
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_DLL, (UCHAR)(DivisorLatch));
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_LCR, 0x03);

    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_MCR, MC_DTRRTS);
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_IEN, 0);
}

VOID
KdpPrintString(
    IN PSTRING String
    )
/*++

Routine Description:

    This routine prints out the supplied string to the serial port.

Arguments:

    String - Specifies the string to be printed to the serial port.

Return Value:

    None.

--*/
{
    BOOLEAN Restore;
    ULONG Length;
    PUCHAR Buffer;

    //
    // If the debugger isn't enabled, don't do anything.
    //

    if (!KdDebuggerEnabled) {
        return;
    }

    //
    // Write out each character to the serial port.  Synchronize by disabling
    // interrupts.
    //

    Restore = KiDisableInterrupts();

    Length = String->Length;
    Buffer = String->Buffer;

    while (Length > 0) {

        while (!(_inp(KDLITE_DEBUG_BASE_ADDRESS + COM_LSR) & COM_OUTRDY));
        _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_DAT, *Buffer);

        Length--;
        Buffer++;
    }

    KiRestoreInterrupts(Restore);
}

BOOLEAN
KdpTrap(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )
/*++

Routine Description:

    This routine is called whenever a exception is dispatched.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/
{
    BOOLEAN Handled = FALSE;

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_KDPRINT)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {

        if ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_KDPRINT)||
            (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT)) {
            KdpPrintString((PSTRING)ExceptionRecord->ExceptionInformation[1]);
            ContextRecord->Eax = STATUS_SUCCESS;
        }

        ContextRecord->Eip++;
        Handled = TRUE;
    }

    return Handled;
}

VOID
KdInitSystem(
    BOOLEAN InitializingSystem
    )
/*++

Routine Description:

    This routine initializes the lite kernel debugger.

Arguments:

    InitializingSystem - Supplies a boolean value that determines whether we're
        called in the context of system initialization or bugcheck code.

Return Value:

    None.

--*/
{
    if (InitializingSystem) {

        //
        // If the kernel is cold-booting, then determine whether or not a super
        // I/O controller is attached to the system so that we know whether or
        // not to output debug spew through the serial port.
        //

        if (!KeHasQuickBooted) {

            HalPulseHardwareMonitorPin();
            KdDebuggerEnabled = HalInitializeSuperIo();

            if (KdDebuggerEnabled) {
                KdpConfigureSerialPort();
            }
        }

        //
        // Set the debug routine to point at our trap handler.
        //

        KiDebugRoutine = KdpTrap;

#ifdef DEVKIT
        //
        // For DEVKIT builds of this library, we still need to initialize the
        // module list so that the debug monitor will continue to function.
        //

        KdpInitializeLoadedModuleList();
#endif
    }
}

#ifdef DEVKIT

//
// The following code and data are present for DEVKIT builds to enable testing
// of the lite kernel debugger on a DEVKIT platform.  None of this code is used
// by a retail build of the system.
//

//
// Set to TRUE if the are any breakpoints that need to be applied to pages that
// are not inpaged.  Always FALSE since this implementation never applies
// breakpoints.
//
BOOLEAN KdpOweBreakpoint;

//
// Static loader data table entry for XBOXKRNL.EXE.
//
LDR_DATA_TABLE_ENTRY KdpNtosDataTableEntry;

//
// List of modules that have been loaded.
//
INITIALIZED_LIST_ENTRY(KdLoadedModuleList);

VOID
KdpInitializeLoadedModuleList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the static loader data table entry for the kernel
    and attaches it to the loaded module list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the loader data table entry for XBOXKRNL.EXE and attach it
    // to the loaded module list.
    //

    KdpNtosDataTableEntry.DllBase = PsNtosImageBase;
    KdpNtosDataTableEntry.SizeOfImage =
        RtlImageNtHeader(PsNtosImageBase)->OptionalHeader.SizeOfImage;
    KdpNtosDataTableEntry.LoadedImports = (PVOID)MAXULONG_PTR;
    RtlInitUnicodeString(&KdpNtosDataTableEntry.FullDllName, L"xboxkrnl.exe");
    RtlInitUnicodeString(&KdpNtosDataTableEntry.BaseDllName, L"xboxkrnl.exe");

    InsertTailList(&KdLoadedModuleList, &KdpNtosDataTableEntry.InLoadOrderLinks);
}

BOOLEAN
KdPollBreakIn(
    VOID
    )
/*++

Routine Description:

    This routine checks if a breakin packet is pending.

Arguments:

    None.

Return Value:

    Returns FALSE to indicate that no breakin packet is pending.

--*/
{
    return FALSE;
}

VOID
KdSetOwedBreakpoints(
    VOID
    )
/*++

Routine Description:

    This routine is called by the page fault handler to store pending
    breakpoints for pages that may have been just made valid.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // This routine should never be called because this implementation never
    // applies breakpoints and never sets KdpOweBreakpoint to TRUE.
    //

    KeBugCheck(0);
}

VOID
KdDeleteAllBreakpoints(
    VOID
    )
/*++

Routine Description:

    This routine is called to delete all breakpoints from the system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\apcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apcsup.c

Abstract:

    This module contains the support routines for the APC object. Functions
    are provided to insert in an APC queue and to deliver user and kernel
    mode APC's.

Author:

    David N. Cutler (davec) 14-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiDeliverApc (
    VOID
    )

/*++

Routine Description:

    This function is called from the APC interrupt code and when one or
    more of the APC pending flags are set at system exit and the previous
    IRQL is zero. All special kernel APC's are delivered first, followed
    by normal kernel APC's if one is not already in progress. On entry
    to this routine IRQL is set to APC_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKAPC Apc;
    PKKERNEL_ROUTINE KernelRoutine;
    PLIST_ENTRY NextEntry;
    PVOID NormalContext;
    PKNORMAL_ROUTINE NormalRoutine;
    KIRQL OldIrql;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;

    //
    // Raise IRQL to dispatcher level and lock the APC queue.
    //

    Thread = KeGetCurrentThread();
    KiLockApcQueue(Thread, &OldIrql);

    //
    // Get address of current thread object, clear kernel APC pending, and
    // check if any kernel mode APC's can be delivered.
    //

    Thread->ApcState.KernelApcPending = FALSE;
    while (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
        NextEntry = Thread->ApcState.ApcListHead[KernelMode].Flink;
        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
        KernelRoutine = Apc->KernelRoutine;
        NormalRoutine = Apc->NormalRoutine;
        NormalContext = Apc->NormalContext;
        SystemArgument1 = Apc->SystemArgument1;
        SystemArgument2 = Apc->SystemArgument2;
        if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) {

            //
            // First entry in the kernel APC queue is a special kernel APC.
            // Remove the entry from the APC queue, set its inserted state
            // to FALSE, release dispatcher database lock, and call the kernel
            // routine. On return raise IRQL to dispatcher level and lock
            // dispatcher database lock.
            //

            RemoveEntryList(NextEntry);
            Apc->Inserted = FALSE;
            KiUnlockApcQueue(Thread, OldIrql);
            (KernelRoutine)(Apc, &NormalRoutine, &NormalContext,
                            &SystemArgument1, &SystemArgument2);

#if DBG

                if (KeGetCurrentIrql() != OldIrql) {
                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                 KeGetCurrentIrql() << 16 | OldIrql << 8,
                                 (ULONG_PTR)KernelRoutine,
                                 (ULONG_PTR)Apc,
                                 (ULONG_PTR)NormalRoutine);
                }

#endif

            KiLockApcQueue(Thread, &OldIrql);

        } else {

            //
            // First entry in the kernel APC queue is a normal kernel APC.
            // If there is not a normal kernel APC in progress and kernel
            // APC's are not disabled, then remove the entry from the APC
            // queue, set its inserted state to FALSE, release the APC queue
            // lock, call the specified kernel routine, set kernel APC in
            // progress, lower the IRQL to zero, and call the normal kernel
            // APC routine. On return raise IRQL to dispatcher level, lock
            // the APC queue, and clear kernel APC in progress.
            //

            if ((Thread->ApcState.KernelApcInProgress == FALSE) &&
               (Thread->KernelApcDisable == 0)) {
                RemoveEntryList(NextEntry);
                Apc->Inserted = FALSE;
                KiUnlockApcQueue(Thread, OldIrql);
                (KernelRoutine)(Apc, &NormalRoutine, &NormalContext,
                                &SystemArgument1, &SystemArgument2);

#if DBG

                if (KeGetCurrentIrql() != OldIrql) {
                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                 KeGetCurrentIrql() << 16 | OldIrql << 8 | 1,
                                 (ULONG_PTR)KernelRoutine,
                                 (ULONG_PTR)Apc,
                                 (ULONG_PTR)NormalRoutine);
                }

#endif

                if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) {
                    Thread->ApcState.KernelApcInProgress = TRUE;
                    KeLowerIrql(0);
                    (NormalRoutine)(NormalContext, SystemArgument1,
                                    SystemArgument2);
                    KeRaiseIrql(APC_LEVEL, &OldIrql);
                }

                KiLockApcQueue(Thread, &OldIrql);
                Thread->ApcState.KernelApcInProgress = FALSE;

            } else {
                KiUnlockApcQueue(Thread, OldIrql);
                return;
            }
        }
    }

    KiUnlockApcQueue(Thread, OldIrql);
    return;
}

VOID
KiDeliverUserApc (
    VOID
    )

/*++

Routine Description:

    This function is called from wait routines after a user APC has been
    detected. All user mode APC's are delivered. On entry to this routine
    IRQL is set to PASSIVE_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKAPC Apc;
    PKKERNEL_ROUTINE KernelRoutine;
    PLIST_ENTRY NextEntry;
    PVOID NormalContext;
    PKNORMAL_ROUTINE NormalRoutine;
    KIRQL OldIrql;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;

    //
    // Raise IRQL to dispatcher level and lock the APC queue.
    //

    Thread = KeGetCurrentThread();
    KiLockApcQueue(Thread, &OldIrql);

    Thread->ApcState.UserApcPending = FALSE;
    while (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE) {
        NextEntry = Thread->ApcState.ApcListHead[UserMode].Flink;
        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
        KernelRoutine = Apc->KernelRoutine;
        NormalRoutine = Apc->NormalRoutine;
        NormalContext = Apc->NormalContext;
        SystemArgument1 = Apc->SystemArgument1;
        SystemArgument2 = Apc->SystemArgument2;
        RemoveEntryList(NextEntry);
        Apc->Inserted = FALSE;
        KiUnlockApcQueue(Thread, OldIrql);
        (KernelRoutine)(Apc, &NormalRoutine, &NormalContext,
                        &SystemArgument1, &SystemArgument2);

#if DBG
        if (KeGetCurrentIrql() != OldIrql) {
            KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                         KeGetCurrentIrql() << 16 | OldIrql << 8 | 1,
                         (ULONG_PTR)KernelRoutine,
                         (ULONG_PTR)Apc,
                         (ULONG_PTR)NormalRoutine);
        }

        ASSERT(OldIrql == PASSIVE_LEVEL);
#endif
        if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) {
            (NormalRoutine)(NormalContext, SystemArgument1, SystemArgument2);
        }

        KiLockApcQueue(Thread, &OldIrql);
    }

    KiUnlockApcQueue(Thread, OldIrql);
    return;
}

BOOLEAN
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into a thread's APC queue. The address
    of the thread object, the APC queue, and the type of APC are all derived
    from the APC object. If the APC object is already in an APC queue, then
    no opertion is performed and a function value of FALSE is returned. Else
    the APC is inserted in the specified APC queue, its inserted state is set
    to TRUE, and a function value of TRUE is returned. The APC will actually
    be delivered when proper enabling conditions exist.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    KPROCESSOR_MODE ApcMode;
    PKAPC ApcEntry;
    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    PLIST_ENTRY ListEntry;
    PKTHREAD Thread;

    //
    // If the APC object is already in an APC queue, then set inserted to
    // FALSE. Else insert the APC object in the proper queue, set the APC
    // inserted state to TRUE, check to determine if the APC should be delivered
    // immediately, and set inserted to TRUE.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that kernel APC disable count is incremented before checking whether
    // the kernel APC queue is nonempty.
    //
    // See KeLeaveCriticalRegion().
    //

    Thread = Apc->Thread;
    KiLockApcQueueAtDpcLevel(Thread);
    if (Apc->Inserted) {
        Inserted = FALSE;

    } else {
        ApcState = &Thread->ApcState;

        //
        // Insert the APC after all other special APC entries selected by
        // the processor mode if the normal routine value is null. Else
        // insert the APC object at the tail of the APC queue selected by
        // the processor mode.
        //

        ApcMode = Apc->ApcMode;
        if (Apc->NormalRoutine != NULL) {
            InsertTailList(&ApcState->ApcListHead[ApcMode],
                           &Apc->ApcListEntry);

        } else {
            ListEntry = ApcState->ApcListHead[ApcMode].Flink;
            while (ListEntry != &ApcState->ApcListHead[ApcMode]) {
                ApcEntry = CONTAINING_RECORD(ListEntry, KAPC, ApcListEntry);
                if (ApcEntry->NormalRoutine != NULL) {
                    break;
                }

                ListEntry = ListEntry->Flink;
            }

            ListEntry = ListEntry->Blink;
            InsertHeadList(ListEntry, &Apc->ApcListEntry);
        }

        Apc->Inserted = TRUE;

        //
        // If the processor mode of the APC is kernel, then check if
        // the APC should either interrupt the thread or sequence the
        // thread out of a Waiting state. Else check if the APC should
        // sequence the thread out of an alertable Waiting state.
        //

        if (ApcMode == KernelMode) {
            Thread->ApcState.KernelApcPending = TRUE;
            if (Thread->State == Running) {
                KiRequestApcInterrupt();

            } else if ((Thread->State == Waiting) &&
                      (Thread->WaitIrql == 0) &&
                      ((Apc->NormalRoutine == NULL) ||
                      ((Thread->KernelApcDisable == 0) &&
                      (Thread->ApcState.KernelApcInProgress == FALSE)))) {
                KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment);
            }

        } else if ((Thread->State == Waiting) &&
                  (Thread->WaitMode == UserMode) &&
                  (Thread->Alertable)) {
            Thread->ApcState.UserApcPending = TRUE;
            KiUnwaitThread(Thread, STATUS_USER_APC, Increment);
        }

        Inserted = TRUE;
    }

    //
    // Unlock the APC queue lock, and return whether the APC object was
    // inserted in an APC queue.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\devquobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    devquobj.c

Abstract:

    This module implements the kernel device queue object. Functions are
    provided to initialize a device queue object and to insert and remove
    device queue entries in a device queue object.

Author:

    David N. Cutler (davec) 1-Apr-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input device queue
// is really a kdevice_queue and not something else, like deallocated pool.
//

#define ASSERT_DEVICE_QUEUE(E) {            \
    ASSERT((E)->Type == DeviceQueueObject); \
}

//
// Define macros to lock and unlock the device queue.
//

#define KiAcquireDeviceQueueLock(QUEUE, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define KiReleaseDeviceQueueLock(QUEUE, OldIrql) \
    KeLowerIrql(OldIrql)

#define KiAcquireDeviceQueueLockAtDpcLevel(QUEUE) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define KiReleaseDeviceQueueLockFromDpcLevel(QUEUE) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)


VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function initializes a kernel device queue object.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    DeviceQueue->Type = DeviceQueueObject;
    DeviceQueue->Size = sizeof(KDEVICE_QUEUE);

    //
    // Initialize the device queue list head, spin lock, and busy indicator.
    //

    InitializeListHead(&DeviceQueue->DeviceListHead);
    DeviceQueue->Busy = FALSE;
    return;
}

BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function inserts a device queue entry at the tail of the specified
    device queue. If the device is not busy, then it is set busy and the entry
    is not placed in the device queue. Otherwise the specified entry is placed
    at the end of the device queue.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    //
    // Insert the specified device queue entry at the end of the device queue
    // if the device queue is busy. Otherwise set the device queue busy and
    // don't insert the device queue entry.
    //

    if (DeviceQueue->Busy == TRUE) {
        Inserted = TRUE;
        InsertTailList(&DeviceQueue->DeviceListHead,
                       &DeviceQueueEntry->DeviceListEntry);
    } else {
        DeviceQueue->Busy = TRUE;
        Inserted = FALSE;
    }
    DeviceQueueEntry->Inserted = Inserted;
    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return Inserted;
}

BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function inserts a device queue entry into the specified device
    queue according to a sort key. If the device is not busy, then it is
    set busy and the entry is not placed in the device queue. Otherwise
    the specified entry is placed in the device queue at a position such
    that the specified sort key is greater than or equal to its predecessor
    and less than its successor.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

    SortKey - Supplies the sort key by which the position to insert the device
        queue entry is to be determined.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY QueueEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    //
    // Insert the specified device queue entry in the device queue at the
    // position specified by the sort key if the device queue is busy.
    // Otherwise set the device queue busy an don't insert the device queue
    // entry.
    //

    DeviceQueueEntry->SortKey = SortKey;
    if (DeviceQueue->Busy == TRUE) {
        Inserted = TRUE;
        NextEntry = DeviceQueue->DeviceListHead.Flink;
        while (NextEntry != &DeviceQueue->DeviceListHead) {
            QueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                           DeviceListEntry);
            if (SortKey < QueueEntry->SortKey) {
                break;
            }
            NextEntry = NextEntry->Flink;
        }
        NextEntry = NextEntry->Blink;
        InsertHeadList(NextEntry, &DeviceQueueEntry->DeviceListEntry);
    } else {
        DeviceQueue->Busy = TRUE;
        Inserted = FALSE;
    }
    DeviceQueueEntry->Inserted = Inserted;
    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return Inserted;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function removes an entry from the head of the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the next entry is removed
    from the head of the device queue and the address of device queue entry
    is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    ASSERT(DeviceQueue->Busy == TRUE);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;
        DeviceQueueEntry = (PKDEVICE_QUEUE_ENTRY)NULL;
    } else {
        NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
        DeviceQueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);
        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Release device queue spin lock and return address of device queue
    // entry.
    //

    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return DeviceQueueEntry;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function removes an entry from the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the an entry is removed
    from the device queue and the address of device queue entry
    is returned.  The queue is search for the first entry which has a value
    greater than or equal to the SortKey.  If no such entry is found then the
    first entry of the queue is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    ASSERT(DeviceQueue->Busy == TRUE);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;
        DeviceQueueEntry = (PKDEVICE_QUEUE_ENTRY)NULL;
    } else {
        NextEntry = DeviceQueue->DeviceListHead.Flink;
        while (NextEntry != &DeviceQueue->DeviceListHead) {
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                           DeviceListEntry);
            if (SortKey <= DeviceQueueEntry->SortKey) {
                break;
            }
            NextEntry = NextEntry->Flink;
        }

        if (NextEntry != &DeviceQueue->DeviceListHead) {
            RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);

        } else {
            NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);
        }

        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Release device queue spin lock and return address of device queue
    // entry.
    //

    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return DeviceQueueEntry;
}

BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function removes a specified entry from the the specified device
    queue. If the device queue entry is not in the device queue, then no
    operation is performed. Otherwise the specified device queue entry is
    removed from the device queue and its inserted status is set to FALSE.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry which is to
        be removed from its device queue.

Return Value:

    A value of TRUE is returned if the device queue entry is removed from its
    device queue. Otherwise a value of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Removed;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock specified device queue.
    //

    KiAcquireDeviceQueueLock(DeviceQueue, &OldIrql);

    //
    // If the device queue entry is not in a device queue, then no operation
    // is performed. Otherwise remove the specified device queue entry from its
    // device queue.
    //

    Removed = DeviceQueueEntry->Inserted;
    if (Removed == TRUE) {
        DeviceQueueEntry->Inserted = FALSE;
        RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);
    }

    //
    // Unlock specified device queue, lower IRQL to its previous level, and
    // return whether the device queue entry was removed from its queue.
    //

    KiReleaseDeviceQueueLock(DeviceQueue, OldIrql);
    return Removed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\genxx.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    genxx.h

Abstract:

    This file contains macros (some of them destined for the M4 preprocessor)
    to aid in the generation of ks & hal header files.  This is used by
    ke\xxx\genxxx.c, as well as sdktools\genxx.

Author:

    Forrest C. Foltz (forrestf) 23-Jan-1998

Revision History:

--*/



//
// Structure element definitions.  
//

#define MAX_ELEMENT_NAME_LEN 127    // big enough for comments too
typedef struct _STRUC_ELEMENT {

//
// Flags is one or more SEF_xxx, defined below.
//

    UINT64 Flags;

//
// Note that Equate is used to store a pointer in the case of bitfield
// processing.
//

    UINT64 Equate;

//
// Name should be quite long, as it is used to hold comments as well.
//

    CHAR Name[ MAX_ELEMENT_NAME_LEN + 1 ];
} STRUC_ELEMENT, *PSTRUC_ELEMENT;

#define SEF_ENABLE_MASK     0x0000FF00      
#define SEF_HAL             0x00000100
#define SEF_KERNEL          0x00000200

#define SEF_INC_FORMAT_MASK 0x00010000
#define SEF_H_FORMAT        0x00000000
#define SEF_INC_FORMAT      0x00010000

//
// Types.  Note that SETMASK, CLRMASK has no effect on te BITFLD types.  BITFLD
// types have SEF_HAL | SEF_KERNEL set in the type.
//

#define SEF_TYPE_MASK       0x000000FF
#define SEF_EQUATE          0x00000000
#define SEF_EQUATE64        0x00000001
#define SEF_COMMENT         0x00000002      
#define SEF_STRING          0x00000003      // Equate is vararg to printf
#define SEF_BITFLD          0x00000004
#define SEF_BITALIAS        0x00000005
#define SEF_STRUCTURE       0x00000006
#define SEF_SETMASK         0x00000010      // Equate is the mask
#define SEF_CLRMASK         0x00000011      // Equate is the mask
#define SEF_END             0x00000012
#define SEF_START           0x00000013
#define SEF_PATH            0x00000014

//
// Note that BITFLD entries have per-entry hal|kernel flags
//


//
// Define architecture specific generation macros.
//

#define SEF_FLAGS 0
#define HAL SEF_HAL
#define KERNEL SEF_KERNEL

#ifndef ULONG_MAX
#define ULONG_MAX 0xFFFFFFFF
#endif

#ifdef _WIN64_
#define SEF_UINT SEF_EQUATE64
#else
#define SEF_UINT SEF_EQUATE
#endif

//
// genDef(Pc, KPCR, MinorVersion)
//
// -> #define PcMinorVersion 0x0
//

#define genDef(Prefix, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Prefix #Member },

//
// genAlt( PbAlignmentFixupCount, KPRCB, KeAlignmentFixupCount )
//
// -> #define PbAlignmentFixupCount 0x2f4
// 

#define genAlt(Name, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Name },

//
// genCom("This is a comment")
//
//    //
// -> // This is a comment
//    //
//

#define genCom(Comment) \
    { SEF_COMMENT, 0, Comment },

//
// genNam(PCR_MINOR_VERSION)
//
// -> #define PCR_MINOR_VERSION 0x1
//

#define genNam(Name) \
    { SEF_EQUATE, (ULONG)(Name), #Name },

//
// genNamUint(KSEG0_BASE)
//
// -> #define KSE0_BASE 0xffffffff80000000
//

#define genNamUint(Name) \
    { SEF_UINT, (UINT64)(Name), #Name },

//
// genVal(FirmwareFrameLength, FIRMWARE_FRAME_LENGTH)
//
// -> #define FirmwareFrameLength 0x250
//
// Note: if the value is 64-bit when _WIN64_ is enabled, use genValUint()
//

#define genVal(Name, Value) \
    { SEF_EQUATE, (ULONG)(Value), #Name },

//
// genValUint(KiPcr, KIPCR)
//
// -> #define KiPcr 0xe0000000ffffe000
//

#define genValUint(Name, Value) \
    { SEF_UINT, (UINT64)(Value), #Name },

//
// genSpc()
//
// ->
//

#define genSpc() \
    { SEF_STRING, 0, "\n" },

//
// genStr("    PCR equ ds:[0%lXH]\n", KIP0PCRADDRESS)
//
// ->     PCR equ ds:[0FFDFF000H]
//

#define genStr(String, Value) \
    { SEF_STRING, (ULONG_PTR)(Value), String },

//
// genTxt("ifdef NT_UP\n")
//
// -> ifdef NT_UP
//

#define genTxt(String) \
    { SEF_STRING, 0, String },

#define DisableInc( x ) \
    { SEF_CLRMASK, x, "" },

#define EnableInc( x ) \
    { SEF_SETMASK, x, "" },

#define MARKER_STRING "This is the genxx marker string."

//
// Source file can specify the _NTDRIVE\_NTROOT - relative output path.
// 'f' is the set of enable-flags that should be routed to this file.
// Use '0' if there is only a single output file.
//
// 'f' should also contain one of SEF_H_FORMAT or SEF_INC_FORMAT to
// indicate whether the generated file is in 'header file' or 'include file'
// format.
//

#define setPath( p, f ) \
    { SEF_PATH | f, 0, p },

//
// START_LIST defines the first element in ElementList.  This element contains
// a (possibly truncated) pointer to the ElementList array.  This is used to
// determine the fixup RA bias.
//

#define START_LIST \
    { SEF_START, (ULONG_PTR)ElementList, MARKER_STRING },

#define END_LIST \
    { SEF_END, 0, "" }

//
// Preprocessor assertion.  Do something here to make the compiler generate
// an error if x != y.
//

#define ASSERT_SAME( x, y )

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#ifndef OFFSET

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif

//
// Following are some M4 macros to help with bitfields.  
//

#ifndef SKIP_M4

//
// First, define the makezeros(n) macro that will generate a string with
// n pairs of ',0'.  This is a recursively defined macro.
//

define(`makezeros',`ifelse(eval($1),0,,`0,makezeros(eval($1-1))')')

//
// Define a concatenation macro.
//

define(`cat',`$1$2')

//
// The following example bitfield declaration uses HARDWARE_PTE as an
// example, which is declared (for alpha) as follows:
//
// typedef struct _HARDWARE_PTE {
//     ULONG Valid: 1;
//     ULONG Owner: 1;
//     ULONG Dirty: 1;
//     ULONG reserved: 1;
//     ULONG Global: 1;
//     ULONG GranularityHint: 2;
//     ULONG Write: 1;
//     ULONG CopyOnWrite: 1;
//     ULONG PageFrameNumber: 23;
// } HARDWARE_PTE, *PHARDWARE_PTE;
//
//
// // First, startBitStruc() is invoked with the structure name.
//
// startBitStruc( HARDWARE_PTE, SEF_HAL | SEF_KERNEL )
//
// //
// // Now, suppose we wanted to expose seven of the fields in an assembly
// // include file:
// //
//
// genBitField( Valid, PTE_VALID )
// genBitField( Owner, PTE_OWNER )
// genBitField( Dirty, PTE_DIRTY )
// genBitField( reserved )
// genBitField( Global, PTE_GLOBAL )
// genBitField( GranularityHint )
// genBitField( Write, PTE_WRITE )
// genBitField( CopyOnWrite, PTE_COPYONWRITE )
// genBitField( PageFrameNumber, PTE_PFN )
//
// Note that fields that are not used (in this case 'reserved' and
// 'GranularityHint') must still appear in the list.
//
// The above will generate a bunch of static, initialized copies of HARDWARE_PTE
// like so:
//
// HARDWARE_PTE HARDWARE_PTE_Valid = {
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Owner = {
//     0,   // Valid
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Dirty = {
//     0,   // Valid
//     0,   // Owner
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Global = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Write = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_CopyOnWrite = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_PageFrameNumber = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0,   // CopyOnWrite
//     0xFFFFFFFF };
//
// Then, as part of processing the END_LIST macro, these structures are
// generated:
//
// { SEF_BITFLD, &HARDWARE_PTE_Valid,           "PTE_VALID" },
// { SEF_BITFLD, &HARDWARE_PTE_Owner,           "PTE_OWNER" },
// { SEF_BITFLD, &HARDWARE_PTE_Dirty,           "PTE_DIRTY" },
// { SEF_BITFLD, &HARDWARE_PTE_Global,          "PTE_GLOBAL" },
// { SEF_BITFLD, &HARDWARE_PTE_Write,           "PTE_WRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_CopyOnWrite,     "PTE_COPYONWRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_PageFrameNumber, "PTE_PFN" },
// { SEF_END,    0,                             "" }
//
//
// ... and that's what gets compiled by the target compiler into the .obj.
// Now, the final stage: genxx.exe is run against this target .obj, and
// would generate the following:
//
// #define PTE_VALID_MASK 0x1
// #define PTE_VALID 0x0
// #define PTE_OWNER_MASK 0x2
// #define PTE_OWNER 0x1
// #define PTE_DIRTY_MASK 0x4
// #define PTE_DIRTY 0x2
// #define PTE_GLOBAL_MASK 0x10
// #define PTE_GLOBAL 0x4
// #define PTE_WRITE_MASK 0x80
// #define PTE_WRITE 0x7
// #define PTE_COPYONWRITE_MASK 0x100
// #define PTE_COPYONWRITE 0x8
// #define PTE_PFN_MASK 0xfffffe00
// #define PTE_PFN 0x9
//

//
// BITFIELD_STRUCS accumulates array element initializations.  END_LIST will
// dump these into the definition array.
// 

define(`BITFIELD_STRUCS',`')

//
// startBitStruc( <strucname>, <whichfile> )
// sets BIT_STRUC_NAME = <strucname> and resets the ZERO_FIELDS count to 0.
// It also sets the WHICH_FILE macro.
//

define(`startBitStruc', `define(`BIT_STRUC_NAME',`$1')
                         define(`BITFIELD_STRUCS',
                                 BITFIELD_STRUCS
                                 )
                         define(`ZERO_FIELDS',0)
                         define(`SEF_TYPE',$2)
                        ')

//
// genBitField( <fldname>, <generatedname> ) declares a structure of type
// <strucname> and initializes the <fldname> bitfield within it.
//
// Note that I used "cma" instead of an actual comma, this gets changed to
// a comma by END_LIST, below.  If I were more proficient with M4 I would know
// how to get around this.
//

define(`genBitField', `define(`VAR_NAME', cat(cat(BIT_STRUC_NAME,`_'),$1))
                      `#'define `def_'VAR_NAME
                      BIT_STRUC_NAME VAR_NAME = {'
                      `makezeros(ZERO_FIELDS)'
                      `(ULONG_PTR)-1 };'
                      `define(`PAD_VAR_NAME', cat(cat(BIT_STRUC_NAME,`p'),$1))'
                      `ULONG_PTR PAD_VAR_NAME = 0;'
                      `define(`ZERO_FIELDS',incr(ZERO_FIELDS))'
                      `define(`FIELD_NAME', $1)'
                      `define(`FIELD_ASMNAME', $2)'
                      `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `dec_'VAR_NAME
                               `#de'fine `dec_'VAR_NAME
                               { SEF_BITFLD | SEF_TYPE cma (ULONG_PTR)&VAR_NAME cma "FIELD_ASMNAME" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                      )

define(`genBitAlias', `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `deca_'VAR_NAME
                               `#de'fine `deca_'VAR_NAME
                               { SEF_BITALIAS | SEF_TYPE cma 0 cma "$1" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                    )

//
// END_LIST dumps the array initializers accumulated by BITFIELD_STRUCS, after
// replacing each 'cma' with an actual comma.
//

define(`DUMP_BITFIELDS',`define(`cma',`,') BITFIELD_STRUCS')

#endif  // SKIP_M4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\eventobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventobj.c

Abstract:

    This module implements the kernel event objects. Functions are
    provided to initialize, pulse, read, reset, and set event objects.

Author:

    David N. Cutler (davec) 27-Feb-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

#undef KeInitializeEvent

VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    )

/*++

Routine Description:

    This function initializes a kernel event object. The initial signal
    state of the object is set to the specified value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Type - Supplies the type of event; NotificationEvent or
        SynchronizationEvent.

    State - Supplies the initial signal state of the event object.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header, set initial signal
    // state of event object, and set the type of event object.
    //

    Event->Header.Type = (UCHAR)Type;
    Event->Header.Size = sizeof(KEVENT) / sizeof(LONG);
    Event->Header.SignalState = State;
    InitializeListHead(&Event->Header.WaitListHead);
    return;
}

LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function atomically sets the signal state of an event object to
    Signaled, attempts to satisfy as many Waits as possible, and then resets
    the signal state of the event object to Not-Signaled. The previous signal
    state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the current state of the event object is Not-Signaled and
    // the wait queue is not empty, then set the state of the event
    // to Signaled, satisfy as many Waits as possible, and then reset
    // the state of the event to Not-Signaled.
    //

    OldState = Event->Header.SignalState;
    if ((OldState == 0) && (IsListEmpty(&Event->Header.WaitListHead) == FALSE)) {
        Event->Header.SignalState = 1;
        KiWaitTest(Event, Increment);
    }

    Event->Header.SignalState = 0;

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to the
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitIrql = OldIrql;
        Thread->WaitNext = Wait;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeResetEvent (
    IN PRKEVENT Event
    )

/*++

Routine Description:

    This function resets the signal state of an event object to
    Not-Signaled. The previous state of the event object is returned
    as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of event object and then reset
    // the state of the event object to Not-Signaled.
    //

    OldState = Event->Header.SignalState;
    Event->Header.SignalState = 0;

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function sets the signal state of an event object to Signaled
    and attempts to satisfy as many Waits as possible. The previous
    signal state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Collect call data.
    //

#if defined(_COLLECT_SET_EVENT_CALLDATA_)

    RECORD_CALL_DATA(&KiSetEventCallData);

#endif

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the wait list is empty, then set the state of the event to signaled.
    // Otherwise, check if the wait can be satisfied immediately.
    //

    OldState = Event->Header.SignalState;
    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // If the event is a notification event or the wait is not a wait any,
        // then set the state of the event to signaled and attempt to satisfy
        // as many waits as possible. Otherwise, the wait can be satisfied by
        // directly unwaiting the thread.
        //

        WaitBlock = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                      KWAIT_BLOCK,
                                      WaitListEntry);

        if ((Event->Header.Type == NotificationEvent) ||
            (WaitBlock->WaitType != WaitAny)) {
            if (OldState == 0) {
                Event->Header.SignalState = 1;
                KiWaitTest(Event, Increment);
            }

        } else {
            KiUnwaitThread(WaitBlock->Thread, (NTSTATUS)WaitBlock->WaitKey, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
       Thread = KeGetCurrentThread();
       Thread->WaitNext = Wait;
       Thread->WaitIrql = OldIrql;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

VOID
KeSetEventBoostPriority (
    IN PRKEVENT Event,
    IN PRKTHREAD *Thread OPTIONAL
    )

/*++

Routine Description:

    This function conditionally sets the signal state of an event object
    to Signaled, and attempts to unwait the first waiter, and optionally
    returns the thread address of the unwatied thread.

    N.B. This function can only be called with synchronization events
         and is primarily for the purpose of implementing fast mutexes.
         It is assumed that the waiter is NEVER waiting on multiple
         objects.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Thread - Supplies an optional pointer to a variable that receives
        the address of the thread that is awakened.

Return Value:

    None.

--*/

{

    KPRIORITY Increment;
    KIRQL OldIrql;
    PRKTHREAD WaitThread;

    ASSERT(Event->Header.Type == SynchronizationEvent);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the the wait list is not empty, then satisfy the wait of the
    // first thread in the wait list. Otherwise, set the signal state
    // of the event object.
    //
    // N.B. This function is only called for fast mutexes and exclusive
    //      access to resources. All waits MUST be wait for single object.
    //

    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // Get the address of the waiting thread.
        //

        WaitThread = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                       KWAIT_BLOCK,
                                       WaitListEntry)->Thread;

        //
        // If specified, return the address of the thread that is awakened.
        //

        if (ARGUMENT_PRESENT(Thread)) {
            *Thread = WaitThread;
        }

        //
        // Give the new owner of the resource/fast mutex (the only callers) a
        // full quantum, and unwait the thread with a standard event increment
        // unless the system is a server system, in which case no boost if given.
        //

        WaitThread->Quantum = WaitThread->ApcState.Process->ThreadQuantum;
        Increment = EVENT_INCREMENT;

        KiUnwaitThread(WaitThread, STATUS_SUCCESS, Increment);
    }

    //
    // Unlock dispatcher database lock and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\dpcobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpcobj.c

Abstract:

    This module implements the kernel DPC object. Functions are provided
    to initialize, insert, and remove DPC objects.

Author:

    David N. Cutler (davec) 6-Mar-1989

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"


//
// The following assert macro is used to check that an input dpc is
// really a kdpc and not something else, like deallocated pool.
//

#define ASSERT_DPC(E) {             \
    ASSERT((E)->Type == DpcObject); \
}

VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    )

/*++

Routine Description:

    This function initializes a kernel DPC object. The deferred routine
    and context parameter are stored in the DPC object.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredRoutine - Supplies a pointer to a function that is called when
        the DPC object is removed from the current processor's DPC queue.

    DeferredContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the DeferredRoutine parameter.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    Dpc->Type = DpcObject;

    //
    // Initialize deferred routine address and deferred context parameter.
    //

    Dpc->DeferredRoutine = DeferredRoutine;
    Dpc->DeferredContext = DeferredContext;
    Dpc->Inserted = FALSE;
    return;
}

BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function inserts a DPC object into the DPC queue. If the DPC object
    is already in the DPC queue, then no operation is performed. Otherwise,
    the DPC object is inserted in the DPC queue and a dispatch interrupt is
    requested.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    SystemArgument1, SystemArgument2  - Supply a set of two arguments that
        contain untyped data provided by the executive.

Return Value:

    If the DPC object is already in a DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;
    PKPRCB Prcb;

    ASSERT_DPC(Dpc);

    //
    // Disable interrupts.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // If the DPC object is not in a DPC queue, then store the system
    // arguments, insert the DPC object in the DPC queue, increment the
    // number of DPCs queued to the target processor, increment the DPC
    // queue depth, set the address of the DPC target DPC spinlock, and
    // request a dispatch interrupt if appropriate.
    //

    Inserted = Dpc->Inserted;
    if (!Inserted) {

        Dpc->Inserted = TRUE;
        Dpc->SystemArgument1 = SystemArgument1;
        Dpc->SystemArgument2 = SystemArgument2;

        //
        // Insert the DPC at the end of the DPC queue.
        //

        Prcb = KeGetCurrentPrcb();
        InsertTailList(&Prcb->DpcListHead, &Dpc->DpcListEntry);

        //
        // If a DPC routine is not active on the target processor, then
        // request a dispatch interrupt if appropriate.
        //

        if ((Prcb->DpcRoutineActive == FALSE) &&
            (Prcb->DpcInterruptRequested == FALSE)) {

            //
            // Request a dispatch interrupt on the current processor.
            //

            Prcb->DpcInterruptRequested = TRUE;
            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
        }
     }

     //
     // Release the DPC lock, enable interrupts, and return whether the
     // DPC was queued or not.
     //

     KeLowerIrql(OldIrql);
     return (BOOLEAN)!Inserted;
}

BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    )

/*++

Routine Description:

    This function removes a DPC object from the DPC queue. If the DPC object
    is not in the DPC queue, then no operation is performed. Otherwise, the
    DPC object is removed from the DPC queue and its inserted state is set
    FALSE.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

Return Value:

    If the DPC object is not in the DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;

    ASSERT_DPC(Dpc);

    //
    // If the DPC object is in the DPC queue, then remove it from the queue
    // and set its inserted state to FALSE.
    //

    _disable();
    Inserted = Dpc->Inserted;
    if (Inserted) {

        //
        // If the specified DPC is still in the DPC queue, then remove it.
        //

        RemoveEntryList(&Dpc->DpcListEntry);
        Dpc->Inserted = FALSE;
    }

    //
    // Enable interrupts and return whether the DPC was removed from a DPC
    // queue.
    //

    _enable();
    return (BOOLEAN)Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\ki.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ki.h

Abstract:

    This module contains the private (internal) header file for the
    kernel.

Author:

    David N. Cutler (davec) 28-Feb-1989

Revision History:

--*/

#ifndef _KI_
#define _KI_
#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "zwapi.h"

//
// Private (internal) constant definitions.
//
// Priority increment value definitions
//

#define ALERT_INCREMENT 2           // Alerted unwait priority increment
#define BALANCE_INCREMENT 10        // Balance set priority increment
#define RESUME_INCREMENT 0          // Resume thread priority increment
#define TIMER_EXPIRE_INCREMENT 0    // Timer expiration priority increment

//
// Define time critical priority class base.
//

#define TIME_CRITICAL_PRIORITY_BOUND 14

//
// Define NIL pointer value.
//

#define NIL (PVOID)NULL             // Null pointer to void

//
// Define macros which are used in the kernel only
//
// Clear member in set
//

#define ClearMember(Member, Set) \
    Set = Set & (~(1 << (Member)))

//
// Set member in set
//

#define SetMember(Member, Set) \
    Set = Set | (1 << (Member))

#define FindFirstSetLeftMember(Set, Member) {                          \
    ULONG _Bit;                                                        \
    ULONG _Mask;                                                       \
    ULONG _Offset = 16;                                                \
    if ((_Mask = Set >> 16) == 0) {                                    \
        _Offset = 0;                                                   \
        _Mask = Set;                                                   \
    }                                                                  \
    if (_Mask >> 8) {                                                  \
        _Offset += 8;                                                  \
    }                                                                  \
    if ((_Bit = Set >> _Offset) & 0xf0) {                              \
        _Bit >>= 4;                                                    \
        _Offset += 4;                                                  \
    }                                                                  \
    *(Member) = KiFindLeftNibbleBitTable[_Bit] + _Offset;              \
}

//
// Lock and unlock APC queue lock.
//

#define KiLockApcQueue(Thread, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToSynchLevel()

#define KiLockApcQueueAtDpcLevel(Thread) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define KiUnlockApcQueue(Thread, OldIrql) KeLowerIrql((OldIrql))

#define KiUnlockApcQueueFromDpcLevel(Thread) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

// VOID
// KiBoostPriorityThread (
//    IN PKTHREAD Thread,
//    IN KPRIORITY Increment
//    )
//
//*++
//
// Routine Description:
//
//    This function boosts the priority of the specified thread using
//    the same algorithm used when a thread gets a boost from a wait
//    operation.
//
// Arguments:
//
//    Thread  - Supplies a pointer to a dispatcher object of type thread.
//
//    Increment - Supplies the priority increment that is to be applied to
//        the thread's priority.
//
// Return Value:
//
//    None.
//
//--*

#define KiBoostPriorityThread(Thread, Increment) {              \
    KPRIORITY NewPriority;                                      \
    PKPROCESS Process;                                          \
                                                                \
    if ((Thread)->Priority < LOW_REALTIME_PRIORITY) {           \
        if ((Thread)->PriorityDecrement == 0) {                 \
            NewPriority = (Thread)->BasePriority + (Increment); \
            if (NewPriority > (Thread)->Priority) {             \
                if (NewPriority >= LOW_REALTIME_PRIORITY) {     \
                    NewPriority = LOW_REALTIME_PRIORITY - 1;    \
                }                                               \
                                                                \
                Process = (Thread)->ApcState.Process;           \
                (Thread)->Quantum = Process->ThreadQuantum;     \
                KiSetPriorityThread((Thread), NewPriority);     \
            }                                                   \
        }                                                       \
    }                                                           \
}

// VOID
// KiInsertWaitList (
//    IN KPROCESSOR_MODE WaitMode,
//    IN PKTHREAD Thread
//    )
//
//*++
//
// Routine Description:
//
//    This function inserts the specified thread in the appropriate
//    wait list.
//
// Arguments:
//
//    WaitMode - Supplies the processor mode of the wait operation.
//
//    Thread - Supplies a pointer to a dispatcher object of type
//        thread.
//
// Return Value:
//
//    None.
//
//--*

#define KiInsertWaitList(_WaitMode, _Thread) {                  \
    PLIST_ENTRY _ListHead;                                      \
    _ListHead = &KiWaitInListHead;                              \
    InsertTailList(_ListHead, &(_Thread)->WaitListEntry);       \
}

//
// Private (internal) structure definitions.
//
// APC Parameter structure.
//

typedef struct _KAPC_RECORD {
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC_RECORD, *PKAPC_RECORD;

//
// Executive initialization.
//

VOID
ExpInitializeExecutive (
    VOID
    );

//
// Private (internal) function definitions.
//

VOID
FASTCALL
KiActivateWaiterQueue (
    IN PRKQUEUE Queue
    );

VOID
KiApcInterrupt (
    VOID
    );

#if DBG

VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER SystemTime
    );

#endif

ULONG
KiComputeTimerTableIndex (
    IN LARGE_INTEGER Interval,
    IN LARGE_INTEGER CurrentCount,
    IN PRKTIMER Timer
    );

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    );

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiDeliverApc (
    VOID
    );

VOID
KiDeliverUserApc (
    VOID
    );

BOOLEAN
KiDisableInterrupts (
    VOID
    );

VOID
KiRestoreInterrupts (
    IN BOOLEAN Enable
    );

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    );

VOID
KiDispatchInterrupt (
    VOID
    );

PKTHREAD
FASTCALL
KiFindReadyThread (
    KPRIORITY LowPriority
    );

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN SIZE_T ThreadLocalStorageSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

VOID
KiInitializeKernel (
    VOID
    );

VOID
KiInitSystem (
    VOID
    );

BOOLEAN
KiInitMachineDependent (
    VOID
    );

LONG
FASTCALL
KiInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry,
    IN BOOLEAN Head
    );

BOOLEAN
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    );

LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PRKTIMER Timer,
    IN LARGE_INTEGER Interval
    );

VOID
KiInterruptDispatch (
    VOID
    );

VOID
KiLevelInterruptDispatch (
    VOID
    );

#if defined(i386)

VOID
KiInitializePcr (
    IN PKPCR    Pcr,
    IN PKTHREAD Thread,
    IN PVOID DpcStack
    );

VOID
KiFlushNPXState (
    VOID
    );

VOID
KiSetHardwareTrigger (
    VOID
    );

#ifdef DBGMP
VOID
KiPollDebugger (
    VOID
    );
#endif

#endif

KIRQL
KiLockDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

PRKTHREAD
KiQuantumEnd (
    VOID
    );

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    );

VOID
FASTCALL
KiReadyThread (
    IN PRKTHREAD Thread
    );

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PRKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    );

#if DBG

#define KiRemoveTreeTimer(Timer)               \
    (Timer)->Header.Inserted = FALSE;          \
    RemoveEntryList(&(Timer)->TimerListEntry); \
    (Timer)->TimerListEntry.Flink = NULL;      \
    (Timer)->TimerListEntry.Blink = NULL

#else

#define KiRemoveTreeTimer(Timer)               \
    (Timer)->Header.Inserted = FALSE;          \
    RemoveEntryList(&(Timer)->TimerListEntry)

#endif

#define KiRequestApcInterrupt() KiRequestSoftwareInterrupt(APC_LEVEL)

#define KiRequestDispatchInterrupt()

PRKTHREAD
FASTCALL
KiSelectNextThread (
    IN PRKTHREAD Thread
    );

VOID
KiSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    );

VOID
KiSuspendNop (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

LONG_PTR
FASTCALL
KiSwapThread (
    VOID
    );

VOID
KiThreadStartup (
    IN PVOID StartContext
    );

VOID
KiTimerExpiration (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    );

VOID
KiUnexpectedInterrupt (
    VOID
    );

VOID
KiUnlockDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN KIRQL OldIrql
    );

VOID
FASTCALL
KiUnwaitThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment
    );

VOID
FASTCALL
KiWaitSatisfyAll (
    IN PRKWAIT_BLOCK WaitBlock
    );

//
// VOID
// FASTCALL
// KiWaitSatisfyAny (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object and performs
//    any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyAny(_Object_, _Thread_) {                               \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    } else if ((_Object_)->Header.Type == MutantObject) {                    \
        (_Object_)->Header.SignalState -= 1;                                 \
        if ((_Object_)->Header.SignalState == 0) {                           \
            (_Object_)->OwnerThread = (_Thread_);                            \
            if ((_Object_)->Abandoned == TRUE) {                             \
                (_Object_)->Abandoned = FALSE;                               \
                (_Thread_)->WaitStatus = STATUS_ABANDONED;                   \
            }                                                                \
                                                                             \
            InsertHeadList((_Thread_)->MutantListHead.Blink,                 \
                           &(_Object_)->MutantListEntry);                    \
        }                                                                    \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyMutant (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for a mutant object.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyMutant(_Object_, _Thread_) {                            \
    (_Object_)->Header.SignalState -= 1;                                     \
    if ((_Object_)->Header.SignalState == 0) {                               \
        (_Object_)->OwnerThread = (_Thread_);                                \
        if ((_Object_)->Abandoned == TRUE) {                                 \
            (_Object_)->Abandoned = FALSE;                                   \
            (_Thread_)->WaitStatus = STATUS_ABANDONED;                       \
        }                                                                    \
                                                                             \
        InsertHeadList((_Thread_)->MutantListHead.Blink,                     \
                       &(_Object_)->MutantListEntry);                        \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyOther (
//    IN PKMUTANT Object
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object except a mutant
//    and performs any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyOther(_Object_) {                                       \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    }                                                                        \
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    );

#endif // _KI_

//
// External references to private kernel data structures
//

extern PKDEBUG_ROUTINE KiDebugRoutine;
extern LIST_ENTRY KiDispatcherReadyListHead[MAXIMUM_PRIORITY];
extern ULONG_PTR KiHardwareTrigger;
extern KAFFINITY KiIdleSummary;
extern const UCHAR KiFindLeftNibbleBitTable[];
extern ULONG KiReadySummary;
extern const LARGE_INTEGER KiTimeIncrementReciprocal;
extern const CCHAR KiTimeIncrementShiftCount;
extern LIST_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];
extern KDPC KiTimerExpireDpc;
extern LIST_ENTRY KiWaitInListHead;
extern KPROCESS KiIdleProcess;
extern KPROCESS KiSystemProcess;

#if defined(i386)

VOID
KeFlushCurrentTbAndInvalidateAllCaches (
    VOID
    );

VOID
KeInvalidateAllCaches (
    VOID
    );

#endif

#if DBG

extern ULONG KiMaximumSearchCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\kernldat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kernldat.c

Abstract:

    This module contains the declaration and allocation of kernel data
    structures.

Author:

    David N. Cutler (davec) 12-Mar-1989

Revision History:

--*/
#include "ki.h"

//
// The following data is read/write data that is grouped together for
// performance. The layout of this data is important and must not be
// changed.
//
// KiDispatcherReadyListHead - This is an array of type list entry. The
//      elements of the array are indexed by priority. Each element is a list
//      head for a set of threads that are in a ready state for the respective
//      priority. This array is used by the find next thread code to speed up
//      search for a ready thread when a thread becomes unrunnable. See also
//      KiReadySummary.
//

LIST_ENTRY KiDispatcherReadyListHead[MAXIMUM_PRIORITY];

//
// KiIdleSummary - This is the set of processors that are idle. It is used by
//      the ready thread code to speed up the search for a thread to preempt
//      when a thread becomes runnable.
//

KAFFINITY KiIdleSummary;

//
// KiReadySummary - This is the set of dispatcher ready queues that are not
//      empty. A member is set in this set for each priority that has one or
//      more entries in its respective dispatcher ready queues.
//

ULONG KiReadySummary;

//
// KiTimerTableListHead - This is a array of list heads that anchor the
//      individual timer lists.
//

LIST_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];

//
// KeBootTime - This is the absolute time when the system was booted.
//

LARGE_INTEGER KeBootTime;

//
// KeBootTimeBias - The time for which KeBootTime has ever been biased
//

ULONGLONG KeBootTimeBias;

//
// KeTimeIncrement - This is the nominal number of 100ns units that are to
//      be added to the system time at each interval timer interupt. This
//      value is set by the HAL and is used to compute the dure time for
//      timer table entries.
//

const ULONG KeTimeIncrement = CLOCK_TIME_INCREMENT;

//
// KiMaximumSearchCount - this is the maximum number of timers entries that
//      have had to be examined to insert in the timer tree.
//

ULONG KiMaximumSearchCount;

//
// KiDebugRoutine - This is the address of the kernel debugger. Initially
//      this is filled with the address of a routine that just returns. If
//      the system debugger is present in the system, then it sets this
//      location to the address of the systemn debugger's routine.
//

PKDEBUG_ROUTINE KiDebugRoutine;

//
// KiFindLeftNibbleBitTable - This a table that is used to find the left most bit in
//      a 4-bit nibble.
//

const UCHAR KiFindLeftNibbleBitTable[] = {0, 0, 1, 1, 2, 2, 2, 2,
                                          3, 3, 3, 3, 3, 3, 3, 3};

//
// KiTimerExpireDpc - This is the Deferred Procedure Call (DPC) object that
//      is used to process the timer queue when a timer has expired.
//

KDPC KiTimerExpireDpc;

//
// KiTimeIncrementReciprocal - This is the reciprocal fraction of the time
//      increment value that is specified by the HAL when the system is
//      booted.
//
// The following is the number for a CLOCK_TIME_INCREMENT of 10000.
//

const LARGE_INTEGER KiTimeIncrementReciprocal = { 0xE219652C, 0xD1B71758 };

//
// KiTimeIncrementShiftCount - This is the shift count that corresponds to
//      the time increment reciprocal value.
//
// The following is the number for a CLOCK_TIME_INCREMENT of 10000.
//

const CCHAR KiTimeIncrementShiftCount = 13;

//
// KiWaitInListHead - This is a list of threads that are waiting with a
//      resident kernel stack.
//

LIST_ENTRY KiWaitInListHead;

//
// KiHardwareTrigger -
//

ULONG KiHardwareTrigger;

//
// KeTickCount - This is the number of clock ticks that have occurred since
//      the system was booted. This count is used to compute a millisecond
//      tick counter.
//

volatile ULONG KeTickCount;

//
// KeInterruptTime -
//

volatile KSYSTEM_TIME KeInterruptTime;

//
// KeSystemTime -
//

volatile KSYSTEM_TIME KeSystemTime;

//
// KeHasQuickBooted - This indicates that the system is initializing or has
//      initialized due to a quick boot.
//

BOOLEAN KeHasQuickBooted;

//
// KiIdleProcess - This is the process that holds the idle thread.
//

KPROCESS KiIdleProcess;

//
// KiSystemProcess - This is the process that holds all of the other threads.
//

KPROCESS KiSystemProcess;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\dpcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpcsup.c

Abstract:

    This module contains the support routines for the system DPC objects.
    Functions are provided to process quantum end, the power notification
    queue, and timer expiration.

Author:

    David N. Cutler (davec) 22-Apr-1989

Environment:

    Kernel mode only, IRQL DISPATCH_LEVEL.

Revision History:

--*/

#include "ki.h"


//
// Define DPC entry structure and maximum DPC List size.
//

#define MAXIMUM_DPC_LIST_SIZE 16

typedef struct _DPC_ENTRY {
    PRKDPC Dpc;
    PKDEFERRED_ROUTINE Routine;
    PVOID Context;
} DPC_ENTRY, *PDPC_ENTRY;


PRKTHREAD
KiQuantumEnd (
    VOID
    )

/*++

Routine Description:

    This function is called when a quantum end event occurs on the current
    processor. Its function is to determine whether the thread priority should
    be decremented and whether a redispatch of the processor should occur.

Arguments:

    None.

Return Value:

    The next thread to be schedule on the current processor is returned as
    the function value. If this value is not NULL, then the return is with
    the dispatcher database locked. Otherwise, the dispatcher database is
    unlocked.

--*/

{

    KPRIORITY NewPriority;
    PKPRCB Prcb;
    KPRIORITY Priority;
    PKPROCESS Process;
    PRKTHREAD Thread;
    PRKTHREAD NextThread;

    //
    // Acquire the dispatcher database lock.
    //

    Prcb = KeGetCurrentPrcb();
    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabaseAtDpcLevel();

    //
    // If the quantum has expired for the current thread, then update its
    // quantum and priority.
    //

    if (Thread->Quantum <= 0) {

        //
        // If quantum runout is disabled for the thread's process and
        // the thread is running at a realtime priority, then set the
        // thread quantum to the highest value and do not round robin
        // at the thread's priority level. Otherwise, reset the thread
        // quantum and decay the thread's priority as appropriate.
        //

        Process = Thread->ApcState.Process;
        if ((Process->DisableQuantum != FALSE) &&
            (Thread->Priority >= LOW_REALTIME_PRIORITY)) {
            Thread->Quantum = MAXLONG;

        } else {
            Thread->Quantum = Process->ThreadQuantum;

            //
            // Decrement the thread's current priority if the thread is not
            // running in a realtime priority class and check to determine
            // if the processor should be redispatched.
            //

            Priority = Thread->Priority;
            if (Priority < LOW_REALTIME_PRIORITY) {
                NewPriority = Priority - Thread->PriorityDecrement - 1;
                if (NewPriority < Thread->BasePriority) {
                    NewPriority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;

            } else {
                NewPriority = Priority;
            }

            //
            // If the new thread priority is different that the current thread
            // priority, then the thread does not run at a realtime level and
            // its priority should be set. Otherwise, attempt to round robin
            // at the current level.
            //

            if (Priority != NewPriority) {
                KiSetPriorityThread(Thread, NewPriority);

            } else {
                if (Prcb->NextThread == NULL) {
                    NextThread = KiFindReadyThread(Priority);

                    if (NextThread != NULL) {
                        NextThread->State = Standby;
                        Prcb->NextThread = NextThread;
                    }

                } else {
                    Thread->Preempted = FALSE;
                }
            }
        }
    }

    //
    // If a thread was scheduled for execution on the current processor,
    // then return the address of the thread with the dispatcher database
    // locked. Otherwise, return NULL with the dispatcher data unlocked.
    //

    NextThread = Prcb->NextThread;
    if (NextThread == NULL) {
        KiUnlockDispatcherDatabaseFromDpcLevel();
    }

    return NextThread;
}

#if DBG


VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER CurrentTime
    )

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;

    //
    // Raise IRQL to highest level and scan timer table for timers that
    // have expired.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            NextEntry = NextEntry->Flink;
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {
                DbgBreakPoint();
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);

    //
    // Lower IRQL to the previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

#endif


VOID
KiTimerExpiration (
    IN PKDPC TimerDpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the clock interupt routine discovers that
    a timer has expired.

Arguments:

    TimerDpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Not used.

    SystemArgument1 - Supplies the starting timer table index value to
        use for the timer table scan.

    SystemArgument2 - Not used.

Return Value:

    None.

--*/

{
    ULARGE_INTEGER CurrentTime;
    LIST_ENTRY ExpiredListHead;
    LONG HandLimit;
    LONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKTIMER Timer;

    //
    // Acquire the dispatcher database lock and read the current interrupt
    // time to determine which timers have expired.
    //

    KiLockDispatcherDatabaseAtDpcLevel();
    KiQueryInterruptTime((PLARGE_INTEGER)&CurrentTime);

    //
    // If the timer table has not wrapped, then start with the specified
    // timer table index value, and scan for timer entries that have expired.
    // Otherwise, start with the first entry in the timer table and scan the
    // entire table for timer entries that have expired.
    //
    // N.B. This later condition exists when DPC processing is blocked for a
    //      period longer than one round trip throught the timer table.
    //

    HandLimit = (LONG)KiQueryLowTickCount();
    if (((ULONG)(HandLimit - PtrToLong(SystemArgument1))) >= TIMER_TABLE_SIZE) {
        Index = - 1;
        HandLimit = TIMER_TABLE_SIZE - 1;

    } else {
        Index = (PtrToLong(SystemArgument1) - 1) & (TIMER_TABLE_SIZE - 1);
        HandLimit &= (TIMER_TABLE_SIZE - 1);
    }

    InitializeListHead(&ExpiredListHead);
    do {
        Index = (Index + 1) & (TIMER_TABLE_SIZE - 1);
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {

                //
                // The next timer in the current timer list has expired.
                // Remove the entry from the timer list and insert the
                // timer in the expired list.
                //

                RemoveEntryList(&Timer->TimerListEntry);
                InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
                NextEntry = ListHead->Flink;

            } else {
                break;
            }
        }

    } while(Index != HandLimit);

#if DBG

    if (PtrToUlong(SystemArgument2) == 0) {
        KiCheckTimerTable(CurrentTime);
    }

#endif

    //
    // Process the expired timer list.
    //
    // N.B. The following function returns with the dispatcher database
    //      unlocked.
    //

    KiTimerListExpire(&ExpiredListHead, DISPATCH_LEVEL);
    return;
}

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function is called to process a list of timers that have expired.

    N.B. This function is called with the dispatcher database locked and
        returns with the dispatcher database unlocked.

Arguments:

    ExpiredListHead - Supplies a pointer to a list of timers that have
        expired.

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    LONG Count;
    PKDPC Dpc;
    DPC_ENTRY DpcList[MAXIMUM_DPC_LIST_SIZE];
    LONG Index;
    LARGE_INTEGER Interval;
    LARGE_INTEGER SystemTime;
    PKTIMER Timer;

    //
    // Capture the timer expiration time.
    //

    KiQuerySystemTime(&SystemTime);

    //
    // Remove the next timer from the expired timer list, set the state of
    // the timer to signaled, reinsert the timer in the timer tree if it is
    // periodic, and optionally call the DPC routine if one is specified.
    //

RestartScan:
    Count = 0;
    while (ExpiredListHead->Flink != ExpiredListHead) {
        Timer = CONTAINING_RECORD(ExpiredListHead->Flink, KTIMER, TimerListEntry);
        KiRemoveTreeTimer(Timer);
        Timer->Header.SignalState = 1;
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            KiWaitTest(Timer, TIMER_EXPIRE_INCREMENT);
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer in the table. If this happens,
        //      try again.
        //
        if (Timer->Period != 0) {
            Interval.QuadPart = Int32x32To64(Timer->Period, - 10 * 1000);
            while (!KiInsertTreeTimer(Timer, Interval)) {
                ;
            }
        }

        if (Timer->Dpc != NULL) {
            Dpc = Timer->Dpc;

            //
            // If the DPC is explicitly targeted to another processor, then
            // queue the DPC to the target processor. Otherwise, capture the
            // DPC parameters for execution on the current processor.
            //

            DpcList[Count].Dpc = Dpc;
            DpcList[Count].Routine = Dpc->DeferredRoutine;
            DpcList[Count].Context = Dpc->DeferredContext;
            Count += 1;
            if (Count == MAXIMUM_DPC_LIST_SIZE) {
                break;
            }
        }
    }

    //
    // Unlock the dispacher database and process DPC list entries.
    //

    if (Count != 0) {
        KiUnlockDispatcherDatabase(DISPATCH_LEVEL);
        Index = 0;
        do {

#if DBG && (defined(i386) || defined(ALPHA))

            //
            // Reset the dpc tick count. If the tick count handler,
            // which increments this value, detects that it has crossed
            // a certain threshold, a breakpoint will be generated.
            //

            KeGetCurrentPrcb()->DebugDpcTime = 0;
#endif

            (DpcList[Index].Routine)(DpcList[Index].Dpc,
                                     DpcList[Index].Context,
                                     ULongToPtr(SystemTime.LowPart),
                                     ULongToPtr(SystemTime.HighPart));

            Index += 1;
        } while (Index < Count);

        //
        // If processing of the expired timer list was terminated because
        // the DPC List was full, then process any remaining entries.
        //

        if (Count == MAXIMUM_DPC_LIST_SIZE) {
            KiLockDispatcherDatabaseAtDpcLevel();
            goto RestartScan;
        }

        KeLowerIrql(OldIrql);

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\procobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    procobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel process object. Functions are provided to initialize, attach,
    detach, exclude, include, and set the base priority of process objects.

Author:

    David N. Cutler (davec) 7-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KeInitializeProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY BasePriority
    )

/*++

Routine Description:

    This function initializes a kernel process object. The base priority,
    affinity, and page frame numbers for the process page table directory
    and hyper space are stored in the process object.

    N.B. It is assumed that the process object is zeroed.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    BasePriority - Supplies the base priority of the process.

Return Value:

    None.

--*/

{

    //
    // Initialize the base priority.
    //

    Process->BasePriority = (SCHAR)BasePriority;

    //
    // Initialize the stack count, profile listhead, ready queue list head,
    // accumulated runtime, process quantum, thread quantum, and thread list
    // head.
    //

    InitializeListHead(&Process->ReadyListHead);
    InitializeListHead(&Process->ThreadListHead);
    Process->ThreadQuantum = THREAD_QUANTUM;

    return;
}

KPRIORITY
KeSetPriorityProcess (
    IN PKPROCESS Process,
    IN KPRIORITY NewBase
    )

/*++

Routine Description:

    This function set the base priority of a process to a new value
    and adjusts the priority and base priority of all child threads
    as appropriate.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    NewBase - Supplies the new base priority of the process.

Return Value:

    The previous base priority of the process.

--*/

{

    KPRIORITY Adjustment;
    PLIST_ENTRY NextEntry;
    KPRIORITY NewPriority;
    KIRQL OldIrql;
    KPRIORITY OldBase;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Save the current process base priority, set the new process base
    // priority, compute the adjustment value, and adjust the priority
    // and base priority of all child threads as appropriate.
    //

    OldBase = Process->BasePriority;
    Process->BasePriority = (SCHAR)NewBase;
    Adjustment = NewBase - OldBase;
    NextEntry = Process->ThreadListHead.Flink;
    if (NewBase >= LOW_REALTIME_PRIORITY) {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // Compute the new base priority of the thread.
            //

            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the realtime class,
            // then limit the change to the realtime class.
            //

            if (NewPriority < LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY;

            } else if (NewPriority > HIGH_PRIORITY) {
                NewPriority = HIGH_PRIORITY;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the appropriate value.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from variable to realtime, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase < LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = HIGH_PRIORITY;

                } else if (Thread->Saturation < 0) {
                    NewPriority = LOW_REALTIME_PRIORITY;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Process->ThreadQuantum;
                Thread->DecrementCount = 0;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            NextEntry = NextEntry->Flink;
        }

    } else {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // Compute the new base priority of the thread.
            //

            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the variable class,
            // then limit the change to the variable class.
            //

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;

            } else if (NewPriority <= LOW_PRIORITY) {
                NewPriority = 1;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the computed value and reset the thread quantum.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from realtime to variable, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase >= LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = LOW_REALTIME_PRIORITY - 1;

                } else if (Thread->Saturation < 0) {
                    NewPriority = 1;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Process->ThreadQuantum;
                Thread->DecrementCount = 0;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            NextEntry = NextEntry->Flink;
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous process base priority
    //

    return OldBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\raisexcp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisexcp.c

Abstract:

    This module implements the internal kernel code to continue execution
    and raise a exception.

Author:

    David N. Cutler (davec) 8-Aug-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context frame to the
    specified exception and trap frames for the continue system service.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if the context record is not readable
        from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the context record is not
        properly aligned.

    STATUS_SUCCESS is returned if the context frame is copied successfully
        to the specified exception and trap frames.

--*/

{
    KIRQL OldIrql;
    BOOLEAN IrqlChanged = FALSE;

    //
    // Synchronize with other context operations.
    //

    if (KeGetCurrentIrql() < APC_LEVEL) {

        //
        // To support try-except and ExRaiseStatus in device driver code we
        // need to check if we are already at raised level.
        //

        IrqlChanged = TRUE;
        KeRaiseIrql(APC_LEVEL, &OldIrql);
    }

    //
    // Move information from the context record to the exception
    // and trap frames.
    //

    KeContextToKframes(TrapFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags);

    if (IrqlChanged) {
        KeLowerIrql (OldIrql);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to raise an exception. The exception can be
    raised as a first or second chance exception.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if either the exception or the context
        record is not readable from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the exception record or the
        context record are not properly aligned.

    STATUS_INVALID_PARAMETER is returned if the number of exception parameters
        is greater than the maximum allowable number of exception parameters.

    STATUS_SUCCESS is returned if the exception is dispatched and handled.

--*/

{

    //
    // Move information from the context record to the exception and
    // trap frames.
    //

    KeContextToKframes(TrapFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags);

    //
    // Make sure the reserved bit is clear in the exception code and
    // perform exception dispatching.
    //
    // N.B. The reserved bit is used to differentiate internally gerarated
    //      codes from codes generated by application programs.
    //

    ExceptionRecord->ExceptionCode &= 0xefffffff;
    KiDispatchException(ExceptionRecord,
                        ExceptionFrame,
                        TrapFrame,
                        FirstChance);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\mutntobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mutntobj.c

Abstract:

    This module implements the kernel mutant object. Functions are
    provided to initialize, read, and release mutant objects.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Author:

    David N. Cutler (davec) 16-Oct-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input mutant is
// really a kmutant and not something else, like deallocated pool.
//

#define ASSERT_MUTANT(E) {                    \
    ASSERT((E)->Header.Type == MutantObject); \
}

VOID
KeInitializeMutant (
    IN PRKMUTANT Mutant,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function initializes a kernel mutant object.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    InitialOwner - Supplies a boolean value that determines whether the
        current thread is to be the initial owner of the mutant object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY ListEntry;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    //
    // Initialize standard dispatcher object header, set the owner thread to
    // NULL, set the abandoned state to FALSE, and set the APC disable count
    // to zero (this is the only thing that distinguishes a mutex from a mutant).
    //

    Mutant->Header.Type = MutantObject;
    Mutant->Header.Size = sizeof(KMUTANT) / sizeof(LONG);
    if (InitialOwner == TRUE) {
        Thread = KeGetCurrentThread();
        Mutant->Header.SignalState = 0;
        Mutant->OwnerThread = Thread;
        KiLockDispatcherDatabase(&OldIrql);
        ListEntry = Thread->MutantListHead.Blink;
        InsertHeadList(ListEntry, &Mutant->MutantListEntry);
        KiUnlockDispatcherDatabase(OldIrql);

    } else {
        Mutant->Header.SignalState = 1;
        Mutant->OwnerThread = (PKTHREAD)NULL;
    }

    InitializeListHead(&Mutant->Header.WaitListHead);
    Mutant->Abandoned = FALSE;
    return;
}

LONG
KeReleaseMutant (
    IN PRKMUTANT Mutant,
    IN KPRIORITY Increment,
    IN BOOLEAN Abandoned,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a mutant object by incrementing the mutant
    count. If the resultant value is one, then an attempt is made to
    satisfy as many Waits as possible. The previous signal state of
    the mutant is returned as the function value. If the Abandoned
    parameter is TRUE, then the mutant object is released by settings
    the signal state to one.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    Increment - Supplies the priority increment that is to be applied
        if setting the event causes a Wait to be satisfied.

    Abandoned - Supplies a boolean value that signifies whether the
        mutant object is being abandoned.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseMutant will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the mutant object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;


    ASSERT_MUTANT(Mutant);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the mutant object.
    //

    OldState = Mutant->Header.SignalState;

    //
    // If the Abandoned parameter is TRUE, then force the release of the
    // mutant object by setting its ownership count to one and setting its
    // abandoned state to TRUE. Otherwise increment mutant ownership count.
    // If the result count is one, then remove the mutant object from the
    // thread's owned mutant list, set the owner thread to NULL, and attempt
    // to satisfy a Wait for the mutant object if the mutant object wait
    // list is not empty.
    //

    Thread = KeGetCurrentThread();
    if (Abandoned != FALSE) {
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;

    } else {

        //
        // If the Mutant object is not owned by the current thread, then
        // unlock the dispatcher data base and raise an exception. Otherwise
        // increment the ownership count.
        //

        if (Mutant->OwnerThread != Thread) {
            KiUnlockDispatcherDatabase(OldIrql);
            ExRaiseStatus(Mutant->Abandoned ?
                          STATUS_ABANDONED : STATUS_MUTANT_NOT_OWNED);
        }

        Mutant->Header.SignalState += 1;
    }

    if (Mutant->Header.SignalState == 1) {
        if (OldState <= 0) {
            RemoveEntryList(&Mutant->MutantListEntry);
        }

        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) == FALSE) {
            KiWaitTest(Mutant, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to
    // caller with IRQL raised and the dispatcher database locked.
    // Else release the dispatcher database lock and lower IRQL to
    // its previous value.
    //

    if (Wait != FALSE) {
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of mutant object.
    //

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\kiinit.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kiinit.c

Abstract:

    This module implements architecture independent kernel initialization.

Author:

    David N. Cutler 11-May-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiInitSystem (
    VOID
    )
/*++

Routine Description:

    This function initializes architecture independent kernel structures.

Arguments:

    None.

Return Value:

    None.

--*/
{

    ULONG Index;

    //
    // Initialize dispatcher ready queue listheads.
    //

    for (Index = 0; Index < MAXIMUM_PRIORITY; Index += 1) {
        InitializeListHead(&KiDispatcherReadyListHead[Index]);
    }

    //
    // Initialize the timer expiration DPC object.
    //

    KeInitializeDpc(&KiTimerExpireDpc,
                    (PKDEFERRED_ROUTINE)KiTimerExpiration, NIL);

    //
    // Initialize the timer table, the timer completion listhead, and the
    // timer completion DPC.
    //

    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
        InitializeListHead(&KiTimerTableListHead[Index]);
    }

    //
    // Initialize the wait listhead.
    //

    InitializeListHead(&KiWaitInListHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\miscc.c ===
/*++

Copyright (c) 1989-1992  Microsoft Corporation

Module Name:

    miscc.c

Abstract:

    This module implements machine independent miscellaneous kernel functions.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#undef KeEnterCriticalRegion
VOID
KeEnterCriticalRegion (
   VOID
   )

/*++

Routine Description:

   This function disables kernel APC's.

   N.B. The following code does not require any interlocks. There are
        two cases of interest: 1) On an MP system, the thread cannot
        be running on two processors as once, and 2) if the thread is
        is interrupted to deliver a kernel mode APC which also calls
        this routine, the values read and stored will stack and unstack
        properly.

Arguments:

   None.

Return Value:

   None.

--*/

{
    //
    // Simply directly disable kernel APCs.
    //

    KeGetCurrentThread()->KernelApcDisable -= 1;
}

#undef KeLeaveCriticalRegion
VOID
KeLeaveCriticalRegion (
    VOID
    )

/*++

Routine Description:

    This function enables kernel APC's and requests an APC interrupt if
    appropriate.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Increment the kernel APC disable count. If the resultant count is
    // zero and the thread's kernel APC List is not empty, then request an
    // APC interrupt.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that queuing an APC is done by first queuing the APC, then checking
    // the AST disable count. The following code increments the disable
    // count first, checks to determine if it is zero, and then checks the
    // kernel AST queue.
    //
    // See also KiInsertQueueApc().
    //

    KiLeaveCriticalRegion();
}

ULONGLONG
KeQueryInterruptTime (
    VOID
    )

/*++

Routine Description:

    This function returns the current interrupt time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{
    LARGE_INTEGER CurrentTime;

    KiQueryInterruptTime(&CurrentTime);
    return CurrentTime.QuadPart;
}

VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function returns the current system time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{
    LARGE_INTEGER StackCurrentTime;

    KiQuerySystemTime(&StackCurrentTime);
    *CurrentTime = StackCurrentTime;
}

VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    )

/*++

Routine Description:

    This function sets the system time to the specified value and updates
    timer queue entries to reflect the difference between the old system
    time and the new system time.

Arguments:

    NewTime - Supplies a pointer to a variable that specifies the new system
        time.

    OldTime - Supplies a pointer to a variable that will receive the previous
        system time.

Return Value:

    None.

--*/

{

    LIST_ENTRY AbsoluteListHead;
    LIST_ENTRY ExpiredListHead;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql1;
    KIRQL OldIrql2;
    LARGE_INTEGER TimeDelta;
    PKTIMER Timer;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Set affinity to the processor that keeps the system time, raise IRQL
    // to dispatcher level and lock the dispatcher database, then raise IRQL
    // to HIGH_LEVEL to synchronize with the clock interrupt routine.
    //

    KiLockDispatcherDatabase(&OldIrql1);
    KeRaiseIrql(HIGH_LEVEL, &OldIrql2);

    //
    // Save the previous system time, set the new system time, and set
    // the realtime clock, if a time value is specified.
    //

    KiQuerySystemTime(OldTime);

    KeSystemTime.High2Time = NewTime->HighPart;
    KeSystemTime.LowPart   = NewTime->LowPart;
    KeSystemTime.High1Time = NewTime->HighPart;

    //
    // Compute the difference between the previous system time and the new
    // system time.
    //

    TimeDelta.QuadPart = NewTime->QuadPart - OldTime->QuadPart;

    //
    // Update the boot time to reflect the delta. This keeps time based
    // on boot time constant
    //

    KeBootTime.QuadPart = KeBootTime.QuadPart + TimeDelta.QuadPart;

    //
    // Track the overall bias applied to the boot time.
    //

    KeBootTimeBias = KeBootTimeBias + TimeDelta.QuadPart;

    //
    // Lower IRQL to dispatch level and if needed adjust the physical
    // system interrupt time.
    //

    KeLowerIrql(OldIrql2);

    //
    // Remove all absolute timers from the timer queue so their due time
    // can be recomputed.
    //

    InitializeListHead(&AbsoluteListHead);
    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            NextEntry = NextEntry->Flink;
            if (Timer->Header.Absolute != FALSE) {
                RemoveEntryList(&Timer->TimerListEntry);
                InsertTailList(&AbsoluteListHead, &Timer->TimerListEntry);
            }
        }
    }

    //
    // Recompute the due time and reinsert all absolute timers in the timer
    // tree. If a timer has already expired, then insert the timer in the
    // expired timer list.
    //

    InitializeListHead(&ExpiredListHead);
    while (AbsoluteListHead.Flink != &AbsoluteListHead) {
        Timer = CONTAINING_RECORD(AbsoluteListHead.Flink, KTIMER, TimerListEntry);
        KiRemoveTreeTimer(Timer);
        Timer->DueTime.QuadPart -= TimeDelta.QuadPart;
        if (KiReinsertTreeTimer(Timer, Timer->DueTime) == FALSE) {
            Timer->Header.Inserted = TRUE;
            InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
        }
    }

    //
    // If any of the attempts to reinsert a timer failed, then timers have
    // already expired and must be processed.
    //
    // N.B. The following function returns with the dispatcher database
    //      unlocked.
    //

    KiTimerListExpire(&ExpiredListHead, OldIrql1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\queueobj.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    queueobj.c

Abstract:

    This module implements the kernel queue object. Functions are
    provided to initialize, read, insert, and remove queue objects.

Author:

    David N. Cutler (davec) 31-Dec-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_QUEUE(Q) ASSERT((Q)->Header.Type == QueueObject);

VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    )

/*++

Routine Description:

    This function initializes a kernel queue object.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

    Count - Supplies the target maximum number of threads that should
        be concurrently active. If this parameter is not specified,
        then the number of processors is used.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // state of queue object.
    //

    Queue->Header.Type = QueueObject;
    Queue->Header.Size = sizeof(KQUEUE) / sizeof(LONG);
    Queue->Header.SignalState = 0;
    InitializeListHead(&Queue->Header.WaitListHead);

    //
    // Initialize queue listhead, the thread list head, the current number
    // of threads, and the target maximum number of threads.
    //

    InitializeListHead(&Queue->EntryListHead);
    InitializeListHead(&Queue->ThreadListHead);
    Queue->CurrentCount = 0;
    if (ARGUMENT_PRESENT((PVOID)(ULONG_PTR)Count)) {
        Queue->MaximumCount = Count;

    } else {
        Queue->MaximumCount = 1;
    }

    return;
}

LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, FALSE);

    //
    // Unlock the dispather database, lower IRQL to the previous level, and
    // return signal state of Queue object.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldState;
}

LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, TRUE);

    //
    // Unlock the dispather database, lower IRQL to the previous level, and
    // return signal state of Queue object.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldState;
}

PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function removes the next entry from the Queue object entry
    list. If no list entry is available, then the calling thread is
    put in a wait state.

    N.B. The wait discipline for Queue object LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The address of the entry removed from the Queue object entry list or
    STATUS_TIMEOUT.

    N.B. These values can easily be distinguished by the fact that all
         addresses in kernel mode have the high order bit set.

--*/

{

    LARGE_INTEGER DueTime;
    PLIST_ENTRY Entry;
    LARGE_INTEGER NewTime;
    KIRQL OldIrql;
    PRKQUEUE OldQueue;
    PLARGE_INTEGER OriginalTime;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    KWAIT_BLOCK StackWaitBlock;
    PRKWAIT_BLOCK WaitBlock;
    LONG_PTR WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&OldIrql);
        Thread->WaitIrql = OldIrql;
    }

    //
    // Check if the thread is currently processing a queue entry and whether
    // the new queue is the same as the old queue.
    //

    OldQueue = Thread->Queue;
    Thread->Queue = Queue;
    if (Queue != OldQueue) {

        //
        // If the thread was previously associated with a queue, then remove
        // the thread from the old queue object thread list and attempt to
        // activate another thread.
        //

        Entry = &Thread->QueueListEntry;
        if (OldQueue != NULL) {
            RemoveEntryList(Entry);
            KiActivateWaiterQueue(OldQueue);
        }

        //
        // Insert thread in the thread list of the new queue that the thread
        // will be associate with.
        //

        InsertTailList(&Queue->ThreadListHead, Entry);

    } else {

        //
        // The previous and current queue are the same queue - decrement the
        // current number of threads.
        //

        Queue->CurrentCount -= 1;
    }

    //
    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the
    // middle of the wait or a kernel APC is pending on the first attempt
    // through the loop.
    //
    // If the Queue object entry list is not empty, then remove the next
    // entry from the Queue object entry list. Otherwise, wait for an entry
    // to be inserted in the queue.
    //

    OriginalTime = Timeout;
    WaitBlock = &StackWaitBlock;
    do {

        //
        // Check if there is a queue entry available and the current
        // number of active threads is less than target maximum number
        // of threads.
        //

        Entry = Queue->EntryListHead.Flink;
        if ((Entry != &Queue->EntryListHead) &&
            (Queue->CurrentCount < Queue->MaximumCount)) {

            //
            // Decrement the number of entires in the Queue object entry list,
            // increment the number of active threads, remove the next entry
            // rom the list, and set the forward link to NULL.
            //

            Queue->Header.SignalState -= 1;
            Queue->CurrentCount += 1;

            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            break;

        } else {

            //
            // Test to determine if a kernel APC is pending.
            //
            // If a kernel APC is pending and the previous IRQL was less than
            // APC_LEVEL, then a kernel APC was queued by another processor
            // just after IRQL was raised to DISPATCH_LEVEL, but before the
            // dispatcher database was locked.
            //
            // N.B. that this can only happen in a multiprocessor system.
            //

            if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

                //
                // Increment the current thread count, unlock the dispatcher
                // database, and lower IRQL to previous value. An APC interrupt
                // will immediately occur which will result in the delivery of
                // the kernel APC if possible.
                //

                Queue->CurrentCount += 1;
                KiUnlockDispatcherDatabase(Thread->WaitIrql);

            } else {

                //
                // Test if a user APC is pending.
                //

                if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) {
                    Entry = (PLIST_ENTRY)ULongToPtr(STATUS_USER_APC);
                    Queue->CurrentCount += 1;
                    break;
                }

                //
                // Construct a wait block and check to determine if the wait
                // is already satisfied. If the wait is satisfied, then perform
                // wait completion and return. Else put current thread in a
                // wait state if an explicit timeout value of zero is not
                // specified.
                //

                Thread->WaitStatus = (NTSTATUS)0;
                Thread->WaitBlockList = WaitBlock;
                WaitBlock->Object = (PVOID)Queue;
                WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);
                WaitBlock->WaitType = WaitAny;
                WaitBlock->Thread = Thread;

                //
                // Check to determine if a timeout value is specified.
                //

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // If the timeout value is zero, then return immediately
                    // without waiting.
                    //

                    if (!(Timeout->LowPart | Timeout->HighPart)) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }

                    //
                    // Initialize a wait block for the thread specific timer,
                    // insert wait block in timer wait list, insert the timer
                    // in the timer tree.
                    //
                    // N.B. The timer wait block is initialized when the
                    //      respective thread is initialized. Thus the constant
                    //      fields are not reinitialized. These include the wait
                    //      object, wait key, wait type, and the wait list entry
                    //      link pointers.
                    //

                    Timer = &Thread->Timer;
                    WaitTimer = &Thread->TimerWaitBlock;
                    WaitBlock->NextWaitBlock = WaitTimer;
                    Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;
                    Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;
                    WaitTimer->NextWaitBlock = WaitBlock;
                    if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }

                    DueTime.QuadPart = Timer->DueTime.QuadPart;

                } else {
                    WaitBlock->NextWaitBlock = WaitBlock;
                }

                //
                // Insert wait block in object wait list.
                //

                InsertTailList(&Queue->Header.WaitListHead, &WaitBlock->WaitListEntry);

                //
                // Set the thread wait parameters, set the thread dispatcher
                // state to Waiting, and insert the thread in the wait list.
                //

                Thread->Alertable = FALSE;
                Thread->WaitMode = WaitMode;
                Thread->WaitReason = WrQueue;
                Thread->WaitTime = KiQueryLowTickCount();
                Thread->State = Waiting;
                KiInsertWaitList(WaitMode, Thread);

                //
                // Switch context to selected thread.
                //
                // Control is returned at the original IRQL.
                //

                ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                WaitStatus = KiSwapThread();

                //
                // If the thread was not awakened to deliver a kernel mode APC,
                // then return wait status.
                //

                Thread->WaitReason = 0;
                if (WaitStatus != STATUS_KERNEL_APC) {
                    return (PLIST_ENTRY)WaitStatus;
                }

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // Reduce the amount of time remaining before timeout occurs.
                    //

                    Timeout = KiComputeWaitInterval(OriginalTime,
                                                    &DueTime,
                                                    &NewTime);
                }
            }

            //
            // Raise IRQL to DISPATCH_LEVEL, lock the dispatcher database,
            // and decrement the count of active threads.
            //

            KiLockDispatcherDatabase(&OldIrql);
            Thread->WaitIrql = OldIrql;
            Queue->CurrentCount -= 1;
        }

    } while (TRUE);

    //
    // Unlock the dispatcher database and return the list entry address or a
    // status of timeout.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return Entry;
}

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function runs down the specified queue by removing the listhead
    from the queue list, removing any associated threads from the thread
    list, and returning the address of the first entry.


Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

Return Value:

    If the queue list is not empty, then the address of the first entry in
    the queue is returned as the function value. Otherwise, a value of NULL
    is returned.

--*/

{

    PLIST_ENTRY Entry;
    PLIST_ENTRY FirstEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatch level and lock the dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Get the address of the first entry in the queue and check if the
    // list is empty or contains entries that should be flushed. If there
    // are no entries in the list, then set the return value to NULL.
    // Otherwise, set the return value to the address of the first list
    // entry and remove the listhead from the list.
    //

    FirstEntry = Queue->EntryListHead.Flink;
    if (FirstEntry == &Queue->EntryListHead) {
        FirstEntry = NULL;

    } else {
        RemoveEntryList(&Queue->EntryListHead);
    }

    //
    // Remove all associated threads from the thread list of the queue.
    //

    while (Queue->ThreadListHead.Flink != &Queue->ThreadListHead) {
        Entry = Queue->ThreadListHead.Flink;
        Thread = CONTAINING_RECORD(Entry, KTHREAD, QueueListEntry);
        Thread->Queue = NULL;
        RemoveEntryList(Entry);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous level,
    // and return the function value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return FirstEntry;
}

VOID
FASTCALL
KiActivateWaiterQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function is called when the current thread is about to enter a
    wait state and is currently processing a queue entry. The current
    number of threads processign entries for the queue is decrement and
    an attempt is made to activate another thread if the current count
    is less than the maximum count, there is a waiting thread, and the
    queue is not empty.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

Return Value:

    None.

--*/

{

    PRLIST_ENTRY Entry;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PRLIST_ENTRY WaitEntry;

    //
    // Decrement the current count of active threads and check if another
    // thread can be activated. If the current number of active threads is
    // less than the target maximum number of threads, there is a entry in
    // in the queue, and a thread is waiting, then remove the entry from the
    // queue, decrement the number of entries in the queue, and unwait the
    // respectiive thread.
    //

    Queue->CurrentCount -= 1;
    if (Queue->CurrentCount < Queue->MaximumCount) {
        Entry = Queue->EntryListHead.Flink;
        WaitEntry = Queue->Header.WaitListHead.Blink;
        if ((Entry != &Queue->EntryListHead) &&
            (WaitEntry != &Queue->Header.WaitListHead)) {
            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            Queue->Header.SignalState -= 1;
            WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
            Thread = WaitBlock->Thread;
            KiUnwaitThread(Thread, (LONG_PTR)Entry, 0);
        }
    }

    return;
}

LONG
FASTCALL
KiInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry,
    IN BOOLEAN Head
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

    Head - Supplies a boolean value that determines whether the queue
        entry is inserted at the head or tail of the queue if it can
        not be immediately dispatched.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    LONG OldState;
    PRKTHREAD Thread;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    ASSERT_QUEUE(Queue);

    //
    // Capture the current signal state of queue object and check if there
    // is a thread waiting on the queue object, the current number of active
    // threads is less than the target number of threads, and the wait reason
    // of the current thread is not queue wait or the wait queue is not the
    // same queue as the insertion queue. If these conditions are satisfied,
    // then satisfy the thread wait and pass the thread the address of the
    // queue entry as the wait status. Otherwise, set the state of the queue
    // object to signaled and insert the specified entry in the queue object
    // entry list.
    //

    OldState = Queue->Header.SignalState;
    Thread = KeGetCurrentThread();
    WaitEntry = Queue->Header.WaitListHead.Blink;
    if ((WaitEntry != &Queue->Header.WaitListHead) &&
        (Queue->CurrentCount < Queue->MaximumCount) &&
        ((Thread->Queue != Queue) ||
        (Thread->WaitReason != WrQueue))) {

        //
        // Remove the last wait block from the wait list and get the address
        // of the waiting thread object.
        //

        RemoveEntryList(WaitEntry);
        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;

        //
        // Set the wait completion status, remove the thread from its wait
        // list, increment the number of active threads, and clear the wait
        // reason.
        //

        Thread->WaitStatus = (LONG_PTR)Entry;
        RemoveEntryList(&Thread->WaitListEntry);
        Queue->CurrentCount += 1;
        Thread->WaitReason = 0;

        //
        // If thread timer is still active, then cancel thread timer.
        //

        Timer = &Thread->Timer;
        if (Timer->Header.Inserted == TRUE) {
            KiRemoveTreeTimer(Timer);
        }

        //
        // Ready the thread for execution.
        //

        KiReadyThread(Thread);

    } else {
        Queue->Header.SignalState += 1;
        if (Head != FALSE) {
            InsertHeadList(&Queue->EntryListHead, Entry);

        } else {
            InsertTailList(&Queue->EntryListHead, Entry);
        }
    }

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\genxx.inc ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    genxx.inc

Abstract:

    This file contains common code to generate assembler definitions.

Author:

    David N. Cutler (davec) 9-Aug-1995

Revision History:

    Forrest C. Foltz (forrestf) 26-Jan-1998

        Modified for use with genxx.exe utility

--*/

    //
    // Size of a pointer in bytes.
    //

    genCom("Pointer size in bytes")

    genVal(SizeofPointer, sizeof(PVOID))

    //
    // Thread state enumerated type definitions.
    //

    genCom("Thread State Enumerated Type Values")

    genVal(Initialized, Initialized)
    genVal(Ready, Ready)
    genVal(Running, Running)
    genVal(Standby, Standby)
    genVal(Terminated, Terminated)
    genVal(Waiting, Waiting)

    //
    // Wait reason and wait type enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Wait Reason and Wait Type Enumerated Type Values")

    genVal(WrExecutive, Executive)

    DisableInc(HAL)

    genVal(WrEventPair, WrEventPair)
    genVal(WaitAny, WaitAny)
    genVal(WaitAll, WaitAll)

    //
    // APC state structure offset definitions.
    //

    genCom("Apc State Structure Offset Definitions")

    genDef(As, KAPC_STATE, ApcListHead)
    genDef(As, KAPC_STATE, Process)
    genDef(As, KAPC_STATE, KernelApcInProgress)
    genDef(As, KAPC_STATE, KernelApcPending)
    genDef(As, KAPC_STATE, UserApcPending)
    genDef(As, KAPC_STATE, ApcQueueable)

    //
    // Bug check code definitions
    //

    EnableInc(HAL)

    genCom("Bug Check Code Definitions")

    genVal(APC_INDEX_MISMATCH, APC_INDEX_MISMATCH)
    genVal(ATTEMPTED_FPU_USE_FROM_DPC, ATTEMPTED_FPU_USE_FROM_DPC)
    genVal(ATTEMPTED_SWITCH_FROM_DPC, ATTEMPTED_SWITCH_FROM_DPC)
    genVal(DATA_BUS_ERROR, DATA_BUS_ERROR)
    genVal(DATA_COHERENCY_EXCEPTION, DATA_COHERENCY_EXCEPTION)
    genVal(HAL1_INITIALIZATION_FAILED, HAL1_INITIALIZATION_FAILED)
    genVal(INSTRUCTION_BUS_ERROR, INSTRUCTION_BUS_ERROR)
    genVal(INSTRUCTION_COHERENCY_EXCEPTION, INSTRUCTION_COHERENCY_EXCEPTION)
    genVal(INTERRUPT_EXCEPTION_NOT_HANDLED, INTERRUPT_EXCEPTION_NOT_HANDLED)
    genVal(INTERRUPT_UNWIND_ATTEMPTED, INTERRUPT_UNWIND_ATTEMPTED)
    genVal(INVALID_AFFINITY_SET, INVALID_AFFINITY_SET)
    genVal(INVALID_DATA_ACCESS_TRAP, INVALID_DATA_ACCESS_TRAP)
    genVal(IRQL_GT_ZERO_AT_SYSTEM_SERVICE, IRQL_GT_ZERO_AT_SYSTEM_SERVICE)
    genVal(IRQL_NOT_LESS_OR_EQUAL, IRQL_NOT_LESS_OR_EQUAL)
    genVal(KMODE_EXCEPTION_NOT_HANDLED, KMODE_EXCEPTION_NOT_HANDLED)
    genVal(NMI_HARDWARE_FAILURE, NMI_HARDWARE_FAILURE)
    genVal(NO_USER_MODE_CONTEXT, NO_USER_MODE_CONTEXT)
    genVal(PAGE_FAULT_WITH_INTERRUPTS_OFF, PAGE_FAULT_WITH_INTERRUPTS_OFF)
    genVal(PANIC_STACK_SWITCH, PANIC_STACK_SWITCH)
    genVal(SPIN_LOCK_INIT_FAILURE, SPIN_LOCK_INIT_FAILURE)
    genVal(SYSTEM_EXIT_OWNED_MUTEX, SYSTEM_EXIT_OWNED_MUTEX)
    genVal(SYSTEM_SERVICE_EXCEPTION, SYSTEM_SERVICE_EXCEPTION)
    genVal(SYSTEM_UNWIND_PREVIOUS_USER, SYSTEM_UNWIND_PREVIOUS_USER)
    genVal(TRAP_CAUSE_UNKNOWN, TRAP_CAUSE_UNKNOWN)
    genVal(UNEXPECTED_KERNEL_MODE_TRAP, UNEXPECTED_KERNEL_MODE_TRAP)

    DisableInc(HAL)

    //
    // Breakpoint types
    //

    EnableInc(HAL)

    genCom("Breakpoint type definitions")

    genVal(DBG_STATUS_CONTROL_C, DBG_STATUS_CONTROL_C)

    DisableInc(HAL)

    //
    // Client Id structure offset definitions.
    //

    genCom("Client Id Structure Offset Definitions")

    genDef(Cid, CLIENT_ID, UniqueProcess)
    genDef(Cid, CLIENT_ID, UniqueThread)

    //
    // Critical section structure offset definitions.
    //

    genCom("Critical Section Structure Offset Definitions")

    genDef(Cs, RTL_CRITICAL_SECTION, LockCount)
    genDef(Cs, RTL_CRITICAL_SECTION, RecursionCount)
    genDef(Cs, RTL_CRITICAL_SECTION, OwningThread)

    //
    // File object strucutre offset definitions.
    //

    genCom("File Object Structure Offset Definitions")

    genDef(Fo, FILE_OBJECT, LockCount)
    genDef(Fo, FILE_OBJECT, Lock)

    //
    // Exception record offset, flag, and enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Exception Record Offset, Flag, and Enumerated Type Definitions")

    genVal(EXCEPTION_NONCONTINUABLE, EXCEPTION_NONCONTINUABLE)
    genVal(EXCEPTION_UNWINDING, EXCEPTION_UNWINDING)
    genVal(EXCEPTION_EXIT_UNWIND, EXCEPTION_EXIT_UNWIND)
    genVal(EXCEPTION_STACK_INVALID, EXCEPTION_STACK_INVALID)
    genVal(EXCEPTION_NESTED_CALL, EXCEPTION_NESTED_CALL)
    genVal(EXCEPTION_TARGET_UNWIND, EXCEPTION_TARGET_UNWIND)
    genVal(EXCEPTION_COLLIDED_UNWIND, EXCEPTION_COLLIDED_UNWIND)
    genVal(EXCEPTION_UNWIND, EXCEPTION_UNWIND)
    genVal(EXCEPTION_EXECUTE_HANDLER, EXCEPTION_EXECUTE_HANDLER)
    genVal(EXCEPTION_CONTINUE_SEARCH, EXCEPTION_CONTINUE_SEARCH)
    genVal(EXCEPTION_CONTINUE_EXECUTION, EXCEPTION_CONTINUE_EXECUTION)

#if defined(_X86_)

    genVal(EXCEPTION_CHAIN_END, (ULONG)EXCEPTION_CHAIN_END)

#endif

    genSpc()

    genVal(ExceptionContinueExecution, ExceptionContinueExecution)
    genVal(ExceptionContinueSearch, ExceptionContinueSearch)
    genVal(ExceptionNestedException, ExceptionNestedException)
    genVal(ExceptionCollidedUnwind, ExceptionCollidedUnwind)

    genSpc()

    genDef(Er, EXCEPTION_RECORD, ExceptionCode)
    genDef(Er, EXCEPTION_RECORD, ExceptionFlags)
    genDef(Er, EXCEPTION_RECORD, ExceptionRecord)
    genDef(Er, EXCEPTION_RECORD, ExceptionAddress)
    genDef(Er, EXCEPTION_RECORD, NumberParameters)
    genDef(Er, EXCEPTION_RECORD, ExceptionInformation)
    genVal(ExceptionRecordLength, (sizeof(EXCEPTION_RECORD) + 15) & (~15))

    DisableInc(HAL)

    //
    // Fast Mutex structure offset definitions.
    //

    EnableInc(HAL)

    //
    // Interrupt priority request level definitions
    //

    genCom("Interrupt Priority Request Level Definitions")

    genVal(PASSIVE_LEVEL, PASSIVE_LEVEL)
    genVal(APC_LEVEL, APC_LEVEL)
    genVal(DISPATCH_LEVEL, DISPATCH_LEVEL)

#if defined(_X86_)

    genVal(SCI_LEVEL, SCI_LEVEL)
    genVal(SMBUS_LEVEL, SMBUS_LEVEL)
    genVal(CLOCK_LEVEL, CLOCK_LEVEL)

#endif

    genVal(IPI_LEVEL, IPI_LEVEL)
    genVal(POWER_LEVEL, POWER_LEVEL)
    genVal(PROFILE_LEVEL, PROFILE_LEVEL)
    genVal(HIGH_LEVEL, HIGH_LEVEL)
    genVal(SYNCH_LEVEL, SYNCH_LEVEL)

    //
    // Large integer structure offset definitions.
    //

    genCom("Large Integer Structure Offset Definitions")

    genDef(Li, LARGE_INTEGER, LowPart)
    genDef(Li, LARGE_INTEGER, HighPart)

    //
    // List entry structure offset definitions.
    //

    genCom("List Entry Structure Offset Definitions")

    genDef(Ls, LIST_ENTRY, Flink)
    genDef(Ls, LIST_ENTRY, Blink)

    //
    // String structure offset definitions.
    //

    genCom("String Structure Offset Definitions")

    genDef(Str, STRING, Length)
    genDef(Str, STRING, MaximumLength)
    genDef(Str, STRING, Buffer)

    //
    // System time structure offset definitions.
    //

#if defined(_MIPS_) || defined(_PPC_) || defined(_X86_)

    genCom("System Time Structure Offset Definitions")

    genAlt(StLowTime, KSYSTEM_TIME, LowPart)
    genDef(St, KSYSTEM_TIME, High1Time)
    genDef(St, KSYSTEM_TIME, High2Time)

#endif

    //
    // Time structure offset definitions.
    //

    genCom("Time Structure Offset Definitions")

    genAlt(TmLowTime, LARGE_INTEGER, LowPart)
    genAlt(TmHighTime, LARGE_INTEGER , HighPart)

    DisableInc(HAL)

    //
    // Status code definitions
    //

    genCom("Status Code Definitions")

    genVal(STATUS_ACCESS_VIOLATION, STATUS_ACCESS_VIOLATION)
    genVal(STATUS_ALERTED, STATUS_ALERTED)
    genVal(STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED)
    genVal(STATUS_BAD_COMPRESSION_BUFFER, STATUS_BAD_COMPRESSION_BUFFER)
    genVal(STATUS_BREAKPOINT, STATUS_BREAKPOINT)
    genVal(STATUS_DATATYPE_MISALIGNMENT, STATUS_DATATYPE_MISALIGNMENT)
    genVal(STATUS_DEVICE_PROTOCOL_ERROR, STATUS_DEVICE_PROTOCOL_ERROR)
    genVal(STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND)
    genVal(STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO)
    genVal(STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT)
    genVal(STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION)
    genVal(STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW)
    genVal(STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK)
    genVal(STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW)
    genVal(STATUS_FLOAT_MULTIPLE_FAULTS, STATUS_FLOAT_MULTIPLE_FAULTS)
    genVal(STATUS_FLOAT_MULTIPLE_TRAPS, STATUS_FLOAT_MULTIPLE_TRAPS)
    genVal(STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION)
    genVal(STATUS_ILLEGAL_FLOAT_CONTEXT, STATUS_ILLEGAL_FLOAT_CONTEXT)
    genVal(STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION)
    genVal(STATUS_INSTRUCTION_MISALIGNMENT, STATUS_INSTRUCTION_MISALIGNMENT)
    genVal(STATUS_INVALID_HANDLE, STATUS_INVALID_HANDLE)
    genVal(STATUS_INVALID_LOCK_SEQUENCE, STATUS_INVALID_LOCK_SEQUENCE)
    genVal(STATUS_INVALID_OWNER, STATUS_INVALID_OWNER)
    genVal(STATUS_INVALID_PARAMETER, STATUS_INVALID_PARAMETER)
    genVal(STATUS_INVALID_PARAMETER_1, STATUS_INVALID_PARAMETER_1)
    genVal(STATUS_INVALID_SYSTEM_SERVICE, STATUS_INVALID_SYSTEM_SERVICE)
    genVal(STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO)
    genVal(STATUS_INTEGER_OVERFLOW, STATUS_INTEGER_OVERFLOW)
    genVal(STATUS_IN_PAGE_ERROR, STATUS_IN_PAGE_ERROR)
    genVal(STATUS_IO_DEVICE_ERROR, STATUS_IO_DEVICE_ERROR)
    genVal(STATUS_IO_TIMEOUT, STATUS_IO_TIMEOUT)
    genVal(STATUS_KERNEL_APC, STATUS_KERNEL_APC)
    genVal(STATUS_LONGJUMP, STATUS_LONGJUMP)
    genVal(STATUS_NO_CALLBACK_ACTIVE, STATUS_NO_CALLBACK_ACTIVE)
    genVal(STATUS_NO_EVENT_PAIR, STATUS_NO_EVENT_PAIR)
    genVal(STATUS_NO_MEMORY, STATUS_NO_MEMORY)
    genVal(STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION)
    genVal(STATUS_SINGLE_STEP, STATUS_SINGLE_STEP)
    genVal(STATUS_STACK_OVERFLOW, STATUS_STACK_OVERFLOW)
    genVal(STATUS_SUCCESS, STATUS_SUCCESS)
    genVal(STATUS_THREAD_IS_TERMINATING, STATUS_THREAD_IS_TERMINATING)
    genVal(STATUS_TIMEOUT, STATUS_TIMEOUT)
    genVal(STATUS_UNWIND, STATUS_UNWIND)
    genVal(STATUS_WAKE_SYSTEM_DEBUGGER, STATUS_WAKE_SYSTEM_DEBUGGER)

    //
    // Define kernel object structure definitions.
    //
    // APC object structure defintions.
    //

    genCom("APC Object Structure Offset Definitions")

    genDef(Ap, KAPC, Type)
    genDef(Ap, KAPC, ApcMode)
    genDef(Ap, KAPC, Inserted)
    genDef(Ap, KAPC, Thread)
    genDef(Ap, KAPC, ApcListEntry)
    genDef(Ap, KAPC, KernelRoutine)
    genDef(Ap, KAPC, RundownRoutine)
    genDef(Ap, KAPC, NormalRoutine)
    genDef(Ap, KAPC, NormalContext)
    genDef(Ap, KAPC, SystemArgument1)
    genDef(Ap, KAPC, SystemArgument2)
    genVal(ApcObjectLength, sizeof(KAPC))

    //
    // DPC Object structure definitions.
    //

    EnableInc(HAL)

    genCom("DPC object Structure Offset Definitions")

    genDef(Dp, KDPC, Type)
    genDef(Dp, KDPC, Inserted)
    genDef(Dp, KDPC, DpcListEntry)
    genDef(Dp, KDPC, DeferredRoutine)
    genDef(Dp, KDPC, DeferredContext)
    genDef(Dp, KDPC, SystemArgument1)
    genDef(Dp, KDPC, SystemArgument2)
    genVal(DpcObjectLength, sizeof(KDPC))

    DisableInc(HAL)

    //
    // Device queue object structure definitions.
    //

    genCom("Device Queue Object Structure Offset Definitions")

    genDef(Dv, KDEVICE_QUEUE, Type)
    genDef(Dv, KDEVICE_QUEUE, Size)
    genDef(Dv, KDEVICE_QUEUE, Busy)
    genDef(Dv, KDEVICE_QUEUE, DeviceListHead)
    genVal(DeviceQueueObjectLength, sizeof(KDEVICE_QUEUE))

    //
    // Device object entry structure definitions.
    //

    genCom("Device Queue Entry Structure Offset Definitions")

    genDef(De, KDEVICE_QUEUE_ENTRY, DeviceListEntry)
    genDef(De, KDEVICE_QUEUE_ENTRY, SortKey)
    genDef(De, KDEVICE_QUEUE_ENTRY, Inserted)
    genVal(DeviceQueueEntryLength, sizeof(KDEVICE_QUEUE_ENTRY))

    //
    // Event object structure definitions.
    //

    genCom("Event Object Structure Offset Definitions")

    genDef(Ev, DISPATCHER_HEADER, Type)
    genDef(Ev, DISPATCHER_HEADER, Size)
    genDef(Ev, DISPATCHER_HEADER, SignalState)
    genAlt(EvWaitListHead, KEVENT, Header.WaitListHead)
    genVal(EventObjectLength, sizeof(KEVENT))

    //
    // Interrupt object structure definitions.
    //

    genCom("Interrupt Object Structure Offset Definitions")

    genVal(InLevelSensitive, LevelSensitive)
    genVal(InLatched, Latched)

    genSpc()

    genDef(In, KINTERRUPT, ServiceRoutine)
    genDef(In, KINTERRUPT, ServiceContext)
    genDef(In, KINTERRUPT, BusInterruptLevel)
    genDef(In, KINTERRUPT, Irql)
    genDef(In, KINTERRUPT, Connected)
    genDef(In, KINTERRUPT, Mode)
    genDef(In, KINTERRUPT, ShareVector)
    genDef(In, KINTERRUPT, DispatchCode)
    genVal(InterruptObjectLength, sizeof(KINTERRUPT))

#if defined(_X86_)

    genSpc()

    genVal(NORMAL_DISPATCH_LENGTH, NORMAL_DISPATCH_LENGTH * sizeof(ULONG))
    genVal(DISPATCH_LENGTH, DISPATCH_LENGTH * sizeof(ULONG))

#endif

    //
    // Process object structure offset definitions.
    //

    genCom("Process Object Structure Offset Definitions")

    genDef(Pr, DISPATCHER_HEADER, Type)
    genDef(Pr, DISPATCHER_HEADER, Size)
    genDef(Pr, DISPATCHER_HEADER, SignalState)

    genDef(Pr, KPROCESS, ReadyListHead)
    genDef(Pr, KPROCESS, ThreadListHead)
    genDef(Pr, KPROCESS, StackCount)
    genDef(Pr, KPROCESS, BasePriority)
    genDef(Pr, KPROCESS, ThreadQuantum)
    genVal(ProcessObjectLength, ((sizeof(KPROCESS) + 15) & ~15))

    //
    // Queue object structure offset definitions.
    //

    genCom("Queue Object Structure Offset Definitions")

    genDef(Qu, DISPATCHER_HEADER, Type)
    genDef(Qu, DISPATCHER_HEADER, Size)
    genDef(Qu, DISPATCHER_HEADER, SignalState)
    genDef(Qu, KQUEUE, EntryListHead)
    genDef(Qu, KQUEUE, CurrentCount)
    genDef(Qu, KQUEUE, MaximumCount)
    genDef(Qu, KQUEUE, ThreadListHead)
    genVal(QueueObjectLength, sizeof(KQUEUE))

    //
    // Thread object structure offset definitions
    //

    genCom("Thread Object Structure Offset Definitions")

    genDef(Et, ETHREAD, UniqueThread)
    genVal(EtEthreadLength, ((sizeof(ETHREAD) + 15) & ~15))

    genSpc()

    genDef(Th, DISPATCHER_HEADER, Type)
    genDef(Th, DISPATCHER_HEADER, Size)
    genDef(Th, DISPATCHER_HEADER, SignalState)
    genDef(Th, KTHREAD, MutantListHead)
    genDef(Th, KTHREAD, KernelTime)
    genDef(Th, KTHREAD, StackBase)
    genDef(Th, KTHREAD, StackLimit)
    genDef(Th, KTHREAD, KernelStack)
    genDef(Th, KTHREAD, TlsData)
    genDef(Th, KTHREAD, State)
    genDef(Th, KTHREAD, Alerted)
    genDef(Th, KTHREAD, Alertable)
    genDef(Th, KTHREAD, NpxState)
    genDef(Th, KTHREAD, Saturation)
    genDef(Th, KTHREAD, Priority)
    genDef(Th, KTHREAD, ApcState)
    genDef(Th, KTHREAD, ContextSwitches)
    genDef(Th, KTHREAD, WaitStatus)
    genDef(Th, KTHREAD, WaitIrql)
    genDef(Th, KTHREAD, WaitMode)
    genDef(Th, KTHREAD, WaitNext)
    genDef(Th, KTHREAD, WaitReason)
    genDef(Th, KTHREAD, WaitBlockList)
    genDef(Th, KTHREAD, WaitListEntry)
    genDef(Th, KTHREAD, WaitTime)
    genDef(Th, KTHREAD, KernelApcDisable)
    genDef(Th, KTHREAD, Quantum)
    genDef(Th, KTHREAD, BasePriority)
    genDef(Th, KTHREAD, DecrementCount)
    genDef(Th, KTHREAD, PriorityDecrement)
    genDef(Th, KTHREAD, DisableBoost)
    genDef(Th, KTHREAD, NpxIrql)
    genDef(Th, KTHREAD, SuspendCount)
    genDef(Th, KTHREAD, Preempted)
    genDef(TH, KTHREAD, HasTerminated)
    genDef(Th, KTHREAD, Queue)
    genDef(Th, KTHREAD, QueueListEntry)
    genDef(Th, KTHREAD, Timer)
    genDef(Th, KTHREAD, TimerWaitBlock)
    genDef(Th, KTHREAD, SuspendApc)
    genDef(Th, KTHREAD, SuspendSemaphore)
    genDef(Th, KTHREAD, ThreadListEntry)

    genVal(ThreadObjectLength, ((sizeof(KTHREAD) + 15) & ~15))
    genVal(ExtendedThreadObjectLength, ((sizeof(ETHREAD) + 15) & ~15))

    genSpc()

#if defined(_X86_)

    genVal(NPX_STATE_NOT_LOADED, NPX_STATE_NOT_LOADED)
    genVal(NPX_STATE_LOADED, NPX_STATE_LOADED)

#endif

    //
    // Timer object structure offset definitions
    //

    genCom("Timer object Structure Offset Definitions")

    genDef(Ti, DISPATCHER_HEADER, Type)
    genDef(Ti, DISPATCHER_HEADER, Size)
    genDef(Ti, DISPATCHER_HEADER, Inserted)
    genDef(Ti, DISPATCHER_HEADER, SignalState)
    genDef(Ti, KTIMER, DueTime)
    genDef(Ti, KTIMER, TimerListEntry)
    genDef(Ti, KTIMER, Dpc)
    genDef(Ti, KTIMER, Period)
    genVal(TimerObjectLength, sizeof(KTIMER))

    genSpc()

    genVal(TIMER_TABLE_SIZE, TIMER_TABLE_SIZE)

    //
    // Wait block structure offset definitions
    //

    genCom("Wait Block Structure Offset Definitions")

    genDef(Wb, KWAIT_BLOCK, WaitListEntry)
    genDef(Wb, KWAIT_BLOCK, Thread)
    genDef(Wb, KWAIT_BLOCK, Object)
    genDef(Wb, KWAIT_BLOCK, NextWaitBlock)
    genDef(Wb, KWAIT_BLOCK, WaitKey)
    genDef(Wb, KWAIT_BLOCK, WaitType)

    //
    // Wait block structure offset definitions
    //

    genCom("Reader/Writer Lock Structure Offset Definitions")

    genDef(Erw, ERWLOCK, LockCount)
    genDef(Erw, ERWLOCK, WritersWaitingCount)
    genDef(Erw, ERWLOCK, ReadersWaitingCount)
    genDef(Erw, ERWLOCK, ReadersEntryCount)
    genDef(Erw, ERWLOCK, WriterEvent)
    genDef(Erw, ERWLOCK, ReaderSemaphore)

    //
    // Common TEB structure offset definitions
    //

    genCom("Thread Environment Block Structure Offset Definitions")

    genDef(Te, NT_TIB, StackBase)
    genDef(Te, NT_TIB, StackLimit)
    genDef(Te, NT_TIB, FiberData)

    genVal(EVENT_INCREMENT,EVENT_INCREMENT)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\semphobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    semphobj.c

Abstract:

    This module implements the kernel semaphore object. Functions
    are provided to initialize, read, and release semaphore objects.

Author:

    David N. Cutler (davec) 28-Feb-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input semaphore is
// really a ksemaphore and not something else, like deallocated pool.
//

#define ASSERT_SEMAPHORE(E) {                    \
    ASSERT((E)->Header.Type == SemaphoreObject); \
}

VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    )

/*++

Routine Description:

    This function initializes a kernel semaphore object. The initial
    count and limit of the object are set to the specified values.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Count - Supplies the initial count value to be assigned to the
        semaphore.

    Limit - Supplies the maximum count value that the semaphore
        can attain.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // count and maximum count values.
    //

    Semaphore->Header.Type = SemaphoreObject;
    Semaphore->Header.Size = sizeof(KSEMAPHORE) / sizeof(LONG);
    Semaphore->Header.SignalState = Count;
    InitializeListHead(&Semaphore->Header.WaitListHead);
    Semaphore->Limit = Limit;
    return;
}

LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a semaphore by adding the specified adjustment
    value to the current semaphore count and attempts to satisfy as many
    Waits as possible. The previous signal state of the semaphore object
    is returned as the function value.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Increment - Supplies the priority increment that is to be applied
        if releasing the semaphore causes a Wait to be satisfied.

    Adjustment - Supplies value that is to be added to the current
        semaphore count.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseSemaphore will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the semaphore object.

--*/

{

    LONG NewState;
    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_SEMAPHORE( Semaphore );
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the semaphore object and
    // compute the new count value.
    //

    OldState = Semaphore->Header.SignalState;
    NewState = OldState + Adjustment;

    //
    // If the new state value is greater than the limit or a carry occurs,
    // then unlock the dispatcher database, and raise an exception.
    //

    if ((NewState > Semaphore->Limit) || (NewState < OldState)) {
        KiUnlockDispatcherDatabase(OldIrql);
        ExRaiseStatus(STATUS_SEMAPHORE_LIMIT_EXCEEDED);
    }

    //
    // Set the new signal state of the semaphore object and set the wait
    // next value. If the previous signal state was Not-Signaled (i.e.
    // the count was zero), and the wait queue is not empty, then attempt
    // to satisfy as many Waits as possible.
    //

    Semaphore->Header.SignalState = NewState;
    if ((OldState == 0) && (IsListEmpty(&Semaphore->Header.WaitListHead) == FALSE)) {
        KiWaitTest(Semaphore, Increment);
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of sempahore object.
    //

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=ke

TARGETNAME=ke
TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc;..\..\halx

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

SOURCES=..\apcobj.c   \
        ..\apcsup.c   \
        ..\bugcheck.c \
        ..\devquobj.c \
        ..\dpcobj.c   \
        ..\dpcsup.c   \
        ..\eventobj.c \
        ..\kernldat.c \
        ..\kiinit.c   \
        ..\miscc.c    \
        ..\mutntobj.c \
        ..\procobj.c  \
        ..\queueobj.c \
        ..\raisexcp.c \
        ..\semphobj.c \
        ..\thredobj.c \
        ..\thredsup.c \
        ..\timerobj.c \
        ..\timersup.c \
        ..\wait.c     \
        ..\waitsup.c  \
        ..\yield.c

NTTEST=
UMLIBS=$(BASEDIR)\public\sdk\lib\*\user32.lib
UMTEST=

NTTARGETFILES=

PRECOMPILED_INCLUDE=..\ki.h
PRECOMPILED_PCH=ki.pch
PRECOMPILED_OBJ=ki.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\timersup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timersup.c

Abstract:

    This module contains the support routines for the timer object. It
    contains functions to insert and remove from the timer queue.

Author:

    David N. Cutler (davec) 13-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define forward referenced function prototypes.
//

LOGICAL
FASTCALL
KiInsertTimerTable (
    LARGE_INTEGER Interval,
    LARGE_INTEGER CurrentTime,
    IN PRKTIMER Timer
    );

LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PRKTIMER Timer,
    IN LARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function inserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Interval - Supplies the absolute or relative time at which the time
        is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER TimeDifference;

    //
    // Clear the signal state of timer if the timer period is zero and set
    // the inserted state to TRUE.
    //

    Timer->Header.Inserted = TRUE;
    Timer->Header.Absolute = FALSE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // If the specified interval is not a relative time (i.e., is an absolute
    // time), then convert it to relative time.
    //

    if (Interval.HighPart >= 0) {
        KiQuerySystemTime(&SystemTime);
        TimeDifference.QuadPart = SystemTime.QuadPart - Interval.QuadPart;

        //
        // If the resultant relative time is greater than or equal to zero,
        // then the timer has already expired.
        //

        if (TimeDifference.HighPart >= 0) {
            Timer->Header.SignalState = TRUE;
            Timer->Header.Inserted = FALSE;
            return FALSE;
        }

        Interval = TimeDifference;
        Timer->Header.Absolute = TRUE;
    }

    //
    // Get the current interrupt time, insert the timer in the timer table,
    // and return the inserted state.
    //

    KiQueryInterruptTime(&CurrentTime);
    return KiInsertTimerTable(Interval, CurrentTime, Timer);
}

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PRKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    )

/*++

Routine Description:

    This function reinserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies the absolute time the timer is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Interval;

    //
    // Clear the signal state of timer if the timer period is zero and set
    // the inserted state to TRUE.
    //

    Timer->Header.Inserted = TRUE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // Compute the interval between the current time and the due time.
    // If the resultant relative time is greater than or equal to zero,
    // then the timer has already expired.
    //

    KiQueryInterruptTime(&CurrentTime);
    Interval.QuadPart = CurrentTime.QuadPart - DueTime.QuadPart;
    if (Interval.QuadPart >= 0) {
        Timer->Header.SignalState = TRUE;
        Timer->Header.Inserted = FALSE;
        return FALSE;
    }

    //
    // Insert the timer in the timer table and return the inserted state.
    //

    return KiInsertTimerTable(Interval, CurrentTime, Timer);
}

LOGICAL
FASTCALL
KiInsertTimerTable (
    LARGE_INTEGER Interval,
    LARGE_INTEGER CurrentTime,
    IN PRKTIMER Timer
    )

/*++

Routine Description:

    This function inserts a timer object in the timer table.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Interval - Supplies the relative timer before the timer is to expire.

    CurrentTime - supplies the current interrupt time.

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PRKTIMER NextTimer;
    ULONG SearchCount;

    //
    // Compute the timer table index and set the timer expiration time.
    //

    Index = KiComputeTimerTableIndex(Interval, CurrentTime, Timer);

    //
    // If the timer is due before the first entry in the computed list
    // or the computed list is empty, then insert the timer at the front
    // of the list and check if the timer has already expired. Otherwise,
    // insert then timer in the sorted order of the list searching from
    // the back of the list forward.
    //
    // N.B. The sequence of operations below is critical to avoid the race
    //      condition that exists between this code and the clock interrupt
    //      code that examines the timer table lists to detemine when timers
    //      expire.
    //

    ListHead = &KiTimerTableListHead[Index];
    NextEntry = ListHead->Blink;

#if DBG

    SearchCount = 0;

#endif

    while (NextEntry != ListHead) {

        //
        // Compute the maximum search count.
        //

#if DBG

        SearchCount += 1;
        if (SearchCount > KiMaximumSearchCount) {
            KiMaximumSearchCount = SearchCount;
        }

#endif

        NextTimer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
        if (((Timer->DueTime.HighPart == NextTimer->DueTime.HighPart) &&
            (Timer->DueTime.LowPart >= NextTimer->DueTime.LowPart)) ||
            (Timer->DueTime.HighPart > NextTimer->DueTime.HighPart)) {
            InsertHeadList(NextEntry, &Timer->TimerListEntry);
            return TRUE;
        }

        NextEntry = NextEntry->Blink;
    }

    //
    // The computed list is empty or the timer is due to expire before
    // the first entry in the list. Insert the entry in the computed
    // timer table list, then check if the timer has expired.
    //
    // Note that it is critical that the interrupt time not be captured
    // until after the timer has been completely inserted into the list.
    //
    // Otherwise, the clock interrupt code can think the list is empty,
    // and the code here that checks if the timer has expired will use
    // a stale interrupt time.
    //

    InsertHeadList(ListHead, &Timer->TimerListEntry);
    KiQueryInterruptTime(&CurrentTime);
    if (((Timer->DueTime.HighPart == (ULONG)CurrentTime.HighPart) &&
        (Timer->DueTime.LowPart <= CurrentTime.LowPart)) ||
        (Timer->DueTime.HighPart < (ULONG)CurrentTime.HighPart)) {

        //
        // The timer is due to expire before the current time. Remove the
        // timer from the computed list, set its status to Signaled, set
        // its inserted state to FALSE, and
        //

        KiRemoveTreeTimer(Timer);
        Timer->Header.SignalState = TRUE;
    }

    return Timer->Header.Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\timerobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timerobj.c

Abstract:

    This module implements the kernel timer object. Functions are
    provided to initialize, read, set, and cancel timer objects.

Author:

    David N. Cutler (davec) 2-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input timer is
// really a ktimer and not something else, like deallocated pool.
//

#define ASSERT_TIMER(E) {                                     \
    ASSERT(((E)->Header.Type == TimerNotificationObject) ||   \
           ((E)->Header.Type == TimerSynchronizationObject)); \
}

VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    )

/*++

Routine Description:

    This function initializes an extended kernel timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Type - Supplies the type of timer object; NotificationTimer or
        SynchronizationTimer;

Return Value:

    None.

--*/

{
    //
    // Initialize standard dispatcher object header and set initial
    // state of timer.
    //

    Timer->Header.Type = (UCHAR)(TimerNotificationObject + Type);
    Timer->Header.Inserted = FALSE;
    Timer->Header.Size = sizeof(KTIMER) / sizeof(LONG);
    Timer->Header.SignalState = FALSE;

#if DBG

    Timer->TimerListEntry.Flink = NULL;
    Timer->TimerListEntry.Blink = NULL;

#endif

    InitializeListHead(&Timer->Header.WaitListHead);
    Timer->DueTime.QuadPart = 0;
    Timer->Period = 0;
    return;
}

BOOLEAN
KeCancelTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function cancels a timer that was previously set to expire at
    a specified time. If the timer is not currently set, then no operation
    is performed. Canceling a timer does not set the state of the timer to
    Signaled.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock the dispatcher database, and
    // capture the timer inserted status. If the timer is currently set,
    // then remove it from the timer list.
    //

    KiLockDispatcherDatabase(&OldIrql);
    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return boolean value that signifies whether the timer was set of not.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}

BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    //
    // Set the timer with a period of zero.
    //

    return KeSetTimerEx(Timer, DueTime, 0, Dpc);
}

BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Period - Supplies an optional period for the timer in milliseconds.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    LARGE_INTEGER SystemTime;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the timer inserted status and if the timer is currently
    // set, then remove it from the timer list.
    //

    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Clear the signal state, set the period, set the DPC address, and
    // insert the timer in the timer tree. If the timer is not inserted
    // in the timer tree, then it has already expired and as many waiters
    // as possible should be continued, and a DPC, if specified should be
    // queued.
    //
    // N.B. The signal state must be cleared in case the period is not
    //      zero.
    //

    Timer->Header.SignalState = FALSE;
    Timer->Dpc = Dpc;
    Timer->Period = Period;
    if (KiInsertTreeTimer((PRKTIMER)Timer, DueTime) == FALSE) {
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            KiWaitTest(Timer, TIMER_EXPIRE_INCREMENT);
        }

        //
        // If a DPC is specfied, then call the DPC routine.
        //

        if (Dpc != NULL) {
            KiQuerySystemTime(&SystemTime);
            KeInsertQueueDpc(Timer->Dpc,
                             ULongToPtr(SystemTime.LowPart),
                             ULongToPtr(SystemTime.HighPart));
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer in the table. If this happens,
        //      try again.
        //

        if (Period != 0) {
            Interval.QuadPart = Int32x32To64(Timer->Period, - 10 * 1000);
            while (!KiInsertTreeTimer(Timer, Interval)) {
                ;
            }
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return boolean value that signifies whether the timer was set of
    // not.
    //

    return Inserted;
}

ULONGLONG
KeQueryTimerDueTime (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function returns the InterruptTime at which the timer is
    pending.   0 is returned if the timer is not pending.

    N.B. This function may only be called by the system sleep code.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    Returns the amount of time remaining on the timer, or 0 if the
    timer is not pending.

--*/

{

    KIRQL OldIrql;
    ULONGLONG DueTime;

    ASSERT_TIMER(Timer);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the timer is currently pending, compute its due time
    //

    DueTime = 0;
    if (Timer->Header.Inserted) {
        DueTime = Timer->DueTime.QuadPart;
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value, and return the due time
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return DueTime;
}

PVOID
KeCheckForTimer(
    IN PVOID BlockStart,
    IN ULONG BlockSize
    )
/*++

Routine Description:

    This function is used for debugging by checking all timers
    to see if any is in the memory block passed.  If so, the
    system stops at a debug breakpoint.

Arguments:

    MemoryBlock - Base address to check for timer

    BlockSize - Size (in bytes) to check in memory block

Return Value:

    The address of the currently active timer.

--*/
{
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;
    PUCHAR Address;
    PUCHAR Start;
    PUCHAR End;

    //
    // Compute the ending memory location.
    //

    Start = (PUCHAR)BlockStart;
    End = Start + BlockSize;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Run the entire timer database and check for any timers in
    // the memory block
    //

    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            Address = (PUCHAR)Timer;
            NextEntry = NextEntry->Flink;

            //
            // Check this timer object is not in the range.
            // In each of the following, we check that the object
            // does not overlap the range, for example, if the timer
            // object (in this first check), starts one dword before
            // the range being checked, we have an overlap and should
            // stop.
            //

            if ((Address > (Start - sizeof(KTIMER))) &&
                (Address < End)) {
                KeBugCheckEx(TIMER_OR_DPC_INVALID,
                             0x0,
                             (ULONG_PTR)Address,
                             (ULONG_PTR)Start,
                             (ULONG_PTR)End);
            }

            if (Timer->Dpc) {

                //
                // Check the timer's DPC object isn't in the range.
                //

                Address = (PUCHAR)Timer->Dpc;
                if ((Address > (Start - sizeof(KDPC))) &&
                    (Address < End)) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x1,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }

                //
                // Check the timer's DPC routine is not in the range.
                //

                Address = (PUCHAR)(ULONG_PTR)Timer->Dpc->DeferredRoutine;
                if (Address >= Start && Address < End) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x2,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);


    //
    // Unlock the dispatcher database and lower IRQL to its previous value
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\thredsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    thredsup.c

Abstract:

    This module contains the support routines for the thread object. It
    contains functions to boost the priority of a thread, find a ready
    thread, select the next thread, ready a thread, set priority of a
    thread, and to suspend a thread.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    All of the functions in this module execute in kernel mode except
    the function that raises a user mode alert condition.

Revision History:


--*/

#include "ki.h"

//
// Define context switch data collection macro.
//

//#define _COLLECT_SWITCH_DATA_ 1

#if defined(_COLLECT_SWITCH_DATA_)

#define KiIncrementSwitchCounter(Member) KeThreadSwitchCounters.Member += 1

#else

#define KiIncrementSwitchCounter(Member)

#endif

VOID
KiSuspendNop (
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC for a
    thread. It is executed in kernel mode as the result of queuing the
    builtin suspend APC and performs no operation. It is called just prior
    to calling the normal routine and simply returns.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    NormalRoutine - not used

    NormalContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{

    //
    // No operation is performed by this routine.
    //

    return;
}

PKTHREAD
FASTCALL
KiFindReadyThread (
    IN KPRIORITY LowPriority
    )

/*++

Routine Description:

    This function searches the dispatcher ready queues from the specified
    high priority to the specified low priority in an attempt to find a thread
    that can execute on the specified processor.

Arguments:

    Processor - Supplies the number of the processor to find a thread for.

    LowPriority - Supplies the lowest priority dispatcher ready queue to
        examine.

Return Value:

    If a thread is located that can execute on the specified processor, then
    the address of the thread object is returned. Otherwise a null pointer is
    returned.

--*/

{

    ULONG HighPriority;
    PRLIST_ENTRY ListHead;
    PRLIST_ENTRY NextEntry;
    ULONG PrioritySet;
    PRKTHREAD Thread;

    //
    // Compute the set of priority levels that should be scanned in an attempt
    // to find a thread that can run on the specified processor.
    //

    PrioritySet = (~((1 << LowPriority) - 1)) & KiReadySummary;

    FindFirstSetLeftMember(PrioritySet, &HighPriority);
    ListHead = &KiDispatcherReadyListHead[HighPriority];
    PrioritySet <<= (31 - HighPriority);
    while (PrioritySet != 0) {

        //
        // If the next bit in the priority set is a one, then examine the
        // corresponding dispatcher ready queue.
        //

        if ((LONG)PrioritySet < 0) {
            NextEntry = ListHead->Flink;

            ASSERT(NextEntry != ListHead);

            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(&Thread->WaitListEntry);
            if (IsListEmpty(ListHead)) {
                ClearMember(HighPriority, KiReadySummary);
            }

            return (PKTHREAD)Thread;
        }

        HighPriority -= 1;
        ListHead -= 1;
        PrioritySet <<= 1;
    };

    //
    // No thread could be found, return a null pointer.
    //

    return (PKTHREAD)NULL;
}

VOID
FASTCALL
KiReadyThread (
    IN PRKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution and attempts to immediately
    dispatch the thread for execution by preempting another lower priority
    thread. If a thread can be preempted, then the specified thread enters
    the standby state and the target processor is requested to dispatch. If
    another thread cannot be preempted, then the specified thread is inserted
    either at the head or tail of the dispatcher ready selected by its priority
    acccording to whether it was preempted or not.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    PRKPRCB Prcb;
    BOOLEAN Preempted;
    KPRIORITY ThreadPriority;
    PRKTHREAD Thread1;

    //
    // Save value of thread's preempted flag, set thread preempted FALSE,
    // capture the thread priority, and set clear the read wait time.
    //

    Preempted = Thread->Preempted;
    Thread->Preempted = FALSE;
    ThreadPriority = Thread->Priority;
    Thread->WaitTime = KiQueryLowTickCount();

    //
    // If there is an idle processor, then schedule the thread on an
    // idle processor giving preference to the processor the thread
    // last ran on. Otherwise, try to preempt either a thread in the
    // standby or running state.
    //

    Prcb = KeGetCurrentPrcb();
    if (KiIdleSummary != 0) {
        KiIdleSummary = 0;
        KiIncrementSwitchCounter(IdleLast);
        Prcb->NextThread = Thread;
        Thread->State = Standby;

        return;

    } else {

        if (Prcb->NextThread != NULL) {
            Thread1 = Prcb->NextThread;
            if (ThreadPriority > Thread1->Priority) {
                Thread1->Preempted = TRUE;
                Prcb->NextThread = Thread;
                Thread->State = Standby;
                KiReadyThread(Thread1);
                KiIncrementSwitchCounter(PreemptLast);
                return;
            }

        } else {
            Thread1 = Prcb->CurrentThread;
            if (ThreadPriority > Thread1->Priority) {
                Thread1->Preempted = TRUE;
                Prcb->NextThread = Thread;
                Thread->State = Standby;
                KiRequestDispatchInterrupt();
                KiIncrementSwitchCounter(PreemptLast);
                return;
            }
        }
    }

    //
    // No thread can be preempted. Insert the thread in the dispatcher
    // queue selected by its priority. If the thread was preempted and
    // runs at a realtime priority level, then insert the thread at the
    // front of the queue. Else insert the thread at the tail of the queue.
    //

    Thread->State = Ready;
    if (Preempted != FALSE) {
        InsertHeadList(&KiDispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);

    } else {
        InsertTailList(&KiDispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);
    }

    SetMember(ThreadPriority, KiReadySummary);
    return;
}

PRKTHREAD
FASTCALL
KiSelectNextThread (
    IN PRKTHREAD Thread
    )

/*++

Routine Description:

    This function selects the next thread to run on the processor that the
    specified thread is running on. If a thread cannot be found, then the
    idle thread is selected.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The address of the selected thread object.

--*/

{

    PRKPRCB Prcb;
    PRKTHREAD Thread1;

    //
    // Get the processor number and the address of the processor control block.
    //

    Prcb = KeGetCurrentPrcb();

    //
    // If a thread has already been selected to run on the specified processor,
    // then return that thread as the selected thread.
    //

    if ((Thread1 = Prcb->NextThread) != NULL) {
        Prcb->NextThread = (PKTHREAD)NULL;

    } else {

        //
        // Attempt to find a ready thread to run.
        //

        Thread1 = KiFindReadyThread(0);

        //
        // If a thread was not found, then select the idle thread and
        // set the processor member in the idle summary.
        //

        if (Thread1 == NULL) {
            KiIncrementSwitchCounter(SwitchToIdle);
            Thread1 = Prcb->IdleThread;

            KiIdleSummary = 1;
        }
    }

    //
    // Return address of selected thread object.
    //

    return Thread1;
}

VOID
FASTCALL
KiSetPriorityThread (
    IN PRKTHREAD Thread,
    IN KPRIORITY Priority
    )

/*++

Routine Description:

    This function set the priority of the specified thread to the specified
    value. If the thread is in the standby or running state, then the processor
    may be redispatched. If the thread is in the ready state, then some other
    thread may be preempted.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new thread priority value.

Return Value:

    None.

--*/

{

    PRKPRCB Prcb;
    KPRIORITY ThreadPriority;
    PRKTHREAD Thread1;

    ASSERT(Priority <= HIGH_PRIORITY);

    //
    // Capture the current priority of the specified thread.
    //

    ThreadPriority = Thread->Priority;

    //
    // If the new priority is not equal to the old priority, then set the
    // new priority of the thread and redispatch a processor if necessary.
    //

    if (Priority != ThreadPriority) {
        Thread->Priority = (SCHAR)Priority;

        //
        // Case on the thread state.
        //

        switch (Thread->State) {

            //
            // Ready case - Remove the thread from its current dispatcher ready
            // queue. If the new priority is less than the old priority, then
            // insert the thread at the tail of the dispatcher ready queue
            // selected by the new priority. Else reready the thread for
            // execution.
            //

        case Ready:
            RemoveEntryList(&Thread->WaitListEntry);
            if (IsListEmpty(&KiDispatcherReadyListHead[ThreadPriority])) {
                ClearMember(ThreadPriority, KiReadySummary);
            }

            if (Priority < ThreadPriority) {
                InsertTailList(&KiDispatcherReadyListHead[Priority],
                               &Thread->WaitListEntry);
                SetMember(Priority, KiReadySummary);

            } else {
                KiReadyThread(Thread);
            }

            break;

            //
            // Standby case - If the thread's priority is being lowered, then
            // attempt to find another thread to execute. If a new thread is
            // found, then put the new thread in the standby state, and reready
            // the old thread.
            //

        case Standby:

            if (Priority < ThreadPriority) {

                Thread1 = KiFindReadyThread(Priority);

                if (Thread1 != NULL) {

                    Prcb = KeGetCurrentPrcb();

                    Thread1->State = Standby;
                    Prcb->NextThread = Thread1;
                    KiReadyThread(Thread);
                }
            }

            break;

            //
            // Running case - If there is not a thread in the standby state
            // on the thread's processor and the thread's priority is being
            // lowered, then attempt to find another thread to execute. If
            // a new thread is found, then put the new thread in the standby
            // state, and request a redispatch on the thread's processor.
            //

        case Running:

            Prcb = KeGetCurrentPrcb();

            if (Prcb->NextThread == NULL) {
                if (Priority < ThreadPriority) {

                    Thread1 = KiFindReadyThread(Priority);

                    if (Thread1 != NULL) {
                        Thread1->State = Standby;
                        Prcb->NextThread = Thread1;
                    }
                }
            }

            break;

            //
            // Initialized, Terminated, Waiting, Transition case - For
            // these states it is sufficient to just set the new thread
            // priority.
            //

        default:
            break;
        }
    }

    return;
}

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC of a
    thread. It is executed in kernel mode as the result of queuing the builtin
    suspend APC and suspends thread execution by Waiting nonalertable on the
    thread's builtin suspend semaphore. When the thread is resumed, execution
    of thread is continued by simply returning.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

Return Value:

    None.

--*/

{

    PRKTHREAD Thread;

    //
    // Get the address of the current thread object and Wait nonalertable on
    // the thread's builtin suspend semaphore.
    //

    Thread = KeGetCurrentThread();

    KeWaitForSingleObject(&Thread->SuspendSemaphore,
                          Suspended,
                          KernelMode,
                          FALSE,
                          (PLARGE_INTEGER)NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\wait.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    wait.c

Abstract:

    This module implements the generic kernel wait routines. Functions
    are provided to wait for a single object, wait for multiple objects,
    wait for event pair low, wait for event pair high, release and wait
    for semaphore, and to delay thread execution.

    N.B. This module is written to be a fast as possible and not as small
        as possible. Therefore some code sequences are duplicated to avoid
        procedure calls. It would also be possible to combine wait for
        single object into wait for multiple objects at the cost of some
        speed. Since wait for single object is the most common case, the
        two routines have been separated.

Author:

    David N. Cutler (davec) 23-Mar-89

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Test for alertable condition.
//
// If alertable is TRUE and the thread is alerted for a processor
// mode that is equal to the wait mode, then return immediately
// with a wait completion status of ALERTED.
//
// Else if alertable is TRUE, the wait mode is user, and the user APC
// queue is not empty, then set user APC pending, and return immediately
// with a wait completion status of USER_APC.
//
// Else if alertable is TRUE and the thread is alerted for kernel
// mode, then return immediately with a wait completion status of
// ALERTED.
//
// Else if alertable is FALSE and the wait mode is user and there is a
// user APC pending, then return immediately with a wait completion
// status of USER_APC.
//

#define TestForAlertPending(Alertable) \
    if (Alertable) { \
        if (Thread->Alerted[WaitMode] != FALSE) { \
            Thread->Alerted[WaitMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } else if ((WaitMode != KernelMode) && \
                  (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode])) == FALSE) { \
            Thread->ApcState.UserApcPending = TRUE; \
            WaitStatus = STATUS_USER_APC; \
            break; \
        } else if (Thread->Alerted[KernelMode] != FALSE) { \
            Thread->Alerted[KernelMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } \
    } else if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) { \
        WaitStatus = STATUS_USER_APC; \
        break; \
    }

VOID
KiAdjustQuantumThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    If the current thread is not a time critical or realtime thread, then
    adjust its quantum in accordance with the adjustment that would have
    occured if the thread had actually waited.

Arguments:

    Thread - Supplies a pointer to the current thread.

Return Value:

    None.

--*/

{
    PKPRCB Prcb;
    PKPROCESS Process;
    PKTHREAD NewThread;
    SCHAR ThreadPriority;

    if ((Thread->Priority < LOW_REALTIME_PRIORITY) &&
        (Thread->BasePriority < TIME_CRITICAL_PRIORITY_BOUND)) {
        Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
        if (Thread->Quantum <= 0) {
            Process = Thread->ApcState.Process;
            Thread->Quantum = Process->ThreadQuantum;
            ThreadPriority = (SCHAR)(Thread->Priority - (Thread->PriorityDecrement + 1));
            if (ThreadPriority < Thread->BasePriority) {
                ThreadPriority = Thread->BasePriority;
            }

            Thread->PriorityDecrement = 0;
            if (ThreadPriority != Thread->Priority) {
                KiSetPriorityThread(Thread, ThreadPriority);

            } else {
                Prcb = KeGetCurrentPrcb();
                if (Prcb->NextThread == NULL) {
                    NewThread = KiFindReadyThread(ThreadPriority);
                    if (NewThread != NULL) {
                        Prcb->NextThread = NewThread;
                        NewThread->State = Standby;
                    }
                }
            }
        }
    }

    return;
}

NTSTATUS
KeDelayExecutionThread (
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    WaitMode  - Supplies the processor mode in which the delay is to occur.

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    Interval - Supplies a pointer to the absolute or relative time over which
        the delay is to occur.

Return Value:

    The wait completion status. A value of STATUS_SUCCESS is returned if
    the delay occurred. A value of STATUS_ALERTED is returned if the wait
    was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    LARGE_INTEGER NewTime;
    PLARGE_INTEGER OriginalTime;
    PKPRCB Prcb;
    KPRIORITY Priority;
    PRKQUEUE Queue;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&Thread->WaitIrql);
    }

    //
    // Start of delay loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the delay or a kernel APC is pending on the first attempt through
    // the loop.
    //

    OriginalTime = Interval;
    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // Initialize wait block, insert wait block in timer wait list,
            // insert timer in timer queue, put thread in wait state, select
            // next thread to execute, and context switch to next thread.
            //
            // N.B. The timer wait block is initialized when the respective
            //      thread is initialized. Thus the constant fields are not
            //      reinitialized. These include the wait object, wait key,
            //      wait type, and the wait list entry link pointers.
            //

            WaitBlock = &Thread->TimerWaitBlock;
            Thread->WaitBlockList = WaitBlock;
            Thread->WaitStatus = (NTSTATUS)0;
            Timer = &Thread->Timer;
            WaitBlock->NextWaitBlock = WaitBlock;
            Timer->Header.WaitListHead.Flink = &WaitBlock->WaitListEntry;
            Timer->Header.WaitListHead.Blink = &WaitBlock->WaitListEntry;

            //
            // If the timer is inserted in the timer tree, then place the
            // current thread in a wait state. Otherwise, attempt to force
            // the current thread to yield the processor to another thread.
            //

            if (KiInsertTreeTimer(Timer, *Interval) == FALSE) {

                //
                // If the thread is not a realtime thread, then drop the
                // thread priority to the base priority.
                //

                Prcb = KeGetCurrentPrcb();
                Priority = Thread->Priority;
                if (Priority < LOW_REALTIME_PRIORITY) {
                    if (Priority != Thread->BasePriority) {
                        Thread->PriorityDecrement = 0;
                        KiSetPriorityThread(Thread, Thread->BasePriority);
                    }
                }

                //
                // If a new thread has not been selected, the attempt to round
                // robin the thread with other threads at the same priority.
                //

                if (Prcb->NextThread == NULL) {
                    Prcb->NextThread = KiFindReadyThread(Thread->Priority);
                }

                //
                // If a new thread has been selected for execution, then
                // switch immediately to the selected thread.
                //

                if (Prcb->NextThread != NULL) {

                    //
                    // Give the current thread a new qunatum and switch
                    // context to selected thread.
                    //
                    // N.B. Control is returned at the original IRQL.
                    //

                    Thread->Preempted = FALSE;
                    Thread->Quantum = Thread->ApcState.Process->ThreadQuantum;

                    ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                    KiReadyThread(Thread);
                    WaitStatus = (NTSTATUS)KiSwapThread();
                    goto WaitComplete;

                } else {
                    WaitStatus = (NTSTATUS)STATUS_SUCCESS;
                    break;
                }
            }

            DueTime.QuadPart = Timer->DueTime.QuadPart;

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->Alertable = Alertable;
            Thread->WaitMode = WaitMode;
            Thread->WaitReason = DelayExecution;
            Thread->WaitTime= KiQueryLowTickCount();
            Thread->State = Waiting;
            KiInsertWaitList(WaitMode, Thread);

            //
            // Switch context to selected thread.
            //
            // N.B. Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

        WaitComplete:
            //
            // If the thread was awakened to deliver a user mode APC, then
            // deliver pending user mode APCs.
            //

            if (WaitStatus == STATUS_USER_APC) {
                KiDeliverUserApc();
            }

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                if (WaitStatus == STATUS_TIMEOUT) {
                    WaitStatus = STATUS_SUCCESS;
                }
                return WaitStatus;
            }

            //
            // Reduce the time remaining before the time delay expires.
            //

            Interval = KiComputeWaitInterval(OriginalTime,
                                             &DueTime,
                                             &NewTime);
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&Thread->WaitIrql);
    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return the
    // wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;
}

NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled. The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled. If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Object[] - Supplies an array of pointers to dispatcher objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

    WaitBlockArray - Supplies a pointer to an array of wait blocks that are to
        used to describe the wait operation.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait. A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread. A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    ULONG Index;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;
    BOOLEAN WaitSatisfied;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // The caller always must supply storage for the KWAIT_BLOCKs (this was
    // optional for small counts under NT).
    //

    ASSERT(WaitBlockArray != NULL);

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&Thread->WaitIrql);
    }

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    OriginalTime = Timeout;
    do {

        //
        // Set address of wait block list in thread object.
        //

        Thread->WaitBlockList = WaitBlockArray;

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Construct wait blocks and check to determine if the wait is
            // already satisfied. If the wait is satisfied, then perform
            // wait completion and return. Else put current thread in a wait
            // state if an explicit timeout value of zero is not specified.
            //

            Thread->WaitStatus = (NTSTATUS)0;
            WaitSatisfied = TRUE;
            for (Index = 0; Index < Count; Index += 1) {

                //
                // Test if wait can be satisfied immediately.
                //

                Objectx = (PKMUTANT)Object[Index];

                ASSERT(Objectx->Header.Type != QueueObject);

                if (WaitType == WaitAny) {

                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MINLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is greater than zero, or the current thread is
                    // the owner of the mutant object, then satisfy the wait.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Objectx->Header.SignalState > 0) ||
                            (Thread == Objectx->OwnerThread)) {
                            if (Objectx->Header.SignalState != MINLONG) {
                                KiWaitSatisfyMutant(Objectx, Thread);
                                WaitStatus = (NTSTATUS)(Index | Thread->WaitStatus);
                                goto NoWait;

                            } else {
                                KiUnlockDispatcherDatabase(Thread->WaitIrql);
                                ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                            }
                        }

                    //
                    // If the signal state is greater than zero, then satisfy
                    // the wait.
                    //

                    } else if (Objectx->Header.SignalState > 0) {
                        KiWaitSatisfyOther(Objectx);
                        WaitStatus = (NTSTATUS)(Index);
                        goto NoWait;
                    }

                } else {

                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MAXLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is less than or equal to zero and the current
                    // thread is not the  owner of the mutant object, then the
                    // wait cannot be satisfied.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Thread == Objectx->OwnerThread) &&
                            (Objectx->Header.SignalState == MINLONG)) {
                            KiUnlockDispatcherDatabase(Thread->WaitIrql);
                            ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);

                        } else if ((Objectx->Header.SignalState <= 0) &&
                                  (Thread != Objectx->OwnerThread)) {
                            WaitSatisfied = FALSE;
                        }

                    //
                    // If the signal state is less than or equal to zero, then
                    // the wait cannot be satisfied.
                    //

                    } else if (Objectx->Header.SignalState <= 0) {
                        WaitSatisfied = FALSE;
                    }
                }

                //
                // Construct wait block for the current object.
                //

                WaitBlock = &WaitBlockArray[Index];
                WaitBlock->Object = (PVOID)Objectx;
                WaitBlock->WaitKey = (CSHORT)(Index);
                WaitBlock->WaitType = (USHORT)WaitType;
                WaitBlock->Thread = Thread;
                WaitBlock->NextWaitBlock = &WaitBlockArray[Index + 1];
            }

            //
            // If the wait type is wait all, then check to determine if the
            // wait can be satisfied immediately.
            //

            if ((WaitType == WaitAll) && (WaitSatisfied)) {
                WaitBlock->NextWaitBlock = &WaitBlockArray[0];
                KiWaitSatisfyAll(WaitBlock);
                WaitStatus = (NTSTATUS)Thread->WaitStatus;
                goto NoWait;
            }

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisifed immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // If the timeout value is zero, then return immediately without
                // waiting.
                //

                if (!(Timeout->LowPart | Timeout->HighPart)) {
                    WaitStatus = (NTSTATUS)(STATUS_TIMEOUT);
                    goto NoWait;
                }

                //
                // Initialize a wait block for the thread specific timer,
                // initialize timer wait list head, insert the timer in the
                // timer tree, and increment the number of wait objects.
                //
                // N.B. The timer wait block is initialized when the respective
                //      thread is initialized. Thus the constant fields are not
                //      reinitialized. These include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                WaitTimer = &Thread->TimerWaitBlock;
                WaitBlock->NextWaitBlock = WaitTimer;
                WaitBlock = WaitTimer;
                Timer = &Thread->Timer;
                InitializeListHead(&Timer->Header.WaitListHead);
                if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                DueTime.QuadPart = Timer->DueTime.QuadPart;
            }

            //
            // Close up the circular list of wait control blocks.
            //

            WaitBlock->NextWaitBlock = &WaitBlockArray[0];

            //
            // Insert wait blocks in object wait lists.
            //

            WaitBlock = &WaitBlockArray[0];
            do {
                Objectx = (PKMUTANT)WaitBlock->Object;
                InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);
                WaitBlock = WaitBlock->NextWaitBlock;
            } while (WaitBlock != &WaitBlockArray[0]);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->Alertable = Alertable;
            Thread->WaitMode = WaitMode;
            Thread->WaitReason = (UCHAR)WaitReason;
            Thread->WaitTime= KiQueryLowTickCount();
            Thread->State = Waiting;
            KiInsertWaitList(WaitMode, Thread);

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was awakened to deliver a user mode APC, then
            // deliver pending user mode APCs.
            //

            if (WaitStatus == STATUS_USER_APC) {
                KiDeliverUserApc();
            }

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&Thread->WaitIrql);
    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the thread priority that is less than time critical, then reduce
    // the thread quantum. If a quantum end occurs, then reduce the thread
    // priority.
    //

NoWait:
    KiAdjustQuantumThread(Thread);

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;
}

NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the object
    attains a state of Signaled. If a timeout is specified, and the object
    has not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait. A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    KWAIT_BLOCK StackWaitBlock;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // Collect call data.
    //

#if defined(_COLLECT_WAIT_SINGLE_CALLDATA_)

    RECORD_CALL_DATA(&KiWaitSingleCallData);

#endif

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&Thread->WaitIrql);
    }

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    OriginalTime = Timeout;
    WaitBlock = &StackWaitBlock;
    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Test if the wait can be immediately satisfied.
            //

            Objectx = (PKMUTANT)Object;
            Thread->WaitStatus = (NTSTATUS)0;

            ASSERT(Objectx->Header.Type != QueueObject);

            //
            // If the object is a mutant object and the mutant object has been
            // recursively acquired MINLONG times, then raise an exception.
            // Otherwise if the signal state of the mutant object is greater
            // than zero, or the current thread is the owner of the mutant
            // object, then satisfy the wait.
            //

            if (Objectx->Header.Type == MutantObject) {
                if ((Objectx->Header.SignalState > 0) ||
                    (Thread == Objectx->OwnerThread)) {
                    if (Objectx->Header.SignalState != MINLONG) {
                        KiWaitSatisfyMutant(Objectx, Thread);
                        WaitStatus = (NTSTATUS)(Thread->WaitStatus);
                        goto NoWait;

                    } else {
                        KiUnlockDispatcherDatabase(Thread->WaitIrql);
                        ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                    }
                }

            //
            // If the signal state is greater than zero, then satisfy the wait.
            //

            } else if (Objectx->Header.SignalState > 0) {
                KiWaitSatisfyOther(Objectx);
                WaitStatus = (NTSTATUS)(0);
                goto NoWait;
            }

            //
            // Construct a wait block for the object.
            //

            Thread->WaitBlockList = WaitBlock;
            WaitBlock->Object = Object;
            WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);
            WaitBlock->WaitType = WaitAny;
            WaitBlock->Thread = Thread;

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisifed immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // If the timeout value is zero, then return immediately without
                // waiting.
                //

                if (!(Timeout->LowPart | Timeout->HighPart)) {
                    WaitStatus = (NTSTATUS)(STATUS_TIMEOUT);
                    goto NoWait;
                }

                //
                // Initialize a wait block for the thread specific timer, insert
                // wait block in timer wait list, insert the timer in the timer
                // tree.
                //
                // N.B. The timer wait block is initialized when the respective
                //      thread is initialized. Thus the constant fields are not
                //      reinitialized. These include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                Timer = &Thread->Timer;
                WaitTimer = &Thread->TimerWaitBlock;
                WaitBlock->NextWaitBlock = WaitTimer;
                Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;
                Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;
                WaitTimer->NextWaitBlock = WaitBlock;
                if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                DueTime.QuadPart = Timer->DueTime.QuadPart;

            } else {
                WaitBlock->NextWaitBlock = WaitBlock;
            }

            //
            // Insert wait block in object wait list.
            //

            InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->Alertable = Alertable;
            Thread->WaitMode = WaitMode;
            Thread->WaitReason = (UCHAR)WaitReason;
            Thread->WaitTime= KiQueryLowTickCount();
            Thread->State = Waiting;
            KiInsertWaitList(WaitMode, Thread);

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was awakened to deliver a user mode APC, then
            // deliver pending user mode APCs.
            //

            if (WaitStatus == STATUS_USER_APC) {
                KiDeliverUserApc();
            }

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&Thread->WaitIrql);
    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the thread priority that is less than time critical, then reduce
    // the thread quantum. If a quantum end occurs, then reduce the thread
    // priority.
    //

NoWait:
    KiAdjustQuantumThread(Thread);

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;
}

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    )

/*++

Routine Description:

    This function recomputes the wait interval after a thread has been
    awakened to deliver a kernel APC.

Arguments:

    OriginalTime - Supplies a pointer to the original timeout value.

    DueTime - Supplies a pointer to the previous due time.

    NewTime - Supplies a pointer to a variable that receives the
        recomputed wait interval.

Return Value:

    A pointer to the new time is returned as the function value.

--*/

{

    //
    // If the original wait time was absolute, then return the same
    // absolute time. Otherwise, reduce the wait time remaining before
    // the time delay expires.
    //

    if (OriginalTime->QuadPart >= 0) {
        return OriginalTime;

    } else {
        KiQueryInterruptTime(NewTime);
        NewTime->QuadPart -= DueTime->QuadPart;
        return NewTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\waitsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    waitsup.c

Abstract:

    This module contains the support routines necessary to support the
    generic kernel wait functions. Functions are provided to test if a
    wait can be satisfied, to satisfy a wait, and to unwwait a thread.

Author:

    David N. Cutler (davec) 24-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
FASTCALL
KiUnwaitThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function unwaits a thread, sets the thread's wait completion status,
    calculates the thread's new priority, and readies the thread for execution.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    WaitStatus - Supplies the wait completion status.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KPRIORITY NewPriority;
    PKPROCESS Process;
    PKQUEUE Queue;
    PKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;

    //
    // Set wait completion status, remove wait blocks from object wait
    // lists, and remove thread from wait list.
    //

    Thread->WaitStatus |= WaitStatus;
    WaitBlock = Thread->WaitBlockList;
    do {
        RemoveEntryList(&WaitBlock->WaitListEntry);
        WaitBlock = WaitBlock->NextWaitBlock;
    } while (WaitBlock != Thread->WaitBlockList);

    RemoveEntryList(&Thread->WaitListEntry);

    //
    // If thread timer is still active, then cancel thread timer.
    //

    Timer = &Thread->Timer;
    if (Timer->Header.Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // If the thread is processing a queue entry, then increment the
    // count of currently active threads.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        Queue->CurrentCount += 1;
    }

    //
    // If the thread runs at a realtime priority level, then reset the
    // thread quantum. Otherwise, compute the next thread priority and
    // charge the thread for the wait operation.
    //

    Process = Thread->ApcState.Process;
    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        if ((Thread->PriorityDecrement == 0) &&
            (Thread->DisableBoost == FALSE)) {
            NewPriority = Thread->BasePriority + Increment;

            if (NewPriority > Thread->Priority) {
                if (NewPriority >= LOW_REALTIME_PRIORITY) {
                    Thread->Priority = LOW_REALTIME_PRIORITY - 1;

                } else {
                    Thread->Priority = (SCHAR)NewPriority;
                }
            }
        }

        if (Thread->BasePriority >= TIME_CRITICAL_PRIORITY_BOUND) {
            Thread->Quantum = Process->ThreadQuantum;

        } else {
            Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
            if (Thread->Quantum <= 0) {
                Thread->Quantum = Process->ThreadQuantum;
                Thread->Priority -= (Thread->PriorityDecrement + 1);
                if (Thread->Priority < Thread->BasePriority) {
                    Thread->Priority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;
            }
        }

    } else {
        Thread->Quantum = Process->ThreadQuantum;
    }

    //
    // Reready the thread for execution.
    //

    KiReadyThread(Thread);
    return;
}

VOID
KeBoostCurrentThread(
    VOID
    )

/*++

Routine Description:

    This function boosts the priority of the current thread for one quantum,
    then reduce the thread priority to the base priority of the thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD Thread;

    //
    // Get current thread address, raise IRQL to synchronization level, and
    // lock the dispatcher database
    //

    Thread = KeGetCurrentThread();

redoboost:
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If a priority boost is not already active for the current thread
    // and the thread priority is less than 14, then boost the thread
    // priority to 14 and give the thread a large quantum. Otherwise,
    // if a priority boost is active, then decrement the round trip
    // count. If the count goes to zero, then release the dispatcher
    // database lock, lower the thread priority to the base priority,
    // and then attempt to boost the priority again. This will give
    // other threads a chance to run. If the count does not reach zero,
    // then give the thread another large qunatum.
    //
    // If the thread priority is above 14, then no boost is applied.
    //

    if ((Thread->PriorityDecrement == 0) && (Thread->Priority < 14)) {
        Thread->PriorityDecrement = 14 - Thread->BasePriority;
        Thread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
        Thread->Priority = 14;
        Thread->Quantum = Thread->ApcState.Process->ThreadQuantum * 2;

    } else if (Thread->PriorityDecrement != 0) {
        Thread->DecrementCount -= 1;
        if (Thread->DecrementCount == 0) {
            KiUnlockDispatcherDatabase(OldIrql);
            KeSetPriorityThread(Thread, Thread->BasePriority);
            goto redoboost;

        } else {
            Thread->Quantum = Thread->ApcState.Process->ThreadQuantum * 2;
        }
    }

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

VOID
FASTCALL
KiWaitSatisfyAll (
    IN PRKWAIT_BLOCK WaitBlock
    )

/*++

Routine Description:

    This function satisfies a wait all and performs any side effects that
    are necessary.

Arguments:

    WaitBlock - Supplies a pointer to a wait block.

Return Value:

    None.

--*/

{

    PKMUTANT Object;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock1;

    //
    // If the wait type was WaitAny, then perform neccessary side effects on
    // the object specified by the wait block. Else perform necessary side
    // effects on all the objects that were involved in the wait operation.
    //

    WaitBlock1 = WaitBlock;
    Thread = WaitBlock1->Thread;
    do {
        if (WaitBlock1->WaitKey != (CSHORT)STATUS_TIMEOUT) {
            Object = (PKMUTANT)WaitBlock1->Object;
            KiWaitSatisfyAny(Object, Thread);
        }

        WaitBlock1 = WaitBlock1->NextWaitBlock;
    } while (WaitBlock1 != WaitBlock);

    return;
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function tests if a wait can be satisfied when an object attains
    a state of signaled. If a wait can be satisfied, then the subject thread
    is unwaited with a completion status that is the WaitKey of the wait
    block from the object wait list. As many waits as possible are satisfied.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

Return Value:

    None.

--*/

{

    PKEVENT Event;
    PLIST_ENTRY ListHead;
    PRKWAIT_BLOCK NextBlock;
    PKMUTANT Mutant;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    //
    // As long as the signal state of the specified object is Signaled and
    // there are waiters in the object wait list, then try to satisfy a wait.
    //

    Event = (PKEVENT)Object;
    ListHead = &Event->Header.WaitListHead;
    WaitEntry = ListHead->Flink;
    while ((Event->Header.SignalState > 0) &&
           (WaitEntry != ListHead)) {
        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;
        if (WaitBlock->WaitType != WaitAny) {

            //
            // The wait type is wait all - if all the objects are in
            // a Signaled state, then satisfy the wait.
            //

            NextBlock = WaitBlock->NextWaitBlock;
            while (NextBlock != WaitBlock) {
                if (NextBlock->WaitKey != (CSHORT)(STATUS_TIMEOUT)) {
                    Mutant = (PKMUTANT)NextBlock->Object;
                    if ((Mutant->Header.Type == MutantObject) &&
                        (Mutant->Header.SignalState <= 0) &&
                        (Thread == Mutant->OwnerThread)) {
                        goto next;

                    } else if (Mutant->Header.SignalState <= 0) {
                        goto scan;
                    }
                }

            next:
                NextBlock = NextBlock->NextWaitBlock;
            }

            //
            // All objects associated with the wait are in the Signaled
            // state - satisfy the wait.
            //

            WaitEntry = WaitEntry->Blink;
            KiWaitSatisfyAll(WaitBlock);

        } else {

            //
            // The wait type is wait any - satisfy the wait.
            //

            WaitEntry = WaitEntry->Blink;
            KiWaitSatisfyAny((PKMUTANT)Event, Thread);
        }

        KiUnwaitThread(Thread, (NTSTATUS)WaitBlock->WaitKey, Increment);

    scan:
        WaitEntry = WaitEntry->Flink;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\thredobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    threadobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel thread object. Functions are provided to initialize, ready,
    alert, test alert, boost priority, enable APC queuing, disable APC
    queuing, confine, set affinity, set priority, suspend, resume, alert
    resume, terminate, read thread state, freeze, unfreeze, query data
    alignment handling mode, force resume, and enter and leave critical
    regions for thread objects.

Author:

    David N. Cutler (davec) 4-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input thread object is
// really a kthread and not something else, like deallocated pool.
//

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}

VOID
KeInitializeThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PKPROCESS Process
    )

/*++

Routine Description:

    This function initializes a thread object. The priority, affinity,
    and initial quantum are taken from the parent process object. The
    thread object is inserted at the end of the thread list for the
    parent process.

    N.B. It is assumed that the thread object is zeroed.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelStack - Supplies a pointer to the base of a kernel stack on which
        the context frame for the thread is to be constructed.

    KernelStackSize - Supplies the number of bytes allocated for the kernel
        stack.

    TlsDataSize - Supplies the number of bytes reserved from the kernel stack
        for thread local storage.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    Process - Supplies a pointer to a control object of type process.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;

    //
    // Initialize the standard dispatcher object header and set the initial
    // state of the thread object.
    //

    Thread->Header.Type = ThreadObject;
    Thread->Header.Size = sizeof(KTHREAD) / sizeof(LONG);
    InitializeListHead(&Thread->Header.WaitListHead);

    //
    // Initialize the owned mutant listhead.
    //

    InitializeListHead(&Thread->MutantListHead);

    //
    // Initialize the alerted, preempted, debugactive, autoalignment,
    // kernel stack resident, enable kernel stack swap, and process
    // ready queue boolean values.
    //
    // N.B. Only nonzero values are initialized.
    //

    //
    // Initialize the APC state pointers, the current APC state, the saved
    // APC state, and enable APC queuing.
    //

    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);
    InitializeListHead(&Thread->ApcState.ApcListHead[UserMode]);
    Thread->ApcState.Process = Process;
    Thread->ApcState.ApcQueueable = TRUE;

    //
    // Initialize the kernel mode suspend APC and the suspend semaphore object.
    // and the builtin wait timeout timer object.
    //

    KeInitializeApc(&Thread->SuspendApc,
                    Thread,
                    (PKKERNEL_ROUTINE)KiSuspendNop,
                    (PKRUNDOWN_ROUTINE)NULL,
                    KiSuspendThread,
                    KernelMode,
                    NULL);

    KeInitializeSemaphore(&Thread->SuspendSemaphore, 0L, 2L);

    //
    // Initialize the builtin timer trimer wait wait block.
    //
    // N.B. This is the only time the wait block is initialized since this
    //      information is constant.
    //

    Timer = &Thread->Timer;
    KeInitializeTimer(Timer);
    WaitBlock = &Thread->TimerWaitBlock;
    WaitBlock->Object = Timer;
    WaitBlock->WaitKey = (CSHORT)STATUS_TIMEOUT;
    WaitBlock->WaitType = WaitAny;
    WaitBlock->Thread = Thread;
    WaitBlock->WaitListEntry.Flink = &Timer->Header.WaitListHead;
    WaitBlock->WaitListEntry.Blink = &Timer->Header.WaitListHead;

    //
    // Set the initial kernel stack and the initial thread context.
    //

    Thread->StackBase = KernelStack;
    Thread->StackLimit = (PVOID)((ULONG_PTR)KernelStack - KernelStackSize);
    KiInitializeContextThread(Thread,
                              TlsDataSize,
                              SystemRoutine,
                              StartRoutine,
                              StartContext);

    //
    // Set the base thread priority, the thread priority, the thread affinity,
    // the thread quantum, and the scheduling state.
    //

    Thread->BasePriority = Process->BasePriority;
    Thread->Priority = Thread->BasePriority;
    Thread->Quantum = Process->ThreadQuantum;
    Thread->State = Initialized;
    Thread->DisableBoost = Process->DisableBoost;

    //
    // Lock the dispatcher database, insert the thread in the process
    // thread list, increment the kernel stack count, and unlock the
    // dispatcher database.
    //
    // N.B. The distinguished value MAXSHORT is used to signify that no
    //      threads have been created for a process.
    //

    KiLockDispatcherDatabase(&OldIrql);
    InsertTailList(&Process->ThreadListHead, &Thread->ThreadListEntry);
    Process->StackCount += 1;

    //
    // Initialize the ideal processor number for the thread.
    //
    //  N.B. This must be done under the dispatcher lock to prevent byte
    //      granularity problems on Alpha.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

BOOLEAN
KeAlertThread (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function attempts to alert a thread and cause its execution to
    be continued if it is currently in an alertable Wait state. Otherwise
    it just sets the alerted variable for the specified processor mode.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    AlertMode - Supplies the processor mode for which the thread is
        to be alerted.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and lock
    // APC queue.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // Capture the current state of the alerted variable for the specified
    // processor mode.
    //

    Alerted = Thread->Alerted[AlertMode];

    //
    // If the alerted state for the specified processor mode is Not-Alerted,
    // then attempt to alert the thread.
    //

    if (Alerted == FALSE) {

        //
        // If the thread is currently in a Wait state, the Wait is alertable,
        // and the specified processor mode is less than or equal to the Wait
        // mode, then the thread is unwaited with a status of "alerted".
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE) &&
            (AlertMode <= Thread->WaitMode)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT);

        } else {
            Thread->Alerted[AlertMode] = TRUE;
        }
    }

    //
    // Unlock APC queue, unlock dispatcher database, lower IRQL to its
    // previous value, and return the previous alerted state for the
    // specified mode.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return Alerted;
}

ULONG
KeAlertResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function attempts to alert a thread in kernel mode and cause its
    execution to be continued if it is currently in an alertable Wait state.
    In addition, a resume operation is performed on the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and lock
    // APC queue.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // If the kernel mode alerted state is FALSE, then attempt to alert
    // the thread for kernel mode.
    //

    if (Thread->Alerted[KernelMode] == FALSE) {

        //
        // If the thread is currently in a Wait state and the Wait is alertable,
        // then the thread is unwaited with a status of "alerted". Else set the
        // kernel mode alerted variable.
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT);

        } else {
            Thread->Alerted[KernelMode] = TRUE;
        }
    }

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero, then resume the thread by
        // releasing its suspend semaphore.
        //

        if (Thread->SuspendCount == 0) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock APC queue, unlock dispatcher database, lower IRQL to its
    // previous value, and return the previous suspend count.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return OldCount;
}

VOID
KeBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function boosts the priority of the specified thread using the
    same algorithm used when a thread gets a boost from a wait operation.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the thread does not run at a realtime priority level, then boost
    // the thread priority.
    //

    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        KiBoostPriorityThread(Thread, Increment);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

BOOLEAN
KeDisableApcQueuingThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function disables the queuing of APC's to the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous value of the APC queuing state variable.

--*/

{

    BOOLEAN ApcQueueable;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the APC queueable state variable and
    // set its state to FALSE.
    //

    ApcQueueable = Thread->ApcState.ApcQueueable;
    Thread->ApcState.ApcQueueable = FALSE;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous APC queueable state.
    //

    return ApcQueueable;
}

BOOLEAN
KeEnableApcQueuingThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function enables the queuing of APC's to the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous value of the APC queuing state variable.

--*/

{

    BOOLEAN ApcQueueable;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the APC queueable state variable and
    // set its state to TRUE.
    //

    ApcQueueable = Thread->ApcState.ApcQueueable;
    Thread->ApcState.ApcQueueable = TRUE;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous APC queueable state.
    //

    return ApcQueueable;
}

ULONG
KeForceResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function forces resumption of thread execution if the thread is
    suspended. If the specified thread is not suspended, then no operation
    is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The sum of the previous suspend count and the freeze count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then force resumption of
    // thread execution.
    //

    if (OldCount != 0) {
        Thread->SuspendCount = 0;
        Thread->SuspendSemaphore.Header.SignalState += 1;
        KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

LONG
KeQueryBasePriorityThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the base priority increment of the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The base priority increment of the specified thread.

--*/

{

    LONG Increment;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If priority saturation occured the last time the thread base priority
    // was set, then return the saturation increment value. Otherwise, compute
    // the increment value as the difference between the thread base priority
    // and the process base priority.
    //

    Process = Thread->ApcState.Process;
    Increment = Thread->BasePriority - Process->BasePriority;
    if (Thread->Saturation != 0) {
        Increment = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread base priority increment.
    //

    return Increment;
}

VOID
KeReadyThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution. If the thread's process
    is currently not in the balance set, then the thread is inserted in the
    thread's process' ready queue. Else if the thread is higher priority than
    another thread that is currently running on a processor then the thread
    is selected for execution on that processor. Else the thread is inserted
    in the dispatcher ready queue selected by its priority.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Ready the specified thread for execution.
    //

    KiReadyThread(Thread);

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

ULONG
KeResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function resumes the execution of a suspended thread. If the
    specified thread is not suspended, then no operation is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero, then resume the thread by
        // releasing its suspend semaphore.
        //

        if (Thread->SuspendCount == 0) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

VOID
KeRundownThread (
    VOID
    )

/*++

Routine Description:

    This function is called by the executive to rundown thread structures
    which must be guarded by the dispatcher database lock and which must
    be processed before actually terminating the thread. An example of such
    a structure is the mutant ownership list that is anchored in the kernel
    thread object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKMUTANT Mutant;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Scan the list of owned mutant objects and release the mutant objects
    // with an abandoned status. If the mutant is a kernel mutex, then bug
    // check.
    //

    NextEntry = Thread->MutantListHead.Flink;
    while (NextEntry != &Thread->MutantListHead) {
        Mutant = CONTAINING_RECORD(NextEntry, KMUTANT, MutantListEntry);

        RemoveEntryList(&Mutant->MutantListEntry);
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;
        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) != TRUE) {
            KiWaitTest(Mutant, MUTANT_INCREMENT);
        }

        NextEntry = Thread->MutantListHead.Flink;
    }

    //
    // Release dispatcher database lock and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

LONG
KeSetBasePriorityThread (
    IN PKTHREAD Thread,
    IN LONG Increment
    )

/*++

Routine Description:

    This function sets the base priority of the specified thread to a
    new value.  The new base priority for the thread is the process base
    priority plus the increment.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the base priority increment of the subject thread.

        N.B. If the absolute value of the increment is such that saturation
             of the base priority is forced, then subsequent changes to the
             parent process base priority will not change the base priority
             of the thread.

Return Value:

    The previous base priority increment of the specified thread.

--*/

{

    KPRIORITY NewBase;
    KPRIORITY NewPriority;
    KPRIORITY OldBase;
    LONG OldIncrement;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the base priority of the specified thread and determine
    // whether saturation if being forced.
    //

    Process = Thread->ApcState.Process;
    OldBase = Thread->BasePriority;
    OldIncrement = OldBase - Process->BasePriority;
    if (Thread->Saturation != 0) {
        OldIncrement = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    Thread->Saturation = FALSE;
    if (abs(Increment) >= (HIGH_PRIORITY + 1) / 2) {
        Thread->Saturation = (Increment > 0) ? 1 : -1;
    }

    //
    // Set the base priority of the specified thread. If the thread's process
    // is in the realtime class, then limit the change to the realtime class.
    // Otherwise, limit the change to the variable class.
    //

    NewBase = Process->BasePriority + Increment;
    if (Process->BasePriority >= LOW_REALTIME_PRIORITY) {
        if (NewBase < LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY;

        } else if (NewBase > HIGH_PRIORITY) {
            NewBase = HIGH_PRIORITY;
        }

        //
        // Set the new priority of the thread to the new base priority.
        //

        NewPriority = NewBase;

    } else {
        if (NewBase >= LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY - 1;

        } else if (NewBase <= LOW_PRIORITY) {
            NewBase = 1;
        }

        //
        // Compute the new thread priority. If the new priority is outside
        // the variable class, then set the new priority to the highest
        // variable priority.
        //

        if (Thread->Saturation != 0) {
            NewPriority = NewBase;

        } else {
            NewPriority = Thread->Priority +
                            (NewBase - OldBase) - Thread->PriorityDecrement;

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;
            }
        }
    }

    //
    // Set the new base priority and clear the priority decrement. If the
    // new priority is not equal to the old priority, then set the new thread
    // priority.
    //

    Thread->BasePriority = (SCHAR)NewBase;
    Thread->DecrementCount = 0;
    Thread->PriorityDecrement = 0;
    if (NewPriority != Thread->Priority) {
        Thread->Quantum = Process->ThreadQuantum;
        KiSetPriorityThread(Thread, NewPriority);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread base priority.
    //

    return OldIncrement;
}

LOGICAL
KeSetDisableBoostThread (
    IN PKTHREAD Thread,
    IN LOGICAL Disable
    )

/*++

Routine Description:

    This function disables priority boosts for the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Disable - Supplies a logical value that determines whether priority
        boosts for the thread are disabled or enabled.

Return Value:

    The previous value of the disable boost state variable.

--*/

{

    LOGICAL DisableBoost;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the disable boost variable and set its
    // state to TRUE.
    //

    DisableBoost = Thread->DisableBoost;
    Thread->DisableBoost = (BOOLEAN)Disable;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous disable boost state.
    //

    return DisableBoost;
}

KPRIORITY
KeSetPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Priority
    )

/*++

Routine Description:

    This function sets the priority of the specified thread to a new value.
    If the new thread priority is lower than the old thread priority, then
    resecheduling may take place if the thread is currently running on, or
    about to run on, a processor.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new priority of the subject thread.

Return Value:

    The previous priority of the specified thread.

--*/

{

    KIRQL OldIrql;
    KPRIORITY OldPriority;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(((Priority != 0) || (Thread->BasePriority == 0)) &&
           (Priority <= HIGH_PRIORITY));

    ASSERT(KeIsExecutingDpc() == FALSE);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current thread priority, set the thread priority to the
    // the new value, and replenish the thread quantum. It is assumed that
    // the priority would not be set unless the thread had already lost it
    // initial quantum.
    //

    OldPriority = Thread->Priority;
    Process = Thread->ApcState.Process;
    Thread->Quantum = Process->ThreadQuantum;
    Thread->DecrementCount = 0;
    Thread->PriorityDecrement = 0;
    KiSetPriorityThread(Thread, Priority);

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread priority.
    //

    return OldPriority;
}

ULONG
KeSuspendThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function suspends the execution of a thread. If the suspend count
    overflows the maximum suspend count, then a condition is raised.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the suspend count is at its maximum value, then unlock dispatcher
    // database, lower IRQL to its previous value, and raise an error
    // condition.
    //

    if (OldCount == MAXIMUM_SUSPEND_COUNT) {

        //
        // Unlock the dispatcher database and raise an exception.
        //

        KiUnlockDispatcherDatabase(OldIrql);
        ExRaiseStatus(STATUS_SUSPEND_COUNT_EXCEEDED);
    }

    //
    // Don't suspend if APC queuing is disabled. Thread is being deleted in this case.
    //

    if (Thread->ApcState.ApcQueueable == TRUE) {

        //
        // Increment the suspend count. If the thread was not previously suspended,
        // then queue the thread's suspend APC.
        //

        Thread->SuspendCount += 1;
        if (OldCount == 0) {
            if (KiInsertQueueApc(&Thread->SuspendApc, RESUME_INCREMENT) == FALSE) {
                Thread->SuspendSemaphore.Header.SignalState -= 1;
            }
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

VOID
KeTerminateThread (
    VOID
    )

/*++

Routine Description:

    This function terminates the execution of the current thread, sets the
    signal state of the thread to Signaled, and attempts to satisfy as many
    Waits as possible. The scheduling state of the thread is set to terminated,
    and a new thread is selected to run on the current processor. There is no
    return from this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKPROCESS Process;
    PRKQUEUE Queue;
    PRKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the current thread is processing a queue entry, then remove
    // the thrread from the queue object thread list and attempt to
    // activate another thread that is blocked on the queue object.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        RemoveEntryList(&Thread->QueueListEntry);
        KiActivateWaiterQueue(Queue);
    }

    //
    // Set the state of the current thread object to Signaled, and attempt
    // to satisfy as many Waits as possible.
    //

    Thread->Header.SignalState = TRUE;
    if (IsListEmpty(&Thread->Header.WaitListHead) != TRUE) {
        KiWaitTest((PVOID)Thread, 0);
    }

    //
    // Remove thread from its parent process' thread list.
    //

    RemoveEntryList(&Thread->ThreadListEntry);

    //
    // Set thread scheduling state to terminated, decrement the process'
    // stack count, select a new thread to run on the current processor,
    // and swap context to the new thread.
    //

    Thread->State = Terminated;
    Process = Thread->ApcState.Process;
    Process->StackCount -= 1;

    //
    // Rundown any architectural specific structures.
    //

    KiRundownThread(Thread);

    //
    // Insert the reaper DPC into the DPC queue to delete the stack and release
    // the reference on the thread object.
    //

    InsertTailList(&PsReaperListHead, &((PETHREAD)Thread)->ReaperListEntry);
    KeInsertQueueDpc(&PsReaperDpc, NULL, NULL);

    //
    // Get off the processor for the last time.
    //

    KiSwapThread();
    return;
}

BOOLEAN
KeTestAlertThread (
    IN KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function tests to determine if the alerted variable for the
    specified processor mode has a value of TRUE or whether a user mode
    APC should be delivered to the current thread.

Arguments:

    AlertMode - Supplies the processor mode which is to be tested
        for an alerted condition.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and lock
    // APC queue.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // If the current thread is alerted for the specified processor mode,
    // then clear the alerted state. Else if the specified processor mode
    // is user and the current thread's user mode APC queue contains an entry,
    // then set user APC pending.
    //

    Alerted = Thread->Alerted[AlertMode];
    if (Alerted == TRUE) {
        Thread->Alerted[AlertMode] = FALSE;

    } else if ((AlertMode == UserMode) &&
              (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) != TRUE)) {
        Thread->ApcState.UserApcPending = TRUE;
    }

    //
    // Unlock APC queue, unlock dispatcher database, lower IRQL to its
    // previous value, and return the previous alerted state for the
    // specified mode.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return Alerted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\yield.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    yield.c

Abstract:

    This module implements the function to yield execution for one quantum
    to any other runnable thread.

Author:

    David N. Cutler (davec) 15-Mar-1996

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

NTSTATUS
NtYieldExecution (
    VOID
    )

/*++

Routine Description:

    This function yields execution to any ready thread for up to one
    quantum.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PRKPRCB Prcb;
    KPRIORITY Priority;
    NTSTATUS Status;
    PRKTHREAD Thread;

    //
    // If any other threads are ready, then attempt to yield execution.
    //

    Status = STATUS_NO_YIELD_PERFORMED;
    if (KiReadySummary != 0) {

        //
        // If a thread has not already been selected for execution, then
        // attempt to select another thread for execution.
        //

        Thread = KeGetCurrentThread();
        KiLockDispatcherDatabase(&Thread->WaitIrql);
        Prcb = KeGetCurrentPrcb();
        if (Prcb->NextThread == NULL) {
            Prcb->NextThread = KiFindReadyThread(1);
        }

        //
        // If a new thread has been selected for execution, then switch
        // immediately to the selected thread.
        //

        if (Prcb->NextThread != NULL) {

            //
            // Give the current thread a new quantum, simulate a quantum
            // end, insert the current thread in the appropriate ready list,
            // and switch context to selected thread.
            //

            Thread->Quantum = Thread->ApcState.Process->ThreadQuantum;
            Thread->State = Ready;
            Priority = Thread->Priority;
            if (Priority < LOW_REALTIME_PRIORITY) {
                Priority = Priority - Thread->PriorityDecrement - 1;
                if (Priority < Thread->BasePriority) {
                    Priority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;

            }

            Thread->Priority = (SCHAR)Priority;

            InsertTailList(&KiDispatcherReadyListHead[Priority],
                           &Thread->WaitListEntry);

            SetMember(Priority, KiReadySummary);
            KiSwapThread();
            Status = STATUS_SUCCESS;

        } else {
            KiUnlockDispatcherDatabase(Thread->WaitIrql);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\ctxswap.asm ===
title  "Context Swap"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ctxswap.asm
;
; Abstract:
;
;    This module implements the code necessary to field the dispatch
;    interrupt and to perform kernel initiated context switching.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 14-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   22-feb-90   bryanwi
;       write actual swap context procedure
;
;--

.486p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  HalClearSoftwareInterrupt,1,,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,,FASTCALL
        EXTRNP  KiReadyThread,1,,FASTCALL
        EXTRNP  KiWaitTest,2,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _KeGetCurrentThread,0
        EXTRNP  _KiDeliverApc,0
        EXTRNP  _KiQuantumEnd,0
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeBugCheck,1

        extrn   _KiTrap13:PROC
        extrn   KiRetireDpcList:PROC
        extrn   _KeTickCount:DWORD

        extrn   _KiDispatcherReadyListHead:DWORD
        extrn   _KiIdleSummary:DWORD
        extrn   _KiReadySummary:DWORD
        extrn   _KiPCR:DWORD
        extrn   _KiIdleThread:DWORD

if DBG
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
endif

ifdef DEVKIT
        extrn  _KiDbgCtxSwapNotify:DWORD
endif

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Unlock Dispatcher Database"
;++
;
; VOID
; KiUnlockDispatcherDatabase (
;    IN KIRQL OldIrql
;    )
;
; Routine Description:
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database locked. Its function is to either unlock the dispatcher
;    database and return or initiate a context switch if another thread
;    has been selected for execution.
;
; Arguments:
;
;    (TOS)   Return address
;
;    (ecx)   OldIrql - Supplies the IRQL when the dispatcher database
;        lock was acquired.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KiUnlockDispatcherDatabase, 1

;
; Check if a new thread is scheduled for execution.
;

        cmp     PCR[PcPrcbData+PbNextThread], 0 ; check if next thread
        jne     short Kiu20             ; if ne, new thread scheduled

;
; Release dispatcher database lock, lower IRQL to its previous level,
; and return.
;

Kiu00:                                  ;

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     @KfLowerIrql@4          ; lower IRQL to previous level

;
; A new thread has been selected to run on the current processor, but
; the new IRQL is not below dispatch level. If the current processor is
; not executing a DPC, then request a dispatch interrupt on the current
; processor.
;

Kiu10:  cmp     dword ptr PCR[PcPrcbData.PbDpcRoutineActive],0  ; check if DPC routine active
        jne     short Kiu00             ; if ne, DPC routine is active

        push    ecx                     ; save new IRQL

        mov     cl, DISPATCH_LEVEL      ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
        pop     ecx                     ; restore new IRQL

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     @KfLowerIrql@4          ; lower IRQL to previous level

;
; Check if the previous IRQL is less than dispatch level.
;

Kiu20:  cmp     cl, DISPATCH_LEVEL      ; check if IRQL below dispatch level
        jge     short Kiu10             ; if ge, not below dispatch level

;
; There is a new thread scheduled for execution and the previous IRQL is
; less than dispatch level. Context switch to the new thread immediately.
;
;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 4, 1, 0)
        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        lea     ebx, _KiPCR             ; get address of PCR
        mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     [edi].ThWaitIrql, cl    ; save previous IRQL
        mov     ecx, edi                ; set address of current thread
        fstCall KiReadyThread           ; reready thread for execution
        mov     cl, [edi].ThWaitIrql    ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        or      al, al                  ; check if kernel APC pending
        mov     cl, [esi].ThWaitIrql    ; get original wait IRQL
        jnz     short Kiu50             ; if nz, kernel APC pending

Kiu30:  mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     @KfLowerIrql@4          ; lower IRQL to previous level

Kiu50:  mov     cl, APC_LEVEL           ; lower IRQL to APC level
        fstCall KfLowerIrql             ;
        xor     eax, eax                ; set previous mode to kernel
        stdCall _KiDeliverApc           ; deliver kernel mode APC
        xor     ecx, ecx                ; set original wait IRQL
        jmp     short Kiu30

fstENDP KiUnlockDispatcherDatabase

        page ,132
        subttl  "Swap Thread"
;++
;
; VOID
; KiSwapThread (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called to select the next thread to run on the
;    current processor and to perform a context switch to the thread.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Wait completion status (eax).
;
;--

cPublicFastCall KiSwapThread, 0
.fpo (0, 0, 0, 4, 1, 0)

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;

        lea     ebx, _KiPCR             ; get address of PCR
        mov     edx, [ebx].PcPrcbData.PbNextThread ; get next thread address
        or      edx, edx                ; check if next thread selected
        jnz     Swt140                  ; if nz, next thread selected

;
; Find the highest nibble in the ready summary that contains a set bit
; and left justify so the nibble is in bits <31:28>
;

        mov     ecx, 16                 ; set base bit number
        mov     edi, _KiReadySummary    ; get ready summary
        mov     esi, edi                ; copy ready summary
        shr     esi, 16                 ; isolate bits <31:16> of summary
        jnz     short Swt10             ; if nz, bits <31:16> are nonzero
        xor     ecx, ecx                ; set base bit number
        mov     esi, edi                ; set bits <15:0> of summary
Swt10:  shr     esi, 8                  ; isolate bits <15:8> of low bits
        jz      short Swt20             ; if z, bits <15:8> are zero
        add     ecx, 8                  ; add offset to nonzero byte
Swt20:  mov     esi, edi                ; isolate highest nonzero byte
        shr     esi, cl                 ;
        add     ecx, 3                  ; adjust to high bit of nibble
        cmp     esi, 10h                ; check if high nibble nonzero
        jb      short Swt30             ; if b, then high nibble is zero
        add     ecx, 4                  ; compute ready queue priority
Swt30:  mov     esi, ecx                ; left justify ready summary nibble
        not     ecx                     ;
        shl     edi, cl                 ;
        or      edi, edi                ;

;
; If the next bit is set in the ready summary, then scan the corresponding
; dispatcher ready queue.
;

Swt40:  js      short Swt60             ; if s, queue contains an entry
Swt50:  sub     esi, 1                  ; decrement ready queue priority
        shl     edi, 1                  ; position next ready summary bit
        jnz     short Swt40             ; if nz, more queues to scan

;
; All ready queues were scanned without finding a runnable thread so
; default to the idle thread and set the appropriate bit in idle summary.
;

        mov     _KiIdleSummary, 1       ; set idle summary bit

        lea     edx, _KiIdleThread      ; set idle thread address
        jmp     Swt140                  ;

;
; If the thread can execute on the current processor, then remove it from
; the dispatcher ready queue.
;

        align   4
swt60:  lea     ebp, [esi*8] + _KiDispatcherReadyListHead ; get ready queue address
        mov     ecx, [ebp].LsFlink      ; get address of first queue entry
Swt70:  mov     edx, ecx                ; compute address of thread object
        sub     edx, ThWaitListEntry    ;

;
; Remove the selected thread from the ready queue.
;

        mov     eax, [ecx].LsFlink      ; get list entry forward link
        mov     ebp, [ecx].LsBlink      ; get list entry backward link
        mov     [ebp].LsFlink, eax      ; set forward link in previous entry
        mov     [eax].LsBlink, ebp      ; set backward link in next entry
        cmp     eax, ebp                ; check if list is empty
        jnz     short Swt140            ; if nz, list is not empty
        mov     ebp, 1                  ; clear ready summary bit
        mov     ecx, esi                ;
        shl     ebp, cl                 ;
        xor     _KiReadySummary, ebp    ;

;
; Swap context to the next thread.
;

Swt140: mov     esi, edx                ; set address of next thread
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; set current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     cl, [edi].ThWaitIrql    ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        or      al, al                  ; check if kernel APC pending
        mov     edi, [esi].ThWaitStatus ; save wait completion status
        mov     cl, [esi].ThWaitIrql    ; get wait IRQL
        jnz     short Swt160            ; if nz, kernel APC pending

Swt150: fstCall KfLowerIrql             ; lower IRQL to previous value

        mov     eax, edi                ; set wait completion status
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4                ;
        fstRET  KiSwapThread            ;

Swt160: mov     cl, APC_LEVEL           ; lower IRQL to APC level
        fstCall KfLowerIrql             ;
        xor     eax, eax                ; set previous mode to kernel
        stdCall _KiDeliverApc           ; deliver kernel mode APC
        xor     ecx, ecx                ; set original wait IRQL
        jmp     short Swt150

fstENDP KiSwapThread

        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at DISPATCH_LEVEL. Its function is to process the Deferred Procedure Call
;    (DPC) list, and then perform a context switch if a new thread has been
;    selected for execution on the processor.
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database unlocked. When a return to the caller finally occurs, the
;    IRQL remains at DISPATCH_LEVEL, and the dispatcher database is still
;    unlocked.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--

        align 16
cPublicProc _KiDispatchInterrupt ,0
cPublicFpo 0, 0

        lea     ebx, _KiPCR             ; get address of PCR
kdi00:  lea     eax, [ebx].PcPrcbData.PbDpcListHead ; get DPC listhead address

;
; Disable interrupts and check if there is any work in the DPC list
; of the current processor.
;

kdi10:  cli                             ; disable interrupts
        cmp     eax, [eax].LsFlink      ; check if DPC List is empty
        je      short kdi40             ; if eq, list is empty
        push    ebp                     ; save register

;
; Exceptions occuring in DPCs are unrelated to any exception handlers
; in the interrupted thread.  Terminate the exception list.
;

        push    [ebx].PcExceptionList
        mov     [ebx].PcExceptionList, EXCEPTION_CHAIN_END

;
; Switch to the DPC stack for this processor.
;

        mov     edx, esp
        mov     esp, [ebx].PcPrcbData.PbDpcStack
        push    edx

.fpo (0, 0, 0, 1, 1, 0)

        mov     ebp, eax                ; set address of DPC listhead
        call    KiRetireDpcList         ; process the current DPC list

;
; Switch back to the current thread stack, restore the exception list
; and saved EBP.
;

        pop     esp
	pop     [ebx].PcExceptionList
        pop     ebp

.fpo (0, 0, 0, 0, 0, 0)

;
; Check to determine if quantum end is requested.
;
; N.B. If a new thread is selected as a result of processing the quantum
;      end request, then the new thread is returned with the dispatcher
;      database locked. Otherwise, NULL is returned with the dispatcher
;      database unlocked.
;

kdi40:  sti                             ; enable interrupts
        cmp     dword ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; quantum end requested
        jne     kdi90                   ; if neq, quantum end request

;
; Check to determine if a new thread has been selected for execution on this
; processor.
;

        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; check addr of next thread object
        je      short kdi70             ; if eq, then no new thread

;
; Disable interrupts and attempt to acquire the dispatcher database lock.
;

        mov     eax, [ebx].PcPrcbData.PbNextThread ; get next thread address

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 3, 1, 0)

kdi60:  sub     esp, 3*4
        mov     [esp+8], esi            ; save registers
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     esi, eax                ; set next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     ecx, edi                ; set address of current thread
        fstCall KiReadyThread           ; ready thread (ecx) for execution
        mov     cl, 1                   ; set APC interrupt bypass disable
        call    SwapContext             ; call context swap routine
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        add     esp, 3*4
kdi70:  stdRET  _KiDispatchInterrupt    ; return

;
; Process quantum end event.
;
; N.B. If the quantum end code returns a NULL value, then no next thread
;      has been selected for execution. Otherwise, a next thread has been
;      selected and the dispatcher databased is locked.
;

kdi90:  mov     dword ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; clear quantum end indicator
        stdCall _KiQuantumEnd           ; process quantum end
        or      eax, eax                ; check if new thread selected
        jne     short kdi60             ; if ne, new thread selected
        stdRET  _KiDispatchInterrupt    ; return

stdENDP _KiDispatchInterrupt

        page ,132
        subttl  "Swap Context to Next Thread"
;++
;
; Routine Description:
;
;    This routine is called to swap context from one thread to the next.
;    It swaps context, flushes the data, instruction, and translation
;    buffer caches, restores nonvolatile integer registers, and returns
;    to its caller.
;
;    N.B. It is assumed that the caller (only callers are within this
;         module) saved the nonvolatile registers, ebx, esi, edi, and
;         ebp. This enables the caller to have more registers available.
;
; Arguments:
;
;    cl - APC interrupt bypass disable (zero enable, nonzero disable).
;    edi - Address of previous thread.
;    esi - Address of next thread.
;    ebx - Address of PCR.
;
; Return value:
;
;    al - Kernel APC pending.
;    ebx - Address of PCR.
;    esi - Address of current thread object.
;
;--

        align   16
        public  SwapContext

SwapContext     proc


;
;   NOTE:   The ES: override on the move to ThState is part of the
;           lazy-segment load system.  It assures that ES has a valid
;           selector in it, thus preventing us from propagating a bad
;           ES accross a context switch.
;
;           Note that if segments, other than the standard flat segments,
;           with limits above 2 gig exist, neither this nor the rest of
;           lazy segment loads are reliable.
;
; Note that ThState must be set before the dispatcher lock is released
; to prevent KiSetPriorityThread from seeing a stale value.
;

;
; Save the APC disable flag and set new thread state to running.
;

        or      cl, cl                  ; set zf in flags
        mov     byte ptr es:[esi]+ThState, Running ; set thread state to running
        pushfd
cPublicFpo 0, 1

;
; Save the APC disable flag and the exception listhead.
; (also, check for DPC running which is illegal right now).
;

        mov     ecx, [ebx]+PcExceptionList ; save exception list
        cmp     [ebx]+PcPrcbData+PbDpcRoutineActive, 0
        push    ecx
cPublicFpo 0, 2
        jne     sc91                    ; bugcheck if DPC active.

;
; Notify the profiling function of the context switch.
;

ifdef DEVKIT

        cmp     _KiDbgCtxSwapNotify, 0
        jne     sc92
sc03:

endif ; DEVKIT

;
; On a uniprocessor system the NPX state is swapped in a lazy manner.
; If a thread whose state is not in the coprocessor attempts to perform
; a coprocessor operation, the current NPX state is swapped out (if needed),
; and the new state is swapped in durning the fault.  (KiTrap07)
;
; On a multiprocessor system we still fault in the NPX state on demand, but
; we save the state when the thread switches out (assuming the NPX state
; was loaded).  This is because it could be difficult to obtain the thread's
; NPX in the trap handler if it was loaded into a different processor's
; coprocessor.
;
        mov     ebp, cr0                ; get current CR0
        mov     edx, ebp

;
; Switch stacks:
;
;   1.  Save old esp in old thread object.
;   2.  Copy stack base and stack limit into TSS AND PCR
;   3.  Load esp from new thread object
;
; Keep interrupts off so we don't confuse the trap handler into thinking
; we've overrun the kernel stack.
;

        cli                             ; disable interrupts
        mov     [edi]+ThKernelStack, esp ; save old kernel stack pointer
        mov     eax, [esi]+ThStackBase  ; get new initial stack pointer
        mov     ecx, [esi]+ThStackLimit ; get stack limit
        sub     eax, NPX_FRAME_LENGTH   ; space for NPX_FRAME & NPX CR0 flags
        mov     [ebx]+PcStackLimit, ecx ; set new stack limit
        mov     [ebx]+PcStackBase, eax  ; set new stack base

.errnz (NPX_STATE_NOT_LOADED - CR0_TS - CR0_MP)
.errnz (NPX_STATE_LOADED - 0)

; (eax) = Initial Stack
; (ebx) = Prcb
; (edi) = OldThread
; (esi) = NewThread
; (ebp) = Current CR0
; (edx) = Current CR0

        xor     ecx, ecx
        mov     cl, [esi]+ThNpxState            ; New NPX state is (or is not) loaded

        and     edx, NOT (CR0_MP+CR0_EM+CR0_TS) ; clear thread settable NPX bits
        or      ecx, edx                        ; or in new thread's cr0
        or      ecx, [eax]+FpCr0NpxState        ; merge new thread settable state
        cmp     ebp, ecx                ; check if old and new CR0 match
        jne     sc_reload_cr0           ; if ne, no change in CR0

        align   4
sc06:   mov     esp, [esi]+ThKernelStack ; set new stack pointer
        sti                             ; enable interrupts

;
; Update context switch counters.
;

        inc     dword ptr [esi]+ThContextSwitches ; thread count
        inc     dword ptr [ebx]+PcPrcbData+PbContextSwitches ; processor count
        pop     ecx                     ; restore exception list
        mov     [ebx].PcExceptionList, ecx ;

;
; If the new thread has a kernel mode APC pending, then request an APC
; interrupt.
;

        cmp     byte ptr [esi].ThApcState.AsKernelApcPending, 0 ; APC pending?
        jne     short sc80              ; if ne, kernel APC pending
        popfd                           ; restore flags
        xor     eax, eax                ; clear kernel APC pending
        ret                             ; return

;
; The new thread has an APC interrupt pending. If APC interrupt bypass is
; enable, then return kernel APC pending. Otherwise, request a software
; interrupt at APC_LEVEL and return no kernel APC pending.
;

sc80:   popfd                           ; restore flags
        jnz     short sc90              ; if nz, APC interupt bypass disabled
        mov     al, 1                   ; set kernel APC pending
        ret                             ;

sc90:   mov     cl, APC_LEVEL           ; request software interrupt level
        fstCall HalRequestSoftwareInterrupt ;
        xor     eax, eax                ; clear kernel APC pending
        ret                             ;

;
; Cr0 has changed (ie, floating point processor present), load the new value.
;

sc_reload_cr0:
if DBG

        test    byte ptr [esi]+ThNpxState, NOT (CR0_TS+CR0_MP)
        jnz     sc_error                ;
        test    dword ptr [eax]+FpCr0NpxState, NOT (CR0_PE+CR0_MP+CR0_EM+CR0_TS)
        jnz     sc_error3               ;

endif
        mov     cr0,ecx                 ; set new CR0 NPX state
        jmp     sc06

;
; Notify context swap callout routine.  This code is out of line to
; optimize the normal case (which is expected to be the case where
; there is no callout routine).
;

ifdef DEVKIT

sc92:   mov     edx, [esi].EtUniqueThread ; set new thread unique id
        mov     ecx, [edi].EtUniqueThread ; set old thread unique id
        call    [_KiDbgCtxSwapNotify]     ; notify callout routine
        jmp     sc03

endif ; DEVKIT

.fpo (2, 0, 0, 0, 0, 0)
sc91:   stdCall _KeBugCheck <ATTEMPTED_SWITCH_FROM_DPC>
        ret                             ; return

if DBG
sc_error5:  int 3
sc_error4:  int 3
sc_error3:  int 3
sc_error2:  int 3
sc_error:   int 3
endif

SwapContext     endp

        page , 132
        subttl "Flush EntireTranslation Buffer"
;++
;
; VOID
; KeFlushCurrentTb (
;     )
;
; Routine Description:
;
;     This function flushes the entire translation buffer (TB) on the current
;     processor and also flushes the data cache if an entry in the translation
;     buffer has become invalid.
;
; Arguments:
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KeFlushCurrentTb ,0

        mov     eax, cr3                ; (eax) = directory table base
        mov     cr3, eax                ; flush TLB
        stdRET    _KeFlushCurrentTb

stdENDP _KeFlushCurrentTb

cPublicProc _KeFlushCurrentTbAndInvalidateAllCaches ,0

        mov     eax, cr3                ; (eax) = directory table base
        mov     cr3, eax                ; flush TLB

cPublicProc _KeInvalidateAllCaches ,0

        wbinvd
        stdRET    _KeFlushCurrentTbAndInvalidateAllCaches

stdENDP _KeInvalidateAllCaches

stdENDP _KeFlushCurrentTbAndInvalidateAllCaches

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\clockint.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    clockint.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.  It works on UP and SystemPro.
;
;--

.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include i386\ix8259.inc
        .list

        EXTRNP  HalBeginClockInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,,FASTCALL
        extrn   _KiTimerTableListHead:DWORD
        extrn   _KiTimerExpireDpc:DWORD
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint
        EXTRNP  _DbgBreakPointWithStatus,1
        extrn   _KiPCR:DWORD
        extrn   _KiIdleThread:DWORD
        extrn   _KeTickCount:DWORD
        extrn   _KeInterruptTime:DWORD
        extrn   _KeSystemTime:DWORD

if DBG
        extrn   _DbgPrint:near
        extrn   _KiDPCTimeout:DWORD
        extrn   _MsgDpcTimeout:BYTE
endif

ifdef DEVKIT
        EXTRNP  _KdPollBreakIn
        extrn   _KiDbgClockInt:DWORD
endif

        page ,132
        subttl  "Update System Time"

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; KeClockInterrupt(
;       VOID
;       )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK.
;    Its function is to update the system time and check to determine if a timer
;    has expired.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _KeClockInterrupt     ,0

;
; Save machine state in trap frame.
;

        ENTER_INTERRUPT

;
; (esp) - base of trap frame
; (ebp) - base of trap frame
;

;
; Dismiss interrupt and raise irq level to CLOCK_LEVEL.
;

.errnz CLOCK_VECTOR - PRIMARY_VECTOR_BASE
        xor     ecx, ecx
        mov     edx, CLOCK_LEVEL
        push    ecx                     ; allocate space to save OldIrql
        fstCall HalBeginClockInterrupt

ifdef DEVKIT
;
; Call the debugger's clock interrupt routine if there is one.
;
        mov     esi,_KiDbgClockInt
        test    esi, esi
        jz      kust_nodbgr
        push    ebp
        call    esi
kust_nodbgr:
endif

;
; Update interrupt time.
;
; N.B. The interrupt time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     edi,_KeInterruptTime+0  ; get low interrupt time
        mov     esi,_KeInterruptTime+4  ; get high interrupt time
        mov     ebx,_KeTickCount        ; get tick count
        add     edi,CLOCK_TIME_INCREMENT; add time increment
        adc     esi,0                   ; propagate carry
        mov     _KeInterruptTime+8,esi  ; store high 2 interrupt time
        mov     _KeInterruptTime+0,edi  ; store low interrupt time
        mov     _KeInterruptTime+4,esi  ; store high 1 interrupt time

;
; Update system time.
;
; N.B. The system time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     ecx,_KeSystemTime+0     ; get low interrupt time
        mov     edx,_KeSystemTime+4     ; get high interrupt time
        add     ecx,CLOCK_TIME_INCREMENT; add time increment
        adc     edx,0                   ; propagate carry
        mov     _KeSystemTime+8,edx     ; store high 2 interrupt time
        mov     _KeSystemTime+0,ecx     ; store low interrupt time
        mov     _KeSystemTime+4,edx     ; store high 1 interrupt time

;
; Update tick count.
;

        mov     eax,ebx                 ; copy tick count
        mov     ecx,ebx                 ; copy tick count
        inc     ecx                     ; increment tick count
        mov     _KeTickCount,ecx        ; store low tick count

;
; Check to determine if a timer has expired.
; (edi:esi) = KiInterruptTime
; (eax) = bucket
; (ebx) = KeTickCount.LowPart
;

kust10: and     eax,TIMER_TABLE_SIZE-1  ; isolate current hand value
        lea     ecx,_KiTimerTableListHead[eax*8] ; get listhead addrees
        mov     edx,[ecx]               ; get first entry address
        cmp     ecx,edx                 ; check if list is empry
        je      kustxx                  ; if equal, list is empty
        cmp     esi,[edx].TiDueTime.TmHighTime-TiTimerListEntry ; compare high
        jb      kustxx                  ; if below, timer has not expired
        ja      short kust15            ; if above, timer has expired
        cmp     edi,[edx].TiDueTime.TmLowTime-TiTimerListEntry ; compare low
        jb      kustxx                  ; if below, timer has not expired

kust15:
;
; Timer has expired, put timer expiration DPC in the current processor's DPC
; queue.
;
; (ebx) = KeTickCount.LowPart
;

        lea     eax,_KiTimerExpireDpc+DpDpcListEntry ; get list entry address
        cmp     byte ptr [eax]+(DpInserted-DpDpcListEntry), 0H ; check if inserted
        jnz     kustxx                  ; if nz, DPC already inserted

        cli

        mov     byte ptr [eax]+(DpInserted-DpDpcListEntry), 1 ; mark as inserted
        mov     [eax]+(DpSystemArgument1-DpDpcListEntry),ebx  ; pass tick count
        lea     ecx,PCR[PcPrcbData+PbDpcListHead] ; compute DPC listhead address
        mov     ebx,[ecx]+LsBlink       ; get address of last entry in list
        mov     [ecx]+LsBlink, eax      ; set new address of last entry
        mov     [ebx]+LsFlink, eax      ; set forward link in old last entry
        mov     [eax]+LsFlink, ecx      ; set forward link in new last entry
        mov     [eax]+LsBlink, ebx      ; set backward link in new last entry

        sti                             ; enable interrupt

; request dispatch interrupt

        mov     ecx, DISPATCH_LEVEL
        fstCall HalRequestSoftwareInterrupt

kustxx:
ifdef DEVKIT
        cmp     _KdDebuggerEnabled, 0
        jz      kust30
        stdCall _KdPollBreakIn
        test    al,al
        jz      kust30
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
kust30:
endif

;
; inline KeUpdateRunTime to do the actual work
;

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]
        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; (ebx)->current thread

;
; Update the total time spent in kernel mode
;

        cmp     byte ptr [esp], DISPATCH_LEVEL
        jc      short Kutp4             ; OldIrql<2, then kernel
        ja      short Kutp3             ; OldIrql>2, then interrupt

        cmp     dword ptr PCR[PcPrcbData.PbDpcRoutineActive], 0
        jz      short Kutp4             ; Executing Dpc?, no then thread time

        inc     dword ptr PCR[PcPrcbData.PbDpcTime]
if DBG
;
; Check for dpcs which run for too long
;

        inc     dword ptr PCR[PcPrcbData.PbDebugDpcTime]
        mov     edx, _KiDPCTimeout
        cmp     dword ptr PCR[PcPrcbData.PbDebugDpcTime], edx
        jc      Kutp55                  ; Jump if not over limit

;
; Dpc time has exceeded the allowed quanta
;

        push    offset FLAT:_MsgDpcTimeout ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 1 * 4              ; remove arguments from stack

        cmp     _KdDebuggerEnabled, 0   ; check if debugger enabled
        je      short Kutp6             ; if eq, no debugger, continue
        stdCall _DbgBreakPoint          ; break into debugger

Kutp6:  mov     dword ptr PCR[PcPrcbData.PbDebugDpcTime], 0 ; Reset Time
endif
        jmp     Kutp55

ALIGN 4
Kutp3:
;
; Update the time spent at interrupt time for this processor
;

        inc     dword ptr PCR[PcPrcbData.PbInterruptTime]
        jmp     Kutp55

ALIGN 4
Kutp4:

;
; Update the time spent in kernel mode for the current thread.
;

        inc     dword ptr [ebx]+ThKernelTime

;
; Decrement current thread quantum and check to determine if a quantum end
; has occurred.
;

ALIGN 4
Kutp55: sub     dword ptr [ebx]+ThQuantum, CLOCK_QUANTUM_DECREMENT ; decrement quantum
        jg      Kutp75                      ; if > 0, time remaining on quantum

;
; Set quantum end flag and initiate a dispather interrupt on the current
; processor.
;

        cmp     ebx,offset FLAT:_KiIdleThread ; check if idle thread
        jz      Kutp75                      ; if z, then idle thread
        mov     PCR[PcPrcbData.PbQuantumEnd], esp ; set quantum end indicator
        mov     ecx, DISPATCH_LEVEL         ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
Kutp75:                                     ;

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT

stdENDP _KeClockInterrupt

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\int.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    int.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Disable Processor Interrupts"
;++
;
; BOOLEAN
; KiDisableInterrupts(
;    VOID
;    )
;
; Routine Description:
;
;    This routine disables interrupts at the processor level.  It does not
;    edit the PICS or adjust IRQL, it is for use in the debugger only.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    (eax) = !0 if interrupts were on, 0 if they were off
;
;--
cPublicProc _KiDisableInterrupts    ,0
cPublicFpo 0, 0
        pushfd
        pop     eax
        and     eax,EFLAGS_IF               ; (eax) = the interrupt bit
        shr     eax,EFLAGS_SHIFT            ; low bit of (eax) == interrupt bit
        cli
        stdRET    _KiDisableInterrupts

stdENDP _KiDisableInterrupts


        page ,132
        subttl  "Restore Processor Interrupts"
;++
;
; VOID
; KiRestoreInterrupts(
;    BOOLEAN Restore
;    )
;
; Routine Description:
;
;    This routine restores interrupts at the processor level.  It does not
;    edit the PICS or adjust IRQL, it is for use in the debugger only.
;
; Arguments:
;
;    Restore (esp+4) - a "boolean" returned by KiDisableInterrupts, if
;                       !0 interrupts will be turned on, else left off.
;
;       NOTE: We don't actually test the boolean as such, we just or
;             it directly into the flags!
;
; Return Value:
;
;    none.
;
;--
cPublicProc _KiRestoreInterrupts    ,1
cPublicFpo 1, 0
        xor     eax, eax
        mov     al, byte ptr [esp]+4
        shl     eax,EFLAGS_SHIFT            ; (eax) == the interrupt bit
        pushfd
        or      [esp],eax                   ; or EI into flags
        popfd
        stdRET    _KiRestoreInterrupts

stdENDP _KiRestoreInterrupts

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;        Some of the code is extracted from Cruiser (mainly,
;        the code to determine 386 stepping.)
;
; Environment:
;
;    80x86
;
; Revision History:
;
;--

        .xlist
include ks386.inc
include callconv.inc
        .list

.586p

_TEXT   SEGMENT DWORD PUBLIC 'CODE'      ; Put IdleLoop in text section
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; ULONGLONG
; FASTCALL
; RDMSR (
;   IN ULONG MsrRegister
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicFastCall RDMSR, 1
    rdmsr
    fstRET  RDMSR
fstENDP RDMSR


;++
;
; VOID
; WRMSR (
;   IN ULONG MsrRegister
;   IN LONGLONG MsrValue
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _WRMSR, 3
    mov     ecx, [esp+4]
    mov     eax, [esp+8]
    mov     edx, [esp+12]
    wrmsr
    stdRET  _WRMSR
stdENDP _WRMSR

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\geni386.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    genoff.c

Abstract:

    This module implements a program which generates structure offset
    definitions for kernel structures that are accessed in assembly code.

Author:

    Bryan M. Willman (bryanwi) 16-Oct-90


To build:

    in ke\up do a "nmake UMAPPL=geni386"
    watch out for precompiled headers


Revision History:

    Forrest Foltz (forrestf) 24-Jan-1998

        Modified format to use new obj-based procedure.

--*/


#include "ki.h"
#pragma hdrstop

#include "nturtl.h"
#include "ntdbg.h"
#include "xdisk.h"
#include "bldr.h"
#include "xpcicfg.h"

/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    genxx.h

Abstract:

    This file contains macros (some of them destined for the M4 preprocessor)
    to aid in the generation of ks & hal header files.  This is used by
    ke\xxx\genxxx.c, as well as sdktools\genxx.

Author:

    Forrest C. Foltz (forrestf) 23-Jan-1998

Revision History:

--*/



//
// Structure element definitions.  
//

#define MAX_ELEMENT_NAME_LEN 127    // big enough for comments too
typedef struct _STRUC_ELEMENT {

//
// Flags is one or more SEF_xxx, defined below.
//

    UINT64 Flags;

//
// Note that Equate is used to store a pointer in the case of bitfield
// processing.
//

    UINT64 Equate;

//
// Name should be quite long, as it is used to hold comments as well.
//

    CHAR Name[ MAX_ELEMENT_NAME_LEN + 1 ];
} STRUC_ELEMENT, *PSTRUC_ELEMENT;

#define SEF_ENABLE_MASK     0x0000FF00      
#define SEF_HAL             0x00000100
#define SEF_KERNEL          0x00000200

#define SEF_INC_FORMAT_MASK 0x00010000
#define SEF_H_FORMAT        0x00000000
#define SEF_INC_FORMAT      0x00010000

//
// Types.  Note that SETMASK, CLRMASK has no effect on te BITFLD types.  BITFLD
// types have SEF_HAL | SEF_KERNEL set in the type.
//

#define SEF_TYPE_MASK       0x000000FF
#define SEF_EQUATE          0x00000000
#define SEF_EQUATE64        0x00000001
#define SEF_COMMENT         0x00000002      
#define SEF_STRING          0x00000003      // Equate is vararg to printf
#define SEF_BITFLD          0x00000004
#define SEF_BITALIAS        0x00000005
#define SEF_STRUCTURE       0x00000006
#define SEF_SETMASK         0x00000010      // Equate is the mask
#define SEF_CLRMASK         0x00000011      // Equate is the mask
#define SEF_END             0x00000012
#define SEF_START           0x00000013
#define SEF_PATH            0x00000014

//
// Note that BITFLD entries have per-entry hal|kernel flags
//


//
// Define architecture specific generation macros.
//

#define SEF_FLAGS 0
#define HAL SEF_HAL
#define KERNEL SEF_KERNEL

#ifndef ULONG_MAX
#define ULONG_MAX 0xFFFFFFFF
#endif

#ifdef _WIN64_
#define SEF_UINT SEF_EQUATE64
#else
#define SEF_UINT SEF_EQUATE
#endif

//
// genDef(Pc, KPCR, MinorVersion)
//
// -> #define PcMinorVersion 0x0
//

#define genDef(Prefix, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Prefix #Member },

//
// genAlt( PbAlignmentFixupCount, KPRCB, KeAlignmentFixupCount )
//
// -> #define PbAlignmentFixupCount 0x2f4
// 

#define genAlt(Name, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Name },

//
// genCom("This is a comment")
//
//    //
// -> // This is a comment
//    //
//

#define genCom(Comment) \
    { SEF_COMMENT, 0, Comment },

//
// genNam(PCR_MINOR_VERSION)
//
// -> #define PCR_MINOR_VERSION 0x1
//

#define genNam(Name) \
    { SEF_EQUATE, (ULONG)(Name), #Name },

//
// genNamUint(KSEG0_BASE)
//
// -> #define KSE0_BASE 0xffffffff80000000
//

#define genNamUint(Name) \
    { SEF_UINT, (UINT64)(Name), #Name },

//
// genVal(FirmwareFrameLength, FIRMWARE_FRAME_LENGTH)
//
// -> #define FirmwareFrameLength 0x250
//
// Note: if the value is 64-bit when _WIN64_ is enabled, use genValUint()
//

#define genVal(Name, Value) \
    { SEF_EQUATE, (ULONG)(Value), #Name },

//
// genValUint(KiPcr, KIPCR)
//
// -> #define KiPcr 0xe0000000ffffe000
//

#define genValUint(Name, Value) \
    { SEF_UINT, (UINT64)(Value), #Name },

//
// genSpc()
//
// ->
//

#define genSpc() \
    { SEF_STRING, 0, "\n" },

//
// genStr("    PCR equ ds:[0%lXH]\n", KIP0PCRADDRESS)
//
// ->     PCR equ ds:[0FFDFF000H]
//

#define genStr(String, Value) \
    { SEF_STRING, (ULONG_PTR)(Value), String },

//
// genTxt("ifdef NT_UP\n")
//
// -> ifdef NT_UP
//

#define genTxt(String) \
    { SEF_STRING, 0, String },

#define DisableInc( x ) \
    { SEF_CLRMASK, x, "" },

#define EnableInc( x ) \
    { SEF_SETMASK, x, "" },

#define MARKER_STRING "This is the genxx marker string."

//
// Source file can specify the _NTDRIVE\_NTROOT - relative output path.
// 'f' is the set of enable-flags that should be routed to this file.
// Use '0' if there is only a single output file.
//
// 'f' should also contain one of SEF_H_FORMAT or SEF_INC_FORMAT to
// indicate whether the generated file is in 'header file' or 'include file'
// format.
//

#define setPath( p, f ) \
    { SEF_PATH | f, 0, p },

//
// START_LIST defines the first element in ElementList.  This element contains
// a (possibly truncated) pointer to the ElementList array.  This is used to
// determine the fixup RA bias.
//

#define START_LIST \
    { SEF_START, (ULONG_PTR)ElementList, MARKER_STRING },

#define END_LIST \
    { SEF_END, 0, "" }

//
// Preprocessor assertion.  Do something here to make the compiler generate
// an error if x != y.
//

#define ASSERT_SAME( x, y )

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#ifndef OFFSET

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif

//
// Following are some M4 macros to help with bitfields.  
//

#ifndef SKIP_M4

//
// First, define the makezeros(n) macro that will generate a string with
// n pairs of ',0'.  This is a recursively defined macro.
//



//
// Define a concatenation macro.
//



//
// The following example bitfield declaration uses HARDWARE_PTE as an
// example, which is declared (for alpha) as follows:
//
// typedef struct _HARDWARE_PTE {
//     ULONG Valid: 1;
//     ULONG Owner: 1;
//     ULONG Dirty: 1;
//     ULONG reserved: 1;
//     ULONG Global: 1;
//     ULONG GranularityHint: 2;
//     ULONG Write: 1;
//     ULONG CopyOnWrite: 1;
//     ULONG PageFrameNumber: 23;
// } HARDWARE_PTE, *PHARDWARE_PTE;
//
//
// // First, startBitStruc() is invoked with the structure name.
//
// startBitStruc( HARDWARE_PTE, SEF_HAL | SEF_KERNEL )
//
// //
// // Now, suppose we wanted to expose seven of the fields in an assembly
// // include file:
// //
//
// genBitField( Valid, PTE_VALID )
// genBitField( Owner, PTE_OWNER )
// genBitField( Dirty, PTE_DIRTY )
// genBitField( reserved )
// genBitField( Global, PTE_GLOBAL )
// genBitField( GranularityHint )
// genBitField( Write, PTE_WRITE )
// genBitField( CopyOnWrite, PTE_COPYONWRITE )
// genBitField( PageFrameNumber, PTE_PFN )
//
// Note that fields that are not used (in this case 'reserved' and
// 'GranularityHint') must still appear in the list.
//
// The above will generate a bunch of static, initialized copies of HARDWARE_PTE
// like so:
//
// HARDWARE_PTE HARDWARE_PTE_Valid = {
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Owner = {
//     0,   // Valid
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Dirty = {
//     0,   // Valid
//     0,   // Owner
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Global = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Write = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_CopyOnWrite = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_PageFrameNumber = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0,   // CopyOnWrite
//     0xFFFFFFFF };
//
// Then, as part of processing the END_LIST macro, these structures are
// generated:
//
// { SEF_BITFLD, &HARDWARE_PTE_Valid,           "PTE_VALID" },
// { SEF_BITFLD, &HARDWARE_PTE_Owner,           "PTE_OWNER" },
// { SEF_BITFLD, &HARDWARE_PTE_Dirty,           "PTE_DIRTY" },
// { SEF_BITFLD, &HARDWARE_PTE_Global,          "PTE_GLOBAL" },
// { SEF_BITFLD, &HARDWARE_PTE_Write,           "PTE_WRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_CopyOnWrite,     "PTE_COPYONWRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_PageFrameNumber, "PTE_PFN" },
// { SEF_END,    0,                             "" }
//
//
// ... and that's what gets compiled by the target compiler into the .obj.
// Now, the final stage: genxx.exe is run against this target .obj, and
// would generate the following:
//
// #define PTE_VALID_MASK 0x1
// #define PTE_VALID 0x0
// #define PTE_OWNER_MASK 0x2
// #define PTE_OWNER 0x1
// #define PTE_DIRTY_MASK 0x4
// #define PTE_DIRTY 0x2
// #define PTE_GLOBAL_MASK 0x10
// #define PTE_GLOBAL 0x4
// #define PTE_WRITE_MASK 0x80
// #define PTE_WRITE 0x7
// #define PTE_COPYONWRITE_MASK 0x100
// #define PTE_COPYONWRITE 0x8
// #define PTE_PFN_MASK 0xfffffe00
// #define PTE_PFN 0x9
//

//
// BITFIELD_STRUCS accumulates array element initializations.  END_LIST will
// dump these into the definition array.
// 



//
// startBitStruc( <strucname>, <whichfile> )
// sets BIT_STRUC_NAME = <strucname> and resets the ZERO_FIELDS count to 0.
// It also sets the WHICH_FILE macro.
//



//
// genBitField( <fldname>, <generatedname> ) declares a structure of type
// <strucname> and initializes the <fldname> bitfield within it.
//
// Note that I used "cma" instead of an actual comma, this gets changed to
// a comma by END_LIST, below.  If I were more proficient with M4 I would know
// how to get around this.
//





//
// END_LIST dumps the array initializers accumulated by , after
// replacing each 'cma' with an actual comma.
//



#endif  // SKIP_M4



#define KS386 KERNEL
#define HAL386 HAL

STRUC_ELEMENT ElementList[] = {

    START_LIST

  EnableInc(KS386)

    #include "genxx.inc"

    //
    // Generate architecture dependent definitions.
    //

    genCom("Apc Record Structure Offset Definitions")

    genDef(Ar, KAPC_RECORD, NormalRoutine)
    genDef(Ar, KAPC_RECORD, NormalContext)
    genDef(Ar, KAPC_RECORD, SystemArgument1)
    genDef(Ar, KAPC_RECORD, SystemArgument2)
    genVal(ApcRecordLength, sizeof(KAPC_RECORD))
    genSpc()

  EnableInc(HAL386)
    genCom("Processor Control Registers Structure Offset Definitions")

    genTxt("PCR equ dword ptr [_KiPCR]\n")
    genTxt("PCRB equ byte ptr [_KiPCR]\n")

    genAlt(PcExceptionList, KPCR,  NtTib.ExceptionList)
    genAlt(PcStackBase, KPCR, NtTib.StackBase)
    genAlt(PcStackLimit, KPCR, NtTib.StackLimit)
    genDef(Pc, KPCR, SelfPcr)
    genDef(Pc, KPCR, Prcb)
    genAlt(PcTeb, KPCR, NtTib.Self)
    genDef(Pc, KPCR, Irql)
    genDef(Pc, KPCR, PrcbData)
  DisableInc (HAL386)
    genVal(ProcessorControlRegisterLength, sizeof(KPCR))

  EnableInc (HAL386)
    genCom("Tss Structure Offset Definitions")

    genDef(Tss, KTSS, Ss0)
    genDef(Tss, KTSS, Esp0)
    genDef(Tss, KTSS, Eip)
    genDef(Tss, KTSS, EFlags)
    genDef(Tss, KTSS, Esp)
    genDef(Tss, KTSS, CR3)
    genDef(Tss, KTSS, Cs)
    genDef(Tss, KTSS, Ss)
    genDef(Tss, KTSS, Ds)
    genDef(Tss, KTSS, Es)
    genDef(Tss, KTSS, Fs)
    genDef(Tss, KTSS, Gs)
    genDef(Tss, KTSS, IoMapBase)
    genDef(Tss, KTSS, IoMaps)
    genVal(TssLength, sizeof(KTSS))
  DisableInc (HAL386)

  EnableInc (HAL386)
    genCom("Gdt Descriptor Offset Definitions")

    genNam(KGDT_R0_CODE)
    genNam(KGDT_R0_DATA)
    genNam(KGDT_R0_PCR)
    genNam(KGDT_TSS)
  DisableInc (HAL386)
    genNam(KGDT_DF_TSS)
    genNam(KGDT_NMI_TSS)

  EnableInc (HAL386)
    genCom("GdtEntry Offset Definitions")

    genDef(Kgdt, KGDTENTRY, BaseLow)
    genAlt(KgdtBaseMid, KGDTENTRY, HighWord.Bytes.BaseMid)
    genAlt(KgdtBaseHi, KGDTENTRY, HighWord.Bytes.BaseHi)
    genAlt(KgdtFlags1, KGDTENTRY, HighWord.Bytes.Flags1)
    genAlt(KgdtLimitHi, KGDTENTRY, HighWord.Bytes.Flags2)
    genDef(Kgdt, KGDTENTRY, LimitLow)
    genVal(KgdtEntryLength, (sizeof(KGDTENTRY)))
    genSpc()

    genCom("IdtEntry Offset Definitions")

    genDef(Kidt, KIDTENTRY, Offset)
    genDef(Kidt, KIDTENTRY, Selector)
    genDef(Kidt, KIDTENTRY, Access)
    genDef(Kidt, KIDTENTRY, ExtendedOffset)
    genVal(KidtEntryLength, (sizeof(KIDTENTRY)))
    genSpc()

    //
    // Processor block structure definitions.
    //

    genCom("Processor Block Structure Offset Definitions")

    genDef(Pb, KPRCB, CurrentThread)
    genDef(Pb, KPRCB, NextThread)
    genDef(Pb, KPRCB, IdleThread)

#ifdef DEVKIT
    genDef(Pb, KPRCB, DebugHaltThread)
    genDef(Pb, KPRCB, DebugMonitorData)
    genDef(Pb, KPRCB, DebugDoubleFault)
#endif

  DisableInc (HAL386)

    genDef(Pb, KPRCB, NpxThread)
    genDef(Pb, KPRCB, InterruptCount)
    genDef(Pb, KPRCB, DpcTime)
    genDef(Pb, KPRCB, InterruptTime)
    genDef(Pb, KPRCB, DebugDpcTime)
    genAlt(PbContextSwitches, KPRCB, KeContextSwitches)
    genDef(Pb, KPRCB, DpcInterruptRequested)
    genDef(Pb, KPRCB, DpcListHead)
    genDef(Pb, KPRCB, DpcRoutineActive)
    genDef(Pb, KPRCB, DpcStack)
    genDef(Pb, KPRCB, QuantumEnd)
    genDef(Pb, KPRCB, NpxSaveArea)
    genVal(ProcessorBlockLength, ((sizeof(KPRCB) + 15) & ~15))

  EnableInc (HAL386)
    genCom("Time Fields (TIME_FIELDS) Structure Offset Definitions")
    genDef(Tf, TIME_FIELDS, Second)
    genDef(Tf, TIME_FIELDS, Minute)
    genDef(Tf, TIME_FIELDS, Hour)
    genDef(Tf, TIME_FIELDS, Weekday)
    genDef(Tf, TIME_FIELDS, Day)
    genDef(Tf, TIME_FIELDS, Month)
    genDef(Tf, TIME_FIELDS, Year)
    genDef(Tf, TIME_FIELDS, Milliseconds)
    genSpc()
  DisableInc (HAL386)

  EnableInc (HAL386)
    genCom("constants for system irql and IDT vector conversion")

    genNam(MAXIMUM_IDTVECTOR)
    genNam(MAXIMUM_PRIMARY_VECTOR)
    genNam(PRIMARY_VECTOR_BASE)

    genCom("Flags in the CR0 register")

    genNam(CR0_PG)
    genNam(CR0_ET)
    genNam(CR0_TS)
    genNam(CR0_EM)
    genNam(CR0_MP)
    genNam(CR0_PE)
    genNam(CR0_CD)
    genNam(CR0_NW)
    genNam(CR0_AM)
    genNam(CR0_WP)
    genNam(CR0_NE)

    genCom("Flags in the CR4 register")

    genNam(CR4_VME)
    genNam(CR4_PVI)
    genNam(CR4_TSD)
    genNam(CR4_DE)
    genNam(CR4_PSE)
    genNam(CR4_PAE)
    genNam(CR4_MCE)
    genNam(CR4_PGE)
    genNam(CR4_FXSR)
    genNam(CR4_XMMEXCPT)

    genCom("Miscellaneous Definitions")

    genNam(MAXIMUM_PROCESSORS)
    genNam(INITIAL_STALL_COUNT)
    genNam(IRQL_NOT_GREATER_OR_EQUAL)
    genNam(IRQL_NOT_LESS_OR_EQUAL)
    genNam(MUTEX_ALREADY_OWNED)
    genNam(THREAD_NOT_MUTEX_OWNER)
  DisableInc (HAL386)
    genNam(BASE_PRIORITY_THRESHOLD)
    genNam(LOW_REALTIME_PRIORITY)
    genNam(KERNEL_STACK_SIZE)
    genNam(DOUBLE_FAULT_STACK_SIZE)
    genNam(EFLAG_SELECT)
    genNam(BREAKPOINT_BREAK )
    genNam(CLOCK_QUANTUM_DECREMENT)
    genNam(THREAD_QUANTUM)
    genNam(WAIT_QUANTUM_DECREMENT)
    genNam(ROUND_TRIP_DECREMENT_COUNT)

    //
    // Print trap frame offsets relative to sp.
    //

  EnableInc (HAL386)
    genCom("Trap Frame Offset Definitions and Length")

    genDef(Ts, KTRAP_FRAME, ExceptionList)
    genDef(Ts, KTRAP_FRAME, Edi)
    genDef(Ts, KTRAP_FRAME, Esi)
    genDef(Ts, KTRAP_FRAME, Ebp)
    genDef(Ts, KTRAP_FRAME, Ebx)
    genDef(Ts, KTRAP_FRAME, Edx)
    genDef(Ts, KTRAP_FRAME, Ecx)
    genDef(Ts, KTRAP_FRAME, Eax)
    genDef(Ts, KTRAP_FRAME, ErrCode)
    genDef(Ts, KTRAP_FRAME, Eip)
    genDef(Ts, KTRAP_FRAME, SegCs)
    genAlt(TsEflags, KTRAP_FRAME, EFlags)
    genDef(Ts, KTRAP_FRAME, HardwareEsp)
    genDef(Ts, KTRAP_FRAME, HardwareSegSs)
    genDef(Ts, KTRAP_FRAME, TempSegCs)
    genDef(Ts, KTRAP_FRAME, TempEsp)
    genDef(Ts, KTRAP_FRAME, DbgEbp)
    genDef(Ts, KTRAP_FRAME, DbgEip)
    genDef(Ts, KTRAP_FRAME, DbgArgMark)
    genDef(Ts, KTRAP_FRAME, DbgArgPointer)
    genNam(KTRAP_FRAME_LENGTH)
    genNam(KTRAP_FRAME_ALIGN)
    genNam(FRAME_EDITED)
    genNam(EFLAGS_ALIGN_CHECK)
    genNam(EFLAGS_V86_MASK)
    genNam(EFLAGS_INTERRUPT_MASK)
    genNam(EFLAGS_VIF)
    genNam(EFLAGS_VIP)
    genNam(EFLAGS_USER_SANITIZE)

    genCom("Context Frame Offset and Flag Definitions")

    genNam(CONTEXT_FULL)
    genNam(CONTEXT_DEBUG_REGISTERS)
    genNam(CONTEXT_CONTROL)
    genNam(CONTEXT_FLOATING_POINT)
    genNam(CONTEXT_INTEGER)
    genNam(CONTEXT_SEGMENTS)
    genSpc()

    //
    // Print context frame offsets relative to sp.
    //

    genDef(Cs, CONTEXT, ContextFlags)
    genDef(Cs, CONTEXT, FloatSave)
    genDef(Cs, CONTEXT, Edi)
    genDef(Cs, CONTEXT, Esi)
    genDef(Cs, CONTEXT, Ebp)
    genDef(Cs, CONTEXT, Ebx)
    genDef(Cs, CONTEXT, Edx)
    genDef(Cs, CONTEXT, Ecx)
    genDef(Cs, CONTEXT, Eax)
    genDef(Cs, CONTEXT, Eip)
    genDef(Cs, CONTEXT, SegCs)
    genAlt(CsEflags, CONTEXT, EFlags)
    genDef(Cs, CONTEXT, Esp)
    genDef(Cs, CONTEXT, SegSs)
    genVal(ContextFrameLength, ROUND_UP(sizeof(CONTEXT), 16))
    genNam(DR6_LEGAL)
    genNam(DR7_LEGAL)
    genNam(DR7_ACTIVE)

    //
    // Print Registration Record Offsets relative to base
    //

    genDef(Err, EXCEPTION_REGISTRATION_RECORD, Handler)
    genDef(Err, EXCEPTION_REGISTRATION_RECORD, Next)

    //
    // Print floating point field offsets relative to Context.FloatSave
    //

    genCom("Floating save area field offset definitions")

    genDef(Fx, FLOATING_SAVE_AREA, ControlWord)
    genDef(Fx, FLOATING_SAVE_AREA, StatusWord)
    genDef(Fx, FLOATING_SAVE_AREA, ErrorOffset)
    genDef(Fx, FLOATING_SAVE_AREA, ErrorSelector)
    genDef(Fx, FLOATING_SAVE_AREA, DataOffset)
    genDef(Fx, FLOATING_SAVE_AREA, DataSelector)
    genDef(Fx, FLOATING_SAVE_AREA, MXCsr)
    genDef(Fp, FLOATING_SAVE_AREA, Cr0NpxState)

    genSpc()
    genVal(NPX_FRAME_LENGTH, sizeof(FX_SAVE_AREA))

    //
    // Processor State Frame offsets relative to base
    //

    genCom("Processor State Frame Offset Definitions")

    genDef(Ps, KPROCESSOR_STATE, ContextFrame)
    genDef(Ps, KPROCESSOR_STATE, SpecialRegisters)
    genDef(Sr, KSPECIAL_REGISTERS, Cr0)
    genDef(Sr, KSPECIAL_REGISTERS, Cr2)
    genDef(Sr, KSPECIAL_REGISTERS, Cr3)
    genDef(Sr, KSPECIAL_REGISTERS, Cr4)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr0)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr1)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr2)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr3)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr6)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr7)
    genAlt(SrGdtr, KSPECIAL_REGISTERS, Gdtr.Limit)

    genAlt(SrIdtr, KSPECIAL_REGISTERS, Idtr.Limit)
    genDef(Sr, KSPECIAL_REGISTERS, Tr)
    genDef(Sr, KSPECIAL_REGISTERS, Ldtr)

    genDef(PsNT5, X86_NT5_KPROCESSOR_STATE, ContextFrame)
    genDef(PsNT5, X86_NT5_KPROCESSOR_STATE, SpecialRegisters)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr0)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr2)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr3)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr4)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr0)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr1)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr2)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr3)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr6)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr7)
    genAlt(SrNT5Gdtr, X86_KSPECIAL_REGISTERS, Gdtr.Limit)

    genAlt(SrNT5Idtr, X86_KSPECIAL_REGISTERS, Idtr.Limit)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Tr)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Ldtr)

    genSpc()
    genNam(PAGE_SIZE)

    genSpc()
    genNam(CLOCK_ROLLOVER_COUNT)
    genNam(CLOCK_TIME_INCREMENT)

    genSpc()
    genNam(PAGE_DIRECTORY_PHYSICAL_ADDRESS)

    genSpc()
    genNam(ROM_SHADOW_PHYSICAL_ADDRESS)
    genNam(ROM_SHADOW_SIZE)

    genSpc()
    genNam(XDISK_UNPARTITIONED_SECTORS)

    genSpc()
    genVal(MzXdataSectionHeader, ((ULONG_PTR)&((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2))
    genDef(Xdsh, XDATA_SECTION_HEADER, SizeOfUninitializedData)
    genDef(Xdsh, XDATA_SECTION_HEADER, SizeOfInitializedData)
    genDef(Xdsh, XDATA_SECTION_HEADER, PointerToRawData)
    genDef(Xdsh, XDATA_SECTION_HEADER, VirtualAddress)

    genSpc()
    genDef(Mudb, MICROCODE_UPDATE_DATA_BLOCK, Processor)
    genDef(Mudb, MICROCODE_UPDATE_DATA_BLOCK, UpdateData)
    genVal(MudbStructureLength, sizeof(MICROCODE_UPDATE_DATA_BLOCK))

    genNam(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0)
    genNam(XPCICFG_LPCBRIDGE_IO_REGISTER_LENGTH_0)
    genNam(XPCICFG_SMBUS_IO_REGISTER_BASE_1)
    genNam(XPCICFG_SMBUS_IO_REGISTER_LENGTH_1)
    genNam(XPCICFG_GPU_MEMORY_REGISTER_BASE_0)
    genNam(XPCICFG_GPU_MEMORY_REGISTER_LENGTH_0)

  DisableInc (HAL386)

    END_LIST
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\i386pcr.asm ===
title  "I386 PCR"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    i386pcr.asm
;
; Abstract:
;
;    This module implements routines for accessing and initing the pcr.
;
; Author:
;
;    Bryan Willman (bryanwi) 20 Mar 90
;
; Environment:
;
;    Kernel mode, early init of first processor.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        extrn   _KiPCR:DWORD

;
;   NOTE - This definition of PCR gives us 2 instructions to get to some
;       variables that need to be addressable in one instruction.  Any
;       such variable (such as current thread) must be accessed via its
;       own access procedure (see below), NOT by KeGetPcr()->PbCurrentThread.
;       (This is only an issue on MP machines.)
;

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc _KeGetPcr ,0

        lea     eax,_KiPCR
        stdRET    _KeGetPcr

stdENDP _KeGetPcr


;++
;
; PKPRCB
; KeGetCurrentPrcb()
;
; Return Value:
;
;   Pointer to current PRCB.
;
;--
cPublicProc _KeGetCurrentPrcb   ,0

        mov     eax,PCR[PcPrcb]
        stdRET    _KeGetCurrentPrcb

stdENDP _KeGetCurrentPrcb


;++
;
; PKTHREAD
; KeGetCurrentThread()
;
; Return Value:
;
;   Pointer to current Thread object.
;
;--
cPublicProc _KeGetCurrentThread   ,0

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        stdRET    _KeGetCurrentThread

stdENDP _KeGetCurrentThread


;++
;
; BOOLEAN
; KeIsExecutingDpc(
;       VOID
;       );
;
; Return Value:
;
;   Value of flag which indicates whether we're executing in DPC context
;
;--

cPublicProc _KeIsExecutingDpc   ,0

        mov     eax,PCR[PcPrcbData.PbDpcRoutineActive]
        stdRET    _KeIsExecutingDpc

stdENDP _KeIsExecutingDpc

_TEXT   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\exceptn.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch expections to the
    proper mode and invoke the exception dispatcher.

--*/

#include "ki.h"

#define FN_BITS_PER_TAGWORD     16
#define FN_TAG_EMPTY            0x3
#define FN_TAG_MASK             0x3
#define FX_TAG_VALID            0x1
#define NUMBER_OF_FP_REGISTERS  8
#define BYTES_PER_FP_REGISTER   10
#define BYTES_PER_FX_REGISTER   16

ULONG
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct esp from a trapframe, accounting
    for whether the frame is a user or kernel mode frame, and whether
    it has been edited.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of Esp.

--*/

{
    if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

        //  Kernel mode frame which has had esp edited,
        //  value of Esp is in TempEsp.

        return TrapFrame->TempEsp;

    } else {

        //  Kernel mode frame has has not had esp edited, compute esp.

        return (ULONG)&TrapFrame->HardwareEsp;
    }
}

VOID
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    )

/*++

Routine Description:

    This routine sets the specified value Esp into the trap frame,
    accounting for whether the frame is a user or kernel mode frame,
    and whether it has been edited before.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    Esp - New value for Esp.

Return Value:

    None.

--*/
{
    ULONG   OldEsp;

    OldEsp = KiEspFromTrapFrame(TrapFrame);

    //
    //  Kernel mode esp can't be lowered or iret emulation will fail
    //

    if (Esp < OldEsp)
        KeBugCheck(SET_OF_INVALID_CONTEXT);

    //
    //  Edit frame, setting edit marker as needed.
    //

    if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

        //  Kernel frame that has already been edited,
        //  store value in TempEsp.

        TrapFrame->TempEsp = Esp;

    } else {

        //  Kernel frame for which Esp is being edited first time.
        //  Save real SegCs, set marked in SegCs, save Esp value.

        if (OldEsp != Esp) {
            TrapFrame->TempSegCs = TrapFrame->SegCs;
            TrapFrame->SegCs = TrapFrame->SegCs & ~FRAME_EDITED;
            TrapFrame->TempEsp = Esp;
        }
    }
}

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception frames
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        ContextFrame->Ebp = TrapFrame->Ebp;
        ContextFrame->Eip = TrapFrame->Eip;

        if (((TrapFrame->SegCs & FRAME_EDITED) == 0) &&
            ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0)) {
            ContextFrame->SegCs = TrapFrame->TempSegCs & SEGMENT_MASK;
        } else {
            ContextFrame->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
        }
        ContextFrame->EFlags = TrapFrame->EFlags;
        ContextFrame->SegSs = KGDT_R0_DATA;
        ContextFrame->Esp = KiEspFromTrapFrame(TrapFrame);
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        ContextFrame->Edi = TrapFrame->Edi;
        ContextFrame->Esi = TrapFrame->Esi;
        ContextFrame->Ebx = TrapFrame->Ebx;
        ContextFrame->Ecx = TrapFrame->Ecx;
        ContextFrame->Edx = TrapFrame->Edx;
        ContextFrame->Eax = TrapFrame->Eax;
    }

    //
    // Set extended register contents if specified.
    //

    if (((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) ||
        ((ContextFrame->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)) {

        KiFlushNPXState();

        NpxFrame = (PFX_SAVE_AREA)KeGetPcr()->NtTib.StackBase;

        RtlCopyMemory( &ContextFrame->FloatSave,
                       &NpxFrame->FloatSave,
                       sizeof(FLOATING_SAVE_AREA) );
    }
}

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers eflag, ebp, eip, cs, esp and ss.
        // Eflags is set first, so that the auxilliary routines
        // can check the v86 bit to determine as well as cs, to
        // determine if the frame is kernel or user mode. (v86 mode cs
        // can have any value)
        //

        TrapFrame->EFlags = SANITIZE_FLAGS(ContextFrame->EFlags);
        TrapFrame->Ebp = ContextFrame->Ebp;
        TrapFrame->Eip = ContextFrame->Eip;
        KiEspToTrapFrame(TrapFrame, ContextFrame->Esp);
    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax.
        //
        //  Can NOT call RtlMoveMemory here because the regs aren't
        //  contiguous in pusha frame, and we don't want to export
        //  bits of junk into context record.
        //

        TrapFrame->Edi = ContextFrame->Edi;
        TrapFrame->Esi = ContextFrame->Esi;
        TrapFrame->Ebx = ContextFrame->Ebx;
        TrapFrame->Ecx = ContextFrame->Ecx;
        TrapFrame->Edx = ContextFrame->Edx;
        TrapFrame->Eax = ContextFrame->Eax;
    }

    //
    // Set extended register contents if requested.
    //

    if (((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) ||
        ((ContextFrame->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)) {

        KiFlushNPXState();

        NpxFrame = (PFX_SAVE_AREA)KeGetPcr()->NtTib.StackBase;

        RtlCopyMemory( &NpxFrame->FloatSave,
                       &ContextFrame->FloatSave,
                       sizeof(FLOATING_SAVE_AREA) );

        //
        // Make sure only valid floating state bits are moved to Cr0NpxState.
        //

        NpxFrame->FloatSave.Cr0NpxState &= ~(CR0_EM | CR0_MP | CR0_TS);

        //
        // Make sure all reserved bits are clear in MXCSR so we don't get a GP
        // fault when doing an FRSTOR on this state.
        //

        NpxFrame->FloatSave.MXCsr = SANITIZE_MXCSR(NpxFrame->FloatSave.MXCsr);
    }
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called. If the previous mode is
    kernel, then the exception dispatcher is called directly to process the
    exception. Otherwise the exception record, exception frame, and trap
    frame contents are copied to the user mode stack. The contents of the
    exception frame and trap are then modified such that when control is
    returned, execution will commense in user mode in a routine which will
    call the exception dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{
    CONTEXT ContextFrame;

    //
    // Move machine state from trap and exception frames to a context frame,
    // and increment the number of exceptions dispatched.
    //

    ContextFrame.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER |
        CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;

    KeContextFromKframes(TrapFrame, &ContextFrame);

    //
    // if it is BREAK_POINT exception, we subtract 1 from EIP and report
    // the updated EIP to user.  This is because Cruiser requires EIP
    // points to the int 3 instruction (not the instruction following int 3).
    // In this case, BreakPoint exception is fatal. Otherwise we will step
    // on the int 3 over and over again, if user does not handle it
    //
    // if the BREAK_POINT occured in V86 mode, the debugger running in the
    // VDM will expect CS:EIP to point after the exception (the way the
    // processor left it.  this is also true for protected mode dos
    // app debuggers.  We will need a way to detect this.
    //
    //

    switch (ExceptionRecord->ExceptionCode) {
        case STATUS_BREAKPOINT:
            ContextFrame.Eip--;
            break;
    }

    //
    // Previous mode was kernel.
    //
    // If the kernel debugger is active, then give the kernel debugger the
    // first chance to handle the exception. If the kernel debugger handles
    // the exception, then continue execution. Else attempt to dispatch the
    // exception to a frame based handler. If a frame based handler handles
    // the exception, then continue execution.
    //
    // If a frame based handler does not handle the exception,
    // give the kernel debugger a second chance, if it's present.
    //
    // If the exception is still unhandled, call KeBugCheck().
    //

    if (FirstChance == TRUE) {

        if ((KiDebugRoutine != NULL) &&
           (((KiDebugRoutine) (TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               &ContextFrame,
                               FALSE)) != FALSE)) {

            goto Handled1;
        }

        // Kernel debugger didn't handle exception.

        if (RtlDispatchException(ExceptionRecord, &ContextFrame) == TRUE) {
            goto Handled1;
        }
    }

    //
    // This is the second chance to handle the exception.
    //

    if ((KiDebugRoutine != NULL) &&
        (((KiDebugRoutine) (TrapFrame,
                            ExceptionFrame,
                            ExceptionRecord,
                            &ContextFrame,
                            TRUE)) != FALSE)) {

        goto Handled1;
    }

    KeBugCheckEx(
        KMODE_EXCEPTION_NOT_HANDLED,
        ExceptionRecord->ExceptionCode,
        (ULONG)ExceptionRecord->ExceptionAddress,
        ExceptionRecord->ExceptionInformation[0],
        ExceptionRecord->ExceptionInformation[1]
        );

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:
    KeContextToKframes(TrapFrame, &ContextFrame, ContextFrame.ContextFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\kernlini.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    kernlini.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, and the processor control
    block.

--*/

#include "ki.h"

VOID
KiSwapGDT (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KiSwapGDT)
#endif

#if DBG
const UCHAR MsgDpcTrashedEsp[] = "\n*** DPC routine %p trashed ESP\n";
const UCHAR MsgDpcFpuEnabled[] = "\n*** DPC routine %p returned with the FPU enabled\n";
const UCHAR MsgDpcTimeout[]    = "\n*** DPC routine > 1 sec --- This is not a break in KeUpdateSystemTime\n";
const UCHAR MsgISRTimeout[]    = "\n*** ISR at %lx took over .5 second\n";
const UCHAR MsgISROverflow[]   = "\n*** ISR at %lx - %d interrupts per .5 second\n";

ULONG   KiDPCTimeout       = 110;
ULONG   KiISRTimeout       = 55;
ULONG   KiISROverflow      = 5500;
#endif

extern  KPCR KiPCR;
extern  KTHREAD KiIdleThread;
extern  UCHAR KiIdleThreadStackLimit[];
extern  KGDTENTRY KiGDTEnd[];
extern  KIDTENTRY KiIDTEnd[];

VOID
KiPreInitializeKernel(
    VOID
    )
/*++

Routine Description:

    This function gains control before the kernel debugger has been initialized
    in order to partially initialize static kernel data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKPCR Pcr;

    Pcr = &KiPCR;

    //
    // Initialize the PCR.  The stack base and limit are initialized in case we
    // end up attempting to flush the NPX state before the KiInitializeKernel
    // has completed initialization.
    //

    Pcr->SelfPcr = Pcr;
    Pcr->Prcb = &Pcr->PrcbData;

    Pcr->NtTib.ExceptionList = EXCEPTION_CHAIN_END;
    Pcr->NtTib.StackLimit = KiIdleThreadStackLimit;
    Pcr->NtTib.StackBase = KiIdleThreadStackLimit + KERNEL_STACK_SIZE - sizeof(FX_SAVE_AREA);

    Pcr->PrcbData.CurrentThread = &KiIdleThread;

    //
    // Mark the idle thread as not having a NPX state as well to further avoid
    // attempting to flush the NPX state.
    //

    KiIdleThread.NpxState = NPX_STATE_NOT_LOADED;
    KiIdleThread.StackLimit = KiIdleThreadStackLimit;
    KiIdleThread.StackBase = KiIdleThreadStackLimit + KERNEL_STACK_SIZE;
}

VOID
KiInitializeKernel(
    VOID
    )
/*++

Routine Description:

    This function gains control after the system has been bootstrapped and
    before the system has been initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    initialize the processor control block, call the executive initialization
    routine, and then return to the system startup routine. This routine is
    also called to initialize the processor specific structures when a new
    processor is brought on line.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKPCR Pcr;
    PKPRCB Prcb;
    PFX_SAVE_AREA NpxFrame;
    KIRQL OldIrql;
    PVOID DpcStack;

    Pcr = KeGetPcr();
    Prcb = KeGetCurrentPrcb();

    //
    // Assert that NpxSaveArea is 16 byte aligned; KeSaveFloatingPointState will
    // use the fxsave instruction with this buffer and the Intel architecture
    // requires that the pointer be 16 byte aligned.
    //

    ASSERT((((ULONG_PTR)&Prcb->NpxSaveArea) % 16) == 0);

    //
    // Initialize DPC listhead and lock.
    //

    InitializeListHead(&Prcb->DpcListHead);
    Prcb->DpcRoutineActive = 0;

    //
    // Lower IRQL to APC level.
    //

    KeLowerIrql(APC_LEVEL);

    //
    // Platform architecture independent initialization.
    //

    KiInitSystem();

    //
    // Initialize idle process object.
    //

    KeInitializeProcess(&KiIdleProcess, (KPRIORITY)0);

    KiIdleProcess.ThreadQuantum = MAXCHAR;

    //
    // Initialize system process object.
    //

    KeInitializeProcess(&KiSystemProcess, NORMAL_BASE_PRIORITY);

    KiSystemProcess.ThreadQuantum = THREAD_QUANTUM;

    //
    // Initialize idle thread object and then set:
    //
    //      1. the initial kernel stack to the specified idle stack.
    //      2. the next processor number to the specified processor.
    //      3. the thread priority to the highest possible value.
    //      4. the state of the thread to running.
    //      5. the thread affinity to the specified processor.
    //      6. the specified processor member in the process active processors
    //          set.
    //

    KeInitializeThread(&KiIdleThread, KiIdleThreadStackLimit + KERNEL_STACK_SIZE,
                       KERNEL_STACK_SIZE, 0, (PKSYSTEM_ROUTINE)NULL,
                       (PKSTART_ROUTINE)NULL, (PVOID)NULL, &KiIdleProcess);
    KiIdleThread.Priority = HIGH_PRIORITY;
    KiIdleThread.State = Running;
    KiIdleThread.WaitIrql = DISPATCH_LEVEL;

    //
    // Initialize the idle thread's NPX state to the same state used for normal
    // threads.
    //

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(KiIdleThread.StackBase) -
                sizeof(FX_SAVE_AREA)));

    RtlZeroMemory((PVOID)NpxFrame, sizeof(FX_SAVE_AREA));

    NpxFrame->FloatSave.ControlWord = 0x27f;     //like fpinit but 64bit mode
    NpxFrame->FloatSave.MXCsr       = 0x1f80;    // mask all the exceptions

    //
    // Initialize the processor block. (Note that some fields have been
    // initialized at KiPreInitializeKernel).
    //

    Prcb->CurrentThread = &KiIdleThread;
    Prcb->NextThread = (PKTHREAD)NULL;
    Prcb->IdleThread = &KiIdleThread;
    Pcr->NtTib.StackBase = (PCHAR)KiIdleThread.StackBase - sizeof(FX_SAVE_AREA);

    //
    // call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        KeBugCheck (PHASE0_EXCEPTION);
    }

    //
    // Processor 0's DPC stack was temporarily allocated on
    // the Double Fault Stack, switch to a proper kernel
    // stack now.
    //

    DpcStack = MmCreateKernelStack(KERNEL_STACK_SIZE, FALSE);

    if (DpcStack == NULL) {
        KeBugCheckEx(NO_PAGES_AVAILABLE, 1, 0, 0, 0);
    }
    Prcb->DpcStack = DpcStack;

    //
    // Set the priority of the specified idle thread to zero, set appropriate
    // member in KiIdleSummary and return to the system start up routine.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(&KiIdleThread, (KPRIORITY)0);

    //
    // if a thread has not been selected to run on the current processors,
    // check to see if there are any ready threads; otherwise add this
    // processors to the IdleSummary
    //

    if (Prcb->NextThread == (PKTHREAD)NULL) {
        SetMember(0, KiIdleSummary);
    }

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
}

VOID
KiSwapGDT(
    VOID
    )
/*++

Routine Description:

    This function is called to edit the GDT.  It swaps words of the address
    and access fields around into the format the part actually needs.
    This allows for easy static init of the GDT.

    Note that this procedure edits the current GDT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKGDTENTRY Entry;
    UCHAR Temp;

    //
    // Rearrange the entries of GDT to match i386 structure
    //

    for (Entry = KiGDT; Entry < KiGDTEnd; Entry++) {
        Temp = Entry->HighWord.Bytes.Flags1;
        Entry->HighWord.Bytes.Flags1 = Entry->HighWord.Bytes.Flags2;
        Entry->HighWord.Bytes.Flags2 = Entry->HighWord.Bytes.BaseHi;
        Entry->HighWord.Bytes.BaseHi = Temp;
    }
}

VOID
KiSwapIDT(
    VOID
    )
/*++

Routine Description:

    This function is called to edit the IDT.  It swaps words of the address
    and access fields around into the format the part actually needs.
    This allows for easy static init of the IDT.

    Note that this procedure edits the current IDT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKIDTENTRY Entry;
    USHORT Temp;

    //
    // Rearrange the entries of IDT to match i386 interrupt gate structure
    //

    for (Entry = KiIDT; Entry < KiIDTEnd; Entry++) {
        Temp = Entry->Selector;
        Entry->Selector = Entry->ExtendedOffset;
        Entry->ExtendedOffset = Temp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\intobj.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

--*/

#include "ki.h"

//
//  Externs from trap.asm used to compute and set handlers for unexpected
//  hardware interrupts.
//

extern  ULONG   KiStartUnexpectedRange(VOID);
extern  ULONG   KiEndUnexpectedRange(VOID);
extern  ULONG   KiUnexpectedEntrySize;

VOID
KeInitializeInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector
    )
/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, SynchronizeIrql, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    Vector - Supplies the index of the entry in the Interrupt Dispatch Table
        that is to be associated with the ServiceRoutine function.

    Irql - Supplies the request priority of the interrupting source.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

Return Value:

    None.

--*/
{
    PULONG pl;
    PULONG NormalDispatchCode;
    ULONG InterruptDispatch;

    ASSERT(Irql <= HIGH_LEVEL);
    ASSERT(Vector >= PRIMARY_VECTOR_BASE && Vector < PRIMARY_VECTOR_BASE + 16);

    //
    // Initialize the address of the service routine,
    // the service context, the address of the spin lock, the vector
    // number, the IRQL of the interrupting source, the Irql used for
    // synchronize execution, abd the interrupt mode.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;

    Interrupt->BusInterruptLevel = Vector - PRIMARY_VECTOR_BASE;
    Interrupt->Irql = (UCHAR)Irql;
    Interrupt->Mode = InterruptMode;

    //
    // Copy the interrupt dispatch code template into the interrupt object
    // and edit the machine code stored in the structure (please see
    // _KiInterruptTemplate in intsup.asm.)
    //

    NormalDispatchCode = &(Interrupt->DispatchCode[0]);

    RtlCopyMemory(NormalDispatchCode, KiInterruptTemplate,
        NORMAL_DISPATCH_LENGTH * sizeof(ULONG));

    //
    // Fill in the address of the interrupt object.
    //

    pl = (PULONG)((PUCHAR)NormalDispatchCode + ((PUCHAR)&KiInterruptTemplateObject -
                                (PUCHAR)KiInterruptTemplate) -4);
    *pl = (ULONG)Interrupt;

    //
    // Fill in the address of interrupt dispatch code.
    //

    pl = (PULONG)((PUCHAR)NormalDispatchCode +
                ((PUCHAR)&KiInterruptTemplateDispatch -
                 (PUCHAR)KiInterruptTemplate) -4);

    if (InterruptMode == LevelSensitive) {
        InterruptDispatch = (ULONG)KiLevelInterruptDispatch;
    } else {
        InterruptDispatch = (ULONG)KiInterruptDispatch;
    }

    *pl = InterruptDispatch-(ULONG)((PUCHAR)pl+4);

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
}

BOOLEAN
KeConnectInterrupt (
    IN PKINTERRUPT Interrupt
    )
/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object. If the interrupt object is already
    connected, or an attempt is made to connect to an interrupt that cannot
    be connected, then a value of FALSE is returned. Else the specified
    interrupt object is connected to the interrupt vector, the connected
    state is set to TRUE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Else a value of TRUE is returned.

--*/
{
    KIRQL OldIrql;
    BOOLEAN Connected;
    ULONG BusInterruptLevel;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Is interrupt object already connected?
    //

    Connected = FALSE;

    if (!Interrupt->Connected) {

        BusInterruptLevel = Interrupt->BusInterruptLevel;

        //
        // Is the IDT entry unclaimed?
        //

        if (KiReturnHandlerAddressFromIDT(BusInterruptLevel + PRIMARY_VECTOR_BASE) ==
            (((ULONG)&KiStartUnexpectedRange) +
            BusInterruptLevel * KiUnexpectedEntrySize)) {

            //
            // Connect the dispatch code in the interrupt object to the IDT
            // and enable the interrupt.
            //

            KiSetHandlerAddressToIDT(BusInterruptLevel + PRIMARY_VECTOR_BASE,
                (ULONG)&Interrupt->DispatchCode);

            HalEnableSystemInterrupt(BusInterruptLevel, Interrupt->Mode);

            Interrupt->Connected = TRUE;
            Connected = TRUE;
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return whether interrupt was connected to the specified vector.
    //

    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    )
/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object. If the interrupt object is not
    connected, then a value of FALSE is returned. Else the specified interrupt
    object is disconnected from the interrupt vector, the connected state is
    set to FALSE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/
{
    KIRQL OldIrql;
    BOOLEAN Connected;
    ULONG BusInterruptLevel;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Connected = Interrupt->Connected;

    if (Connected) {

        BusInterruptLevel = Interrupt->BusInterruptLevel;

        //
        // Disable the interrupt and connect the unexpected interrupt code to
        // the IDT.
        //

        HalDisableSystemInterrupt(BusInterruptLevel);

        KiSetHandlerAddressToIDT(BusInterruptLevel + PRIMARY_VECTOR_BASE,
            (((ULONG)&KiStartUnexpectedRange) +
            BusInterruptLevel * KiUnexpectedEntrySize));

        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Connected;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\intsup.asm ===
TITLE  "Interrupt Object Support Routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intsup.asm
;
; Abstract:
;
;    This module implements the code necessary to support interrupt objects.
;    It contains the interrupt dispatch code and the code template that gets
;    copied into an interrupt object.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 20-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KeBugCheck,1
        EXTRNP  _KiDeliverApc,0
        EXTRNP  HalBeginSystemInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  HalEndSystemLevelInterrupt,1,,FASTCALL
        extrn   HalpSpecialDismissTable:DWORD
        extrn   _KiPCR:DWORD
if DBG
        extrn   _DbgPrint:near
        extrn   _MsgISRTimeout:BYTE
        extrn   _MsgISROverflow:BYTE
        extrn   _KeTickCount:DWORD
        extrn   _KiISRTimeout:DWORD
        extrn   _KiISROverflow:DWORD
endif

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

if DBG
COMM    KiInterruptCounts:dword:16*2
endif

_DATA   ends

        page ,132
        subttl  "Synchronize Execution"

_TEXT   SEGMENT PARA PUBLIC 'CODE'

;++
;
; BOOLEAN
; KeSynchronizeExecution (
;    IN PKINTERRUPT Interrupt,
;    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
;    IN PVOID SynchronizeContext
;    )
;
; Routine Description:
;
;    This function synchronizes the execution of the specified routine with the
;    execution of the service routine associated with the specified interrupt
;    object.
;
; Arguments:
;
;    Interrupt - Supplies a pointer to a control object of type interrupt.
;
;    SynchronizeRoutine - Supplies a pointer to a function whose execution
;       is to be synchronized with the execution of the service routine associated
;       with the specified interrupt object.
;
;    SynchronizeContext - Supplies a pointer to an arbitrary data structure
;       which is to be passed to the function specified by the SynchronizeRoutine
;       parameter.
;
; Return Value:
;
;    The value returned by the SynchronizeRoutine function is returned as the
;    function value.
;
;--
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
cPublicProc _KeSynchronizeExecution ,3

; equates of Local variables

KsePreviousIrql equ [ebp - 4]                ; previous IRQL
KseStackSize = 4 * 1

; equates for arguments

KseInterrupt equ [ebp +8]
KseSynchronizeRoutine equ [ebp + 12]
KseSynchronizeContext equ [ebp + 16]

        push    ebp                     ; save ebp
        mov     ebp, esp                ; (ebp)-> base of local variable frame
        sub     esp, KseStackSize       ; allocate local variables space
        push    ebx                     ; save ebx

; Acquire the associated spin lock and raise IRQL to the interrupting source.

        mov     ebx, KseInterrupt       ; (ebx)->interrupt object

        mov     ecx, InIrql[ebx]        ; (ecx) = Synchronize Irql
        fstCall KfRaiseIrql
        mov     KsePreviousIrql, al

; Call specified routine passing the specified context parameter.
        mov     eax,KseSynchronizeContext
        push    eax
        call    KseSynchronizeRoutine
        mov     ebx, eax                ; save function returned value

; Unlock spin lock, lower IRQL to its previous level, and return the value
; returned by the specified routine.

        mov     ecx, KsePreviousIrql
        fstCall KfLowerIrql

        mov     eax, ebx                ; (eax) = returned value
        pop     ebx                     ; restore ebx
        leave                           ; will clear stack
        stdRET    _KeSynchronizeExecution

stdENDP _KeSynchronizeExecution

        page ,132
        subttl  "Interrupt Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to directly call the specified interrupt service routine.
;
;    This version is used for edge sensitive interrupts.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiInterruptDispatch    ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; Save previous IRQL and set new priority level
;
; Instead of invoking HalBeginSystemInterrupt, we call indirect through the
; dismiss table ourselves.
;

        mov     ecx, [edi].InBusInterruptLevel
        mov     edx, [edi].InIrql
        push    0                       ; make room for OldIrql
        call    HalpSpecialDismissTable[ecx*4]

;
; Call the service routine.
;

if DBG
        mov     ebx, [edi].InBusInterruptLevel  ; this vector
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second
        shl     ebx, 3                          ; eax = eax * 8
        cmp     eax, [KiInterruptCounts+ebx]        ; in same 1/2 range?
        jne     kid_overflowreset

        mov     eax, _KiISROverflow
        inc     [KiInterruptCounts+ebx+4]
        cmp     [KiInterruptCounts+ebx+4], eax
        jnc     kid_interruptoverflow
kid_dbg2:
        mov     ebx, _KeTickCount
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine

if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     kid200
kid31:
endif

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                  ; will do an iret

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kid200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     kid31                   ; continue

kid_interruptoverflow:
        push    [KiInterruptCounts+ebx+4]
        push    InServiceRoutine[edi]
        push    offset FLAT:_MsgISROverflow
        call    _DbgPrint
        add     esp,12
        int 3

        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second

kid_overflowreset:
        mov     [KiInterruptCounts+ebx], eax        ; initialize time
        mov     [KiInterruptCounts+ebx+4], 0        ; reset count
        jmp     kid_dbg2
endif


stdENDP _KiInterruptDispatch

        page ,132
        subttl  "Level Interrupt Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to directly call the specified interrupt service routine.
;
;    This version is used for level sensitive interrupts.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiLevelInterruptDispatch    ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; Save previous IRQL and set new priority level
;
; Instead of invoking HalBeginSystemInterrupt, we call indirect through the
; dismiss table ourselves.
;

        mov     ecx, [edi].InBusInterruptLevel
        mov     edx, [edi].InIrql
        push    0                       ; make room for OldIrql
        call    HalpSpecialDismissTable[ecx*4]

;
; Call the service routine.
;

if DBG
        mov     ebx, [edi].InBusInterruptLevel  ; this vector
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second
        shl     ebx, 3                          ; eax = eax * 8
        cmp     eax, [KiInterruptCounts+ebx]        ; in same 1/2 range?
        jne     klid_overflowreset

        mov     eax, _KiISROverflow
        inc     [KiInterruptCounts+ebx+4]
        cmp     [KiInterruptCounts+ebx+4], eax
        jnc     klid_interruptoverflow
klid_dbg2:
        mov     ebx, _KeTickCount
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine

if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     klid200
klid31:
endif

;
; Do interrupt exit processing
;

        mov     eax, [edi].InBusInterruptLevel
        LEVEL_INTERRUPT_EXIT

;
; ISR took a long time to complete, abort to debugger
;

if DBG
klid200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     klid31                  ; continue

klid_interruptoverflow:
        push    [KiInterruptCounts+ebx+4]
        push    InServiceRoutine[edi]
        push    offset FLAT:_MsgISROverflow
        call    _DbgPrint
        add     esp,12
        int 3

        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second

klid_overflowreset:
        mov     [KiInterruptCounts+ebx], eax        ; initialize time
        mov     [KiInterruptCounts+ebx+4], 0        ; reset count
        jmp     klid_dbg2
endif

stdENDP _KiLevelInterruptDispatch

        page ,132
        subttl  "Interrupt Template"
;++
;
; Routine Description:
;
;    This routine is a template that is copied into each interrupt object. Its
;    function is to save machine state and pass the address of the respective
;    interrupt object and transfer control to the appropriate interrupt
;    dispatcher.
;
;    Control comes here through i386 interrupt gate and, upon entry, the
;    interrupt is disabled.
;
;    Note: If the length of this template changed, the corresponding constant
;          defined in Ki.h needs to be updated accordingly.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    edi - addr of interrupt object
;    esp - top of trap frame
;    interrupts are disabled
;
;--

_KiShutUpAssembler      proc

        public  _KiInterruptTemplate
_KiInterruptTemplate    label   byte

; Save machine state on trap frame

        ENTER_INTERRUPT

;
; the following instruction gets the addr of associated interrupt object.
; the value ? will be replaced by REAL interrupt object address at
; interrupt object initialization time.
;       mov     edi, addr of interrupt object
;
; Template modifications made to support BBT, include replacing bogus
; insructions (created by db and dd) with real instructions.
; This stuff gets overwritten anyway.  BBT just needs to see real instructions.

        public  _KiInterruptTemplate2ndDispatch
_KiInterruptTemplate2ndDispatch equ     this dword
        mov      edi,0

        public  _KiInterruptTemplateObject
_KiInterruptTemplateObject      equ     this dword

; the following instruction transfers control to the appropriate dispatcher
; code.  The value ? will be replaced by real InterruptObj.DispatchAddr
; at interrupt initialization time.  The dispatcher routine will be any one
; of _KiInterruptDispatch or _KiChainDispatch.
;       jmp     [IntObj.DispatchAddr]

        db      0E9h, 0, 0, 0, 0

        public  _KiInterruptTemplateDispatch
_KiInterruptTemplateDispatch    equ     this dword

; end of _KiInterruptTemplate

; The template must fit in the KINTERRUPT.DispatchCode[DISPATCH_LENGTH] field.
.errnz (($ - _KiInterruptTemplate) GT DISPATCH_LENGTH)

_KiShutUpAssembler      endp

        page ,132
        subttl  "Unexpected Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is not connected to an interrupt object.
;
;    For any unconnected vector, its associated 8259 irq is masked out at
;    Initialization time.  So, this routine should NEVER be called.
;    If somehow, this routine gets control we simple raise a BugCheck and
;    stop the system.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--
        public _KiUnexpectedInterrupt
_KiUnexpectedInterrupt  proc
cPublicFpo 0,0

; stop the system
        stdCall   _KeBugCheck, <TRAP_CAUSE_UNKNOWN>
        nop

_KiUnexpectedInterrupt endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implements machine dependent miscellaneous kernel functions.

Author:

    Ken Reneris     7-5-95

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Internal format of the floating_save structure which is passed
//
typedef struct _CONTROL_WORD {
    USHORT      ControlWord;
    ULONG       MXCsr;
} CONTROL_WORD, *PCONTROL_WORD;

typedef struct {
    UCHAR       Flags;
    KIRQL       Irql;
    KIRQL       PreviousNpxIrql;
    UCHAR       Spare[2];

    union {
        CONTROL_WORD    Fcw;
        PFX_SAVE_AREA   Context;
    } u;
    ULONG       Cr0NpxState;

    PKTHREAD    Thread;         // debug

} FLOAT_SAVE, *PFLOAT_SAVE;


#define FLOAT_SAVE_COMPLETE_CONTEXT     0x01
#define FLOAT_SAVE_FREE_CONTEXT_HEAP    0x02
#define FLOAT_SAVE_VALID                0x04
#define FLOAT_SAVE_RESERVED             0xF8

#pragma warning(disable:4035)               // re-enable below

// notes:
// Kix86FxSave(NpxFame) - performs an FxSave to the address specificied
//                   - no other action occurs
__inline
KIRQL
Kix86FxSave(
    PULONG NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit   0
    }
}

//
// Load Katmai New Instruction Technology Control/Status
//
__inline
KIRQL
Kix86LdMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;LDMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  10h
    }
}

//
// Store Katmai New Instruction Technology Control/Status
//
__inline
KIRQL
Kix86StMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;STMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  18h
    }
}
#pragma warning(default:4035)


NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     PublicFloatSave
    )
/*++

Routine Description:

    This routine saves the thread's current non-volatile NPX state,
    and sets a new initial floating point state for the caller.

Arguments:

    FloatSave - receives the current non-volatile npx state for the thread

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    KIRQL                   Irql;
    USHORT                  ControlWord;
    ULONG                   MXCsr;
    PKPRCB                  Prcb;
    PFLOAT_SAVE             FloatSave;

    //
    // Get the current irql and thread
    //

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;

    Irql = KeGetCurrentIrql();
    Thread = KeGetCurrentThread();

    ASSERT (Thread->NpxIrql <= Irql);

    FloatSave->Flags           = 0;
    FloatSave->Irql            = Irql;
    FloatSave->PreviousNpxIrql = Thread->NpxIrql;
    FloatSave->Thread          = Thread;

    //
    // If the irql has changed we need to save the complete floating
    // state context as the prior level has been interrupted.
    //

    if (Thread->NpxIrql != Irql) {

        //
        // If this is apc level we don't have anyplace to hold this
        // context, allocate some heap.
        //

        if (Irql == APC_LEVEL) {
            FloatSave->u.Context = ExAllocatePoolWithTag (
                                        sizeof (FX_SAVE_AREA),
                                        ' XPN'
                                        );

            if (!FloatSave->u.Context) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            FloatSave->Flags |= FLOAT_SAVE_FREE_CONTEXT_HEAP;

        } else {

            ASSERT (Irql == DISPATCH_LEVEL);
            FloatSave->u.Context = &KeGetCurrentPrcb()->NpxSaveArea;

        }

        FloatSave->Flags |= FLOAT_SAVE_COMPLETE_CONTEXT;
    }

    //
    // Stop context switching and allow access to the local fp unit
    //

    _asm {
        cli
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        cmp     eax, ecx
        je      short sav10

        mov     cr0, eax
sav10:
    }

    Prcb = KeGetCurrentPrcb();

    //
    // Get ownership of npx register set for this context
    //

    if (Prcb->NpxThread != Thread) {

        //
        // If the other context is loaded in the npx registers, flush
        // it to that threads save area
        //
        if (Prcb->NpxThread) {

            NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Prcb->NpxThread->StackBase) -
                        sizeof(FX_SAVE_AREA)));

            Kix86FxSave((PULONG)NpxFrame);

            Prcb->NpxThread->NpxState = NPX_STATE_NOT_LOADED;
        }

        Prcb->NpxThread = Thread;
    }

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->StackBase) -
                sizeof(FX_SAVE_AREA)));


    //
    // Save the previous state as required
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Need to save the entire context
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            Kix86FxSave ((PULONG)(FloatSave->u.Context));

            FloatSave->u.Context->FloatSave.Cr0NpxState = NpxFrame->FloatSave.Cr0NpxState;

        } else {

            RtlCopyMemory (FloatSave->u.Context, NpxFrame, sizeof(FX_SAVE_AREA));
        }

    } else {

        //
        // Save only the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            _asm {
                mov     eax, FloatSave
                fnstcw  [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }

            Kix86StMXCsr(&FloatSave->u.Fcw.MXCsr);

        } else {
            //
            // Save the control word from the npx frame.
            //

            FloatSave->u.Fcw.ControlWord = (USHORT) NpxFrame->FloatSave.ControlWord;
            FloatSave->u.Fcw.MXCsr = NpxFrame->FloatSave.MXCsr;
        }

        //
        // Save Cr0NpxState, but clear CR0_TS as there's not non-volatile
        // pending fp exceptions
        //

        FloatSave->Cr0NpxState = NpxFrame->FloatSave.Cr0NpxState & ~CR0_TS;
    }

    //
    // The previous state is saved.  Set an initial default
    // FP state for the caller
    //

    NpxFrame->FloatSave.Cr0NpxState = 0;
    Thread->NpxState = NPX_STATE_LOADED;
    Thread->NpxIrql  = Irql;
    ControlWord = 0x27f;    // 64bit mode
    MXCsr = 0x1f80;

    _asm {
        fninit
        fldcw       ControlWord
    }

    Kix86LdMXCsr(&MXCsr);

    _asm {
        sti
    }

    FloatSave->Flags |= FLOAT_SAVE_VALID;
    return STATUS_SUCCESS;
}


NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      PublicFloatSave
    )
/*++

Routine Description:

    This routine retores the thread's current non-volatile NPX state,
    to the passed in state.

Arguments:

    FloatSave - the non-volatile npx state for the thread to restore

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    ULONG                   Cr0State;
    PFLOAT_SAVE             FloatSave;

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;
    Thread = FloatSave->Thread;
    
    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->StackBase) -
                sizeof(FX_SAVE_AREA)));


    //
    // Verify float save looks like it's from the right context
    //

    if ((FloatSave->Flags & (FLOAT_SAVE_VALID | FLOAT_SAVE_RESERVED)) != FLOAT_SAVE_VALID) {

        //
        // Invalid floating point save area.
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     0,
                     FloatSave->Flags,
                     0,
                     0);
    }

    if (FloatSave->Irql != KeGetCurrentIrql()) {

        //
        // Invalid IRQL.   IRQL now must be the same as when the
        // context was saved.  (Why?   Because we save it in different
        // places depending on the IRQL at that time).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     1,
                     FloatSave->Irql,
                     KeGetCurrentIrql(),
                     0);
    }

    if (Thread != KeGetCurrentThread()) {

        //
        // Invalid Thread.   The thread this floating point context
        // belongs to is not the current thread (or the saved thread
        // field is trash).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     2,
                     (ULONG_PTR)Thread,
                     (ULONG_PTR)KeGetCurrentThread(),
                     0);
    }


    //
    // Synchronize with context switches and the npx trap handlers
    //

    _asm {
        cli
    }

    //
    // Restore the required state
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Restore the entire fp state to the threads save area
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // This state in the fp unit is no longer needed, just disregard it
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED;
            KeGetCurrentPrcb()->NpxThread = NULL;
        }

        //
        // Copy restored state to npx frame
        //

        RtlCopyMemory (NpxFrame, FloatSave->u.Context, sizeof(FX_SAVE_AREA));

    } else {

        //
        // Restore the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // Init fp state and restore control word
            //

            _asm {
                fninit
                mov     eax, FloatSave
                fldcw   [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }

            Kix86LdMXCsr(&FloatSave->u.Fcw.MXCsr);

        } else {

            //
            // Fp state not loaded.  Restore control word in npx frame
            //

            NpxFrame->FloatSave.ControlWord = FloatSave->u.Fcw.ControlWord;
            NpxFrame->FloatSave.StatusWord = 0;
            NpxFrame->FloatSave.TagWord = 0;
            NpxFrame->FloatSave.MXCsr = FloatSave->u.Fcw.MXCsr;
        }

        NpxFrame->FloatSave.Cr0NpxState = FloatSave->Cr0NpxState;
    }

    //
    // Restore NpxIrql and Cr0
    //

    Thread->NpxIrql = FloatSave->PreviousNpxIrql;
    Cr0State = Thread->NpxState | NpxFrame->FloatSave.Cr0NpxState;

    _asm {
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        or      eax, Cr0State
        cmp     eax, ecx
        je      short res10
        mov     cr0, eax
res10:
        sti
    }

    //
    // Done
    //

    if (FloatSave->Flags & FLOAT_SAVE_FREE_CONTEXT_HEAP) {
        ExFreePool (FloatSave->u.Context);
    }

    FloatSave->Flags = 0;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\newsysbg.asm ===
title  "System Startup"
;++
;
; Copyright (c) 1989-2001  Microsoft Corporation
;
; Module Name:
;
;    newsysbg.asm
;
; Abstract:
;
;    This module implements the code necessary to initially startup the
;    NT system.
;
; Environment:
;
;    Kernel mode only.
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, 0 )
endm
        .list

        option  segment:flat

        EXTRNP  _KdInitSystem,1
        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KiPreInitializeKernel
        EXTRNP  _KiInitializeKernel
        extrn   SwapContext:PROC
        EXTRNP  _KiSwapGDT
        EXTRNP  _KiSwapIDT
        extrn   _KiTrap08:PROC
        extrn   _KiTrap02:PROC
        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _KeBugCheckEx, 5
        EXTRNP  _HalMicrocodeUpdateLoader,0
        EXTRNP  HalClearSoftwareInterrupt,1,,FASTCALL
        EXTRNP  _MmPrepareToQuickRebootSystem,0

        extrn   _KeHasQuickBooted:BYTE
        extrn   _KiIDT:BYTE
        extrn   _KiIDTLEN:BYTE          ; NOTE - really an ABS, linker problems

ifdef DEVKIT
        extrn   _KiDpcDispatchNotify:DWORD
endif

if DBG
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
        extrn   _MsgDpcTrashedEsp:BYTE
        extrn   _MsgDpcFpuEnabled:BYTE
endif

;
; Constants for various variables
;

_DATA   SEGMENT PARA PUBLIC 'DATA'

COMM    _KiDoubleFaultStackLimit:byte:DOUBLE_FAULT_STACK_SIZE
COMM    _KiIdleThreadStackLimit:byte:KERNEL_STACK_SIZE

        align   16
        public  _KiIdleThread
_KiIdleThread  label   byte
        db      ExtendedThreadObjectLength dup(0) ; sizeof (ETHREAD)

        align   16
        dd      3 dup(0) ; padding to force PbNpxSaveArea to be 16 byte aligned
.errnz ((SIZEOF DWORD * 3 + PcPrcbData + PbNpxSaveArea) AND 15)
        public  _KiPCR
_KiPCR label dword
        db      ProcessorControlRegisterLength dup (0)

_DATA   ends

STICKY  SEGMENT PARA PUBLIC 'DATA'

;
; Allocate space for the task state segments.
;

INITIALIZE_TSS macro HandlerRoutine, HandlerStack
        dw      0                       ; TssBacklink
        dw      0                       ; TssReserved0
        dd      HandlerStack            ; TssEsp0
        dw      KGDT_R0_DATA            ; TssSs0
        dw      0                       ; TssReserved1
        dd      0                       ; TssEsp1
        dw      0                       ; TssSs1
        dw      0                       ; TssReserved2
        dd      0                       ; TssEsp2
        dw      0                       ; TssSs2
        dw      0                       ; TssReserved3
        dd      0                       ; TssCR3
        dd      HandlerRoutine          ; TssEip
        dd      0                       ; TssEFlags
        dd      0                       ; TssEax
        dd      0                       ; TssEcx
        dd      0                       ; TssEdx
        dd      0                       ; TssEbx
        dd      HandlerStack            ; TssEsp
        dd      0                       ; TssEbp
        dd      0                       ; TssEsi
        dd      0                       ; TssEdi
        dw      KGDT_R0_DATA            ; TssEs
        dw      0                       ; TssReserved4
        dw      KGDT_R0_CODE            ; TssCs
        dw      0                       ; TssReserved5
        dw      KGDT_R0_DATA            ; TssSs
        dw      0                       ; TssReserved6
        dw      KGDT_R0_DATA            ; TssDs
        dw      0                       ; TssReserved7
        dw      KGDT_R0_PCR             ; TssFs
        dw      0                       ; TssReserved8
        dw      0                       ; TssGs
        dw      0                       ; TssReserved9
        dw      0                       ; TssLDT
        dw      0                       ; TssReserved10
        dw      0                       ; TssFlags
        dw      TssIoMaps               ; TssIoMapBase
        endm

        align   8
        public  _KiNormalTSS
_KiNormalTSS label byte
INITIALIZE_TSS 0, 0

        align   8
        public  _KiDoubleFaultTSS
_KiDoubleFaultTSS label byte
INITIALIZE_TSS <OFFSET _KiTrap08>, <OFFSET _KiDoubleFaultStackLimit + DOUBLE_FAULT_STACK_SIZE>

        align   8
        public  _KiNMITSS
_KiNMITSS label byte
INITIALIZE_TSS <OFFSET _KiTrap02>, <OFFSET _KiDoubleFaultStackLimit + DOUBLE_FAULT_STACK_SIZE>

;
; Allocate space for the global descriptor table.
;

GDTEntry macro  base,limit,flags
        dw      limit
        dd      base
        dw      flags
        endm

        align   8
        public  _KiGDT, _KiGDTLEN, _KiGDTEnd
_KiGDT label byte

GDTEntry        0, 0, 0                                                 ; KGDT_NULL
GDTEntry        0, 0FFFFh, 0CB9Bh                                       ; KGDT_R0_CODE
GDTEntry        0, 0FFFFh, 0CF93h                                       ; KGDT_R0_DATA
GDTEntry        <OFFSET _KiNormalTSS>, TssIoMaps, 89h                   ; KGDT_TSS
GDTEntry        <OFFSET _KiPCR>, ProcessorControlRegisterLength, 0C093h ; KGDT_R0_PCR
GDTEntry        <OFFSET _KiDoubleFaultTSS>, TssIoMaps, 89h              ; KGDT_DF_TSS
GDTEntry        <OFFSET _KiNMITSS>, TssIoMaps, 89h                      ; KGDT_NMI_TSS

_KiGDTLEN       equ     $ - _KiGDT
_KiGDTEnd       equ     $

STICKY  ends

        page ,132
        subttl  "System Startup"
INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; For processor 0, Routine Description:
;
;    This routine is called when the NT system begins execution.
;    Its function is to initialize system hardware state, call the
;    kernel initialization routine, and then fall into code that
;    represents the idle thread for all processors.
;
;    Entry state created by the boot loader:
;       A short-form IDT (0-1f) exists and is active.
;       A complete GDT is set up and loaded.
;       A complete TSS is set up and loaded.
;       Page map is set up with minimal start pages loaded
;           The lower 4Mb of virtual memory are directly mapped into
;           physical memory.
;
;           The system code (ntoskrnl.exe) is mapped into virtual memory
;           as described by its memory descriptor.
;       DS=ES=SS = flat
;       ESP->a usable boot stack
;       Interrupts OFF
;
; For processor > 0, Routine Description:
;
;   This routine is called when each additional processor begins execution.
;   The entry state for the processor is:
;       IDT, GDT, TSS, stack, selectors, PCR = all valid
;       Page directory is set to the current running directory
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSystemStartup,0

;
; Initialize ebp, esp, and argument registers for initializing the kernel.
; Reserve space for idle thread stack NPX_SAVE_AREA, enough padding bytes to
; store the initial context from KiInitializeContextThread and the FWORD for
; lgdt/lidt.
;

        xor     ebp, ebp                ; (ebp) = 0.   No more stack frame
        mov     esp, offset _KiIdleThreadStackLimit + KERNEL_STACK_SIZE - NPX_FRAME_LENGTH - 64

;
; Rearrange the bytes in KiGDT to match the processor's layout.
;

        stdCall _KiSwapGDT

;
; Load the global descriptor table register.
;

        mov     WORD PTR [esp], _KiGDTLEN
        mov     DWORD PTR [esp+2], OFFSET _KiGDT
        lgdt    FWORD PTR [esp]

;
; Execute a 16:32 jump to reload the code selector.
;

        db      0EAh
        dd      OFFSET kis10
        dw      KGDT_R0_CODE

;
; Reload the data selectors.
;

kis10:  mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax

;
; Load the various selector registers.
;

        push    KGDT_R0_PCR
        pop     fs

        mov     eax, KGDT_TSS
        ltr     ax

;
; Initialize TssCr3 of the task state segments to the boot page directory.
;

        mov     eax, cr3
        mov     dword ptr [_KiNormalTSS]+TssCr3, eax
        mov     dword ptr [_KiDoubleFaultTSS]+TssCr3, eax
        mov     dword ptr [_KiNMITSS]+TssCr3, eax

;
; Update the microcode for the processor.
;

        stdCall _HalMicrocodeUpdateLoader

;
; Since the entries of Kernel IDT have their Selector and Extended Offset
; fields set up in the wrong order, we need to swap them back to the order
; which i386 recognizes.
;

        stdCall _KiSwapIDT

;
; Load the interrupt descriptor table register.
;

        mov     ecx, offset FLAT:_KiIDTLEN
        mov     WORD PTR [esp], cx
        mov     DWORD PTR [esp+2], OFFSET _KiIDT
        lidt    FWORD PTR [esp]

;
; Preinitialize the system data structures.
;

        stdCall _KiPreInitializeKernel

;
; Enable the kernel debugger.
;

        stdCall _KdInitSystem, <1>

if  DEVL
;
; Give the debugger an opportunity to gain control.
;

        POLL_DEBUGGER
endif   ; DEVL
        nop                             ; leave a spot for int-3 patch

;
; Set initial IRQL = HIGH_LEVEL for init
;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql

;
; Initialize system data structures and HAL.
;

        stdCall _KiInitializeKernel

;
; Set "shadow" priority value for Idle thread.  This will keep the Mutex
; priority boost/drop code from dropping priority on the Idle thread, and
; thus avoids leaving a bit set in the ActiveMatrix for the Idle thread when
; there should never be any such bit.
;

        mov     byte ptr [_KiIdleThread]+ThPriority,LOW_REALTIME_PRIORITY

;
; Control is returned to the idle thread with IRQL at HIGH_LEVEL. Lower IRQL
; to DISPATCH_LEVEL and set wait IRQL of idle thread.
;

        sti
        mov     ecx, DISPATCH_LEVEL
        fstCall KfLowerIrql
        mov     byte ptr [_KiIdleThread]+ThWaitIrql, DISPATCH_LEVEL

;
; The following code represents the idle thread for a processor. The idle
; thread executes at IRQL DISPATCH_LEVEL and continually polls for work to
; do. Control may be given to this loop either as a result of a return from
; the system initialization routine or as the result of starting up another
; processor in a multiprocessor configuration.
;

        jmp     KiIdleLoop              ; enter idle loop

stdENDP _KiSystemStartup

INIT   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'      ; Put IdleLoop in text section
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; DECLSPEC_NORETURN
; VOID
; KeQuickRebootSystem(
;     VOID
;     )
;
; Routine Description:
;
;     This function quick reboots the system.  The .data section is refreshed
;     from the ROM and system initialization is started again.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _KeQuickRebootSystem,0

;
; Disable interrupts.
;

        cli

;
; Initialize ebp, esp, and argument registers for initializing the kernel.
; Reserve space for idle thread stack NPX_SAVE_AREA, enough padding bytes to
; store the initial context from KiInitializeContextThread and the FWORD for
; lgdt/lidt.
;

        xor     ebp, ebp                ; (ebp) = 0.   No more stack frame
        mov     esp, offset _KiIdleThreadStackLimit + KERNEL_STACK_SIZE - NPX_FRAME_LENGTH - 64

;
; Inform the memory manager that we're about to quick reboot the system.  This
; will cause us to switch back to large pages and to make the ROM visible so
; that we can copy out our .data section again.
;

        stdCall _MmPrepareToQuickRebootSystem

;
; Copy the initialized portion of the .data section from ROM.  Note that the
; stack that we're running on is part of this data image, so don't use the
; stack here or in the next block.
;

        cld
        mov     ecx, dword ptr ds:[MzXdataSectionHeader]+XdshSizeOfInitializedData
        shr     ecx, 2
        mov     esi, dword ptr ds:[MzXdataSectionHeader]+XdshPointerToRawData
        mov     edi, dword ptr ds:[MzXdataSectionHeader]+XdshVirtualAddress
        rep     movsd

;
; Zero out the uninitialized portion of the .data section.
;

        mov     ecx, dword ptr ds:[MzXdataSectionHeader]+XdshSizeOfUninitializedData
        xor     eax, eax
        shr     ecx, 2
        rep     stosd

;
; Indicate to the rest of the system that we're initializing due to a quick
; boot.
;

        mov     byte ptr [_KeHasQuickBooted], 1

;
; Since the entries of Kernel IDT have their Selector and Extended Offset
; fields set up in the wrong order, we need to swap them back to the order
; which i386 recognizes.
;

        stdCall _KiSwapIDT

;
; Load the interrupt descriptor table register.
;

        mov     ecx, offset FLAT:_KiIDTLEN
        mov     WORD PTR [esp], cx
        mov     DWORD PTR [esp+2], OFFSET _KiIDT
        lidt    FWORD PTR [esp]

;
; Preinitialize the system data structures.
;

        stdCall _KiPreInitializeKernel

;
; Enable the kernel debugger.
;

        stdCall _KdInitSystem, <1>

;
; Set initial IRQL = HIGH_LEVEL for init
;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql

;
; Initialize system data structures and HAL.
;

        stdCall _KiInitializeKernel

;
; Set "shadow" priority value for Idle thread.  This will keep the Mutex
; priority boost/drop code from dropping priority on the Idle thread, and
; thus avoids leaving a bit set in the ActiveMatrix for the Idle thread when
; there should never be any such bit.
;

        mov     byte ptr [_KiIdleThread]+ThPriority,LOW_REALTIME_PRIORITY

;
; Control is returned to the idle thread with IRQL at HIGH_LEVEL. Lower IRQL
; to DISPATCH_LEVEL and set wait IRQL of idle thread.
;

        sti
        mov     ecx, DISPATCH_LEVEL
        fstCall KfLowerIrql
        mov     byte ptr [_KiIdleThread]+ThWaitIrql, DISPATCH_LEVEL

;
; The following code represents the idle thread for a processor. The idle
; thread executes at IRQL DISPATCH_LEVEL and continually polls for work to
; do. Control may be given to this loop either as a result of a return from
; the system initialization routine or as the result of starting up another
; processor in a multiprocessor configuration.
;

        jmp     KiIdleLoop              ; enter idle loop

stdENDP _KeQuickRebootSystem

        page ,132
        subttl  "Idle Loop"
;++
;
; Routine Description:
;
;    This routine continuously executes the idle loop and never returns.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    None - routine never returns.
;
;--

        public  KiIdleLoop
KiIdleLoop proc

        lea     ebx, _KiPCR             ; get address of PCR
        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address

kid10:

;
; N.B. The following code enables interrupts for a few cycles, then
;      disables them again for the subsequent DPC and next thread
;      checks.
;

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        je      short CheckNextThread   ; if eq, DPC list is empty
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        fstCall HalClearSoftwareInterrupt ; clear software interrupt
        call    KiRetireDpcList         ; process the current DPC list

;
; Check if a thread has been selected to run on the current processor.
;

CheckNextThread:                        ;
        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; thread selected?
        je      short kid10             ; if eq, no thread selected

;
; A thread has been selected for execution on this processor. Acquire
; the dispatcher database lock, get the thread address again (it may have
; changed), clear the address of the next thread in the processor block,
; and call swap context to start execution of the selected thread.
;
; N.B. If the dispatcher database lock cannot be obtained immediately,
;      then attempt to process another DPC rather than spinning on the
;      dispatcher database lock.
;

        sti                             ; enable interrupts
        mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; set current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address

        mov     cl, 1                   ; set APC interrupt bypass disable
        call    SwapContext             ;

        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address
        jmp     kid10

KiIdleLoop      endp

        page ,132
        subttl  "Retire DPC List Loop"
;++
;
; Routine Description:
;
;    This routine continuously executes a retire DPC loop and never returns.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    None - routine never returns.
;
;--

cPublicProc _KeRetireDpcListLoop,0

        lea     ebx, _KiPCR             ; get address of PCR
        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address

;
; This routine is entered at DPC level from a HAL DPC routine.  Clear the flag
; that indicates that we're already executing a DPC so that the debug code in
; the clock interrupt won't fire because we're taking too long to execute.
;

        mov     [ebx].PcPrcbData.PbDpcRoutineActive, 0

krd10:

;
; N.B. The following code enables interrupts for a few cycles, then
;      disables them again for the subsequent DPC and next thread
;      checks.
;

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        je      short krd10             ; if eq, DPC list is empty
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        fstCall HalClearSoftwareInterrupt ; clear software interrupt
        call    KiRetireDpcList         ; process the current DPC list
        jmp     short krd10

stdENDP _KeRetireDpcListLoop

        page ,132
        subttl  "Retire Deferred Procedure Call List"
;++
;
; Routine Description:
;
;    This routine is called to retire the specified deferred procedure
;    call list. DPC routines are called using the idle thread (current)
;    stack.
;
;    N.B. Interrupts must be disabled and the DPC list lock held on entry
;         to this routine. Control is returned to the caller with the same
;         conditions true.
;
;    N.B. The registers ebx and ebp are preserved across the call.
;
; Arguments:
;
;    ebx - Address of the target processor PCR.
;    ebp - Address of the target DPC listhead.
;
; Return value:
;
;    None.
;
;--

        public  KiRetireDpcList
KiRetireDpcList proc

?FpoValue = 0

FPOFRAME ?FpoValue,0

;
; Disable the FPU to catch the use of floating point from a DPC without first
; calling KeSaveFloatingPointState and KeRestoreFloatingPointState.
;

if DBG
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        jne     rdl5
        mov     eax, cr0                ; retrieve CR0
        or      eax, CR0_MP+CR0_TS
        lmsw    ax                      ; load new CR0 (low 16-bits)
endif

rdl5:   mov     PCR[PcPrcbData.PbDpcRoutineActive], esp ; set DPC routine active

;
; Process the DPC List.
;

rdl10:                                  ;

        mov     edx, [ebp].LsFlink      ; get address of next entry
        mov     ecx, [edx].LsFlink      ; get address of next entry
        mov     [ebp].LsFlink, ecx      ; set address of next in header
        mov     [ecx].LsBlink, ebp      ; set address of previous in next
        sub     edx, DpDpcListEntry     ; compute address of DPC object
        mov     ecx, [edx].DpDeferredRoutine ; get DPC routine address

if DBG
        push    ecx                     ; remember DPC routine address
        push    edi                     ; save register
        mov     edi, esp                ; save current stack pointer
endif

ifdef DEVKIT
        push    esi                     ; save esi register
endif

FPOFRAME ?FpoValue,0

        push    [edx].DpSystemArgument2 ; second system argument
        push    [edx].DpSystemArgument1 ; first system argument
        push    [edx].DpDeferredContext ; get deferred context argument
        push    edx                     ; address of DPC object
        mov     byte ptr [edx]+DpInserted, 0 ; clear DPC inserted state
if DBG
        mov     PCR[PcPrcbData.PbDebugDpcTime], 0 ; Reset the time in DPC
endif

        sti                             ; enable interrupts

;
; If the profiler is active, call its notification routine.
;
ifdef DEVKIT
        cmp     _KiDpcDispatchNotify, 0
        jne     rdl70
        call    ecx                     ; call DPC routine
rdl20:  pop     esi                     ; restore esi

else
        call    ecx                     ; call DPC routine
endif

if DBG

;
; Verify that the DPC returned with the FPU disabled.  If the FPU is enabled,
; then the DPC probably forgot to call KeRestoreFloatingPointState.
;

        mov     eax, cr0                ; retrieve CR0
        test    al, CR0_TS              ; test if FPU is still disabled
        je      rdl57                   ; if e, FPU not disabled

;
; Verify that the DPC returned at DISPATCH_LEVEL.
;

rdl25:  movzx   eax, byte ptr PCR[PcIrql] ; get current IRQL
        cmp     al, DISPATCH_LEVEL      ; check if still at dispatch level
        jne     rdl55                   ; if ne, not at dispatch level
        cmp     esp, edi                ; check if stack pointer is correct
        jne     rdl60                   ; if ne, stack pointer is not correct
rdl30:  pop     edi                     ; restore register
        pop     ecx                     ; pop off saved DPC routine address

endif

FPOFRAME ?FpoValue,0

rdl35:  cli                             ; disable interrupts
        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        jne     rdl10                   ; if ne, DPC list not empty

;
; Clear DPC routine active and DPC requested flags.
;

rdl40:  mov     [ebx].PcPrcbData.PbDpcRoutineActive, 0
        mov     [ebx].PcPrcbData.PbDpcInterruptRequested, 0

;
; Check one last time that the DPC list is empty. This is required to
; close a race condition with the DPC queuing code where it appears that
; a DPC routine is active (and thus an interrupt is not requested), but
; this code has decided the DPC list is empty and is clearing the DPC
; active flag.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        jne     rdl5                    ; if ne, DPC list not empty

;
; Restore the original CR0 if the current thread still owns the FPU.  Note that
; if a DPC called KeSaveFloatingPointState or hit the debugger, then the FPU
; state was flushed, so we shouldn't enable the FPU.
;

if DBG
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        cmp     byte ptr [ecx].ThNpxState, NPX_STATE_LOADED
        jne     rdl50

        mov     eax, cr0
        mov     edx, [ebx].PcStackBase
        and     eax, NOT (CR0_MP+CR0_EM+CR0_TS)
        or      eax, [edx].FpCr0NpxState
        lmsw    ax                      ; load new CR0 (low 16-bits)
endif

rdl50:  ret                             ; return

;
; Unlock DPC list and clear DPC active.
;

if DBG

rdl55:  stdCall _KeBugCheckEx, <IRQL_NOT_GREATER_OR_EQUAL, ebx, eax, 0, 0> ;

rdl57:  push    dword ptr [edi+4]
        push    offset FLAT:_MsgDpcFpuEnabled ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 8                  ; remove arguments from stack
        int     3                       ; break into debugger
        mov     esp, edi                ; reset stack pointer
        jmp     rdl25                   ;

rdl60:  push    dword ptr [edi+4]       ; push address of DPC function
        push    offset FLAT:_MsgDpcTrashedEsp ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 8                  ; remove arguments from stack
        int     3                       ; break into debugger
        mov     esp, edi                ; reset stack pointer
        jmp     rdl30                   ;

endif

;
; Notify the profiler that a DPC routine is called:
;
;   VOID (FASTCALL *KiDpcDispatchNotify)(VOID*, ULONG)
;

ifdef DEVKIT
rdl70:  mov     esi, ecx                ; save DPC routine address in esi
        xor     edx, edx                ; KiDpcDispatchNotify(dpcproc, 0)
        call    [_KiDpcDispatchNotify]

        call    esi                     ; call the DPC routine

        mov     ecx, esi                ; KiDpcDispatchNotify(dpcproc, 1)
        mov     edx, 1
        call    [_KiDpcDispatchNotify]
        jmp     rdl20
endif

KiRetireDpcList endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\kimacro.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       kimacro.inc
;
;   Abstract:
;
;       This module contains the macros used by kernel assembler code.
;       It includes macros to manipulate interrupts, support system
;       entry and exit for syscalls, faults, and interrupts, and
;       manipulate floating point state.
;
;   Author:
;
;       Shie-Lin (shielint) 24-Jan-1990
;
;   Revision History:
;
;       BryanWi 17-Aug-90
;           Replace GENERATE_MACHINE... and RESTORE... with ENTER_...
;           and EXIT_ALL macros.
;
;--

;++
;
;   These constants are used by the fpo directives in this file.
;   This directive causes the assembler to output a .debug$f segment
;   in the obj file.  The segment will contain 1 fpo record for each
;   directive present during assembly.
;
;   Although the assembler will accept all valid values, the value of 7
;   in the FPO_REGS field indicates to the debugger that a trap frame is
;   generated by the function.  The value of 7 can be used because the
;   C/C++ compiler puts a maximum value of 3 in the field.
;
FPO_LOCALS      equ     0         ; 32 bits, size of locals in dwords
FPO_PARAMS      equ     0         ; 32 bits, size of parameters in dwords
FPO_PROLOG      equ     0         ; 12 bits, 0-4095, # of bytes in prolog
FPO_REGS        equ     0         ; 3 bits, 0-7, # regs saved in prolog
FPO_USE_EBP     equ     0         ; 1 bit, 0-1, is ebp used?
FPO_TRAPFRAME   equ     1         ; 2 bits, 0=fpo, 1=trap frame, 2=tss
;
;--


;++
;
;   POLL_DEBUGGER
;
;   Macro Description:
;
;       Call the debugger so it can check for control-c.  If it finds
;       it, it will report our iret address as address of break-in.
;
;       N.B. This macro should be used when all the caller's registers
;            have been restored. (Otherwise, the kernel debugger register
;            dump will not have correct state.)  The only exception is
;            fs.  This is because Kd may need to access PCR or PRCB.
;
;   Arguments:
;
;       There MUST be an iret frame on the stack when this macro
;       is invoked.
;
;   Exit:
;
;       Debugger will iret for us, so we don't usually return from
;       this macro, but remember that it generates nothing for non-DEVL
;       kernels.
;--

POLL_DEBUGGER   macro
local   a, b, c_

ifdef DEVKIT
        EXTRNP  _KdPollBreakIn,0
        EXTRNP  _DbgBreakPointWithStatus,1
        stdCall _KdPollBreakIn
        or      al,al
        jz      short c_
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
c_:
endif
endm

;++
;
;   ASSERT_FS
;
;   Try to catch funky condition wherein we get FS=r3 value while
;   running in kernel mode.
;
;--

ASSERT_FS   macro
local   a,b

if DBG
        EXTRNP   _KeBugCheck,1

        cmp     dword ptr fs:[0], 0
        jne     short b

a:
        stdCall   _KeBugCheck,<-1>
align 4
b:
endif
endm



;++
;
;
;   Copy data from various places into base of TrapFrame, net effect
;   is to allow dbg KB command to trace accross trap frame, and to
;   allow user to find arguments to system calls.
;
;   USE ebx and edi.
;--

SET_DEBUG_DATA  macro

ife FPO

;
; This macro is used by ENTER_SYSTEM_CALL, ENTER_TRAP and ENTER_INTERRUPT
; and is used at the end of above macros.  It is safe to destroy ebx, edi.
;

        mov     ebx,[ebp]+TsEbp
        mov     edi,[ebp]+TsEip
        mov     [ebp]+TsDbgArgPointer,edx
        mov     [ebp]+TsDbgArgMark,0BADB0D00h
        mov     [ebp]+TsDbgEbp,ebx
        mov     [ebp]+TsDbgEip,edi
endif

endm

;++
;
;   ENTER_SYSCALL
;
;   Macro Description:
;
;       Build the frame and set registers needed by a system call.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;
;       Don't Save:
;           Volatile regs
;           Seg regs
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Direction
;
;   Arguments:
;       None.
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, edx
;
;   Note:
;       The DS: reference to PreviousMode is *required* for correct
;       functioning of lazy selector loads.  If you remove this use
;       of DS:, put a DS: override on something.
;
;--

ENTER_SYSCALL macro

.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

ifdef KERNELONLY

;
; Construct trap frame.
;
; N.B. The initial part of the trap frame is constructed by pushing values
;      on the stack. If the format of the trap frame is changed, then the
;      following code must alos be changed.
;

        push    0                       ; put pad dword for error on stack
        push    ebp                     ; save the non-volatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;

;
; Save the old exception list in trap frame and initialize a new empty
; exception list.
;

        push    PCR[PcExceptionList]    ; save old exception list
        mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END ; set new empty list

;
; Allocate the remainder of trap frame,
;

        sub     esp,TsExceptionList
        mov     ebp,esp                 ; set trap frame address
        cld                             ; make sure direction is forward

        SET_DEBUG_DATA                  ; Note this destroys edi

        sti                             ; enable interrupts

else
        %out    ENTER_SYSCAL outside of kernel
        .err
endif
        endm

;++
;
;   ENTER_INTERRUPT  PassParm
;
;   Macro Description:
;
;       Build the frame and set registers needed by an interrupt.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;           Volatile regs
;           Seg regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode
;
;   Arguments:
;       PassParm -
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, ecx, edx
;
;--

ENTER_INTERRUPT macro   PassParm
        local b

.FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

ifb <PassParm>
        push    esp                 ; put pad dword for error on stack
endif
        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        sub     esp, TsEdi
        mov     ebp,esp

        mov     [esp]+TsEax, eax    ; Save volatile registers
        mov     [esp]+TsEcx, ecx
        mov     [esp]+TsEdx, edx

        mov     ebx, PCR[PcExceptionList] ;Save, set ExceptionList
        mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END
        mov     [esp]+TsExceptionList, ebx

        cld

        SET_DEBUG_DATA

        endm

;++
;
;   ENTER_TRAP
;
;   Macro Description:
;
;       Build the frame and set registers needed by a trap or exception.
;
;       Save:
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Volatile regs
;           Seg Regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode,
;           ExceptionList
;
;   Arguments:
;       None.
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax
;
;--

ENTER_TRAP macro
        local b

.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

        mov     word ptr [esp+2], 0 ; Clear upper word of ErrorCode

        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        mov     ebx, PCR[PcExceptionList] ;Save ExceptionList
        push    ebx
        push    eax                 ; Save the volatile registers
        push    ecx
        push    edx

;
;   Skip allocate reset of trap frame.
;

        sub     esp,TsEdx

        mov     ebp,esp

        cld
        SET_DEBUG_DATA

        endm
;++
;
;   EXIT_ALL    NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
;
;   Macro Description:
;
;       Load a syscall frame back into the machine.
;
;       Restore:
;           Volatile regs, IF NoRestoreVolatiles blank
;           NoPreviousMode,
;           ExceptionList,
;           FS,
;           Non-volatile regs
;
;       If the frame is a kernel mode frame, AND esp has been edited,
;       then TsSegCs will have a special value.  Test for that value
;       and execute special code for that case.
;
;       N.B. This macro generates an IRET!  (i.e. It exits!)
;
;   Arguments:
;
;       NoRestoreSegs - non-blank if DS, ES, GS are NOT to be restored
;
;       NoRestoreVolatiles - non-blank if Volatile regs are NOT to be restored
;
;       NoPreviousMode - if nb pop ThPreviousMode
;
;   Entry-conditions:
;
;       (esp)->base of trap frame
;       (ebp)->Base of trap frame
;
;   Exit-conditions:
;
;       Does not exit, returns.
;       Preserves eax, ecx, edx, IFF NoRestoreVolatiles is set
;
;--

?adjesp = 0
?RestoreAll = 1

EXIT_ALL macro  NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
local   a, b, f, x
local   Db_NotATrapFrame, Db_A, Db_NotValidEntry
local   DbgHalt, DbgNoHalt, DbgDoneHalt

;
; Sanity check some values and setup globals for macro
;

?adjesp = TsEdx
?RestoreAll = 1

ifnb <NoRestoreSegs>
    ?RestoreAll = 0
endif

ifnb <NoRestoreVolatiles>
    if ?RestoreAll eq 1
        %out "EXIT_ALL NoRestoreVolatiles requires NoRestoreSegs"
        .err
    endif
    ?adjesp = ?adjesp + 12
endif

ifb <NoPreviousMode>
ifndef KERNELONLY
        %out    EXIT_ALL can not restore previousmode outside kernel
        .err
endif
endif

; All callers are responsible for getting here with interrupts disabled.

if DBG
        pushfd
        pop     edx

        test    edx, EFLAGS_INTERRUPT_MASK
        jnz     Db_NotValidEntry

        cmp     esp, ebp                    ; make sure esp = ebp
        jne     Db_NotValidEntry

; Make sure BADB0D00 sig is present.  If not this isn't a trap frame!
Db_A:   sub     [esp]+TsDbgArgMark,0BADB0D00h
        jne     Db_NotATrapFrame
endif

        ASSERT_FS

        mov     edx, [esp]+TsExceptionList
if DBG
        or      edx, edx
        jnz     short @f
    int 3
@@:
endif
        mov     PCR[PcExceptionList], edx   ; Restore ExceptionList

        test    word ptr [esp]+TsSegCs,FRAME_EDITED
        jz      b                           ; Edited frame pop out.

ifb <NoRestoreVolatiles>
ifb <NoRestoreSegs>                         ; must restore eax before any
        mov     eax, [esp].TsEax            ; selectors! (see trap0e handler)
endif
endif

ifb <NoRestoreVolatiles>
        mov     edx, [ebp]+TsEdx            ; Restore volitales
        mov     ecx, [ebp]+TsEcx
ifb <NoRestoreSegs>
else
        mov     eax, [ebp]+TsEax
endif
endif   ; NoRestoreVolatiles

        lea     esp, [ebp]+TsEdi            ; Skip PreMode, ExceptList and fs

ifdef DEVKIT
        ; check for requested halt
        mov     edi, PCR[PcPrcbData+PbDebugHaltThread]
        test    edi, edi
        jnz     short DbgHalt
DbgNoHalt:
        ; EBP is toast here, so we'd better not need it
endif

        pop     edi                         ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        add     esp, 4              ; remove error code from trap frame
        iretd                       ; return

ifdef DEVKIT
DbgHalt:
        ; There is a requested halt, so let's see if now's the time to halt
        push    eax
        mov     eax, PCR[PcIrql]
        push    ecx
        push    edx
        test    eax, eax            ; only break if irql = 0
        jne     DbgDoneHalt
        call    edi
        test    al, al
        je      DbgDoneHalt
        sti
        mov     ebp, [esp+24]       ; load up the saved EBP so the debugger
        int     3h                  ; shows a reasonable trace
        cli
DbgDoneHalt:
        pop     edx
        pop     ecx
        pop     eax
        jmp     DbgNoHalt
endif

if DBG
Db_NotATrapFrame:
        add     [esp]+TsDbgArgMark,0BADB0D00h   ; put back the orig value
Db_NotValidEntry:
        int 3
        jmp     Db_A
endif

;
;   TsSegCs contains the special value that means the frame was edited
;   in a way that affected esp, AND it's a kernel mode frame.
;   (Special value is null selector except for RPL.)
;
;   Put back the real CS.
;   push eflags, eip onto target stack
;   restore
;   switch to target stack
;   iret
;

b:      mov     ebx,[esp]+TsTempSegCs
        mov     [esp]+TsSegCs,ebx

;
;   There is no instruction that will load esp with an arbitrary value
;   (i.e. one out of a frame) and do a return, if no privledge transition
;   is occuring.  Therefore, if we are returning to kernel mode, and
;   esp has been edited, we must "emulate" a kind of iretd.
;
;   We do this by logically pushing the eip,cs,eflags onto the new
;   logical stack, loading that stack, and doing an iretd.  This
;   requires that the new logical stack is at least 1 dword higher
;   than the unedited esp would have been.  (i.e.  It is not legal
;   to edit esp to have a new value < the old value.)
;
;   KeContextToKframes enforces this rule.
;

;
;   Compute new logical stack address
;

        mov     ebx,[esp]+TsTempEsp
        sub     ebx,12
        mov     [esp]+TsErrCode,ebx

;
;   Copy eip,cs,eflags to new stack.  note we do this high to low
;

        mov     esi,[esp]+TsEflags
        mov     [ebx+8],esi
        mov     esi,[esp]+TsSegCs
        mov     [ebx+4],esi
        mov     esi,[esp]+TsEip
        mov     [ebx],esi

;
;   Do a standard restore sequence.
;
;   Observe that RestoreVolatiles is honored.  Editing a volatile
;   register has no effect when returning from a system call.
;
ifb     <NoRestoreVolatiles>
        mov     eax,[esp].TsEax
endif
;        add     esp,TsSegGs
;
;ifb     <NoRestoreSegs>
;        pop     gs
;        pop     es
;        pop     ds
;else
;        add     esp,12
;endif

ifb     <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx
        mov     ecx, [esp]+TsEcx
endif

;ifnb <NoPreviousMode>
;        add     esp, 4              ; Skip previous mode
;else
;        pop     ebx                 ; Restore PreviousMode
;        mov     esi,fs:[PcPrcbData+PbCurrentThread]
;        mov     ss:[esi]+ThPreviousMode,bl
;endif
;
;       pop     ebx
;
;       mov     fs:[PcExceptionList], ebx ;Restore ExceptionList
;       pop     fs

        add     esp, TsEdi
        pop     edi                 ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
;   (esp)->TsErrCode, where we saved the new esp
;

        mov     esp,[esp]           ; Do move not push to avoid increment
        iretd

        endm


;++
;
;   INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from an interrupt vector service
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution. If control is returning to
;       user mode and there is a user  APC pending, then APC level interupt
;       will be requested and control is transfered to the user APC delivery
;       routine, if no higher level interrupt pending.
;
;   Arguments:
;
;       (TOS)   = previous irql
;       (TOS+4 ...) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

INTERRUPT_EXIT     macro
local   a

if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif

        cli
        pop     ecx
        jmp     @HalEndSystemInterrupt@4

endm


;++
;
;   LEVEL_INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from an interrupt vector service
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution. If control is returning to
;       user mode and there is a user  APC pending, then APC level interupt
;       will be requested and control is transfered to the user APC delivery
;       routine, if no higher level interrupt pending.
;
;   Arguments:
;
;       (eax)-> bus interrupt level
;       (TOS)   = previous irql
;       (TOS+4 ...) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

LEVEL_INTERRUPT_EXIT     macro
local   a

if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif

        cli
        pop     ecx
        jmp     @HalEndSystemLevelInterrupt@4

endm


;++
;
;   SPURIOUS_INTERRUPT_EXIT
;
;   Macro Description:
;
;       To exit an interrupt without performing the EOI.
;
;   Arguments:
;
;       (TOS) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

SPURIOUS_INTERRUPT_EXIT  macro
local   a
if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif
        jmp     Kei386EoiHelper@0
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\thredini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent function to set the initial
    context and data alignment handling mode for a process or thread object.

Author:

    David N. Cutler (davec) 31-Mar-1990

Environment:

    Kernel mode only.

Revision History:

    3 April 90  bryan willman

        This version ported to 386.

--*/

#include "ki.h"

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN SIZE_T TlsDataSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread object.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    TlsDataSize - Supplies the number of bytes reserved from the kernel stack
        for thread local storage.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;
    PVOID TlsData;
    PKSWITCHFRAME SwitchFrame;
    PULONG PSystemRoutine;
    PULONG PStartRoutine;
    PULONG PStartContext;

    //
    // Load up an initial NPX state.
    //

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->StackBase) -
                sizeof(FX_SAVE_AREA)));

    RtlZeroMemory((PVOID)NpxFrame, sizeof(FX_SAVE_AREA));

    NpxFrame->FloatSave.ControlWord = 0x27f;     //like fpinit but 64bit mode
    NpxFrame->FloatSave.MXCsr       = 0x1f80;    // mask all the exceptions

    //
    // Thread's NPX state is not in the coprocessor.
    //

    Thread->NpxState = NPX_STATE_NOT_LOADED;

    //
    // Zero the thread local storage area.
    //

    TlsDataSize = ALIGN_UP(TlsDataSize, ULONG);
    TlsData = ((PUCHAR)(ULONG)NpxFrame) - TlsDataSize;

    if (TlsDataSize != 0) {
        Thread->TlsData = TlsData;
        RtlZeroMemory(TlsData, TlsDataSize);
    } else {
        Thread->TlsData = NULL;
    }

    //
    // Space for arguments to KiThreadStartup.  Order of fields in the
    // switchframe is important, since args are passed on stack through
    // KiThreadStartup to PStartRoutine with PStartContext as an argument.
    //

    PStartContext = (PULONG)((ULONG)TlsData) - 1;
    PStartRoutine = PStartContext - 1;
    PSystemRoutine = PStartRoutine - 1;

    SwitchFrame = (PKSWITCHFRAME)((PUCHAR)PSystemRoutine - sizeof(KSWITCHFRAME));

    //
    // Set up thread start parameters.
    //

    *PStartContext = (ULONG)StartContext;
    *PStartRoutine = (ULONG)StartRoutine;
    *PSystemRoutine = (ULONG)SystemRoutine;

    //
    // Set up switch frame.
    //

    SwitchFrame->RetAddr = (ULONG)KiThreadStartup;

    SwitchFrame->Eflags = EFLAGS_INTERRUPT_MASK;

    SwitchFrame->ExceptionList = (ULONG)(EXCEPTION_CHAIN_END);

    //
    // Set the initial kernel stack pointer.
    //

    Thread->KernelStack = (PVOID)SwitchFrame;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\threadbg.asm ===
title  "Thread Startup"

;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    threadbg.asm
;
; Abstract:
;
;    This module implements the code necessary to startup a thread in kernel
;    mode.
;
; Author:
;
;    Bryan Willman (bryanwi) 22-Feb-1990, derived from DaveC's code.
;
; Environment:
;
;    Kernel mode only, IRQL PASSIVE_LEVEL.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KeBugCheck,1
        EXTRNP  _PsTerminateSystemThread,1
        extrn   _KiPCR:DWORD

        page ,132
        subttl  "Thread Startup"

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; Routine Description:
;
;    This routine is called at thread startup. Its function is to call the
;    initial thread procedure.
;
; Arguments:
;
;   (TOS)    = SystemRoutine - address of initial system routine.
;   (TOS+4)  = StartRoutine - Initial thread routine.
;   (TOS+8)  = StartContext - Context parm for initial thread routine.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiThreadStartup    ,1

        xor     ebx,ebx             ; clear registers
        xor     esi,esi             ;
        xor     edi,edi             ;
        xor     ebp,ebp             ;
        mov     ecx, PASSIVE_LEVEL
        fstCall KfLowerIrql         ; KeLowerIrql(PASSIVE_LEVEL)

;
; Check if PsCreateSystemThreadEx failed to fully initialize the thread.  If so,
; it will mark the thread as already terminated and use PsTerminateSystemThread
; to cleanup the thread.
;

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        cmp     BYTE PTR [eax].ThHasTerminated, 0
        jne     kits20

;
; Invoke the system routine.
;

        pop     eax                 ; (eax)->SystemRoutine
        call    eax                 ; SystemRoutine(StartRoutine, StartContext)
IFNDEF STD_CALL
        add     esp,8               ; Clear off args
ENDIF

kits10: stdCall _KeBugCheck, <NO_USER_MODE_CONTEXT>

kits20: stdCall _PsTerminateSystemThread, <STATUS_NO_MEMORY>

stdENDP _KiThreadStartup

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\timindex.asm ===
TITLE   "Compute Timer Table Index"
;++
;
; Copyright (c) 1993  Microsoft Corporation
;
; Module Name:
;
;    timindex.asm
;
; Abstract:
;
;    This module implements the code necessary to compute the timer table
;    index for a timer.
;
; Author:
;
;    David N. Cutler (davec) 19-May-1993
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        extrn  _KiTimeIncrementReciprocal:dword
        extrn  _KiTimeIncrementShiftCount:BYTE

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Compute Timer Table Index"
;++
;
; ULONG
; KiComputeTimerTableIndex (
;    IN LARGE_INTEGER Interval,
;    IN LARGE_INTEGER CurrentTime,
;    IN PKTIMER Timer
;    )
;
; Routine Description:
;
;    This function computes the timer table index for the specified timer
;    object and stores the due time in the timer object.
;
;    N.B. The interval parameter is guaranteed to be negative since it is
;         expressed as relative time.
;
;    The formula for due time calculation is:
;
;    Due Time = Current Time - Interval
;
;    The formula for the index calculation is:
;
;    Index = (Due Time / Maximum time) & (Table Size - 1)
;
;    The time increment division is performed using reciprocal multiplication.
;
; Arguments:
;
;    Interval  - Supplies the relative time at which the timer is to
;        expire.
;
;    CurrentCount  - Supplies the current system tick count.
;
;    Timer - Supplies a pointer to a dispatch object of type timer.
;
; Return Value:
;
;    The time table index is returned as the function value and the due
;    time is stored in the timer object.
;
;--

LocalStack  equ  20

Interval    equ [esp+LocalStack+4]
CurrentTime equ [esp+LocalStack+12]
Timer       equ [esp+LocalStack+20]

cPublicProc _KiComputeTimerTableIndex ,5
        sub     esp, LocalStack
        mov     [esp+16], ebx
        mov     ebx,CurrentTime         ; get low current time
        mov     ecx,CurrentTime + 4     ; get high current time
        sub     ebx,Interval            ; subtract low parts
        sbb     ecx,Interval + 4        ; subtract high parts and borrow
        mov     eax,Timer               ; get address of timer object
        mov     [eax].TiDueTime.LiLowPart,ebx ; set low part of due time
        mov     [eax].TiDueTime.LiHighPart,ecx ; set high part of due time

;
; Compute low 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax,ebx                 ; copy low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        mov     [esp+12], edx           ; save high order 32-bits of product

;
; Compute low 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax,ebx                 ; copy low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal+4] ;multiply by high 32-bits of divisor
        mov     [esp+8], eax            ; save full 64-bit product
        mov     [esp+4], edx            ;

;
; Compute high 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax,ecx                 ; copy high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        mov     [esp+0], edx            ; save high 32-bits of product

;
; Compute carry out of low 64-bits of 128-bit product.
;

        xor     ebx,ebx                 ; clear carry accumlator
        add     eax,[esp]+8             ; generate carry
        adc     ebx,0                   ; accumlate carry
        add     eax,[esp]+12             ; generate carry
        adc     ebx,0                   ; accumulate carry

;
; Compute high 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax,ecx                 ; copy high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal+4] ; multiply by high 32-bits of divisor

;
; Compute high 64-bits of 128-bit product.
;

        add     eax,ebx                 ; add carry from low 64-bits
        adc     edx,0                   ; propagate carry
        add     eax,[esp]+0             ; add and generate carry
        adc     edx,0                   ; propagate carry
        add     eax,[esp]+4             ; add and generate carry
        adc     edx,0                   ; propagate carry

;
; Right shift the result by the specified shift count and mask off extra
; bits.
;

        mov     cl,[_KiTimeIncrementShiftCount] ; get shift count value
        shrd    eax,edx,cl              ; extract appropriate product bits

        mov     ebx, [esp+16]           ; restore register
        add     esp, LocalStack         ; trim stack
        and     eax,(TIMER_TABLE_SIZE-1); reduce to size of table

        stdRET    _KicomputeTimerTableIndex

stdENDP _KiComputeTimerTableIndex

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    trap.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    trap conditions.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 4-Feb-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
        .list


        page ,132
        extrn   ExpInterlockedPopEntrySListFault:DWORD
        extrn   ExpInterlockedPopEntrySListResume:DWORD
        extrn   _KiHardwareTrigger:dword
        extrn   _KiBugCheckData:dword
        EXTRNP  _KeGetCurrentIrql,0

        EXTRNP  _HalHandleNMI,0
        EXTRNP  HalBeginSystemInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  _KiDispatchException,4
        EXTRNP  _MmAccessFault,3
        EXTRNP  _KeBugCheck,1
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeTestAlertThread,1
        EXTRNP  _KiContinue,3
        EXTRNP  _KiRaiseException,5
        extrn   _DbgPrint:proc
        EXTRNP  _Ki386CheckDivideByZeroTrap,1
        extrn   SwapContext:near
        extrn   _KiGDT:BYTE
        extrn   _KiPCR:DWORD
        extrn   _KiDoubleFaultTSS:DWORD
ifdef DEVKIT
        EXTRNP  _KdSetOwedBreakpoints
        extrn   _KdpOweBreakpoint:dword
endif

;
; Equates for exceptions which cause system fatal error
;

EXCEPTION_DIVIDED_BY_ZERO       EQU     0
EXCEPTION_DEBUG                 EQU     1
EXCEPTION_NMI                   EQU     2
EXCEPTION_INT3                  EQU     3
EXCEPTION_BOUND_CHECK           EQU     5
EXCEPTION_INVALID_OPCODE        EQU     6
EXCEPTION_NPX_NOT_AVAILABLE     EQU     7
EXCEPTION_DOUBLE_FAULT          EQU     8
EXCEPTION_NPX_OVERRUN           EQU     9
EXCEPTION_INVALID_TSS           EQU     0AH
EXCEPTION_SEGMENT_NOT_PRESENT   EQU     0BH
EXCEPTION_STACK_FAULT           EQU     0CH
EXCEPTION_GP_FAULT              EQU     0DH
EXCEPTION_RESERVED_TRAP         EQU     0FH
EXCEPTION_NPX_ERROR             EQU     010H
EXCEPTION_ALIGNMENT_CHECK       EQU     011H

;
; Exception flags
;

EXCEPT_UNKNOWN_ACCESS           EQU     0H
EXCEPT_LIMIT_ACCESS             EQU     10H

;
; page fault read/write mask
;

ERR_0E_STORE                    EQU     2

;
; EFLAGS single step bit
;

EFLAGS_TF_BIT                   EQU     100h
EFLAGS_OF_BIT                   EQU     4000H

;
;   Force assume into place
;

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT PARA PUBLIC 'DATA'

;
; Definitions for gate descriptors
;

GATE_TYPE_386INT        EQU     0E00H
GATE_TYPE_386TRAP       EQU     0F00H
GATE_TYPE_TASK          EQU     0500H
D_GATE                  EQU     0
D_PRESENT               EQU     8000H
D_DPL_3                 EQU     6000H
D_DPL_0                 EQU     0

;
; Definitions for present 386 trap and interrupt gate attributes
;

D_TRAP032               EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386TRAP
D_TRAP332               EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386TRAP
D_INT032                EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386INT
D_INT332                EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386INT
D_TASK                  EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_TASK

;
;       This is the protected mode interrupt descriptor table.
;

if DBG
BadInterruptMessage db 0ah,7,7,'!!! Unexpected Interrupt %02lx !!!',0ah,00
endif

;++
;
;   DEFINE_SINGLE_EMPTY_VECTOR - helper for DEFINE_EMPTY_VECTORS
;
;--

DEFINE_SINGLE_EMPTY_VECTOR macro    number
IDTEntry    _KiUnexpectedInterrupt&number, D_INT032
_TEXT   SEGMENT
        public  _KiUnexpectedInterrupt&number
_KiUnexpectedInterrupt&number proc
        push    dword ptr (&number)
        jmp     _KiUnexpectedInterruptTail
_KiUnexpectedInterrupt&number endp
_TEXT   ENDS

        endm

FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, FPO_TRAPFRAME )
endm

FXSAVE_ESI  macro
    db  0FH, 0AEH, 06
endm

FXSAVE_ECX  macro
    db  0FH, 0AEH, 01
endm

FXRSTOR_ECX macro
    db  0FH, 0AEH, 09
endm

;++
;
;   DEFINE_EMPTY_VECTORS emits an IDTEntry macro (and thus and IDT entry)
;   into the data segment.  It then emits an unexpected interrupt target
;   with push of a constant into the code segment.  Labels in the code
;   segment are defined to bracket the unexpected interrupt targets so
;   that KeConnectInterrupt can correctly test for them.
;
;   Empty vectors will be defined from 30 to 3f, which is the hardware
;   vector set.
;
;--

NUMBER_OF_IDT_VECTOR    EQU     03fH

DEFINE_EMPTY_VECTORS macro

;
;   Set up
;

        empty_vector = 00H

_TEXT   SEGMENT
IFDEF STD_CALL
        public  _KiStartUnexpectedRange@0
_KiStartUnexpectedRange@0   equ     $
ELSE
        public  _KiStartUnexpectedRange
_KiStartUnexpectedRange     equ     $
ENDIF
_TEXT   ENDS

        rept (NUMBER_OF_IDT_VECTOR - (($ - _KiIDT)/8)) + 1

        DEFINE_SINGLE_EMPTY_VECTOR  %empty_vector
        empty_vector = empty_vector + 1

        endm    ;; rept

_TEXT   SEGMENT
IFDEF STD_CALL
        public  _KiEndUnexpectedRange@0
_KiEndUnexpectedRange@0     equ     $
ELSE
        public  _KiEndUnexpectedRange
_KiEndUnexpectedRange       equ     $
ENDIF
_TEXT   ENDS

        endm    ;; DEFINE_EMPTY_VECTORS macro

IDTEntry macro  name,access
        dd      offset FLAT:name
        dw      access
        dw      KGDT_R0_CODE
        endm

IDTEntryEx macro  name,access,sel
        dd      offset FLAT:name
        dw      access
        dw      sel
        endm

ALIGN 8
                public  _KiIDT, _KiIDTLEN, _KiIDTEnd
_KiIDT          label byte

IDTEntry        _KiTrap00, D_INT032             ; 0: Divide Error
IDTEntry        _KiTrap01, D_INT032             ; 1: DEBUG TRAP
IDTEntryEx      _KiTrap02, D_TASK, KGDT_NMI_TSS ; 2: NMI/NPX Error
IDTEntry        _KiTrap03, D_INT332             ; 3: Breakpoint
IDTEntry        _KiTrap04, D_INT332             ; 4: INTO
IDTEntry        _KiTrap05, D_INT032             ; 5: BOUND/Print Screen
IDTEntry        _KiTrap06, D_INT032             ; 6: Invalid Opcode
IDTEntry        _KiTrap07, D_INT032             ; 7: NPX Not Available
IDTEntryEx      _KiTrap08, D_TASK, KGDT_DF_TSS  ; 8: Double Exception
IDTEntry        _KiTrap09, D_INT032             ; 9: NPX Segment Overrun
IDTEntry        _KiTrap0A, D_INT032             ; A: Invalid TSS
IDTEntry        _KiTrap0B, D_INT032             ; B: Segment Not Present
IDTEntry        _KiTrap0C, D_INT032             ; C: Stack Fault
IDTEntry        _KiTrap0D, D_INT032             ; D: General Protection
IDTEntry        _KiTrap0E, D_INT032             ; E: Page Fault
IDTEntry        _KiTrap0F, D_INT032             ; F: Intel Reserved

IDTEntry        _KiTrap10, D_INT032             ;10: 486 coprocessor error
IDTEntry        _KiTrap11, D_INT032             ;11: 486 alignment
IDTEntry        _KiTrap0F, D_INT032             ;12: Machine-Check
IDTEntry        _KiTrap13, D_INT032             ;13: XMMI unmasked numeric exception
IDTEntry        _KiTrap0F, D_INT032             ;14: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;15: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;16: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;17: Intel Reserved

IDTEntry        _KiTrap0F, D_INT032             ;18: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;19: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1A: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1B: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1C: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1D: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1E: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1F: Reserved for APIC

        rept 28H - (($ - _KiIDT)/8)
IDTEntry        0, 0                            ;invalid IDT entry
        endm
IDTEntry        _KiContinueService, D_INT332        ;28: NtContinue service
IDTEntry        _KiRaiseExceptionService, D_INT332  ;29: NtRaiseException service
IDTEntry        0, 0                                ;2A: OBSOLETE: KiGetTickCount service
IDTEntry        0, 0                                ;2B: OBSOLETE: KiCallbackReturn
IDTEntry        0, 0                                ;2C: OBSOLETE: KiSetLowWaitHighThread service
IDTEntry        _KiDebugService,  D_INT332          ;2D: debugger calls
IDTEntry        0, 0                                ;2E: OBSOLETE: system service calls
IDTEntry        _KiTrap0F, D_INT032                 ;2F: Reserved for APIC

;
;   Generate per-vector unexpected interrupt entries for 30 - 3f
;
        DEFINE_EMPTY_VECTORS

_KiIDTLEN       equ     $ - _KiIDT
_KiIDTEnd       equ     $

                public  _KiUnexpectedEntrySize
_KiUnexpectedEntrySize          dd  _KiUnexpectedInterrupt1 - _KiUnexpectedInterrupt0

;
; definition for  floating status word error mask
;

FSW_INVALID_OPERATION   EQU     1
FSW_DENORMAL            EQU     2
FSW_ZERO_DIVIDE         EQU     4
FSW_OVERFLOW            EQU     8
FSW_UNDERFLOW           EQU     16
FSW_PRECISION           EQU     32
FSW_STACK_FAULT         EQU     64
FSW_CONDITION_CODE_0    EQU     100H
FSW_CONDITION_CODE_1    EQU     200H
FSW_CONDITION_CODE_2    EQU     400H
FSW_CONDITION_CODE_3    EQU     4000H
_DATA   ENDS

_TEXT   SEGMENT
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page    ,132
        subttl "NtContinue service"
;++
;
; Routine Description:
;
;    This routine gains control when trap occurs via vector 28H.
;
;    After the trap frame is constructed, control is transferred to
;    NtContinue.  The call will not return.
;
; Arguments:
;
;    eax - ContextRecord parameter to NtContinue.
;    ecx - TestAlert parameter to NtContinue.
;
; Return Value:
;
;    Does not return.
;
;--

align 16
        PUBLIC  _KiContinueService
_KiContinueService proc

        ENTER_SYSCALL
        stdCall _NtContinue, <eax, ecx>

_KiContinueService endp

        page    ,132
        subttl "NtRaiseException service"
;++
;
; Routine Description:
;
;    This routine gains control when trap occurs via vector 29H.
;
;    After the trap frame is constructed, control is transferred to
;    NtRaiseException.  The call will not return.
;
; Arguments:
;
;    eax - ExceptionRecord parameter to NtRaiseException.
;    ecx - ContextRecord parameter to NtRaiseException.
;    edx - FirstChance parameter to NtRaiseException.
;
; Return Value:
;
;    Does not return.
;
;--

align 16
        PUBLIC  _KiRaiseExceptionService
_KiRaiseExceptionService proc

        ENTER_SYSCALL
        stdcall _NtRaiseException, <eax, ecx, edx>

_KiRaiseExceptionService endp

;
;   System service's private version of KiExceptionExit
;   (Also used by KiDebugService)
;
        public  _KiServiceExit
_KiServiceExit:

        cli                                         ; disable interrupts

;
; Exit from SystemService
;

        EXIT_ALL    NoRestoreSegs, NoRestoreVolatile

;++
;
;   _KiServiceExit2 - same as _KiServiceExit BUT the full trap_frame
;       context is restored
;
;--
        public  _KiServiceExit2
_KiServiceExit2:

        cli                             ; disable interrupts

;
; Exit from SystemService
;
        EXIT_ALL                            ; RestoreAll

        page ,132
        subttl  "Common Trap Exit"
;++
;
;   KiExceptionExit
;
;   Routine Description:
;
;       This code is transfered to at the end of the processing for
;       an exception.  Its function is to restore machine state, and
;       continue thread execution.  If control is returning to user mode
;       and there is a user APC pending, then control is transfered to
;       the user APC delivery routine.
;
;       N.B. It is assumed that this code executes at IRQL zero or APC_LEVEL.
;          Therefore page faults and access violations can be taken.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (ebp) -> base of trap frame.
;
;   Return Value:
;
;       None.
;
;--
align 4
        public  _KiExceptionExit
_KiExceptionExit proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        cli                             ; disable interrupts

;
; Exit from Exception
;

        EXIT_ALL    ,,NoPreviousMode

_KiExceptionExit endp


;++
;
;   KiUnexpectedInterruptTail
;
;   Routine Description:
;       This function is jumped to by an IDT entry who has no interrupt
;       handler.
;
;   Arguments:
;
;       (esp) -> base of trap frame.
;       (ebp) -> base of trap frame.
;
;--

        public  _KiUnexpectedInterruptTail
_KiUnexpectedInterruptTail  proc
        ENTER_INTERRUPT PassDwordParm

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

        mov     ecx, [ebp]+TsErrCode    ; get IRQ passed through error code
        mov     edx, HIGH_LEVEL
        push    0                       ; make space for OldIrql

        fstCall HalBeginSystemInterrupt

if DBG
        push    dword ptr [ebp]+TsErrCode
        push    offset FLAT:BadInterruptMessage
        call    _DbgPrint               ; display unexpected interrupt message
        add     esp, 8
endif
;
; end this interrupt
;
        INTERRUPT_EXIT

_KiUnexpectedInterruptTail  endp


        page , 132
        subttl "trap processing"

;++
;
; Routine Description:
;
;    _KiTrapxx - protected mode trap entry points
;
;    These entry points are for internally generated exceptions,
;    such as a general protection fault.  They do not handle
;    external hardware interrupts, or user software interrupts.
;
; Arguments:
;
;    On entry the stack looks like:
;
;       [ss]
;       [esp]
;       eflags
;       cs
;       eip
;    ss:sp-> [error]
;
;    The cpu saves the previous SS:ESP, eflags, and CS:EIP on
;    the new stack if there was a privilige transition. If no
;    priviledge level transition occurred, then there is no
;    saved SS:ESP.
;
;    Some exceptions save an error code, others do not.
;
; Return Value:
;
;       None.
;
;--


        page , 132
        subttl "dispatch exception"

;++
;
; CommonDispatchException
;
; Routine Description:
;
;    This routine allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
;    NOTE:
;
;    The purpose of this routine is to save code space.  Use this routine
;    only if:
;    1. ExceptionRecord is NULL
;    2. ExceptionFlags is 0
;    3. Number of parameters is less or equal than 3.
;
;    Otherwise, you should use DISPATCH_EXCEPTION macro to set up your special
;    exception record.
;
; Arguments:
;
;    (eax) = ExcepCode - Exception code to put into exception record
;    (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
;    (ecx) = NumParms - Number of additional parameters
;    (edx) = Parameter1
;    (esi) = Parameter2
;    (edi) = Parameter3
;
; Return Value:
;
;    None.
;
;--
CommonDispatchException0Args:
        xor     ecx, ecx                ; zero arguments
        call    CommonDispatchException

CommonDispatchException1Arg0d:
        xor     edx, edx                ; zero edx
CommonDispatchException1Arg:
        mov     ecx, 1                  ; one argument
        call    CommonDispatchException ; there is no return

CommonDispatchException2Args0d:
        xor     edx, edx                ; zero edx
CommonDispatchException2Args:
        mov     ecx, 2                  ; two arguments
        call    CommonDispatchException ; there is no return

      public CommonDispatchException
align dword
CommonDispatchException proc
cPublicFpo 0, ExceptionRecordLength / 4
;
;       Set up exception record for raising exception
;

        sub     esp, ExceptionRecordLength
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, eax
                                        ; set up exception code
        xor     eax, eax
        mov     dword ptr [esp]+ErExceptionFlags, eax
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, eax
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ebx
        mov     dword ptr [esp]+ErNumberParameters, ecx
                                        ; set number of parameters
        cmp     ecx, 0
        je      short de00

        lea     ebx, [esp + ErExceptionInformation]
        mov     [ebx], edx
        mov     [ebx+4], esi
        mov     [ebx+8], edi
de00:
;
; set up arguments and call _KiDispatchException
;

        mov     ecx, esp                ; (ecx)->exception record

; 1 - first chance TRUE
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

        stdCall _KiDispatchException,<ecx, 0, ebp, 1>

        mov     esp, ebp                ; (esp) -> trap frame
        jmp     _KiExceptionExit

CommonDispatchException endp

        page ,132
        subttl "Divide error processing"
;++
;
; Routine Description:
;
;    Handle divide error fault.
;
;    The divide error fault occurs if a DIV or IDIV instructions is
;    executed with a divisor of 0, or if the quotient is too big to
;    fit in the result operand.
;
;    An INTEGER DIVIDED BY ZERO exception will be raised for the fault.
;    If the fault occurs in kernel mode, the system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap00
_KiTrap00       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; Set up exception record for raising Integer_Divided_by_zero exception
; and call _KiDispatchException
;

if DBG
        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jnz     short @f                                ; interrupts disabled?

        xor     eax, eax
        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,-1,eax,esi>
@@:
endif

        sti

;
; Flat mode
;
; The intel processor raises a divide by zero expcetion on DIV instruction
; which overflows. To be compatible we other processors we want to
; return overflows as such and not as divide by zero's.  The operand
; on the div instruction is tested to see if it's zero or not.
;
        stdCall _Ki386CheckDivideByZeroTrap,<ebp>
        mov     ebx, [ebp]+TsEip        ; (ebx)-> faulting instruction
        jmp     CommonDispatchException0Args ; Won't return

_KiTrap00       endp

        page ,132
        subttl "Debug Exception"
;++
;
; Routine Description:
;
;    Handle debug exception.
;
;    The processor triggers this exception for any of the following
;    conditions:
;
;    1. Instruction breakpoint fault.
;    2. Data address breakpoint trap.
;    3. General detect fault.
;    4. Single-step trap.
;    5. Task-switch breadkpoint trap.
;
;
; Arguments:
;
;    At entry, the values of saved CS and EIP depend on whether the
;    exception is a fault or a trap.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap01
_KiTrap01       proc

; Set up machine state frame for displaying

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; Set up exception record for raising single step exception
; and call _KiDispatchException
;

        and     dword ptr [ebp]+TsEflags, not EFLAGS_TF_BIT
        mov     ebx, [ebp]+TsEip                ; (ebx)-> faulting instruction
        mov     eax, STATUS_SINGLE_STEP
        jmp     CommonDispatchException0Args    ; Never return

_KiTrap01       endp

        page ,132
        subttl "Nonmaskable Interrupt"
;++
;
; Routine Description:
;
;    Handle Nonmaskable interrupt.
;
;    An NMI is typically used to signal serious system conditions
;    such as bus time-out, memory parity error, and so on.
;
;    Upon detection of the NMI, the system will be terminated, ie a
;    bugcheck will be raised, no matter what previous mode is.
;
; Arguments:
;
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap02
_KiTrap02       proc
.FPO (1, 0, 0, 0, 0, 2)
        cli

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; Clear the busy bit in the TSS selector
;
        mov     byte ptr [_KiGDT+KGDT_NMI_TSS+5],089h

;
; Let the HAL have a crack at it before we crash
;
        stdCall _HalHandleNMI

        stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP,2,0,0,0>

_KiTrap02       endp

        page ,132
        subttl "DebugService Breakpoint"
;++
;
; Routine Description:
;
;    Handle INT 2d DebugService
;
;    The trap is caused by an INT 2d.  This is used instead of a
;    BREAKPOINT exception so that parameters can be passed for the
;    requested debug service.  A BREAKPOINT instruction is assumed
;    to be right after the INT 2d - this allows this code to share code
;    with the breakpoint handler.
;
; Arguments:
;     eax - ServiceClass - which call is to be performed
;     ecx - Arg1 - generic first argument
;     edx - Arg2 - generic second argument
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiDebugService
_KiDebugService  proc
        push    0                           ; push dummy error code
        ENTER_TRAP
;       sti                                 ; *NEVER sti here*

        inc     dword ptr [ebp]+TsEip
        mov     eax, [ebp]+TsEax            ; ServiceClass
        mov     ecx, [ebp]+TsEcx            ; Arg1      (already loaded)
        mov     edx, [ebp]+TsEdx            ; Arg2      (already loaded)
        jmp     KiTrap03DebugService

_KiDebugService  endp

        page ,132
        subttl "Single Byte INT3 Breakpoin"
;++
;
; Routine Description:
;
;    Handle INT 3 breakpoint.
;
;    The trap is caused by a single byte INT 3 instruction.  A
;    BREAKPOINT exception with additional parameter indicating
;    READ access is raised for this trap if previous mode is user.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INT 3 instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap03
_KiTrap03       proc
        push    0                       ; push dummy error code
        ENTER_TRAP

   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

        mov     eax, BREAKPOINT_BREAK

KiTrap03DebugService:

;
; Set up exception record and arguments for raising breakpoint exception
;

        mov     esi, ecx                ; ExceptionInfo 2
        mov     edi, edx                ; ExceptionInfo 3
        mov     edx, eax                ; ExceptionInfo 1

        mov     ebx, [ebp]+TsEip
        dec     ebx                     ; (ebx)-> int3 instruction
        mov     ecx, 3
        mov     eax, STATUS_BREAKPOINT
        call    CommonDispatchException ; Never return

_KiTrap03       endp

        page ,132
        subttl "Integer Overflow"
;++
;
; Routine Description:
;
;    Handle INTO overflow.
;
;    The trap occurs when the processor encounters an INTO instruction
;    and the OF flag is set.
;
;    An INTEGER_OVERFLOW exception will be raised for this fault.
;
;    N.B. i386 will not generate fault if only OF flag is set.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INTO instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap04
_KiTrap04       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; set exception record and arguments and call _KiDispatchException
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> instr. after INTO
        dec     ebx                     ; (ebx)-> INTO
        mov     eax, STATUS_INTEGER_OVERFLOW
        jmp     CommonDispatchException0Args ; Never return

_KiTrap04       endp

        page ,132
        subttl "Bound Check fault"
;++
;
; Routine Description:
;
;    Handle bound check fault.
;
;    The bound check fault occurs if a BOUND instruction finds that
;    the tested value is outside the specified range.
;
;    For bound check fault, an ARRAY BOUND EXCEEDED exception will be
;    raised.
;    For kernel mode exception, it causes system to be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting BOUND
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap05
_KiTrap05       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; set exception record and arguments and call _KiDispatchException
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->BOUND instruction
        mov     eax, STATUS_ARRAY_BOUNDS_EXCEEDED
        jmp     CommonDispatchException0Args ; Won't return

_KiTrap05       endp

        page ,132
        subttl "Invalid OP code"
;++
;
; Routine Description:
;
;    Handle invalid op code fault.
;
;    The invalid opcode fault occurs if CS:EIP point to a bit pattern which
;    is not recognized as an instruction by the 386.  This may happen if:
;
;    1. the opcode is not a valid 80386 instruction
;    2. a register operand is specified for an instruction which requires
;       a memory operand
;    3. the LOCK prefix is used on an instruction that cannot be locked
;
;    If fault occurs in USER mode:
;       an Illegal_Instruction exception will be raised
;    if fault occurs in KERNEL mode:
;       system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the invalid
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap06
_KiTrap06       proc

        push    0                       ; Push dummy error code
        ENTER_TRAP

;
; set exception record and arguments and call _KiDispatchException
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> invalid instruction
        mov     eax, STATUS_ILLEGAL_INSTRUCTION
        jmp     CommonDispatchException0Args ; Won't return

_KiTrap06       endp

        page ,132
        subttl "Coprocessor Not Avalaible"
;++
;
; Routine Description:
;
;   Handle Coprocessor not avaliable exception.
;
;   If we are REALLY emulating the 80387, the trap 07 vector is edited
;   to point directly at the emulator's entry point.  So this code is
;   only hit when an 80387 DOES exist.
;
;   The current threads coprocessor state is loaded into the
;   coprocessor.  If the coprocessor has a different threads state
;   in it (UP only) it is first saved away.  The thread is then continued.
;   Note: the threads state may contian the TS bit - In this case the
;   code loops back to the top of the Trap07 handler.  (which is where
;   we would end up if we let the thread return to user code anyway).
;
;   If the threads NPX context is in the coprocessor and we hit a Trap07
;   there is an NPX error which needs to be processed.  If the trap was
;   from usermode the error is dispatched.  If the trap was from kernelmode
;   the error is remembered, but we clear CR0 so the kernel code can
;   continue.  We can do this because the kernel mode code will restore
;   CR0 (and set TS) to signal a delayed error for this thread.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the faulting
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap07
_KiTrap07       proc

        push    0                       ; push dummy error code
        ENTER_TRAP
Kt0700:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack
        cli                             ; don't context switch

;
; Bugcheck if attempting to use the FPU from a DPC without first calling
; KeSaveFloatingPointState.
;

if DBG
        cmp     PCR[PcPrcbData.PbDpcRoutineActive],0
        jne     Kt07110
endif

Kt0701: cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        je      Kt0715

;
; Trap occured and this threads NPX state is not loaded.  Load it now
; and resume the application.  If someone elses state is in the coprocessor
; (uniprocessor implementation only) then save it first.
;

        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                ; allow frstor (& fnsave) to work

Kt0702:
        mov     edx, PCR[PcPrcbData+PbNpxThread] ; Owner of NPX state
        or      edx, edx                ; NULL?
        jz      Kt0704                  ; Yes - skip save

;
; Due to an hardware errata we need to know that the coprocessor
; doesn't generate an error condition once interrupts are disabled and
; trying to perform an fnsave which could wait for the error condition
; to be handled.
;
; The fix for this errata is that we "know" that the coprocessor is
; being used by a different thread then the one which may have caused
; the error condition.  The round trip time to swap to a new thread
; is longer then ANY floating point instruction.  We therefore know
; that any possible coprocessor error has already occured and been
; handled.
;
        mov     esi,[edx].ThStackBase
        sub     esi, NPX_FRAME_LENGTH   ; Space for NPX_FRAME

        FXSAVE_ESI
        mov     byte ptr [edx].ThNpxState, NPX_STATE_NOT_LOADED
Kt0704:

;
; Load current threads coprocessor state into the coprocessor
;
; (eax) - CurrentThread
; (ecx) - CurrentThreads NPX save area
; (ebx) - CR0
; (ebp) - trap frame
; Interrupts disabled
;

        FXRSTOR_ECX                     ; reload NPX context

Kt0704c:
        mov     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        mov     PCR[PcPrcbData+PbNpxThread], eax  ; owner of coprocessors state

        sti                             ; Allow interrupts & context switches
        nop                             ; sti needs one cycle

        cmp     dword ptr [ecx].FpCr0NpxState, 0
        jz      _KiExceptionExit        ; nothing to set, skip CR0 reload

;
; Note: we have to get the CR0 value again to insure that we have the
;       correct state for TS.  We may have context switched since
;       the last move from CR0, and our npx state may have been moved off
;       of the npx.
;
        cli
if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz short Kt07dbg1
endif
        mov     ebx,CR0
        or      ebx, [ecx].FpCr0NpxState
        mov     cr0, ebx                ; restore threads CR0 NPX state
        sti
        test    ebx, CR0_TS             ; Setting TS?  (delayed error)
        jz      _KiExceptionExit        ; No - continue

        jmp     Kt0700                  ; Dispatch delayed exception
if DBG
Kt07dbg1:    int 3
Kt07dbg2:    int 3
Kt07dbg3:    int 3
        sti
        jmp short $-2
endif

;
; A Trap07 or Trap10 has occured from a ring 0 ESCAPE instruction.  This
; may occur when trying to load the coprocessors state.  These
; code paths rely on Cr0NpxState to signal a delayed error (not CR0) - we
; set CR0_TS in Cr0NpxState to get a delayed error, and make sure CR0 CR0_TS
; is not set so the R0 ESC instruction(s) can complete.
;
; (ecx) - CurrentThreads NPX save area
; (ebp) - trap frame
; Interrupts disabled
;

Kt0710:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack

Kt0715:
if DBG
        mov     eax, cr0                    ; Did we fault because some bit in CR0
        test    eax, (CR0_TS+CR0_MP+CR0_EM)
        jnz     short Kt07dbg3
endif

        or      dword ptr [ecx].FpCr0NpxState, CR0_TS   ; signal a delayed error

Kt0716: mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack

Kt0720:
;
; Some type of coprocessor exception has occured for the current thread.
;
; (eax) - CurrentThread
; (ecx) - CurrentThreads NPX save area
; (ebp) - TrapFrame
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fnsave & fwait

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;

        FXSAVE_ECX

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt07dbg2
endif
        or      ebx, NPX_STATE_NOT_LOADED
        or      ebx,[ecx]+FpCr0NpxState ; restore this threads CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

;
; According to the floating error priority, we test what is the cause of
; the NPX error and raise an appropriate exception.
;

        mov     ebx, [ecx] + FxErrorOffset
        movzx   eax, word ptr [ecx] + FxControlWord
        movzx   edx, word ptr [ecx] + FxStatusWord
        mov     esi, [ecx] + FxDataOffset ; (esi) = operand addr

        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        not     eax                        ; ax = mask of enabled exceptions
        and     eax, edx
        test    eax, FSW_INVALID_OPERATION ; Is it an invalid op exception?
        jz      short Kt0740               ; if z, no, go Kt0740
        test    eax, FSW_STACK_FAULT       ; Is it caused by stack fault?
        jnz     short Kt0730               ; if nz, yes, go Kt0730

; Raise Floating reserved operand exception
;

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0730:
;
; Raise Access Violation exception for stack overflow/underflow
;

        mov     eax, STATUS_FLOAT_STACK_CHECK
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0740:

; Check for floating zero divide exception

        test    eax, FSW_ZERO_DIVIDE    ; Is it a zero divide error?
        jz      short Kt0750            ; if z, no, go Kt0750

; Raise Floating divided by zero exception

        mov     eax, STATUS_FLOAT_DIVIDE_BY_ZERO
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0750:

; Check for denormal error

        test    eax, FSW_DENORMAL       ; Is it a denormal error?
        jz      short Kt0760            ; if z, no, go Kt0760

; Raise floating reserved operand exception

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0760:

; Check for floating overflow error

        test    eax, FSW_OVERFLOW       ; Is it an overflow error?
        jz      short Kt0770            ; if z, no, go Kt0770

; Raise floating overflow exception

        mov     eax, STATUS_FLOAT_OVERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0770:

; Check for floating underflow error

        test    eax, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt0780            ; if z, no, go Kt0780

; Raise floating underflow exception

        mov     eax, STATUS_FLOAT_UNDERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0780:

; Check for precision (IEEE inexact) error

        test    eax, FSW_PRECISION      ; Is it a precision error
        jz      short Kt07100           ; if z, no, go Kt07100

        mov     eax, STATUS_FLOAT_INEXACT_RESULT
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt07100:
        sti                             ; stop the system
        stdCall _KeBugCheck, <TRAP_CAUSE_UNKNOWN>

if DBG
Kt07110:
        cmp     byte ptr [eax].ThNpxIrql, DISPATCH_LEVEL
        je      Kt0701
        stdCall _KeBugCheck, <ATTEMPTED_FPU_USE_FROM_DPC>
endif

_KiTrap07       endp


        page ,132
        subttl "Double Fault"
;++
;
; Routine Description:
;
;    Handle double exception fault.
;
;    Normally, when the processor detects an exception while trying to
;    invoke the handler for a prior exception, the two exception can be
;    handled serially.  If, however, the processor cannot handle them
;    serially, it signals the double-fault exception instead.
;
;    If double exception is detected, no matter previous mode is USER
;    or kernel, a bugcheck will be raised and the system will be terminated.
;
; Arguments:
;
;    error code, which is always zero, is pushed on stack.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap08
_KiTrap08       proc
.FPO (0, 0, 0, 0, 0, 2)

        cli

ifdef DEVKIT
;
; If the debugger can handle a double fault now, then we do so
;
        lea     edi, PCR[PcPrcbData+PbDebugDoubleFault]
        mov     eax, [edi]
        test    eax, eax
        je      Kt0810

;
; we're only going to take one double fault at a time
;
        xor     edx, edx
        mov     [edi], edx

;
; find the old TSS
;
        mov     dx, word ptr [_KiDoubleFaultTSS]
        lea     ecx, _KiGDT
        mov     edi, [edx+ecx+2]
        push    edi
        mov     dl, [edx+ecx+7]
        mov     [esp+3], dl

;
; ask the debugger whether we can handle things
;
        call    eax
        test    al, al
        je      Kt0810

;
; we're good to go
;
        iretd
        jmp     _KiTrap08   ; in case we dbl-fault again
endif ; DEVKIT

Kt0810:
;
; Clear the busy bit in the TSS selector
;
        mov     byte ptr [_KiGDT+KGDT_DF_TSS+5],089h

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; The original machine context is in original task's TSS
;
@@:     stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP,8,0,0,0>
        jmp     short @b        ; do not remove - for debugger

_KiTrap08       endp

        page ,132
        subttl "Coprocessor Segment Overrun"
;++
;
; Routine Description:
;
;    Handle Coprocessor Segment Overrun exception.
;
;    This exception only occurs on the 80286 (it's a trap 0d on the 80386),
;    so choke if we get here.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap09
_KiTrap09       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

        sti
        mov     eax, EXCEPTION_NPX_OVERRUN ; (eax) = exception type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap09       endp

        page ,132
        subttl "Invalid TSS exception"
;++
;
; Routine Description:
;
;    Handle Invalid TSS fault.
;
;    This exception occurs if a segment exception other than the
;    not-present exception is detected when loading a selector
;    from the TSS.
;
;    If the exception is caused as a result of the kernel, device
;    drivers, or user incorrectly setting the NT bit in the flags
;    while the back-link selector in the TSS is invalid and the
;    IRET instruction being executed, in this case, this routine
;    will clear the NT bit in the trap frame and restart the iret
;    instruction.  For other causes of the fault, the user process
;    will be terminated if previous mode is user and the system
;    will stop if the exception occurs in kernel mode.  No exception
;    is raised.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
;    NT386 does not use TSS for context switching.  So, the invalid tss
;    fault should NEVER occur.  If it does, something is wrong with
;    the kernel.  We simply shutdown the system.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap0A
_KiTrap0A       proc

        ENTER_TRAP

        sti
        mov     eax, EXCEPTION_INVALID_TSS ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0A       endp

        page ,132
        subttl "Segment Not Present"
;++
;
; Routine Description:
;
;    Handle Segment Not Present fault.
;
;    This exception occurs when the processor finds the P bit 0
;    when accessing an otherwise valid descriptor that is not to
;    be loaded in SS register.
;
;    The only place the fault can occur (in kernel mode) is Trap/Exception
;    exit code.  Otherwise, this exception causes system to be terminated.
;    NT386 uses flat mode, the segment not present fault in Kernel mode
;    indicates system malfunction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
; Return value:
;
;    None
;
;--
        page ,132
        subttl "Stack segment fault"
;++
;
; Routine Description:
;
;    Handle Stack Segment fault.
;
;    This exception occurs when the processor detects certain problem
;    with the segment addressed by the SS segment register:
;
;    1. A limit violation in the segment addressed by the SS (error
;       code = 0)
;    2. A limit vioalation in the inner stack during an interlevel
;       call or interrupt (error code = selector for the inner stack)
;    3. If the descriptor to be loaded into SS has its present bit 0
;       (error code = selector for the not-present segment)
;
;    The exception should never occurs in kernel mode except when we
;    perform the iret back to user mode.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        page ,132
        subttl "General Protection Fault"
;++
;
; Routine Description:
;
;    Handle General protection fault.
;
;    First, check to see if the fault occured in kernel mode with
;    incorrect selector values.  If so, this is a lazy segment load.
;    Correct the selector values and restart the instruction.  Otherwise,
;    parse out various kinds of faults and report as exceptions.
;
;    All protection violations that do not cause another exception
;    cause a general exception.  If the exception indicates a violation
;    of the protection model by an application program executing a
;    previleged instruction or I/O reference, a PRIVILEGED INSTRUCTION
;    exception will be raised.  All other causes of general protection
;    fault cause a ACCESS VIOLATION exception to be raised.
;
;    If previous mode = Kernel;
;        the system will be terminated  (assuming not lazy segment load)
;    Else previous mode = USER
;        the process will be terminated if the exception was not caused
;        by privileged instruction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap0B
_KiTrap0B       proc
_KiTrap0C       label byte
_KiTrap0D       label byte

; Set up machine state frame for displaying

        ENTER_TRAP

        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, [ebp]+TsErrCode
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

_KiTrap0B       endp

        page ,132
        subttl "Page fault processing"
;++
;
; Routine Description:
;
;    Handle page fault.
;
;    The page fault occurs if paging is enabled and any one of the
;    conditions is true:
;
;    1. page not present
;    2. the faulting procedure does not have sufficient privilege to
;       access the indicated page.
;
;    For case 1, the referenced page will be loaded to memory and
;    execution continues.
;    For case 2, registered exception handler will be invoked with
;    appropriate error code (in most cases STATUS_ACCESS_VIOLATION)
;
;    N.B. It is assumed that no page fault is allowed during task
;    switches.
;
;    N.B. INTERRUPTS MUST REMAIN OFF UNTIL AFTER CR2 IS CAPTURED.
;
; Arguments:
;
;    Error code left on stack.
;    CR2 contains faulting address.
;    Interrupts are turned off at entry by use of an interrupt gate.
;
; Return value:
;
;    None
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap0E
_KiTrap0E       proc

        ENTER_TRAP

        mov     edi,cr2
        sti

        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jz      Kt0e12b                 ; interrupts disabled?
Kt0e01:

;
; call _MmAccessFault to page in the not present page.  If the cause
; of the fault is 2, _MmAccessFault will return approriate error code
;

        sub     esp, 12
        mov     [esp+8], ebp            ; pass in the trap frame base
        mov     [esp+4], edi
        mov     eax, [ebp]+TsErrCode    ; (eax)= error code
        and     eax, ERR_0E_STORE       ; (eax)= 0 if fault caused by read
                                        ;      = 2 if fault caused by write
        shr     eax, 1                  ; (eax) = 0 if read fault, 1 if write fault
        mov     [esp+0], eax            ; arg3: load/store indicator

        call    _MmAccessFault@12

        or      eax, eax                ; sucessful?
        jge     Kt0e10                  ; yes, go exit

;
; Check to determine if the fault occured in the interlocked pop entry slist
; code. There is a case where a fault may occur in this code when the right
; set of circumstances occurs. The fault can be ignored by simply skipping
; the faulting instruction.
;

Kt0e05: mov     ecx, offset FLAT:ExpInterlockedPopEntrySListFault ; get pop code address
        cmp     [ebp].TsEip, ecx        ; check if fault at pop code address
        je      Kt0e10a                 ; if eq, skip faulting instruction

        mov     ecx, [ebp]+TsErrCode    ; (ecx) = error code
        and     ecx, ERR_0E_STORE       ; (ecx) = 0 if fault caused by read
                                        ;         2 if fault caused by write
        shr     ecx,1                   ; (ecx) = load/store indicator

;
; Set up exception record and arguments and call _KiDispatchException
;

        mov     esi, [ebp]+TsEip        ; (esi)-> faulting instruction

        cmp     eax, STATUS_ACCESS_VIOLATION ; dispatch access violation or
        je      short Kt0e9b                 ; or in_page_error?

        cmp     eax, STATUS_GUARD_PAGE_VIOLATION
        je      short Kt0e9b

        cmp     eax, STATUS_STACK_OVERFLOW
        je      short Kt0e9b

;
; test to see if davec's reserved status code bit is set. If so, then bugchecka
;

        cmp     eax, STATUS_IN_PAGE_ERROR or 10000000h
        je      Kt0e12                  ; bugchecka

;
; (ecx) = ExceptionInfo 1
; (edi) = ExceptionInfo 2
; (eax) = ExceptionInfo 3
; (esi) -> Exception Addr
;

        mov     edx, ecx
        mov     ebx, esi
        mov     esi, edi
        mov     ecx, 3
        mov     edi, eax
        mov     eax, STATUS_IN_PAGE_ERROR
        call    CommonDispatchException ; Won't return

Kt0e9b:
        mov     ebx, esi
        mov     edx, ecx
        mov     esi, edi
        jmp     CommonDispatchException2Args ; Won't return

.FPO ( 0, 0, 0, 0, 0, FPO_TRAPFRAME )

;
; The fault occured in the interlocked pop slist function and the faulting
; instruction should be skipped.
;

Kt0e10a:mov     ecx, offset FLAT:ExpInterlockedPopEntrySListResume ; get resume address
        mov     [ebp].TsEip, ecx        ; set continuation address

Kt0e10:

ifdef DEVKIT
        mov     esp,ebp                 ; (esp) -> trap frame
        test    _KdpOweBreakpoint, 1    ; do we have any owed breakpoints?
        jz      _KiExceptionExit        ; No, all done

        stdCall _KdSetOwedBreakpoints   ; notify the debugger
endif

Kt0e11: mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code

Kt0e12:
        stdCall _KeGetCurrentIrql       ; (eax) = OldIrql
Kt0e12a:
   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

;
; bugcheck a, addr, irql, load/store, pc
;
        mov     ecx, [ebp]+TsErrCode    ; (ecx)= error code
        and     ecx, ERR_0E_STORE       ; (ecx)= 0 if fault caused by read
        shr     ecx, 1                  ; (ecx) = 0 if read fault, 1 if write fault

        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction

        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,edi,eax,ecx,esi>

Kt0e12b:
        cmp     _KiBugCheckData, 0      ; If crashed, handle trap in
        jnz     Kt0e01                  ; normal manner


        mov     eax, 0ffh               ; OldIrql = -1
        jmp     short Kt0e12a

_KiTrap0E       endp

        page ,132
        subttl "Trap0F -- Intel Reserved"
;++
;
; Routine Description:
;
;    The trap 0F should never occur.  If, however, the exception occurs in
;    USER mode, the current process will be terminated.  If the exception
;    occurs in KERNEL mode, a bugcheck will be raised.  NO registered
;    handler, if any, will be inviked to handle the exception.
;
; Arguments:
;
;    None
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap0F
_KiTrap0F       proc

        push    0                       ; push dummy error code
        ENTER_TRAP
        sti

        mov     eax, EXCEPTION_RESERVED_TRAP ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0F       endp


        page ,132
        subttl "Coprocessor Error"

;++
;
; Routine Description:
;
;    Handle Coprocessor Error.
;
;    This exception is used on 486 or above only.  For i386, it uses
;    IRQ 13 instead.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap10
_KiTrap10       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

        mov     eax, PCR[PcPrcbData+PbNpxThread]  ; Correct context for fault?
        cmp     eax, PCR[PcPrcbData+PbCurrentThread]
        je      Kt0710                  ; Yes - go try to dispatch it

;
; We are in the wrong NPX context and can not dispatch the exception right now.
; Set up the target thread for a delay exception.
;
; Note: we don't think this is a possible case, but just to be safe...
;
        mov     eax, [eax].ThStackBase
        sub     eax, NPX_FRAME_LENGTH   ; Space for NPX_FRAME
        or      dword ptr [eax].FpCr0NpxState, CR0_TS   ; Set for delayed error

        jmp     _KiExceptionExit

_KiTrap10       endp

        page ,132
        subttl "Alignment fault"
;++
;
; Routine Description:
;
;    Handle alignment faults.
;
;    This exception occurs when an unaligned data access is made by a thread
;    with alignment checking turned on.
;
;    This exception will only occur on 486 machines.  The 386 will not do
;    any alignment checking.  Only threads which have the appropriate bit
;    set in EFLAGS will generate alignment faults.
;
;    The exception will never occur in kernel mode.  (hardware limitation)
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    Error code is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap11
_KiTrap11       proc

        ENTER_TRAP
        sti

;
; We should never be here, since the 486 will not generate alignment faults
; in kernel mode.
;
        mov     eax, EXCEPTION_ALIGNMENT_CHECK      ; (eax) = trap type
        jmp     _KiSystemFatalException

_KiTrap11       endp

;++
;
; Routine Description:
;
;    Handle XMMI Exception.
;;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap13
_KiTrap13       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

        mov     eax, PCR[PcPrcbData+PbNpxThread]  ; Correct context for fault?
        cmp     eax, PCR[PcPrcbData+PbCurrentThread]
        je      Kt13_10                 ; Yes - go try to dispatch it

;
;       Katmai New Instruction exceptions are precise and occur immediately.
;       if we are in the wrong NPX context, bugcheck the system.
;
        ; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,eax,0,0>

Kt13_10:
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack

;
;       TrapFrame is built by ENTER_TRAP.
;       XMMI are accessible from all IA execution modes:
;       Protected Mode, Real address mode, Virtual 8086 mode
;
Kt13_15:
;
; We are about to dispatch a XMMI floating point exception to user mode.
;
; (ebp) - Trap frame
; (ecx) - CurrentThreads NPX save area (PCR[PcStackBase])
; (eax) - CurrentThread

; Dispatch
Kt13_20:
;
; Some type of coprocessor exception has occured for the current thread.
;
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fxsave

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;
        FXSAVE_ECX

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt13_dbg2
endif

        or      ebx, NPX_STATE_NOT_LOADED ; CR0_TS | CR0_MP
        or      ebx,[ecx]+FpCr0NpxState ; restore this threads CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

; (eax) = ExcepCode - Exception code to put into exception record
; (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
; (ecx) = NumParms - Number of additional parameters
; (edx) = Parameter1
; (esi) = Parameter2
; (edi) = Parameter3
        mov     ebx, [ebp].TsEip          ; Eip is from trap frame, not from FxErrorOffset
        movzx   eax, word ptr [ecx] + FxMXCsr
        mov     edx, eax
        shr     edx, 7                    ; get the mask
        not     edx
        mov     esi, 0                    ; (esi) = operand addr, addr is computed from
                                          ; trap frame, not from FxDataOffset
;
;       Exception will be handled in user's handler if there is one declared.
;
        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        and     eax, edx
        test    eax, FSW_INVALID_OPERATION ; Is it an invalid op exception?
        jz      short Kt13_40              ; if z, no, go Kt13_40
;
; Invalid Operation Exception - Invalid arithmetic operand
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_40:
; Check for floating zero divide exception
;
        test    eax, FSW_ZERO_DIVIDE    ; Is it a zero divide error?
        jz      short Kt13_50           ; if z, no, go Kt13_50
;
; Division-By-Zero Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_50:
; Check for denormal error
;
        test    eax, FSW_DENORMAL       ; Is it a denormal error?
        jz      short Kt13_60           ; if z, no, go Kt13_60
;
; Denormal Operand Excpetion
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_60:
; Check for floating overflow error
;
        test    eax, FSW_OVERFLOW       ; Is it an overflow error?
        jz      short Kt13_70           ; if z, no, go Kt13_70
;
; Numeric Overflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_70:
; Check for floating underflow error
;
        test    eax, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt13_80           ; if z, no, go Kt13_80
;
; Numeric Underflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_80:
; Check for precision (IEEE inexact) error
;
        test    eax, FSW_PRECISION      ; Is it a precision error
        jz      short Kt13_100          ; if z, no, go Kt13_100
;
; Inexact-Result (Precision) Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

; Huh?
Kt13_100:
; If status word does not indicate error, then something is wrong...
; (Note: that we have done a sti, before the status is examined)
        sti
; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,eax,0,1>

if DBG
Kt13_dbg1:    int 3
Kt13_dbg2:    int 3
Kt13_dbg3:    int 3
        sti
        jmp short $-2
endif

_KiTrap13       endp

;++
;
; VOID
; KiFlushNPXState (
;     VOID
;     )
;
; Routine Description:
;
;   When a threads NPX context is requested (most likely by a debugger)
;   this function is called to flush the threads NPX context out of the
;   compressor if required.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
align dword

cPublicProc _KiFlushNPXState    ,0
cPublicFpo 1, 1

        pushfd
        cli                             ; don't context switch

        mov     edx, PCR[PcPrcbData+PbCurrentThread]

        cmp     byte ptr [edx].ThNpxState, NPX_STATE_LOADED
        jne     short fnpx70

fnpx20:
    ;
    ; Current thread has NPX state in the coprocessor, flush it
    ;
        mov     eax, cr0
        test    eax, CR0_MP+CR0_TS+CR0_EM
        jz      short fnpx30
        and     eax, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax                ; allow frstor (& fnsave) to work
fnpx30:
        mov     ecx, PCR[PcStackBase]   ; (ecx) -> top of kernel stack
        FXSAVE_ECX

        mov     byte ptr [edx].ThNpxState, NPX_STATE_NOT_LOADED
        mov     PCR[PcPrcbData+PbNpxThread], 0      ; clear npx owner

        or      eax, NPX_STATE_NOT_LOADED           ; or in new threads cr0
        or      eax, [ecx].FpCr0NpxState            ; merge new thread setable state
        mov     cr0, eax

fnpx70:
        popfd                           ; enable interrupts
        stdRET    _KiFlushNPXState

stdENDP _KiFlushNPXState

;++
;
; VOID
; KiSetHardwareTrigger (
;     VOID
;     )
;
; Routine Description:
;
;   This function sets KiHardwareTrigger such that an analyzer can sniff
;   for this access.   It needs to occur with a lock cycle such that
;   the processor won't speculatively read this value.   Interlocked
;   functions can't be used as in a UP build they do not use a
;   lock prefix.
;
; Arguments:
;
;    None
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
cPublicProc _KiSetHardwareTrigger,0
   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer
        stdRet  _KiSetHardwareTrigger
stdENDP _KiSetHardwareTrigger


        page ,132
        subttl "Processing System Fatal Exceptions"
;++
;
; Routine Description:
;
;    This routine processes the system fatal exceptions.
;    The machine state and trap type will be displayed and
;    System will be stopped.
;
; Arguments:
;
;    (eax) = Trap type
;    (ebp) -> machine state frame
;
; Return value:
;
;    system stopped.
;
;--
        assume  ds:nothing, es:nothing, ss:nothing, fs:nothing, gs:nothing

align dword
        public  _KiSystemFatalException
_KiSystemFatalException proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP, eax, 0, 0, 0>
        ret

_KiSystemFatalException endp

        page
        subttl  "Continue Execution System Service"
;++
;
; NTSTATUS
; NtContinue (
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN TestAlert
;    )
;
; Routine Description:
;
;    This routine is called as a system service to continue execution after
;    an exception has occurred. Its function is to transfer information from
;    the specified context record into the trap frame that was built when the
;    system service was executed, and then exit the system as if an exception
;    had occurred.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwContinue!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
; Arguments:
;
;    KTrapFrame (ebp+0: after setup) -> base of KTrapFrame
;
;    ContextRecord (ebp+8: after setup) = Supplies a pointer to a context rec.
;
;    TestAlert (esp+12: after setup) = Supplies a boolean value that specifies
;       whether alert should be tested for the previous processor mode.
;
; Return Value:
;
;    Normally there is no return from this routine. However, if the specified
;    context record is misaligned or is not accessible, then the appropriate
;    status code is returned.
;
;--

NcTrapFrame             equ     [ebp + 0]
NcContextRecord         equ     [ebp + 8]
NcTestAlert             equ     [ebp + 12]

align dword
cPublicProc _NtContinue     ,2

        push    ebp

;
; Call KiContinue to load ContextRecord into TrapFrame.  On x86 TrapFrame
; is an atomic entity, so we don't need to allocate any other space here.
;
; KiContinue(NcContextRecord, 0, NcTrapFrame)
;

        mov     ebp,esp
        mov     eax, NcTrapFrame
        mov     ecx, NcContextRecord
        stdCall  _KiContinue, <ecx, 0, eax>
        or      eax,eax                 ; return value 0?
        jnz     short Nc20              ; KiContinue failed, go report error

;
; Check to determine if alert should be tested for the previous processor mode.
;

        cmp     byte ptr NcTestAlert,0  ; Check test alert flag
        je      short Nc10              ; if z, don't test alert, go Nc10
        stdCall _KeTestAlertThread, <0>  test alert for current thread

Nc10:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit2         ; common exit

Nc20:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit          ; common exit

stdENDP _NtContinue

align dword
cPublicProc _ZwContinue     ,2

;
; Must go through an interrupt trap in order to build the trap frame that
; NtContinue requires.
;
        mov     eax, [esp+4]            ; (eax) -> ContextRecord
        mov     ecx, [esp+8]            ; (ecx) -> TestAlert
        int     28h
        stdRet  _ZwContinue

stdENDP _ZwContinue

        page
        subttl  "Raise Exception System Service"
;++
;
; NTSTATUS
; NtRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN FirstChance
;    )
;
; Routine Description:
;
;    This routine is called as a system service to raise an exception. Its
;    function is to transfer information from the specified context record
;    into the trap frame that was built when the system service was executed.
;    The exception may be raised as a first or second chance exception.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwRaiseException!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
;   NOTE - KiSystemService will terminate the ExceptionList, which is
;          not what we want for this case, so we will fish it out of
;          the trap frame and restore it.
;
; Arguments:
;
;    TrapFrame (ebp+0: before setup) -> System trap frame for this call
;
;    ExceptionRecord (ebp+8: after setup) -> An exception record.
;
;    ContextRecord (ebp+12: after setup) -> Points to a context record.
;
;    FirstChance (epb+16: after setup) -> Supplies a boolean value that
;       specifies whether the exception is to be raised as a first (TRUE)
;       or second chance (FALSE) exception.
;
; Return Value:
;
;    None.
;--
align dword
cPublicProc _NtRaiseException ,3

        push    ebp

;
;   Put back the ExceptionList so the exception can be properly
;   dispatched.
;

        mov     ebp,esp                 ; [ebp+0] -> TrapFrame
        mov     ebx, [ebp+0]            ; (ebx)->TrapFrame
        mov     edx, [ebp+16]           ; (edx) = First chance indicator
        mov     eax, [ebx]+TsExceptionList ; Old exception list
        mov     ecx, [ebp+12]           ; (ecx)->ContextRecord
        mov     PCR[PcExceptionList],eax
        mov     eax, [ebp+8]            ; (eax)->ExceptionRecord

;
;   KiRaiseException(ExceptionRecord, ContextRecord, ExceptionFrame,
;           TrapFrame, FirstChance)
;

        stdCall   _KiRaiseException,<eax, ecx, 0, ebx, edx>

        pop     ebp
        mov     esp,ebp                 ; (esp) = (ebp) -> trap frame

;
;   If the exception was handled, then the trap frame has been edited to
;   reflect new state, and we'll simply exit the system service to get
;   the effect of a continue.
;
;   If the exception was not handled, we'll return to our caller, who
;   will raise a new exception.
;
        jmp     _KiServiceExit2

stdENDP _NtRaiseException

align dword
cPublicProc _ZwRaiseException     ,3

;
; Must go through an interrupt trap in order to build the trap frame that
; NtRaiseException requires.
;
        mov     eax, [esp+4]            ; (eax) -> ExceptionRecord
        mov     ecx, [esp+8]            ; (ecx) -> ContextRecord
        mov     edx, [esp+12]           ; (edx) -> FirstChance
        int     29h
        stdRet  _ZwRaiseException

stdENDP _ZwRaiseException

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ldrx\ldrx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ldrx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the Xbox executable image loader.

--*/

#ifndef _LDRX_
#define _LDRX_

#include <ntos.h>
#include <ani.h>
#include <ldr.h>
#include <dm.h>
#include <ntddcdvd.h>
#include <xbeimage.h>
#include <smcdef.h>
#include <limits.h>
#include <wtypes.h>
#include <xbox.h>
#include <xboxp.h>
#include <xconfig.h>
#include <xlaunch.h>
#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define LdrxDbgPrint(x)                         DbgPrint x
#define LdrxDbgBreakPoint()                     DbgBreakPoint()
#else
#define LdrxDbgPrint(x)
#define LdrxDbgBreakPoint()
#endif

//
// Bit flag macros.
//

#define LdrxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define LdrxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Define the title identifier of the dashboard.
//

#define LDR_DASHBOARD_TITLE_ID                  0xFFFE0000

//
// External symbols.
//

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

NTSTATUS
DebugService(
    ULONG ServiceClass,
    PVOID Arg1,
    PVOID Arg2
    );

DECLSPEC_NORETURN
VOID
IdexDiskFatalError(
    IN ULONG ErrorCode
    );

extern PDEVICE_OBJECT IdexCdRomDeviceObject;
extern BOOLEAN IdexCdRomDVDX2Authenticated;
extern BOOLEAN IdexDiskSecurityUnlocked;

#include <poppack.h>

#endif  // LDRX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ldrx\sources.inc ===
!IF 0

Copyright (c) 1989-2001  Microsoft Corporation

!ENDIF

MAJORCOMP=ntos
MINORCOMP=ldrx

TARGETPATH=$(BASEDIR)\private\ntos\obj
TARGETTYPE=LIBRARY

INCLUDES=$(BASEDIR)\private\ntos\inc

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

!IF DEFINED(INTERIMPUBKEY)
C_DEFINES=$(C_DEFINES) -DINTERIMPUBKEY=1
!ENDIF

SOURCES=..\loader.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\up\makefile.inc ===
#
# "nmake genxx" will generate platform-dependent include files
#

!if "$(TARGET_DIRECTORY)"=="alpha" || "$(TARGET_DIRECTORY)"=="axp64"
KS_NAME=ksp$(TARGET_DIRECTORY)
HAL_NAME=halp$(TARGET_DIRECTORY)

!else if "$(TARGET_DIRECTORY)"=="i386"
HAL_NAME=hal386
KS_NAME=ks386

!else
HAL_NAME=hal$(TARGET_DIRECTORY)
KS_NAME=ks$(TARGET_DIRECTORY)
!endif

KS_TARGET =$(_NTROOT)\public\sdk\inc\$(KS_NAME).$(ASM_INCLUDE_SUFFIX)
HAL_TARGET=$(_NTROOT)\private\ntos\inc\$(HAL_NAME).$(ASM_INCLUDE_SUFFIX)

genxx: $(KS_TARGET) $(HAL_TARGET)

#
# If the following invocation of genxx fails, make sure you have a
# current version of genxx.
#

$(KS_TARGET) $(HAL_TARGET): \
!if $(AXP64)
        ..\alpha\genalpha.m4 \
!endif	
	..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).m4 \
        ..\genxx.h \
        ..\genxx.inc \
        $(_NTROOT)\public\ddk\inc\ntddk.h
    set PASS0ONLY=
    if not exist obj\$(TARGET_DIRECTORY) mkdir obj\$(TARGET_DIRECTORY)
    -erase obj\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).obj
    -erase ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).c
    m4 < ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).m4 \
       > ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).c
    nmake -l obj\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).obj NTNOPCH=1
    genxx -$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ke\i386\trapc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module contains some trap handling code written in C.
    Only by the kernel.

Author:

    Ken Reneris     6-9-93

Revision History:

--*/

#include    "ki.h"

#define REG(field)          ((ULONG)(&((KTRAP_FRAME *)0)->field))
#define GETREG(frame,reg)   ((PULONG) (((ULONG) frame)+reg))[0]

typedef struct {
    UCHAR   RmDisplaceOnly;     // RM of displacment only, no base reg
    UCHAR   RmSib;              // RM of SIB
    UCHAR   RmDisplace;         // bit mask of RMs which have a displacement
    UCHAR   Disp;               // sizeof displacement (in bytes)
} KMOD, *PKMOD;

static UCHAR RM32[] = {
    /* 000 */   REG(Eax),
    /* 001 */   REG(Ecx),
    /* 010 */   REG(Edx),
    /* 011 */   REG(Ebx),
    /* 100 */   REG(HardwareEsp),
    /* 101 */   REG(Ebp),       // SIB
    /* 110 */   REG(Esi),
    /* 111 */   REG(Edi)
};

static UCHAR RM8[] = {
    /* 000 */   REG(Eax),       // al
    /* 001 */   REG(Ecx),       // cl
    /* 010 */   REG(Edx),       // dl
    /* 011 */   REG(Ebx),       // bl
    /* 100 */   REG(Eax) + 1,   // ah
    /* 101 */   REG(Ecx) + 1,   // ch
    /* 110 */   REG(Edx) + 1,   // dh
    /* 111 */   REG(Ebx) + 1    // bh
};

static KMOD MOD32[] = {
    /* 00 */     5,     4,   0x20,   4,
    /* 01 */  0xff,     4,   0xff,   1,
    /* 10 */  0xff,     4,   0xff,   4,
    /* 11 */  0xff,  0xff,   0x00,   0
} ;

NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    TrapFrame
    )
/*++

Routine Description:

    This function gains control when the x86 processor generates a
    divide by zero trap.  The x86 design generates such a trap on
    divide by zero and on division overflows.  In order to determine
    which expection code to dispatch, the divisor of the "div" or "idiv"
    instruction needs to be inspected.

Arguments:

    TrapFrame - Trap frame of the divide by zero trap

Return Value:

    exception code dispatch

--*/
{
    ULONG       operandsize, operandmask, i, accum;
    PUCHAR      istream, pRM;
    UCHAR       ibyte, rm;
    PKMOD       Mod;
    BOOLEAN     fPrefix;
    NTSTATUS    status;

    status = STATUS_INTEGER_DIVIDE_BY_ZERO;

    try {

        //
        // read instruction prefixes
        //

        fPrefix = TRUE;
        pRM = RM32;
        operandsize = 4;
        operandmask = 0xffffffff;
        istream = (PUCHAR) TrapFrame->Eip;
        while (fPrefix) {
            ibyte = *istream++;
            switch (ibyte) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                case 0xF3:  // rep
                case 0xF2:  // rep
                case 0xF0:  // lock
                    break;

                case 0x66:
                    // 16 bit operand override
                    operandsize = 2;
                    operandmask = 0xffff;
                    break;

                case 0x67:
                    // 16 bit address size override
                    // this is some non-flat code
                    goto try_exit;

                default:
                    fPrefix = FALSE;
                    break;
            }
        }

        //
        // Check instruction opcode
        //

        if (ibyte != 0xf7  &&  ibyte != 0xf6) {
            // this is not a DIV or IDIV opcode
            goto try_exit;
        }

        if (ibyte == 0xf6) {
            // this is a byte div or idiv
            operandsize = 1;
            operandmask = 0xff;
        }

        //
        // Get Mod R/M
        //

        ibyte = *istream++;
        Mod = MOD32 + (ibyte >> 6);
        rm  = (UCHAR)(ibyte & 7);

        //
        // put register values into accum
        //

        if (operandsize == 1  &&  (ibyte & 0xc0) == 0xc0) {
            pRM = RM8;
        }

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte = *istream++;
                i = (ibyte >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(TrapFrame, RM32[i]);
                    accum = accum << (ibyte >> 6);    // apply scaler
                }
                i = ibyte & 7;
                accum = accum + GETREG(TrapFrame, RM32[i]);
            } else {
                // get register's value
                accum = GETREG(TrapFrame, pRM[rm]);
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = *((PULONG) istream);
            } else {
                ibyte = *istream;
                i = (signed long) ((signed char) ibyte);    // sign extend
            }
            accum += i;
        }

        //
        // if this is an effective address, go get the data value
        //

        if (Mod->Disp) {
            switch (operandsize) {
                case 1:  accum = *((PUCHAR) accum);    break;
                case 2:  accum = *((PUSHORT) accum);  break;
                case 4:  accum = *((PULONG) accum);    break;
            }
        }

        //
        // accum now contains the instruction operand, see if the
        // operand was really a zero
        //

        if (accum & operandmask) {
            // operand was non-zero, must be an overflow
            status = STATUS_INTEGER_OVERFLOW;
        }

try_exit: ;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing...
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ldrx\loader.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    loader.c

Abstract:

    This module implements the Xbox executable image loader.

--*/

#include "ldrx.h"

//
// Verify that the definitions in the xbeimage.h match those found in xconfig.h.
//
C_ASSERT(XBEIMAGE_GAME_REGION_NA == XC_GAME_REGION_NA);
C_ASSERT(XBEIMAGE_GAME_REGION_JAPAN == XC_GAME_REGION_JAPAN);
C_ASSERT(XBEIMAGE_GAME_REGION_RESTOFWORLD == XC_GAME_REGION_RESTOFWORLD);
C_ASSERT(XBEIMAGE_GAME_REGION_MANUFACTURING == XC_GAME_REGION_MANUFACTURING);

//
// Contains the public key data to verify the encrypted header digest of an Xbox
// executable image.
//
#ifdef INTERIMPUBKEY
DECLSPEC_RDATA UCHAR XePublicKeyData[XC_PUBLIC_KEYDATA_SIZE] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0xE5,0xEC,0x86,0x9B,
    0x50,0x89,0x3B,0xB3,0xEB,0x41,0x30,0x8A,
    0x13,0x6E,0xAD,0xE9,0x7D,0xCA,0x9B,0xB4,
    0xF1,0x89,0x58,0xCE,0xAE,0xE1,0x9A,0x66,
    0xE9,0x1C,0x3C,0x04,0x39,0x2E,0xF7,0xA1,
    0x13,0xE8,0xFB,0x66,0x1C,0x59,0xC1,0xCE,
    0x18,0x7C,0x71,0xB8,0x5D,0x25,0xBB,0x5F,
    0x21,0x30,0x59,0xF7,0xDC,0x3B,0x24,0x13,
    0x42,0x69,0x30,0xF6,0x88,0x3D,0x99,0x89,
    0xCC,0xEB,0xFB,0x16,0x7C,0x78,0xEB,0x05,
    0x6B,0x41,0x8F,0xE0,0xB3,0x55,0x5F,0xEB,
    0x74,0xCA,0xB4,0x31,0x04,0xA2,0xB2,0x5A,
    0xF0,0x03,0x8E,0xDC,0x27,0x1A,0x61,0xF8,
    0x90,0x45,0xFE,0x20,0xD4,0x29,0x1C,0x58,
    0xAF,0xE9,0xFD,0x77,0x37,0x90,0xEC,0xBD,
    0x19,0xD0,0x8F,0x06,0x56,0x3C,0x95,0xC8,
    0xA0,0xA9,0x5A,0x07,0x62,0x4E,0xE8,0x35,
    0xCB,0xCF,0xA5,0xAE,0x27,0x94,0xE5,0x1C,
    0x4F,0xA6,0x18,0x5E,0xD3,0x5C,0xE9,0x06,
    0x24,0x93,0x57,0x38,0x91,0xC7,0x98,0x17,
    0x81,0x3B,0xD3,0x39,0xC7,0xD6,0xEC,0x6D,
    0xFC,0xB1,0xE1,0x52,0xAB,0x82,0x90,0x40,
    0x7B,0xC9,0x1D,0xD4,0x45,0x87,0xAC,0x94,
    0xD6,0x9D,0xB1,0x40,0xB3,0x19,0xE5,0xAD,
    0x18,0xF2,0xB8,0x9C,0xB0,0x54,0xE5,0x07,
    0x4C,0x74,0x4C,0xBD,0x9F,0xCC,0xDF,0xEC,
    0x7C,0xFF,0xAD,0x19,0x2A,0x44,0x03,0xD4,
    0xAA,0xA2,0x79,0x23,0xF9,0x1A,0xDD,0x46,
    0x05,0xF1,0x11,0xB0,0x89,0xC0,0xEB,0xBC,
    0xD7,0x3D,0x94,0xFC,0x04,0x9E,0x67,0x01,
    0x4C,0x10,0x00,0x70,0x2A,0x3F,0x5A,0xD0,
    0x68,0xCF,0xC7,0x59,0xA9,0x01,0x7B,0x07,
    0x34,0x26,0x54,0xA6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};
#else
DECLSPEC_RDATA UCHAR XePublicKeyData[XC_PUBLIC_KEYDATA_SIZE] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};
#endif

//
// Stores the name of the image file.
//
OBJECT_STRING XeImageFileName;

//
// Guards multiple threads attempting to load or unload image sections.
//
INITIALIZED_CRITICAL_SECTION(XepLoaderLock);

//
// Name of the default Xbox executable to load from the CD-ROM device.
//
const OCHAR XepDefaultImagePath[] = OTEXT("\\Device\\CdRom0\\default.xbe");

//
// Name of the default dashboard Xbox executable to load from the disk device.
//
const OCHAR XepDashboardImagePath[] = OTEXT("\\Device\\Harddisk0\\Partition2\\xboxdash.xbe");

//
// Name of the DOS device symbolic link for the CD-ROM device.
//
INITIALIZED_OBJECT_STRING_RDATA(XepCdRomDosDevice, "\\??\\D:");

#ifdef DEVKIT
//
// Static loader data table entry for the Xbox executable image.
//
LDR_DATA_TABLE_ENTRY XepDataTableEntry;

//
// Indicates whether or not section load and unload debugger notifications
// should be sent.
//
BOOLEAN XepSendSectionDebugNotifications;

//
// Name of the dashboard direction file used to specify an alternate dashboard.
//
INITIALIZED_OBJECT_STRING_RDATA(XepDashboardRedirectionPath, "\\Device\\Harddisk0\\Partition1\\dashboard.xbx");
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, XeLoadImageAfterTrayEjectBoot)
#endif

//
// Stores the title identifier for the media located in the CD-ROM device.  The
// loader only allows a single title identifier to be launched from a single
// media.
//
DECLSPEC_STICKY ULONG XeCdRomMediaTitleID;

NTSTATUS
XepOpenImageFile(
    OUT PHANDLE ImageFileHandle
    )
/*++

Routine Description:

    This routine opens the image file with the appropriate options.

Arguments:

    ImageFileHandle - Specifies the buffer to receive the handle to the image
        file.

Return Value:

    Status of operation.

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    InitializeObjectAttributes(&ObjectAttributes, &XeImageFileName,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    return NtOpenFile(ImageFileHandle, GENERIC_READ, &ObjectAttributes,
        &IoStatusBlock, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT |
        FILE_NON_DIRECTORY_FILE);
}

NTSTATUS
XepReadImageFile(
    IN HANDLE ImageFileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG ByteOffset
    )
/*++

Routine Description:

    This routine reads the requested number of bytes from the file to the
    supplied buffer from the starting file byte offset.

Arguments:

    ImageFileHandle - Specifies the handle to the image file.

    Buffer - Specifies the address of the buffer to receive the image file data.

    Length - Specifies the number of bytes to transfer to the buffer.

    ByteOffset - Specifies the byte offset within the file to begin the read
        operation.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    LARGE_INTEGER ByteOffsetLarge;
    IO_STATUS_BLOCK IoStatusBlock;

    ByteOffsetLarge.QuadPart = ByteOffset;

    status = NtReadFile(ImageFileHandle, NULL, NULL, NULL, &IoStatusBlock,
        Buffer, Length, &ByteOffsetLarge);

    if (NT_SUCCESS(status)) {

        if (IoStatusBlock.Information != Length) {
            status = STATUS_FILE_CORRUPT_ERROR;
        }
    }

    return status;
}

NTSTATUS
XepCommitSectionPages(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine commits the pages assigned to the supplied section.

Arguments:

    Section - Specifies the section to commit pages for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID BaseAddress;
    SIZE_T RegionSize;

    //
    // Commit the pages for the section.  Note that NtAllocateVirtualMemory is
    // serving double duty if the pages are already committed: the pages may be
    // marked as PAGE_EXECUTE_READ, but we need to change them to
    // PAGE_EXECUTE_READWRITE in order to transfer data to the page.
    //

    BaseAddress = (PVOID)Section->VirtualAddress;
    RegionSize = Section->VirtualSize;

    status = NtAllocateVirtualMemory(&BaseAddress, 0, &RegionSize,
        MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to commit memory for section %s (size=%08x).\n",
            Section->SectionName, Section->VirtualSize));
        return status;
    }

    //
    // Increment the shared page reference counts.
    //

    (*Section->HeadSharedPageReferenceCount)++;
    (*Section->TailSharedPageReferenceCount)++;

    return STATUS_SUCCESS;
}

VOID
XepMarkSectionPagesReadOnly(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine changes the protection of a section's page to be read-only.

Arguments:

    Section - Specifies the section to change the protection for.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PVOID BaseAddress;
    PVOID EndingAddress;
    SIZE_T RegionSize;
    ULONG OldProtect;

    ASSERT(Section->SectionReferenceCount > 0);
    ASSERT(LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_WRITEABLE));

    //
    // Compute the pointers to the first and last byte, exclusive, of the
    // section.
    //

    BaseAddress = (PVOID)Section->VirtualAddress;
    EndingAddress = (PVOID)(Section->VirtualAddress + Section->VirtualSize);

    //
    // If the tail page of the section can't be marked as read-only, then align
    // the pointer down to the nearest page boundary so that we don't change the
    // protection of this page.
    //

    if (LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_TAIL_PAGE_READONLY)) {
        EndingAddress = PAGE_ALIGN(EndingAddress);
    }

    //
    // If the head page of the section can't be marked as read-only, then align
    // the pointer up to the next page boundary so that we don't change the
    // protection of this page.
    //

    if (LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_HEAD_PAGE_READONLY)) {
        BaseAddress = PAGE_ALIGN((PUCHAR)BaseAddress + PAGE_SIZE);
    }

    //
    // If the ending address is still beyond the base address, then there's at
    // least one page that can be marked as read-only.  Note that
    // NtProtectVirtualMemory can handle the base address not being page aligned
    // and the region size not being an integral number of pages.
    //

    if (EndingAddress > BaseAddress) {

        RegionSize = (ULONG)EndingAddress - (ULONG)BaseAddress;

        status = NtProtectVirtualMemory(&BaseAddress, &RegionSize,
            PAGE_EXECUTE_READ, &OldProtect);

        ASSERT(NT_SUCCESS(status));
    }
}

VOID
XepDecommitSectionPages(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine decommits the pages assigned to the supplied section.

Arguments:

    Section - Specifies the section to decommit pages for.

Return Value:

    None.

--*/
{
    PVOID BaseAddress;
    PVOID EndingAddress;
    SIZE_T RegionSize;

    ASSERT(*Section->HeadSharedPageReferenceCount > 0);
    ASSERT(*Section->TailSharedPageReferenceCount > 0);

    //
    // Compute the pointers to the first and last byte, exclusive, of the
    // section.
    //

    BaseAddress = (PVOID)Section->VirtualAddress;
    EndingAddress = (PVOID)(Section->VirtualAddress + Section->VirtualSize);

    //
    // Decrement the shared page reference counts.
    //

    (*Section->HeadSharedPageReferenceCount)--;
    (*Section->TailSharedPageReferenceCount)--;

    //
    // If the tail page still has references, then align the pointer down to the
    // nearest page boundary so that we don't free the page.
    //

    if ((*Section->TailSharedPageReferenceCount) != 0) {
        EndingAddress = PAGE_ALIGN(EndingAddress);
    }

    //
    // If the head page still has references, then align the pointer up to the
    // next page boundary so that we don't free the page.
    //

    if ((*Section->HeadSharedPageReferenceCount) != 0) {
        BaseAddress = PAGE_ALIGN((PUCHAR)BaseAddress + PAGE_SIZE);
    }

    //
    // If the ending address is still beyond the base address, then there's at
    // least one page that can be decommitted.  Note that NtFreeVirtualMemory
    // can handle the base address not being page aligned and the region size
    // not being an integral number of pages.
    //

    if (EndingAddress > BaseAddress) {

        RegionSize = (ULONG)EndingAddress - (ULONG)BaseAddress;

        NtFreeVirtualMemory(&BaseAddress, &RegionSize, MEM_DECOMMIT);
    }
}

NTSTATUS
XepLoadSection(
    IN HANDLE ImageFileHandle,
    IN PXBEIMAGE_SECTION Section,
    IN BOOLEAN Preloading
    )
/*++

Routine Description:

    This routine loads the supplied section into memory.

Arguments:

    ImageFileHandle - Specifies the handle of the file that the section can be
        loaded from.

    Section - Specifies the section to be loaded.

    Preloading - Specifies TRUE if the section is being loaded from inside
        XeLoadImage, else FALSE.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    UCHAR SectionDigest[XC_DIGEST_LEN];

    ASSERT(Section->SectionReferenceCount == 0);
    ASSERT(Section->SizeOfRawData <= Section->VirtualSize);

    //
    // Commit the pages assigned to the section.  Note that if this fails, then
    // we'll always allow the error to propagate back to the caller.
    //

    status = XepCommitSectionPages(Section);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read the raw data from the image file.
    //

    status = XepReadImageFile(ImageFileHandle, (PVOID)Section->VirtualAddress,
        Section->SizeOfRawData, Section->PointerToRawData);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Zero the rest of the section.
    //

    RtlZeroMemory((PUCHAR)Section->VirtualAddress + Section->SizeOfRawData,
        Section->VirtualSize - Section->SizeOfRawData);

    //
    // Verify that the digest of the data that was read from the file matches
    // the digest stored in the section header.
    //

    XCCalcDigest((PUCHAR)Section->VirtualAddress, Section->SizeOfRawData,
        SectionDigest);

    if (memcmp(Section->SectionDigest, SectionDigest, XC_DIGEST_LEN) != 0) {
        LdrxDbgPrint(("LDRX: failed to verify section digest.\n"));
        status = STATUS_TRUST_FAILURE;
        goto CleanupAndExit;
    }

    //
    // The section is now loaded.
    //

    Section->SectionReferenceCount = 1;

    status = STATUS_SUCCESS;

#ifdef DEVKIT
    //
    // Notify the debugger that the section has been loaded.
    //

    if (XepSendSectionDebugNotifications) {
        DebugService(BREAKPOINT_LOAD_XESECTION, Section, NULL);
    }
#endif

CleanupAndExit:
    if (!NT_SUCCESS(status)) {

        //
        // Decommit the pages assigned to the section.
        //

        XepDecommitSectionPages(Section);

        //
        // If a section fails to load due to a device I/O error or the section
        // digest not matching and we're not inside XeLoadImage, then halt the
        // system.  If the current title is the dashboard, then the disk is
        // probably corrupt, so we'll display the universal error message.  We
        // don't simply return an error to the caller, because we can't trust
        // that the title will properly handle the error and the title will
        // likely crash anyway.
        //

        if (!Preloading) {

            LdrxDbgPrint(("LDRX: failed to read section %08x (status=%08x).\n",
                Section, status));

            if (XeImageHeader()->Certificate->TitleID == LDR_DASHBOARD_TITLE_ID) {
                HalReturnToFirmware(HalFatalErrorRebootRoutine);
            } else {
                HalHaltSystem();
            }
        }
    }


    return status;
}

NTSTATUS
XeLoadSection(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine loads the supplied section into memory or increments the
    reference count for the section if the section is already loaded.

Arguments:

    Section - Specifies the section to be loaded.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE ImageFileHandle;

    ImageFileHandle = NULL;

    RtlEnterCriticalSectionAndRegion(&XepLoaderLock);

    //
    // Check if the section is already loaded and if so, just increment the
    // section's reference count and bail out.
    //

    if (Section->SectionReferenceCount > 0) {
        Section->SectionReferenceCount++;
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // Open the image file.
    //

    status = XepOpenImageFile(&ImageFileHandle);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Delegate the actual section loading to a common worker routine.
    //

    status = XepLoadSection(ImageFileHandle, Section, FALSE);

    if (NT_SUCCESS(status)) {

        //
        // Change the protection of the section to PAGE_EXECUTE_READ if the
        // section is not a writeable section.
        //

        if (LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_WRITEABLE)) {
            XepMarkSectionPagesReadOnly(Section);
        }
    }

CleanupAndExit:
    //
    // Close the image file handle.
    //

    if (ImageFileHandle != NULL) {
        NtClose(ImageFileHandle);
    }

    RtlLeaveCriticalSectionAndRegion(&XepLoaderLock);

    return status;
}

NTSTATUS
XeUnloadSection(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine decrements the reference count for the supplied section and if
    the count reaches zero, unloads the section from memory.

Arguments:

    Section - Specifies the section to be unloaded.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;

    RtlEnterCriticalSectionAndRegion(&XepLoaderLock);

    //
    // Check if the section has been loaded.  If not, return an error.
    //

    if (Section->SectionReferenceCount == 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Decrement the section's reference count and check if there are still
    // references to the section.  If so, bail out.
    //

    Section->SectionReferenceCount--;

    if (Section->SectionReferenceCount > 0) {
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

#ifdef DEVKIT
    //
    // Notify the debugger that the section is unloading.
    //

    if (XepSendSectionDebugNotifications) {
        DebugService(BREAKPOINT_UNLOAD_XESECTION, Section, NULL);
    }
#endif

    //
    // Decommit the pages that are used by the section.
    //

    XepDecommitSectionPages(Section);

    status = STATUS_SUCCESS;

CleanupAndExit:
    RtlLeaveCriticalSectionAndRegion(&XepLoaderLock);

    return status;
}

NTSTATUS
XepVerifyImageHeaderEncryptedDigest(
    VOID
    )
/*++

Routine Description:

    This routine verifies that the encrypted header digest stored in the image
    header matches the digest of the data in the rest of the image headers.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    PUCHAR PublicKeyData;
    PUCHAR Workspace;
    ULONG HeaderDigestLength;
    UCHAR HeaderDigest[XC_DIGEST_LEN];
    BOOLEAN Verified;

    PublicKeyData = XePublicKeyData;

    //
    // Allocate a workspace to do the digest verification.
    //

    Workspace = (PUCHAR)ExAllocatePoolWithTag(XCCalcKeyLen(PublicKeyData) * 2,
        'sWeX');

    if (Workspace == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The encrypted header digest starts at the field after the encrypted
    // header field in the main image header.
    //

    HeaderDigestLength = XeImageHeader()->SizeOfHeaders -
        FIELD_OFFSET(XBEIMAGE_HEADER, BaseAddress);

    //
    // Calculate the SHA1 digest for the headers.
    //

    XCCalcDigest((PUCHAR)&XeImageHeader()->BaseAddress, HeaderDigestLength,
        HeaderDigest);

    //
    // Verify that the SHA1 digest matches the encrypted header digest.
    //

    Verified = XCVerifyDigest(XeImageHeader()->EncryptedDigest, PublicKeyData,
        Workspace, HeaderDigest);

    ExFreePool(Workspace);

    if (Verified) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_TRUST_FAILURE;
    }
}

NTSTATUS
XepComputeImageMediaTypes(
    IN HANDLE ImageFileHandle,
    OUT PULONG ReturnedImageMediaTypes
    )
/*++

Routine Description:

    This routine computes the type of image media that the supplied file handle
    references.

Arguments:

    ImageFileHandle - Specifies the handle of the image file.

    ReturnedImageMediaTypes - Specifies the buffer to receive the type of media
        that the supplied file handle references.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;
#if !defined(ARCADE) || defined(DEVKIT)
    DVD_READ_STRUCTURE ReadStructure;
    UCHAR ReadStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) +
        sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];
    PDVD_DESCRIPTOR_HEADER DescriptorHeader;
    PDVD_LAYER_DESCRIPTOR LayerDescriptor;
    ULONG ImageMediaTypes;
#endif

    //
    // Query the file's volume to find out what type of device we have.
    //

    status = NtQueryVolumeInformationFile(ImageFileHandle, &IoStatusBlock,
        &DeviceInformation, sizeof(FILE_FS_DEVICE_INFORMATION),
        FileFsDeviceInformation);

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to query device information (status=%08x).\n",
            status));
        return status;
    }

#ifdef ARCADE
    //
    // Check if this is a handle to a file loaded from the media board.
    //

    if (DeviceInformation.DeviceType == FILE_DEVICE_MEDIA_BOARD) {
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_MEDIA_BOARD;
        return STATUS_SUCCESS;
    }
#endif

#if !defined(ARCADE) || defined(DEVKIT)
    //
    // If this isn't a handle to a file from the CD-ROM device, then it must be
    // a file from the hard disk device.
    //

    if (DeviceInformation.DeviceType != FILE_DEVICE_CD_ROM) {
        ASSERT(DeviceInformation.DeviceType == FILE_DEVICE_DISK);
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_HARD_DISK;
        return STATUS_SUCCESS;
    }

    //
    // If the device has already passed DVD-X2 authentication, then we only
    // return this media type flag.
    //

    if (IdexCdRomDVDX2Authenticated) {
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_X2;
        return STATUS_SUCCESS;
    }

    //
    // Read the DVD physical descriptor structure.  If the device reports back
    // that this is an unrecognized media, then assume that we have a CD media.
    //

    RtlZeroMemory(&ReadStructure, sizeof(DVD_READ_STRUCTURE));

    ReadStructure.Format = DvdPhysicalDescriptor;

    RtlZeroMemory(ReadStructureOutput, sizeof(ReadStructureOutput));

    status = NtDeviceIoControlFile(ImageFileHandle, NULL, NULL, NULL,
        &IoStatusBlock, IOCTL_DVD_READ_STRUCTURE, &ReadStructure,
        sizeof(DVD_READ_STRUCTURE), &ReadStructureOutput,
        sizeof(ReadStructureOutput));

    if (status == STATUS_UNRECOGNIZED_MEDIA) {
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
            XBEIMAGE_MEDIA_TYPE_CD;
        return STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Decode the DVD physical descriptor structure.
    //

    DescriptorHeader = (PDVD_DESCRIPTOR_HEADER)ReadStructureOutput;
    LayerDescriptor = (PDVD_LAYER_DESCRIPTOR)DescriptorHeader->Data;

    if (LayerDescriptor->LayerType == 0x01) {

        if (LayerDescriptor->NumberOfLayers == 0x00) {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_5_RO;
        } else {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_9_RO;
        }

    } else {

        if (LayerDescriptor->NumberOfLayers == 0x00) {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_5_RW;
        } else {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_9_RW;
        }
    }

    *ReturnedImageMediaTypes = ImageMediaTypes;
    return STATUS_SUCCESS;
#else
    //
    // The only media type that is supported is the media board.  Don't allow
    // executables to be loaded from any other type of media.
    //

    return STATUS_UNSUCCESSFUL;
#endif
}

NTSTATUS
XepResolveImageImports(
    IN PVOID ExportBaseAddress,
    IN PIMAGE_THUNK_DATA ImageThunkData
    )
/*++

Routine Description:

    This routine resolves ordinal imports from the supplied export executable.

Arguments:

    ExportBaseAddress - Specifies the base address of the image that is
        providing the exports.

    ImageThunkData - Specifies the pointer to the array of ordinal import thunks
        that are to be replaced by pointers to functions in the export image.

Return Value:

    Status of operation.

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportDirectorySize;
    PULONG AddressOfFunctions;
    ULONG OrdinalNumber;

    //
    // Lookup the export directory from the export executable.
    //

    ExportDirectory =
        (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(ExportBaseAddress,
        TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirectorySize);

    if (ExportDirectory == NULL) {
        LdrxDbgPrint(("LDRX: cannot import from image %p.\n", ExportBaseAddress));
        return STATUS_ORDINAL_NOT_FOUND;
    }

    AddressOfFunctions = (PULONG)((ULONG)ExportBaseAddress +
        (ULONG)ExportDirectory->AddressOfFunctions);

    //
    // Loop over the image thunks and resolve the ordinals against the export
    // directory.
    //

    while (ImageThunkData->u1.Ordinal != 0) {

        ASSERT(IMAGE_SNAP_BY_ORDINAL(ImageThunkData->u1.Ordinal));

        OrdinalNumber = IMAGE_ORDINAL(ImageThunkData->u1.Ordinal) -
            ExportDirectory->Base;

        if ((OrdinalNumber >= ExportDirectory->NumberOfFunctions) ||
            (AddressOfFunctions[OrdinalNumber] == 0)) {
            LdrxDbgPrint(("LDRX: cannot import ordinal %d from image %p.\n",
                IMAGE_ORDINAL(ImageThunkData->u1.Ordinal), ExportBaseAddress));
            return STATUS_ORDINAL_NOT_FOUND;
        }

        ImageThunkData->u1.Function = (ULONG)ExportBaseAddress +
            AddressOfFunctions[OrdinalNumber];

        ImageThunkData++;
    }

    return STATUS_SUCCESS;
}

#ifdef DEVKIT

NTSTATUS
XepResolveNonKernelImageImports(
    VOID
    )
/*++

Routine Description:

    This routine resolves imports for modules other than the kernel.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PXBEIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    UNICODE_STRING ImageName;
    PLIST_ENTRY NextListEntry;
    PLDR_DATA_TABLE_ENTRY DataTableEntry;

    ASSERT(XeImageHeader()->ImportDirectory != NULL);

    //
    // Loop over each import descriptor in the import directory.  Stop when we
    // find an import descriptor with a NULL thunk data.
    //

    ImportDescriptor = XeImageHeader()->ImportDirectory;

    while (ImportDescriptor->ImageThunkData != NULL) {

        RtlInitUnicodeString(&ImageName, ImportDescriptor->ImageName);

        //
        // Search the loaded module list for the image name.
        //

        NextListEntry = KdLoadedModuleList.Flink;

        while (NextListEntry != &KdLoadedModuleList) {

            DataTableEntry = CONTAINING_RECORD(NextListEntry, LDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);

            if (RtlEqualUnicodeString(&ImageName, &DataTableEntry->BaseDllName,
                TRUE)) {

                //
                // Resolve the imports from this module.
                //

                status = XepResolveImageImports(DataTableEntry->DllBase,
                    ImportDescriptor->ImageThunkData);

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                break;
            }

            NextListEntry = DataTableEntry->InLoadOrderLinks.Flink;
        }

        if (NextListEntry == &KdLoadedModuleList) {
            LdrxDbgPrint(("LDRX: cannot import from module %wZ.\n", &ImageName));
            return STATUS_DLL_NOT_FOUND;
        }

        ImportDescriptor++;
    }

    return STATUS_SUCCESS;
}

VOID
XepNotifyDebuggerOfImageLoad(
    VOID
    )
/*++

Routine Description:

    This routine notifies the debugger that an Xbox executable image has been
    loaded and sends the section load notifications for the preload sections.

Arguments:

    ImageFileName - Specifies the name of the Xbox executable image to load.

Return Value:

    Status of operation.

--*/
{
    PVOID BaseAddress;
    KD_SYMBOLS_INFO SymbolInfo;
    STRING SymbolFileName;
    PXBEIMAGE_SECTION Section;
    PXBEIMAGE_SECTION EndingSection;

    //
    // The Xbox executable has NtBaseOfDll set to where the portable executable
    // (PE) headers would have been located given the base address of the first
    // section of this executable.  There may or may not actually be PE headers
    // at this address.  However, we don't allow the base address to be located
    // below the Xbox executable header.
    //

    BaseAddress = XeImageHeader()->NtBaseOfDll;

    if (BaseAddress < (PVOID)XeImageHeader()) {
        BaseAddress = XeImageHeader();
    }

    //
    // Initialize the loader data table for the Xbox executable and attach it to
    // the loaded module list.
    //

    RtlInitUnicodeString(&XepDataTableEntry.FullDllName,
        XeImageHeader()->DebugUnicodeFileName);

    XepDataTableEntry.DllBase = BaseAddress;
    XepDataTableEntry.SizeOfImage = XeImageHeader()->NtSizeOfImage;
    XepDataTableEntry.CheckSum = XeImageHeader()->NtCheckSum;
    XepDataTableEntry.Flags = LDRP_ENTRY_XE_IMAGE;
    XepDataTableEntry.LoadedImports = (PVOID)MAXULONG_PTR;
    XepDataTableEntry.BaseDllName = XepDataTableEntry.FullDllName;

    ExInterlockedInsertTailList(&KdLoadedModuleList,
        &XepDataTableEntry.InLoadOrderLinks);

    //
    // Notify the debugger that the module has been loaded.
    //

    SymbolInfo.BaseOfDll = BaseAddress;
    SymbolInfo.ProcessId = (ULONG_PTR)-1;
    SymbolInfo.SizeOfImage = XeImageHeader()->NtSizeOfImage;
    SymbolInfo.CheckSum = XeImageHeader()->NtCheckSum;

    RtlInitAnsiString(&SymbolFileName, XeImageHeader()->DebugFileName);

    DebugLoadImageSymbols(&SymbolFileName, &SymbolInfo);

    //
    // Notify the debugger that all of the preload sections have been loaded.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        if (LdrxIsFlagSet(Section->SectionFlags, XBEIMAGE_SECTION_PRELOAD)) {
            DebugService(BREAKPOINT_LOAD_XESECTION, Section, NULL);
        }

        Section++;
    }

    //
    // Allow debugger notifications to be sent from the normal section load and
    // unload code paths.
    //

    XepSendSectionDebugNotifications = TRUE;
}

#endif

VOID
XepExtractCertificateKey(
    IN XBEIMAGE_CERTIFICATE_KEY InputKey,
    OUT PUCHAR OutputKey
    )
/*++

Routine Description:

    This routine extracts the raw data from the supplied input key and stores
    the result in the supplied output key.

Arguments:

    InputKey - Specifies the raw data to use as input for generating the output
        key.

    OutputKey - Specifies the location to receive the output key.

Return Value:

    None.

--*/
{
    UCHAR Digest[XC_DIGEST_LEN];

    //
    // Generate the output key from the input key and the certificate key stored
    // in the ROM.
    //

    XcHMAC(XboxCERTKey, XBOX_KEY_LENGTH, InputKey,
        XBEIMAGE_CERTIFICATE_KEY_LENGTH, NULL, 0, Digest);

    RtlCopyMemory(OutputKey, Digest, XBOX_KEY_LENGTH);
}

VOID
XepExtractCertificateKeys(
    VOID
    )
/*++

Routine Description:

    This routine extracts the raw keys stored in the Xbox executable and stores
    them in global data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG Index;

    Certificate = XeImageHeader()->Certificate;

    //
    // Extract the LAN key.
    //

    XepExtractCertificateKey(Certificate->LANKey, XboxLANKey);

    //
    // Extract the signature key.
    //

    XepExtractCertificateKey(Certificate->SignatureKey, XboxSignatureKey);

    //
    // Extract the alternate signature keys.
    //

    for (Index = 0; Index < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT; Index++) {
        XepExtractCertificateKey(Certificate->AlternateSignatureKeys[Index],
            XboxAlternateSignatureKeys[Index]);
    }
}

NTSTATUS
XeLoadImage(
    IN PCOSTR ImageFileName,
    IN BOOLEAN LoadingDashboard,
    IN ULONG SettingsError
    )
/*++

Routine Description:

    This routine loads and verifies an Xbox executable image.

Arguments:

    ImageFileName - Specifies the name of the Xbox executable image to load.

    LoadingDashboard - Specifies TRUE if we're attempting to load the dashboard.

    SettingsError - If non-zero, specifies what settings are invalid and should
        be fixed via the dashboard.  Used as a flag to indicate whether or not
        the executable image needs to be signed to run from the manufacturing
        region.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE ImageFileHandle;
    PXBEIMAGE_HEADER ImageHeader;
    BOOLEAN ReleaseBaseAddress;
    SIZE_T ImageFileNameLength;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    ULONG HeaderBytesRemaining;
    PVOID EndOfHeaders;
    PULONG ConfoundingKey;
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG TitleGameRegion;
    ULONG ImageMediaTypes;
    PXBEIMAGE_SECTION Section;
    PXBEIMAGE_SECTION EndingSection;
#ifdef DEVKIT
    PXBEIMAGE_LIBRARY_VERSION LibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION EndingLibraryVersion;
#endif
    BOOLEAN ChangeResetOnTrayOpen;
    ULONG ResetOnTrayOpen;

    ImageFileHandle = NULL;
    ImageHeader = NULL;
    ReleaseBaseAddress = FALSE;

    //
    // Duplicate the image file name.
    //

    ImageFileNameLength = ocslen(ImageFileName) * sizeof(OCHAR);

    ASSERT(ImageFileNameLength <= USHRT_MAX);

    XeImageFileName.Buffer = (POCHAR)ExAllocatePoolWithTag(ImageFileNameLength,
        'nFeX');

    if (XeImageFileName.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    RtlCopyMemory(XeImageFileName.Buffer, ImageFileName, ImageFileNameLength);
    XeImageFileName.Length = (USHORT)ImageFileNameLength;
    XeImageFileName.MaximumLength = (USHORT)ImageFileNameLength;

#ifdef DEVKIT
    //
    // On DEVKIT systems, we assume that the system is never so messed up that
    // system settings cannot be restored in the dash.  So if we've been called
    // to find something to run instead of the dash when system settings are
    // bad, we won't even bother to do any work.
    //

    if (SettingsError != 0) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto CleanupAndExit;
    }
#endif

    //
    // Open the image file.
    //

    status = XepOpenImageFile(&ImageFileHandle);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Allocate a buffer to read the first page of the image header.
    //

    ImageHeader = (PXBEIMAGE_HEADER)ExAllocatePoolWithTag(PAGE_SIZE, 'hIeX');

    if (ImageHeader == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Read the first page of the image header.
    //

    ByteOffset.QuadPart = 0;

    status = NtReadFile(ImageFileHandle, NULL, NULL, NULL, &IoStatusBlock,
        ImageHeader, PAGE_SIZE, &ByteOffset);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Verify that we read at least an entire image header.
    //

    if (IoStatusBlock.Information < XBEIMAGE_HEADER_BASE_SIZEOF) {
        LdrxDbgPrint(("LDRX: image too small.\n"));
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // Validate that the signature is correct, that the size of the headers is
    // at least large enough to contain the image header, that the size of the
    // image is greater than the size of the headers, and that the image is
    // based at the expected address.
    //

    if ((ImageHeader->Signature != XBEIMAGE_SIGNATURE) ||
        (ImageHeader->SizeOfHeaders <= XBEIMAGE_HEADER_BASE_SIZEOF) ||
        (ImageHeader->SizeOfHeaders > ImageHeader->SizeOfImage) ||
        (ImageHeader->BaseAddress != (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS)) {
        LdrxDbgPrint(("LDRX: invalid image header.\n"));
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // Reserve the address space used to map the XBE image.
    //

    BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
    RegionSize = ImageHeader->SizeOfImage;

    status = NtAllocateVirtualMemory(&BaseAddress, 0, &RegionSize, MEM_RESERVE,
        PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    ReleaseBaseAddress = TRUE;

    //
    // Commit the address space used to map the XBE headers.
    //

    BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
    RegionSize = ImageHeader->SizeOfHeaders;

    status = NtAllocateVirtualMemory(&BaseAddress, 0, &RegionSize, MEM_COMMIT,
        PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Copy the first page of the image header to its actual base address and
    // free the temporary buffer.
    //

    RtlCopyMemory((PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS, ImageHeader, PAGE_SIZE);

    ExFreePool(ImageHeader);
    ImageHeader = NULL;

    //
    // Read in the rest of the image headers if the headers are larger than a
    // single sector.
    //

    if (XeImageHeader()->SizeOfHeaders > PAGE_SIZE) {

        HeaderBytesRemaining = XeImageHeader()->SizeOfHeaders - PAGE_SIZE;

        status = XepReadImageFile(ImageFileHandle,
            (PVOID)(XBEIMAGE_STANDARD_BASE_ADDRESS + PAGE_SIZE),
            HeaderBytesRemaining, PAGE_SIZE);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

    //
    // Validate that all of the important header data is present and part of the
    // signed headers.
    //

    EndOfHeaders = (PUCHAR)XeImageHeader() + XeImageHeader()->SizeOfHeaders;

    if ((PVOID)XeImageHeader()->Certificate < (PVOID)XeImageHeader() ||
        (PVOID)((ULONG_PTR)XeImageHeader()->Certificate + XBEIMAGE_CERTIFICATE_BASE_SIZEOF) > EndOfHeaders ||
        (PVOID)XeImageHeader()->SectionHeaders < (PVOID)XeImageHeader() ||
        (PVOID)(XeImageHeader()->SectionHeaders + XeImageHeader()->NumberOfSections) >
        EndOfHeaders) {
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // Verify that the encrypted digest stored in the image header is valid.
    //

    status = XepVerifyImageHeaderEncryptedDigest();

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to verify header digest.\n"));
        goto CleanupAndExit;
    }

    //
    // Cache the pointer to the certificate and the title game region in locals.
    //

    Certificate = XeImageHeader()->Certificate;
    TitleGameRegion = Certificate->GameRegion;

#ifndef DEVKIT
#ifndef ARCADE
    //
    // Verify that we have a valid locked hard drive unless the title is
    // willing to run without one, or we're in the manufacturing region.
    //

    if (!IdexDiskSecurityUnlocked &&
        LdrxIsFlagClear(XboxGameRegion, XC_GAME_REGION_MANUFACTURING) &&
        LdrxIsFlagClear(Certificate->AllowedMediaTypes,
        XBEIMAGE_MEDIA_TYPE_NONSECURE_HARD_DISK)) {
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_LOCKED);
    }
#endif

    //
    // Verify that the image isn't attempting to bind to any imports that aren't
    // available in a non-DEVKIT version of the kernel.
    //

    if (XeImageHeader()->ImportDirectory != NULL) {
        LdrxDbgPrint(("LDRX: cannot import from modules other than kernel.\n"));
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // If we have invalid settings, then make sure this image is signed to run
    // in the manufacturing region before proceeding.
    //

    if ((SettingsError != 0) &&
        LdrxIsFlagClear(TitleGameRegion, XBEIMAGE_GAME_REGION_MANUFACTURING)) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto CleanupAndExit;
    }
#endif

    //
    // Unconfound portions of the header data.
    //

    ConfoundingKey = (PULONG)&XePublicKeyData[128];

    *((PULONG)&XeImageHeader()->AddressOfEntryPoint) ^=
        ConfoundingKey[0] ^ ConfoundingKey[4];
    *((PULONG)&XeImageHeader()->XboxKernelThunkData) ^=
        ConfoundingKey[1] ^ ConfoundingKey[2];

    //
    // Check if the game region is supported by the console.  If the console is
    // configured to run manufacturing content, then only allow manufacturing
    // content to run.
    //

    if (LdrxIsFlagSet(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {
        TitleGameRegion &= XBEIMAGE_GAME_REGION_MANUFACTURING;
    }

    if ((TitleGameRegion & XboxGameRegion) == 0) {
        LdrxDbgPrint(("LDRX: game region mismatch; cannot run image.\n"));
        status = STATUS_IMAGE_GAME_REGION_VIOLATION;
        goto CleanupAndExit;
    }

    //
    // Check if the image is allowed to run from this type of media.
    //

    status = XepComputeImageMediaTypes(ImageFileHandle, &ImageMediaTypes);

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to compute media types.\n"));
        goto CleanupAndExit;
    }

    if ((Certificate->AllowedMediaTypes & ImageMediaTypes) == 0) {
        LdrxDbgPrint(("LDRX: media types mismatch; cannot run image.\n"));
        status = STATUS_IMAGE_MEDIA_TYPE_VIOLATION;
        goto CleanupAndExit;
    }

    //
    // For images loaded from the CD-ROM device, verify that this executable's
    // title identifier matches the title identifier of previously loaded
    // media.
    //
    // If this is the first title that has run from this media, then remember
    // it's title identifier.
    //

    if ((ImageMediaTypes & (XBEIMAGE_MEDIA_TYPE_DVD_X2 |
        XBEIMAGE_MEDIA_TYPE_DVD_CD)) != 0) {

        if ((XeCdRomMediaTitleID != 0) &&
            (XeCdRomMediaTitleID != Certificate->TitleID)) {
            LdrxDbgPrint(("LDRX: title ID mismatch; cannot run image.\n"));
            status = STATUS_IMAGE_MEDIA_TYPE_VIOLATION;
            goto CleanupAndExit;
        }

        XeCdRomMediaTitleID = Certificate->TitleID;
    }

    //
    // Pass the Microsoft logo embedded in the Xbox executable to the animation
    // code so that it can be displayed as long as possible.
    //

    if (!KeHasQuickBooted) {
        AniSetLogo(XeImageHeader()->MicrosoftLogo, XeImageHeader()->SizeOfMicrosoftLogo);
    }

    //
    // Bring in all of the preload sections.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        if (LdrxIsFlagSet(Section->SectionFlags, XBEIMAGE_SECTION_PRELOAD)) {

            status = XepLoadSection(ImageFileHandle, Section, TRUE);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }
        }

        Section++;
    }

    //
    // Now that we've loaded a candidate Xbox executable, disable the option of
    // hitting the tray eject button without causing a reboot to occur.  If a
    // tray eject has occurred before this routine is called and we're not
    // loading the dashboard, then pretend like the file wasn't found and fail
    // this image load.
    //
    // Note that if we're loading the dashboard and we're not already in
    // non-secure mode, then this call will switch us to non-secure mode.  This
    // is done to close a window where tray ejects are causing a reboot, but
    // the HAL doesn't yet think that we're going to be running trusted code.
    //

    if (HalEnableTrayEjectRequiresReboot(LoadingDashboard)) {

        ASSERT(!KeHasQuickBooted);
        ASSERT(LdrxIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_NONSECUREMODE));

        if (!LoadingDashboard) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            goto CleanupAndExit;
        }
    }

    //
    // Resolve the image imports from the kernel.
    //

    if (XeImageHeader()->XboxKernelThunkData != NULL) {

        status = XepResolveImageImports(PsNtosImageBase,
            XeImageHeader()->XboxKernelThunkData);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

#ifdef DEVKIT
    //
    // Resolve the image imports from outside the kernel.
    //

    if (XeImageHeader()->ImportDirectory != NULL) {

        status = XepResolveNonKernelImageImports();

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

    //
    // Notify the debugger that the image has been loaded.
    //
    // Note that this has to be done before marking the section pages as
    // read-only.  The debug monitor may change the attributes of the sections
    // to not be read-only in order to support components like VTune.
    //

    XepNotifyDebuggerOfImageLoad();
#endif

    //
    // Change the protection of all of the preload non-writeable sections to
    // PAGE_EXECUTE_READ.  This is done after resolving the image imports
    // because the image imports are typically merged into the read-only .text
    // section.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        if (LdrxIsFlagSet(Section->SectionFlags, XBEIMAGE_SECTION_PRELOAD) &&
            LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_WRITEABLE)) {
            XepMarkSectionPagesReadOnly(Section);
        }

        Section++;
    }

#ifdef DEVKIT
    //
    // Print out the path to the Xbox executable that has been loaded.
    //

    DbgPrint("Xbox image loaded: %Z\n", &XeImageFileName);

    //
    // Print out the library versions that this Xbox executable linked against.
    //

    LibraryVersion = XeImageHeader()->LibraryVersions;
    EndingLibraryVersion = LibraryVersion + XeImageHeader()->NumberOfLibraryVersions;

    while (LibraryVersion < EndingLibraryVersion) {
        DbgPrint("This XBE was linked with %8.8s.LIB version %d.%02d.%d.%02d%s\n",
            LibraryVersion->LibraryName, LibraryVersion->MajorVersion,
            LibraryVersion->MinorVersion, LibraryVersion->BuildVersion,
            LibraryVersion->QFEVersion, LibraryVersion->DebugBuild ? " (Debug)" : "");
        LibraryVersion++;
    }

#ifndef ARCADE
    //
    // Check if the title wants extra memory in the development kit to be
    // automatically used for memory manager allocations or not.
    //

    if (LdrxIsFlagClear(XeImageHeader()->InitFlags, XINIT_LIMIT_DEVKIT_MEMORY)) {
        MmReleaseDeveloperKitMemory();
    }
#endif
#endif

    //
    // Extract the raw certificate keys.
    //

    XepExtractCertificateKeys();

    //
    // If we're not loading a title that's enabled to run from the manufacturing
    // content, then zero out the EEPROM key.  The console may not be configured
    // to allow manufacturing content, but we still allow some titles to access
    // the EEPROM key as long as they're marked as being able to run from the
    // manufacturing region.
    //

    if (LdrxIsFlagClear(TitleGameRegion, XBEIMAGE_GAME_REGION_MANUFACTURING)) {
        RtlZeroMemory(XboxEEPROMKey, XBOX_KEY_LENGTH);
    }

    //
    // If we're loading the dashboard, booting a kernel from the CD-ROM (such as
    // recovery), or if we're in the manufacturing region, then switch the SMC
    // to non-secure mode, where tray open events do not force a reboot.  In all
    // other cases, switch the SMC to secure mode.
    //
    // Note that the SMC only allows us to set non-secure mode once and this
    // must be the first override request to the SMC after a power cycle.  Once
    // the SMC is configured to run as secure mode, it cannot be switched back,
    // so this command may have no effect on the actual state of the SMC.
    //

    ResetOnTrayOpen = SMC_RESET_ON_TRAY_OPEN_SECURE_MODE;
    ChangeResetOnTrayOpen = FALSE;

    if (LoadingDashboard ||
        LdrxIsFlagSet(Certificate->AllowedMediaTypes, XBEIMAGE_MEDIA_TYPE_NONSECURE_MODE) ||
        LdrxIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_CDBOOT) ||
        LdrxIsFlagSet(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {

        if (!KeHasQuickBooted &&
            LdrxIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_NONSECUREMODE)) {
            XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE;
            ResetOnTrayOpen = SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE;
            ChangeResetOnTrayOpen = TRUE;
        }

    } else {

        if (!KeHasQuickBooted ||
            LdrxIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_NONSECUREMODE)) {
            XboxBootFlags &= ~XBOX_BOOTFLAG_NONSECUREMODE;
            ChangeResetOnTrayOpen = TRUE;
        }
    }

    if (ChangeResetOnTrayOpen) {

        do {
            status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS,
                SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, ResetOnTrayOpen);
        } while (!NT_SUCCESS(status));
    }

#ifdef ARCADE
    //
    // Force all Xbox executables to run with the "no setup hard disk" flag for
    // the arcade build.  This turns off the XAPI startup code that attempts to
    // create title and user directories as well as mounting a utility drive.
    //

    XeImageHeader()->InitFlags |= XINIT_NO_SETUP_HARD_DISK;
#endif

    //
    // The image is successfully loaded.
    //

    status = STATUS_SUCCESS;

CleanupAndExit:
    //
    // Free the temporary buffer used to hold the first sector of the image
    // header.
    //

    if (ImageHeader != NULL) {
        ExFreePool(ImageHeader);
    }

    //
    // Close the image file handle.
    //

    if (ImageFileHandle != NULL) {
        NtClose(ImageFileHandle);
    }

    if (!NT_SUCCESS(status)) {

        //
        // Release the virtual address range used to map the XBE image.
        //

        if (ReleaseBaseAddress) {

            BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
            RegionSize = 0;

            NtFreeVirtualMemory(&BaseAddress, &RegionSize, MEM_RELEASE);
        }

        //
        // Delete the image file name string.  Note that if
        // XeImageFileName.Buffer is NULL, then this call does nothing.
        //

        RtlFreeObjectString(&XeImageFileName);
    }

    return status;
}

#ifdef DEVKIT

NTSTATUS
XeLoadAlternateDashboardImage(
    VOID
    )
/*++

Routine Description:

    This routine attempts to load the dashboard as specified in the dashboard
    redirection file.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE RedirectionFileHandle;
    OCHAR RedirectionBuffer[MAX_LAUNCH_PATH + 1];
    POSTR Delimiter;

    //
    // Attempt to open the dashboard redirection file.
    //

    InitializeObjectAttributes(&ObjectAttributes, &XepDashboardRedirectionPath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&RedirectionFileHandle, GENERIC_READ, &ObjectAttributes,
        &IoStatusBlock, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT |
        FILE_NON_DIRECTORY_FILE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read in the dashboard redirection file and close the handle to the file.
    //

    status = NtReadFile(RedirectionFileHandle, NULL, NULL, NULL, &IoStatusBlock,
        RedirectionBuffer, MAX_LAUNCH_PATH * sizeof(OCHAR), NULL);

    NtClose(RedirectionFileHandle);

    if (!NT_SUCCESS(status)) {
        return status;
    } else if (IoStatusBlock.Information != (MAX_LAUNCH_PATH * sizeof(OCHAR))) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // Search for the title path delimiter and replace it with a backslash.  The
    // first portion of the string used to specify the object manager path for
    // the D: symbolic link, but the dashboard and XDK launcher don't require
    // that drive letter to be set up, so we no longer do that.
    //

    RedirectionBuffer[MAX_LAUNCH_PATH] = OTEXT('\0');

    Delimiter = ocschr(RedirectionBuffer, TITLE_PATH_DELIMITER);

    if (Delimiter != NULL) {
        *Delimiter = OTEXT('\\');
    }

    //
    // Attempt to load the alternate dashboard image.
    //

    status = XeLoadImage(RedirectionBuffer, TRUE, 0);

    return status;
}

#endif

VOID
XeLoadDashboardImage(
    VOID
    )
/*++

Routine Description:

    This routine attempts to load the dashboard from the shell partition.  This
    routine will not return if the dashboard cannot be loaded.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG FatalErrorCode;
    PLD_LAUNCH_DASHBOARD LaunchDashboard;

#ifdef DEVKIT
    //
    // Tell the debug monitor that we're going to be running the dashboard.
    //

    if (DmGetCurrentDmi() != NULL) {
        DmGetCurrentDmi()->Flags |= DMIFLAG_RUNSHELL;
    }

    //
    // Attempt to load the dashboard as specified in the dashboard redirection
    // file and return if successful.
    //

    status = XeLoadAlternateDashboardImage();

    if (NT_SUCCESS(status)) {
        return;
    }
#endif

    //
    // Attempt to load the standard dashboard image and return if successful.
    //

    status = XeLoadImage(XepDashboardImagePath, TRUE, 0);

    if (!NT_SUCCESS(status)) {

        LdrxDbgPrint(("INIT: Failed to launch an XBE (status=%08x).\n", status));
        LdrxDbgBreakPoint();

        //
        // Display the universal error message.
        //

        if (!KeHasQuickBooted) {

            HalWriteSMCLEDStates(SMC_LED_STATES_GREEN_STATE0 | SMC_LED_STATES_RED_STATE1 |
                SMC_LED_STATES_RED_STATE2 | SMC_LED_STATES_RED_STATE3);

            FatalErrorCode = FATAL_ERROR_XBE_DASH_GENERIC;

            //
            // If the launch data is available and there is a dashboard error,
            // change the fatal error code to indicate the dashboard error.
            // Otherwise, indicate if DVD-X2 authentication has passed.
            //

            if (LaunchDataPage != NULL &&
                LaunchDataPage->Header.dwLaunchDataType == LDT_LAUNCH_DASHBOARD) {

                LaunchDashboard = (PLD_LAUNCH_DASHBOARD)&(LaunchDataPage->LaunchData[0]);

                FatalErrorCode += LaunchDashboard->dwReason;

            } else {

#ifndef ARCADE
                if (IdexCdRomDVDX2Authenticated) {
                    FatalErrorCode = FATAL_ERROR_XBE_DASH_X2_PASS;
                }
#endif
            }

            ExDisplayFatalError(FatalErrorCode);

        } else {
            HalReturnToFirmware(HalFatalErrorRebootRoutine);
        }
    }
}

VOID
XeLoadDashboardImageWithReason(
    IN ULONG Reason,
    IN ULONG Parameter1
    )
/*++

Routine Description:

    This routine attempts to load the dashboard from the shell partition.  The
    dashboard is given a launch data page with the supplied reason and parameter
    codes.  This routine will not return if the dashboard cannot be loaded.

Arguments:

    Reason - Specifies the reason that the dashboard is being loaded.

    Parameter1 - Specifies more information about the reason that the dashboard
        is being loaded.

Return Value:

    None.

--*/
{
    PLD_LAUNCH_DASHBOARD LaunchDashboard;

    //
    // If a launch data page is not already allocated, then allocate a new page.
    //

    if (LaunchDataPage == NULL) {
        LaunchDataPage = MmAllocateContiguousMemory(PAGE_SIZE);
    }

    //
    // If a launch data page is available, then zero it out and fill it in with
    // supplied error codes.  If there's not enough memory to obtain a launch
    // data page, then we'll still try to launch the dashboard, but we'll likely
    // fail and end up displaying the universal error message.
    //

    if (LaunchDataPage != NULL) {

        MmPersistContiguousMemory(LaunchDataPage, PAGE_SIZE, TRUE);

        RtlZeroMemory(LaunchDataPage, PAGE_SIZE);

        LaunchDataPage->Header.dwLaunchDataType = LDT_LAUNCH_DASHBOARD;

        LaunchDashboard = (PLD_LAUNCH_DASHBOARD)&(LaunchDataPage->LaunchData[0]);
        LaunchDashboard->dwReason = Reason;
        LaunchDashboard->dwParameter1 = Parameter1;
    }

    //
    // Attempt to load the dashboard.  This will not return if the dashboard
    // cannot be loaded.
    //

    XeLoadDashboardImage();
}

VOID
XeLoadTitleImage(
    IN ULONG SettingsError
    )
/*++

Routine Description:

    This routine attempts to load a title as by either using the launch data
    page or the default Xbox executable path.  If the title load fails, then the
    dashboard is loaded instead.  This routine will not return if no image can
    be loaded.

Arguments:

    SettingsError - If non-zero, specifies what settings are invalid and should
        be fixed via the dashboard.  However, instead of immediately loading the
        dashboard, a check is made to see if a title can be loaded from the
        default Xbox executable path.  If a title can be loaded and the title
        is enabled to run from the manufacturing region, then that title is
        allowed to run.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OCHAR CapturedLaunchPath[MAX_LAUNCH_PATH + 1];
    PLAUNCH_DATA_PAGE SavedLaunchDataPage;
    POSTR Delimiter;
    OBJECT_STRING LinkTarget;
    BOOLEAN CreatedSymbolicLink;
    ULONG TrayState;
    ULONG TrayStateChangeCount1;
    ULONG TrayStateChangeCount2;
    ULONG DashboardError;

    //
    // Check to see if there is launch data has already been read by the kernel
    // during a previous reboot, and if so, free it now and ignore the data.
    //

    if ((SettingsError == 0) && (LaunchDataPage != NULL) &&
        LdrxIsFlagSet(LaunchDataPage->Header.dwFlags, LDF_HAS_BEEN_READ)) {
        SavedLaunchDataPage = LaunchDataPage;
        LaunchDataPage = NULL;
        MmFreeContiguousMemory(SavedLaunchDataPage);
    }

    //
    // Check if there's a settings error.  If so, then force a load from the
    // default Xbox executable path and ignore the launch data page (this should
    // only occur from a cold boot, so the launch data page is probably NULL).
    //
    // Check if there's a launch data page available.  If so, this page will
    // specify what Xbox executable image should be loaded.
    //

    if ((SettingsError == 0) && (LaunchDataPage != NULL)) {

        //
        // Immediately mark the launch data as having been read by the kernel.
        //

        LaunchDataPage->Header.dwFlags |= LDF_HAS_BEEN_READ;

        //
        // Copy out the launch path and ensure that the buffer is
        // null-terminated.
        //

        RtlCopyMemory(CapturedLaunchPath, LaunchDataPage->Header.szLaunchPath,
            MAX_LAUNCH_PATH * sizeof(OCHAR));
        CapturedLaunchPath[MAX_LAUNCH_PATH] = OTEXT('\0');

        //
        // Free the launch data page now if it only specified a launch path.
        //

        if (LaunchDataPage->Header.dwLaunchDataType == LDT_NONE) {
            SavedLaunchDataPage = LaunchDataPage;
            LaunchDataPage = NULL;
            MmFreeContiguousMemory(SavedLaunchDataPage);
        }

        //
        // If the launch path is empty, then this is an alias for loading the
        // dashboard.
        //

        if (CapturedLaunchPath[0] == OTEXT('\0')) {
            XeLoadDashboardImage();
            return;
        }

        //
        // Check for a path delimiter in the launch path.  If present, then the
        // first part of the string is the object manager path to use for the D:
        // symbolic link.  The second half of the string is a path relative to
        // the first half of the string.
        //
        // If no delimiter is present, then this is an absolute object manager
        // path and no D: symbolic link is created.
        //

        CreatedSymbolicLink = FALSE;
        Delimiter = ocschr(CapturedLaunchPath, TITLE_PATH_DELIMITER);

        if (Delimiter != NULL) {

            *Delimiter = OTEXT('\\');

            LinkTarget.Buffer = CapturedLaunchPath;
            LinkTarget.Length = (USHORT)(Delimiter - CapturedLaunchPath);
            LinkTarget.MaximumLength = LinkTarget.Length;

            status = IoCreateSymbolicLink(&XepCdRomDosDevice, &LinkTarget);

            if (NT_SUCCESS(status)) {
                CreatedSymbolicLink = TRUE;
            }
        }

        //
        // Attempt to load the specified image and return if successful.
        //

        status = XeLoadImage(CapturedLaunchPath, FALSE, 0);

        if (NT_SUCCESS(status)) {
            return;
        }

        //
        // Delete the symbolic link created above.
        //

        if (CreatedSymbolicLink) {
            IoDeleteSymbolicLink(&XepCdRomDosDevice);
        }

    } else {

        //
        // Read the initial tray state change count so that we can check below
        // if anything has changed.
        //

        HalReadSMCTrayState(&TrayState, &TrayStateChangeCount1);

        //
        // Attempt to load the default image and return if successful.  Note
        // that this can return an error if there is a settings error and the
        // default image isn't signed to run from the manufacturing region.
        //

        status = XeLoadImage(XepDefaultImagePath, FALSE, SettingsError);

        if (NT_SUCCESS(status)) {
            return;
        }

        //
        // If there's a settings error and the default title couldn't be found
        // or wasn't signed to run from the manufacturing region, then launch
        // the dashboard to handle the settings error.
        //

        if (SettingsError != 0) {
            XeLoadDashboardImageWithReason(XLD_LAUNCH_DASHBOARD_SETTINGS,
                SettingsError);
            return;
        }

        //
        // We failed to load the default image; check if it's due to the tray
        // state changing while we were attempting to load that image.  If so,
        // then normalize the error so that we don't disable an invalid XBE
        // message just because the user ejected the tray while we were reading
        // from the file.  Also, if the tray appears to be empty, then don't
        // send device errors to the dashboard.
        //

        HalReadSMCTrayState(&TrayState, &TrayStateChangeCount2);

        if (TrayState != SMC_TRAY_STATE_MEDIA_DETECT) {
            status = STATUS_NO_MEDIA_IN_DEVICE;
        } else if (TrayStateChangeCount1 != TrayStateChangeCount2) {
            status = STATUS_DEVICE_NOT_READY;
        }

        //
        // If this is a non-critical error, such as the drive being empty or
        // containing media without a title, then simply launch the dashboard
        // with no error code.
        //

        switch (status) {

            case STATUS_OBJECT_NAME_NOT_FOUND:
            case STATUS_OBJECT_PATH_NOT_FOUND:
            case STATUS_NO_MEDIA_IN_DEVICE:
            case STATUS_INVALID_DEVICE_REQUEST:
            case STATUS_UNRECOGNIZED_VOLUME:
            case STATUS_DEVICE_NOT_READY:
            case STATUS_NONEXISTENT_SECTOR:
                XeLoadDashboardImage();
                return;
        }
    }

    //
    // We failed to load a title.  Convert the error code to a dashboard error
    // code and load the dashboard to handle the error.
    //

    ASSERT(!NT_SUCCESS(status));

    LdrxDbgPrint(("LDRX: failed to load title image (status=%08x).\n", status));

    switch (status) {

        case STATUS_IMAGE_GAME_REGION_VIOLATION:
            DashboardError = XLD_ERROR_XBE_REGION;
            break;

        case STATUS_IMAGE_MEDIA_TYPE_VIOLATION:
            DashboardError = XLD_ERROR_XBE_MEDIA_TYPE;
            break;

        default:
            DashboardError = XLD_ERROR_INVALID_XBE;
            break;
    }

    XeLoadDashboardImageWithReason(XLD_LAUNCH_DASHBOARD_ERROR, DashboardError);
}

VOID
XeLoadImageAfterTrayEjectBoot(
    VOID
    )
/*++

Routine Description:

    This routine is called when the console was either powered on by hitting the
    tray eject button or if the tray eject button is hit shortly after hitting
    the power on button.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG TrayState;
    LARGE_INTEGER Interval;

    //
    // Block until the boot animation has completed and is ready to display the
    // Microsoft logo.
    //
    // Note that the time that it typically takes for the tray to eject, for
    // media to be put in the drive, the tray closed, and for the media to be
    // detected by the drive is approximately the length required to display the
    // boot animation, so we don't bother blocking on a media detected event.
    //

    AniBlockOnAnimation();

    for (;;) {

        //
        // Read the tray state from the SMC.
        //
        // Note that we can't use HalReadSMCTrayState here because that routine
        // can't tell us if the tray is in process of being closed.
        //

        status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_TRAY_STATE,
            &TrayState);

        if (!NT_SUCCESS(status)) {
            TrayState = SMC_TRAY_STATE_OPEN;
            break;
        }

        //
        // Check if the tray is in the process of closing or detecting media.
        // If we're in either of these states, then keep looping until we're out
        // of these states.
        //

        TrayState &= SMC_TRAY_STATE_STATE_MASK;

        if ((TrayState != SMC_TRAY_STATE_CLOSING) &&
            (TrayState != SMC_TRAY_STATE_CLOSED)) {
            break;
        }

        //
        // Delay for 250 milliseconds.
        //

        Interval.QuadPart = -250 * 10000;
        KeDelayExecutionThread(KernelMode, FALSE, &Interval);
    }

    //
    // If media was detected, then attempt to load a title image, otherwise load
    // the dashboard image.  Note that we might need to dismount the CD-ROM
    // device, especially for DEVKIT systems, if a file system was mounted
    // before the XBOX_BOOTFLAG_TRAYEJECT flag was checked by the calling
    // routine.
    //

    if (TrayState == SMC_TRAY_STATE_MEDIA_DETECT) {
        IoDismountVolume(IdexCdRomDeviceObject);
        XeLoadTitleImage(0);
    } else {
        XeLoadDashboardImage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\addrsup.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    addrsup.c

Abstract:

    This module implements routines to manipulate the virtual address
    descriptor tree.

--*/

#include "mi.h"

VOID
MiReorderTree (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    );

VOID
MiReorderTree (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    This function reorders the Node tree by applying various splay functions
    to the tree. This is a local function that is called by the insert Node
    routine.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    None.

--*/
{
    PMMADDRESS_NODE GrandParent;
    PMMADDRESS_NODE Parent;
    PMMADDRESS_NODE SplayNode;

    //
    // Reorder Node tree to make it as balanced as possible with as little
    // work as possible.
    //

    SplayNode = Node;

    while (SplayNode != *Root) {

        Parent = SplayNode->Parent;
        if (Parent == *Root) {

            //
            // Splay node's parent is the root of the tree. Rotate the tree
            // left or right depending on whether the splay node is the left
            // of right child of its parent.
            //
            // Pictorially:
            //
            //            Right                 Left
            //
            //          P        X          P          X
            //         / \      / \        / \        / \
            //        X   C -> A   P      C   X  ->  P   A
            //       / \          / \        / \    / \
            //      A   B        B   C      B   A  C   B
            //

            *Root = SplayNode;
            SplayNode->Parent = (PMMADDRESS_NODE)NULL;
            Parent->Parent = SplayNode;
            if (SplayNode == Parent->LeftChild) {

                //
                // Splay node is the left child of its parent. Rotate tree
                // right.
                //

                Parent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = Parent;
                }
                SplayNode->RightChild = Parent;
            } else {

                //
                // Splay node is the right child of its parent. Rotate tree
                // left.
                //

                Parent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = Parent;
                }
                SplayNode->LeftChild = Parent;
            }
            break;
        } else {
            GrandParent = Parent->Parent;
            if ((SplayNode == Parent->LeftChild) &&
               (Parent == GrandParent->LeftChild)) {

                //
                // Both the splay node and the parent node are left children
                // of their parents. Rotate tree right and make the parent
                // the root of the new subtree.
                //
                // Pictorially:
                //
                //        G                 P
                //       / \              /   \
                //      P   D            X     G
                //     / \       ->     / \   / \
                //    X   C            A   B C   D
                //   / \
                //  A   B
                //

                if (GrandParent == *Root) {
                    *Root = Parent;
                    Parent->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    Parent->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = Parent;
                    } else {
                        GrandParent->Parent->RightChild = Parent;
                    }
                }
                GrandParent->LeftChild = Parent->RightChild;
                if (Parent->RightChild) {
                    Parent->RightChild->Parent = GrandParent;
                }
                GrandParent->Parent = Parent;
                Parent->RightChild = GrandParent;
                SplayNode = Parent;
            } else if ((SplayNode == Parent->RightChild) &&
                      (Parent == GrandParent->RightChild)) {

                //
                // Both the splay node and the parent node are right children
                // of their parents. Rotate tree left and make the parent
                // the root of the new subtree.
                //
                // Pictorially:
                //
                //        G                 P
                //       / \              /   \
                //      D   P            G     X
                //         / \   ->     / \   / \
                //        C   X        D   C B   A
                //           / \
                //          A   B
                //

                if (GrandParent == *Root) {
                    *Root = Parent;
                    Parent->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    Parent->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = Parent;
                    } else {
                        GrandParent->Parent->RightChild = Parent;
                    }
                }
                GrandParent->RightChild = Parent->LeftChild;
                if (Parent->LeftChild) {
                    Parent->LeftChild->Parent = GrandParent;
                }
                GrandParent->Parent = Parent;
                Parent->LeftChild = GrandParent;
                SplayNode = Parent;
            } else if ((SplayNode == Parent->LeftChild) &&
                      (Parent == GrandParent->RightChild)) {

                //
                // Splay node is the left child of its parent and parent is
                // the right child of its parent. Rotate tree left and make
                // splay node the root of the new subtree.
                //
                // Pictorially:
                //
                //      G                 X
                //     / \              /   \
                //    A   P            G     P
                //       / \    ->    / \   / \
                //      X   D        A   B C   D
                //     / \
                //    B   C
                //

                if (GrandParent == *Root) {
                    *Root = SplayNode;
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    SplayNode->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = SplayNode;
                    } else {
                        GrandParent->Parent->RightChild = SplayNode;
                    }
                }
                Parent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = Parent;
                }
                GrandParent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = GrandParent;
                }
                Parent->Parent = SplayNode;
                GrandParent->Parent = SplayNode;
                SplayNode->LeftChild = GrandParent;
                SplayNode->RightChild = Parent;
            } else {

                //
                // Splay node is the right child of its parent and parent is
                // the left child of its parent. Rotate tree right and make
                // splay node the root of the new subtree.
                //
                // Pictorially:
                //
                //       G                 X
                //      / \              /   \
                //     P   A            P     G
                //    / \        ->    / \   / \
                //   D   X            D   C B   A
                //      / \
                //     C   B
                //

                if (GrandParent == *Root) {
                    *Root = SplayNode;
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    SplayNode->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = SplayNode;
                    } else {
                        GrandParent->Parent->RightChild = SplayNode;
                    }
                }
                Parent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = Parent;
                }
                GrandParent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = GrandParent;
                }
                Parent->Parent = SplayNode;
                GrandParent->Parent = SplayNode;
                SplayNode->LeftChild = Parent;
                SplayNode->RightChild = GrandParent;
            }
        }
    }
    return;
}

PMMADDRESS_NODE
FASTCALL
MiGetNextNode (
    IN PMMADDRESS_NODE Node
    )
/*++

Routine Description:

    This function locates the virtual address descriptor which contains
    the address range which logically follows the specified address range.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    Returns a pointer to the virtual address descriptor containing the
    next address range, NULL if none.

--*/
{
    PMMADDRESS_NODE Next;
    PMMADDRESS_NODE Parent;
    PMMADDRESS_NODE Left;

    Next = Node;

    if (Next->RightChild == (PMMADDRESS_NODE)NULL) {

        while ((Parent = Next->Parent) != (PMMADDRESS_NODE)NULL) {

            //
            // Locate the first ancestor of this node of which this
            // node is the left child of and return that node as the
            // next element.
            //

            if (Parent->LeftChild == Next) {
                return Parent;
            }

            Next = Parent;

        }

        return (PMMADDRESS_NODE)NULL;
    }

    //
    // A right child exists, locate the left most child of that right child.
    //

    Next = Next->RightChild;

    while ((Left = Next->LeftChild) != (PMMADDRESS_NODE)NULL) {
        Next = Left;
    }
    return Next;

}

PMMADDRESS_NODE
FASTCALL
MiGetPreviousNode (
    IN PMMADDRESS_NODE Node
    )
/*++

Routine Description:

    This function locates the virtual address descriptor which contains
    the address range which logically precedes the specified virtual
    address descriptor.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    Returns a pointer to the virtual address descriptor containing the
    next address range, NULL if none.

--*/
{
    PMMADDRESS_NODE Previous;

    Previous = Node;

    if (Previous->LeftChild == (PMMADDRESS_NODE)NULL) {


        while (Previous->Parent != (PMMADDRESS_NODE)NULL) {

            //
            // Locate the first ancestor of this node of which this
            // node is the right child of and return that node as the
            // Previous element.
            //

            if (Previous->Parent->RightChild == Previous) {
                return Previous->Parent;
            }

            Previous = Previous->Parent;

        }
        return (PMMADDRESS_NODE)NULL;
    }

    //
    // A left child exists, locate the right most child of that left child.
    //

    Previous = Previous->LeftChild;
    while (Previous->RightChild != (PMMADDRESS_NODE)NULL) {
        Previous = Previous->RightChild;
    }
    return Previous;
}

PMMADDRESS_NODE
FASTCALL
MiGetFirstNode (
    IN PMMADDRESS_NODE Root
    )
/*++

Routine Description:

    This function locates the virtual address descriptor which contains
    the address range which logically is first within the address space.

Arguments:

    None.

Return Value:

    Returns a pointer to the virtual address descriptor containing the
    first address range, NULL if none.

--*/
{
    PMMADDRESS_NODE First;

    First = Root;

    if (First == (PMMADDRESS_NODE)NULL) {
        return (PMMADDRESS_NODE)NULL;
    }

    while (First->LeftChild != (PMMADDRESS_NODE)NULL) {
        First = First->LeftChild;
    }

    return First;
}

VOID
FASTCALL
MiInsertNode (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    This function inserts a virtual address descriptor into the tree and
    reorders the splay tree as appropriate.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor


Return Value:

    None.

--*/
{
    ULONG Level = 0;
    PMMADDRESS_NODE Parent;

    //
    // Initialize virtual address descriptor child links.
    //

    Node->LeftChild = (PMMADDRESS_NODE)NULL;
    Node->RightChild = (PMMADDRESS_NODE)NULL;

    //
    // If the tree is empty, then establish this virtual address descriptor
    // as the root of the tree.
    // Otherwise descend the tree to find the correct place to
    // insert the descriptor.
    //

    Parent = *Root;
    if (!Parent) {
        *Root = Node;
        Node->Parent = (PMMADDRESS_NODE)NULL;
    } else {

        for (;;) {

            Level += 1;
            if (Level == 15) {
                MiReorderTree(Parent, Root);
            }

            //
            // If the starting address for this virtual address descriptor
            // is less than the parent starting address, then
            // follow the left child link. Else follow the right child link.
            //

            if (Node->StartingVpn < Parent->StartingVpn) {

                //
                // Starting address of the virtual address descriptor is less
                // than the parent starting virtual address.
                // Follow left child link if not null. Otherwise
                // insert the descriptor as the left child of the parent and
                // reorder the tree.
                //

                if (Parent->LeftChild) {
                    Parent = Parent->LeftChild;
                } else {
                    Parent->LeftChild = Node;
                    Node->Parent = Parent;
                    // MiReorderTree(Node, Root);
                    break;
                }
            } else {

                //
                // Starting address of the virtual address descriptor is greater
                // than the parent starting virtual address.
                // Follow right child link if not null. Otherwise
                // insert the descriptor as the right child of the parent and
                // reorder the tree.
                //

                if (Parent->RightChild) {
                    Parent = Parent->RightChild;
                } else {
                    Parent->RightChild = Node;
                    Node->Parent = Parent;
                    // MiReorderTree(Node, Root);
                    break;
                }
            }
        }
    }
    return;
}

VOID
FASTCALL
MiRemoveNode (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    This function removes a virtual address descriptor from the tree and
    reorders the splay tree as appropriate.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    None.

--*/
{

    PMMADDRESS_NODE LeftChild;
    PMMADDRESS_NODE RightChild;
    PMMADDRESS_NODE SplayNode;


    LeftChild = Node->LeftChild;
    RightChild = Node->RightChild;


    //
    // If the Node is the root of the tree, then establish new root. Else
    // isolate splay case and perform splay tree transformation.
    //

    if (Node == *Root) {

        //
        // This Node is the root of the tree. There are four cases to
        // handle:
        //
        //  1. the descriptor has no children
        //  2. the descriptor has a left child but no right child
        //  3. the descriptor has a right child but no left child
        //  4. the descriptor has both a right child and a left child
        //

        if (LeftChild) {
            if (RightChild) {

                //
                // The descriptor has both a left child and a right child.
                //

                if (LeftChild->RightChild) {

                    //
                    // The left child has a right child. Make the right most
                    // descendent of the right child of the left child the
                    // new root of the tree.
                    //
                    // Pictorially:
                    //
                    //      R          R
                    //      |          |
                    //      X          Z
                    //     / \        / \
                    //    A   B  ->  A   B
                    //     \          \
                    //      .          .
                    //       \
                    //        Z
                    //

                    SplayNode = LeftChild->RightChild;
                    while (SplayNode->RightChild) {
                        SplayNode = SplayNode->RightChild;
                    }
                    *Root = SplayNode;
                    SplayNode->Parent->RightChild = SplayNode->LeftChild;
                    if (SplayNode->LeftChild) {
                        SplayNode->LeftChild->Parent = SplayNode->Parent;
                    }
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                    LeftChild->Parent = SplayNode;
                    RightChild->Parent = SplayNode;
                    SplayNode->LeftChild = LeftChild;
                    SplayNode->RightChild = RightChild;
                } else if (RightChild->LeftChild) {

                    //
                    // The right child has a left child. Make the left most
                    // descendent of the left child of the right child the
                    // new root of the tree.
                    //
                    // Pictorially:
                    //
                    //      R          R
                    //      |          |
                    //      X          Z
                    //     / \        / \
                    //    A   B  ->  A   B
                    //       /          /
                    //      .          .
                    //     /
                    //    Z
                    //

                    SplayNode = RightChild->LeftChild;
                    while (SplayNode->LeftChild) {
                        SplayNode = SplayNode->LeftChild;
                    }
                    *Root = SplayNode;
                    SplayNode->Parent->LeftChild = SplayNode->RightChild;
                    if (SplayNode->RightChild) {
                        SplayNode->RightChild->Parent = SplayNode->Parent;
                    }
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                    LeftChild->Parent = SplayNode;
                    RightChild->Parent = SplayNode;
                    SplayNode->LeftChild = LeftChild;
                    SplayNode->RightChild = RightChild;
                } else {

                    //
                    // The left child of the descriptor does not have a right child,
                    // and the right child of the descriptor does not have a left
                    // child. Make the left child of the descriptor the new root of
                    // the tree.
                    //
                    // Pictorially:
                    //
                    //      R          R
                    //      |          |
                    //      X          A
                    //     / \        / \
                    //    A   B  ->  .   B
                    //   /          /
                    //  .
                    //

                    *Root = LeftChild;
                    LeftChild->Parent = (PMMADDRESS_NODE)NULL;
                    LeftChild->RightChild = RightChild;
                    LeftChild->RightChild->Parent = LeftChild;
                }
            } else {

                //
                // The descriptor has a left child, but does not have a right child.
                // Make the left child the new root of the tree.
                //
                // Pictorially:
                //
                //       R      R
                //       |      |
                //       X  ->  A
                //      /
                //     A
                //

                *Root = LeftChild;
                LeftChild->Parent = (PMMADDRESS_NODE)NULL;
            }
        } else if (RightChild) {

            //
            // The descriptor has a right child, but does not have a left child.
            // Make the right child the new root of the tree.
            //
            // Pictorially:
            //
            //       R         R
            //       |         |
            //       X    ->   A
            //        \
            //         A
            //

            *Root = RightChild;
            RightChild->Parent = (PMMADDRESS_NODE)NULL;
            while (RightChild->LeftChild) {
                RightChild = RightChild->LeftChild;
            }
        } else {

            //
            // The descriptor has neither a left child nor a right child. The
            // tree will be empty after removing the descriptor.
            //
            // Pictorially:
            //
            //      R      R
            //      |  ->
            //      X
            //

            *Root = NULL;
        }
    } else if (LeftChild) {
        if (RightChild) {

            //
            // The descriptor has both a left child and a right child.
            //

            if (LeftChild->RightChild) {

                //
                // The left child has a right child. Make the right most
                // descendent of the right child of the left child the new
                // root of the subtree.
                //
                // Pictorially:
                //
                //        P      P
                //       /        \
                //      X          X
                //     / \        / \
                //    A   B  or  A   B
                //     \          \
                //      .          .
                //       \          \
                //        Z          Z
                //
                //           |
                //           v
                //
                //        P      P
                //       /        \
                //      Z          Z
                //     / \        / \
                //    A   B  or  A   B
                //     \          \
                //      .          .
                //

                SplayNode = LeftChild->RightChild;
                while (SplayNode->RightChild) {
                    SplayNode = SplayNode->RightChild;
                }
                SplayNode->Parent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = SplayNode->Parent;
                }
                SplayNode->Parent = Node->Parent;
                if (Node == Node->Parent->LeftChild) {
                    Node->Parent->LeftChild = SplayNode;
                } else {
                    Node->Parent->RightChild = SplayNode;
                }
                LeftChild->Parent = SplayNode;
                RightChild->Parent = SplayNode;
                SplayNode->LeftChild = LeftChild;
                SplayNode->RightChild = RightChild;
            } else if (RightChild->LeftChild) {

                //
                // The right child has a left child. Make the left most
                // descendent of the left child of the right child the
                // new root of the subtree.
                //
                // Pictorially:
                //
                //        P      P
                //       /        \
                //      X          X
                //     / \        / \
                //    A   B  or  A   B
                //       /          /
                //      .          .
                //     /          /
                //    Z          Z
                //
                //           |
                //           v
                //
                //        P      P
                //       /        \
                //      Z          Z
                //     / \        / \
                //    A   B  or  A   B
                //       /          /
                //      .          .
                //

                SplayNode = RightChild->LeftChild;
                while (SplayNode->LeftChild) {
                    SplayNode = SplayNode->LeftChild;
                }
                SplayNode->Parent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = SplayNode->Parent;
                }
                SplayNode->Parent = Node->Parent;
                if (Node == Node->Parent->LeftChild) {
                    Node->Parent->LeftChild = SplayNode;
                } else {
                    Node->Parent->RightChild = SplayNode;
                }
                LeftChild->Parent = SplayNode;
                RightChild->Parent = SplayNode;
                SplayNode->LeftChild = LeftChild;
                SplayNode->RightChild = RightChild;
            } else {

                //
                // The left child of the descriptor does not have a right child,
                // and the right child of the descriptor does node have a left
                // child. Make the left child of the descriptor the new root of
                // the subtree.
                //
                // Pictorially:
                //
                //        P      P
                //       /        \
                //      X          X
                //     / \        / \
                //    A   B  or  A   B
                //   /          /
                //  .          .
                //
                //           |
                //           v
                //
                //        P      P
                //       /        \
                //      A          A
                //     / \        / \
                //    .   B  or  .   B
                //   /          /
                //

                SplayNode = LeftChild;
                SplayNode->Parent = Node->Parent;
                if (Node == Node->Parent->LeftChild) {
                    Node->Parent->LeftChild = SplayNode;
                } else {
                    Node->Parent->RightChild = SplayNode;
                }
                SplayNode->RightChild = RightChild;
                RightChild->Parent = SplayNode;
            }
        } else {

            //
            // The descriptor has a left child, but does not have a right child.
            // Make the left child the new root of the subtree.
            //
            // Pictorially:
            //
            //        P   P
            //       /     \
            //      X   or  X
            //     /       /
            //    A       A
            //
            //          |
            //          v
            //
            //        P   P
            //       /     \
            //      A       A
            //

            LeftChild->Parent = Node->Parent;
            if (Node == Node->Parent->LeftChild) {
                Node->Parent->LeftChild = LeftChild;
            } else {
                Node->Parent->RightChild = LeftChild;
            }
        }
    } else if (RightChild) {

        //
        // descriptor has a right child, but does not have a left child. Make
        // the right child the new root of the subtree.
        //
        // Pictorially:
        //
        //        P   P
        //       /     \
        //      X   or  X
        //       \       \
        //        A       A
        //
        //          |
        //          v
        //
        //        P   P
        //       /     \
        //      A       A
        //

        RightChild->Parent = Node->Parent;
        if (Node == Node->Parent->LeftChild) {
            Node->Parent->LeftChild = RightChild;
        } else {
            Node->Parent->RightChild = RightChild;
        }
    } else {

        //
        // The descriptor has neither a left child nor a right child. Delete
        // the descriptor from the tree and adjust its parent right or left
        // link.
        //
        // Pictorially:
        //
        //        P   P
        //       /     \
        //      X   or  X
        //
        //          |
        //          v
        //
        //        P   P
        //

        if (Node == Node->Parent->LeftChild) {
            Node->Parent->LeftChild = (PMMADDRESS_NODE)NULL;
        } else {
            Node->Parent->RightChild = (PMMADDRESS_NODE)NULL;
        }
    }
    return;
}

PMMADDRESS_NODE
FASTCALL
MiLocateAddressInTree (
    IN ULONG_PTR Vpn,
    IN PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    The function locates the virtual address descriptor which describes
    a given address.

Arguments:

    Vpn - Supplies the virtual page number to locate a descriptor
                     for.

Return Value:

    Returns a pointer to the virtual address descriptor which contains
    the supplied virtual address or NULL if none was located.

--*/
{

    PMMADDRESS_NODE Parent;
    ULONG Level = 0;

    Parent = *Root;

    for (;;) {

        if (Parent == (PMMADDRESS_NODE)NULL) {
            return (PMMADDRESS_NODE)NULL;
        }

        if (Level == 20) {

            //
            // There are 20 nodes above this point, reorder the
            // tree with this node as the root.
            //

            MiReorderTree(Parent, Root);
        }

        if (Vpn < Parent->StartingVpn) {
            Parent = Parent->LeftChild;
            Level += 1;

        } else if (Vpn > Parent->EndingVpn) {
            Parent = Parent->RightChild;
            Level += 1;

        } else {

            //
            // The address is within the start and end range.
            //

            return Parent;
        }
    }
}

PMMADDRESS_NODE
MiCheckForConflictingNode (
    IN ULONG_PTR StartVpn,
    IN ULONG_PTR EndVpn,
    IN PMMADDRESS_NODE Root
    )
/*++

Routine Description:

    The function determines if any addresses between a given starting and
    ending address is contained within a virtual address descriptor.

Arguments:

    StartVpn - Supplies the virtual address to locate a containing
                      descriptor.

    EndVpn - Supplies the virtual address to locate a containing
                      descriptor.

Return Value:

    Returns a pointer to the first conflicting virtual address descriptor
    if one is found, otherwise a NULL value is returned.

--*/
{
    PMMADDRESS_NODE Node;

    Node = Root;

    for (;;) {

        if (Node == (PMMADDRESS_NODE)NULL) {
            return (PMMADDRESS_NODE)NULL;
        }

        if (StartVpn > Node->EndingVpn) {
            Node = Node->RightChild;

        } else if (EndVpn < Node->StartingVpn) {
            Node = Node->LeftChild;

        } else {

            //
            // The starting address is less than or equal to the end VA
            // and the ending address is greater than or equal to the
            // start va.  Return this node.
            //

            return Node;
        }
    }
}

PVOID
MiFindEmptyAddressRangeInTree (
    IN SIZE_T SizeOfRange,
    IN ULONG_PTR Alignment,
    IN PMMADDRESS_NODE Root,
    OUT PMMADDRESS_NODE *PreviousVad
    )
/*++

Routine Description:

    The function examines the virtual address descriptors to locate
    an unused range of the specified size and returns the starting
    address of the range.

Arguments:

    SizeOfRange - Supplies the size in bytes of the range to locate.

    Alignment - Supplies the alignment for the address.  Must be
                 a power of 2 and greater than the page_size.

    Root - Supplies the root of the tree to search through.

    PreviousVad - Supplies the Vad which is before this the found
                  address range.

Return Value:

    Returns the starting address of a suitable range.

--*/
{
    PMMADDRESS_NODE Node;
    PMMADDRESS_NODE NextNode;
    ULONG_PTR AlignmentVpn;

    AlignmentVpn = Alignment >> PAGE_SHIFT;

    //
    // Locate the Node with the lowest starting address.
    //

    SizeOfRange = (SizeOfRange + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
    ASSERT (SizeOfRange != 0);

    Node = Root;

    if (Node == (PMMADDRESS_NODE)NULL) {
        return MM_LOWEST_USER_ADDRESS;
    }
    while (Node->LeftChild != (PMMADDRESS_NODE)NULL) {
        Node = Node->LeftChild;
    }

    //
    // Check to see if a range exists between the lowest address VAD
    // and lowest user address.
    //

    if (Node->StartingVpn > MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS)) {
        if ( SizeOfRange <
            (Node->StartingVpn - MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS))) {

            *PreviousVad = NULL;
            return MM_LOWEST_USER_ADDRESS;
        }
    }

    for (;;) {

        NextNode = MiGetNextNode (Node);

        if (NextNode != (PMMADDRESS_NODE)NULL) {

            if (SizeOfRange <=
                ((ULONG_PTR)NextNode->StartingVpn -
                                MI_ROUND_TO_SIZE(1 + Node->EndingVpn,
                                                 AlignmentVpn))) {

                //
                // Check to ensure that the ending address aligned upwards
                // is not greater than the starting address.
                //

                if ((ULONG_PTR)NextNode->StartingVpn >
                        MI_ROUND_TO_SIZE(1 + Node->EndingVpn,
                                         AlignmentVpn)) {

                    *PreviousVad = Node;
                    return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE(
                                   (ULONG_PTR)MI_VPN_TO_VA_ENDING(Node->EndingVpn),
                                          Alignment);
                }
            }

        } else {

            //
            // No more descriptors, check to see if this fits into the remainder
            // of the address space.
            //

            if ((((ULONG_PTR)Node->EndingVpn + MI_VA_TO_VPN(X64K)) <
                    MI_VA_TO_VPN (MM_HIGHEST_VAD_ADDRESS))
                        &&
                (SizeOfRange <=
                    ((ULONG_PTR)MM_HIGHEST_VAD_ADDRESS -
                         (ULONG_PTR)MI_ROUND_TO_SIZE(
                         (ULONG_PTR)MI_VPN_TO_VA(Node->EndingVpn), Alignment)))) {

                *PreviousVad = Node;
                return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE(
                                    (ULONG_PTR)MI_VPN_TO_VA_ENDING(Node->EndingVpn),
                                    Alignment);
            } else {
                ExRaiseStatus (STATUS_NO_MEMORY);
            }
        }
        Node = NextNode;
    }
}

PVOID
MiFindEmptyAddressRangeDownTree (
    IN SIZE_T SizeOfRange,
    IN PVOID HighestAddressToEndAt,
    IN ULONG_PTR Alignment,
    IN PMMADDRESS_NODE Root
    )
/*++

Routine Description:

    The function examines the virtual address descriptors to locate
    an unused range of the specified size and returns the starting
    address of the range.  The function examines from the high
    addresses down and ensures that starting address is less than
    the specified address.

Arguments:

    SizeOfRange - Supplies the size in bytes of the range to locate.

    HighestAddressToEndAt - Supplies the virtual address that limits
                            the value of the ending address.  The ending
                            address of the located range must be less
                            than this address.

    Alignment - Supplies the alignment for the address.  Must be
                 a power of 2 and greater than the page_size.

    Root - Supplies the root of the tree to search through.

Return Value:

    Returns the starting address of a suitable range.

--*/
{
    PMMADDRESS_NODE Node;
    PMMADDRESS_NODE PreviousNode;
    ULONG_PTR AlignedEndingVa;
    PVOID OptimalStart;
    ULONG_PTR OptimalStartVpn;
    ULONG_PTR HighestVpn;
    ULONG_PTR AlignmentVpn;

    SizeOfRange = MI_ROUND_TO_SIZE (SizeOfRange, PAGE_SIZE);

    ASSERT (HighestAddressToEndAt != NULL);
    ASSERT (HighestAddressToEndAt <= (PVOID)((ULONG_PTR)MM_HIGHEST_VAD_ADDRESS + 1));

    HighestVpn = MI_VA_TO_VPN (HighestAddressToEndAt);

    //
    // Locate the Node with the highest starting address.
    //

    OptimalStart = (PVOID)(MI_ALIGN_TO_SIZE(
                           (((ULONG_PTR)HighestAddressToEndAt + 1) - SizeOfRange),
                           Alignment));
    Node = Root;

    if (Node == (PMMADDRESS_NODE)NULL) {

        //
        // The tree is empty, any range is okay.
        //

        return (PMMADDRESS_NODE)(OptimalStart);
    }

    //
    // See if an empty slot exists to hold this range, locate the largest
    // element in the tree.
    //

    while (Node->RightChild != (PMMADDRESS_NODE)NULL) {
        Node = Node->RightChild;
    }

    //
    // Check to see if a range exists between the highest address VAD
    // and the highest address to end at.
    //

    AlignedEndingVa = (ULONG_PTR)MI_ROUND_TO_SIZE ((ULONG_PTR)MI_VPN_TO_VA_ENDING (Node->EndingVpn),
                                               Alignment);

    if (AlignedEndingVa < (ULONG_PTR)HighestAddressToEndAt) {

        if ( SizeOfRange < ((ULONG_PTR)HighestAddressToEndAt - AlignedEndingVa)) {

            return (PMMADDRESS_NODE)(MI_ALIGN_TO_SIZE(
                                  ((ULONG_PTR)HighestAddressToEndAt - SizeOfRange),
                                  Alignment));
        }
    }

    //
    // Walk the tree backwards looking for a fit.
    //

    OptimalStartVpn = MI_VA_TO_VPN (OptimalStart);
    AlignmentVpn = MI_VA_TO_VPN (Alignment);

    for (;;) {

        PreviousNode = MiGetPreviousNode (Node);

        if (PreviousNode != (PMMADDRESS_NODE)NULL) {

            //
            // Is the ending Va below the top of the address to end at.
            //

            if (PreviousNode->EndingVpn < OptimalStartVpn) {
                if ((SizeOfRange >> PAGE_SHIFT) <=
                    ((ULONG_PTR)Node->StartingVpn -
                    (ULONG_PTR)MI_ROUND_TO_SIZE(1 + PreviousNode->EndingVpn,
                                            AlignmentVpn))) {

                    //
                    // See if the optimal start will fit between these
                    // two VADs.
                    //

                    if ((OptimalStartVpn > PreviousNode->EndingVpn) &&
                        (HighestVpn < Node->StartingVpn)) {
                        return (PMMADDRESS_NODE)(OptimalStart);
                    }

                    //
                    // Check to ensure that the ending address aligned upwards
                    // is not greater than the starting address.
                    //

                    if ((ULONG_PTR)Node->StartingVpn >
                            (ULONG_PTR)MI_ROUND_TO_SIZE(1 + PreviousNode->EndingVpn,
                                                    AlignmentVpn)) {

                        return (PMMADDRESS_NODE)MI_ALIGN_TO_SIZE(
                                            (ULONG_PTR)MI_VPN_TO_VA (Node->StartingVpn) - SizeOfRange,
                                            Alignment);
                    }
                }
            }
        } else {

            //
            // No more descriptors, check to see if this fits into the remainder
            // of the address space.
            //

            if (Node->StartingVpn > MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS)) {
                if ((SizeOfRange >> PAGE_SHIFT) <=
                    ((ULONG_PTR)Node->StartingVpn - MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS))) {

                    //
                    // See if the optimal start will fit between these
                    // two VADs.
                    //

                    if (HighestVpn < Node->StartingVpn) {
                        return (PMMADDRESS_NODE)(OptimalStart);
                    }

                    return (PMMADDRESS_NODE)MI_ALIGN_TO_SIZE(
                                  (ULONG_PTR)MI_VPN_TO_VA (Node->StartingVpn) - SizeOfRange,
                                  Alignment);
                }
            } else {
                ExRaiseStatus (STATUS_NO_MEMORY);
            }
        }
        Node = PreviousNode;
    }
}

#if DBG
VOID
NodeTreeWalk (
    PMMADDRESS_NODE Start
    )

{
    if (Start == (PMMADDRESS_NODE)NULL) {
        return;
    }

    NodeTreeWalk(Start->LeftChild);

    DbgPrint("Node at 0x%lx start 0x%lx  end 0x%lx \n",
                    (ULONG_PTR)Start, MI_VPN_TO_VA(Start->StartingVpn),
                    (ULONG_PTR)MI_VPN_TO_VA (Start->EndingVpn) | (PAGE_SIZE - 1));


    NodeTreeWalk(Start->RightChild);
    return;
}
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\fscache.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fscache.c

Abstract:

    This module implements the file system cache services.

--*/

#include "mi.h"

//
// Macro to convert from a physical byte offset to a physical block number.
//

#define FscByteOffsetToBlockNumber(byteoffset) \
    ((ULONG)((ULONGLONG)(byteoffset) >> PAGE_SHIFT))

//
// Macro to round a size in bytes up to a multiple of the sector size.
//

#define FscRoundToSectors(volume, size) \
    (((ULONG)(size) + ((volume)->SectorSize - 1)) & \
        ~((volume)->SectorSize - 1))

//
// Array of cache elements.
//
PFSCACHE_ELEMENT FscElementArray;

//
// Number of elements allocated to the array of cache elements.
//
ULONG FscNumberOfCachePages;

//
// Linked list of cache elements ordered by least recently used.
//
LIST_ENTRY FscLruList;

//
// Page table entries used by FscWriteFFs to bulk write a range of 0xFF bytes
// using a single page.
//
PMMPTE FscWriteFFsPtes;

//
// Synchronization event to guard against multiple threads executing
// FscSetCacheSize at the same time.
//
INITIALIZED_KEVENT(FscSetCacheSizeEvent, SynchronizationEvent, TRUE);

//
// Notification event for when a read for a cache buffer has completed and there
// are threads waiting for the I/O completion.
//
INITIALIZED_KEVENT(FscCollidedMapBufferEvent, NotificationEvent, FALSE);

//
// Synchronization event for when the number of free elements is non-zero.
//
INITIALIZED_KEVENT(FscWaitingForElementEvent, SynchronizationEvent, FALSE);

//
// Guards multiple threads attempting to enter FscWriteFFs and access
// FscWriteFFsPtes.
//
INITIALIZED_CRITICAL_SECTION(FscWriteFFsLock);

VOID
FscBuildElementLruList(
    VOID
    )
/*++

Routine Description:

    This routine rebuilds the global element lists after the number of pages
    allocated to the cache has changed.  No assumptions are made about the order
    that pages should be placed in the LRU list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PFSCACHE_ELEMENT ElementArray;
    ULONG NumberOfCachePages;
    ULONG Index;

    MI_ASSERT_LOCK_MM();

    //
    // Initialize the LRU list head.
    //

    InitializeListHead(&FscLruList);

    //
    // Move these globals into locals to keep the compiler happy.
    //

    ElementArray = FscElementArray;
    NumberOfCachePages = FscNumberOfCachePages;

    //
    // Loop over all of the elements and insert them into the appropriate lists.
    //

    for (Index = 0; Index < NumberOfCachePages; Index++) {

        if (ElementArray[Index].CacheExtension == NULL) {

            //
            // The element doesn't reference valid data, so place it at the
            // front of the LRU list so that we grab this type of page first.
            //

            InsertHeadList(&FscLruList, &ElementArray[Index].ListEntry);

        } else {

            //
            // The element references valid data, so place it at the tail of the
            // LRU list so that we don't start reclaiming any elements with
            // valid data until all "free" elements from above are allocated.
            //

            InsertTailList(&FscLruList, &ElementArray[Index].ListEntry);
        }
    }
}

NTSTATUS
FscGrowCacheSize(
    IN PFN_COUNT NumberOfCachePages
    )
/*++

Routine Description:

    This routine grows the number of pages allocated to the file system cache.

Arguments:

    NumberOfCachePages - Specifies the number of pages that should be allocated
        to the file system cache.

Return Value:

    Status of operation.

--*/
{
    PFSCACHE_ELEMENT NewElementArray;
    PCHAR CacheBuffer;
    ULONG Index;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(NumberOfCachePages > FscNumberOfCachePages);

    //
    // Allocate the new array of cache elements.
    //

    NewElementArray = (PFSCACHE_ELEMENT)ExAllocatePoolWithTag(
        sizeof(FSCACHE_ELEMENT) * NumberOfCachePages, 'AcsF');

    if (NewElementArray == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    RtlFillMemoryUlong(NewElementArray, sizeof(FSCACHE_ELEMENT) *
        NumberOfCachePages, 'looP');
#endif

    //
    // Allocate the additional cache pages as one virtually contiguous chunk.
    //

    CacheBuffer = (PCHAR)MiAllocateMappedMemory(&MmSystemPteRange,
        MmFsCacheUsage, PAGE_READONLY,
        (NumberOfCachePages - FscNumberOfCachePages) << PAGE_SHIFT,
        MiRemoveAnyPage, FALSE);

    if (CacheBuffer == NULL) {
        ExFreePool(NewElementArray);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the old array of cache elements to the new array.
    //

    RtlCopyMemory(NewElementArray, FscElementArray, sizeof(FSCACHE_ELEMENT) *
        FscNumberOfCachePages);

    //
    // Fill in the new cache elements.
    //

    for (Index = FscNumberOfCachePages; Index < NumberOfCachePages; Index++) {

        NewElementArray[Index].CacheExtension = NULL;
        NewElementArray[Index].CacheBuffer = CacheBuffer;

        //
        // Override the PTE index that's currently in the page frame with the
        // buffer's index into the FscElementArray so that we can quickly map
        // from a buffer's virtual address to it's cache element.
        //

        PageFrameNumber = MiGetPteAddress(CacheBuffer)->Hard.PageFrameNumber;
        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        ASSERT(PageFrame->Busy.Busy != 0);
        ASSERT(PageFrame->Busy.BusyType == MmFsCacheUsage);

        PageFrame->FsCache.ElementIndex = Index;

        CacheBuffer += PAGE_SIZE;
    }

    //
    // Switch to the new array of cache elements.
    //

    if (FscElementArray != NULL) {
        ExFreePool(FscElementArray);
    }

    FscElementArray = NewElementArray;
    FscNumberOfCachePages = NumberOfCachePages;

    //
    // Relink the LRU list of cache elements.
    //

    FscBuildElementLruList();

    return STATUS_SUCCESS;
}

NTSTATUS
FscShrinkCacheSize(
    IN PFN_COUNT NumberOfCachePages
    )
/*++

Routine Description:

    This routine shrinks the number of pages allocated to the file system cache.

Arguments:

    NumberOfCachePages - Specifies the number of pages that should be allocated
        to the file system cache.

Return Value:

    Status of operation.

--*/
{
    PFSCACHE_ELEMENT NewElementArray;
    ULONG PagesToRelease;
    ULONG Index;
    PFSCACHE_ELEMENT Element;
    KIRQL OldIrql;
    ULONG NewIndex;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(NumberOfCachePages < FscNumberOfCachePages);

    //
    // Allocate the new array of cache elements.
    //

    if (NumberOfCachePages != 0) {

        NewElementArray = (PFSCACHE_ELEMENT)ExAllocatePoolWithTag(
            sizeof(FSCACHE_ELEMENT) * NumberOfCachePages, 'AcsF');

        if (NewElementArray == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

#if DBG
        RtlFillMemoryUlong(NewElementArray, sizeof(FSCACHE_ELEMENT) *
            NumberOfCachePages, 'looP');
#endif

    } else {
        NewElementArray = NULL;
    }

    //
    // Compute the number of pages that we need to grab from the existing cache.
    //

    PagesToRelease = FscNumberOfCachePages - NumberOfCachePages;

    //
    // Loop over the file system cache and grab as many free pages as we can.
    //

ReleaseMoreElements:
    for (Index = FscNumberOfCachePages; Index > 0; Index--) {

        Element = &FscElementArray[Index - 1];

        //
        // Check if this element is free and not already marked for deletion.
        //

        if (Element->UsageCount == 0 && !Element->DeletePending) {

            //
            // Mark the element as pending deletion.
            //

            Element->DeletePending = TRUE;
            Element->CacheExtension = NULL;

            //
            // Remove the entry from the LRU list so that other routines no
            // longer can access the element.
            //

            RemoveEntryList(&Element->ListEntry);
            InitializeListHead(&Element->ListEntry);

            //
            // Decrement the number of pages that we've released and check if
            // we've discovered enough free pages.
            //

            PagesToRelease--;

            if (PagesToRelease == 0) {
                break;
            }
        }
    }

    //
    // If we still need to release more pages, then block until more elements
    // become available.  We own FscSetCacheSizeEvent, so we don't have to worry
    // about another thread growing or shrinking the cache out from under us.
    //

    if (PagesToRelease != 0) {

        MI_UNLOCK_MM_AND_THEN_WAIT(PASSIVE_LEVEL);

        KeWaitForSingleObject(&FscWaitingForElementEvent, Executive, KernelMode,
            FALSE, NULL);

        MI_LOCK_MM(&OldIrql);

        goto ReleaseMoreElements;
    }

    //
    // We've now marked the necessary number of pages to delete.  Walk through
    // the array and free up the entries marked for deletion and copy the
    // surviving elements to the new array of cache elements.
    //

    NewIndex = 0;

    for (Index = 0; Index < FscNumberOfCachePages; Index++) {

        Element = &FscElementArray[Index];

        if (Element->DeletePending) {

            //
            // Free the cache buffer.
            //

            MiFreeMappedMemory(&MmSystemPteRange, PAGE_ALIGN(Element->CacheBuffer),
                PAGE_SIZE);

        } else {

            //
            // Transfer the cache buffer to the new array of cache elements.
            //

            NewElementArray[NewIndex] = *Element;

            //
            // Change the index stored in the page frame to be the new array's
            // index.
            //

            PageFrameNumber =
                MiGetPteAddress(Element->CacheBuffer)->Hard.PageFrameNumber;
            PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

            ASSERT(PageFrame->Busy.Busy != 0);
            ASSERT(PageFrame->Busy.BusyType == MmFsCacheUsage);

            PageFrame->FsCache.ElementIndex = NewIndex;

            NewIndex++;
        }
    }

    ASSERT(NewIndex == NumberOfCachePages);

    //
    // Switch to the new array of cache elements.
    //

    ExFreePool(FscElementArray);

    FscElementArray = NewElementArray;
    FscNumberOfCachePages = NumberOfCachePages;

    //
    // Relink the LRU list of cache elements.
    //

    FscBuildElementLruList();

    //
    // Notify as many waiters for free elements as we can so that other threads
    // try to grab free elements given the new element count, which could be
    // zero now.
    //

    while (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
        KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FscSetCacheSize(
    IN PFN_COUNT NumberOfCachePages
    )
/*++

Routine Description:

    This routine changes the number of pages allocated to the file system cache.

Arguments:

    NumberOfCachePages - Specifies the number of pages that should be allocated
        to the file system cache.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;

    KeWaitForSingleObject(&FscSetCacheSizeEvent, Executive, KernelMode, FALSE,
        NULL);

    MI_LOCK_MM(&OldIrql);

    if (NumberOfCachePages > FSCACHE_MAXIMUM_NUMBER_OF_CACHE_PAGES) {
        status = STATUS_INVALID_PARAMETER;
    } else if (NumberOfCachePages > FscNumberOfCachePages) {
        status = FscGrowCacheSize(NumberOfCachePages);
    } else if (NumberOfCachePages < FscNumberOfCachePages) {
        status = FscShrinkCacheSize(NumberOfCachePages);
    } else {
        status = STATUS_SUCCESS;
    }

    MI_UNLOCK_MM(OldIrql);

    KeSetEvent(&FscSetCacheSizeEvent, 0, FALSE);

    return status;
}

PFN_COUNT
FscGetCacheSize(
    VOID
    )
/*++

Routine Description:

    This routine returns the number of pages allocated to the file system cache.

Arguments:

    None.

Return Value:

    Number of pages currently allocated to the file system cache.

--*/
{
    return FscNumberOfCachePages;
}

PFSCACHE_ELEMENT
FscLookupElement(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONG BlockNumber
    )
/*++

Routine Description:

    This routine searches the file system cache for an element that maps the
    block with the supplied block number from the supplied target device.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    The pointer to the element if found, else NULL.

--*/
{
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;

    NextListEntry = FscLruList.Blink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);

        //
        // Check if this element satisfies the search criteria.
        //

        if ((Element->BlockNumber == BlockNumber) &&
            (Element->CacheExtension == CacheExtension)) {

            //
            // Move the element to the end of the LRU list.
            //

            RemoveEntryList(&Element->ListEntry);
            InsertTailList(&FscLruList, &Element->ListEntry);

            return Element;
        }

        //
        // If we find an element with an empty cache extension, then the element
        // doesn't reference valid data.  All free elements are at the front of
        // the LRU list, so we know that we can stop the search now.
        //

        if (Element->CacheExtension == NULL) {
            break;
        }

        NextListEntry = Element->ListEntry.Blink;
    }

    return NULL;
}

PFSCACHE_ELEMENT
FscAllocateElement(
    VOID
    )
/*++

Routine Description:

    This routine allocates an element from the file system cache.  If no
    elements are currently available, it will block until elements do become
    available.

Arguments:

    None.

Return Value:

    The pointer to the allocated element.

--*/
{
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;
    KIRQL OldIrql;

    MI_ASSERT_LOCK_MM();

RetryOperation:
    //
    // If the cache doesn't have any pages allocated to it, then we're never
    // going to be able to allocate an element, so bail out now.
    //

    if (FscNumberOfCachePages == 0) {
        MiDbgPrint(("FSCACHE: cache page required by file system, but cache size is zero.\n"));
        return NULL;
    }

    //
    // Search the LRU list for an unreferenced element.
    //

    NextListEntry = FscLruList.Flink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);

        //
        // Check if this element is free.  If so, detach the element from the
        // LRU list and give it back to the caller.
        //

        if (Element->UsageCount == 0) {
            RemoveEntryList(&Element->ListEntry);
            ASSERT(MiGetPteAddress(Element->CacheBuffer)->Hard.Write == 0);
            return Element;
        }

        NextListEntry = Element->ListEntry.Flink;
    }

    //
    // There aren't any unused pages in the LRU list.  We'll have to block until
    // a page becomes available.
    //

    MI_UNLOCK_MM_AND_THEN_WAIT(APC_LEVEL);

    KeWaitForSingleObject(&FscWaitingForElementEvent, Executive, KernelMode,
        FALSE, NULL);

    MI_LOCK_MM(&OldIrql);

    goto RetryOperation;
}

PFSCACHE_ELEMENT
FscElementFromCacheBuffer(
    PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine returns the element corresponding to the supplied cache buffer
    pointer.

Arguments:

    CacheBuffer - Supplies the pointer to the cache buffer.

Return Value:

    The pointer to the corresponding element.

--*/
{
    PFSCACHE_ELEMENT Element;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    //
    // From any cache virtual address, we can get back to its cache element by
    // going through the page frame database.  We have to acquire the memory
    // manager lock here to make sure the page doesn't move while we're doing
    // the conversion.
    //

    PageFrameNumber = MiGetPteAddress(CacheBuffer)->Hard.PageFrameNumber;
    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    ASSERT(PageFrame->Busy.Busy != 0);
    ASSERT(PageFrame->Busy.BusyType == MmFsCacheUsage);

    Element = &FscElementArray[PageFrame->FsCache.ElementIndex];

    ASSERT(PAGE_ALIGN(Element->CacheBuffer) == PAGE_ALIGN(CacheBuffer));

    return Element;
}

VOID
FASTCALL
FscSetCacheBufferProtection(
    IN PVOID CacheBuffer,
    IN BOOLEAN MapAsReadWrite
    )
/*++

Routine Description:

    This routine is called to change the page protection of the supplied cache
    buffer.

Arguments:

    CacheBuffer - Specifies the cache buffer to change the page protection for.

    MapAsReadWrite - Specifies whether the page should be mapped as read-only or
        read/write.

Return Value:

    None.

--*/
{
    PMMPTE PointerPte;
    MMPTE TempPte;

    MI_ASSERT_LOCK_MM();

    PointerPte = MiGetPteAddress(CacheBuffer);

    TempPte = *PointerPte;

    TempPte.Hard.Write = MapAsReadWrite ? 1 : 0;

    MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
}

NTSTATUS
FscSignalIoEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to signal an event when a thread is blocked on an
    I/O operation inside an IRP dispatch routine.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    KeSetEvent((PKEVENT)Context, IO_DISK_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FscMapBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN BOOLEAN MapAsReadWrite,
    OUT PVOID *ReturnedCacheBuffer
    )
/*++

Routine Description:

    This routine maps the page buffer at the supplied byte offset into the file
    system cache.

    The returned cache buffer will have the same page byte offset as the
    supplied byte offset.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to map into the cache.

    MapAsReadWrite - Specifies whether the page should be mapped as read-only or
        read/write.

    CacheBuffer - Specifies the buffer to receive the pointer to the cache
        buffer.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    ULONG BlockNumber;
    PFSCACHE_ELEMENT Element;
    PVOID CacheBuffer;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;
    ULONG EndingBlockNumber;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(Irp->CurrentLocation > CacheExtension->TargetDeviceObject->StackSize);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);

RetryOperation:
    MI_LOCK_MM(&OldIrql);

    //
    // Attempt to find the requested block number in the file system cache.
    //

    BlockNumber = FscByteOffsetToBlockNumber(ByteOffset);
    Element = FscLookupElement(CacheExtension, BlockNumber);

    if (Element != NULL) {

        //
        // The element was found.  If there's I/O in progress for the element,
        // then we need to block until the I/O is complete.  Most likely,
        // another thread is in the process of reading the block we need.
        //

        if (!Element->ReadInProgress) {

            Element->UsageCount++;

            CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

            if (MapAsReadWrite) {
                FscSetCacheBufferProtection(CacheBuffer, TRUE);
            } else {
                ASSERT(MiGetPteAddress(CacheBuffer)->Hard.Write == 0);
            }

            *ReturnedCacheBuffer = (PCHAR)CacheBuffer + BYTE_OFFSET(ByteOffset);

            MI_UNLOCK_MM(OldIrql);

            return STATUS_SUCCESS;
        }

        //
        // Mark the element so that the original thread knows that somebody is
        // waiting for a read operation to complete.
        //

        Element->ReadWaiters = TRUE;

        //
        // Contention should happen fairly infrequently since file system access
        // will likely happen on a small number of threads.  So we use one event
        // for all collided calls to FscMapBuffer.
        //

        MI_UNLOCK_MM_AND_THEN_WAIT(OldIrql);

        KeWaitForSingleObject(&FscCollidedMapBufferEvent, Executive, KernelMode,
            FALSE, NULL);

        goto RetryOperation;
    }

    //
    // Allocate an element to receive the page.  We could get a NULL back from
    // this routine if the cache has been scaled back to zero pages.
    //

    Element = FscAllocateElement();

    if (Element == NULL) {
        MI_UNLOCK_MM(OldIrql);
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the element with our block number and cache extension and
    // insert the element at the tail of the LRU list.  The element is marked so
    // that other threads know that we're currently reading the cache buffer
    // into memory.
    //

    Element->BlockNumber = BlockNumber;
    Element->CacheExtension = CacheExtension;
    Element->UsageCount = 1;
    Element->ReadInProgress = TRUE;
    ASSERT(!Element->ReadWaiters);

    InsertTailList(&FscLruList, &Element->ListEntry);

    //
    // Lock down the cache buffer.
    //

    CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);
    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, FALSE);

    //
    // Leave the memory manager lock so that we can block for the I/O operation.
    //

    MI_UNLOCK_MM(OldIrql);

    //
    // Initialize the event used to block for completion of the I/O operation
    // and set the completion routine that will signal this event.
    //

    KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
        TRUE, TRUE);

    //
    // Initialize the next IRP stack location for the I/O operation.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = IRP_MJ_READ;
    IrpSp->Flags = SL_FSCACHE_REQUEST;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = (ULONGLONG)BlockNumber <<
        PAGE_SHIFT;
    IrpSp->Parameters.Read.CacheBuffer = CacheBuffer;

    //
    // Compute the number of bytes that we're going to read.  The length of the
    // partition is not necessarily page aligned, so we have to be careful to
    // request a legal number of bytes.
    //

    EndingBlockNumber =
        FscByteOffsetToBlockNumber(CacheExtension->PartitionLength.QuadPart);

    if (BlockNumber < EndingBlockNumber) {
        IrpSp->Parameters.Read.Length = PAGE_SIZE;
    } else {
        IrpSp->Parameters.Read.Length =
            BYTE_OFFSET(CacheExtension->PartitionLength.LowPart);
        ASSERT(BlockNumber == EndingBlockNumber);
        ASSERT(IrpSp->Parameters.Read.Length != 0);
    }

    //
    // Submit the request to the target device and wait for the I/O operation to
    // complete.
    //

    status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&IoEvent, WrFsCacheIn, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    MI_LOCK_MM(&OldIrql);

    //
    // Unlock the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, TRUE);

    //
    // Recompute the pointer to the cache element to guard against somebody
    // changing the size of the cache out from under us and causing the old
    // cache element pointer to become invalid.
    //

    Element = FscElementFromCacheBuffer(CacheBuffer);

    ASSERT(Element->BlockNumber == BlockNumber);
    ASSERT(Element->UsageCount == 1);
    ASSERT(Element->ReadInProgress);

    //
    // Clear the read in progress flag from the cache element.  If anybody is
    // waiting for this buffer to be mapped, then signal the collision event so
    // that everybody goes and checks if their page is available.  If an error
    // occurred reading in the page, the other threads won't see that error but
    // will have to call down to the lower driver themselves.  That's equivalent
    // to the same thread attempting to read in the same page multiple times and
    // failing.
    //

    Element->ReadInProgress = FALSE;

    if (Element->ReadWaiters) {
        KePulseEvent(&FscCollidedMapBufferEvent, IO_DISK_INCREMENT, FALSE);
        Element->ReadWaiters = FALSE;
    }

    //
    // If we successfully read the page in, then return the address of the cache
    // buffer to the caller.  Otherwise, discard the cache buffer.
    //

    if (NT_SUCCESS(status)) {

        if (MapAsReadWrite) {
            FscSetCacheBufferProtection(CacheBuffer, TRUE);
        } else {
            ASSERT(MiGetPteAddress(CacheBuffer)->Hard.Write == 0);
        }

        *ReturnedCacheBuffer = (PCHAR)CacheBuffer + BYTE_OFFSET(ByteOffset);

    } else {
        FscDiscardBuffer(CacheBuffer);
    }

    MI_UNLOCK_MM(OldIrql);

    return status;
}

NTSTATUS
FscMapEmptyBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    OUT PVOID *CacheBuffer
    )
/*++

Routine Description:

    This routine maps the page buffer at the supplied byte offset into the file
    system cache if the buffer is already present in the cache.  If the buffer
    is not present in the cache, then an uninitialized page is returned instead.
    This routine is intended for writes of page sized buffers through the cache.

    The supplied byte offset must be page aligned.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    ByteOffset - Specifies the byte offset to map into the cache.

    CacheBuffer - Specifies the buffer to receive the pointer to the cache
        buffer.

Return Value:

    Status of operation.

--*/
{
    KIRQL OldIrql;
    ULONG BlockNumber;
    PFSCACHE_ELEMENT Element;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT(BYTE_OFFSET(ByteOffset) == 0);

    MI_LOCK_MM(&OldIrql);

    //
    // Attempt to find the requested block number in the file system cache.
    //

    BlockNumber = FscByteOffsetToBlockNumber(ByteOffset);
    Element = FscLookupElement(CacheExtension, BlockNumber);

    if (Element != NULL) {

        ASSERT(!Element->ReadInProgress);

        Element->UsageCount++;

        //
        // Make the cache buffer writable.
        //

        FscSetCacheBufferProtection(Element->CacheBuffer, TRUE);

        //
        // Fill the cache buffer with 0xFFs to reduce signal noise when writing
        // to a memory unit (MU) device.
        //

        RtlFillMemory(PAGE_ALIGN(Element->CacheBuffer), PAGE_SIZE, (ULONG)-1);

        *CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

        MI_UNLOCK_MM(OldIrql);

        return STATUS_SUCCESS;
    }

    //
    // Allocate an element to receive the page.  We could get a NULL back from
    // this routine if the cache has been scaled back to zero pages.
    //

    Element = FscAllocateElement();

    if (Element == NULL) {
        MI_UNLOCK_MM(OldIrql);
        return STATUS_NO_MEMORY;
    }

    //
    // All we want is an empty page, so we just need to initialize the element
    // with our block number and cache extension and insert the element at the
    // tail of the LRU list.
    //

    Element->BlockNumber = BlockNumber;
    Element->CacheExtension = CacheExtension;
    Element->UsageCount = 1;
    ASSERT(!Element->ReadInProgress);
    ASSERT(!Element->ReadWaiters);

    InsertTailList(&FscLruList, &Element->ListEntry);

    //
    // Make the cache buffer writable.
    //

    FscSetCacheBufferProtection(Element->CacheBuffer, TRUE);

    //
    // Fill the cache buffer with 0xFFs to reduce signal noise when writing to a
    // memory unit (MU) device.
    //

    RtlFillMemory(PAGE_ALIGN(Element->CacheBuffer), PAGE_SIZE, (ULONG)-1);

    *CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

    MI_UNLOCK_MM(OldIrql);

    return STATUS_SUCCESS;
}

NTSTATUS
FscWriteBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength,
    IN PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine writes out the contents of the supplied cache buffer to the
    target device.

    Although the cache buffer is PAGE_SIZE bytes in length, this routine may
    only write enough sectors to contain the starting byte offset and the
    specified number of bytes.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start writing to.

    WriteLength - Specifies the number of bytes that have been dirtied in the
        cache.

    CacheBuffer - Specifies the address of the cache buffer to start writing
        from.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG SectorMask;
    ULONGLONG EndingByteOffset;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(Irp->CurrentLocation > CacheExtension->TargetDeviceObject->StackSize);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((ByteOffset + WriteLength) <= (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((BYTE_OFFSET(ByteOffset) + WriteLength) <= PAGE_SIZE);
    ASSERT(MiGetPteAddress(CacheBuffer)->Hard.Write != 0);

    //
    // Align the byte offset and length to sector boundaries.
    //

    SectorMask = CacheExtension->SectorSize - 1;
    EndingByteOffset = (ByteOffset + WriteLength + SectorMask) & ~((ULONGLONG)SectorMask);
    ByteOffset = ByteOffset & ~((ULONGLONG)SectorMask);
    WriteLength = (ULONG)(EndingByteOffset - ByteOffset);
    CacheBuffer = (PCHAR)PAGE_ALIGN(CacheBuffer) + BYTE_OFFSET(ByteOffset);

    ASSERT(EndingByteOffset <= (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((BYTE_OFFSET(ByteOffset) + WriteLength) <= PAGE_SIZE);

    //
    // Lock down the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, WriteLength, FALSE);

    //
    // Initialize the event used to block for completion of the I/O operation
    // and set the completion routine that will signal this event.
    //

    KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
        TRUE, TRUE);

    //
    // Initialize the next IRP stack location for the I/O operation.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = IRP_MJ_WRITE;
    IrpSp->Flags = SL_FSCACHE_REQUEST;
    IrpSp->Parameters.Write.ByteOffset.QuadPart = ByteOffset;
    IrpSp->Parameters.Write.Length = WriteLength;
    IrpSp->Parameters.Write.CacheBuffer = CacheBuffer;

    //
    // Submit the request to the target device and wait for the I/O operation to
    // complete.
    //

    status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&IoEvent, WrFsCacheOut, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    //
    // Unlock the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, WriteLength, TRUE);

    //
    // Unmap or discard the buffer.
    //

    if (NT_SUCCESS(status)) {
        FscUnmapBuffer(CacheBuffer);
    } else {
        FscDiscardBuffer(CacheBuffer);
    }

    return status;
}

VOID
FscUnmapBuffer(
    PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine unmaps the supplied page buffer that was obtained from a call
    to FscMapBuffer.  The buffer remains in the file system cache until another
    request reclaims the memory.

Arguments:

    CacheBuffer - Specifies the cache buffer to unmap.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    //
    // Change the protection of the cache buffer back to read-only if necessary.
    //

    if (MiGetPteAddress(CacheBuffer)->Hard.Write != 0) {
        FscSetCacheBufferProtection(CacheBuffer, FALSE);
    }

    //
    // Obtain the element corresponding to the supplied cache buffer.
    //

    Element = FscElementFromCacheBuffer(CacheBuffer);

    ASSERT(Element->UsageCount > 0);

    //
    // Decrement the reference count for the element and signal anybody waiting
    // for a cache page.
    //
    // Note that setting the cache buffer back to its page aligned address
    // zeroes out the usage count and various flags.
    //

    Element->UsageCount--;

    if (Element->UsageCount == 0) {

        Element->CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

        if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
            KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
        }
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
FscDiscardBuffer(
    PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine unmaps and discards the supplied page buffer that was obtained
    from a call to FscMapBuffer or FscMapEmptyBuffer.  The buffer is marked as
    being free in the system cache.  This is intended to be called after failing
    to write out a dirty cache buffer so that a subsequent mapping obtains the
    original buffer.

    Note that this routine is also called in the error path of FscMapBuffer.

Arguments:

    CacheBuffer - Specifies the cache buffer to discard.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    //
    // Change the protection of the cache buffer back to read-only.
    //

    FscSetCacheBufferProtection(CacheBuffer, FALSE);

    //
    // Obtain the element corresponding to the supplied cache buffer.
    //

    Element = FscElementFromCacheBuffer(CacheBuffer);

    ASSERT(!Element->DeletePending);
    ASSERT(Element->UsageCount == 1);

    //
    // Release the reference on the page, null out the cache extension so that
    // we don't try to map the page again, and insert it at the front of the LRU
    // list.
    //
    // Note that setting the cache buffer back to its page aligned address
    // zeroes out the usage count and various flags.
    //

    Element->CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);
    Element->CacheExtension = NULL;

    ASSERT(Element->UsageCount == 0);

    RemoveEntryList(&Element->ListEntry);
    InsertHeadList(&FscLruList, &Element->ListEntry);

    if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
        KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
    }

    MI_UNLOCK_MM(OldIrql);
}

NTSTATUS
FscWriteFFs(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength
    )
/*++

Routine Description:

    This routine writes out the supplied number of 0xFF bytes to the target
    device.  Only a single cache buffer at the supplied byte offset is dirtied
    for the I/O operation.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start writing to.

    WriteLength - Specifies the number of 0xFF bytes to write out; this number
        should be a multiple of the sector size.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    MMPTE TempPte;
    PMMPTE PointerPte;
    ULONG Index;
    ULONG WriteBytesRemaining;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((ByteOffset + WriteLength) <= (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT(BYTE_OFFSET(ByteOffset) == 0);
    ASSERT(WriteLength > 0);
    ASSERT((WriteLength & (CacheExtension->SectorSize - 1)) == 0);

    //
    // Synchronize access to FscWriteFFsPtes.
    //

    RtlEnterCriticalSection(&FscWriteFFsLock);

    //
    // Allocate a cache buffer for the operation.
    //

    status = FscMapEmptyBuffer(CacheExtension, ByteOffset, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // If we're writing out more than a page worth of data, then invalidate any
    // other pages from the dirty byte range.
    //

    if (WriteLength > PAGE_SIZE) {
        FscInvalidateByteRange(CacheExtension, ByteOffset + PAGE_SIZE,
            WriteLength - PAGE_SIZE);
    }

    //
    // Initialize the contents of this cache buffer.
    //

    RtlFillMemory(CacheBuffer, PAGE_SIZE, (ULONG)-1);

    //
    // Lock down the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, FALSE);

    //
    // Copy the page table entry for the cache buffer to the "write 0xFF" PTEs.
    // The cache buffer is locked down, so we can safely map the page multiple
    // times without fear that the page will be relocated out from under us.
    //

    TempPte = *MiGetPteAddress(CacheBuffer);
    PointerPte = FscWriteFFsPtes;

    for (Index = 0; Index < FSCACHE_NUMBER_OF_WRITE_FF_PTES; Index++) {
        MI_WRITE_PTE(PointerPte, TempPte);
        PointerPte++;
    }

    //
    // Write out chunks of pages until we've exhausted the requested write
    // length.
    //

    WriteBytesRemaining = WriteLength;

    do {

        //
        // Compute the number of bytes to write out in this iteration.
        //

        WriteLength = PAGE_SIZE * FSCACHE_NUMBER_OF_WRITE_FF_PTES;

        if (WriteLength > WriteBytesRemaining) {
            WriteLength = WriteBytesRemaining;
        }

        //
        // Initialize the event used to block for completion of the I/O operation
        // and set the completion routine that will signal this event.
        //

        KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

        IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
            TRUE, TRUE);

        //
        // Initialize the next IRP stack location for the I/O operation.
        //

        IrpSp = IoGetNextIrpStackLocation(Irp);

        IrpSp->MajorFunction = IRP_MJ_WRITE;
        IrpSp->Flags = SL_FSCACHE_REQUEST;
        IrpSp->Parameters.Write.ByteOffset.QuadPart = ByteOffset;
        IrpSp->Parameters.Write.Length = WriteLength;
        IrpSp->Parameters.Write.CacheBuffer =
            MiGetVirtualAddressMappedByPte(FscWriteFFsPtes);

        //
        // Submit the request to the target device and wait for the I/O operation to
        // complete.
        //

        status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&IoEvent, WrFsCacheOut, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            break;
        }

        ByteOffset += WriteLength;
        WriteBytesRemaining -= WriteLength;

    } while (WriteBytesRemaining > 0);

    //
    // Clear the double mapping from the "write 0xFF" PTEs.
    //

    MiZeroAndFlushPtes(FscWriteFFsPtes, FSCACHE_NUMBER_OF_WRITE_FF_PTES);

    //
    // Unlock the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, TRUE);

    //
    // Unmap or discard the buffer.
    //

    if (NT_SUCCESS(status)) {
        FscUnmapBuffer(CacheBuffer);
    } else {
        FscDiscardBuffer(CacheBuffer);
    }

CleanupAndExit:
    RtlLeaveCriticalSection(&FscWriteFFsLock);

    return status;
}

BOOLEAN
FscTestForFullyCachedIo(
    IN PIRP Irp,
    IN ULONG ByteOffsetLowPart,
    IN ULONG IoLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine tests the supplied transfer parameters to see if the transfer
    should be handled through a fully cached path, where all bytes are
    transferred using the file system cache, or a partially cached path, where
    whole pages are transferred using non-cached I/O requests and partial pages
    are transferered using the file system cache.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

    ByteOffsetLowPart - Specifies the lower 32-bits of the transfer byte offset.

    IoLength - Specifies the number of bytes to transfer.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Returns TRUE if the transfer should go through a fully cached path, else
    FALSE.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG AlignmentRequirement;
    ULONG EndingByteOffsetLowPart;

    ASSERT(IoLength != 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Check if the file object was opened for random access.  If so, then we'll
    // copy through the cache so that the pages stay resident in the cache as
    // long as possible.
    //

    if (MiIsFlagClear(IrpSp->FileObject->Flags, FO_RANDOM_ACCESS)) {

        //
        // Check if the starting file byte offset or user buffer are misaligned.
        // If so, then we need to go through the fully cached path since the
        // hardware won't be able to directly deal with these buffers.
        //

        AlignmentRequirement = IrpSp->DeviceObject->AlignmentRequirement;

        if (((IrpSp->Parameters.Read.ByteOffset.LowPart & AlignmentRequirement) == 0) &&
            ((BYTE_OFFSET(Irp->UserBuffer) & AlignmentRequirement) == 0)) {

            if (NonCachedEndOfFileTransfer) {

                //
                // Compute the ending byte offset truncated down to the nearest
                // page and the starting byte offset truncated down to the
                // nearest page.  If these aren't the same byte offsets, then
                // there's some number of bytes on a different cache page than
                // the starting byte offset, so use the partially cached paths
                // to avoid using the cache for any middle pages or the partial
                // tail page.
                //
                // If we've reached this code, then we already know that this is
                // a read request and that the transfer buffer is large enough
                // to handle a partial sector I/O transfer.
                //

                if (BYTE_OFFSET(ByteOffsetLowPart) == 0) {
                    return FALSE;
                }

                EndingByteOffsetLowPart = ByteOffsetLowPart + IoLength;

                if ((BYTE_OFFSET(EndingByteOffsetLowPart) != 0) &&
                    (PAGE_ALIGN(ByteOffsetLowPart) != PAGE_ALIGN(EndingByteOffsetLowPart))) {
                    return FALSE;
                }

            } else if (IoLength >= PAGE_SIZE) {

                //
                // Compute the ending byte offset truncated down to the nearest
                // page and the starting byte offset rounded up to the nearest
                // page.  If these aren't the same byte offsets, then the
                // transfer contains at least one whole page, so use the
                // partially cached paths to avoid using the cache for these
                // middle pages.
                //
                // We only go through this code for the case where the transfer
                // length is greater than a page to handle the case of the
                // starting and ending byte offset residing on the same cache
                // page.
                //

                EndingByteOffsetLowPart = (ULONG)PAGE_ALIGN(ByteOffsetLowPart + IoLength);
                ByteOffsetLowPart = ROUND_TO_PAGES(ByteOffsetLowPart);

                if (ByteOffsetLowPart != EndingByteOffsetLowPart) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

NTSTATUS
FscPartiallyCachedRead(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG ReadLength,
    IN ULONG BufferByteOffset,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine reads the supplied number of bytes from the supplied starting
    byte offset to IRP.UserBuffer plus the supplied buffer byte offset.  This
    routine reads whole pages using direct I/O into the read buffer and,
    if necessary, reads the tail page using a file system cache buffer.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start reading from.  The byte
        offset must be page aligned.

    ReadLength - Specifies the number of bytes to read.  The number of bytes
        must be greater than or equal to the page size.

    BufferByteOffset - Specifies the offset into IRP.UserBuffer to start reading
        the data.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG PartialReadLength;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;
    PVOID CacheBuffer;

    ASSERT(BYTE_OFFSET(ByteOffset) == 0);

    //
    // If NonCachedEndOfFileTransfer is TRUE, then we're reading to the end of
    // the file and the transfer buffer is large enough to hold the transfer
    // length rounded up to a sector boundary.
    //

    if (NonCachedEndOfFileTransfer) {
        ReadLength = FscRoundToSectors(CacheExtension, ReadLength);
        PartialReadLength = ReadLength;
    } else {
        ASSERT(ReadLength >= PAGE_SIZE);
        PartialReadLength = (ULONG)PAGE_ALIGN(ReadLength);
    }

    //
    // Initialize the event used to block for completion of the I/O operation
    // and set the completion routine that will signal this event.
    //

    KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
        TRUE, TRUE);

    //
    // Initialize the next IRP stack location for the I/O operation.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = IRP_MJ_READ;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = ByteOffset;
    IrpSp->Parameters.Read.Length = PartialReadLength;
    IrpSp->Parameters.Read.BufferOffset = BufferByteOffset;

    //
    // Submit the request to the target device and wait for the I/O operation to
    // complete.
    //

    status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&IoEvent, WrFsCacheIn, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    //
    // Transfer the remaining non whole page of the request if necessary.
    //

    if (NT_SUCCESS(status)) {

        ReadLength -= PartialReadLength;

        if (ReadLength > 0) {

            ByteOffset += PartialReadLength;
            BufferByteOffset += PartialReadLength;

            status = FscMapBuffer(CacheExtension, Irp, ByteOffset, FALSE,
                &CacheBuffer);

            if (NT_SUCCESS(status)) {
                RtlCopyMemory((PUCHAR)Irp->UserBuffer + BufferByteOffset,
                    CacheBuffer, ReadLength);
                FscUnmapBuffer(CacheBuffer);
            }
        }
    }

    return status;
}

NTSTATUS
FscCachedRead(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG ReadLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine reads the supplied number of bytes from the supplied starting
    byte offset to IRP.UserBuffer.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start reading from.

    ReadLength - Specifies the number of bytes to read.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PVOID UserBuffer;
    ULONG BytesRemaining;
    PVOID CacheBuffer;
    ULONG BytesToCopy;
    ULONG BufferByteOffset;
    ULONG PartialIoLength;
    PFILE_OBJECT FileObject;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    UserBuffer = Irp->UserBuffer;
    BytesRemaining = ReadLength;

    //
    // Check if this transfer should use the fully or partially cached path.
    //

    if (FscTestForFullyCachedIo(Irp, (ULONG)ByteOffset, ReadLength,
        NonCachedEndOfFileTransfer)) {

        //
        // Map each page into the cache and copy the contents into the user's
        // buffer.
        //

        do {

            //
            // Map the physical byte offset into the cache.
            //

            status = FscMapBuffer(CacheExtension, Irp, ByteOffset, FALSE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Compute the number of bytes to copy from this cache page.
            //

            BytesToCopy = PAGE_SIZE - BYTE_OFFSET(ByteOffset);

            if (BytesToCopy > BytesRemaining) {
                BytesToCopy = BytesRemaining;
            }

            //
            // Copy the bytes from the cache page and unmap the cache buffer.
            //

            RtlCopyMemory(UserBuffer, CacheBuffer, BytesToCopy);
            FscUnmapBuffer(CacheBuffer);

            //
            // Advance to the next physical byte offset, which now will be page
            // aligned, and adjust our other loop variables.
            //

            ByteOffset = (ByteOffset + PAGE_SIZE) & ~(PAGE_SIZE - 1);
            UserBuffer = (PUCHAR)UserBuffer + BytesToCopy;
            BytesRemaining -= BytesToCopy;

        } while (BytesRemaining > 0);

    } else {

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp,
            IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length);

        //
        // Transfer the head of the request if it's not page aligned.
        //

        if (BYTE_OFFSET(ByteOffset) != 0) {

            PartialIoLength = PAGE_SIZE - BYTE_OFFSET(ByteOffset);

            ASSERT(PartialIoLength < BytesRemaining);

            //
            // Map the physical byte offset into the cache.
            //

            status = FscMapBuffer(CacheExtension, Irp, ByteOffset, FALSE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Copy the bytes from the cache page and unmap the cache buffer.
            //

            RtlCopyMemory(UserBuffer, CacheBuffer, PartialIoLength);
            FscUnmapBuffer(CacheBuffer);

            //
            // Advance to the next physical byte offset, which now will be page
            // aligned.
            //

            BytesRemaining -= PartialIoLength;
            ByteOffset += PartialIoLength;
            BufferByteOffset = PartialIoLength;

        } else {
            BufferByteOffset = 0;
        }

        ASSERT(BYTE_OFFSET(ByteOffset) == 0);

        //
        // Transfer the body and tail of the request using the file system
        // cache to handle the tail page.
        //

        status = FscPartiallyCachedRead(CacheExtension, Irp, ByteOffset,
            BytesRemaining, BufferByteOffset, NonCachedEndOfFileTransfer);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    FileObject = IrpSp->FileObject;

    if (MiIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.QuadPart =
            IrpSp->Parameters.Read.ByteOffset.QuadPart + ReadLength;
    }

    //
    // Fill in the number of bytes actually read.
    //

    Irp->IoStatus.Information = ReadLength;

    return STATUS_SUCCESS;
}

VOID
FscInvalidateBlocks(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONG BlockNumber,
    IN ULONG EndingBlockNumber
    )
/*++

Routine Description:

    This routine invalidates any buffers in the supplied byte range for the
    supplied cache extension.

Arguments:

    CacheExtension - Specifies the cache extension to invalidate.

    BlockNumber - Specifies the block number to start invalidating buffers from.

    EndingBlockNumber - Specifies the block number, inclusive, to stop
        invalidating buffers from.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    NextListEntry = FscLruList.Blink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);
        NextListEntry = Element->ListEntry.Blink;

        //
        // If we find an element with an empty cache extension, then the element
        // doesn't reference valid data.  All free elements are at the front of
        // the LRU list, so we know that we can stop the search now.
        //

        if (Element->CacheExtension == NULL) {
            break;
        }

        //
        // Does this element hold data from the given cache extension and block
        // number range and is the element idle?
        //

        if ((Element->CacheExtension == CacheExtension) &&
            (Element->BlockNumber >= BlockNumber) &&
            (Element->BlockNumber <= EndingBlockNumber) &&
            (Element->UsageCount == 0)) {

            ASSERT(!Element->DeletePending);
            ASSERT(Element->UsageCount == 0);

            //
            // We found a cache element with the desired attributes.  Mark the
            // element as free and move it to the beginning of the LRU list.
            //

            Element->CacheExtension = NULL;

            RemoveEntryList(&Element->ListEntry);
            InsertHeadList(&FscLruList, &Element->ListEntry);

            //
            // Release another waiter for a free element if necessary.
            //

            if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
                KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
            }
        }
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
FscInvalidateDevice(
    IN PFSCACHE_EXTENSION CacheExtension
    )
/*++

Routine Description:

    This routine invalidates any buffers for the supplied cache extension.

Arguments:

    CacheExtension - Specifies the cache extension to invalidate.

Return Value:

    None.

--*/
{
    //
    // Invalidate all blocks for the supplied cache extension.
    //

    FscInvalidateBlocks(CacheExtension, 0, MAXULONG);
}

VOID
FscInvalidateByteRange(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine invalidates any buffers in the supplied byte range for the
    supplied cache extension.

    This routine assumes that it is called from within an exclusive writer lock
    for the supplied cache extension.  No buffers from the supplied cache
    extension map be actively mapped.

Arguments:

    CacheExtension - Specifies the cache extension to invalidate.

    ByteOffset - Specifies the byte offset to start invalidating buffers from.

    Length - Specifies the number of bytes to invalidate.

Return Value:

    None.

--*/
{
    ULONG BlockNumber;
    ULONG EndingBlockNumber;

    ASSERT(Length != 0);

    BlockNumber = FscByteOffsetToBlockNumber(ByteOffset);
    EndingBlockNumber = FscByteOffsetToBlockNumber(ByteOffset + Length - 1);

    FscInvalidateBlocks(CacheExtension, BlockNumber, EndingBlockNumber);
}

VOID
FscInvalidateIdleBlocks(
    VOID
    )
/*++

Routine Description:

    This routine invalidates any buffers that are not currently marked as busy.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    NextListEntry = FscLruList.Blink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);
        NextListEntry = Element->ListEntry.Blink;

        //
        // If we find an element with an empty cache extension, then the element
        // doesn't reference valid data.  All free elements are at the front of
        // the LRU list, so we know that we can stop the search now.
        //

        if (Element->CacheExtension == NULL) {
            break;
        }

        //
        // Is the element idle?
        //

        if (Element->UsageCount == 0) {

            ASSERT(!Element->DeletePending);

            //
            // We found a cache element with the desired attributes.  Mark the
            // element as free and move it to the beginning of the LRU list.
            //

            Element->CacheExtension = NULL;

            RemoveEntryList(&Element->ListEntry);
            InsertHeadList(&FscLruList, &Element->ListEntry);

            //
            // Release another waiter for a free element if necessary.
            //

            if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
                KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
            }
        }
    }

    MI_UNLOCK_MM(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\debugsup.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    debugsup.c

Abstract:

    This module implements routines which provide support for the debugger.

--*/

#include "mi.h"

PVOID
MmDbgWriteCheck(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    )
/*++

Routine Description:

    i386/486 implementation specific:

    This routine checks the specified virtual address and if it is
    valid and writable, it returns that virtual address, otherwise
    it returns NULL.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

    Opaque - Supplies an opaque pointer.

Return Value:

    Returns NULL if the address is not valid or writable, otherwise
    returns the virtual address.

Environment:

    Kernel mode IRQL at DISPATCH_LEVEL or greater.

--*/
{
    PMMPTE InputPte;
    PMMPTE PointerPte;
    MMPTE TempPte;

    InputPte = (PMMPTE)Opaque;
    InputPte->Long = 0;

    if (!MmIsAddressValid(VirtualAddress)) {
        return NULL;
    }

    PointerPte = MiGetPdeAddress(VirtualAddress);
    if (PointerPte->Hard.LargePage == 0) {
        PointerPte = MiGetPteAddress(VirtualAddress);
    }

    if (PointerPte->Hard.Write == 0) {

        TempPte = *PointerPte;

        *InputPte = TempPte;

        TempPte.Hard.Write = 1;

        MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
    }

    return VirtualAddress;
}

VOID
MmDbgReleaseAddress(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    )
/*++

Routine Description:

    i386/486 implementation specific:

    This routine resets the specified virtual address access permissions
    to its original state.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

    Opaque - Supplies an opaque pointer.

Return Value:

    None.

Environment:

    Kernel mode IRQL at DISPATCH_LEVEL or greater.

--*/
{
    MMPTE TempPte;
    PMMPTE PointerPte;
    PMMPTE InputPte;

    InputPte = (PMMPTE)Opaque;

    ASSERT(MmIsAddressValid(VirtualAddress));

    if (InputPte->Long != 0) {

        PointerPte = MiGetPdeAddress(VirtualAddress);
        if (PointerPte->Hard.LargePage == 0) {
            PointerPte = MiGetPteAddress(VirtualAddress);
        }

        TempPte = *InputPte;

        MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
    }
}

PVOID64
MmDbgTranslatePhysicalAddress64(
    IN PHYSICAL_ADDRESS PhysicalAddress
    )
/*++

Routine Description:

    i386/486 implementation specific:

    This routine maps the specified physical address and returns
    the virtual address which maps the physical address.

    The next call to MmDbgTranslatePhysicalAddress removes the
    previous physical address translation, hence only a single
    physical address can be examined at a time (can't cross page
    boundaries).

Arguments:

    PhysicalAddress - Supplies the physical address to map and translate.

Return Value:

    The virtual address which corresponds to the physical address.

Environment:

    Kernel mode IRQL at DISPATCH_LEVEL or greater.

--*/
{
    PMMPTE DebugPde;
    MMPTE TempPte;

    DebugPde = MiGetPdeAddress(MM_DEBUG_VA);

    TempPte.Long = MiGetValidKernelPteBits();
    MI_DISABLE_CACHING(TempPte);
    TempPte.Long |= (PhysicalAddress.LowPart & (~((1 << PAGE_SHIFT_LARGE) - 1)));
    TempPte.Hard.LargePage = 1;

    MI_WRITE_PTE(DebugPde, TempPte);
    MI_FLUSH_VA((PVOID)MM_DEBUG_VA);

    return (PVOID64)((ULONG)MM_DEBUG_VA + BYTE_OFFSET_LARGE(PhysicalAddress.LowPart));
}

#ifdef DEVKIT

PVOID
MmDbgAllocateMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    )
/*++

Routine Description:

    This routine allocates a range of memory in the debugger portion of the
    address space.  The pages are allocated from the extra memory pool available
    on development systems.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

    NULL - The specified request could not be satisfied.

Environment:

    Kernel mode, <= DISPATCH_LEVEL

--*/
{
    return MiAllocateMappedMemory(&MmDeveloperKitPteRange, MmDebuggerUsage,
        Protect, NumberOfBytes, MmDeveloperKitPteRange.RemovePageRoutine, FALSE);
}

ULONG
MmDbgFreeMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This routine deallocates a range of memory in the debugger portion of the
    address space.  This is designed to free pages acquired via
    MmDbgAllocateMemory only.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

    NumberOfBytes - Supplies the number of bytes allocated to the request.
                    This number can be zero to free the original size passed to
                    MmDbgAllocateMemory.

Return Value:

    Returns the number of pages deallocated.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    return MiFreeMappedMemory(&MmDeveloperKitPteRange, BaseAddress, NumberOfBytes);
}

PFN_COUNT
MmDbgQueryAvailablePages(
    VOID
    )
/*++

Routine Description:

    This routine returns the number of available pages in the extra memory
    region available on development kits.

Arguments:

    None.

Return Value:

    Number of available pages.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    //
    // Instead of using MmDeveloperKitPfnRegion, indirect through
    // MmDeveloperKitPteRange so that we handle the case of the DVT with only
    // 64 megabytes of memory.
    //

    return *MmDeveloperKitPteRange.AvailablePages;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\mmfault.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    mmfault.c

Abstract:

    This module contains the handlers for access check, page faults
    and write faults.

--*/

#include "mi.h"

NTSTATUS
MmAccessFault(
    IN BOOLEAN StoreInstruction,
    IN PVOID VirtualAddress,
    IN PVOID TrapInformation
    )
/*++

Routine Description:

    This function is called by the kernel on data or instruction
    access faults.  The access fault was detected due to either
    an access violation, a PTE with the present bit clear, or a
    valid PTE with the dirty bit clear and a write operation.

    Also note that the access violation and the page fault could
    occur because of the Page Directory Entry contents as well.

    This routine determines what type of fault it is and calls
    the appropriate routine to handle the page fault or the write
    fault.

Arguments:

    StoreInstruction - Supplies TRUE (1) if the operation causes a write into
                       memory.  Note this value must be 1 or 0.

    VirtualAddress - Supplies the virtual address which caused the fault.

    TrapInformation - Opaque information about the trap, interpreted by the
                      kernel, not Mm.  Needed to allow fast interlocked access
                      to operate correctly.

Return Value:

    Returns the status of the fault handling operation.  Can be one of:
        - Success.
        - Access Violation.
        - Guard Page Violation.
        - In-page Error.

Environment:

    Kernel mode, APCs disabled.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    PMMPTE PointerPte;
    MMPTE TempPte;
    ULONG PteProtectionMask;
    ULONG Protect;

    //
    // No page fault can be handled at DISPATCH_LEVEL or greater.
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        status = STATUS_IN_PAGE_ERROR | 0x10000000;
        goto ReturnStatusCode;
    }

    //
    // Determine if this is an access violation or a guard page violation.
    //

    status = STATUS_ACCESS_VIOLATION;

    if ((VirtualAddress >= MM_LOWEST_USER_ADDRESS) &&
        (VirtualAddress <= MM_HIGHEST_VAD_ADDRESS)) {

        MI_LOCK_ADDRESS_SPACE();

        MI_LOCK_MM(&OldIrql);

        if (MiGetPdeAddress(VirtualAddress)->Hard.Valid == 1) {

            PointerPte = MiGetPteAddress(VirtualAddress);
            TempPte = *PointerPte;

            //
            // Check if the PTE is marked committed.  Note that we don't just
            // check the Valid bit because the page may be a PAGE_NOACCESS or
            // PAGE_GUARD protected page.
            //

            if (TempPte.Long != 0) {

                PteProtectionMask = (TempPte.Long & MM_PTE_PROTECTION_MASK);
                Protect = MiDecodePteProtectionMask(PteProtectionMask);

                if (Protect & PAGE_GUARD) {

                    //
                    // This is a guard page.  Clear the guard page protection
                    // for this page and return the correct violation status.
                    //

                    MiMakePteProtectionMask(Protect & ~PAGE_GUARD,
                        &PteProtectionMask);

                    TempPte.Long = ((TempPte.Long & ~MM_PTE_PROTECTION_MASK) |
                        PteProtectionMask);

                    MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);

                    status = STATUS_GUARD_PAGE_VIOLATION;
                }
            }
        }

        MI_UNLOCK_MM(OldIrql);

        MI_UNLOCK_ADDRESS_SPACE();
    }

ReturnStatusCode:
    if (!NT_SUCCESS(status) && status != STATUS_GUARD_PAGE_VIOLATION) {
        if (TrapInformation != NULL) {
            MiDbgPrint(("MM: page fault touching %p, trap frame %p, eip %p\n",
                VirtualAddress, TrapInformation,
                ((PKTRAP_FRAME)TrapInformation)->Eip));
        } else {
            MiDbgPrint(("MM: page fault touching %p, trap frame %p\n",
                VirtualAddress, TrapInformation));
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\mminit.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    mminit.c

Abstract:

    This module implements the initialization for the memory management system.

--*/

#include "mi.h"

//
// Export the data structures used by the memory manager implementation.
//
DECLSPEC_RDATA MMGLOBALDATA MmGlobalData = {
    &MmRetailPfnRegion,
    &MmSystemPteRange,
    &MmAvailablePages,
    MmAllocatedPagesByUsage,
    &MmAddressSpaceLock,
    &MmVadRoot,
    &MmVadHint,
    &MmVadFreeHint
};

//
// Stores the physical address of the top byte, not inclusive, of the kernel
// image.
//
DECLSPEC_STICKY ULONG_PTR MmTopOfKernelPhysicalAddress;

//
// Local support.
//

#ifdef DEVKIT
VOID
MiCopyShadowROMDataSection(
    VOID
    );
#endif

#ifdef ALLOC_PRAGMA
#ifdef DEVKIT
#pragma alloc_text(INIT, MiCopyShadowROMDataSection)
#endif
#endif

#ifdef DEVKIT

VOID
MiCopyShadowROMDataSection(
    VOID
    )
/*++

Routine Description:

    This routine takes a snapshot of the initialized .data section from the
    shadow ROM and fixes up the kernel's headers to point at this copy.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PXDATA_SECTION_HEADER DataSectionHeader;
    PFN_COUNT DataSectionSizeInPages;
    PFN_COUNT PfnDatabaseSizeInPages;
    PUCHAR DataSectionCopy;

    //
    // Compute how many pages will be required to hold the copy of the
    // initialized data.
    //

    DataSectionHeader = (PXDATA_SECTION_HEADER)((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2;
    DataSectionSizeInPages = BYTES_TO_PAGES(DataSectionHeader->SizeOfInitializedData);

    //
    // Compute how many pages will be required to hold the PFN database.
    //

    PfnDatabaseSizeInPages = BYTES_TO_PAGES((MM_HIGHEST_PHYSICAL_PAGE + 1) *
        sizeof(MMPFN));

#ifdef ARCADE
    //
    // Always place the copy of the initialized data below the PFN database and
    // NVIDIA NV2A instance memory.
    //

    DataSectionCopy = MI_CONVERT_PFN_TO_PHYSICAL(MM_DATABASE_PHYSICAL_PAGE -
        DataSectionSizeInPages);
#else
    //
    // Figure out where we're going to put the copy of the initialized data.  If
    // this is a machine with 64M of memory, then the copy is placed below the
    // PFN database and NVIDIA NV2A instance memory.  Otherwise, the copy is
    // placed after the PFN database in the upper 64M.
    //

    if (MM_DATABASE_PHYSICAL_PAGE + PfnDatabaseSizeInPages +
        DataSectionSizeInPages >= MM_HIGHEST_PHYSICAL_PAGE) {
        DataSectionCopy = MI_CONVERT_PFN_TO_PHYSICAL(MM_INSTANCE_PHYSICAL_PAGE -
            DataSectionSizeInPages);
    } else {
        DataSectionCopy = MI_CONVERT_PFN_TO_PHYSICAL(MM_DATABASE_PHYSICAL_PAGE +
            PfnDatabaseSizeInPages);
    }
#endif

    //
    // Copy the initialized data to the private copy.
    //

    RtlCopyMemory(DataSectionCopy, (PUCHAR)DataSectionHeader->PointerToRawData,
        DataSectionHeader->SizeOfInitializedData);

    //
    // Update the image header to point at the private copy of the data.
    //

    DataSectionHeader->PointerToRawData = (ULONG_PTR)DataSectionCopy;
}

#endif // DEVKIT

VOID
MmInitSystem(
    VOID
    )
/*++

Routine Description:

    This routine initializes the memory manager.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    MMPTE TempPte;
    PMMPTE PointerPde;
#ifndef ARCADE
    PCI_SLOT_NUMBER PCISlotNumber;
    UCHAR MemoryTop;
#endif
    PMMPTE EndingPointerPde;

    //
    // Verify that the page attribute table (PAT) is initialized correctly by
    // the boot loader.  Specifically, we want to be able to mark pages as USWC.
    //

    ASSERT(RDMSR(0x277) == 0x0007010600070106ui64);

    //
    // Unmap the lower two gigabytes of memory.
    //

    for (PointerPde = MiGetPdeAddress(0); PointerPde <
        MiGetPdeAddress(MM_PHYSICAL_MAP_BASE); PointerPde++) {
        MI_WRITE_ZERO_PTE(PointerPde);
    }

    //
    // Unmap the boot ROM from its identity mapping at the top of memory.
    //

    PointerPde = MiGetPdeAddress((PVOID)MAXULONG_PTR);
    MI_WRITE_ZERO_PTE(PointerPde);

    //
    // Map the MM_DEVICE_WC_BASE window.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.LargePage = 1;
    TempPte.Hard.PageFrameNumber = MM_DEVICE_WC_BASE >> PAGE_SHIFT;
    MI_SET_PTE_WRITE_COMBINE(TempPte);

    for (PointerPde = MiGetPdeAddress(MM_DEVICE_WC_BASE); PointerPde <=
        MiGetPdeAddress(MM_DEVICE_WC_END); PointerPde++) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Long += PAGE_SIZE_LARGE;
    }

    //
    // Map the MM_DEVICE_UC_BASE window.
    //

    TempPte.Hard.PageFrameNumber = MM_DEVICE_UC_BASE >> PAGE_SHIFT;
    MI_DISABLE_CACHING(TempPte);

    for (PointerPde = MiGetPdeAddress(MM_DEVICE_UC_BASE); PointerPde <=
        MiGetPdeAddress(MM_DEVICE_UC_END); PointerPde++) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Long += PAGE_SIZE_LARGE;
    }

#ifndef ARCADE
    //
    // Access the host bridge's configuration space.
    //

    PCISlotNumber.u.AsULONG = 0;
    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_HOSTBRIDGE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_HOSTBRIDGE_FUNCTION_ID;

#ifdef DEVKIT
    //
    // Configure the memory manager to use the page count configured in the host
    // bridge.  Each increment of the memory top is equal to 16 megabytes, or
    // 4096 pages.
    //

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, CR_CPU_MEMTOP_LIMIT,
        &MemoryTop, sizeof(UCHAR));

    MmHighestPhysicalPage = (((ULONG)MemoryTop + 1) * 4096) - 1;

    //
    // If the system only has 64 megabytes of memory, then allow pages in the
    // developer kit range to use memory from standard system memory.
    //

    if (MM_HIGHEST_PHYSICAL_PAGE < MM_64M_PHYSICAL_PAGE) {
        MmDeveloperKitPteRange.AvailablePages = &MmAvailablePages;
        MmDeveloperKitPteRange.RemovePageRoutine = MiRemoveZeroPage;
    }
#else
    //
    // Configure the host bridge's top of memory to a hardwired 64 megabytes.
    //

    MemoryTop = CR_CPU_MEMTOP_LIMIT_64MB;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, CR_CPU_MEMTOP_LIMIT,
        &MemoryTop, sizeof(UCHAR));
#endif
#endif

#ifdef DEVKIT
    //
    // If this is the first boot and we booted from a ROM image loaded in RAM,
    // then make a copy of the initialized .data section so that we can throw
    // away the rest of the shadow ROM.
    //

    if (!KeHasQuickBooted && (XboxBootFlags & XBOX_BOOTFLAG_SHADOW)) {
        MiCopyShadowROMDataSection();
    }
#endif

    //
    // Initialize the page frame database.
    //

    if (!KeHasQuickBooted) {
        MiInitializePfnDatabase();
    } else {
        MiReinitializePfnDatabase();
    }

    //
    // Switch from the large pages used by the boot loader to the page tables
    // contained in the page frame database.
    //

    TempPte.Long = MiGetValidKernelPdeBits();
    TempPte.Hard.PageFrameNumber = MM_DATABASE_PHYSICAL_PAGE;

    PointerPde = MiGetPdeAddress(MM_SYSTEM_PHYSICAL_MAP);
    EndingPointerPde = MiGetPdeAddress(MI_CONVERT_PFN_TO_PHYSICAL(MM_HIGHEST_PHYSICAL_PAGE));

    while (PointerPde <= EndingPointerPde) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Hard.PageFrameNumber++;
        PointerPde++;
    }

    //
    // Unmap the rest of the system RAM physical window.
    //

    EndingPointerPde = MiGetPdeAddress(MM_SYSTEM_PHYSICAL_MAP +
        MM_BYTES_IN_PHYSICAL_MAP - 1);

    while (PointerPde <= EndingPointerPde) {
        MI_WRITE_ZERO_PTE(PointerPde);
        PointerPde++;
    }

    //
    // Flush the TLB now that the switch over is complete.
    //

    KeFlushCurrentTb();

    //
    // Initialize the pool support.
    //

    InitializePool();

    //
    // Allocate the "write 0xFF" PTEs for the file system cache.  We're called
    // early enough in the boot process that this shouldn't fail.
    //

    FscWriteFFsPtes = MiReserveSystemPtes(&MmSystemPteRange,
        FSCACHE_NUMBER_OF_WRITE_FF_PTES);

    ASSERT(FscWriteFFsPtes != NULL);

    //
    // Set the file system cache to the default boot size.
    //

    FscSetCacheSize(16);
}

VOID
MmDiscardInitSection(
    VOID
    )
/*++

Routine Description:

    This routine frees the INIT section of the kernel.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER InitSectionHeader;
    PUCHAR VirtualAddress;
    PUCHAR EndingVirtualAddress;
    PFN_NUMBER PageFrameNumber;
    PFN_NUMBER EndingPageFrameNumberExclusive;
    KIRQL OldIrql;

    //
    // Find the NT headers for XBOXKRNL.EXE.
    //

    NtHeader = RtlImageNtHeader(PsNtosImageBase);

    ASSERT(NtHeader != NULL);
    ASSERT(NtHeader->FileHeader.NumberOfSections > 0);

    //
    // Find the last section of XBOXKRNL.EXE, which by convention should be the
    // discardable INIT section.
    //

    InitSectionHeader = IMAGE_FIRST_SECTION(NtHeader) +
        NtHeader->FileHeader.NumberOfSections - 1;

    ASSERT((*(PULONG)InitSectionHeader->Name) == 'TINI');
    ASSERT((InitSectionHeader->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) != 0);

    //
    // Insert the pages of the INIT section into the free lists.  The starting
    // page of the INIT section may be shared with other code or data but
    // everything on the ending page of the INIT section is discardable.
    //

    VirtualAddress = (PUCHAR)PsNtosImageBase + InitSectionHeader->VirtualAddress;
    EndingVirtualAddress = VirtualAddress + InitSectionHeader->SizeOfRawData;

#if DBG
    RtlFillMemory(VirtualAddress, InitSectionHeader->SizeOfRawData, 0xCC);
#endif

    VirtualAddress = (PUCHAR)PAGE_ALIGN((ULONG_PTR)VirtualAddress + PAGE_SIZE - 1);
    EndingVirtualAddress = (PUCHAR)PAGE_ALIGN((ULONG_PTR)EndingVirtualAddress + PAGE_SIZE - 1);

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(VirtualAddress);
    EndingPageFrameNumberExclusive = MI_CONVERT_PHYSICAL_TO_PFN(EndingVirtualAddress);

    MmTopOfKernelPhysicalAddress = MmGetPhysicalAddress(VirtualAddress);

    MI_LOCK_MM(&OldIrql);

    while (PageFrameNumber < EndingPageFrameNumberExclusive) {

        //
        // MmAllocateContiguousMemorySpecifyCache searches for free pages from
        // the highest page to the lowest page, so insert pages such that the
        // lowest pages are at the front of the free lists.  This avoids
        // unnecessary page relocation in order to satisfy a contiguous memory
        // allocation.
        //

        MmAllocatedPagesByUsage[MmContiguousUsage]--;

        MiInsertPageInFreeList(PageFrameNumber, FALSE);

        PageFrameNumber++;
    }

    MI_UNLOCK_MM(OldIrql);

    ASSERT(EndingVirtualAddress == (PUCHAR)PsNtosImageBase +
        ROUND_TO_PAGES(RtlImageNtHeader(PsNtosImageBase)->OptionalHeader.SizeOfImage));

    //
    // Flush the TLB now that we've cleared several page table entries.
    //

    KeFlushCurrentTb();
}

VOID
MmRelocatePersistentMemory(
    VOID
    )
/*++

Routine Description:

    This routine relocates the contiguous memory allocations used by the launch
    data page and the persisted frame buffer.  This is done in order to make the
    memory layout at entry to an Xbox executable consistent between various
    methods of invocation (cold boot, warm boot from title, warm boot from
    Dashboard, etc.).

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PLAUNCH_DATA_PAGE NewLaunchDataPage;
    PLAUNCH_DATA_PAGE OldLaunchDataPage;
    PVOID OldSurface;
    ULONG_PTR OldSurfacePhysicalAddress;
    ULONG NumberOfBytes;
    PVOID NewSurface;

    //
    // First, attempt to relocate the launch data page at the bottom of memory
    // in the region below the base of the kernel.  This region should be
    // available at this point unless we've collided with other persisted
    // contiguous memory.
    //

    OldLaunchDataPage = LaunchDataPage;

    if (OldLaunchDataPage != NULL) {

        NewLaunchDataPage = MmAllocateContiguousMemoryEx(PAGE_SIZE, 0,
            MmGetPhysicalAddress(PsNtosImageBase) - 1, 0, PAGE_READWRITE);

        if (NewLaunchDataPage != NULL) {

            RtlCopyMemory(NewLaunchDataPage, OldLaunchDataPage, PAGE_SIZE);
            MmPersistContiguousMemory(NewLaunchDataPage, PAGE_SIZE, TRUE);

            LaunchDataPage = NewLaunchDataPage;

            MmFreeContiguousMemory(OldLaunchDataPage);

        } else {
            MiDbgPrint(("MM: cannot relocate launch data page\n"));
        }
    }

    //
    // Second, attempt to relocate the frame buffer created by
    // D3DDevice::PersistDisplay at the location immediately above the kernel
    // image.  If no surface exists or the surface is already at the desired
    // address, then bail out now.
    //

    OldSurface = AvGetSavedDataAddress();

    if (OldSurface == NULL) {
        return;
    }

    OldSurfacePhysicalAddress = MmGetPhysicalAddress(OldSurface);

    if (OldSurfacePhysicalAddress == MmTopOfKernelPhysicalAddress) {
        return;
    }

    //
    // Check if the surface overlaps the target surface physical address.  If
    // so, then we'll try to first relocate the surface to a higher physical
    // address.  If this fails, we'll fall into the below code path which will
    // fail due to the existing allocation.
    //

    NumberOfBytes = MmQueryAllocationSize(OldSurface);

    if (OldSurfacePhysicalAddress < MmTopOfKernelPhysicalAddress + NumberOfBytes) {

        NewSurface = MmAllocateContiguousMemoryEx(NumberOfBytes,
            MmTopOfKernelPhysicalAddress, MAXULONG_PTR, 0, PAGE_READWRITE |
            PAGE_WRITECOMBINE);

        if (NewSurface != NULL) {
            AvRelocateSavedDataAddress(NewSurface, NumberOfBytes);
            OldSurface = NewSurface;
        }
    }

    //
    // Attempt to relocate the surface to the physical memory immediately above
    // the kernel image.
    //

    NewSurface = MmAllocateContiguousMemoryEx(NumberOfBytes,
        MmTopOfKernelPhysicalAddress, MmTopOfKernelPhysicalAddress +
        NumberOfBytes - 1, 0, PAGE_READWRITE | PAGE_WRITECOMBINE);

    if (NewSurface != NULL) {
        AvRelocateSavedDataAddress(NewSurface, NumberOfBytes);
    } else {
        MiDbgPrint(("MM: cannot relocate persist display surface\n"));
    }
}

VOID
MmPrepareToQuickRebootSystem(
    VOID
    )
/*++

Routine Description:

    This routine is called by the HAL immediately before quick rebooting the
    system.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    ULONG PageFrameNumber;
    ULONG EndingPageFrameNumber;
    MMPFN TempPageFrame;
    MMPTE TempPte;
    PMMPTE PointerPde;

    //
    // Convert the page frames that hold NV2A instance memory to page table
    // entries.  When the memory manager reinitializes itself in the next
    // instance of the kernel, we want all of the pages that can be used for
    // instance memory to be reserved again until the D3D drivers calls
    // MmClaimGpuInstanceMemory.
    //

    PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE;
    EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT;

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        MI_DISABLE_CACHING(TempPageFrame.Pte);
        TempPageFrame.Pte.Hard.PersistAllocation = 1;
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        PageFrameNumber++;
    }

#ifdef CONSOLE_DEVKIT
    //
    // On a development kit system, the NVIDIA NV2A instance memory must be
    // relative to the top of memory, so we also reserve the instance memory
    // pages in the upper half of memory.
    //

    if (MM_HIGHEST_PHYSICAL_PAGE != MM_64M_PHYSICAL_PAGE - 1) {

        PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_64M_PHYSICAL_PAGE;
        EndingPageFrameNumber = MM_DATABASE_PHYSICAL_PAGE + MM_64M_PHYSICAL_PAGE;

        while (PageFrameNumber < EndingPageFrameNumber) {

            TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
            MI_DISABLE_CACHING(TempPageFrame.Pte);
            TempPageFrame.Pte.Hard.PersistAllocation = 1;
            TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

            *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

            PageFrameNumber++;
        }
    }
#endif

    //
    // Unmap the lower two gigabytes of memory.
    //

    for (PointerPde = MiGetPdeAddress(0); PointerPde <
        MiGetPdeAddress(MM_PHYSICAL_MAP_BASE); PointerPde++) {
        MI_WRITE_ZERO_PTE(PointerPde);
    }

    //
    // Unmap the system PTE space.
    //

    for (PointerPde = MiGetPdeAddress(MM_SYSTEM_PTE_BASE); PointerPde <=
        MiGetPdeAddress(MM_SYSTEM_PTE_END); PointerPde++) {
        MI_WRITE_ZERO_PTE(PointerPde);
    }

    //
    // Switch back to large pages for the physical mapping window.  When the
    // memory manager reinitializes, the PFN database will be modified causing
    // the existing page tables to become invalid.  Also, this causes the ROM
    // shadow physical address to be visible for KeQuickRebootSystem.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.LargePage = 1;

    for (PointerPde = MiGetPdeAddress(MM_PHYSICAL_MAP_BASE); PointerPde <=
        MiGetPdeAddress(MM_PHYSICAL_MAP_END); PointerPde++) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Long += PAGE_SIZE_LARGE;
    }

    //
    // Map the boot ROM to its identity mapping at the top of memory.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.LargePage = 1;
    TempPte.Hard.PageFrameNumber = (ULONG_PTR)PAGE_ALIGN_LARGE(MAXULONG_PTR) >>
        PAGE_SHIFT;

    PointerPde = MiGetPdeAddress((PVOID)MAXULONG_PTR);
    MI_WRITE_PTE(PointerPde, TempPte);

    //
    // Flush the TLB now that the switch over is complete.
    //

    KeFlushCurrentTb();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\mi.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    mi.h

Abstract:

    This module contains the private data structures and procedure
    prototypes for the memory management system.

--*/

#ifndef _MI_
#define _MI_

#include <ntos.h>
#include <bldr.h>
#include <ki.h>
#include <pool.h>
#include <pci.h>
#include <av.h>
#include <xlaunch.h>

//
// Break DEVKIT functionality into CONSOLE versus ARCADE features with the
// following macro.
//

#if defined(DEVKIT) && !defined(ARCADE)
#define CONSOLE_DEVKIT
#endif

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define MiDbgPrint(x)               DbgPrint x
#else
#define MiDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define MiIsFlagSet(flagset, flag)              (((flagset) & (flag)) != 0)
#define MiIsFlagClear(flagset, flag)            (((flagset) & (flag)) == 0)

//
// Returns the index of the supplied element relative to the supplied base
// address.
//

#define ARRAY_ELEMENT_NUMBER(base, type, element)                             \
    ((ULONG)(((type *)(element)) - (base)))

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Shortcuts to common multiplication factors.
//

#define X64K                        ((ULONG)64*1024)
#define X1024K                      ((ULONG)1024*1024)

//
// Define the NVIDIA NV2A constants for controlling the last accessible byte of
// memory.  These are accessed from the host bridge device.
//

#define CR_CPU_MEMTOP_LIMIT         0x87
#define CR_CPU_MEMTOP_LIMIT_64MB    0x03
#define CR_CPU_MEMTOP_LIMIT_128MB   0x07

//
// Define the lowest physical page available in the system.
//

#define MM_LOWEST_PHYSICAL_PAGE     0x00000

//
// Define the highest physical page available in the system.
//

#if defined(ARCADE)
#define MM_HIGHEST_PHYSICAL_PAGE    0x07FFF
#elif defined(DEVKIT)
#define MM_HIGHEST_PHYSICAL_PAGE    MmHighestPhysicalPage
#else
#define MM_HIGHEST_PHYSICAL_PAGE    0x03FFF
#endif

//
// Define the physical page that's reserved for use by D3D.  D3D needs the first
// ULONG in the system in order to initialize the push buffer, so we reserve the
// entire page for D3D's use.
//

#define MM_D3D_PHYSICAL_PAGE        0x00000

//
// Define the highest physical page that's allowed for a contiguous memory
// allocation.  All contiguous memory allocations are constrained to the memory
// available on a retail system.
//
// Additionally, the NVIDIA NV2A can use up to 128K of instance memory that must
// be allocated from the top of memory.  In order to leave the maximum amount of
// instance memory available from quick boot to quick boot, we don't allow
// anybody to allocate contiguous pages from the upper 128K (64K of which is
// already consumed by the PFN database).  This prevents somebody from
// persisting a contiguous allocation in this range across a quick reboot and
// screwing up the next title.
//
// For ARCADE, we require a 128K PFN database to describe the 128M retail
// system.  With 64K reserved for NVIDIA NV2A instance memory, this pushes the
// contiguous memory limit to 196K from the top of memory.
//

#ifdef ARCADE
#define MM_CONTIGUOUS_MEMORY_LIMIT  0x07FCF
#else
#define MM_CONTIGUOUS_MEMORY_LIMIT  0x03FDF
#endif

//
// Define the first physical page that's used to hold the PFN database.  The
// page number is selected such that the first 64M's half of the database sits
// at the end of the first 64M and the second 64M's half of the database sits
// at the start of the second 64M.
//
// For ARCADE, the PFN database is always 128K.  NVIDIA NV2A instance memory
// must be located in the top 128K of memory, but we only reserve 64K of
// instance memory.  The PFN database is instead located below the reserved
// instance memory.
//

#ifdef ARCADE
#define MM_DATABASE_PHYSICAL_PAGE   0x07FD0
#else
#define MM_DATABASE_PHYSICAL_PAGE   0x03FF0
#endif

//
// Define the bottom of the region that is reserved at system startup for NVIDIA
// NV2A instance memory.  These pages may be made available for other use when
// the D3D library calls MmClaimGpuInstanceMemory.
//
// For ARCADE, the PFN database is always 128K.  This would consume all of the
// usable pages for NVIDIA NV2A instance memory, so instead this instance memory
// is reserved at the top of memory and the PFN database is located below this
// instance memory.
//

#ifdef ARCADE
#define MM_INSTANCE_PHYSICAL_PAGE   0x07FF0
#else
#define MM_INSTANCE_PHYSICAL_PAGE   0x03FE0
#endif

#define MM_INSTANCE_PAGE_COUNT      16

//
// Define the first physical page that's available only on a development kit
// system.
//

#define MM_64M_PHYSICAL_PAGE        0x04000

//
// Define the write combine system memory aperture that's exposed by the NVIDIA
// NV2A.  PAGE_VIDEO allocations are mapped through this aperture instead of the
// standard system memory aperture starting at physical page zero.
//

#define MM_WRITE_COMBINE_APERTURE   0x40000

//
// Fixed addresses for memory manager data structures.
//

#define MM_PHYSICAL_MAP_BASE        ((ULONG)0x80000000)
#define MM_PHYSICAL_MAP_END         ((ULONG)0x8FFFFFFF)

#define MM_DEVKIT_PTE_BASE          ((ULONG)0xB0000000)
#define MM_DEVKIT_PTE_END           ((ULONG)0xBFFFFFFF)

#define MM_PAGE_TABLES_BASE         ((ULONG)0xC0000000)
#define MM_PAGE_TABLES_END          ((ULONG)0xC03FFFFF)

#define MM_DEBUG_VA                 ((ULONG)0xC0800000)

#define MM_SYSTEM_PTE_BASE          ((ULONG)0xD0000000)
#define MM_SYSTEM_PTE_END           ((ULONG)0xEFFFFFFF)

#define MM_DEVICE_WC_BASE           ((ULONG)0xF0000000)
#define MM_DEVICE_WC_END            ((ULONG)0xF7FFFFFF)
#define MM_DEVICE_UC_BASE           ((ULONG)0xF8000000)
#define MM_DEVICE_UC_END            ((ULONG)0xFFBFFFFF)

#define MM_HIGHEST_VAD_ADDRESS      ((PVOID)((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - X64K))
#define MM_USER_ADDRESS_RANGE_LIMIT 0xFFFFFFFF
#define MM_MAXIMUM_ZERO_BITS        21

//
// Page color support.
//

#define MM_NUMBER_OF_COLORS_BITS    5
#define MM_NUMBER_OF_COLORS         (1 << MM_NUMBER_OF_COLORS_BITS)
#define MM_NUMBER_OF_COLORS_MASK    (MM_NUMBER_OF_COLORS - 1)

typedef ULONG MMCOLOR;

//
// Macros to lock and unlock the memory manager data structures.
//

#define MI_LOCK_MM(OldIrql)         (*OldIrql) = KeRaiseIrqlToDpcLevel()
#define MI_UNLOCK_MM(OldIrql)       KeLowerIrql(OldIrql)
#define MI_ASSERT_LOCK_MM()         ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define MI_UNLOCK_MM_AND_THEN_WAIT(OldIrql) {                                 \
    PKTHREAD Thread = KeGetCurrentThread();                                   \
    MI_ASSERT_LOCK_MM();                                                      \
    ASSERT((OldIrql) <= APC_LEVEL);                                           \
    Thread->WaitIrql = (OldIrql);                                             \
    Thread->WaitNext = TRUE;                                                  \
}

//
// Page table entry data structure as overloaded by the memory manager.
//

typedef struct _MMPTE {
    union {
        ULONG Long;
        HARDWARE_PTE Hard;
        struct {
            ULONG Valid : 1;
            ULONG OneEntry : 1;
            ULONG NextEntry : 30;
        } List;
    };
} MMPTE, *PMMPTE;

#define PTE_PER_PAGE                (PAGE_SIZE / sizeof(MMPTE))
#define PDE_PER_PAGE                (PAGE_SIZE / sizeof(MMPTE))

//
// Define masks for fields within the PTE.
//

#define MM_PTE_VALID_MASK           0x00000001
#define MM_PTE_WRITE_MASK           0x00000002
#define MM_PTE_OWNER_MASK           0x00000004
#define MM_PTE_WRITE_THROUGH_MASK   0x00000008
#define MM_PTE_CACHE_DISABLE_MASK   0x00000010
#define MM_PTE_ACCESS_MASK          0x00000020
#define MM_PTE_DIRTY_MASK           0x00000040
#define MM_PTE_LARGE_PAGE_MASK      0x00000080
#define MM_PTE_GLOBAL_MASK          0x00000100
#define MM_PTE_GUARD_MASK           0x00000200
#define MM_PTE_NEXT_ENTRY_MASK      0xFFFFFFFC

//
// Bit fields to or into PTE to make a PTE valid based on the protection field
// of the invalid PTE.
//
// Note that for guard pages, we overload the supervisor/user PTE flag to mean
// that the page is a guard page.  Because we never go to user mode, this flag
// is effectively unused by hardware.
//

#define MM_PTE_NOACCESS             0x000   // not expressable on i386
#define MM_PTE_READONLY             0x000
#define MM_PTE_READWRITE            MM_PTE_WRITE_MASK
#define MM_PTE_NOCACHE              MM_PTE_CACHE_DISABLE_MASK
#define MM_PTE_GUARD                MM_PTE_GUARD_MASK
#define MM_PTE_CACHE                0x000

//
// Define the set of bits that MiMakePteProtectionMask will return.  This mask
// can be used to check if an existing PTE has compatible attributes.
//

#define MM_PTE_PROTECTION_MASK      0x0000021B

//
// Define the set of bits that MiMakeSystemPteProtectionMask will return.  This
// mask can be used to check if an existing PTE has compatible attributes.
//

#define MM_SYSTEM_PTE_PROTECTION_MASK 0x0000001B

//
// Define the end of list marker for the linked list contained in a PTE.
//

#define MM_EMPTY_PTE_LIST           ((ULONG)0x3FFFFFFF)

//
// Enumeration to identify what a busy page frame is being used for.
//

typedef enum _MMPFN_BUSY_TYPE {
    MmUnknownUsage,
    MmStackUsage,
    MmVirtualPageTableUsage,
    MmSystemPageTableUsage,
    MmPoolUsage,
    MmVirtualMemoryUsage,
    MmSystemMemoryUsage,
    MmImageUsage,
    MmFsCacheUsage,
    MmContiguousUsage,
    MmDebuggerUsage,
    MmMaximumUsage
} MMPFN_BUSY_TYPE;

//
// PFN free page element.
//
// The low bit of PackedPfnFlink must be clear so that the overloaded
// MMPFN.Pte.Valid is clear.
//
// The low bit of PackedPfnBlink must be clear so that the overloaded
// MMPFN.Busy.Busy is clear.
//

typedef struct _MMPFNFREE {
    USHORT PackedPfnFlink;              // low bit must be clear
    USHORT PackedPfnBlink;              // low bit must be clear
} MMPFNFREE, *PMMPFNFREE;

//
// PFN database element.
//

typedef struct _MMPFN {
    union {
        ULONG Long;
        MMPTE Pte;
        MMPFNFREE Free;
        struct {
            ULONG LockCount : 16;       // low bit must be clear
            ULONG Busy : 1;
            ULONG Reserved : 1;
            ULONG PteIndex : 10;
            ULONG BusyType : 4;
        } Busy;
        struct {
            ULONG LockCount : 16;       // low bit must be clear
            ULONG Busy : 1;
            ULONG ElementIndex : 11;
            ULONG BusyType : 4;
        } FsCache;
        struct {
            ULONG LockCount : 16;       // low bit must be clear
            ULONG Busy : 1;
            ULONG NumberOfUsedPtes : 11;
            ULONG BusyType : 4;
        } Directory;
    };
} MMPFN, *PMMPFN;

#define MM_PFN_NULL                 ((PFN_NUMBER)-1)
#define MM_PACKED_PFN_NULL          ((USHORT)0xFFFE)

#define MM_PFN_DATABASE             ((PMMPFN)MI_CONVERT_PFN_TO_PHYSICAL(MM_DATABASE_PHYSICAL_PAGE))

#define MI_PFN_ELEMENT(pfn)         (&MM_PFN_DATABASE[pfn])
#define MI_PFN_NUMBER(pmmpfn)       ((PFN_NUMBER)ARRAY_ELEMENT_NUMBER(MM_PFN_DATABASE, MMPFN, pmmpfn))

//
// Define the basic unit for the MMPFN.Busy.LockCount field.  The low bit must
// always be clear in order for the entry to not be viewed by the processor as a
// valid PTE, so we always increment or decrement the LockCount field in units
// of two.
//

#define MI_LOCK_COUNT_UNIT          2
#define MI_LOCK_COUNT_MAXIMUM       0xFFFE

//
// PFN region descriptor.
//

typedef struct _MMPFNREGION {
    MMPFNFREE FreePagesByColor[MM_NUMBER_OF_COLORS];
    PFN_COUNT AvailablePages;
} MMPFNREGION, *PMMPFNREGION;

#ifdef CONSOLE_DEVKIT
#define MI_PFN_REGION_SHIFT         14
#define MI_PAGES_IN_PFN_REGION      (1 << MI_PFN_REGION_SHIFT)
#define MI_BYTES_IN_PFN_REGION      (MI_PAGES_IN_PFN_REGION << PAGE_SHIFT)
#define MI_NUMBER_OF_REGIONS        (MM_PAGES_IN_PHYSICAL_MAP / MI_PAGES_IN_PFN_REGION)
#define MI_PFN_REGION(pfn)          (MmPfnRegions[((pfn) >> MI_PFN_REGION_SHIFT)])
#else
#define MI_PAGES_IN_PFN_REGION      (MM_PAGES_IN_PHYSICAL_MAP)
#define MI_BYTES_IN_PFN_REGION      (MI_PAGES_IN_PFN_REGION << PAGE_SHIFT)
#define MI_PFN_REGION(pfn)          &MmRetailPfnRegion
#endif

//
// Define the function signature for a routine that removes a page with the
// supplied busy type code and target page table entry address.
//

typedef
PFN_NUMBER
(FASTCALL *PMMREMOVE_PAGE_ROUTINE)(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

//
// Page table entry range structure.
//

typedef struct _MMPTERANGE {
    MMPTE HeadPte;
    PMMPTE FirstCommittedPte;
    PMMPTE LastCommittedPte;
    PMMPTE LastReservedPte;
    PFN_COUNT *AvailablePages;
    PMMREMOVE_PAGE_ROUTINE RemovePageRoutine;
} MMPTERANGE, *PMMPTERANGE;

//
// Address node.
//

typedef struct _MMADDRESS_NODE {
    ULONG_PTR StartingVpn;
    ULONG_PTR EndingVpn;
    struct _MMADDRESS_NODE *Parent;
    struct _MMADDRESS_NODE *LeftChild;
    struct _MMADDRESS_NODE *RightChild;
} MMADDRESS_NODE, *PMMADDRESS_NODE;

//
// Virtual address descriptor.
//

#ifdef __cplusplus
typedef struct _MMVAD : public MMADDRESS_NODE {
#else
typedef struct _MMVAD {
    MMADDRESS_NODE;
#endif
    ULONG AllocationProtect;
} MMVAD, *PMMVAD;

//
// Macros to guard access to the virtual memory space.
//

#define MI_LOCK_ADDRESS_SPACE()     RtlEnterCriticalSectionAndRegion(&MmAddressSpaceLock)
#define MI_UNLOCK_ADDRESS_SPACE()   RtlLeaveCriticalSectionAndRegion(&MmAddressSpaceLock)

//
// Macros to convert between virtual address and virtual page numbers.
//

#define MI_VA_TO_PAGE(va)           ((ULONG_PTR)(va) >> PAGE_SHIFT)
#define MI_VA_TO_VPN(va)            ((ULONG_PTR)(va) >> PAGE_SHIFT)
#define MI_VPN_TO_VA(vpn)           (PVOID)((vpn) << PAGE_SHIFT)
#define MI_VPN_TO_VA_ENDING(vpn)    (PVOID)(((vpn) << PAGE_SHIFT) | (PAGE_SIZE - 1))

//++
//ULONG
//MI_ROUND_TO_SIZE (
//    IN ULONG LENGTH,
//    IN ULONG ALIGNMENT
//    )
//
// Routine Description:
//
//    The ROUND_TO_SIZE macro takes a LENGTH in bytes and rounds it up to a
//    multiple of the alignment.
//
// Arguments:
//
//    LENGTH - LENGTH in bytes to round up to.
//
//    ALIGNMENT - alignment to round to, must be a power of 2, e.g, 2**n.
//
// Return Value:
//
//    Returns the LENGTH rounded up to a multiple of the alignment.
//
//--

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)                                    \
    (((LENGTH) + ((ALIGNMENT) - 1)) & ~((ALIGNMENT) - 1))

//++
//PVOID
//MI_ALIGN_TO_SIZE (
//    IN PVOID VA
//    IN ULONG ALIGNMENT
//    );
//
// Routine Description:
//
//    The MI_ALIGN_TO_SIZE macro takes a virtual address and returns a
//    virtual address for that page with the specified alignment.
//
// Arguments:
//
//    VA - Virtual address.
//
//    ALIGNMENT - alignment to round to, must be a power of 2, e.g, 2**n.
//
// Return Value:
//
//    Returns the aligned virtual address.
//
//--

#define MI_ALIGN_TO_SIZE(VA,ALIGNMENT)                                        \
    ((PVOID)((ULONG_PTR)(VA) & ~((ULONG_PTR) ALIGNMENT - 1)))

//++
//VOID
//MI_WRITE_PTE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_PTE fills in the specified PTE with the specified contents.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_PTE(_PointerPte, _PteContents)                               \
    (*(_PointerPte) = (_PteContents))

//++
//VOID
//MI_WRITE_ZERO_PTE (
//    IN PMMPTE PointerPte
//    );
//
// Routine Description:
//
//    MI_WRITE_PTE fills in the specified PTE with zero.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_ZERO_PTE(_PointerPte)                                        \
    ((_PointerPte)->Long = 0)

//++
//VOID
//MI_WRITE_AND_FLUSH_PTE(
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_AND_FLUSH_PTE fills in the specified PTE with the specified
//    contents and invalidates the TLB line associated with the page.
//
// Arguments:
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

__inline
VOID
MI_WRITE_AND_FLUSH_PTE(
    PMMPTE PointerPte,
    MMPTE PteContents
    )
{
    MI_WRITE_PTE(PointerPte, PteContents);

    __asm {
        mov     eax, PointerPte
        shl     eax, 10             ; eax = MiGetVirtualAddressMappedByPte(eax)
        invlpg  [eax]
    }
}

//++
//VOID
//MI_FLUSH_VA(
//    IN PVOID VirtualAddress
//    );
//
// Routine Description:
//
//    MI_FLUSH_VA invalidates the TLB line associated with the page.
//
// Arguments:
//
//    VirtualAddress - Supplies the virtual address to flush.
//
// Return Value:
//
//    None.
//
//--

__inline
VOID
MI_FLUSH_VA(
    PVOID VirtualAddress
    )
{
    __asm {
        mov     ecx, VirtualAddress
        invlpg  [ecx]
    }
}

//++
//VOID
//MI_DISABLE_CACHING (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and sets the caching state to be
//    disabled.  This is performed by setting the PCD and PWT bits in the PTE.
//
//    Semantics of the overlap between PCD, PWT, and the
//    USWC memory type in the MTRR are:
//
//    PCD   PWT   Mtrr Mem Type      Effective Memory Type
//     1     0    USWC               USWC
//     1     1    USWC               UC
//
//    Since an effective memory type of UC is desired here,
//    the WT bit is set.
//
// Arguments
//
//    PTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_DISABLE_CACHING(PTE) {                                             \
    ((PTE).Hard.CacheDisable = 1);                                            \
    ((PTE).Hard.WriteThrough = 1);                                            \
}

//++
//VOID
//MI_SET_PTE_WRITE_COMBINE (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and enables WriteCombining as the
//    caching state.  Note that the PTE bits may only be set this way
//    if the Page Attribute Table is present and the PAT has been
//    initialized to provide Write Combining.
//
//    If either of the above conditions is not satisfied, then
//    the macro enables WEAK UC (PCD = 1, PWT = 0) in the PTE.
//
// Arguments
//
//    PTE - Supplies a valid PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_SET_PTE_WRITE_COMBINE(PTE) {                                       \
    ((PTE).Hard.CacheDisable = 0);                                            \
    ((PTE).Hard.WriteThrough = 1);                                            \
}

//++
//PMMPTE
//MiGetPdeAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeAddress returns the address of the PDE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PDE for.
//
// Return Value:
//
//    The address of the PDE.
//
//--

#define MiGetPdeAddress(va) ((PMMPTE)(((((ULONG)(va)) >> 22) << 2) + PDE_BASE))

//++
//PMMPTE
//MiGetPteAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteAddress returns the address of the PTE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PTE for.
//
// Return Value:
//
//    The address of the PTE.
//
//--

#define MiGetPteAddress(va) ((PMMPTE)(((((ULONG)(va)) >> 12) << 2) + PTE_BASE))

//++
//ULONG
//MiGetPdeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeOffset returns the offset into a page directory
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page directory table the corresponding PDE is at.
//
//--

#define MiGetPdeOffset(va) (((ULONG)(va)) >> 22)

//++
//ULONG
//MiGetPteOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteOffset returns the offset into a page table page
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page table page table the corresponding PTE is at.
//
//--

#define MiGetPteOffset(va) ((((ULONG)(va)) << 10) >> 22)

//++
//PVOID
//MiGetVirtualAddressMappedByPde (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPde returns the virtual address
//    which is mapped by a given PDE address.
//
// Arguments
//
//    PDE - Supplies the PDE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PDE.
//
//--

#define MiGetVirtualAddressMappedByPde(PDE) ((PVOID)((ULONG)(PDE) << 20))

//++
//PVOID
//MiGetVirtualAddressMappedByPte (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPte returns the virtual address
//    which is mapped by a given PTE address.
//
// Arguments
//
//    PTE - Supplies the PTE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PTE.
//
//--

#define MiGetVirtualAddressMappedByPte(PTE) ((PVOID)((ULONG)(PTE) << 10))

//++
//LOGICAL
//MiIsPteOnPdeBoundary (
//    IN PVOID PTE
//    );
//
// Routine Description:
//
//    MiIsPteOnPdeBoundary returns TRUE if the PTE is
//    on a page directory entry boundary.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if on a 4MB PDE boundary, FALSE if not.
//
//--

#define MiIsPteOnPdeBoundary(PTE) (((ULONG_PTR)(PTE) & (PAGE_SIZE - 1)) == 0)

//++
//MMPTE
//MiGetValidKernelPdeBits (
//    VOID
//    );
//
// Routine Description:
//
//    MiGetValidKernelPde returns the basic bits for a valid kernel PDE.
//
// Return Value:
//
//    The bits for the PDE.
//
//--

#define MiGetValidKernelPdeBits() \
    (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_OWNER_MASK | MM_PTE_DIRTY_MASK | MM_PTE_ACCESS_MASK)

//++
//MMPTE
//MiGetValidKernelPteBits (
//    VOID
//    );
//
// Routine Description:
//
//    MiGetValidKernelPde returns the basic bits for a valid kernel PTE.
//
// Return Value:
//
//    The bits for the PTE.
//
//--

#define MiGetValidKernelPteBits() \
    (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_DIRTY_MASK | MM_PTE_ACCESS_MASK)

//++
//MMPTE
//MiGetValidCachePteBits (
//    VOID
//    );
//
// Routine Description:
//
//    MiGetValidKernelPde returns the basic bits for a valid cache PTE.
//
// Return Value:
//
//    The bits for the PTE.
//
//--

#define MiGetValidCachePteBits() \
    (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_ACCESS_MASK)

//++
//BOOLEAN
//MI_IS_PHYSICAL_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro determines if a given virtual address is really a
//    physical address.
//
// Arguments
//
//    VA - Supplies the virtual address.
//
// Return Value:
//
//    FALSE if it is not a physical address, TRUE if it is.
//
//--

#define MI_IS_PHYSICAL_ADDRESS(Va) \
    (((ULONG)(Va) - MM_PHYSICAL_MAP_BASE) <= (MM_PHYSICAL_MAP_END - MM_PHYSICAL_MAP_BASE))

//++
//ULONG
//MI_CONVERT_PHYSICAL_TO_PFN (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro converts a physical address (see MI_IS_PHYSICAL_ADDRESS)
//    to its corresponding physical frame number.
//
// Arguments
//
//    VA - Supplies a pointer to the physical address.
//
// Return Value:
//
//    Returns the PFN for the page.
//
//--

#define MI_CONVERT_PHYSICAL_TO_PFN(Va)                                        \
    (((ULONG)(Va) & (MM_BYTES_IN_PHYSICAL_MAP - 1)) >> PAGE_SHIFT)

//++
//PCHAR
//MI_CONVERT_PFN_TO_PHYSICAL (
//    IN PAGE_FRAME_NUMBER Pfn
//    );
//
// Routine Description:
//
//    This macro converts a physical frame number to its corresponding
//    physical address.
//
// Arguments
//
//    Pfn - Supplies the physical frame number.
//
// Return Value:
//
//    Returns the physical address for the page number.
//
//--

#define MI_CONVERT_PFN_TO_PHYSICAL(Pfn)                                       \
    ((PCHAR)MM_SYSTEM_PHYSICAL_MAP + ((ULONG)(Pfn) << PAGE_SHIFT))

//++
//BOOLEAN
//MI_IS_SYSTEM_PTE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is an address in the system PTE space.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is in the system PTE space, FALSE if not.
//
//--

#define MI_IS_SYSTEM_PTE_ADDRESS(Va)                                          \
    (((ULONG)(Va) - MM_SYSTEM_PTE_BASE) <= (MM_SYSTEM_PTE_END - MM_SYSTEM_PTE_BASE))

//++
//BOOLEAN
//MI_SIZE_OF_MDL (
//    IN PVOID BASE,
//    IN SIZE_T LENGTH
//    );
//
// Routine Description:
//
//    This function returns the number of bytes required for an MDL for a
//    given buffer and size.
//
// Arguments:
//
//    Base - Supplies the base virtual address for the buffer.
//
//    Length - Supplies the size of the buffer in bytes.
//
// Return Value:
//
//    Returns the number of bytes required to contain the MDL.
//
//--

#define MI_SIZE_OF_MDL(BASE,LENGTH)                                           \
    (sizeof(MDL) + (ADDRESS_AND_SIZE_TO_SPAN_PAGES((BASE), (LENGTH)) * sizeof(PFN_NUMBER)))

//++
//USHORT
//MiPackFreePfn(
//    IN PFN_NUMBER PFN
//    );
//
// Routine Description:
//
//    This function packs a page frame number for storage in the MMPFN free
//    link fields.  The returned number must have the low bit clear in order
//    to make the entry appear as non-busy.
//
// Arguments:
//
//    PFN - Supplies the page frame number.
//
// Return Value:
//
//    Returns the packed form of the page frame number.
//
//--

#define MiPackFreePfn(PFN)                                                \
    ((USHORT)((((PFN_NUMBER)(PFN)) >> MM_NUMBER_OF_COLORS_BITS) << 1))

//++
//PFN_NUMBER
//MiUnpackFreePfn(
//    IN USHORT CPFN,
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This function unpacks a MMPFN free link field to obtain the original
//    page frame number.  The low bit of the packed page frame number will
//    have the low bit clear.
//
// Arguments:
//
//    CPFN - Supplies the packed page frame number.
//
//    COLOR - Supplies the color of the original page frame number.
//
// Return Value:
//
//    Returns the unpacked page frame number.
//
//--

#define MiUnpackFreePfn(CPFN,COLOR)                                           \
    ((((ULONG)(CPFN)) << (MM_NUMBER_OF_COLORS_BITS - 1)) + (ULONG)(COLOR))

//++
//PMMPFN
//MiUnpackFreePfnElement(
//    IN USHORT CPFN,
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This function unpacks a MMPFN free link field to obtain the original
//    page frame element.  The low bit of the packed page frame number will
//    have the low bit clear.
//
// Arguments:
//
//    CPFN - Supplies the packed page frame number.
//
//    COLOR - Supplies the color of the original page frame number.
//
// Return Value:
//
//    Returns the unpacked page frame element.
//
//--

#define MiUnpackFreePfnElement(CPFN,COLOR)                                    \
    MI_PFN_ELEMENT(MiUnpackFreePfn((CPFN),(COLOR)))

//++
//MMCOLOR
//MiGetPfnColor(
//    IN ULONG PFN
//    );
//
// Routine Description:
//
//    This function computes the color of the supplied page frame number.
//
// Arguments:
//
//    PFN - Supplies the page frame number.
//
// Return Value:
//
//    Returns the color of the page frame number.
//
//--

#define MiGetPfnColor(PFN)                                                    \
    ((PFN_NUMBER)(PFN) & (MM_NUMBER_OF_COLORS - 1))

// PVOID
// MiFindEmptyAddressRangeDown (
//    IN ULONG_PTR SizeOfRange,
//    IN PVOID HighestAddressToEndAt,
//    IN ULONG_PTR Alignment
//    )
//
// Routine Description:
//
//    The function examines the virtual address descriptors to locate
//    an unused range of the specified size and returns the starting
//    address of the range.  This routine looks from the top down.
//
// Arguments:
//
//    SizeOfRange - Supplies the size in bytes of the range to locate.
//
//    HighestAddressToEndAt - Supplies the virtual address to begin looking
//                            at.
//
//    Alignment - Supplies the alignment for the address.  Must be
//                 a power of 2 and greater than the page_size.
//
//Return Value:
//
//    Returns the starting address of a suitable range.
//

#define MiFindEmptyAddressRangeDown(SizeOfRange,HighestAddressToEndAt,Alignment) \
               (MiFindEmptyAddressRangeDownTree(                             \
                    (SizeOfRange),                                           \
                    (HighestAddressToEndAt),                                 \
                    (Alignment),                                             \
                    MmVadRoot))

// PMMVAD
// MiGetPreviousVad (
//     IN PMMVAD Vad
//     )
//
// Routine Description:
//
//     This function locates the virtual address descriptor which contains
//     the address range which logically precedes the specified virtual
//     address descriptor.
//
// Arguments:
//
//     Vad - Supplies a pointer to a virtual address descriptor.
//
// Return Value:
//
//     Returns a pointer to the virtual address descriptor containing the
//     next address range, NULL if none.
//
//

#define MiGetPreviousVad(VAD) ((PMMVAD)MiGetPreviousNode((PMMADDRESS_NODE)(VAD)))

// PMMVAD
// MiGetNextVad (
//     IN PMMVAD Vad
//     )
//
// Routine Description:
//
//     This function locates the virtual address descriptor which contains
//     the address range which logically follows the specified address range.
//
// Arguments:
//
//     VAD - Supplies a pointer to a virtual address descriptor.
//
// Return Value:
//
//     Returns a pointer to the virtual address descriptor containing the
//     next address range, NULL if none.
//

#define MiGetNextVad(VAD) ((PMMVAD)MiGetNextNode((PMMADDRESS_NODE)(VAD)))

// PMMVAD
// MiCheckForConflictingVad (
//     IN PVOID StartingAddress,
//     IN PVOID EndingAddress
//     )
//
// Routine Description:
//
//     The function determines if any addresses between a given starting and
//     ending address is contained within a virtual address descriptor.
//
// Arguments:
//
//     StartingAddress - Supplies the virtual address to locate a containing
//                       descriptor.
//
//     EndingAddress - Supplies the virtual address to locate a containing
//                       descriptor.
//
// Return Value:
//
//     Returns a pointer to the first conflicting virtual address descriptor
//     if one is found, otherwise a NULL value is returned.
//

#define MiCheckForConflictingVad(StartingAddress,EndingAddress)           \
    ((PMMVAD)MiCheckForConflictingNode(                                   \
                    MI_VA_TO_VPN(StartingAddress),                        \
                    MI_VA_TO_VPN(EndingAddress),                          \
                    MmVadRoot))

//++
//LOGICAL
//MiIsRetryIoStatus(
//    IN NTSTATUS S
//    );
//
// Routine Description:
//
//    This function tests the supplied status code to see if the error might
//    have been caused by a verifier induced error or by temporarily being out
//    of system resources.
//
// Arguments:
//
//    S - Supplies the status code to test.
//
// Return Value:
//
//    Returns TRUE if the I/O operation should be retried, else FALSE.
//
//--

#define MiIsRetryIoStatus(S)                                                  \
    (((S) == STATUS_INSUFFICIENT_RESOURCES) || ((S) == STATUS_NO_MEMORY))

//
// Routines which operate on the page frame database.
//

VOID
MiInitializePfnDatabase(
    VOID
    );

VOID
MiReinitializePfnDatabase(
    VOID
    );

VOID
FASTCALL
MiInsertPageInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN BOOLEAN InsertAtHeadList
    );

VOID
MiInsertPhysicalMemoryInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN PFN_NUMBER EndingPageFrameNumberExclusive
    );

VOID
FASTCALL
MiRemovePageFromFreeList(
    IN PFN_NUMBER PageFrameNumber
    );

PFN_NUMBER
FASTCALL
MiRemoveAnyPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

PFN_NUMBER
FASTCALL
MiRemoveZeroPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

PFN_NUMBER
FASTCALL
MiRemoveDebuggerPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

VOID
FASTCALL
MiRelocateBusyPage(
    IN PFN_NUMBER PageFrameNumber
    );

VOID
FASTCALL
MiReleasePageOwnership(
    IN PFN_NUMBER PageFrameNumber
    );

//
// Routines to obtain and release system PTEs.
//

PMMPTE
MiReserveSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PFN_COUNT NumberOfPtes
    );

VOID
MiReleaseSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PMMPTE StartingPte,
    IN PFN_COUNT NumberOfPtes
    );

VOID
FASTCALL
MiZeroAndFlushPtes(
    IN PMMPTE StartingPte,
    IN PFN_COUNT NumberOfPtes
    );

//
// Routines which operate on an address tree.
//

PMMADDRESS_NODE
FASTCALL
MiGetNextNode(
   IN PMMADDRESS_NODE Node
   );

PMMADDRESS_NODE
FASTCALL
MiGetPreviousNode(
   IN PMMADDRESS_NODE Node
   );

VOID
FASTCALL
MiInsertNode(
   IN PMMADDRESS_NODE Node,
   IN OUT PMMADDRESS_NODE *Root
   );

VOID
FASTCALL
MiRemoveNode(
   IN PMMADDRESS_NODE Node,
   IN OUT PMMADDRESS_NODE *Root
   );

PMMADDRESS_NODE
FASTCALL
MiLocateAddressInTree(
   IN ULONG_PTR Vpn,
   IN PMMADDRESS_NODE *Root
   );

PMMADDRESS_NODE
MiCheckForConflictingNode(
   IN ULONG_PTR StartVpn,
   IN ULONG_PTR EndVpn,
   IN PMMADDRESS_NODE Root
   );

PVOID
MiFindEmptyAddressRangeInTree(
   IN SIZE_T SizeOfRange,
   IN ULONG_PTR Alignment,
   IN PMMADDRESS_NODE Root,
   OUT PMMADDRESS_NODE *PreviousVad
   );

PVOID
MiFindEmptyAddressRangeDownTree(
   IN SIZE_T SizeOfRange,
   IN PVOID HighestAddressToEndAt,
   IN ULONG_PTR Alignment,
   IN PMMADDRESS_NODE Root
   );

//
// Routines which operate on the tree of virtual address descriptors.
//

VOID
MiInsertVad(
    IN PMMVAD Vad
    );

VOID
MiRemoveVad(
    IN PMMVAD Vad
    );

PMMVAD
FASTCALL
MiLocateAddress(
    IN PVOID Vad
    );

PVOID
MiFindEmptyAddressRange(
    IN SIZE_T SizeOfRange,
    IN ULONG_PTR Alignment,
    IN ULONG QuickCheck
    );

//
// Miscellaneous routines.
//

PVOID
MiAllocateMappedMemory(
    IN PMMPTERANGE PteRange,
    IN MMPFN_BUSY_TYPE BusyType,
    IN ULONG Protect,
    IN SIZE_T NumberOfBytes,
    IN PMMREMOVE_PAGE_ROUTINE RemovePageRoutine,
    IN BOOLEAN AddBarrierPage
    );

PFN_COUNT
MiFreeMappedMemory(
    IN PMMPTERANGE PteRange,
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes OPTIONAL
    );

BOOLEAN
FASTCALL
MiMakePteProtectionMask(
    IN ULONG Protect,
    OUT PULONG PteProtectionMask
    );

BOOLEAN
FASTCALL
MiMakeSystemPteProtectionMask(
    IN ULONG Protect,
    OUT PMMPTE ProtoPte
    );

ULONG
FASTCALL
MiDecodePteProtectionMask(
    IN ULONG PteProtectionMask
    );

//
// Global data structure.
//

typedef struct _MMGLOBALDATA {
    PMMPFNREGION RetailPfnRegion;
    PMMPTERANGE SystemPteRange;
    PULONG AvailablePages;
    PFN_COUNT *AllocatedPagesByUsage;
    PRTL_CRITICAL_SECTION AddressSpaceLock;
    PMMADDRESS_NODE *VadRoot;
    PMMADDRESS_NODE *VadHint;
    PMMADDRESS_NODE *VadFreeHint;
} MMGLOBALDATA, *PMMGLOBALDATA;

//
// External symbols.
//

extern PFN_COUNT MmNumberOfPhysicalPages;
extern PMMPFNREGION MmPfnRegions[];
extern MMPFNREGION MmRetailPfnRegion;
extern MMPFNREGION MmDeveloperKitPfnRegion;
extern PFN_COUNT MmAvailablePages;
extern PFN_COUNT MmAllocatedPagesByUsage[MmMaximumUsage];
extern RTL_CRITICAL_SECTION MmAddressSpaceLock;
extern SIZE_T MmVirtualMemoryBytesReserved;
extern PMMADDRESS_NODE MmVadRoot;
extern PMMADDRESS_NODE MmVadHint;
extern PMMADDRESS_NODE MmVadFreeHint;
extern MMPTERANGE MmSystemPteRange;
extern MMPTERANGE MmDeveloperKitPteRange;
extern PFSCACHE_ELEMENT FscElementArray;
extern ULONG FscNumberOfCachePages;
extern PMMPTE FscWriteFFsPtes;

#endif  // MI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\pfnsup.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    pfnsup.c

Abstract:

    This module implements routines which provide support for managing the page
    frame database.

--*/

#include "mi.h"

//
// Define a macro to statically initialize a PFN region.
//
#define MI_PFN_REGION_INITIALIZER() {                                         \
    {                                                                         \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
    },                                                                        \
    0,                                                                        \
}

//
// Total number of physical pages available on the system.
//
DECLSPEC_STICKY PFN_COUNT MmNumberOfPhysicalPages;

//
// Highest physical page number in the system.
//
#ifdef CONSOLE_DEVKIT
PFN_NUMBER MmHighestPhysicalPage;
#else
DECLSPEC_RDATA PFN_NUMBER MmHighestPhysicalPage = MM_HIGHEST_PHYSICAL_PAGE;
#endif

//
// Database that contains the use of each allocatable physical page in the
// system.  Exposed here for the kernel debugger.
//
DECLSPEC_SELECTANY PMMPFN MmPfnDatabase = MM_PFN_DATABASE;

//
// Region for general use pages, such as code, pool, and stacks.
//
MMPFNREGION MmRetailPfnRegion = MI_PFN_REGION_INITIALIZER();

#ifdef CONSOLE_DEVKIT
//
// Region for the extra memory available in the development kits.
//
MMPFNREGION MmDeveloperKitPfnRegion = MI_PFN_REGION_INITIALIZER();

//
// Mapping from MI_PFN_REGION to the corresponding PMMPFNREGION.
//
PMMPFNREGION MmPfnRegions[MI_NUMBER_OF_REGIONS] = {
    &MmRetailPfnRegion,
    &MmDeveloperKitPfnRegion,
    &MmDeveloperKitPfnRegion,
    &MmDeveloperKitPfnRegion,
};

//
// Set if MmReleaseDeveloperKitMemory has been called to place all of the extra
// pages available on a developer kit in the general free lists.
//
BOOLEAN MmDeveloperKitMemoryReleased;
#endif

//
// Page color to use for the next allocation without a specified page color.
//
MMCOLOR MmNextDefaultPageColor;

//
// Number of pages that can be allocated for general use.
//
PFN_COUNT MmAvailablePages;

//
// Number of pages that have been allocated for the various usage types.
//
PFN_COUNT MmAllocatedPagesByUsage[MmMaximumUsage];

//
// Local support.
//

VOID
MiRelocateBusyPageHelper(
    IN PVOID OldPhysicalAddress,
    IN PVOID NewPhysicalAddress,
    IN PMMPTE PointerPte,
    IN MMPTE NewPteContents,
    IN BOOLEAN FullTlbFlush
    );

#if DBG
VOID
MiAssertFreeListsValid(
    VOID
    );
#define MI_ASSERT_FREE_LISTS_VALID()    MiAssertFreeListsValid()
#else
#define MI_ASSERT_FREE_LISTS_VALID()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, MiInitializePfnDatabase)
#endif

VOID
MiInitializePfnDatabase(
    VOID
    )
/*++

Routine Description:

    This routine initializes the database used to track busy and free pages.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PIMAGE_NT_HEADERS NtHeader;
    ULONG NtosImageSize;
    PFN_COUNT PfnDatabaseSizeInPages;
    MMPFN TempPageFrame;
    ULONG PageFrameNumber;
    ULONG EndingPageFrameNumber;
#ifdef DEVKIT
    PXDATA_SECTION_HEADER DataSectionHeader;
#endif
    PIMAGE_SECTION_HEADER TextSectionHeader;

    MI_LOCK_MM(&OldIrql);

    //
    // Verify that the highest physical page doesn't exceed the limits of the
    // physical mapping window.
    //

    ASSERT(MM_HIGHEST_PHYSICAL_PAGE < MM_PAGES_IN_PHYSICAL_MAP);

    //
    // Find the NT headers for XBOXKRNL.EXE.
    //

    NtHeader = RtlImageNtHeader(PsNtosImageBase);

    ASSERT(NtHeader != NULL);
    ASSERT(NtHeader->FileHeader.NumberOfSections > 0);

    //
    // Get the size of the XBOXKRNL.EXE image.
    //

    NtosImageSize = ROUND_TO_PAGES(NtHeader->OptionalHeader.SizeOfImage);

    //
    // Compute how many pages will be required to hold the PFN database.
    //

    PfnDatabaseSizeInPages = BYTES_TO_PAGES((MM_HIGHEST_PHYSICAL_PAGE + 1) *
        sizeof(MMPFN));

    //
    // Initialize all entries in the PFN database as unknown usage with a
    // maximum reference count so that MmAllocateContiguousMemoryEx doesn't
    // consider the page when finding a candidate range.
    //

    TempPageFrame.Long = 0;
    TempPageFrame.Busy.Busy = 1;
    TempPageFrame.Busy.LockCount = MI_LOCK_COUNT_MAXIMUM;
    TempPageFrame.Busy.BusyType = MmUnknownUsage;

    RtlFillMemoryUlong(MM_PFN_DATABASE, PfnDatabaseSizeInPages * PAGE_SIZE,
        TempPageFrame.Long);

    //
    // Insert all of the pages from the bottom of memory to the base of
    // XBOXKRNL.EXE into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(MM_LOWEST_PHYSICAL_PAGE,
        MI_CONVERT_PHYSICAL_TO_PFN(PsNtosImageBase));

#ifdef ARCADE
    //
    // Insert all of the pages from the end of XBOXKRNL.EXE to the base of the
    // PFN database into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(
        MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase + NtosImageSize),
        MM_DATABASE_PHYSICAL_PAGE);
#else
    //
    // Insert all of the pages from the end of XBOXKRNL.EXE to the base of the
    // NVIDIA NV2A instance memory into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(
        MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase + NtosImageSize),
        MM_INSTANCE_PHYSICAL_PAGE);
#endif

#ifdef CONSOLE_DEVKIT
    //
    // Insert all of the pages from the end of the PFN database to the top of
    // memory into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(MM_DATABASE_PHYSICAL_PAGE +
        PfnDatabaseSizeInPages, MM_HIGHEST_PHYSICAL_PAGE + 1);
#endif

#ifdef DEVKIT
    //
    // If we booted from a shadow copy of the ROM, then we need to remove the
    // pages that were used to make a copy of the kernel's initialized data.
    //

    if (XboxBootFlags & XBOX_BOOTFLAG_SHADOW) {

        DataSectionHeader = (PXDATA_SECTION_HEADER)((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2;

        PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(DataSectionHeader->PointerToRawData);
        EndingPageFrameNumber = PageFrameNumber +
            BYTES_TO_PAGES(DataSectionHeader->SizeOfInitializedData);

        while (PageFrameNumber < EndingPageFrameNumber) {

            MiRemovePageFromFreeList(PageFrameNumber);

            TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
            TempPageFrame.Pte.Hard.Write = 0;
            TempPageFrame.Pte.Hard.PersistAllocation = 1;
            TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

            *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

            MmAllocatedPagesByUsage[MmContiguousUsage]++;

            PageFrameNumber++;
        }
    }
#endif

    //
    // Convert the page frame that holds the page directory to a page table
    // entry.
    //

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(PAGE_DIRECTORY_PHYSICAL_ADDRESS);

    MiRemovePageFromFreeList(PageFrameNumber);

    TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
    TempPageFrame.Pte.Hard.PersistAllocation = 1;
    TempPageFrame.Pte.Hard.GuardOrEndOfAllocation = 1;
    TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;;

    *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

    MmAllocatedPagesByUsage[MmContiguousUsage]++;

    //
    // Convert the page frames that hold XBOXKRNL.EXE to page table entries.
    //

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(PsNtosImageBase);
    EndingPageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase +
        NtosImageSize);

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        TempPageFrame.Pte.Hard.PersistAllocation = 1;
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        MmNumberOfPhysicalPages++;
        MmAllocatedPagesByUsage[MmContiguousUsage]++;

        PageFrameNumber++;
    }

    //
    // Find the first section of XBOXKRNL.EXE, which by convention should be the
    // text section.
    //

    TextSectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    ASSERT((*(PULONG)TextSectionHeader->Name) == 'xet.');
    ASSERT((TextSectionHeader->Characteristics & IMAGE_SCN_CNT_CODE) != 0);

    //
    // Convert the image headers and .text section of XBOXKRNL.EXE to read-only.
    //

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(PsNtosImageBase);
    EndingPageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase +
        TextSectionHeader->Misc.VirtualSize);

    while (PageFrameNumber < EndingPageFrameNumber) {
        MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.Write = 0;
        PageFrameNumber++;
    }

    //
    // Convert the page frames that hold the PFN database to page table entries.
    // The pages persist across a quick reboot.
    //

    PageFrameNumber = MM_DATABASE_PHYSICAL_PAGE;
    EndingPageFrameNumber = MM_DATABASE_PHYSICAL_PAGE + PfnDatabaseSizeInPages;

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        TempPageFrame.Pte.Hard.PersistAllocation = 1;
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        MmNumberOfPhysicalPages++;
        MmAllocatedPagesByUsage[MmContiguousUsage]++;

        PageFrameNumber++;
    }

    //
    // Convert the page frames that hold NV2A instance memory to page table
    // entries.
    //

    PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE;
    EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT;

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        MI_DISABLE_CACHING(TempPageFrame.Pte);
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        MmNumberOfPhysicalPages++;
        MmAllocatedPagesByUsage[MmContiguousUsage]++;

        PageFrameNumber++;
    }

#ifdef CONSOLE_DEVKIT
    //
    // On a development kit system, the NVIDIA NV2A instance memory must be
    // relative to the top of memory, so we also reserve the instance memory
    // pages in the upper half of memory.
    //

    if (MM_HIGHEST_PHYSICAL_PAGE != MM_64M_PHYSICAL_PAGE - 1) {

        PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_64M_PHYSICAL_PAGE;
        EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE +
            MM_INSTANCE_PAGE_COUNT + MM_64M_PHYSICAL_PAGE;

        while (PageFrameNumber < EndingPageFrameNumber) {

            MiRemovePageFromFreeList(PageFrameNumber);

            TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
            MI_DISABLE_CACHING(TempPageFrame.Pte);
            TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

            *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

            MmAllocatedPagesByUsage[MmContiguousUsage]++;

            PageFrameNumber++;
        }
    }
#endif

    //
    // Reserve the first physical page in the system for D3D's use.
    //

    MiRemovePageFromFreeList(MM_D3D_PHYSICAL_PAGE);

    TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
    TempPageFrame.Pte.Hard.PersistAllocation = 1;
    TempPageFrame.Pte.Hard.GuardOrEndOfAllocation = 1;
    TempPageFrame.Pte.Hard.PageFrameNumber = MM_D3D_PHYSICAL_PAGE;

    *MI_PFN_ELEMENT(MM_D3D_PHYSICAL_PAGE) = TempPageFrame;

    MmAllocatedPagesByUsage[MmContiguousUsage]++;

    MI_UNLOCK_MM(OldIrql);
}

VOID
MiReinitializePfnDatabase(
    VOID
    )
/*++

Routine Description:

    This routine reinitializes the database used to track busy and free pages
    after a quick reboot has occurred.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_LOCK_MM(&OldIrql);

    //
    // Loop over the page frame database and either keep persistent pages or
    // insert pages into the free lists.
    //

    for (PageFrameNumber = MM_LOWEST_PHYSICAL_PAGE; PageFrameNumber <=
        MM_HIGHEST_PHYSICAL_PAGE; PageFrameNumber++) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        if (PageFrame->Pte.Hard.Valid != 0) {

            //
            // The page was a contiguous memory allocation in the previous
            // instance of the kernel.  If the page is marked as being
            // peristent, then keep the allocation alive.
            //

            if (PageFrame->Pte.Hard.PersistAllocation != 0) {
                MmAllocatedPagesByUsage[MmContiguousUsage]++;
                continue;
            }

        } else if (PageFrame->Busy.Busy != 0) {

            //
            // The page was marked as an unknown page type in the previous
            // instance of the kernel.  Keep the page in this state since we
            // can't manage the page.
            //

            if (PageFrame->Busy.BusyType == MmUnknownUsage) {
                continue;
            }

        } else {

            //
            // The page was free in the previous instance of the kernel.
            //
        }

        //
        // MmAllocateContiguousMemorySpecifyCache searches for free pages from
        // the highest page to the lowest page, so insert pages such that the
        // lowest pages are at the front of the free lists.  This avoids
        // unnecessary page relocation in order to satisfy a contiguous memory
        // allocation.
        //

        MiInsertPageInFreeList(PageFrameNumber, FALSE);
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
FASTCALL
MiInsertPageInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN BOOLEAN InsertAtHeadList
    )
/*++

Routine Description:

    This routine inserts the supplied physical page into the appropriate free
    list.  No assumptions are made about the current status of the page.

Arguments:

    PageFrameNumber - Supplies the physical page frame to insert.

    InsertAtHeadList - If TRUE, insert the page at the front of the free lists,
        else insert the page at the end of the free lists.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MMCOLOR Color;
    USHORT PackedPfn;
    PMMPFN PageFrame;
    PMMPFNREGION PfnRegion;
    PMMPFN OldLinkPageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);

    Color = MiGetPfnColor(PageFrameNumber);
    PackedPfn = MiPackFreePfn(PageFrameNumber);

    //
    // Verify that the caller is not attempting to free the page frame number
    // used as the end of list marker.
    //

    ASSERT(PackedPfn != MM_PACKED_PFN_NULL);

    //
    // Copy the list head to the freed page frame.  We'll clear out the forward
    // or backward link below depending on the list insertion direction.
    //

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);
    PfnRegion = MI_PFN_REGION(PageFrameNumber);
    PageFrame->Free = PfnRegion->FreePagesByColor[Color];

    if (PfnRegion->FreePagesByColor[Color].PackedPfnFlink != MM_PACKED_PFN_NULL) {

        //
        // The page color list was not empty, so link the new page list head or
        // tail to the old page list head or tail.
        //

        if (InsertAtHeadList) {

            PageFrame->Free.PackedPfnBlink = MM_PACKED_PFN_NULL;
            PfnRegion->FreePagesByColor[Color].PackedPfnFlink = PackedPfn;

            OldLinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnFlink,
                Color);

            ASSERT(OldLinkPageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL);
            OldLinkPageFrame->Free.PackedPfnBlink = PackedPfn;

        } else {

            PageFrame->Free.PackedPfnFlink = MM_PACKED_PFN_NULL;
            PfnRegion->FreePagesByColor[Color].PackedPfnBlink = PackedPfn;

            OldLinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnBlink,
                Color);

            ASSERT(OldLinkPageFrame->Free.PackedPfnFlink == MM_PACKED_PFN_NULL);
            OldLinkPageFrame->Free.PackedPfnFlink = PackedPfn;
        }

        ASSERT(OldLinkPageFrame->Busy.Busy == 0);

    } else {

        //
        // The page color list was empty, so make both the head and tail
        // pointer reference this page.
        //

        ASSERT(PageFrame->Free.PackedPfnFlink == MM_PACKED_PFN_NULL);
        ASSERT(PageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL);

        PfnRegion->FreePagesByColor[Color].PackedPfnBlink = PackedPfn;
        PfnRegion->FreePagesByColor[Color].PackedPfnFlink = PackedPfn;
    }

    //
    // Verify that the packed page frame numbers are structurally correct-- the
    // low bits must be clear to mark the page as free.
    //

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy == 0);

    //
    // Update the number of available pages in the region.
    //

    PfnRegion->AvailablePages++;

#ifdef CONSOLE_DEVKIT
    //
    // Update the number of available pages in the system if the page is from
    // the retail PFN region or if the extra memory on a development kit is
    // available for general use.
    //

    if (PfnRegion == &MmRetailPfnRegion || MmDeveloperKitMemoryReleased) {
        MmAvailablePages++;
    }
#else
    //
    // Update the number of available pages in the system.
    //

    MmAvailablePages++;
#endif
}

VOID
MiInsertPhysicalMemoryInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN PFN_NUMBER EndingPageFrameNumberExclusive
    )
/*++

Routine Description:

    This routine inserts a range of physical pages into the appropriate free
    lists.  No assumptions are made about the current status of the pages.

Arguments:

    PageFrameNumber - Supplies the first physical page frame to insert.

    EndingPageFrameNumberExclusive - Supplies the last physical page frame to
                                     insert, not including the page itself.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    MI_ASSERT_LOCK_MM();

    while (PageFrameNumber < EndingPageFrameNumberExclusive) {

        //
        // MmAllocateContiguousMemorySpecifyCache searches for free pages from
        // the highest page to the lowest page, so insert pages such that the
        // lowest pages are at the front of the free lists.  This avoids
        // unnecessary page relocation in order to satisfy a contiguous memory
        // allocation.
        //

        MiInsertPageInFreeList(PageFrameNumber, FALSE);

        MmNumberOfPhysicalPages++;

        PageFrameNumber++;
    }
}

VOID
FASTCALL
MiRemovePageFromFreeList(
    IN PFN_NUMBER PageFrameNumber
    )
/*++

Routine Description:

    This routine removes the supplied physical page from the free page list
    that it is currently attached to.

    The returned page frame is not initialized.

Arguments:

    PageFrameNumber - Supplies the physical page frame to remove.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MMCOLOR Color;
    USHORT PackedPfn;
    PMMPFN PageFrame;
    PMMPFNREGION PfnRegion;
    PMMPFN LinkPageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);

    Color = MiGetPfnColor(PageFrameNumber);
    PackedPfn = MiPackFreePfn(PageFrameNumber);

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);
    PfnRegion = MI_PFN_REGION(PageFrameNumber);

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy == 0);

    //
    // Detach the page from its backward link.
    //

    if (PageFrame->Free.PackedPfnBlink != MM_PACKED_PFN_NULL) {

        LinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnBlink,
            Color);

        ASSERT(LinkPageFrame->Pte.Hard.Valid == 0);
        ASSERT(LinkPageFrame->Busy.Busy == 0);
        ASSERT(LinkPageFrame->Free.PackedPfnFlink == PackedPfn);

        LinkPageFrame->Free.PackedPfnFlink = PageFrame->Free.PackedPfnFlink;

        ASSERT(LinkPageFrame->Busy.Busy == 0);

    } else {

        //
        // The page is the head of the list.
        //

        ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnFlink == PackedPfn);
        PfnRegion->FreePagesByColor[Color].PackedPfnFlink =
            PageFrame->Free.PackedPfnFlink;
    }

    //
    // Detach the page from its forward link.
    //

    if (PageFrame->Free.PackedPfnFlink != MM_PACKED_PFN_NULL) {

        LinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnFlink,
            Color);

        ASSERT(LinkPageFrame->Pte.Hard.Valid == 0);
        ASSERT(LinkPageFrame->Busy.Busy == 0);
        ASSERT(LinkPageFrame->Free.PackedPfnBlink == PackedPfn);

        LinkPageFrame->Free.PackedPfnBlink = PageFrame->Free.PackedPfnBlink;

        ASSERT(LinkPageFrame->Busy.Busy == 0);

    } else {

        //
        // The page is the tail of the list.
        //

        ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnBlink == PackedPfn);
        PfnRegion->FreePagesByColor[Color].PackedPfnBlink =
            PageFrame->Free.PackedPfnBlink;
    }

    //
    // Update the number of available pages in the region.
    //

    PfnRegion->AvailablePages--;

#ifdef CONSOLE_DEVKIT
    //
    // Update the number of available pages in the system if the page is from
    // the retail PFN region or if the extra memory on a development kit is
    // available for general use.
    //

    if (PfnRegion == &MmRetailPfnRegion || MmDeveloperKitMemoryReleased) {
        MmAvailablePages--;
    }
#else
    //
    // Update the number of available pages in the system.
    //

    MmAvailablePages--;
#endif
}

PFN_NUMBER
FASTCALL
MiRemoveAnyPageFromFreeList(
    VOID
    )
/*++

Routine Description:

    This routine removes any physical page from the free page lists.

    The returned page frame is not initialized.

Arguments:

    None.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PMMPFNREGION PfnRegion;
    MMCOLOR Color;
    USHORT PackedPfn;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    PMMPFN NewLinkPageFrame;

    MI_ASSERT_LOCK_MM();

    //
    // Verify that there are pages available.  The caller is responsible for
    // first checking that a page can be allocated.
    //

    ASSERT(MmAvailablePages > 0);

    //
    // Look for the first region with a free page.
    //

    PfnRegion = &MmRetailPfnRegion;

#ifdef CONSOLE_DEVKIT
    if (PfnRegion->AvailablePages == 0) {
        PfnRegion = &MmDeveloperKitPfnRegion;
        ASSERT(MmDeveloperKitMemoryReleased);
    }
#endif

    ASSERT(PfnRegion->AvailablePages > 0);

    //
    // Look for the first colored free list with a free page.
    //

    ASSERT(MmNextDefaultPageColor < MM_NUMBER_OF_COLORS);

    for (Color = MmNextDefaultPageColor; NOTHING;
        Color = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK)) {

        if (PfnRegion->FreePagesByColor[Color].PackedPfnFlink !=
            MM_PACKED_PFN_NULL) {

            PackedPfn = PfnRegion->FreePagesByColor[Color].PackedPfnFlink;
            PageFrameNumber = MiUnpackFreePfn(PackedPfn, Color);

            ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);
            ASSERT(MI_PFN_REGION(PageFrameNumber) == PfnRegion);

            PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

            ASSERT(PageFrame->Pte.Hard.Valid == 0);
            ASSERT(PageFrame->Busy.Busy == 0);

            //
            // Unlink the page from the free list.
            //

            if (PageFrame->Free.PackedPfnFlink != MM_PACKED_PFN_NULL) {

                NewLinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnFlink,
                    Color);
                ASSERT(NewLinkPageFrame->Busy.Busy == 0);

                ASSERT(NewLinkPageFrame->Free.PackedPfnBlink ==
                    PfnRegion->FreePagesByColor[Color].PackedPfnFlink);
                NewLinkPageFrame->Free.PackedPfnBlink = MM_PACKED_PFN_NULL;

            } else {

                //
                // The page is the tail of the list.
                //

                ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnBlink == PackedPfn);
                PfnRegion->FreePagesByColor[Color].PackedPfnBlink = MM_PACKED_PFN_NULL;
            }

            ASSERT(PageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL);
            PfnRegion->FreePagesByColor[Color].PackedPfnFlink =
                PageFrame->Free.PackedPfnFlink;

            break;
        }
    }

    MmNextDefaultPageColor = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK);

    //
    // Update the number of available pages in the region.
    //

    PfnRegion->AvailablePages--;

#ifdef CONSOLE_DEVKIT
    //
    // Update the number of available pages in the system if the page is from
    // the retail PFN region or if the extra memory on a development kit is
    // available for general use.
    //

    if (PfnRegion == &MmRetailPfnRegion || MmDeveloperKitMemoryReleased) {
        MmAvailablePages--;
    }
#else
    //
    // Update the number of available pages in the system.
    //

    MmAvailablePages--;
#endif

    return PageFrameNumber;
}

PFN_NUMBER
FASTCALL
MiRemoveAnyPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    )
/*++

Routine Description:

    This routine removes one page from the free list and initializes it as a
    busy page with the supplied busy type.

    The contents of the page are uninitialized.

Arguments:

    BusyType - Usage code to place in allocated page frame.

    TargetPte - Supplies the address of the PDE/PTE that will receive the page
        frame.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    ASSERT(BusyType < MmMaximumUsage);

    MI_ASSERT_LOCK_MM();

    //
    // Allocate any page from a free list.
    //

    PageFrameNumber = MiRemoveAnyPageFromFreeList();
    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    //
    // Initialize the page frame as busy.  Page tables created for the lower
    // half of the address space (user space) are always allocated via
    // MiRemoveZeroPage, so we don't need to handle that special case here.
    //

    ASSERT(BusyType != MmVirtualPageTableUsage);

    PageFrame->Long = 0;                // Also zeroes LockCount
    PageFrame->Busy.Busy = 1;
    PageFrame->Busy.BusyType = BusyType;

    PageFrame->Busy.PteIndex = MiGetPteOffset(MiGetVirtualAddressMappedByPte(TargetPte));

    //
    // Increment the number of pages of this type.
    //

    MmAllocatedPagesByUsage[BusyType]++;

    return PageFrameNumber;
}

PFN_NUMBER
FASTCALL
MiRemoveZeroPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    )
/*++

Routine Description:

    This routine removes one page from the free list and initializes it as a
    busy page with the supplied busy type.

    The contents of the page are zeroed.

Arguments:

    BusyType - Usage code to place in allocated page frame.

    TargetPte - Supplies the address of the PDE/PTE that will receive the page
        frame.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    MMPTE TempPte;

    ASSERT(BusyType < MmMaximumUsage);

    MI_ASSERT_LOCK_MM();

    //
    // Allocate any page from a free list.
    //

    PageFrameNumber = MiRemoveAnyPageFromFreeList();
    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    //
    // Zero the page's contents by temporarily exposing it through the system
    // RAM physical mapping.
    //
    // The below "nop" serves as a fake write barrier to ensure that
    // MI_WRITE_PTE is not optimized away because we end up changing PageFrame
    // below.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.PageFrameNumber = PageFrameNumber;

    MI_WRITE_PTE(&((volatile MMPFN*)PageFrame)->Pte, TempPte);

    __asm nop;

    RtlZeroMemory(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber), PAGE_SIZE);

    //
    // Initialize the page frame as busy.
    //

    PageFrame->Long = 0;                // Also zeroes LockCount
    PageFrame->Busy.Busy = 1;
    PageFrame->Busy.BusyType = BusyType;

    if (BusyType != MmVirtualPageTableUsage) {
        PageFrame->Busy.PteIndex =
            MiGetPteOffset(MiGetVirtualAddressMappedByPte(TargetPte));
    }

    //
    // Increment the number of pages of this type.
    //

    MmAllocatedPagesByUsage[BusyType]++;

    //
    // Flush the system RAM physical mapping created above.
    //

    MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

    return PageFrameNumber;
}

VOID
FASTCALL
MiRelocateBusyPage(
    IN PFN_NUMBER PageFrameNumber
    )
/*++

Routine Description:

    This routine relocates the contents of the supplied physical page to another
    physical page.

    The original page frame is left in an uninitialized state.

Arguments:

    PageFrameNumber - Supplies the physical page frame to relocate.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PMMPFN PageFrame;
    BOOLEAN FullTlbFlush;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    PVOID CacheBuffer;
    PFN_NUMBER NewPageFrameNumber;
    PMMPFN NewPageFrame;
    MMPTE TempPte;

    MI_ASSERT_LOCK_MM();

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy != 0);
    ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
    ASSERT(PageFrame->Busy.LockCount == 0);

    //
    // Locate the pointer to the PTE for the page frame.
    //

    FullTlbFlush = FALSE;

    switch (PageFrame->Busy.BusyType) {

        case MmVirtualPageTableUsage:
            //
            // Busy.PteIndex isn't valid for a MmVirtualPageTableUsage page.
            // Instead, scan through the PDE for the page table.
            //

            PointerPde = MiGetPdeAddress(MM_LOWEST_USER_ADDRESS);

            for (;;) {

                if ((PointerPde->Hard.Valid != 0) &&
                    (PointerPde->Hard.PageFrameNumber == PageFrameNumber)) {
                    PointerPte = PointerPde;
                    break;
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_HIGHEST_USER_ADDRESS));
            }

            FullTlbFlush = TRUE;

            break;

        case MmSystemPageTableUsage:
            //
            // Busy.PteIndex is valid for a MmSystemPageTableUsage page, but
            // it's relative to the page directory, not a page table.
            //

            PointerPte = (PMMPTE)PDE_BASE + PageFrame->Busy.PteIndex;

            ASSERT(PointerPte->Hard.Valid != 0);
            ASSERT(PointerPte->Hard.PageFrameNumber == PageFrameNumber);

            FullTlbFlush = TRUE;

            break;

        case MmFsCacheUsage:
            //
            // FsCache.ElementIndex is the index into the FscElementArray which
            // can be used to find the virtual address of the cache page.
            //

            ASSERT(PageFrame->FsCache.ElementIndex < FscNumberOfCachePages);
            CacheBuffer = PAGE_ALIGN(FscElementArray[PageFrame->FsCache.ElementIndex].CacheBuffer);
            PointerPte = MiGetPteAddress(CacheBuffer);
            break;

        case MmVirtualMemoryUsage:
        case MmImageUsage:
            //
            // Busy.PteIndex is valid for a MmVirtualMemoryUsage page.  Scan
            // through each page table in the application virtual memory space.
            //

            PointerPde = MiGetPdeAddress(MM_LOWEST_USER_ADDRESS);

            for (;;) {

                if (PointerPde->Hard.Valid != 0) {

                    ASSERT(PointerPde->Hard.LargePage == 0);

                    PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) +
                        PageFrame->Busy.PteIndex;

                    //
                    // The page may be protected as PAGE_NOACCESS or PAGE_GUARD,
                    // so we can't just check the Valid bit here.
                    //

                    if ((PointerPte->Long != 0) &&
                        (PointerPte->Hard.PageFrameNumber == PageFrameNumber)) {
                        break;
                    }
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                // If we hit this, then that means that a page either has an
                // invalid PTE index.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_HIGHEST_USER_ADDRESS));
            }
            break;

#ifdef DEVKIT
        case MmDebuggerUsage:
#ifdef CONSOLE_DEVKIT
            //
            // Relocatable pages only exist in the first 64 megabytes of memory
            // and debugger pages can only be allocated in this memory if the
            // system only has 64 megabytes of memory.
            //

            ASSERT(MM_HIGHEST_PHYSICAL_PAGE < MM_64M_PHYSICAL_PAGE);
#endif

            //
            // Busy.PteIndex is valid for a MmDebuggerUsage page.  Scan through
            // each page table in the development kit PTE space.
            //

            PointerPde = MiGetPdeAddress(MM_DEVKIT_PTE_BASE);

            for (;;) {

                if (PointerPde->Hard.Valid != 0) {

                    ASSERT(PointerPde->Hard.LargePage == 0);

                    PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) +
                        PageFrame->Busy.PteIndex;

                    if ((PointerPte->Hard.Valid != 0) &&
                        (PointerPte->Hard.PageFrameNumber == PageFrameNumber)) {
                        break;
                    }
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                // If we hit this, then that means that a page either has an
                // invalid PTE index.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_DEVKIT_PTE_END));
            }
            break;
#endif

        default:
#ifdef CONSOLE_DEVKIT
            //
            // For non-DEVKIT builds or builds with more than 64 megabytes of
            // memory, make sure that we don't hit a debugger page.
            //

            ASSERT(PageFrame->Busy.BusyType != MmDebuggerUsage);
#endif

            //
            // Busy.PteIndex is valid for all other types.  Scan through each
            // page table in the system PTE space.
            //

            PointerPde = MiGetPdeAddress(MM_SYSTEM_PTE_BASE);

            for (;;) {

                if (PointerPde->Hard.Valid != 0) {

                    ASSERT(PointerPde->Hard.LargePage == 0);

                    PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) +
                        PageFrame->Busy.PteIndex;

                    if ((PointerPte->Hard.Valid != 0) &&
                        (PointerPte->Hard.PageFrameNumber == PageFrameNumber)) {
                        break;
                    }
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                // If we hit this, then that means that a page either has an
                // invalid PTE index.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_SYSTEM_PTE_END));
            }
            break;
    }

    //
    // Allocate another page to hold the contents of the page.  Attempt to
    // obtain the same color page so that virtual buffers are still spaced
    // nicely in the cache.
    //

    MmNextDefaultPageColor = MiGetPfnColor(PageFrameNumber);
    NewPageFrameNumber = MiRemoveAnyPageFromFreeList();
    NewPageFrame = MI_PFN_ELEMENT(NewPageFrameNumber);

    //
    // Temporarily expose the new page through the system RAM physical mapping
    // so that we can copy the page from the old address to the new address.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.PageFrameNumber = NewPageFrameNumber;

    MI_WRITE_PTE(&((volatile MMPFN*)NewPageFrame)->Pte, TempPte);

    //
    // Build the PTE contents for the virtual address to point at the new page.
    //

    TempPte = *PointerPte;
    ASSERT(PointerPte->Hard.PageFrameNumber == PageFrameNumber);
    TempPte.Hard.PageFrameNumber = NewPageFrameNumber;

    //
    // Invoke a helper to copy the contents of the page from the old page to the
    // new page, to update the page tables, and to flush the appropriate TLB
    // entries.  This is done in an assembly routine in order to ensure the
    // stack is updated properly if we're relocating the current stack's pages.
    //

    MiRelocateBusyPageHelper(MiGetVirtualAddressMappedByPte(PointerPte),
        MI_CONVERT_PFN_TO_PHYSICAL(NewPageFrameNumber), PointerPte, TempPte,
        FullTlbFlush);

    //
    // Copy the page frame attributes from the old page frame to the new.
    //

    NewPageFrame->Long = PageFrame->Long;

    //
    // Flush the system RAM physical mapping created above.
    //

    MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(NewPageFrameNumber));

    //
    // If caching is disabled or is write combined for the page's old virtual
    // address, then force a flush of the TLB and cache now to ensure coherency.
    //

    if (TempPte.Hard.WriteThrough) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }
}

VOID
FASTCALL
MiReleasePageOwnership(
    IN PFN_NUMBER PageFrameNumber
    )
/*++

Routine Description:

    This routine is called when the original use of an allocated page is
    complete.

Arguments:

    PageFrameNumber - Supplies the physical page frame to release.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy != 0);
    ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
    ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);

    //
    // If the page is still locked for I/O, then this is a bug in the client
    // code.  Pages should never be released with pending I/O.
    //

    ASSERT(PageFrame->Busy.LockCount == 0);

    //
    // Decrement the number of pages of this type.
    //

    MmAllocatedPagesByUsage[PageFrame->Busy.BusyType]--;

    //
    // Insert the page at the head of the free lists so that this page is
    // more likely to be allocated before a previously pinned page.
    //

    MiInsertPageInFreeList(PageFrameNumber, TRUE);
}

#ifdef CONSOLE_DEVKIT

VOID
MmReleaseDeveloperKitMemory(
    VOID
    )
/*++

Routine Description:

    This routine places all of the available pages in the extra memory PFN
    region back in the general available pages pool.  All of the other virtual
    memory manager services can start using these pages.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;

    MI_LOCK_MM(&OldIrql);

    MmAvailablePages += MmDeveloperKitPfnRegion.AvailablePages;

    MmDeveloperKitMemoryReleased = TRUE;

    MI_UNLOCK_MM(OldIrql);
}

PFN_NUMBER
FASTCALL
MiRemoveDebuggerPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    )
/*++

Routine Description:

    This routine removes one page from the free list and initializes it as a
    busy page with the supplied busy type.

    The contents of the page are zeroed.

Arguments:

    BusyType - Ignored.  MmDebuggerUsage is used for all pages allocated by
        this routine.

    TargetPte - Supplies the address of the PDE/PTE that will receive the page
        frame.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MMCOLOR Color;
    USHORT PackedPfn;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    MMPTE TempPte;

    MI_ASSERT_LOCK_MM();

    //
    // Verify that there are pages available.  The caller is responsible for
    // first checking that a page can be allocated.
    //

    ASSERT(MmDeveloperKitPfnRegion.AvailablePages > 0);

    //
    // Look for the first colored free list with a free page.
    //

    ASSERT(MmNextDefaultPageColor < MM_NUMBER_OF_COLORS);

    for (Color = MmNextDefaultPageColor; NOTHING;
        Color = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK)) {

        if (MmDeveloperKitPfnRegion.FreePagesByColor[Color].PackedPfnFlink !=
            MM_PACKED_PFN_NULL) {

            PackedPfn = MmDeveloperKitPfnRegion.FreePagesByColor[Color].PackedPfnFlink;
            PageFrameNumber = MiUnpackFreePfn(PackedPfn, Color);

            //
            // MiRemoveAnyPage is optimized for speed and detaches the page from
            // the free list itself knowing that the page is at the head of the
            // list.  Here, we optimize for size and delegate the list
            // detachment to a common routine.
            //

            MiRemovePageFromFreeList(PageFrameNumber);

            break;
        }
    }

    MmNextDefaultPageColor = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK);

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    //
    // Zero the page's contents by temporarily exposing it through the system
    // RAM physical mapping.
    //
    // The below "nop" serves as a fake write barrier to ensure that
    // MI_WRITE_PTE is not optimized away because we end up changing PageFrame
    // below.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.PageFrameNumber = PageFrameNumber;

    MI_WRITE_PTE(&((volatile MMPFN*)PageFrame)->Pte, TempPte);

    __asm nop;

    RtlZeroMemory(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber), PAGE_SIZE);

    //
    // Initialize the page frame as busy.
    //

    PageFrame->Long = 0;                // Also zeroes LockCount
    PageFrame->Busy.Busy = 1;
    PageFrame->Busy.BusyType = MmDebuggerUsage;
    PageFrame->Busy.PteIndex =
        MiGetPteOffset(MiGetVirtualAddressMappedByPte(TargetPte));

    //
    // Increment the number of pages of this type.
    //

    MmAllocatedPagesByUsage[MmDebuggerUsage]++;

    //
    // Flush the system RAM physical mapping created above.
    //

    MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

    return PageFrameNumber;
}

#endif

#if DBG

VOID
MiAssertPfnRegionFreeListsValid(
    IN PMMPFNREGION PfnRegion
    )
/*++

Routine Description:

    This routine analyzes the free lists of a PFN region to verify that they are
    structurally correct.

Arguments:

    PfnRegion - Supplies the PFN region to verify.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PFN_COUNT FreePagesFound;
    MMCOLOR Color;
    USHORT PackedPfnBlink;
    USHORT PackedPfn;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    FreePagesFound = 0;

    for (Color = 0; Color < MM_NUMBER_OF_COLORS; Color++) {

        PackedPfnBlink = MM_PACKED_PFN_NULL;
        PackedPfn = PfnRegion->FreePagesByColor[Color].PackedPfnFlink;

        while (PackedPfn != MM_PACKED_PFN_NULL) {

            ASSERT((PackedPfn & 1) == 0);

            PageFrameNumber = MiUnpackFreePfn(PackedPfn, Color);

            ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);
            ASSERT(MI_PFN_REGION(PageFrameNumber) == PfnRegion);

            PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

            ASSERT(PageFrame->Pte.Hard.Valid == 0);
            ASSERT(PageFrame->Busy.Busy == 0);
            ASSERT(PageFrame->Free.PackedPfnBlink == PackedPfnBlink);

            FreePagesFound++;

            PackedPfnBlink = PackedPfn;
            PackedPfn = PageFrame->Free.PackedPfnFlink;

            ASSERT(FreePagesFound <= MmAvailablePages);
        }

        ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnBlink == PackedPfnBlink);
    }

    ASSERT(PfnRegion->AvailablePages == FreePagesFound);
}

VOID
MiAssertFreeListsValid(
    VOID
    )
/*++

Routine Description:

    This routine analyzes the free lists to verify that they are structurally
    correct.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MiAssertPfnRegionFreeListsValid(&MmRetailPfnRegion);
#ifdef CONSOLE_DEVKIT
    MiAssertPfnRegionFreeListsValid(&MmDeveloperKitPfnRegion);
#endif
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\physical.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    This module implements the kernel physical memory management services.

--*/

#include "mi.h"

//
// Number of bytes that have been reserved for instance memory allocation.
//
ULONG MmNumberOfInstanceMemoryBytes = MM_INSTANCE_PAGE_COUNT << PAGE_SHIFT;

ULONG_PTR
MmGetPhysicalAddress(
    IN PVOID BaseAddress
    )
/*++

Routine Description:

    This function returns the corresponding physical address for a
    valid virtual address.

Arguments:

    BaseAddress - Supplies the virtual address for which to return the
                  physical address.

Return Value:

    Returns the corresponding physical address.

Environment:

    Kernel mode.  Any IRQL level.

--*/
{
    ULONG_PTR PhysicalAddress;
    PMMPTE PointerPte;
#if DBG
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
#endif

    PointerPte = MiGetPdeAddress(BaseAddress);
    if (PointerPte->Hard.Valid == 0) {
        goto InvalidAddress;
    }

    if (PointerPte->Hard.LargePage == 0) {

        PointerPte = MiGetPteAddress(BaseAddress);
        if (PointerPte->Hard.Valid == 0) {
            goto InvalidAddress;
        }

        PhysicalAddress = BYTE_OFFSET(BaseAddress);

    } else {

        PhysicalAddress = BYTE_OFFSET_LARGE(BaseAddress);
    }

    PhysicalAddress += (PointerPte->Hard.PageFrameNumber << PAGE_SHIFT);

#if DBG
    //
    // Verify that the base address is either a physically mapped page (either a
    // contiguous memory allocation or part of XBOXKRNL.EXE) or that it's I/O
    // lock count is non-zero (a page that's been liked with a service like
    // MmLockUnlockBufferPages).
    //

    PageFrameNumber = PhysicalAddress >> PAGE_SHIFT;

    if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        if (PageFrame->Pte.Hard.Valid == 0) {
            ASSERT(PageFrame->Busy.LockCount != 0);
        }
    }
#endif

    return PhysicalAddress;

InvalidAddress:
    MiDbgPrint(("MmGetPhysicalAddress failed, base address was %p", BaseAddress));
    return 0;
}

PVOID
MmAllocateContiguousMemory(
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a range of physically contiguous non-paged pool.

    This routine is designed to be used by a driver's initialization
    routine to allocate a contiguous block of physical memory for
    issuing DMA requests from.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - a contiguous range could not be found to satisfy the request.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/
{
    return MmAllocateContiguousMemoryEx(NumberOfBytes, 0, MAXULONG_PTR, 0,
        PAGE_READWRITE);
}

PVOID
MmAllocateContiguousMemoryEx(
    IN SIZE_T NumberOfBytes,
    IN ULONG_PTR LowestAcceptableAddress,
    IN ULONG_PTR HighestAcceptableAddress,
    IN ULONG_PTR Alignment,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function allocates a range of physically contiguous non-cached,
    non-paged memory.  This is accomplished by using MmAllocateContiguousMemory
    which uses nonpaged pool virtual addresses to map the found memory chunk.

    Then this function establishes another map to the same physical addresses,
    but this alternate map is initialized as non-cached.  All references by
    our caller will be done through this alternate map.

    This routine is designed to be used by a driver's initialization
    routine to allocate a contiguous block of noncached physical memory for
    things like the AGP GART.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    LowestAcceptableAddress - Supplies the lowest physical address
                              which is valid for the allocation.  For
                              example, if the device can only reference
                              physical memory in the 8M to 16MB range, this
                              value would be set to 0x800000 (8Mb).

    HighestAcceptableAddress - Supplies the highest physical address
                               which is valid for the allocation.  For
                               example, if the device can only reference
                               physical memory below 16MB, this
                               value would be set to 0xFFFFFF (16Mb - 1).

    Alignment - Supplies the desired page alignment for the allocation.  The
                alignment is treated as a power of two.  The minimum alignment
                is PAGE_SIZE.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    NULL - a contiguous range could not be found to satisfy the request.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    ULONG PhysicalAperture;
    MMPTE TempPte;
    PFN_NUMBER LowestAcceptablePageFrameNumber;
    PFN_NUMBER HighestAcceptablePageFrameNumber;
    PFN_COUNT PfnAlignment;
    PFN_COUNT PfnAlignmentMask;
    PFN_COUNT NumberOfPages;
    PFN_COUNT PfnAlignmentSubtraction;
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    PFN_COUNT ContiguousCandidatePagesFound;
    PFN_NUMBER EndingPageFrameNumber;
    PFN_NUMBER PageFrameNumberToGrab;

    ASSERT(NumberOfBytes != 0);

    //
    // Determine which system memory aperature to use.  If this is a video
    // memory request, use the write-combined memory aperture, otherwise use the
    // standard memory aperture.
    //

    if (Protect & PAGE_OLD_VIDEO) {
        PhysicalAperture = MM_WRITE_COMBINE_APERTURE;
        Protect = (Protect & ~PAGE_OLD_VIDEO);
    } else {
        PhysicalAperture = 0;
    }

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(Protect, &TempPte)) {
        return NULL;
    }

    //
    // Convert the supplied physical addresses into page frame numbers.
    //

    LowestAcceptablePageFrameNumber =
        (PFN_NUMBER)(LowestAcceptableAddress >> PAGE_SHIFT);
    HighestAcceptablePageFrameNumber =
        (PFN_NUMBER)(HighestAcceptableAddress >> PAGE_SHIFT);

    if (HighestAcceptablePageFrameNumber > MM_CONTIGUOUS_MEMORY_LIMIT) {
        HighestAcceptablePageFrameNumber = MM_CONTIGUOUS_MEMORY_LIMIT;
    }

    if (LowestAcceptablePageFrameNumber > HighestAcceptablePageFrameNumber) {
        LowestAcceptablePageFrameNumber = HighestAcceptablePageFrameNumber;
    }

    //
    // Compute the alignment of the allocation in terms of pages.  The alignment
    // should be a power of two.
    //

    ASSERT((Alignment & (Alignment - 1)) == 0);

    PfnAlignment = (PFN_COUNT)(Alignment >> PAGE_SHIFT);

    if (PfnAlignment == 0) {
        PfnAlignment = 1;
    }

    //
    // Compute the alignment mask to round a page frame number down to the
    // nearest alignment boundary.
    //

    PfnAlignmentMask = ~(PfnAlignment - 1);

    //
    // Compute the number of pages to allocate.
    //

    NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);

    //
    // Compute the number of pages to subtract from an aligned page frame number
    // to get to the prior candidate ending page frame number.
    //

    PfnAlignmentSubtraction = ((NumberOfPages + PfnAlignment - 1) &
        PfnAlignmentMask) - NumberOfPages + 1;

    //
    // Now ensure that we can allocate the required number of pages.
    //

    MI_LOCK_MM(&OldIrql);

    if (MmAvailablePages < NumberOfPages) {
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    //
    // Search the page frame database for a range that satisfies the size and
    // alignment requirements.
    //

    PageFrameNumber = HighestAcceptablePageFrameNumber + 1;

InvalidCandidatePageFound:
    PageFrameNumber = (PageFrameNumber & PfnAlignmentMask) -
        PfnAlignmentSubtraction;
    ContiguousCandidatePagesFound = 0;

    while ((SPFN_NUMBER)PageFrameNumber >= (SPFN_NUMBER)LowestAcceptablePageFrameNumber) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        //
        // If we have a page frame that's already being used for a physical
        // mapping, then this is an invalid candidate page.
        //

        if (PageFrame->Pte.Hard.Valid != 0) {
            goto InvalidCandidatePageFound;
        }

        //
        // If we have a page frame that's busy and is locked for I/O, then we
        // can't relocate the page, so this is an invalid candidate page.
        //

        if ((PageFrame->Busy.Busy != 0) && (PageFrame->Busy.LockCount != 0)) {
            goto InvalidCandidatePageFound;
        }

        //
        // This page can be used to help satisfy the request.  If we haven't
        // found the required number of physical pages yet, then continue the
        // search.
        //

        ContiguousCandidatePagesFound++;

        if (ContiguousCandidatePagesFound < NumberOfPages) {
            PageFrameNumber--;
            continue;
        }

        //
        // Verify that the starting page frame number is correctly aligned.
        //

        ASSERT((PageFrameNumber & (PfnAlignment - 1)) == 0);

        //
        // We found a range of physical pages of the requested size.
        //

        EndingPageFrameNumber = PageFrameNumber + NumberOfPages - 1;

        //
        // First, allocate all of the free pages in the range so that any
        // relocations we do won't go into our target range.
        //

        for (PageFrameNumberToGrab = PageFrameNumber;
            PageFrameNumberToGrab <= EndingPageFrameNumber;
            PageFrameNumberToGrab++) {

            PageFrame = MI_PFN_ELEMENT(PageFrameNumberToGrab);

            if (PageFrame->Busy.Busy == 0) {

                //
                // Detach the page from the free list.
                //

                MiRemovePageFromFreeList(PageFrameNumberToGrab);

                //
                // Convert the page frame to a physically mapped page.
                //

                TempPte.Hard.PageFrameNumber = PageFrameNumberToGrab +
                    PhysicalAperture;
                MI_WRITE_PTE(&PageFrame->Pte, TempPte);

                //
                // Increment the number of physically mapped pages.
                //

                MmAllocatedPagesByUsage[MmContiguousUsage]++;
            }
        }

        //
        // Second, relocate any non-pinned pages in the range.  The above loop
        // will allocate physically mapped pages and there won't be any pinned
        // pages already existing in the range due to the above candidate page
        // checks.
        //

        for (PageFrameNumberToGrab = PageFrameNumber;
            PageFrameNumberToGrab <= EndingPageFrameNumber;
            PageFrameNumberToGrab++) {

            PageFrame = MI_PFN_ELEMENT(PageFrameNumberToGrab);

            if (PageFrame->Pte.Hard.Valid == 0) {

                //
                // Relocate the page.
                //

                MiRelocateBusyPage(PageFrameNumberToGrab);

                //
                // Convert the page frame to a physically mapped page.
                //

                TempPte.Hard.PageFrameNumber = PageFrameNumberToGrab +
                    PhysicalAperture;
                MI_WRITE_PTE(&PageFrame->Pte, TempPte);

                //
                // Increment the number of physically mapped pages.
                //

                MmAllocatedPagesByUsage[MmContiguousUsage]++;
            }
        }

        //
        // Mark the last page of the allocation with a flag so that we
        // can later determine the size of this allocation.
        //

        MI_PFN_ELEMENT(EndingPageFrameNumber)->Pte.Hard.GuardOrEndOfAllocation = 1;

        //
        // Write combined accesses may not check the processor's cache, so force
        // a flush of the TLB and cache now to ensure coherency.
        //
        // Flush the cache for uncached allocations so that all cache lines from
        // the page are out of the processor's caches.  The pages are likely to
        // be shared with an external device and the external device may not
        // snoop cache lines.
        //

        if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
            KeFlushCurrentTbAndInvalidateAllCaches();
        }

        MI_UNLOCK_MM(OldIrql);

        return MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber);
    }

    MI_UNLOCK_MM(OldIrql);

    return NULL;
}

VOID
MmFreeContiguousMemory(
    IN PVOID BaseAddress
    )
/*++

Routine Description:

    This function deallocates a range of physically contiguous non-paged
    pool which was allocated with the MmAllocateContiguousMemory function.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    ULONG EndOfAllocation;

    ASSERT(MI_IS_PHYSICAL_ADDRESS(BaseAddress));

    //
    // Release each page in the buffer while looking for the end of allocation
    // marker bit in the PTE.
    //

    MI_LOCK_MM(&OldIrql);

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(BaseAddress);

    do {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        ASSERT(PageFrame->Pte.Hard.Valid != 0);

        EndOfAllocation = MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.GuardOrEndOfAllocation;

        //
        // Insert the page at the tail of the free lists so that we keep this
        // range of contiguous pages free as long as possible in order to
        // satisfy another contiguous memory allocation request.
        //

        MiInsertPageInFreeList(PageFrameNumber, FALSE);

        //
        // Flush the system RAM physical mapping.
        //

        MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

        //
        // Decrement the number of physically mapped pages.
        //

        MmAllocatedPagesByUsage[MmContiguousUsage]--;

        PageFrameNumber++;

    } while (!EndOfAllocation);

    MI_UNLOCK_MM(OldIrql);
}

SIZE_T
MmQueryAllocationSize(
    IN PVOID BaseAddress
    )
/*++

Routine Description:

    This function attempts to query the number of bytes allocated to a range of
    memory.  This is designed to work with memory allocated by
    MmAllocateContiguousMemory or MmAllocateSystemMemory.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

Return Value:

    Number of bytes allocated to the base address.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_COUNT NumberOfPages;
    PMMPTE PointerPte;

    MI_LOCK_MM(&OldIrql);

    //
    // Start with one page for the page of the base address.  Loop over the PTEs
    // of the buffer looking for the end of allocation marker.
    //

    NumberOfPages = 1;
    PointerPte = MiGetPteAddress(BaseAddress);

    while (PointerPte->Hard.GuardOrEndOfAllocation == 0) {

        ASSERT(PointerPte->Hard.Valid != 0);

        NumberOfPages++;
        PointerPte++;
    }

    MI_UNLOCK_MM(OldIrql);

    return NumberOfPages << PAGE_SHIFT;
}

VOID
MmPersistContiguousMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN Persist
    )
/*++

Routine Description:

    This function marks a contiguous memory allocation as needing to be
    preserved across a quick reboot.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

    NumberOfBytes - Supplies the number of bytes to be preserved.

    Persist - Supplies TRUE if the memory should be persisted, else FALSE.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PMMPTE PointerPte;
    PMMPTE EndingPte;

    ASSERT(MI_IS_PHYSICAL_ADDRESS(BaseAddress));
    ASSERT(NumberOfBytes != 0);

    MI_LOCK_MM(&OldIrql);

    PointerPte = MiGetPteAddress(BaseAddress);
    EndingPte = MiGetPteAddress((PCHAR)BaseAddress + NumberOfBytes - 1);
    Persist = Persist ? TRUE : FALSE;

    while (PointerPte <= EndingPte) {

        ASSERT(PointerPte->Hard.Valid != 0);

        PointerPte->Hard.PersistAllocation = Persist;
        PointerPte++;
    }

    MI_UNLOCK_MM(OldIrql);
}

PVOID
MmMapIoSpace(
    IN ULONG_PTR PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function maps the specified physical address into the non-pagable
    portion of the system address space.

Arguments:

    PhysicalAddress - Supplies the starting physical address to map.

    NumberOfBytes - Supplies the number of bytes to map.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    Returns the virtual address which maps the specified physical addresses.
    The value NULL is returned if sufficient virtual address space for
    the mapping could not be found.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    MMPTE TempPte;
    PFN_COUNT NumberOfPtes;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    PFN_NUMBER PageFrameNumber;
    PMMPTE EndingPte;
    PVOID BaseAddress;

    ASSERT (NumberOfBytes != 0);

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(Protect, &TempPte)) {
        return NULL;
    }

    //
    // If the mapping is for device memory, then use one of the physical device
    // mappings if we recoginze the cache type.  These device mappings are
    // identity mapped, so the base address is simply the physical address.
    //

    if ((Protect == (PAGE_READWRITE | PAGE_NOCACHE)) &&
        (PhysicalAddress >= MM_DEVICE_UC_BASE) &&
        (PhysicalAddress + NumberOfBytes <= MM_DEVICE_UC_END)) {
        BaseAddress = (PVOID)PhysicalAddress;
        return BaseAddress;
    }

    if ((Protect == (PAGE_READWRITE | PAGE_WRITECOMBINE)) &&
        (PhysicalAddress >= MM_DEVICE_WC_BASE) &&
        (PhysicalAddress + NumberOfBytes <= MM_DEVICE_WC_END)) {
        BaseAddress = (PVOID)PhysicalAddress;
        goto ReturnWriteCombinedAddress;
    }

    //
    // Reserve the PTEs for the mapped memory.
    //

    NumberOfPtes = COMPUTE_PAGES_SPANNED(PhysicalAddress, NumberOfBytes);

    StartingPte = MiReserveSystemPtes(&MmSystemPteRange, NumberOfPtes);
    if (StartingPte == NULL) {
        return NULL;
    }

    //
    // Fill in the PTEs.
    //

    PageFrameNumber = (PFN_NUMBER)(PhysicalAddress >> PAGE_SHIFT);
    EndingPte = StartingPte + NumberOfPtes;

    for (PointerPte = StartingPte; PointerPte < EndingPte; PointerPte++,
        PageFrameNumber++) {
        TempPte.Hard.PageFrameNumber = PageFrameNumber;
        MI_WRITE_PTE(PointerPte, TempPte);
    }

    //
    // Compute the offset into the mapped region for the requested address.
    //

    BaseAddress = (PCHAR)MiGetVirtualAddressMappedByPte(StartingPte) +
        BYTE_OFFSET(PhysicalAddress);

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
ReturnWriteCombinedAddress:
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    return BaseAddress;
}

VOID
MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function unmaps a range of physical address which were previously
    mapped via an MmMapIoSpace function call.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

    NumberOfBytes - Supplies the number of bytes which were mapped.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    PFN_COUNT NumberOfPtes;
    PMMPTE StartingPte;

    ASSERT(NumberOfBytes != 0);

    if (MI_IS_SYSTEM_PTE_ADDRESS(BaseAddress)) {

        //
        // The physical address was not mapped into a physical mapping window.
        // Free the PTEs that were allocated to map the memory.
        //

        NumberOfPtes = COMPUTE_PAGES_SPANNED(BaseAddress, NumberOfBytes);
        StartingPte = MiGetPteAddress(BaseAddress);

        MiZeroAndFlushPtes(StartingPte, NumberOfPtes);
        MiReleaseSystemPtes(&MmSystemPteRange, StartingPte, NumberOfPtes);
    }
}

VOID
MmLockUnlockBufferPages(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN UnlockPages
    )
/*++

Routine Description:

    This function locks or unlocks the physical pages backing the specified
    buffer.  The routine may be called multiple times for a given buffer and
    buffer ranges may overlap.  Every lock call must be matched by an unlock
    call.

Arguments:

    BaseAddress - Supplies the base virtual address to lock or unlock.

    NumberOfBytes - Supplies the number of bytes to lock or unlock.

    UnlockPages - If TRUE, the pages are unlocked, else the pages are locked.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    ULONG LockCountAdjustment;
    PFN_NUMBER PageFrameNumber;
    PMMPTE PointerPte;
    PMMPTE EndingPte;
    PMMPFN PageFrame;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NumberOfBytes != 0);

    MI_LOCK_MM(&OldIrql);

    ASSERT(MiGetPdeAddress(BaseAddress)->Hard.Valid != 0);

    //
    // If this is a physically mapped address, then there's nothing to lock or
    // unlock.  Locking is used to prevent virtually mapped pages from being
    // relocated while a device is accessing the page.
    //
    // If this is an address backed by a large page, then there's nothing to
    // lock or unlock.  Large pages are used for memory mapped I/O.
    //

    if (!MI_IS_PHYSICAL_ADDRESS(BaseAddress) &&
        (MiGetPdeAddress(BaseAddress)->Hard.LargePage == 0)) {

        LockCountAdjustment = UnlockPages ? (-MI_LOCK_COUNT_UNIT) :
            MI_LOCK_COUNT_UNIT;

        PointerPte = MiGetPteAddress(BaseAddress);
        EndingPte = MiGetPteAddress((PCHAR)BaseAddress + NumberOfBytes - 1);

        do {

            ASSERT(PointerPte->Hard.Valid != 0);

            PageFrameNumber = PointerPte->Hard.PageFrameNumber;

            if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

                PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

                ASSERT(PageFrame->Pte.Hard.Valid == 0);
                ASSERT(PageFrame->Busy.Busy != 0);
                ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
                ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);

                if (UnlockPages) {
                    ASSERT(PageFrame->Busy.LockCount != 0);
                } else {
                    ASSERT(PageFrame->Busy.LockCount != MI_LOCK_COUNT_MAXIMUM);
                }

                PageFrame->Busy.LockCount += LockCountAdjustment;
            }

            PointerPte++;

        } while (PointerPte <= EndingPte);
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
MmLockUnlockPhysicalPage(
    IN ULONG_PTR PhysicalAddress,
    IN BOOLEAN UnlockPage
    )
/*++

Routine Description:

    This function locks or unlocks the specified physical page.

Arguments:

    BaseAddress - Supplies the physical page to lock or unlock.

    UnlockPage - If TRUE, the page is unlocked, else the page is locked.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    MI_LOCK_MM(&OldIrql);

    PageFrameNumber = PhysicalAddress >> PAGE_SHIFT;

    //
    // If this is a physically mapped page or a memory mapped I/O page, then
    // there's nothing to lock or unlock.  Physically mapped pages are by
    // definition always locked and memory mapped I/O addresses are not managed
    // by this code.
    //

    if ((MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.Valid == 0) &&
        (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE)) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        ASSERT(PageFrame->Pte.Hard.Valid == 0);
        ASSERT(PageFrame->Busy.Busy != 0);
        ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
        ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);

        if (UnlockPage) {
            ASSERT(PageFrame->Busy.LockCount != 0);
            PageFrame->Busy.LockCount -= MI_LOCK_COUNT_UNIT;
        } else {
            ASSERT(PageFrame->Busy.LockCount != MI_LOCK_COUNT_MAXIMUM);
            PageFrame->Busy.LockCount += MI_LOCK_COUNT_UNIT;
        }
    }

    MI_UNLOCK_MM(OldIrql);
}

NTSTATUS
MmLockSelectedIoPages(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OUT PIRP Irp,
    IN BOOLEAN MapUserBuffer
    )
/*++

Routine Description:

    This function locks the pages described by the supplied file segment element
    array.  A copy of the array is placed in the supplied I/O request packet.
    Optionally, the file segment element array is mapped to a virtual buffer in
    system space for target devices that do not support scatter/gather I/O.

Arguments:

    SegmentArray - Supplies the list of file segments to be locked.

    Length - Supplies the number of bytes contained in the segment array.

    Irp - Supplies a pointer to the I/O request packet to receive a copy of the
        segment array as well as the optional virtual mapping.

    MapUserBuffer - Supplies whether or not to map a virtual user buffer for the
        segment array.

Return Value:

    Status of operation.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    PFN_COUNT NumberOfPages;
    PFILE_SEGMENT_ELEMENT SegmentArrayClone;
    PMMPTE MappingPte;
    KIRQL OldIrql;
    PFILE_SEGMENT_ELEMENT EndingSegmentArray;
    PVOID BufferAddress;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    MMPTE TempPte;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(Length != 0);

    NumberOfPages = ROUND_TO_PAGES(Length) >> PAGE_SHIFT;

    //
    // Allocate the array to hold the copy of the segment array and perform the
    // copy.
    //

    SegmentArrayClone = (PFILE_SEGMENT_ELEMENT)ExAllocatePoolWithTag(
        sizeof(FILE_SEGMENT_ELEMENT) * NumberOfPages, 'aSmM');

    if (SegmentArrayClone == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(SegmentArrayClone, SegmentArray,
        sizeof(FILE_SEGMENT_ELEMENT) * NumberOfPages);

    //
    // If we need to map a virtual buffer for the segment array, then reserve
    // the PTEs now.
    //

    if (MapUserBuffer) {

        MappingPte = MiReserveSystemPtes(&MmSystemPteRange, NumberOfPages);

        if (MappingPte == NULL) {
            ExFreePool(SegmentArrayClone);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Fill the I/O request packet with the mapped user buffer and set a
        // flag so that MmUnlockSelectedIoPages knows to release the mapping.
        //

        Irp->UserBuffer = MiGetVirtualAddressMappedByPte(MappingPte);
        Irp->Flags |= IRP_UNMAP_SEGMENT_ARRAY;

    } else {
        MappingPte = NULL;
    }

    //
    // Loop over the segment array and lock down each of the page buffers.
    //

    MI_LOCK_MM(&OldIrql);

    EndingSegmentArray = SegmentArray + NumberOfPages;

    while (SegmentArray < EndingSegmentArray) {

        BufferAddress = SegmentArray->Buffer;

        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.Valid != 0);
        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.LargePage == 0);

        if (!MI_IS_PHYSICAL_ADDRESS(BufferAddress)) {

            ASSERT(MiGetPteAddress(BufferAddress)->Hard.Valid != 0);

            PageFrameNumber = MiGetPteAddress(BufferAddress)->Hard.PageFrameNumber;

            if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

                PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

                ASSERT(PageFrame->Pte.Hard.Valid == 0);
                ASSERT(PageFrame->Busy.Busy != 0);
                ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
                ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);
                ASSERT(PageFrame->Busy.LockCount != MI_LOCK_COUNT_MAXIMUM);

                PageFrame->Busy.LockCount += MI_LOCK_COUNT_UNIT;
            }

        } else {
            PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(BufferAddress);
        }

        //
        // If we need to map a virtual buffer for the segment array, then fill
        // in the next mapping PTE.
        //

        if (MappingPte != NULL) {
            TempPte.Long = MiGetValidKernelPteBits();
            TempPte.Hard.PageFrameNumber = PageFrameNumber;
            MI_WRITE_PTE(MappingPte, TempPte);
            MappingPte++;
        }

        SegmentArray++;
    }

    MI_UNLOCK_MM(OldIrql);

    //
    // Fill the I/O request packet with the copy of the segment array and the
    // number of bytes that are locked down.  These are used by
    // MmUnlockSelectedIoPages.
    //

    Irp->SegmentArray = SegmentArrayClone;
    Irp->LockedBufferLength = Length;

    return STATUS_SUCCESS;
}

VOID
MmUnlockSelectedIoPages(
    IN PIRP Irp
    )
/*++

Routine Description:

    This function unlocks the pages described by the file segment element
    pointed to by the supplied I/O request packet.  Optionally, the virtual
    mapping created by MmLockSelectedPages is unmapped.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    PFN_COUNT NumberOfPages;
    PMMPTE MappingPte;
    KIRQL OldIrql;
    PFILE_SEGMENT_ELEMENT SegmentArray;
    PFILE_SEGMENT_ELEMENT EndingSegmentArray;
    PVOID BufferAddress;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(Irp->SegmentArray != NULL);
    ASSERT(Irp->LockedBufferLength != 0);

    NumberOfPages = ROUND_TO_PAGES(Irp->LockedBufferLength) >> PAGE_SHIFT;

    //
    // If we mapped a virtual buffer for the segment array, then release the
    // PTEs now.
    //

    if (Irp->Flags & IRP_UNMAP_SEGMENT_ARRAY) {

        ASSERT(Irp->UserBuffer != NULL);

        MappingPte = MiGetPteAddress(Irp->UserBuffer);

        MiZeroAndFlushPtes(MappingPte, NumberOfPages);
        MiReleaseSystemPtes(&MmSystemPteRange, MappingPte, NumberOfPages);

        Irp->UserBuffer = NULL;
        Irp->Flags &= ~IRP_UNMAP_SEGMENT_ARRAY;
    }

    //
    // Loop over the segment array and unlock each of the page buffers.
    //

    MI_LOCK_MM(&OldIrql);

    SegmentArray = Irp->SegmentArray;
    EndingSegmentArray = SegmentArray + NumberOfPages;

    while (SegmentArray < EndingSegmentArray) {

        BufferAddress = SegmentArray->Buffer;

        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.Valid != 0);
        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.LargePage == 0);

        if (!MI_IS_PHYSICAL_ADDRESS(BufferAddress)) {

            ASSERT(MiGetPteAddress(BufferAddress)->Hard.Valid != 0);

            PageFrameNumber = MiGetPteAddress(BufferAddress)->Hard.PageFrameNumber;

            if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

                PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

                ASSERT(PageFrame->Pte.Hard.Valid == 0);
                ASSERT(PageFrame->Busy.Busy != 0);
                ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
                ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);
                ASSERT(PageFrame->Busy.LockCount != 0);

                PageFrame->Busy.LockCount -= MI_LOCK_COUNT_UNIT;
            }
        }

        SegmentArray++;
    }

    MI_UNLOCK_MM(OldIrql);

    //
    // Free the memory for the copied segment array.
    //

    ExFreePool(Irp->SegmentArray);

    Irp->SegmentArray = NULL;
}

PVOID
MmClaimGpuInstanceMemory(
    IN SIZE_T NumberOfBytes,
    OUT SIZE_T *NumberOfPaddingBytes
    )
/*++

Routine Description:

    This function returns the ending physical address and number of instance
    padding bytes for instance memory used by the NVIDIA NV2A.

Arguments:

    NumberOfBytes - Specifies the number of bytes to leave allocated for
        instance memory, or MAXULONG_PTR if no change in instance memory
        allocation should be made (used by the startup animation).

    NumberOfPaddingBytes - Specifies the location to receive the number of bytes
        that are reserved from the top of memory for other system use.

Return Value:

    Returns the virtual address of the pointer to the last byte, not inclusive,
    of the instance memory.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PFN_NUMBER EndingPageFrameNumber;

    //
    // The number of padding bytes indicates the number of bytes that must be
    // skipped over in order to reach the first byte of the instance memory.
    //
    // For a retail console configuration, the top 64K of memory is used to
    // store the PFN database.  For a 128M configuration, we'll also reserve the
    // top 64K of memory in order to make the code simpler.
    //

#ifdef ARCADE
    *NumberOfPaddingBytes = 0;
#else
    *NumberOfPaddingBytes = MI_CONVERT_PFN_TO_PHYSICAL(MM_64M_PHYSICAL_PAGE) -
        MI_CONVERT_PFN_TO_PHYSICAL(MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT);
#endif

    //
    // The startup animation code will call us with a number of bytes set to
    // MAXULONG_PTR.  At this point, don't free any of the instance memory
    // pages.
    //

    if (NumberOfBytes != MAXULONG_PTR) {

        MI_LOCK_MM(&OldIrql);

        NumberOfBytes = ROUND_TO_PAGES(NumberOfBytes);

        //
        // Verify that the requested allocation size is equal to or less than
        // the number of bytes already set aside for instance memory.
        //

        ASSERT(NumberOfBytes <= MmNumberOfInstanceMemoryBytes);

        //
        // Compute the number of pages that can be freed as instance memory and
        // made available for other use.
        //

        PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT -
            BYTES_TO_PAGES(MmNumberOfInstanceMemoryBytes);
        EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE +
            MM_INSTANCE_PAGE_COUNT - BYTES_TO_PAGES(NumberOfBytes);

        while (PageFrameNumber < EndingPageFrameNumber) {

            ASSERT(MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.Valid != 0);

            //
            // Insert the page at the head of the free lists.  We don't allow
            // contiguous memory allocations to cross into the instance memory
            // region, so these pages might as well be allocated ahead of other
            // pages that could be used for contiguous memory allocations.
            //

            MiInsertPageInFreeList(PageFrameNumber, TRUE);

            MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

            MmAllocatedPagesByUsage[MmContiguousUsage]--;

#ifdef CONSOLE_DEVKIT
            //
            // On a development kit system, the NVIDIA NV2A instance memory must
            // be relative to the top of memory, so we also reserve the instance
            // memory pages in the upper half of memory.
            //

            if (MM_HIGHEST_PHYSICAL_PAGE != MM_64M_PHYSICAL_PAGE - 1) {

                ASSERT(MI_PFN_ELEMENT(MM_64M_PHYSICAL_PAGE + PageFrameNumber)->Pte.Hard.Valid != 0);

                MiInsertPageInFreeList(MM_64M_PHYSICAL_PAGE + PageFrameNumber,
                    TRUE);

                MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(MM_64M_PHYSICAL_PAGE +
                    PageFrameNumber));

                MmAllocatedPagesByUsage[MmContiguousUsage]--;
            }
#endif

            PageFrameNumber++;
        }

        MmNumberOfInstanceMemoryBytes = NumberOfBytes;

        MI_UNLOCK_MM(OldIrql);
    }

    //
    // Return the virtual address of the non-inclusive ending byte of the
    // instance memory allocation.  This pointer is always relative to the top
    // of memory.
    //

    return (PUCHAR)MI_CONVERT_PFN_TO_PHYSICAL(MM_HIGHEST_PHYSICAL_PAGE + 1) -
        *NumberOfPaddingBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\mmsup.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    mmsup.c

Abstract:

    This module implements the various routines for miscellaneous support
    operations for memory management.

--*/

#include "mi.h"

//
// Table to convert external protection codes to internal memory manager codes.
//

const CCHAR MmProtectToPteProtectionMask[16] = {
    -1,
    MM_PTE_READONLY,
    MM_PTE_READONLY,
    -1,
    MM_PTE_READWRITE,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
};

BOOLEAN
MmIsAddressValid(
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    For a given virtual address this function returns TRUE if no page fault
    will occur for a read operation on the address, FALSE otherwise.

    Note that after this routine was called, if appropriate locks are not
    held, a non-faulting address could fault.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

Return Value:

    TRUE if a no page fault would be generated reading the virtual address,
    FALSE otherwise.

Environment:

    Kernel mode.

--*/
{
    PMMPTE PointerPte;

    PointerPte = MiGetPdeAddress (VirtualAddress);
    if (PointerPte->Hard.Valid == 0) {
        return FALSE;
    }

    if (PointerPte->Hard.LargePage != 0) {
        return TRUE;
    }

    PointerPte = MiGetPteAddress (VirtualAddress);
    if (PointerPte->Hard.Valid == 0) {
        return FALSE;
    }

    //
    // Make sure we're not treating a page directory as a page table here for
    // the case where the page directory is mapping a large page.  This is
    // because the large page bit is valid in PDE formats, but reserved in
    // PTE formats and will cause a trap.  A virtual address like c0200000
    // triggers this case.  It's not enough to just check the large page bit
    // in the PTE below because of course that bit's been reused by other
    // steppings of the processor so we have to look at the address too.
    //
    if (PointerPte->Hard.LargePage != 0) {
        PVOID Va;

        Va = MiGetVirtualAddressMappedByPde (PointerPte);
        if (MI_IS_PHYSICAL_ADDRESS(Va)) {
            return FALSE;
        }
    }

    return TRUE;
}

PVOID
MiAllocateMappedMemory(
    IN PMMPTERANGE PteRange,
    IN MMPFN_BUSY_TYPE BusyType,
    IN ULONG Protect,
    IN SIZE_T NumberOfBytes,
    IN PMMREMOVE_PAGE_ROUTINE RemovePageRoutine,
    IN BOOLEAN AddBarrierPage
    )
/*++

Routine Description:

    This routine allocates a number of pages in the system part of the address
    space.  The page frames are marked with the supplied busy type code and the
    PTEs are configured with the supplied cache type.  The RemovePageRoutine
    parameter is used to specify the source of the pages (non-zeroed, zeroed,
    etc.).

Arguments:

    PteRange - Supplies the PTE range to allocate the pages from.

    BusyType - Usage code to place in allocated page frame.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

    NumberOfBytes - Supplies the number of byte to allocate.

    RemovePageRoutine - Supplies the allocator routine to use grab pages.

    AddBarrierPage - Supplies whether or not to add an extra barrier page.

Return Value:

    Returns the virtual address of the allocated memory.  When AddBarrierPage is
    TRUE, the returned address points at the barrier page.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    MMPTE TempPte;
    KIRQL OldIrql;
    PFN_COUNT NumberOfPages;
    PFN_COUNT NumberOfPtes;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    PMMPTE EndingPte;

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(Protect, &TempPte)) {
        return NULL;
    }

    MI_LOCK_MM(&OldIrql);

    //
    // Compute the number of pages to allocate.
    //

    NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
    ASSERT(NumberOfPages != 0);

    //
    // Verify that there are enough pages available to satisfy the request.
    // This check doesn't take into account the pages that may be taken when we
    // reserve system PTEs below.
    //

    if (*PteRange->AvailablePages < NumberOfPages) {
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    //
    // Compute the number of PTEs that will be required to map the allocated
    // memory.
    //

    NumberOfPtes = NumberOfPages;

    if (AddBarrierPage) {
        NumberOfPtes++;
    }

    //
    // Reserve the PTEs for the allocated memory.
    //

    StartingPte = MiReserveSystemPtes(PteRange, NumberOfPtes);

    if (StartingPte == NULL) {
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    PointerPte = StartingPte;

    //
    // Verify that there are enough pages available to satisfy the request.  We
    // have to check again after reserving the system PTEs because that may have
    // consumed the pages that we thought we had available above.
    //

    if (*PteRange->AvailablePages < NumberOfPages) {
        MiReleaseSystemPtes(PteRange, StartingPte, NumberOfPtes);
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    if (AddBarrierPage) {

        //
        // Fill in the barrier page to protect against stack overflow errors.
        //

        MI_WRITE_ZERO_PTE(PointerPte);
        PointerPte++;
    }

    //
    // Allocate the pages.
    //

    EndingPte = PointerPte + NumberOfPages - 1;

    while (PointerPte <= EndingPte) {
        TempPte.Hard.PageFrameNumber = RemovePageRoutine(BusyType, PointerPte);
        MI_WRITE_PTE(PointerPte, TempPte);
        PointerPte++;
    }

    //
    // Mark the last page of the allocation so that we can find it later if we
    // need to free the buffer without knowing the original size.
    //

    EndingPte->Hard.GuardOrEndOfAllocation = 1;

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);

    return MiGetVirtualAddressMappedByPte(StartingPte);
}

PFN_COUNT
MiFreeMappedMemory(
    IN PMMPTERANGE PteRange,
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes OPTIONAL
    )
/*++

Routine Description:

    This routine deallocates a number of pages in the system part of the address
    space.  This is designed to free pages acquired via MiAllocateMappedMemory.

    For stack allocations, the BaseAddress parameter should be pointing at the
    barrier page and NumberOfBytes should include the size of the barrier page.

Arguments:

    PteRange - Supplies the PTE range to free the pages to.

    BaseAddress - Supplies the virtual address of the buffer.

    NumberOfBytes - Supplies the number of bytes in the buffer.  If the count is
                    zero, then the routine attempts to determine the size of the
                    buffer by finding the page frame with the "end of
                    allocation" flag set.

Return Value:

    Returns the number of pages deallocated.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    MMPTE TempPte;
    PMMPTE EndingPte;
    PFN_NUMBER PageFrameNumber;
    ULONG EndOfAllocation;
    PFN_COUNT NumberOfPages;

    ASSERT(MiGetPteAddress(BaseAddress) >= PteRange->FirstCommittedPte);
    ASSERT(MiGetPteAddress(BaseAddress) < PteRange->LastCommittedPte);
    ASSERT(((ULONG_PTR)BaseAddress & (PAGE_SIZE - 1)) == 0);

    //
    // Free the pages.
    //

    MI_LOCK_MM(&OldIrql);

    StartingPte = MiGetPteAddress(BaseAddress);
    PointerPte = StartingPte;
    TempPte.Long = 0;

    if (NumberOfBytes != 0) {

        EndingPte = StartingPte + BYTES_TO_PAGES(NumberOfBytes) - 1;

        while (PointerPte <= EndingPte) {

            //
            // If we know the size of the original allocation, then the caller
            // is allowed to free any pages in the original allocation.  For
            // example, the loader may have freed pages used at initialization
            // time only.
            //

            if (PointerPte->Hard.Valid != 0) {
                PageFrameNumber = PointerPte->Hard.PageFrameNumber;
                MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
                MiReleasePageOwnership(PageFrameNumber);
            }

            PointerPte++;
        }

    } else {

        do {

            //
            // If we don't know the size of the original allocation, then the
            // caller must not free any of the pages since the page frame is
            // used to store the "end of allocation" flag.
            //

            ASSERT(PointerPte->Hard.Valid != 0);

            PageFrameNumber = PointerPte->Hard.PageFrameNumber;
            EndOfAllocation = PointerPte->Hard.GuardOrEndOfAllocation;
            MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
            MiReleasePageOwnership(PageFrameNumber);

            PointerPte++;

        } while (!EndOfAllocation);
    }

    //
    // Release the PTEs for the allocated memory.
    //

    NumberOfPages = PointerPte - StartingPte;
    MiReleaseSystemPtes(PteRange, StartingPte, NumberOfPages);

    MI_UNLOCK_MM(OldIrql);

    return NumberOfPages;
}

BOOLEAN
FASTCALL
MiMakePteProtectionMask(
    IN ULONG Protect,
    OUT PULONG PteProtectionMask
    )
/*++

Routine Description:

    This routine translates the access protection code used by external APIs
    to the PTE bit mask that implements that policy.

Arguments:

    Protect - Supplies the protection code (e.g., PAGE_READWRITE).

    PteProtectionMask - Supplies a pointer to the variable that will receive
                        the PTE protection mask (e.g., MM_PTE_READWRITE).

Return Value:

    TRUE if the protection code was successfully decoded, else FALSE.

Environment:

    Kernel mode.

--*/
{
    ULONG Field1;
    ULONG Field2;
    ULONG Mask;

    //
    // Check for unknown protection bits.
    //

    if (Protect & ~(PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE | 0xFF)) {
        return FALSE;
    }

    //
    // None of the protection attributes are valid for "no access" pages.
    //

    if (Protect & PAGE_NOACCESS) {

        if (Protect & (PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE)) {
            return FALSE;
        }
    }

    //
    // Only one of the cache protection attributes may be specified.
    //

    if ((Protect & PAGE_NOCACHE) && (Protect & PAGE_WRITECOMBINE)) {
        return FALSE;
    }

    //
    // One of the nibbles must be non-zero and the other must be zero.
    //

    Field1 = Protect & 0xF;
    Field2 = (Protect >> 4) & 0xF;

    if ((Field1 == 0 && Field2 == 0) || (Field1 != 0 && Field2 != 0)) {
        return FALSE;
    }

    //
    // Check if the table knows how to translate the protection code.
    //

    Mask = (ULONG)(LONG)(CCHAR)MmProtectToPteProtectionMask[Field1 | Field2];

    if (Mask == (ULONG)-1) {
        return FALSE;
    }

    //
    // Apply the rest of the protection attributes to the PTE mask.
    //

    if ((Protect & (PAGE_NOACCESS | PAGE_GUARD)) == 0) {
        Mask |= MM_PTE_VALID_MASK;
    } else if (Protect & PAGE_GUARD) {
        Mask |= MM_PTE_GUARD;
    }

    if (Protect & PAGE_NOCACHE) {
        Mask |= MM_PTE_CACHE_DISABLE_MASK;
    } else if (Protect & PAGE_WRITECOMBINE) {
        Mask |= MM_PTE_WRITE_THROUGH_MASK;
    }

    ASSERT((Mask & ~(MM_PTE_PROTECTION_MASK)) == 0);

    *PteProtectionMask = Mask;

    return TRUE;
}

BOOLEAN
FASTCALL
MiMakeSystemPteProtectionMask(
    IN ULONG Protect,
    OUT PMMPTE ProtoPte
    )
/*++

Routine Description:

    This routine translates the access protection code used by external APIs
    to the PTE bit mask that implements that policy.

Arguments:

    Protect - Supplies the protection code (e.g., PAGE_READWRITE).

    ProtoPte - Supplies a pointer to the variable that will receive
               the PTE protection mask (e.g., MM_PTE_READWRITE).

Return Value:

    TRUE if the protection code was successfully decoded, else FALSE.

Environment:

    Kernel mode.

--*/
{
    ULONG Mask;

    Mask = 0;

    //
    // Check for unknown protection bits.
    //

    if (Protect & ~(PAGE_NOCACHE | PAGE_WRITECOMBINE | PAGE_READWRITE |
        PAGE_READONLY)) {
        return FALSE;
    }

    //
    // Only one of the page protection attributes may be specified.
    //

    switch (Protect & (PAGE_READONLY | PAGE_READWRITE)) {

        case PAGE_READONLY:
            Mask = (MM_PTE_VALID_MASK | MM_PTE_DIRTY_MASK | MM_PTE_ACCESS_MASK);
            break;

        case PAGE_READWRITE:
            Mask = (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_DIRTY_MASK |
                MM_PTE_ACCESS_MASK);
            break;

        default:
            return FALSE;
    }

    //
    // Only one of the cache protection attributes may be specified.
    //

    switch (Protect & (PAGE_NOCACHE | PAGE_WRITECOMBINE)) {

        case 0:
            break;

        case PAGE_NOCACHE:
            Mask |= MM_PTE_CACHE_DISABLE_MASK;
            break;

        case PAGE_WRITECOMBINE:
            Mask |= MM_PTE_WRITE_THROUGH_MASK;
            break;

        default:
            return FALSE;
    }

    ProtoPte->Long = Mask;

    return TRUE;
}

ULONG
FASTCALL
MiDecodePteProtectionMask(
    IN ULONG PteProtectionMask
    )
/*++

Routine Description:

    This routine translate a PTE protection bit mask into the external access
    protection code used by external APIs.

Arguments:

    PteProtectionMask - Supplies the PTE protection bit mask.

Return Value:

    The protection code equivalent (e.g., PAGE_READWRITE).

Environment:

    Kernel mode.

--*/
{
    ULONG Protect;

    if (PteProtectionMask & MM_PTE_READWRITE) {
        Protect = PAGE_READWRITE;
    } else {
        Protect = PAGE_READONLY;
    }

    if ((PteProtectionMask & MM_PTE_VALID_MASK) == 0) {

        if (PteProtectionMask & MM_PTE_GUARD) {
            Protect |= PAGE_GUARD;
        } else {
            Protect = PAGE_NOACCESS;
        }
    }

    if (PteProtectionMask & MM_PTE_CACHE_DISABLE_MASK) {
        Protect |= PAGE_NOCACHE;
    } else if (PteProtectionMask & MM_PTE_WRITE_THROUGH_MASK) {
        Protect |= PAGE_WRITECOMBINE;
    }

    return Protect;
}

ULONG
MmQueryAddressProtect(
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This routine queries the protection code associated with the specified base
    address.

Arguments:

    VirtualAddress - Supplies the virtual address to return the protection code
                     for.

Return Value:

    Returns the page protection code.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    ULONG Protect;
    KIRQL OldIrql;
    PMMPTE PointerPte;
    MMPTE TempPte;

    MI_LOCK_MM(&OldIrql);

    PointerPte = MiGetPdeAddress(VirtualAddress);
    TempPte = *PointerPte;

    if (TempPte.Hard.Valid != 0) {

        if (TempPte.Hard.LargePage == 0) {

            PointerPte = MiGetPteAddress(VirtualAddress);
            TempPte = *PointerPte;

            //
            // Addresses in system space must be marked as valid.  Addresses in
            // user space may be marked invalid if they are PAGE_NOACCESS or
            // PAGE_GUARD pages.
            //

            if ((TempPte.Hard.Valid != 0) ||
                ((TempPte.Long != 0) && (VirtualAddress <= MM_HIGHEST_USER_ADDRESS))) {
                Protect = MiDecodePteProtectionMask(TempPte.Long);
            } else {
                Protect = 0;
            }

        } else {
            Protect = MiDecodePteProtectionMask(TempPte.Long);
        }

    } else {
        Protect = 0;
    }

    MI_UNLOCK_MM(OldIrql);

    return Protect;
}

VOID
MmSetAddressProtect(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
    )
/*++

Routine Description:

    This routine applies the protection code to the specified address range.

Arguments:

    BaseAddress - Supplies the starting virtual address to change the protection
                  code for.

    NumberOfBytes - Supplies the number of bytes to change.

    NewProtect - Supplies the type of protection and cache mapping to use for
                 the allocation.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    MMPTE ProtoPte;
    KIRQL OldIrql;
    PMMPTE PointerPte;
    PMMPTE EndingPte;
    MMPTE TempPte;

    ASSERT(MI_IS_PHYSICAL_ADDRESS(BaseAddress) || MI_IS_SYSTEM_PTE_ADDRESS(BaseAddress));
    ASSERT(NumberOfBytes != 0);

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(NewProtect, &ProtoPte)) {
        return;
    }

    MI_LOCK_MM(&OldIrql);

    PointerPte = MiGetPteAddress(BaseAddress);
    EndingPte = MiGetPteAddress((PUCHAR)BaseAddress + NumberOfBytes - 1);

    while (PointerPte <= EndingPte) {

        TempPte = *PointerPte;

        ASSERT(TempPte.Hard.Valid != 0);

        if ((TempPte.Long & MM_SYSTEM_PTE_PROTECTION_MASK) != ProtoPte.Long) {

            TempPte.Long = ((TempPte.Long & ~MM_SYSTEM_PTE_PROTECTION_MASK) |
                ProtoPte.Long);

            MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
        }

        PointerPte++;
    }

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (NewProtect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);
}

NTSTATUS
MmQueryStatistics(
    IN OUT PMM_STATISTICS MemoryStatistics
    )
/*++

Routine Description:

    This routine returns various statistics about the state of the memory
    manager subsystem.

Arguments:

    MemoryStatistics - Supplies the buffer to fill with the memory manager's
        statistics.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;

    if (MemoryStatistics->Length == sizeof(MM_STATISTICS)) {

        MI_LOCK_MM(&OldIrql);

        MemoryStatistics->TotalPhysicalPages = MmNumberOfPhysicalPages;
        MemoryStatistics->AvailablePages = MmAvailablePages;
        MemoryStatistics->VirtualMemoryBytesCommitted =
            ((MmAllocatedPagesByUsage[MmVirtualMemoryUsage] +
            MmAllocatedPagesByUsage[MmImageUsage]) << PAGE_SHIFT);
        MemoryStatistics->VirtualMemoryBytesReserved = MmVirtualMemoryBytesReserved;
        MemoryStatistics->CachePagesCommitted = MmAllocatedPagesByUsage[MmFsCacheUsage];
        MemoryStatistics->PoolPagesCommitted = MmAllocatedPagesByUsage[MmPoolUsage];
        MemoryStatistics->StackPagesCommitted = MmAllocatedPagesByUsage[MmStackUsage];
        MemoryStatistics->ImagePagesCommitted = MmAllocatedPagesByUsage[MmImageUsage];

        MI_UNLOCK_MM(OldIrql);

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

PVOID
MmAllocateSystemMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function allocates a range of memory in the non-paged portion of the
    system address space.

    This routine is designed to be used by a driver's initialization
    routine to allocate a noncached block of virtual memory for various device
    specific buffers.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

    NULL - The specified request could not be satisfied.

Environment:

    Kernel mode, <= DISPATCH_LEVEL

--*/
{
    return MiAllocateMappedMemory(&MmSystemPteRange, MmSystemMemoryUsage,
        Protect, NumberOfBytes, MiRemoveAnyPage, FALSE);
}

ULONG
MmFreeSystemMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function deallocates a range of memory in the non-paged portion of the
    system address space.  This is designed to free pages acquired via
    MmAllocateSystemMemory only.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

    NumberOfBytes - Supplies the number of bytes allocated to the request.
                    This must be the same number that was obtained with
                    the MmAllocateSystemMemory call.

Return Value:

    Returns the number of pages deallocated.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    return MiFreeMappedMemory(&MmSystemPteRange, BaseAddress, NumberOfBytes);
}

PVOID
MmAllocatePoolPages(
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a set of pages from the specified pool
    and returns the starting virtual address to the caller.

Arguments:

    NumberOfBytes - Supplies the size of the request in bytes.  The actual
                    size returned is rounded up to a page boundary.

Return Value:

    Returns a pointer to the allocated pool, or NULL if no more pool is
    available.

Environment:

    These functions are used by the general pool allocation routines
    and should not be called directly.

    Mutexes guarding the pool databases must be held when calling
    these functions.

    Kernel mode, IRQL at DISPATCH_LEVEL.

--*/
{
    PVOID StartingAddress;

    StartingAddress = MiAllocateMappedMemory(&MmSystemPteRange, MmPoolUsage,
        PAGE_READWRITE, NumberOfBytes, MiRemoveAnyPage, FALSE);

#if DBG
    if (StartingAddress != NULL) {
        RtlFillMemoryUlong(StartingAddress, NumberOfBytes, 'looP');
    }
#endif

    return StartingAddress;
}

ULONG
MmFreePoolPages(
    IN PVOID StartingAddress
    )
/*++

Routine Description:

    This function returns a set of pages back to the pool from
    which they were obtained.  Once the pages have been deallocated
    the region provided by the allocation becomes available for
    allocation to other callers, i.e. any data in the region is now
    trashed and cannot be referenced.

Arguments:

    StartingAddress - Supplies the starting address which was returned
                      in a previous call to MmAllocatePoolPages.

Return Value:

    Returns the number of pages deallocated.

Environment:

    These functions are used by the general pool allocation routines
    and should not be called directly.

    Mutexes guarding the pool databases must be held when calling
    these functions.

--*/
{
#if DBG
    //
    // The number of pages may exceed one for a large pool allocation, but we'll
    // do the simple thing and just assume a single page here.
    //

    RtlFillMemoryUlong(StartingAddress, PAGE_SIZE, 'daeD');
#endif

    return MiFreeMappedMemory(&MmSystemPteRange, StartingAddress, 0);
}

PVOID
MmCreateKernelStack(
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN DebuggerThread
    )
/*++

Routine Description:

    This routine allocates a kernel stack and a no-access page within
    the non-pagable portion of the system address space.

Arguments:

    NumberOfBytes - Supplies the size of the request in bytes.  The actual
                    size returned is rounded up to a page boundary.

    DebuggerThread - Supplies TRUE if this thread's stack should be allocated
                     from the extra memory available on a development kit or
                     from the retail memory region.

Return Value:

    Returns a pointer to the base of the kernel stack.  Note, that the
    base address points to the guard page, so space must be allocated
    on the stack before accessing the stack.

    If a kernel stack cannot be created, the value NULL is returned.

Environment:

    Kernel mode.  APCs Disabled.

--*/
{
    PMMPTERANGE PteRange;
    PMMREMOVE_PAGE_ROUTINE RemovePageRoutine;
    MMPFN_BUSY_TYPE BusyType;
    PVOID KernelStackBottom;
    SIZE_T ActualNumberOfBytes;

    ASSERT(NumberOfBytes != 0);
    ASSERT((NumberOfBytes & (PAGE_SIZE - 1)) == 0);

    //
    // Determine which PTE address range to allocate the stack from.
    //

    PteRange = &MmSystemPteRange;
    RemovePageRoutine = MiRemoveAnyPage;
    BusyType = MmStackUsage;

#ifdef DEVKIT
    if (DebuggerThread) {
        PteRange = &MmDeveloperKitPteRange;
        RemovePageRoutine = MmDeveloperKitPteRange.RemovePageRoutine;
        BusyType = MmDebuggerUsage;
    }
#endif

    //
    // Allocate the stack.  Note that an extra barrier page will be added to the
    // allocation.
    //

    KernelStackBottom = MiAllocateMappedMemory(PteRange, BusyType,
        PAGE_READWRITE, NumberOfBytes, RemovePageRoutine, TRUE);
    ActualNumberOfBytes = NumberOfBytes + PAGE_SIZE;

    if (KernelStackBottom == NULL) {
        return NULL;
    }

#if DBG
    RtlFillMemoryUlong((PCHAR)KernelStackBottom + PAGE_SIZE, NumberOfBytes,
        'katS');
#endif

    return (PCHAR)KernelStackBottom + ActualNumberOfBytes;
}

VOID
MmDeleteKernelStack(
    IN PVOID KernelStackBase,
    IN PVOID KernelStackLimit
    )
/*++

Routine Description:

    This routine deletes a kernel stack and the no-access page within
    the non-pagable portion of the system address space.

Arguments:

    KernelStackBase - Supplies a pointer to the base of the kernel stack.

    KernelStackLimit - Supplies a pointer to the limit of the kernel stack.

Return Value:

    None.

Environment:

    Kernel mode.  APCs Disabled.

--*/
{
    PMMPTERANGE PteRange;
    SIZE_T ActualNumberOfBytes;
    PVOID KernelStackBottom;

    //
    // Determine which PTE range allocated the stack.
    //

    PteRange = &MmSystemPteRange;

#ifdef DEVKIT
    if (!MI_IS_SYSTEM_PTE_ADDRESS(KernelStackLimit)) {
        PteRange = &MmDeveloperKitPteRange;
    }
#endif

    //
    // Free the stack.  Note that an extra barrier page had been added to the
    // allocation.
    //

    ActualNumberOfBytes = ((PCHAR)KernelStackBase - (PCHAR)KernelStackLimit) +
        PAGE_SIZE;

    ASSERT((ActualNumberOfBytes & (PAGE_SIZE - 1)) == 0);

    KernelStackBottom = (PCHAR)KernelStackBase - ActualNumberOfBytes;

    MiFreeMappedMemory(PteRange, KernelStackBottom, ActualNumberOfBytes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\sysptes.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    sysptes.c

Abstract:

    This module implements the functions to manipulate the system PTE space.
    These PTES are used to map kernel stacks, pool pages, and I/O devices.

--*/

#include "mi.h"

//
// Define a macro to access the size for free blocks larger than one entry.
//
#define MI_PTE_LIST_LARGE_BLOCK_SIZE(ppte) (((ppte)+1)->List.NextEntry)

//
// Define a macro to get the next entry from a PTE list.
//
#define MI_PTE_LIST_NEXT_ENTRY(ppte) ((PMMPTE)((ppte)->Long & MM_PTE_NEXT_ENTRY_MASK))

//
// Define a macro to encode the next entry value for the supplied PTE.
//
#define MI_PTE_LIST_ENCODE_NEXT_ENTRY(ppte) (((ULONG)(ppte)) >> 2)

//
// PTE range starting at MM_SYSTEM_PTE_BASE.
//
MMPTERANGE MmSystemPteRange = {
    { MM_EMPTY_PTE_LIST << 2 },
    MiGetPteAddress(MM_SYSTEM_PTE_BASE),
    MiGetPteAddress(MM_SYSTEM_PTE_BASE),
    MiGetPteAddress(MM_SYSTEM_PTE_END + 1),
    &MmAvailablePages,
    MiRemoveZeroPage
};

#ifdef DEVKIT
//
// PTE range starting at MM_DEVKIT_PTE_BASE.
//
// To allow consoles with only 64 megabytes to still be able to load the debug
// monitor, fall back on using the retail allocators.
//
// Arcade retail and DEVKIT units have the same amount of memory, so always use
// the retail allocators.
//
MMPTERANGE MmDeveloperKitPteRange = {
    { MM_EMPTY_PTE_LIST << 2 },
    MiGetPteAddress(MM_DEVKIT_PTE_BASE),
    MiGetPteAddress(MM_DEVKIT_PTE_BASE),
    MiGetPteAddress(MM_DEVKIT_PTE_END + 1),
#ifdef ARCADE
    &MmAvailablePages,
    MiRemoveZeroPage
#else
    &MmDeveloperKitPfnRegion.AvailablePages,
    MiRemoveDebuggerPage
#endif
};
#endif

PMMPTE
MiReserveSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PFN_COUNT NumberOfPtes
    )
/*++

Routine Description:

    This routine allocates the specified number of contiguous PTE slots from the
    system page tables.

Arguments:

    PteRange - Supplies the PTE range to allocate the PTEs from.

    NumberOfPtes - Supplies the number of contiguous PTE slots to allocate.

Return Value:

    Returns a pointer to the first allocated PTE.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PMMPTE LastPointerPte;
    PMMPTE PointerPte;
    PFN_COUNT ExtraPtes;
    PFN_COUNT PtesToCommit;
    PFN_COUNT NumberOfPtesInBlock;
    MMPTE TempPte;
    PFN_COUNT PtesCommitted;
    PMMPTE PointerPde;

    ASSERT(NumberOfPtes != 0);

    MI_LOCK_MM(&OldIrql);

    //
    // Scan the free list for a block that can satisfy the requested size.
    //

RetryOperation:
    LastPointerPte = &PteRange->HeadPte;

    while (LastPointerPte->List.NextEntry != MM_EMPTY_PTE_LIST) {

        PointerPte = MI_PTE_LIST_NEXT_ENTRY(LastPointerPte);

        //
        // Verify that the list is ordered by free address.
        //

        if (LastPointerPte != &PteRange->HeadPte) {
            ASSERT(PointerPte > LastPointerPte);
        }

        if (PointerPte->List.OneEntry) {

            if (NumberOfPtes == 1) {
                LastPointerPte->List.NextEntry = PointerPte->List.NextEntry;
                goto ReturnPointerPte;
            }

        } else if (MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte) == NumberOfPtes) {

            //
            // A single PTE can't be encoded in a format where Link.OneEntry is
            // clear.
            //

            ASSERT(NumberOfPtes != 1);

            LastPointerPte->List.NextEntry = PointerPte->List.NextEntry;
            goto ReturnPointerPte;

        } else if (MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte) > NumberOfPtes) {

            //
            // The block has more PTEs that we need so shuffle the free count
            // into the next PTE or convert the PTE to the single PTE format.
            //

            ExtraPtes = MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte) - NumberOfPtes;

            if (ExtraPtes > 1) {
                PointerPte[NumberOfPtes].List.OneEntry = 0;
                MI_PTE_LIST_LARGE_BLOCK_SIZE(&PointerPte[NumberOfPtes]) = ExtraPtes;
            } else {
                PointerPte[NumberOfPtes].List.OneEntry = 1;
            }

            PointerPte[NumberOfPtes].List.NextEntry = PointerPte->List.NextEntry;
            LastPointerPte->List.NextEntry += NumberOfPtes;
            goto ReturnPointerPte;
        }

        LastPointerPte = PointerPte;
    }

    //
    // The PTE list doesn't have a block that can satisfy the request.  See how
    // many PTEs we'll need to commit to make enough space.
    //

    PtesToCommit = NumberOfPtes;

    if (LastPointerPte != &PteRange->HeadPte) {

        NumberOfPtesInBlock = LastPointerPte->List.OneEntry ? 1 :
            MI_PTE_LIST_LARGE_BLOCK_SIZE(LastPointerPte);

        if (LastPointerPte + NumberOfPtesInBlock == PteRange->LastCommittedPte) {
            PtesToCommit -= NumberOfPtesInBlock;
        }
    }

    PtesToCommit = MI_ROUND_TO_SIZE(PtesToCommit, PTE_PER_PAGE);
    ASSERT(PtesToCommit > 0);

    //
    // Commit the additional page tables if there's enough virtual address space
    // to hold them.
    //

    if ((ULONG)(PteRange->LastReservedPte - PteRange->LastCommittedPte) >
        PtesToCommit) {

        if (*PteRange->AvailablePages >= (PtesToCommit / PTE_PER_PAGE)) {

            PointerPte = PteRange->LastCommittedPte;

            for (PtesCommitted = 0; PtesCommitted < PtesToCommit;
                PtesCommitted += PTE_PER_PAGE) {

                PointerPde = MiGetPteAddress(PteRange->LastCommittedPte);

                TempPte.Long = MiGetValidKernelPdeBits();
                TempPte.Hard.PageFrameNumber =
                    PteRange->RemovePageRoutine(MmSystemPageTableUsage, PointerPde);

                MI_WRITE_PTE(PointerPde, TempPte);

                PteRange->LastCommittedPte += PTE_PER_PAGE;
            }

            MiReleaseSystemPtes(PteRange, PointerPte, PtesToCommit);
            goto RetryOperation;
        }
    }

    PointerPte = NULL;

ReturnPointerPte:
    MI_UNLOCK_MM(OldIrql);

    return PointerPte;
}

VOID
MiReleaseSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PMMPTE StartingPte,
    IN PFN_COUNT NumberOfPtes
    )
/*++

Routine Description:

    This routine frees the specified number of contiguous PTE slots from the
    system page tables.

Arguments:

    PteRange - Supplies the PTE range to free the PTEs to.

    StartingPte - Supplies the pointer to the first PTE to free.

    NumberOfPtes - Supplies the number of contiguous PTE slots to fre.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PMMPTE LastPointerPte;
    PMMPTE PointerPte;
    PFN_COUNT NumberOfPtesInBlock;

    ASSERT(NumberOfPtes != 0);
    ASSERT(StartingPte >= PteRange->FirstCommittedPte);
    ASSERT(StartingPte + NumberOfPtes <= PteRange->LastCommittedPte);

    MI_LOCK_MM(&OldIrql);

    //
    // Zero the PTEs.  The caller is responsible for deleting any pages attached
    // to these PTEs and flushing the TLB.
    //

    RtlFillMemoryUlong(StartingPte, NumberOfPtes * sizeof(MMPTE), 0);

    //
    // Scan the free list for the position to insert the PTE block.
    //

    LastPointerPte = &PteRange->HeadPte;

    while (LastPointerPte->List.NextEntry != MM_EMPTY_PTE_LIST) {

        PointerPte = MI_PTE_LIST_NEXT_ENTRY(LastPointerPte);

        //
        // Verify that the list is ordered by free address.
        //

        if (LastPointerPte != &PteRange->HeadPte) {
            ASSERT(PointerPte > LastPointerPte);
        }

        if (PointerPte > StartingPte) {

            //
            // Verify that the end of the block we're freeing up doesn't overlap
            // the start of the current block.
            //
            ASSERT(PointerPte >= StartingPte + NumberOfPtes);

            //
            // If the current block is contiguous with the block we're freeing
            // up, then combine the two blocks.
            //
            if (StartingPte + NumberOfPtes == PointerPte) {
                NumberOfPtesInBlock = PointerPte->List.OneEntry ? 1 :
                    MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte);
                NumberOfPtes += NumberOfPtesInBlock;
                LastPointerPte->List.NextEntry = PointerPte->List.NextEntry;
            }

            break;
        }

        //
        // Verify that the end of the current block doesn't overlap the start of
        // the block we're freeing up.
        //

        ASSERT((PointerPte + (PointerPte->List.OneEntry ? 1 :
            MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte))) <= StartingPte);

        LastPointerPte = PointerPte;
    }

    //
    // Set the number of PTEs in the freed block and link it into the free list.
    //

    if (NumberOfPtes > 1) {
        StartingPte->List.OneEntry = 0;
        StartingPte[1].List.NextEntry = NumberOfPtes;
    } else {
        StartingPte->List.OneEntry = 1;
    }

    StartingPte->List.NextEntry = LastPointerPte->List.NextEntry;
    LastPointerPte->List.NextEntry = MI_PTE_LIST_ENCODE_NEXT_ENTRY(StartingPte);

    //
    // If the previous block is contiguous with the block we're freeing up,
    // then combine the two blocks.
    //

    if (LastPointerPte != &PteRange->HeadPte) {

        NumberOfPtesInBlock = LastPointerPte->List.OneEntry ? 1 :
            MI_PTE_LIST_LARGE_BLOCK_SIZE(LastPointerPte);

        if (LastPointerPte + NumberOfPtesInBlock == StartingPte) {
            LastPointerPte->List.OneEntry = 0;
            LastPointerPte->List.NextEntry = StartingPte->List.NextEntry;
            MI_PTE_LIST_LARGE_BLOCK_SIZE(LastPointerPte) = NumberOfPtes +
                NumberOfPtesInBlock;
        }
    }

    MI_UNLOCK_MM(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=mm

TARGETPATH=$(BASEDIR)\private\ntos\obj
TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\ntos\ke;$(BASEDIR)\private\inc

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\addrsup.c  \
        ..\debugsup.c \
        ..\fscache.c  \
        ..\mmfault.c  \
        ..\mminit.c   \
        ..\mmsup.c    \
        ..\mmsupa.asm \
        ..\pfnsup.c   \
        ..\physical.c \
        ..\sysptes.c  \
        ..\vadtree.c  \
        ..\virtual.c

PRECOMPILED_INCLUDE=..\mi.h
PRECOMPILED_PCH=mi.pch
PRECOMPILED_OBJ=mi.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\virtual.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    virtual.c

Abstract:

    This module implements the kernel virtual memory management services.

--*/

#include "mi.h"

//
// Guards multiple threads attempting to commit, reserve, or change the page
// protections for the application virtual memory space.
//
INITIALIZED_CRITICAL_SECTION(MmAddressSpaceLock);

//
// Root pointer and hints into the virtual address descriptor tree.
//
PMMADDRESS_NODE MmVadRoot;
PMMADDRESS_NODE MmVadHint;
PMMADDRESS_NODE MmVadFreeHint;

//
// Number of bytes that have been reserved in the application virtual memory
// space.
//
SIZE_T MmVirtualMemoryBytesReserved;

NTSTATUS
NtAllocateVirtualMemory(
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function creates a region of pages within the virtual address
    space of a subject process.

Arguments:

    BaseAddress - Supplies a pointer to a variable that will receive
                  the base address of the allocated region of pages.
                  If the initial value of this argument is not null,
                  then the region will be allocated starting at the
                  specified virtual address rounded down to the next
                  host page size address boundary. If the initial
                  value of this argument is null, then the operating
                  system will determine where to allocate the region.

    ZeroBits - Supplies the number of high order address bits that
               must be zero in the base address of the section view. The
               value of this argument must be less than or equal to the
               maximum number of zero bits and is only used when memory
               management determines where to allocate the view (i.e. when
               BaseAddress is null).

               If ZeroBits is zero, then no zero bit constraints are applied.

               If ZeroBits is greater than 0 and less than 32, then it is
               the number of leading zero bits from bit 31.  Bits 63:32 are
               also required to be zero.  This retains compatibility
               with 32-bit systems.

               If ZeroBits is greater than 32, then it is considered as
               a mask and then number of leading zero are counted out
               in the mask.  This then becomes the zero bits argument.

    RegionSize - Supplies a pointer to a variable that will receive
                 the actual size in bytes of the allocated region
                 of pages. The initial value of this argument
                 specifies the size in bytes of the region and is
                 rounded up to the next host page size boundary.

    AllocationType - Supplies a set of flags that describe the type
                     of allocation that is to be performed for the
                     specified region of pages. Flags are:

         MEM_COMMIT - The specified region of pages is to be committed.

         MEM_RESERVE - The specified region of pages is to be reserved.

         MEM_TOP_DOWN - The specified region should be created at the
                        highest virtual address possible based on ZeroBits.

         MEM_RESET - Reset the state of the specified region so
                     that if the pages are in page paging file, they
                     are discarded and pages of zeroes are brought in.
                     If the pages are in memory and modified, they are marked
                     as not modified so they will not be written out to
                     the paging file.  The contents are NOT zeroed.

                     The Protect argument is ignored, but a valid protection
                     must be specified.

         MEM_PHYSICAL - The specified region of pages will map physical memory
                        directly via the AWE APIs.

         MEM_WRITE_WATCH - The specified private region is to be used for
                           write-watch purposes.

         MEM_NOZERO - The specified memory pages are not zero filled.

    Protect - Supplies the protection desired for the committed region of pages.

         PAGE_NOACCESS - No access to the committed region
                         of pages is allowed. An attempt to read,
                         write, or execute the committed region
                         results in an access violation.

         PAGE_EXECUTE - Execute access to the committed
                        region of pages is allowed. An attempt to
                        read or write the committed region results in
                        an access violation.

         PAGE_READONLY - Read only and execute access to the
                         committed region of pages is allowed. An
                         attempt to write the committed region results
                         in an access violation.

         PAGE_READWRITE - Read, write, and execute access to
                          the committed region of pages is allowed. If
                          write access to the underlying section is
                          allowed, then a single copy of the pages are
                          shared. Otherwise the pages are shared read
                          only/copy on write.

         PAGE_NOCACHE - The region of pages should be allocated
                        as non-cachable.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    NTSTATUS status;
    ULONG PteProtectionMask;
    PVOID CapturedBase;
    SIZE_T CapturedRegionSize;
    PMMVAD Vad;
    BOOLEAN DeleteVadOnFailure;
    PCHAR TopAddress;
    PCHAR EndingAddress;
    PCHAR StartingAddress;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    PMMPTE PointerPte;
    PFN_COUNT PagesToCommit;
    PMMPFN PdePageFrame;
    PMMPTE PointerPde;
    PMMPTE NextPointerPte;
    KIRQL OldIrql;
    PMMREMOVE_PAGE_ROUTINE RemovePageRoutine;
    MMPFN_BUSY_TYPE BusyType;
    BOOLEAN ChangeProtection;
    MMPTE TempPte;
    ULONG OldProtect;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Check the zero bits argument for correctness.
    //

    if (ZeroBits > MM_MAXIMUM_ZERO_BITS) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the AllocationType for correctness.
    //

    if ((AllocationType & ~(MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN |
                            MEM_RESET | MEM_NOZERO)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // One of MEM_COMMIT, MEM_RESET or MEM_RESERVE must be set.
    //

    if ((AllocationType & (MEM_COMMIT | MEM_RESERVE | MEM_RESET)) == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((AllocationType & MEM_RESET) && (AllocationType != MEM_RESET)) {

        //
        // MEM_RESET may not be used with any other flag.
        //

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the protection field.
    //

    if (!MiMakePteProtectionMask(Protect, &PteProtectionMask)) {
        return STATUS_INVALID_PAGE_PROTECTION;
    }

    //
    // Capture the base address.
    //

    CapturedBase = *BaseAddress;

    //
    // Capture the region size.
    //

    CapturedRegionSize = *RegionSize;

    //
    // Make sure the specified starting and ending addresses are within the user
    // part of the virtual address space.
    //

    if (CapturedBase > MM_HIGHEST_VAD_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if ((((ULONG_PTR)MM_HIGHEST_VAD_ADDRESS + 1) - (ULONG_PTR)CapturedBase) <
        CapturedRegionSize) {

        //
        // Invalid region size.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (CapturedRegionSize == 0) {

        //
        // Region size cannot be 0.
        //

        return STATUS_INVALID_PARAMETER;
    }

    MI_LOCK_ADDRESS_SPACE();

    //
    // Handle the case of reserving an address range.
    //

    Vad = NULL;
    DeleteVadOnFailure = FALSE;

    if ((CapturedBase == NULL) || (AllocationType & MEM_RESERVE)) {

        //
        // Reserve the address space.
        //

        if (CapturedBase == NULL) {

            //
            // No base address was specified.  This MUST be a reserve or
            // reserve and commit.
            //

            CapturedRegionSize = ROUND_TO_PAGES(CapturedRegionSize);

            //
            // If the number of zero bits is greater than zero, then calculate
            // the highest address.
            //

            if (ZeroBits != 0) {
                TopAddress = (PCHAR)(((ULONG_PTR)MM_USER_ADDRESS_RANGE_LIMIT) >> ZeroBits);

                //
                // Keep the top address below the highest user vad address
                // regardless.
                //

                if (TopAddress > (PCHAR)MM_HIGHEST_VAD_ADDRESS) {
                    status = STATUS_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

            } else {
                TopAddress = MM_HIGHEST_VAD_ADDRESS;
            }

            //
            // Establish exception handler as MiFindEmptyAddressRange will raise
            // an exception if it fails.
            //

            try {

                if (AllocationType & MEM_TOP_DOWN) {

                    //
                    // Start from the top of memory downward.
                    //

                    StartingAddress = MiFindEmptyAddressRangeDown(
                        CapturedRegionSize, TopAddress, X64K);

                } else {

                    StartingAddress = MiFindEmptyAddressRange(
                        CapturedRegionSize, X64K, (ULONG)ZeroBits);
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                goto ErrorReturn;
            }

            //
            // Calculate the ending address based on the top address.
            //

            EndingAddress = (PVOID)(((ULONG_PTR)StartingAddress +
                CapturedRegionSize - 1L) | (PAGE_SIZE - 1L));

            if (EndingAddress > TopAddress) {

                //
                // The allocation does not honor the zero bits argument.
                //

                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

        } else {

            //
            // A non-NULL base address was specified. Check to make sure the
            // specified base address to ending address is currently unused.
            //

            EndingAddress = (PVOID)(((ULONG_PTR)CapturedBase +
                CapturedRegionSize - 1L) | (PAGE_SIZE - 1L));

            //
            // Align the starting address on a 64k boundary.
            //

            StartingAddress = (PVOID)MI_ALIGN_TO_SIZE(CapturedBase, X64K);

            //
            // See if a VAD overlaps with this starting/ending address pair.
            //

            if (MiCheckForConflictingVad(StartingAddress, EndingAddress) != NULL) {
                status = STATUS_CONFLICTING_ADDRESSES;
                goto ErrorReturn;
            }
        }

        Vad = ExAllocatePoolWithTag(sizeof(MMVAD), 'SdaV');

        if (Vad == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorReturn;
        }

        Vad->StartingVpn = MI_VA_TO_VPN(StartingAddress);
        Vad->EndingVpn = MI_VA_TO_VPN(EndingAddress);
        Vad->AllocationProtect = Protect;

        MiInsertVad(Vad);

        CapturedBase = StartingAddress;
        CapturedRegionSize = EndingAddress - StartingAddress + 1;

        MmVirtualMemoryBytesReserved += CapturedRegionSize;

        if ((AllocationType & MEM_COMMIT) == 0) {

            //
            // Don't commit the pages, so bail out now.
            //

            MI_UNLOCK_ADDRESS_SPACE();

            *RegionSize = CapturedRegionSize;
            *BaseAddress = CapturedBase;

            return STATUS_SUCCESS;
        }

        //
        // Fall into the commit path.
        //

        DeleteVadOnFailure = TRUE;
    }

    //
    // Handle the case of committing or resetting the pages contained in an
    // address range.
    //

    EndingAddress = (PCHAR)(((ULONG_PTR)CapturedBase + CapturedRegionSize - 1) |
        (PAGE_SIZE - 1));
    StartingAddress = (PCHAR)PAGE_ALIGN(CapturedBase);

    CapturedRegionSize = EndingAddress - StartingAddress + 1;

    //
    // Locate the virtual address descriptor for the specified addresses.
    //

    Vad = MiCheckForConflictingVad(StartingAddress, EndingAddress);

    if (Vad == NULL) {

        //
        // No virtual address is reserved at the specified base address, return
        // an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Ensure that the starting and ending addresses are all within the same
    // virtual address descriptor.
    //

    if ((MI_VA_TO_VPN(StartingAddress) < Vad->StartingVpn) ||
        (MI_VA_TO_VPN(EndingAddress) > Vad->EndingVpn)) {

        //
        // Not within the section virtual address descriptor,
        // return an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Handle the case of resetting the pages contained in an address range.
    // We wait until this point to ensure that a virtual address descriptor
    // really exists for the input arguments.
    //

    if (AllocationType == MEM_RESET) {

        //
        // There's no pagefile support, so this flag is a no-op.
        //

        status = STATUS_SUCCESS;
        goto ErrorReturn;
    }

    //
    // Compute the starting and ending PTE addresses.
    //

    StartingPte = MiGetPteAddress(StartingAddress);
    EndingPte = MiGetPteAddress(EndingAddress);

    //
    // Make a pass through the PTEs to determine the number of pages that we'll
    // need to commit.
    //

    PagesToCommit = 0;
    PointerPte = StartingPte;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {

                //
                // The PDE is not committed.  Add in one page for the page table
                // and all of the pages that need to be committed for this PDE.
                //

                NextPointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);

                PagesToCommit++;

                if (NextPointerPte > EndingPte) {
                    PagesToCommit += (EndingPte - PointerPte + 1);
                } else {
                    PagesToCommit += (NextPointerPte - PointerPte);
                }

                PointerPte = NextPointerPte;

                continue;
            }
        }

        //
        // Add in one page if the PTE is zero.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long == 0) {
            PagesToCommit++;
        }

        PointerPte++;
    }

    //
    // Now ensure that we can allocate the required number of pages.
    //

    MI_LOCK_MM(&OldIrql);

    if (MmAvailablePages < PagesToCommit) {
        MI_UNLOCK_MM(OldIrql);
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Make another pass through the PTEs to actually commit the pages.
    //

    RemovePageRoutine = (AllocationType & MEM_NOZERO) ? MiRemoveAnyPage :
        MiRemoveZeroPage;
    BusyType = (Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ |
        PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) ? MmImageUsage :
        MmVirtualMemoryUsage;
    ChangeProtection = FALSE;
    PointerPte = StartingPte;
    PdePageFrame = NULL;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {

                PagesToCommit--;

                TempPte.Long = MiGetValidKernelPdeBits();
                TempPte.Hard.PageFrameNumber =
                    MiRemoveZeroPage(MmVirtualPageTableUsage, PointerPde);

                MI_WRITE_PTE(PointerPde, TempPte);
            }

            PdePageFrame = MI_PFN_ELEMENT(PointerPde->Hard.PageFrameNumber);

            ASSERT(PdePageFrame->Busy.Busy == 1);
            ASSERT(PdePageFrame->Busy.BusyType == MmVirtualPageTableUsage);
        }

        if (PointerPte->Long == 0) {

            PagesToCommit--;

            TempPte.Long = PteProtectionMask;
            TempPte.Hard.PageFrameNumber = RemovePageRoutine(BusyType, PointerPte);

            MI_WRITE_PTE(PointerPte, TempPte);

            PdePageFrame->Directory.NumberOfUsedPtes++;

            ASSERT(PdePageFrame->Directory.NumberOfUsedPtes <= PTE_PER_PAGE);

        } else if ((PointerPte->Long & MM_PTE_PROTECTION_MASK) != PteProtectionMask) {

            ChangeProtection = TRUE;
        }

        PointerPte++;
    }

    ASSERT(PagesToCommit == 0);
    ASSERT(PdePageFrame != NULL && PdePageFrame->Directory.NumberOfUsedPtes > 0);

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);

    MI_UNLOCK_ADDRESS_SPACE();

    *RegionSize = CapturedRegionSize;
    *BaseAddress = StartingAddress;

    //
    // If we found a page that was already committed but had the wrong page
    // protection, then make a call to NtProtectVirtualMemory to make all of
    // the pages have the right attributes.
    //

    if (ChangeProtection) {
        NtProtectVirtualMemory(&StartingAddress, &CapturedRegionSize, Protect,
            &OldProtect);
    }

    return STATUS_SUCCESS;

ErrorReturn:
    if (!NT_SUCCESS(status) && DeleteVadOnFailure) {

        MmVirtualMemoryBytesReserved -= CapturedRegionSize;

        MiRemoveVad(Vad);
        ExFreePool(Vad);
    }

    MI_UNLOCK_ADDRESS_SPACE();
    return status;
}

NTSTATUS
NtFreeVirtualMemory(
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    )
/*++

Routine Description:

    This function deletes a region of pages within the virtual address
    space of a subject process.

Arguments:

    BaseAddress - The base address of the region of pages
                  to be freed. This value is rounded down to the
                  next host page address boundary.

    RegionSize - A pointer to a variable that will receive
                 the actual size in bytes of the freed region of
                 pages. The initial value of this argument is
                 rounded up to the next host page size boundary.

    FreeType - A set of flags that describe the type of
               free that is to be performed for the specified
               region of pages.

       FreeType Flags

        MEM_DECOMMIT - The specified region of pages is to
             be decommitted.

        MEM_RELEASE - The specified region of pages is to
             be released.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    NTSTATUS status;
    PVOID CapturedBase;
    SIZE_T CapturedRegionSize;
    PCHAR EndingAddress;
    PCHAR StartingAddress;
    PMMVAD Vad;
    PMMVAD NewVad;
    KIRQL OldIrql;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    MMPTE TempPte;
    PMMPTE PointerPte;
    PMMPFN PdePageFrame;
    PMMPTE PointerPde;
    PFN_NUMBER PageFrameNumber;
    BOOLEAN FullTlbFlush;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Check to make sure FreeType is good.
    //

    if ((FreeType & ~(MEM_DECOMMIT | MEM_RELEASE)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // One of MEM_DECOMMIT or MEM_RELEASE must be specified, but not both.
    //

    if (((FreeType & (MEM_DECOMMIT | MEM_RELEASE)) == 0) ||
        ((FreeType & (MEM_DECOMMIT | MEM_RELEASE)) ==
                            (MEM_DECOMMIT | MEM_RELEASE))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Capture the base address.
    //

    CapturedBase = *BaseAddress;

    //
    // Capture the region size.
    //

    CapturedRegionSize = *RegionSize;

    //
    // Make sure the specified starting and ending addresses are within the user
    // part of the virtual address space.
    //

    if (CapturedBase > MM_HIGHEST_USER_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if ((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - (ULONG_PTR)CapturedBase <
        CapturedRegionSize) {

        //
        // Invalid region size.
        //

        return STATUS_INVALID_PARAMETER;
    }

    EndingAddress = (PCHAR)(((ULONG_PTR)CapturedBase + CapturedRegionSize - 1) |
        (PAGE_SIZE - 1));
    StartingAddress = (PCHAR)PAGE_ALIGN(CapturedBase);

    MI_LOCK_ADDRESS_SPACE();

    Vad = (PMMVAD)MiLocateAddress(StartingAddress);

    if (Vad == NULL) {

        //
        // No virtual address descriptor located for base address.
        //

        status = STATUS_MEMORY_NOT_ALLOCATED;
        goto ErrorReturn;
    }

    //
    // Found the associated virtual address descriptor.
    //

    if (Vad->EndingVpn < MI_VA_TO_VPN(EndingAddress)) {

        //
        // The entire range to delete is not contained within a single
        // virtual address descriptor.  Return an error.
        //

        status = STATUS_UNABLE_TO_FREE_VM;
        goto ErrorReturn;
    }

    //
    // Handle the case of releasing an address range.
    //

    if (FreeType & MEM_RELEASE) {

        //
        // If the region size is zero, remove the whole VAD.
        //

        if (CapturedRegionSize == 0) {

            //
            // If the region size is specified as 0, the base address
            // must be the starting address for the region.
            //

            if (MI_VA_TO_VPN(CapturedBase) != Vad->StartingVpn) {
                status = STATUS_FREE_VM_NOT_AT_BASE;
                goto ErrorReturn;
            }

            //
            // Delete the VAD.
            //

            StartingAddress = MI_VPN_TO_VA(Vad->StartingVpn);
            EndingAddress = MI_VPN_TO_VA_ENDING(Vad->EndingVpn);

            MiRemoveVad(Vad);
            ExFreePool(Vad);

        } else {

            //
            // Region's size was not specified as zero, delete the whole VAD or
            // split the VAD.
            //

            if (MI_VA_TO_VPN(StartingAddress) == Vad->StartingVpn) {

                if (MI_VA_TO_VPN(EndingAddress) == Vad->EndingVpn) {

                    //
                    // Delete the VAD.
                    //

                    MiRemoveVad(Vad);
                    ExFreePool(Vad);

                } else {

                    //
                    // Change the starting address of the VAD.
                    //

                    Vad->StartingVpn = MI_VA_TO_VPN(EndingAddress + 1);
                }

            } else {

                //
                // Starting address is greater than start of VAD.
                //

                if (MI_VA_TO_VPN(EndingAddress) == Vad->EndingVpn) {

                    //
                    // Change the ending address of the VAD.
                    //

                    Vad->EndingVpn = MI_VA_TO_VPN(StartingAddress - 1);

                } else {

                    //
                    // Split this VAD as the address range is within the VAD.
                    //

                    NewVad = ExAllocatePoolWithTag(sizeof(MMVAD), 'SdaV');

                    if (NewVad == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorReturn;
                    }

                    *NewVad = *Vad;

                    Vad->EndingVpn = MI_VA_TO_VPN(StartingAddress - 1);
                    NewVad->StartingVpn = MI_VA_TO_VPN(EndingAddress + 1);

                    MiInsertVad(NewVad);
                }
            }
        }

        MmVirtualMemoryBytesReserved -= (1 + EndingAddress - StartingAddress);

        //
        // Fall into the decommit path.
        //
    }

    //
    // Handle the case of decomitting pages in an address range.
    //

    MI_LOCK_MM(&OldIrql);

    //
    // Compute the starting and ending PTE addresses.
    //

    StartingPte = MiGetPteAddress(StartingAddress);
    EndingPte = MiGetPteAddress(EndingAddress);

    //
    // Make a pass through the PTEs to decommit pages.
    //

    TempPte.Long = 0;
    PointerPte = StartingPte;
    PdePageFrame = NULL;
    FullTlbFlush = FALSE;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {
                PointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);
                continue;
            }

            PdePageFrame = MI_PFN_ELEMENT(PointerPde->Hard.PageFrameNumber);
        }

        //
        // Check if the PTE is marked committed.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long != 0) {

            PageFrameNumber = PointerPte->Hard.PageFrameNumber;

            MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);

            MiReleasePageOwnership(PageFrameNumber);

            //
            // Decrement the number of PTEs allocated to this page directory and
            // free the page directory if the count is zero.
            //

            PdePageFrame->Directory.NumberOfUsedPtes--;

            if (PdePageFrame->Directory.NumberOfUsedPtes == 0) {

                PointerPde = MiGetPteAddress(PointerPte);
                PageFrameNumber = PointerPde->Hard.PageFrameNumber;

                MI_WRITE_PTE(PointerPde, TempPte);

                FullTlbFlush = TRUE;

                MiReleasePageOwnership(PageFrameNumber);

                PointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);
                continue;
            }
        }

        PointerPte++;
    }

    //
    // If any page table pages were discarded above, then do a full flush of the
    // TLB.
    //

    if (FullTlbFlush) {
        KeFlushCurrentTb();
    }

    MI_UNLOCK_MM(OldIrql);

    MI_UNLOCK_ADDRESS_SPACE();

    *RegionSize = 1 + EndingAddress - StartingAddress;
    *BaseAddress = StartingAddress;

    return STATUS_SUCCESS;

ErrorReturn:
    MI_UNLOCK_ADDRESS_SPACE();
    return status;
}

NTSTATUS
NtQueryVirtualMemory(
    IN PVOID BaseAddress,
    OUT PMEMORY_BASIC_INFORMATION MemoryInformation
    )
/*++

Routine Description:

    This function provides the capability to determine the state,
    protection, and type of a region of pages within the virtual address
    space of the subject process.

    The state of the first page within the region is determined and then
    subsequent entries in the process address map are scanned from the
    base address upward until either the entire range of pages has been
    scanned or until a page with a nonmatching set of attributes is
    encountered. The region attributes, the length of the region of pages
    with matching attributes, and an appropriate status value are
    returned.

    If the entire region of pages does not have a matching set of
    attributes, then the returned length parameter value can be used to
    calculate the address and length of the region of pages that was not
    scanned.

Arguments:

    BaseAddress - The base address of the region of pages to be
        queried. This value is rounded down to the next host-page-
        address boundary.

    MemoryInformation - A pointer to a buffer that receives the
        specified information.  The format and content of the buffer
        depend on the specified information class.

        MemoryBasicInformation - Data type is PMEMORY_BASIC_INFORMATION.

            MEMORY_BASIC_INFORMATION Structure

            ULONG RegionSize - The size of the region in bytes
                beginning at the base address in which all pages have
                identical attributes.

            ULONG State - The state of the pages within the region.

                State Values

                MEM_COMMIT - The state of the pages within the region
                    is committed.

                MEM_FREE - The state of the pages within the region
                    is free.

                MEM_RESERVE - The state of the pages within the
                    region is reserved.

            ULONG Protect - The protection of the pages within the
                region.

                Protect Values

                PAGE_NOACCESS - No access to the region of pages is
                    allowed. An attempt to read, write, or execute
                    within the region results in an access violation
                    (i.e., a GP fault).

                PAGE_EXECUTE - Execute access to the region of pages
                    is allowed. An attempt to read or write within
                    the region results in an access violation.

                PAGE_READONLY - Read-only and execute access to the
                    region of pages is allowed. An attempt to write
                    within the region results in an access violation.

                PAGE_READWRITE - Read, write, and execute access to
                    the region of pages is allowed. If write access
                    to the underlying section is allowed, then a
                    single copy of the pages are shared. Otherwise,
                    the pages are shared read-only/copy-on-write.

                PAGE_GUARD - Read, write, and execute access to the
                    region of pages is allowed; however, access to
                    the region causes a "guard region entered"
                    condition to be raised in the subject process.

                PAGE_NOCACHE - Disable the placement of committed
                    pages into the data cache.

            ULONG Type - The type of pages within the region.

                Type Values

                MEM_PRIVATE - The pages within the region are
                    private.

                MEM_MAPPED - The pages within the region are mapped
                    into the view of a section.

                MEM_IMAGE - The pages within the region are mapped
                    into the view of an image section.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    PMMVAD Vad;
    ULONG_PTR BaseVpn;
    BOOLEAN Found;
    SIZE_T RegionSize;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    ULONG AllocationProtect;
    ULONG Protect;
    ULONG PteProtectionMask;
    ULONG State;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if (BaseAddress > MM_HIGHEST_VAD_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    MI_LOCK_ADDRESS_SPACE();

    //
    // Locate the VAD that contains the base address or the VAD which follows
    // the base address.
    //

    Vad = (PMMVAD)MmVadRoot;
    BaseVpn = MI_VA_TO_VPN(BaseAddress);
    Found = FALSE;

    for (;;) {

        if (Vad == NULL) {
            break;
        }

        if ((BaseVpn >= Vad->StartingVpn) && (BaseVpn <= Vad->EndingVpn)) {
            Found = TRUE;
            break;
        }

        if (BaseVpn < Vad->StartingVpn) {
            if (Vad->LeftChild == NULL) {
                break;
            }
            Vad = (PMMVAD)Vad->LeftChild;

        } else {
            if (BaseVpn < Vad->EndingVpn) {
                break;
            }
            if (Vad->RightChild == NULL) {
                break;
            }
            Vad = (PMMVAD)Vad->RightChild;
        }
    }

    if (!Found) {

        //
        // There is no virtual address allocated at the base address.  Return
        // the size of the hole starting at the base address.
        //

        if (Vad == NULL) {
            RegionSize = ((PCHAR)MM_HIGHEST_VAD_ADDRESS + 1) -
                (PCHAR)PAGE_ALIGN(BaseAddress);
        } else {
            if (Vad->StartingVpn < BaseVpn) {

                //
                // We are looking at the Vad which occupies the range just
                // before the desired range.  Get the next Vad.
                //

                Vad = MiGetNextVad(Vad);
                if (Vad == NULL) {
                    RegionSize = ((PCHAR)MM_HIGHEST_VAD_ADDRESS + 1) -
                        (PCHAR)PAGE_ALIGN(BaseAddress);
                } else {
                    RegionSize = (PCHAR)MI_VPN_TO_VA (Vad->StartingVpn) -
                        (PCHAR)PAGE_ALIGN(BaseAddress);
                }
            } else {
                RegionSize = (PCHAR)MI_VPN_TO_VA (Vad->StartingVpn) -
                    (PCHAR)PAGE_ALIGN(BaseAddress);
            }
        }

        MI_UNLOCK_ADDRESS_SPACE();

        MemoryInformation->AllocationBase = NULL;
        MemoryInformation->AllocationProtect = 0;
        MemoryInformation->BaseAddress = PAGE_ALIGN(BaseAddress);
        MemoryInformation->RegionSize = RegionSize;
        MemoryInformation->State = MEM_FREE;
        MemoryInformation->Protect = PAGE_NOACCESS;
        MemoryInformation->Type = 0;

        return STATUS_SUCCESS;
    }

    //
    // There is a virtual address allocated at the base address.
    //

    StartingPte = MiGetPteAddress(BaseAddress);
    EndingPte = MiGetPteAddress(MI_VPN_TO_VA(Vad->EndingVpn));

    AllocationProtect = Vad->AllocationProtect;

    //
    // Determine the state and protection attributes of the base address.
    //

    Protect = 0;
    PteProtectionMask = 0;
    PointerPte = StartingPte;
    PointerPde = MiGetPteAddress(PointerPte);

    if (PointerPde->Hard.Valid != 0) {

        //
        // Check if the PTE is marked committed.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long == 0) {
            State = MEM_RESERVE;
        } else {
            State = MEM_COMMIT;
            PteProtectionMask = (PointerPte->Long & MM_PTE_PROTECTION_MASK);
            Protect = MiDecodePteProtectionMask(PteProtectionMask);
        }

    } else {

        State = MEM_RESERVE;
    }

    //
    // Make a pass through the PTEs to compute the number of pages with the same
    // state and protection attributes as the base address.
    //

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {

                if (State == MEM_COMMIT) {
                    break;
                }

                PointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);
                continue;
            }
        }

        if (PointerPte->Long != 0) {

            if (State == MEM_RESERVE) {
                break;
            }

            if ((PointerPte->Long & MM_PTE_PROTECTION_MASK) != PteProtectionMask) {
                break;
            }

        } else {

            if (State == MEM_COMMIT) {
                break;
            }
        }

        PointerPte++;
    }

    if (PointerPte > EndingPte) {
        PointerPte = EndingPte + 1;
    }

    RegionSize = (PCHAR)MiGetVirtualAddressMappedByPte(PointerPte) -
        (PCHAR)PAGE_ALIGN(BaseAddress);

    //
    // We should have found at least one valid page worth of data.
    //

    ASSERT(RegionSize > 0);

    MI_UNLOCK_ADDRESS_SPACE();

    MemoryInformation->AllocationBase = MI_VPN_TO_VA(Vad->StartingVpn);
    MemoryInformation->AllocationProtect = AllocationProtect;
    MemoryInformation->BaseAddress = PAGE_ALIGN(BaseAddress);
    MemoryInformation->RegionSize = RegionSize;
    MemoryInformation->State = State;
    MemoryInformation->Protect = Protect;
    MemoryInformation->Type = MEM_PRIVATE;

    return STATUS_SUCCESS;
}

NTSTATUS
NtProtectVirtualMemory(
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    )
/*++

Routine Description:

    This routine changes the protection on a region of committed pages
    within the virtual address space of the subject process.  Setting
    the protection on a range of pages causes the old protection to be
    replaced by the specified protection value.

Arguments:

    BaseAddress - The base address of the region of pages
          whose protection is to be changed. This value is
          rounded down to the next host page address
          boundary.

    RegionSize - A pointer to a variable that will receive
          the actual size in bytes of the protected region
          of pages. The initial value of this argument is
          rounded up to the next host page size boundary.

    NewProtect - The new protection desired for the
          specified region of pages.

     Protect Values

          PAGE_NOACCESS - No access to the specified region
               of pages is allowed. An attempt to read,
               write, or execute the specified region
               results in an access violation (i.e. a GP
               fault).

          PAGE_EXECUTE - Execute access to the specified
               region of pages is allowed. An attempt to
               read or write the specified region results in
               an access violation.

          PAGE_READONLY - Read only and execute access to the
               specified region of pages is allowed. An
               attempt to write the specified region results
               in an access violation.

          PAGE_READWRITE - Read, write, and execute access to
               the specified region of pages is allowed. If
               write access to the underlying section is
               allowed, then a single copy of the pages are
               shared. Otherwise the pages are shared read
               only/copy on write.

          PAGE_GUARD - Read, write, and execute access to the
               specified region of pages is allowed,
               however, access to the region causes a "guard
               region entered" condition to be raised in the
               subject process. If write access to the
               underlying section is allowed, then a single
               copy of the pages are shared. Otherwise the
               pages are shared read only/copy on write.

          PAGE_NOCACHE - The page should be treated as uncached.
               This is only valid for non-shared pages.

     OldProtect - A pointer to a variable that will receive
          the old protection of the first page within the
          specified region of pages.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    NTSTATUS status;
    ULONG PteProtectionMask;
    PVOID CapturedBase;
    SIZE_T CapturedRegionSize;
    PCHAR EndingAddress;
    PCHAR StartingAddress;
    PMMVAD Vad;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    KIRQL OldIrql;
    ULONG OldPteProtectionMask;
    MMPTE TempPte;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Check the protection field.
    //

    if (!MiMakePteProtectionMask(NewProtect, &PteProtectionMask)) {
        return STATUS_INVALID_PAGE_PROTECTION;
    }

    //
    // Capture the base address.
    //

    CapturedBase = *BaseAddress;

    //
    // Capture the region size.
    //

    CapturedRegionSize = *RegionSize;

    //
    // Make sure the specified starting and ending addresses are within the user
    // part of the virtual address space.
    //

    if (CapturedBase > MM_HIGHEST_USER_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if ((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - (ULONG_PTR)CapturedBase <
        CapturedRegionSize) {

        //
        // Invalid region size.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (CapturedRegionSize == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    MI_LOCK_ADDRESS_SPACE();

    EndingAddress = (PCHAR)(((ULONG_PTR)CapturedBase + CapturedRegionSize - 1) |
        (PAGE_SIZE - 1));
    StartingAddress = (PCHAR)PAGE_ALIGN(CapturedBase);

    //
    // Locate the virtual address descriptor for the specified addresses.
    //

    Vad = MiCheckForConflictingVad(StartingAddress, EndingAddress);

    if (Vad == NULL) {

        //
        // No virtual address is reserved at the specified base address,
        // return an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Ensure that the starting and ending addresses are all within the same
    // virtual address descriptor.
    //

    if ((MI_VA_TO_VPN(StartingAddress) < Vad->StartingVpn) ||
        (MI_VA_TO_VPN(EndingAddress) > Vad->EndingVpn)) {

        //
        // Not within the section virtual address descriptor,
        // return an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Compute the starting and ending PTE addresses.
    //

    StartingPte = MiGetPteAddress(StartingAddress);
    EndingPte = MiGetPteAddress(EndingAddress);

    //
    // Make a pass through the PTEs to verify that all of the pages are
    // committed.
    //

    PointerPte = StartingPte;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {
                status = STATUS_NOT_COMMITTED;
                goto ErrorReturn;
            }
        }

        //
        // Check if the PTE is marked committed.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long == 0) {
            status = STATUS_NOT_COMMITTED;
            goto ErrorReturn;
        }

        PointerPte++;
    }

    //
    // Make another pass through the PTEs to change the page permissions.
    //

    MI_LOCK_MM(&OldIrql);

    OldPteProtectionMask = PteProtectionMask;
    PointerPte = StartingPte;

    while (PointerPte <= EndingPte) {

        if (PointerPte->Long != 0) {

            TempPte = *PointerPte;

            if ((TempPte.Long & MM_PTE_PROTECTION_MASK) != PteProtectionMask) {

                //
                // Save off the attributes of the first non-matching page that
                // we find so that we can return the old protection code to the
                // caller.
                //

                if (OldPteProtectionMask == PteProtectionMask) {
                    OldPteProtectionMask = (TempPte.Long & MM_PTE_PROTECTION_MASK);
                }

                TempPte.Long = ((TempPte.Long & ~MM_PTE_PROTECTION_MASK) |
                    PteProtectionMask);

                MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
            }
        }

        PointerPte++;
    }

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (NewProtect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);

    MI_UNLOCK_ADDRESS_SPACE();

    *RegionSize = 1 + EndingAddress - StartingAddress;
    *BaseAddress = StartingAddress;
    *OldProtect = MiDecodePteProtectionMask(OldPteProtectionMask);

    return STATUS_SUCCESS;

ErrorReturn:
    MI_UNLOCK_ADDRESS_SPACE();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\vadtree.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    vadtree.c

Abstract:

    This module implements the routines to manipulate the virtual address
    descriptor tree.

--*/

#include "mi.h"

VOID
MiInsertVad (
    IN PMMVAD Vad
    )
/*++

Routine Description:

    This function inserts a virtual address descriptor into the tree and
    reorders the splay tree as appropriate.

Arguments:

    Vad - Supplies a pointer to a virtual address descriptor


Return Value:

    None - An exception is raised if quota is exceeded.

--*/
{
    PMMADDRESS_NODE *Root;

    ASSERT (Vad->EndingVpn >= Vad->StartingVpn);

    Root = &MmVadRoot;

    //
    // Set the hint field in the process to this Vad.
    //

    MmVadHint = (PMMADDRESS_NODE)Vad;

    if (MmVadFreeHint != NULL) {
        if (((ULONG)((PMMVAD)MmVadFreeHint)->EndingVpn +
                MI_VA_TO_VPN (X64K)) >=
                Vad->StartingVpn) {
            MmVadFreeHint = (PMMADDRESS_NODE)Vad;
        }
    }

    MiInsertNode ( (PMMADDRESS_NODE)Vad, Root);
    return;
}

VOID
MiRemoveVad (
    IN PMMVAD Vad
    )
/*++

Routine Description:

    This function removes a virtual address descriptor from the tree and
    reorders the splay tree as appropriate.  If any quota or commitment
    was charged by the VAD (as indicated by the CommitCharge field) it
    is released.

Arguments:

    Vad - Supplies a pointer to a virtual address descriptor.

Return Value:

    None.

--*/
{
    PMMADDRESS_NODE *Root;

    if (Vad == (PMMVAD)MmVadFreeHint) {
        MmVadFreeHint = (PMMADDRESS_NODE)MiGetPreviousVad (Vad);
    }

    Root = &MmVadRoot;

    MiRemoveNode ( (PMMADDRESS_NODE)Vad, Root);

    //
    // If the VadHint was the removed Vad, change the Hint.

    if (MmVadHint == (PMMADDRESS_NODE)Vad) {
        MmVadHint = MmVadRoot;
    }

    return;
}

PMMVAD
FASTCALL
MiLocateAddress (
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    The function locates the virtual address descriptor which describes
    a given address.

Arguments:

    VirtualAddress - Supplies the virtual address to locate a descriptor
                     for.

Return Value:

    Returns a pointer to the virtual address descriptor which contains
    the supplied virtual address or NULL if none was located.

--*/
{
    PMMVAD FoundVad;
    ULONG_PTR Vpn;

    if (MmVadHint == NULL) {
        return NULL;
    }

    Vpn = MI_VA_TO_VPN (VirtualAddress);
    if ((Vpn >= MmVadHint->StartingVpn) &&
        (Vpn <= MmVadHint->EndingVpn)) {

        return (PMMVAD)MmVadHint;
    }

    FoundVad = (PMMVAD)MiLocateAddressInTree ( Vpn, &MmVadRoot );

    if (FoundVad != NULL) {
        MmVadHint = (PMMADDRESS_NODE)FoundVad;
    }
    return FoundVad;
}

PVOID
MiFindEmptyAddressRange (
    IN SIZE_T SizeOfRange,
    IN ULONG_PTR Alignment,
    IN ULONG QuickCheck
    )
/*++

Routine Description:

    The function examines the virtual address descriptors to locate
    an unused range of the specified size and returns the starting
    address of the range.

Arguments:

    SizeOfRange - Supplies the size in bytes of the range to locate.

    Alignment - Supplies the alignment for the address.  Must be
                 a power of 2 and greater than the page_size.

    QuickCheck - Supplies a zero if a quick check for free memory
                 after the VadFreeHint exists, non-zero if checking
                 should start at the lowest address.

Return Value:

    Returns the starting address of a suitable range.

--*/
{
    PMMVAD NextVad;
    PMMVAD FreeHint;
    PVOID StartingVa;
    PVOID EndingVa;

    FreeHint = (PMMVAD)MmVadFreeHint;

    if ((QuickCheck == 0) && (FreeHint != NULL)) {

        EndingVa = MI_VPN_TO_VA_ENDING (FreeHint->EndingVpn);
        NextVad = MiGetNextVad (FreeHint);
        if (NextVad == NULL) {

            if (SizeOfRange <
                (((ULONG_PTR)MM_HIGHEST_USER_ADDRESS + 1) -
                         MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa, Alignment))) {
                return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa,
                                                         Alignment);
            }
        } else {
            StartingVa = MI_VPN_TO_VA (NextVad->StartingVpn);

            if (SizeOfRange <
                ((ULONG_PTR)StartingVa -
                         MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa, Alignment))) {

                //
                // Check to ensure that the ending address aligned upwards
                // is not greater than the starting address.
                //

                if ((ULONG_PTR)StartingVa >
                         MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa,Alignment)) {
                    return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa,
                                                           Alignment);
                }
            }
        }
    }

    return (PMMVAD)MiFindEmptyAddressRangeInTree (
                   SizeOfRange,
                   Alignment,
                   MmVadRoot,
                   &MmVadFreeHint);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\mmx\i386\mmsupa.asm ===
TITLE   "Memory Management Support Routines"
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     mmsupa.asm
;
;  Abstract:
;
;     This module implements the various routines for miscellaneous support
;     operations for memory management.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; FASTCALL
; MiZeroAndFlushPtes(
;     IN PMMPTE StartingPte,
;     IN PFN_COUNT NumberOfPtes
;     )
;
; Routine Description:
;
;     This function zeroes a range of PTEs and flushes its corresponding TLB
;     entries.  The NumberOfPtes must be greater than zero.
;
; Arguments:
;
;     StartingPte - Supplies the first PTE to zero.
;
;     NumberOfPtes - Supplies the number of PTEs to zero.
;
; Return Value:
;
;     None.
;
;--
cPublicFastCall MiZeroAndFlushPtes, 2

IF DBG
        test    edx, edx
        jnz     @F
        int     3
@@:
ENDIF

        mov     eax, ecx
        shl     eax, 10             ; eax = MiGetVirtualAddressMappedByPte(ecx)

FlushNextPte:
        mov     [ecx], 0
        invlpg  [eax]
        add     ecx, 4
        add     eax, PAGE_SIZE
        dec     edx
        jnz     FlushNextPte

        fstRET  MiZeroAndFlushPtes

fstENDP MiZeroAndFlushPtes

;++
;
; VOID
; MiRelocateBusyPageHelper(
;     IN PVOID OldPhysicalAddress,
;     IN PVOID NewPhysicalAddress,
;     IN PMMPTE PointerPte OPTIONAL,
;     IN MMPTE NewPteContents OPTIONAL,
;     IN BOOLEAN FullTlbFlush
;     )
;
; Routine Description:
;
;     This function is called by MiRelocateBusyPage to handle the work of
;     copying a page's contents, updating the page tables, and flushing the
;     appropriate TLB entries.  This routine is implemented in assembly to
;     ensure that the stack is touched properly in the case of relocating the
;     current stack's pages.
;
; Arguments:
;
;     OldPhysicalAddress - Supplies a KSEG0 pointer to the old page's contents.
;
;     NewPhysicalAddress - Supplies a KSEG0 pointer to the new location for the
;         page.
;
;     PointerPte - Supplies an optional pointer to the PTE to update after doing
;         the page copy.
;
;     NewPteContents - Supplies the value to write to PointerPte.
;
;     FullTlbFlush - Specifies whether the entire TLB should be flushed after
;         updating PointerPte or only the virtual address mapped by the PTE.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _MiRelocateBusyPageHelper, 5

        push    esi
        mov     esi, [esp+8]        ; esi = OldPhysicalAddress
        push    edi
        mov     edi, [esp+16]       ; edi = NewPhysicalAddress
        mov     edx, [esp+20]       ; edx = PointerPte
        mov     ecx, PAGE_SIZE / 4
        mov     eax, [esp+24]       ; eax = NewPteContents

;
; Disable interrupts during the rest of the operation.  The page we're moving
; could be modified by an interrupt service routine while we're copying it.
;

        cli

;
; Copy the old page to the new page.
;

        rep     movsd

;
; Grab the last value from the stack before we start changing the page tables.
;

        mov     ecx, [esp+28]       ; cl = FullTlbFlush

;
; Update the page table entry.
;

        mov     [edx], eax          ; MI_WRITE_PTE(edx, eax)

;
; Check if we should flush just a single TLB entry or the entire TLB.
;

        test    cl, cl
        jnz     FlushEntireTlb

FlushSingleTlb:
        shl     edx, 10             ; edx = MiGetVirtualAddressMappedByPte(edx)
        invlpg  [edx]
        jmp     ReenableInterrupts

FlushEntireTlb:
        mov     eax, cr3
        mov     cr3, eax

;
; The page tables now point at the new page and the TLB has been flushed.  It's
; safe to allow interrupts to fire again.
;

ReenableInterrupts:
        sti

        pop     edi
        pop     esi

        stdRET  _MiRelocateBusyPageHelper

stdENDP _MiRelocateBusyPageHelper

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\halw.h ===
// ---------------------------------------------------------------------------------------
// halw.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _HALW_H_
#define _HALW_H_

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

typedef void (*PKDEFERRED_ROUTINE) (struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);

typedef struct _KDPC {
    LIST_ENTRY              DpcListEntry;
    PKDEFERRED_ROUTINE      DeferredRoutine;
    PVOID                   DeferredContext;
    PVOID                   SystemArgument1;
    PVOID                   SystemArgument2;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _KTIMER {
    LIST_ENTRY              TimerListEntry;
    KDPC *                  Dpc;
    DWORD                   DueTime;
    LONG                    Period;
} KTIMER, *PKTIMER, *PRKTIMER;

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

void *  HalAlloc(size_t cb, ULONG tag);
void *  HalAllocZ(size_t cb, ULONG tag);
void    HalFree(void * pv);

class CXnHal : public CXnVoid
{
    // Definitions -----------------------------------------------------------------------

    #define KEVENT                      HANDLE
    #define PRKEVENT                    HANDLE
    #define EvtInit(prke)               prke = CreateEvent(NULL, FALSE, FALSE, NULL)
    #define EvtTerm(prke)               CloseHandle(prke)
    #define EvtSet(prke, pri)           SetEvent(prke)
    #define EvtClear(prke)              ResetEvent(prke)
    #define EvtRef(ke)                  ke
    #define EvtFromHandle(hEvent)       hEvent
    #define EvtDereference(prke)
    #define KeQuerySystemTime(x)        GetSystemTimeAsFileTime((LPFILETIME)(x))
    #define KeQueryTickCount()          GetTickCount()

    #define PASSIVE_LEVEL               0
    #define DISPATCH_LEVEL              1
    #define USER                        0x0001
    #define UDPC                        0x0002
    #define SDPC                        0x0004

    #define XC_ONLINE_IP_ADDRESS                0
    #define XC_ONLINE_SUBNET_ADDRESS            1
    #define XC_ONLINE_DEFAULT_GATEWAY_ADDRESS   2

#ifdef XNET_FEATURE_ASSERT
    #define TCHECK_(pXnBase, lev)       AssertSz((pXnBase)->HalThreadCheck(lev), "Not allowed to execute this code at the current level")
#else
    #define TCHECK_(pXnBase, lev)
#endif
    #define TCHECK(lev)                 TCHECK_(this, lev)

#ifdef XNET_FEATURE_ASSERT
    #define ICHECK_(pXnBase, lay, lev)  AssertSz((pXnBase)->TestInitFlag(INITF_##lay), "This layer is not initialized"); \
                                        AssertSz(!(pXnBase)->TestInitFlag(INITF_##lay##_TERM), "This layer has been terminated."); \
                                        TCHECK_(pXnBase, lev)
#else
    #define ICHECK_(pXnBase, lay, lev)
#endif
    #define ICHECK(lay, lev)            ICHECK_(this, lay, lev)

    #define HAL_DECLARE_NEW_DELETE(class) \
       INLINE void * operator new(size_t cb) { return(HalAllocZ(cb, PTAG_##class)); } \
       INLINE void operator delete(void * pv) { HalFree(pv); } \
       INLINE class() {} \
       INLINE ~class() {}

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnHal)

    KIRQL               KeGetCurrentIrql();
    KIRQL               KeRaiseIrqlToDpcLevel();
    VOID                KeLowerIrql(KIRQL kirql);
    VOID                KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
    BOOLEAN             KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2);
    BOOLEAN             KeRemoveQueueDpc(PRKDPC Dpc);
    VOID                KeInitializeTimer(PKTIMER Timer);
    BOOLEAN             KeSetTimerEx(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc);
    BOOLEAN             KeCancelTimer(PKTIMER Timer);

    BOOL                HalThreadCheck(UINT uiCheck);
    void                HalEnterDpc();
    BOOL                HalTryEnterDpc();
    void                HalLeaveDpc();

    UINT                HalRandGather(BYTE * pb, UINT cb);    

    void                SetInitFlag(DWORD dwFlag);
    INLINE BOOL         TestInitFlag(DWORD dwFlag)      { return(!!(_dwInitFlags & dwFlag)); }
    INLINE BOOL         EvtWait(PRKEVENT prke, UINT uiTimeout);

    #undef  HALAPI
    #define HALAPI(ret, fname, arglist, paramlist)  INLINE ret fname arglist { return(Hal##fname paramlist); }
    HALAPILIST()

protected:

    NTSTATUS            HalInit(XNetInitParams * pxnip);
    INLINE void         HalStart()  {};
    INLINE void         HalStop()   {};
    void                HalTerm();

    // Data ------------------------------------------------------------------------------

private:

    DWORD               _dwInitFlags;           // Initialization flags (INITF_*)

protected:

    char                _achXbox[64];           // Name of this xbox

};

INLINE BOOL CXnHal::EvtWait(PRKEVENT prke, UINT uiTimeout)
{
    BOOL fResult = (WaitForSingleObject(prke, uiTimeout ? uiTimeout : INFINITE) != WAIT_TIMEOUT);

    // We need to wait for the DPC thread to finish because it most likely just signalled
    // this event, and on the Xbox the user thread would not get a chance to run until
    // the dispatch routine returned.  On windows we don't simulate dispatch
    // exclusivity, so we just raise/lower to DPC here to make sure the dispatch call
    // that signalled the event is done.

    HalEnterDpc();
    HalLeaveDpc();

    return(fResult);
}

class CRaiseToDpc
{
public:
    CRaiseToDpc(CXnHal * pXnHal);
    ~CRaiseToDpc();
private:
    CRaiseToDpc();
    CXnHal *    _pXnHal;
    UINT        _irql;
};

#define RaiseToDpc()  CRaiseToDpc __RaiseToDpc__(this)

#define HalQueryTsc(pli)    QueryPerformanceCounter(pli)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\halx.cpp ===
// ---------------------------------------------------------------------------------------
// halx.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_XBOX

//
// Linker directive to merge XNET_RD section into XNET section
//
#pragma comment(linker, "/merge:XNET_RD=XNET")

// ---------------------------------------------------------------------------------------
// TCHECK
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

KIRQL CXnHal::KeRaiseIrqlToDpcLevel()
{
    KIRQL kirql = ::KeRaiseIrqlToDpcLevel();

    if (kirql == PASSIVE_LEVEL)
    {
        _fUserDpc = TRUE;
    }

    return(kirql);
}

void CXnHal::KeLowerIrql(KIRQL kirql)
{
    if (kirql == PASSIVE_LEVEL)
    {
        _fUserDpc = FALSE;
    }

    ::KeLowerIrql(kirql);
}

BOOL CXnHal::HalThreadCheck(UINT uiCheck)
{
    KIRQL kirql = KeGetCurrentIrql();

    if (kirql != DISPATCH_LEVEL)
        return(uiCheck & USER);
    else if (_fUserDpc)
        return(uiCheck & UDPC);
    else
        return(uiCheck & SDPC);
}

#endif

// ---------------------------------------------------------------------------------------
// SetInitFlag
// ---------------------------------------------------------------------------------------

void CXnHal::SetInitFlag(DWORD dwFlag)
{
    DWORD dwFlagsOld, dwFlagsNew;

    while (1)
    {
        dwFlagsOld = _dwInitFlags;

        Assert((dwFlagsOld & dwFlag) == 0);

        dwFlagsNew = dwFlagsOld | dwFlag;

        if (InterlockedCompareExchange((LONG *)&_dwInitFlags, (LONG)dwFlagsNew, (LONG)dwFlagsOld) == (LONG)dwFlagsOld)
            break;

        TraceSz(Warning, "CXnHal::SetInitFlag: Thread/DPC contention.  Retrying.");
    }
}

// ---------------------------------------------------------------------------------------
// QueryTsc, HalQueryTsc
// ---------------------------------------------------------------------------------------

__declspec(naked) static void QueryTsc(LARGE_INTEGER * pli)
{
    _asm {
        mov ecx, [esp+4]
        rdtsc
        mov [ecx], eax
        mov [ecx+4], edx
        ret 4
    }
}

void HalQueryTsc(LARGE_INTEGER * pli)
{
    QueryTsc(pli);
}

// ---------------------------------------------------------------------------------------
// HalRandGather
// ---------------------------------------------------------------------------------------

struct CRandBytes
{
    BYTE *  _pb;
    UINT    _cb;

    INLINE void Init(BYTE * pb, UINT cb) { _pb = pb; _cb = cb; }
    INLINE void AddDword(DWORD dw) { Add(&dw, sizeof(DWORD)); }
    INLINE void AddWord(WORD w) { Add(&w, sizeof(WORD)); }
    INLINE void AddByte(BYTE b) { Add(&b, sizeof(BYTE)); }
    void Add(void * pv, UINT cb);
};

void CRandBytes::Add(void * pv, UINT cb)
{
    AssertSz(_cb >= cb, "HalRandGather has more randomness than the buffer has room");

    if (_cb >= cb)
    {
        memcpy(_pb, pv, cb);
        _pb += cb;
        _cb -= cb;
    }
}

UINT CXnHal::HalRandGather(BYTE * pb, UINT cb)
{
    LARGE_INTEGER liPerfCount;
    CRandBytes  randbytes;

    // We shouldn't need to initialize liPerfCount, but the compiler is stupid,
    // and if we don't initialize it, the compiler will fail to computs its
    // live range and will put it in the same place on the stack as randbytes.
    liPerfCount.QuadPart = 0;
    randbytes.Init(pb, cb);

    // ** indicates US DoD's specific recommendations for password generation

    // ** ticks since boot (system clock)
    DWORD dwTickBegin = NtGetTickCount(); 
    randbytes.AddDword(dwTickBegin);
    
    // ** system time
    LARGE_INTEGER liTime;
    KeQuerySystemTime(&liTime);
    randbytes.Add(&liTime, sizeof(liTime));

    // ** hi-res performance counter (system counters)
    QueryTsc(&liPerfCount);
    randbytes.AddDword(liPerfCount.LowPart ^ liPerfCount.HighPart);

    // memory status
    MM_STATISTICS mstMemStat;
    MmQueryStatistics(&mstMemStat);
    randbytes.AddWord(LOWORD(mstMemStat.AvailablePages));
    randbytes.AddWord(LOWORD(mstMemStat.PoolPagesCommitted));
    randbytes.AddByte(HIBYTE(LOWORD(mstMemStat.VirtualMemoryBytesReserved)));

#ifndef XNET_FEATURE_XBDM_SERVER

    // Free disk space
    ULARGE_INTEGER  ulintDriveFreeSpace;
    ULARGE_INTEGER  ulintTemp;
    ULARGE_INTEGER  ulintDiskFreeSpace;

    if (GetDiskFreeSpaceEx("T:", &ulintDriveFreeSpace, &ulintTemp, &ulintDiskFreeSpace))
    {
        randbytes.Add(&ulintDriveFreeSpace, sizeof(ulintDriveFreeSpace));
        randbytes.Add(&ulintDiskFreeSpace, sizeof(ulintDiskFreeSpace));
    }

#endif // XBDM

    // EEPROM values
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    NTSTATUS status;
    DWORD type, size;

    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (NT_SUCCESS(status))
    {
        Assert(type == REG_BINARY);
        Assert(size == EEPROM_TOTAL_MEMORY_SIZE);
        randbytes.Add(buf, size);
    }

    // Use hard drive model and serial number
    randbytes.Add(HalDiskModelNumber->Buffer, HalDiskModelNumber->Length);
    randbytes.Add(HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length);

    return(cb - randbytes._cb);
}

// ---------------------------------------------------------------------------------------
// DbgPrintToKd
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_SERVER

void DbgPrintToKd(const char * psz)
{
	STRING st, *pst;
	st.Buffer = (PCHAR)psz;
	st.Length = (USHORT)strlen(psz);
	st.MaximumLength = st.Length + 1;
	pst = &st;
	_asm {
		mov eax, BREAKPOINT_KDPRINT
		mov ecx, pst
		int 2dh
		int 3
	}
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\enet.cpp ===
// ---------------------------------------------------------------------------------------
// enet.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(Arp,          0);
DefineTag(ArpWarn,      TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// CXnEnet - External Functions
// ---------------------------------------------------------------------------------------

NTSTATUS CXnEnet::EnetInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = NicInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_ENET);

    KeInitializeDpc(&_dpcEnet, &EnetDpc, this);

#ifdef XNET_FEATURE_ARP
    _paeLast = _aae;
    _timerArp.Init((PFNTIMER)ArpTimer);
#endif

    return(NETERR_OK);
}

void CXnEnet::EnetTerm()
{
    TCHECK(UDPC);

    EnetStop();

    if (TestInitFlag(INITF_ENET))
    {
        KeRemoveQueueDpc(&_dpcEnet);

        if (!_pqXmit.IsEmpty())
        {
            TraceSz1(Warning, "Enet shutdown with %d packet(s) queued for transmit", _pqXmit.Count());
            _pqXmit.Discard(this);
        }

#ifdef XNET_FEATURE_ARP

        CArpEntry * pae = _aae;
        UINT        cae = dimensionof(_aae);

        for (; cae > 0; --cae, ++pae)
        {
            if (!pae->_pqWait.IsEmpty())
            {
                TraceSz2(Warning, "Enet shutdown with %d packet(s) queued for ARP %s",
                         pae->_pqWait.Count(), pae->_ipa.Str());
                pae->_pqWait.Discard(this);
            }
        }

        TimerSet(&_timerArp, TIMER_INFINITE);

#endif
    }

    SetInitFlag(INITF_ENET_TERM);

    NicTerm();
}

void CXnEnet::EnetXmit(CPacket * ppkt, CIpAddr ipaNext)
{
    ICHECK(ENET, UDPC|SDPC);

    if (!ppkt->TestFlags(PKTF_XMIT_FRAME))
    {
        Assert(ppkt->IsIp());
        *((CIpAddr *)ppkt->GetPv() - 1) = ipaNext;
    }

    if (ppkt->TestFlags(PKTF_XMIT_PRIORITY))
        _pqXmit.InsertHead(ppkt);
    else
        _pqXmit.InsertTail(ppkt);

    ppkt->ClearFlags(PKTF_XMIT_PRIORITY);

    EnetQueuePush();
}

#ifdef XNET_FEATURE_ARP

void CXnEnet::EnetXmitArp(CIpAddr ipa)
{
    ICHECK(ENET, UDPC|SDPC);

    _ipaCheck = ipa;

    if (_ipaCheck)
    {
        ArpXmit(ARP_OP_REQUEST, _ipaCheck, _ipaCheck, NULL);
    }
}

#endif

void CXnEnet::EnetStop()
{
    TCHECK(UDPC);

    if (TestInitFlag(INITF_ENET) && !TestInitFlag(INITF_ENET_STOP))
    {
        SetInitFlag(INITF_ENET_STOP);
    }

    NicStop();
}

// ---------------------------------------------------------------------------------------
// Virtual callbacks
// ---------------------------------------------------------------------------------------

void CXnEnet::EnetRecv(CPacket * ppkt, UINT uiType)
{
    ICHECK(ENET, UDPC|SDPC);

    Assert(ppkt->IsEnet());

    if (uiType == ENET_TYPE_IP)
    {
        ppkt->SetType(PKTF_TYPE_IP);
        IpRecv(ppkt);
    }
#ifdef XNET_FEATURE_ARP
    else if (uiType == ENET_TYPE_ARP)
    {
        ArpRecv(ppkt);
    }
#endif
    else
    {
        TraceSz1(pktRecv, "[DISCARD] No support for Ethernet type %04X", NTOHS((WORD)uiType));
    }
}

// ---------------------------------------------------------------------------------------
// CXnEnet - Internal Functions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ARP

void CXnEnet::ArpXmit(WORD wOp, CIpAddr ipaTarget, CIpAddr ipaSender, CEnetAddr * peaTarget)
{
    ICHECK(ENET, UDPC|SDPC);

    CPacket *   ppkt;
    CEnetHdr *  pEnetHdr;
    CArpMsg *   pArpMsg;
    
    ppkt = PacketAlloc(PTAG_CArpPacket,
                       PKTF_POOLALLOC|PKTF_TYPE_ENET|PKTF_XMIT_FRAME|PKTF_XMIT_PRIORITY,
                       sizeof(CArpMsg));
    if (ppkt == NULL)
    {
        TraceSz(Warning, "Out of memory allocating ARP packet");
        return;
    }

    pEnetHdr = ppkt->GetEnetHdr();
    pArpMsg = (CArpMsg *)ppkt->GetPv();

    if (peaTarget)
    {
        pEnetHdr->_eaDst = *peaTarget;
        pArpMsg->_eaTarget = *peaTarget;
    }
    else
    {
        pEnetHdr->_eaDst.SetBroadcast();
        pArpMsg->_eaTarget.SetZero();
    }

    pEnetHdr->_eaSrc    = _ea;
    pEnetHdr->_wType    = ENET_TYPE_ARP;
    pArpMsg->_wHrd      = ARP_HWTYPE_ENET;
    pArpMsg->_wPro      = ENET_TYPE_IP;
    pArpMsg->_bHln      = sizeof(CEnetAddr);
    pArpMsg->_bPln      = sizeof(CIpAddr);
    pArpMsg->_wOp       = wOp;
    pArpMsg->_eaSender  = _ea;
    pArpMsg->_ipaSender = ipaSender;
    pArpMsg->_ipaTarget = ipaTarget;

    TraceSz5(Arp, "%s (%s) is %s %s (%s)",
             ipaSender.Str(), _ea.Str(), peaTarget ? "replying to" : "broadcasting request for",
             ipaTarget.Str(), pArpMsg->_eaTarget.Str());

    EnetXmit(ppkt);
}

CXnEnet::CArpEntry * CXnEnet::ArpLookup(CIpAddr ipa, ArpResolve eResolve)
{
    ICHECK(ENET, UDPC|SDPC);
    Assert(ipa.IsValidUnicast());

    CArpEntry * pae;
    CArpEntry * paeRetryEnd;
    CArpEntry * paeHash;
    UINT        uiHash;

    Assert(ipa != 0);

    if (_paeLast->_ipa == ipa)
    {
        Assert(!_paeLast->IsFree());
        return(_paeLast);
    }

    // Get the hash bucket for the specified address

    uiHash = ARP_HASH(ipa);
    pae    = &_aae[uiHash];

    // Found the target address in the cache via a direct hash hit

    if (pae->_ipa == ipa)
    {
        goto found;
    }

    // No direct hash hit, try linear search

    paeHash     = pae;
    paeRetryEnd = pae + ARP_HASH_RETRY;

    while (++pae < paeRetryEnd)
    {
        if (pae->_ipa == ipa)
            goto found;
    }

    if (eResolve == eNone)
    {
        return(NULL);
    }

    // The target IP address is not in the cache:
    //  send out an ARP request if specified;
    //  and make a new cache entry for the target
    
    // Check to see if the hash bucket is free

    pae = paeHash;

    if (!pae->IsFree())
    {
        while (++pae < paeRetryEnd)
        {
            if (pae->IsFree())
                break;
        }

        // Couldn't find a free entry
        //  fall back and try to find a non-busy entry

        if (pae == paeRetryEnd)
        {
            pae = paeHash;

            while (++pae < paeRetryEnd)
            {
                if (!pae->IsBusy())
                    break;
            }

            if (pae == paeRetryEnd)
            {
                // Too bad: couldn't find either a free or non-busy entry
                //  emit a warning and give up

                return(NULL);
            }

            // This entry is currently used for another address:
            // we'll just bump it off here.

            TraceSz1(Arp, "Bumped entry for %s", pae->_ipa.Str());
        }
    }

    TraceSz1(Arp, "Adding entry for %s", ipa.Str());

    pae->_ipa = ipa;
    Assert(pae->_pqWait.IsEmpty());

    if (eResolve == eSendRequest)
    {
        pae->_wState = ARP_STATE_BUSY + cfgEnetArpReqRetries;
        pae->_dwTick = TimerSetRelative(&_timerArp, cfgEnetArpRexmitTimeoutInSeconds * TICKS_PER_SECOND);
        ArpXmit(ARP_OP_REQUEST, ipa, _ipa, NULL);
    }
    else
    {
        // Remaining initialization of this entry happens in the caller which
        // changes the state to ARP_STATE_IDLE
        pae->_wState = ARP_STATE_BUSY;
    }

found:
    Assert(pae && !pae->IsFree());
    _paeLast = pae;
    return(pae);
}

void CXnEnet::ArpTimer(CTimer * pt)
{
    ICHECK(ENET, UDPC|SDPC);

    CArpEntry * pae;
    UINT        iae;
    DWORD       dwTickNow = TimerTick();
    DWORD       dwTickArp = TIMER_INFINITE;

    for (iae = 0, pae = _aae; iae < ARP_CACHE_SIZE; ++iae, ++pae)
    {
        if (pae->IsFree())
            continue;

        if (dwTickNow >= pae->_dwTick)
        {
            if (pae->_wState > ARP_STATE_BUSY)
            {
                TraceSz1(ArpWarn, "ArpTimer: %s didn't respond to request.  Trying again.", pae->_ipa.Str());
                pae->_dwTick = dwTickNow + cfgEnetArpRexmitTimeoutInSeconds * TICKS_PER_SECOND;
                pae->_wState -= 1;
                ArpXmit(ARP_OP_REQUEST, pae->_ipa, _ipa, NULL);
            }
            else if (pae->_wState == ARP_STATE_BUSY)
            {
                TraceSz3(ArpWarn, "ArpTimer: %s is unreachable.  Discarding %d waiting packet%s.",
                         pae->_ipa.Str(), pae->_pqWait.Count(), pae->_pqWait.Count() == 1 ? "" : "s");
                pae->_pqWait.Complete(this);
                pae->_dwTick = dwTickNow + (cfgEnetArpNegCacheTimeoutInMinutes * 60 * TICKS_PER_SECOND);
                pae->_wState = ARP_STATE_BAD;
            }
            else
            {
                TraceSz1(Arp, "%s has timed out", pae->_ipa.Str());
                pae->_dwTick = TIMER_INFINITE;
                pae->_wState = ARP_STATE_FREE;
                pae->_ipa    = 0;
            }
        }

        if (dwTickArp > pae->_dwTick)
            dwTickArp = pae->_dwTick;
    }

    Assert(pt == &_timerArp);
    TimerSet(pt, dwTickArp);
}

void CXnEnet::ArpRecv(CPacket * ppkt)
{
    ICHECK(ENET, UDPC|SDPC);

    Assert(ppkt->IsEnet());

    CEnetHdr *  pEnetHdr = ppkt->GetEnetHdr();
    CArpMsg *   pArpMsg  = (CArpMsg *)ppkt->GetPv();
    UINT        cbMsg    = ppkt->GetCb();
    WORD        wOp;
    CIpAddr     ipaSender;
    CEnetAddr   eaSender;
    CIpAddr     ipaTarget;
    CArpEntry * pae;
    ArpResolve  eResolve;

    TraceSz5(pktRecv, "[ARP %s %s %s %s %s]",
             pArpMsg->_wOp == ARP_OP_REQUEST ? "Request" :
             pArpMsg->_wOp == ARP_OP_REPLY ? "Reply" : "???",
             pArpMsg->_ipaSender.Str(), pArpMsg->_eaSender.Str(),
             pArpMsg->_ipaTarget.Str(), pArpMsg->_eaTarget.Str());

    if (_ea.IsEqual(pEnetHdr->_eaSrc))
    {
        // We received an ARP packet from someone who has the same Ethernet address
        // as us.  Issue a warning and discard the packet.  There's not a lot we
        // can do at this point.

        TraceSz(pktWarn, "[DISCARD] ARP sender has conflicting Ethernet address!");
        return;
    }

    if (cbMsg < sizeof(CArpMsg))
    {
        TraceSz1(pktRecv, "[DISCARD] ARP packet is too small (%d)", cbMsg);
        return;
    }

    wOp       = pArpMsg->_wOp;
    ipaSender = pArpMsg->_ipaSender;
    eaSender  = pArpMsg->_eaSender;
    ipaTarget = pArpMsg->_ipaTarget;

    if (    pArpMsg->_wHrd != ARP_HWTYPE_ENET && pArpMsg->_wHrd != ARP_HWTYPE_802
        ||  pArpMsg->_wPro != ENET_TYPE_IP
        ||  pArpMsg->_bHln != sizeof(CEnetAddr)
        ||  pArpMsg->_bPln != sizeof(CIpAddr)
        ||  wOp != ARP_OP_REQUEST && wOp != ARP_OP_REPLY
        ||  !ipaSender.IsValidUnicast()
        ||  !ipaTarget.IsValidUnicast()
        ||  eaSender.IsMulticast())
    {
        TraceSz9(pktRecv, "[DISCARD] ARP message is invalid (%d,%d,%d,%d,%d,%d,%d,%d,%d)",
                 pArpMsg->_wHrd != ARP_HWTYPE_ENET && pArpMsg->_wHrd != ARP_HWTYPE_802,
                 pArpMsg->_wPro != ENET_TYPE_IP,
                 pArpMsg->_bHln != sizeof(CEnetAddr),
                 pArpMsg->_bPln != sizeof(CIpAddr),
                 wOp != ARP_OP_REQUEST && wOp != ARP_OP_REPLY,
                 !ipaSender.IsValidUnicast(),
                 !ipaTarget.IsValidUnicast(),
                 eaSender.IsMulticast(),
                 eaSender.IsBroadcast());
        return;
    }

    // Check to see if we have an existing entry for the sender
    // in our ARP cache. If we're the target and there is no
    // existing entry, then we'll create a new entry.
    // This assumes that communication will likely be bidirectional.

    if (ipaSender == _ipaCheck)
    {
        TraceSz(Arp, "Auto-IP collision detected");
        _ipaCheck = 0;
        IpRecvArp(&eaSender);
    }

    // If we don't have an IP address yet, there is nothing more to do

    if (_ipa == 0)
        return;

    if (ipaSender != _ipa)
    {
        eResolve = (ipaTarget == _ipa) ? eCreateEntry : eNone;

        pae = ArpLookup(ipaSender, eResolve);

        if (pae)
        {
            if (pae->_wState != ARP_STATE_IDLE)
            {
                TraceSz2(Arp, "%s resolved to %s", pae->_ipa.Str(), eaSender.Str());
            }

            pae->_wState = ARP_STATE_IDLE;
            pae->_dwTick = TimerSetRelative(&_timerArp, cfgEnetArpPosCacheTimeoutInMinutes * 60 * TICKS_PER_SECOND);
            pae->_eaNext = eaSender;

            if (!pae->_pqWait.IsEmpty())
            {
                TraceSz3(Arp, "Sending %d packet%s waiting for %s", pae->_pqWait.Count(),
                         pae->_pqWait.Count() == 1 ? "" : "s", pae->_ipa.Str());

                _pqXmit.InsertHead(&pae->_pqWait);

                EnetQueuePush();
            }
        }
    }
    
    // If we're the target and the packet is an ARP request,
    // then send out an ARP reply.

    if (ipaTarget == _ipa && wOp == ARP_OP_REQUEST)
    {
        TraceSz(pktRecv, "[REPLY] Replying to ARP request");
        ArpXmit(ARP_OP_REPLY, ipaSender, _ipa, &eaSender);
    }
    else if (wOp == ARP_OP_REQUEST)
    {
        TraceSz(pktRecv, "[DISCARD] ARP request not for me");
        return;
    }
    else
    {
        TraceSz(pktRecv, "[ARPDONE] ARP reply processed");
        return;
    }
}

#endif

// ---------------------------------------------------------------------------------------
// EnetPush
// ---------------------------------------------------------------------------------------

void CXnEnet::EnetPush()
{
    ICHECK(ENET, UDPC|SDPC);

    CPacket *   ppkt;
    CIpAddr     ipaNext;

#ifdef XNET_FEATURE_ARP
    CArpEntry * pae;
#endif

    while (!_pqXmit.IsEmpty() && NicXmitReady())
    {
        ppkt = _pqXmit.RemoveHead();

        if (TestInitFlag(INITF_ENET_STOP))
        {
            TraceSz(pktWarn, "[DISCARD] Network is down");
            goto complete;
        }

        if (ppkt->TestFlags(PKTF_XMIT_FRAME))
        {
            ppkt->ClearFlags(PKTF_XMIT_FRAME);
            NicXmit(ppkt);
            continue;
        }

        Assert(ppkt->IsIp());

        ipaNext = *((CIpAddr *)ppkt->GetPv() - 1);

        if (ipaNext == 0)
        {
            // ipaNext set to zero from the caller means that this packet should be discarded
            // silently.  The purpose is to prevent calling back to the sender in the middle
            // of transmitting the packet to break potential recursion.
            goto complete;
        }

        if (ipaNext.IsBroadcast())
        {
            CEnetAddr eaNext;
            eaNext.SetBroadcast();
            EnetFillAndXmit(ppkt, &eaNext);
            continue;
        }

        if (ipaNext.IsLoopback() && ipaNext != IPADDR_LOOPBACK)
        {
            TraceSz1(pktWarn, "[DISCARD] Can't send to %s", ipaNext.Str());
            goto complete;
        }

        if (ipaNext == IPADDR_LOOPBACK || ipaNext == _ipa)
        {
            TraceSz1(pktRecv, "\n[LOOPBACK][%d]", ppkt->GetCb());
            ppkt->SetFlags(PKTF_RECV_LOOPBACK);
            IpRecv(ppkt);
            ppkt->ClearFlags(PKTF_RECV_LOOPBACK);
            ppkt->Complete(this);
            continue;
        }

#ifdef XNET_FEATURE_ARP

        pae = ArpLookup(ipaNext, eSendRequest);

        if (pae == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] ARP cache is full");
            goto complete;
        }

        if (pae->IsIdle())
        {
            EnetFillAndXmit(ppkt, &pae->_eaNext);
            continue;
        }

        if (pae->IsBad())
        {
            TraceSz1(pktWarn, "[DISCARD] %s is unreachable", pae->_ipa.Str());
            goto complete;
        }

        Assert(pae->IsBusy());
        pae->_pqWait.InsertTail(ppkt);
        continue;

#else
        TraceSz1(pktWarn, "[DISCARD] %s is unreachable", ipaNext);
        goto complete;
#endif

complete:
        ppkt->Complete(this);
    }
}

void CXnEnet::EnetFillAndXmit(CPacket * ppkt, CEnetAddr * peaNext)
{
    ICHECK(ENET, UDPC|SDPC);
    Assert(ppkt->IsIp());
    Assert(peaNext);

    CEnetHdr * pEnetHdr = ppkt->GetEnetHdr();
    pEnetHdr->_eaDst = *peaNext;
    pEnetHdr->_eaSrc = _ea;
    pEnetHdr->_wType = ENET_TYPE_IP;

    NicXmit(ppkt);
}

void CXnEnet::EnetQueuePush()
{
    ICHECK(ENET, UDPC|SDPC);
    KeInsertQueueDpc(&_dpcEnet, NULL, NULL);
}

void CXnEnet::EnetDpc(PKDPC, void * pEnet, void *, void *)
{
    ((CXnEnet *)pEnet)->EnetPush();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\base.cpp ===
tag// ---------------------------------------------------------------------------------------
// base.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_SERVER
#define XNET_TRACE_PREFIX   "XBDM"
#elif defined(XNET_FEATURE_ONLINE)
#define XNET_TRACE_PREFIX   "XONLINE"
#else
#define XNET_TRACE_PREFIX   "XNET"
#endif

DefineTag(Timer,    0);
DefineTag(poolWarn, TAG_ENABLE);
DefineTag(poolDump, 0);

// ---------------------------------------------------------------------------------------
// Crypto Constants
// ---------------------------------------------------------------------------------------

extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
    0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
    0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
    0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
    0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
    0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
    0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
    0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
    0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
    0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

// ---------------------------------------------------------------------------------------
// CXnBase (Params)
// ---------------------------------------------------------------------------------------

#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) typedef int _farf_##name[offsetof(XNetStartupParams, name) == idx];
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max)
XNETPARAMDEFS()     // If this barfs, XNETPARAMDEFS is out of sync with XNetStartupParams
#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) def,
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max) def,
const XNetParams CXnBase::s_XNetParamsDef = { XNETPARAMDEFS() };
#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) min,
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max) min,
const XNetParams CXnBase::s_XNetParamsMin = { XNETPARAMDEFS() };
#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) max,
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max)  max,
const XNetParams CXnBase::s_XNetParamsMax = { XNETPARAMDEFS() };
#undef DEFINE_PARAM

// ---------------------------------------------------------------------------------------
// CLeakTracker
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

#define LEAKS_PER_ALLOC     128

DefineTag(LeakWarn, TAG_ENABLE);

void * CXnBase::LeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    if (pv && !pli->_fLeakDisable)
    {
        RaiseToDpc();

        CLeak * pLeak = NULL;

        if (pli->_cLeak == pli->_cLeakAlloc)
        {
            pLeak = (CLeak *)HalAlloc((pli->_cLeakAlloc + LEAKS_PER_ALLOC) * sizeof(CLeak), 0);

            if (pLeak == NULL)
            {
                if (pli->_pLeak)
                {
                    HalFree(pli->_pLeak);
                    pli->_pLeak = NULL;
                    pli->_cLeak = 0;
                }

                TraceSz(LeakWarn, "Leak tracker ran out of memory.  Tracking disabled.");
                pli->_fLeakDisable = TRUE;
                return(pv);
            }

            if (pli->_pLeak)
            {
                memcpy(pLeak, pli->_pLeak, pli->_cLeakAlloc * sizeof(CLeak));
                HalFree(pli->_pLeak);
            }

            pli->_pLeak = pLeak;
            pli->_cLeakAlloc += LEAKS_PER_ALLOC;
        }

        if (LeakFind(pli, pv, &pLeak))
        {
            AssertSz(FALSE, "Attempt to leak track the same memory more than once.  Tracking disabled.");
            HalFree(pli->_pLeak);
            pli->_pLeak = NULL;
            pli->_cLeak = 0;
            pli->_fLeakDisable = TRUE;
            return(pv);
        }

        UINT cbMov = (pli->_cLeak - (pLeak - pli->_pLeak)) * sizeof(CLeak);

        if (cbMov > 0)
        {
            memmove(pLeak + 1, pLeak, cbMov);
        }

        pLeak->_pv   = pv;
        pLeak->_cb   = cb;
        pLeak->_tag  = tag;
        pli->_cLeak += 1;
    }

    return(pv);
}

void * CXnBase::LeakDel(CLeakInfo * pli, void * pv)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    if (pv && !pli->_fLeakDisable)
    {
        RaiseToDpc();

        CLeak * pLeak = NULL;

        if (LeakFind(pli, pv, &pLeak))
        {
            Assert(pLeak->_pv == pv);

            int cbMov = (pli->_cLeak - (pLeak - pli->_pLeak) - 1) * sizeof(CLeak);

            if (cbMov > 0)
            {
                memmove(pLeak, pLeak + 1, cbMov);
            }

            pli->_cLeak -= 1;
        }
        else
        {
            AssertSz(FALSE, "Leak tracker can't find memory block in its table");
        }
    }

    return(pv);
}

BOOL CXnBase::LeakFind(CLeakInfo * pli, void * pv, CLeak ** ppLeak)
{
    ICHECK(BASE, UDPC|SDPC);

    int     iLo     = 0;
    int     iHi     = (int)pli->_cLeak;
    int     iMid;
    CLeak * pLeak   = pli->_pLeak;
    BOOL    fFound  = FALSE;

    while (iLo < iHi)
    {
        iMid  = (iLo + iHi) >> 1;
        pLeak = pli->_pLeak + iMid;

        if (pLeak->_pv == pv)
        {
            iLo = iMid;
            fFound = TRUE;
            break;
        }
        else if (pLeak->_pv < pv)
            iLo = iMid + 1;
        else
            iHi = iMid;
    }

    *ppLeak = pli->_pLeak + iLo;

    return(fFound);
}

void CXnBase::LeakTerm(CLeakInfo * pli)
{
    if (pli->_cLeak > 0)
    {
        CLeak * pLeak   = pli->_pLeak;
        UINT cLeak      = pli->_cLeak;
        UINT cbLeak     = 0;

        for (; cLeak > 0; --cLeak, ++pLeak)
        {
            cbLeak += pLeak->_cb;
            TraceSz3(LeakWarn, "Leaked %5d bytes at %08lX - %s", pLeak->_cb, pLeak->_pv,
                     pli->_pfnLeakTag(pLeak->_tag));
        }

        TraceSz1(LeakWarn, "Leaked %5d bytes total", cbLeak);
    }

    if (pli->_pLeak)
    {
        HalFree(pli->_pLeak);
        pli->_pLeak = NULL;
    }
}

const char * XnLeakTagToString(ULONG tag)
{
    switch (tag)
    {
        #undef  XNETPTAG
        #define XNETPTAG(_name, _tag) case PTAG_##_name: return(#_name); break;
        XNETPTAGLIST()
    }

    return("?");
}

#endif

// ---------------------------------------------------------------------------------------
// CXnBase (Pool Allocator)
// ---------------------------------------------------------------------------------------

//
// Pool allocation block header: We intentionally let this have
// the same size as the system pool header. But we've restructured
// the fields in such a way that if you try to free a memory block
// that was allocated out of our private pool to the system pool,
// you'd get a bugcheck.
//

struct PoolEntry
{
    BYTE bOver;
        // if busy, the amount of overhead in the block
    BYTE bBusy;
        // Whether the block is allocated or free

    WORD tag;
        // We're only using 2 bytes for pool tag,
        // since all of our pool tags have the form NET*.

    WORD blockSize;
    WORD previousSize;
        // Size of this block and the previous block in 32-bit units

    LIST_ENTRY links;
        // A free pool entry has two additional pointer fields
        // for maintaining a doubly-linked list of free blocks.
};

#define POOL_BLOCK_SHIFT 5
#define POOL_BLOCK_SIZE (1 << POOL_BLOCK_SHIFT)
#define MAX_POOL_SIZE (POOL_BLOCK_SIZE * 0xffff)
#define POOL_HEADER_SIZE offsetof(PoolEntry, links)

#define MarkPoolEntryBusy(_entry) ((_entry)->bBusy = 1)
#define MarkPoolEntryFree(_entry) ((_entry)->bBusy = 0)
#define IsPoolEntryBusy(_entry) ((_entry)->bBusy != 0)
#define IsPoolEntryFree(_entry) ((_entry)->bBusy == 0)
#define TagPoolEntry(_entry, _tag) ((_entry)->tag = (WORD) ((_tag) >> 16))

#define GetPoolEntryHeader(_ptr) \
        ((PoolEntry*) ((BYTE*) (_ptr) - POOL_HEADER_SIZE))
#define GetPoolEntryNext(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) + ((UINT) (_entry)->blockSize << POOL_BLOCK_SHIFT)))
#define GetPoolEntryPrev(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) - ((UINT) (_entry)->previousSize << POOL_BLOCK_SHIFT)))

//
// Beginning and ending address of the entire pool
//

#define IsPoolEntryValid(_entry) ((_entry) >= _pvPoolStart && (_entry) < _pvPoolEnd)

#define InsertFreePoolEntry(_entry) { \
            LIST_ENTRY* _head; \
            _head = &_aleFree[ \
                        (_entry)->blockSize <= MAX_SMALL_BLOCKS ? \
                            (_entry)->blockSize - 1 : \
                            MAX_SMALL_BLOCKS]; \
            InsertHeadList(_head, &(_entry)->links); \
        }


void * CXnBase::PoolAlloc(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC|SDPC);

#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        return(LeakAdd(&_leakinfo, VMemAlloc(size), size, tag));
    }
#endif

    PoolEntry* entry;

    Assert(size > 0 && size <= MAX_POOL_SIZE - POOL_HEADER_SIZE);
    size_t size_orig = size;
    size = (size + (POOL_HEADER_SIZE + POOL_BLOCK_SIZE - 1)) >> POOL_BLOCK_SHIFT;

    RaiseToDpc();

    // Find a free pool block that's large enough for us.
    // Handle small block allocation with the quick lookup.
    if (size <= MAX_SMALL_BLOCKS)
    {
        UINT index;

        for (index=size-1; index <= MAX_SMALL_BLOCKS; index++)
        {
            if (!IsListEmpty(&_aleFree[index]))
            {
                entry = GetPoolEntryHeader(_aleFree[index].Flink);
                goto found;
            }
        }
    }
    else
    {
        LIST_ENTRY* head;
        LIST_ENTRY* list;

        head = &_aleFree[MAX_SMALL_BLOCKS];
        list = head->Flink;
        while (list != head)
        {
            entry = GetPoolEntryHeader(list);
            if ((WORD) size <= entry->blockSize)
                goto found;
            list = list->Flink;
        }
    }

    TraceSz1(poolWarn, "Pool allocation failed: %d blocks", size);
    TraceSz(poolWarn, "Make sure you promptly call recv() to receive incoming data.");
    TraceSz(poolWarn, "You may also want to consider setting a larger pool size.");

#if DBG
    if (Tag(poolDump))
        PoolDump();
#endif

    return(NULL);

found:
    // Take it out of the free list
    RemoveEntryList(&entry->links);

    // If we didn't use up the entire free block,
    // put the remaining portion back on the free list.
    if (entry->blockSize > size) {
        UINT leftover = entry->blockSize - size;
        PoolEntry* next;

        entry->blockSize = (WORD) size;

        next = GetPoolEntryNext(entry);
        next->blockSize = (WORD) leftover;
        next->previousSize = (WORD) size;
        next->tag = entry->tag;
        MarkPoolEntryFree(next);
        InsertFreePoolEntry(next);

        next = GetPoolEntryNext(next);
        Assert(IsPoolEntryValid(next));
        next->previousSize = (WORD) leftover;
    }

    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, tag);
    entry->bOver = (BYTE)((size << POOL_BLOCK_SHIFT) - size_orig);

#ifdef XNET_FEATURE_ASSERT
    LeakAdd(&_leakinfo, (BYTE *)entry + POOL_HEADER_SIZE, size_orig, tag);
#endif

    return (BYTE*) entry + POOL_HEADER_SIZE;
}

void * CXnBase::PoolAllocZ(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    void * pv = PoolAlloc(size, tag);

    if (pv)
    {
        memset(pv, 0, size);
    }

    return(pv);
}

void CXnBase::PoolFree(void * ptr)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    if (ptr == NULL)
    {
        return;
    }

#ifdef XNET_FEATURE_ASSERT
    LeakDel(&_leakinfo, ptr);
#endif

#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        VMemFree(ptr);
        return;
    }
#endif

    PoolEntry* entry;
    PoolEntry* prev;
    PoolEntry* next;
    WORD blockSize;

    entry = GetPoolEntryHeader(ptr);
    Assert(IsPoolEntryValid(entry) && IsPoolEntryBusy(entry));

    RaiseToDpc();

    MarkPoolEntryFree(entry);
    blockSize = entry->blockSize;

    //
    // Check to see if the block before this one is free
    // If so, collapse the two free blocks together
    //
    prev = GetPoolEntryPrev(entry);
    Assert(IsPoolEntryValid(prev));
    if (IsPoolEntryFree(prev)) {
        RemoveEntryList(&prev->links);
        prev->blockSize = (WORD) (prev->blockSize + blockSize);
        entry = prev;
    }

    //
    // Check if the block after this one is free
    // If so, collapse the two free blocks together
    //
    next = GetPoolEntryNext(entry);
    Assert(IsPoolEntryValid(next) && next->previousSize == blockSize);
    if (IsPoolEntryFree(next)) {
        RemoveEntryList(&next->links);
        entry->blockSize = (WORD) (entry->blockSize + next->blockSize);
    }

    //
    // If we performed any collapsing, 
    // update the previousSize field of the next block.
    //
    if (entry->blockSize != blockSize) {
        next = GetPoolEntryNext(entry);
        Assert(IsPoolEntryValid(next));
        next->previousSize = entry->blockSize;
    }

    InsertFreePoolEntry(entry);
}

#if DBG

void CXnBase::PoolDump()
{
    ICHECK(BASE, USER|UDPC|SDPC);

    PoolEntry* entry;
    PoolEntry* prev;
    UINT cbFree = 0;
    UINT cbBusy = 0;
    UINT cbOver = 0;
    UINT cbPool = (BYTE *)_pvPoolEnd - (BYTE *)_pvPoolStart;

    TraceSz(poolWarn, "+\n-------------------------------------------------------------------------");
    TraceSz2(poolWarn, "Private Pool Dump (%08lX - %08lX)", _pvPoolStart, _pvPoolEnd);
    TraceSz(poolWarn, "");

    prev = NULL;
    entry = (PoolEntry *)_pvPoolStart;

    while (entry < _pvPoolEnd)
    {
        BOOL fIsFree = IsPoolEntryFree(entry);
        BOOL fIsOver = (entry == _pvPoolStart) || ((BYTE *)entry + (1 << POOL_BLOCK_SHIFT)) == (BYTE *)_pvPoolEnd;
        UINT cb      = (entry->blockSize << POOL_BLOCK_SHIFT);

        if (fIsFree)
        {
            cb -= POOL_HEADER_SIZE;
            cbFree += cb;
            cbOver += POOL_HEADER_SIZE;
            TraceSz3(poolWarn, "%08lX f %7d (+%2d) bytes",
                     (UINT_PTR)entry + POOL_HEADER_SIZE, cb, POOL_HEADER_SIZE);
        }
        else
        {
            cb -= entry->bOver;
            cbBusy += cb;
            cbOver += entry->bOver;

            TraceSz4(poolWarn, "%08lX   %7d (+%2d) bytes %s",
                     (UINT_PTR)entry + POOL_HEADER_SIZE, cb, entry->bOver,
                     XnLeakTagToString(('xTEN' & 0xFFFF) | (entry->tag << 16)));
        }

        if (prev)
        {
            Assert(prev->blockSize == entry->previousSize);
            prev = entry;
        }

        entry = GetPoolEntryNext(entry);
    }

    Assert(entry == _pvPoolEnd);

    TraceSz(poolWarn, "");
    TraceSz1(poolWarn, "%7d bytes used", cbBusy);
    TraceSz1(poolWarn, "%7d bytes free", cbFree);
    TraceSz1(poolWarn, "%7d bytes overhead", cbOver);
    TraceSz1(poolWarn, "%7d bytes entire pool", cbPool);
    TraceSz(poolWarn, "+-------------------------------------------------------------------------\n");

    Assert(cbBusy + cbFree + cbOver == cbPool);

    if (Tag(poolDump) >= TAG_BREAK)
    {
        DbgBreak();
    }
}

#endif // DBG

// ---------------------------------------------------------------------------------------
// CXnBase (Rand)
// ---------------------------------------------------------------------------------------

void CXnBase::RandInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    BYTE    abSha1Ctx[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE    abRand[512];
    BYTE    abHash[XC_SERVICE_DIGEST_SIZE];
    UINT    cbRand = 0;

    // Gather system randomness into the abRand vector

    cbRand = HalRandGather(abRand, sizeof(abRand));
    Assert(cbRand <= sizeof(abRand));

    // Compute a SHA1 digest of all of the gathered random bits

    XcSHAInit(abSha1Ctx);
    XcSHAUpdate(abSha1Ctx, pxnip->abSeed, sizeof(pxnip->abSeed));
    XcSHAUpdate(abSha1Ctx, (BYTE *)&pxnip->liTime, sizeof(pxnip->liTime));
    XcSHAUpdate(abSha1Ctx, abRand, cbRand);
    XcSHAFinal(abSha1Ctx, abHash);

    // Initialize an RC4 machine with the given digest as a key

    XcRC4Key(_abRandRc4Struct, sizeof(abHash), abHash);
    
    // Throw away the first 256 bytes of the RC4 machine

    XcRC4Crypt(_abRandRc4Struct, 256, abRand);

    // Update the seed value with the next 20 bytes of the RC4 machine

    XcRC4Crypt(_abRandRc4Struct, sizeof(pxnip->abSeed), pxnip->abSeed);
}

void CXnBase::Rand(BYTE * pb, UINT cb)
{
    ICHECK(BASE, USER|UDPC|SDPC);
    RaiseToDpc();
    XcRC4Crypt(_abRandRc4Struct, cb, pb);
}

ULONG CXnBase::RandLong()
{
    ICHECK(BASE, USER|UDPC|SDPC);
    ULONG ul;
    Rand((BYTE *)&ul, sizeof(ULONG));
    return(ul);
}

// ---------------------------------------------------------------------------------------
// CXnBase (Packet)
// ---------------------------------------------------------------------------------------

CPacket * CXnBase::PacketAlloc(ULONG tag, UINT uiFlags, UINT cbPayload, UINT cbPkt, PFNPKTFREE pfn)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    Assert(sizeof(PFNPKTFREE) == sizeof(void *));

    CPacket *   ppkt;
    UINT        cbPtr;
    UINT        cbPad = 0;
    UINT        cbHdr = 0;

    // We shouldn't be creating CPacket classes that aren't four-byte aligned

    if (cbPkt == 0)
        cbPkt = sizeof(CPacket);

    Assert(cbPkt == ROUNDUP4(cbPkt));

    // Add in the ethernet header

    cbPkt += ROUNDUP4(sizeof(CEnetHdr));

    // This offset tells us where the [Payload] begins.

    cbPtr = cbPkt;

    // Add in the size of all the headers in the packet based on its type.

    cbPkt += CPacket::_abPktTypeInfo[((uiFlags & PKTF_TYPE_MASK) >> PKTF_TYPE_SHIFT) * PKTI_MAX + PKTI_SIZE];

    if (uiFlags & PKTF_TYPE_ESP)
    {
        cbHdr  = (uiFlags & PKTF_TYPE_UDP) ? sizeof(CUdpHdr) : (uiFlags & PKTF_TYPE_TCP) ? sizeof(CTcpHdr) : 0;
        cbPkt -= cbHdr;
        cbPad  = cbPkt;

        if (uiFlags & PKTF_CRYPT)
        {
            cbPkt += ROUNDUP8(XC_SERVICE_DES_BLOCKLEN + cbHdr + cbPayload + offsetof(CEspTail, _abHash));
            cbPad  = cbPkt - cbPad - (XC_SERVICE_DES_BLOCKLEN + cbHdr + cbPayload + offsetof(CEspTail, _abHash));
        }
        else
        {
            cbPkt += ROUNDUP4(cbPayload + cbHdr + offsetof(CEspTail, _abHash));
            cbPad  = cbPkt - cbPad - (cbPayload + cbHdr + offsetof(CEspTail, _abHash));
        }

        cbPkt += sizeof(CEspTail) - offsetof(CEspTail, _abHash);
    }
    else
    {
        // Add in the size of the user-specified payload

        cbPkt += cbPayload;
    }

    // Allocate the packet and initialize it

    if (uiFlags & PKTF_POOLALLOC)
        ppkt = (CPacket *)PoolAlloc(cbPkt, tag);
    else 
        ppkt = (CPacket *)SysAlloc(cbPkt, tag);

    if (ppkt)
    {
        ppkt->Init(uiFlags, (BYTE *)ppkt + cbPtr, cbPkt - cbPtr, pfn ? pfn : (PFNPKTFREE)PacketFree);

        // If this is an [ESP] packet, we need to store the _bPadLen field now since
        // we just went through a lot of trouble to compute it.

        if (uiFlags & PKTF_TYPE_ESP)
        {
            CEspTail * pEspTail = ppkt->GetEspTail();
            
            pEspTail->_bPadLen = (BYTE)cbPad;

            // Fill the padding (if any) with the byte series 1, 2, 3, ...

            for (BYTE * pb = (BYTE *)pEspTail; cbPad > 0; )
            {
                *--pb = (BYTE)cbPad--;
            }
        }

        IFDBG(ppkt->SetAllocated();)

        ppkt->Validate();
    }
    else
    {
        TraceSz1(Warning, "Out of memory allocating a CPacket of size %ld bytes", cbPkt);
    }

    return(ppkt);
}

void CXnBase::PacketFree(CPacket * ppkt)
{
    ICHECK(BASE, USER|UDPC|SDPC);
    Assert(!ppkt->TestFlags(PKTF_RECV_LOOPBACK));

#if DBG
    Assert(ppkt->IsAllocated());
#endif

    if (ppkt->TestFlags(PKTF_POOLALLOC))
        PoolFree(ppkt);
    else
        SysFree(ppkt);
}

void * CPacket::GetHdr(int iHdr)
{
    Assert(IsIp());
    Assert(PKTF_IHL_SHIFT == 2);
    Assert(iHdr == PKTI_ESP || iHdr == PKTI_UDP_TCP);
    Assert(PKTI_UDP_TCP == 1);
    return(     (BYTE *)_pv
            +   (_wFlags & PKTF_IHL_MASK)
            +   _abPktTypeInfo[(GetType() >> PKTF_TYPE_SHIFT) * PKTI_MAX + iHdr]
            +   (((!!(_wFlags & PKTF_CRYPT)) & iHdr) << 3));
}

#if DBG

const char * const CPacket::_aszPktTypeName[] =
{
    "[ENET]^[IP][Payload]",
    "[ENET]^[IP][ESP][Payload][ESPT]",
    "[ENET]^[IP][UDP][Payload]",
    "[ENET]^[IP][ESP][UDP][Payload][ESPT]",
    "[ENET]^[IP][TCP][Payload]",
    "[ENET]^[IP][ESP][TCP][Payload][ESPT]",
    "[ENET]^[Payload]",
    "[ENET]^[IP][Payload]",
    "[ENET]^[IP][ESP][IV][Payload][ESPT]",
    "[ENET]^[IP][UDP][Payload]",
    "[ENET]^[IP][ESP][IV][UDP][Payload][ESPT]",
    "[ENET]^[IP][TCP][Payload]",
    "[ENET]^[IP][ESP][IV][TCP][Payload][ESPT]",
    "[ENET]^[Payload]",
};

void CPacket::DbgSetSpy()
{
    int iType = (int)((_wFlags & PKTF_TYPE_MASK) >> PKTF_TYPE_SHIFT);

    _pchSpy = _aszPktTypeName[iType + ((_wFlags & PKTF_CRYPT) ? 7 : 0)];

    memset(&_spy, 0, sizeof(CSpy));

    _spy._pEnetHdr = (CEnetHdr *)((BYTE *)_pv - sizeof(CEnetHdr));

    if ((_wFlags & PKTF_TYPE_MASK) != PKTF_TYPE_ENET)
    {
        _spy._pIpHdr = (CIpHdr *)_pv;

        if (_wFlags & PKTF_TYPE_ESP)
        {
            _spy._pEspHdr  = GetEspHdr();
            _spy._pEspTail = GetEspTail();
        }

        if (_wFlags & PKTF_TYPE_UDP)
        {
            _spy._pUdpHdr = GetUdpHdr();
        }

        if (_wFlags & PKTF_TYPE_TCP)
        {
            _spy._pTcpHdr = GetTcpHdr();
        }
    }
}

void CPacket::Validate()
{
    if (IsEsp())
    {
        CEspTail *  pEspTail = GetEspTail();
        UINT        cbPad    = pEspTail->_bPadLen;
        BYTE *      pbPad    = (BYTE *)pEspTail;

        // Verify that the padding is the series of bytes 1, 2, 3, ...

        while (cbPad > 0 && *--pbPad == (BYTE)cbPad)
            cbPad--;
    
        AssertSz1(cbPad == 0, "Packet padding has been overwritten (ppkt=%08lX)", this);
    }
}

#endif

const BYTE CPacket::_abPktTypeInfo[] =
{
    // [ENET]^[IP][Payload]

    0,                                                                      // [ESP]
    0,                                                                      // [UDP]/[TCP]
    sizeof(CIpHdr),                                                         // Size

    // [ENET]^[IP][ESP][Payload][ESPT]

    sizeof(CIpHdr),                                                         // [ESP]
    0,                                                                      // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CEspHdr),                                       // Size

    // [ENET]^[IP][UDP][Payload]

    0,                                                                      // [ESP]
    sizeof(CIpHdr),                                                         // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CUdpHdr),                                       // Size

    // [ENET]^[IP][ESP][UDP][Payload][ESPT]

    sizeof(CIpHdr),                                                         // [ESP]
    sizeof(CIpHdr) + sizeof(CEspHdr),                                       // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CEspHdr) + sizeof(CUdpHdr),                     // Size

    // [ENET]^[IP][TCP][Payload]

    0,                                                                      // [ESP]
    sizeof(CIpHdr),                                                         // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CTcpHdr),                                       // Size

    // [ENET]^[IP][ESP][TCP][Payload][ESPT]

    sizeof(CIpHdr),                                                         // [ESP]
    sizeof(CIpHdr) + sizeof(CEspHdr),                                       // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CEspHdr) + sizeof(CTcpHdr),                     // Size
    
    // [ENET]^[Payload]
    0,                                                                      // [ESP]
    0,                                                                      // [UDP]/[TCP]
    0                                                                       // Size

};

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

void CPacketQueue::InsertHead(CPacket * ppkt)
{
    if ((ppkt->_ppktNext = _ppktHead) == NULL)
        _ppktTail = ppkt;
    _ppktHead = ppkt;
}

void CPacketQueue::InsertTail(CPacket * ppkt)
{
    if (_ppktTail)
        _ppktTail->_ppktNext = ppkt;
    else
        _ppktHead = ppkt;

    _ppktTail = ppkt;
    ppkt->_ppktNext = NULL;
}

void CPacketQueue::InsertHead(CPacketQueue * ppq)
{
    Assert(!ppq->IsEmpty());
    if (_ppktTail == NULL)
        _ppktTail = ppq->_ppktTail;
    ppq->_ppktTail->_ppktNext = _ppktHead;
    _ppktHead = ppq->_ppktHead;
    ppq->Init();
}

CPacket * CPacketQueue::RemoveHead()
{
    Assert(!IsEmpty());

    CPacket * ppkt = _ppktHead;

    if ((_ppktHead = ppkt->_ppktNext) == NULL)
        _ppktTail = NULL;
    else
        ppkt->_ppktNext = NULL;

    return(ppkt);
}

void CPacketQueue::Complete(CXnBase * pXnBase)
{
    while (!IsEmpty())
    {
        RemoveHead()->Complete(pXnBase);
    }
}

void CPacketQueue::Discard(CXnBase * pXnBase)
{
    while (!IsEmpty())
    {
        pXnBase->PacketFree(RemoveHead());
    }
}

void CPacketQueue::Dequeue(CPacket * ppktDequeue)
{
    CPacket **  pppkt    = &_ppktHead;
    CPacket *   ppktPrev = NULL;
    CPacket *   ppkt;

    for (; (ppkt = *pppkt) != NULL; ppktPrev = ppkt, pppkt = &ppkt->_ppktNext)
    {
        if (ppkt == ppktDequeue)
        {
            *pppkt = ppkt->_ppktNext;

            if (_ppktHead == NULL)
                _ppktTail = NULL;
            else if (_ppktTail == ppkt)
                _ppktTail = ppktPrev;
            return;
        }
    }

    AssertSz1(0, "CPacketQueue::Dequeue(%08lX) - Packet not found in queue", ppktDequeue);
}

UINT CPacketQueue::Count()
{
    CPacket * ppkt;
    UINT c;

    for (c = 0, ppkt = _ppktHead; ppkt; ppkt = ppkt->_ppktNext)
    {
        c += 1;
    }

    return(c);
}

// ---------------------------------------------------------------------------------------
// CIpAddr
// ---------------------------------------------------------------------------------------

CIpAddr CIpAddr::DefaultMask() const
{
    if (IsClassA()) return(IPADDR_CLASSA_NETMASK);
    if (IsClassB()) return(IPADDR_CLASSB_NETMASK);
    if (IsClassC()) return(IPADDR_CLASSC_NETMASK);
    if (IsClassD()) return(IPADDR_CLASSD_NETMASK);

    TraceSz1(Warning, "CIpAddr:DefaultMask(): Invalid host IP address: %s", Str());

    return(0);
}

BOOL CIpAddr::IsValidUnicast() const
{
    return(_dw != 0 && !IsSecure() && !IsBroadcast() && !IsMulticast() && !IsLoopback());
}

BOOL CIpAddr::IsValidAddr() const
{
    return(     ((BYTE)(_ab[0] - 1)) <  254     // 1 ... 254
            &&  _ab[1]               <= 254     // 0 ... 254
            &&  _ab[2]               <= 254     // 0 ... 254
            &&  ((BYTE)(_ab[3] - 1)) <  254);   // 1 ... 254
}

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * CIpAddr::Str() const
{
    #define IPADDR_STR_BUFFS    32
    #define IPADDR_BUF_SIZE     16
    static char g_chBufIpAddr[IPADDR_STR_BUFFS * IPADDR_BUF_SIZE];
    static LONG g_lBufIndexIpAddr = 0;
    char * pch = &g_chBufIpAddr[(InterlockedIncrement(&g_lBufIndexIpAddr) % IPADDR_STR_BUFFS) * IPADDR_BUF_SIZE];
    XnInAddrToString(*(IN_ADDR *)&_dw, pch, IPADDR_BUF_SIZE);
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// HexStr
// ---------------------------------------------------------------------------------------

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * HexStr(const void * pv, size_t cb)
{
    #define HEXSTR_BUFFS        8
    #define HEXSTR_CBMAX        128
    #define HEXSTR_BUF_SIZE     (HEXSTR_CBMAX * 2 + 1)
    static char g_chHexBuf[HEXSTR_BUFFS * HEXSTR_BUF_SIZE];
    static LONG g_lHexBufIndex = 0;
    char * pch = &g_chHexBuf[(InterlockedIncrement(&g_lHexBufIndex) % HEXSTR_BUFFS) * HEXSTR_BUF_SIZE];
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui;

    if (cb > HEXSTR_CBMAX)
        cb = HEXSTR_CBMAX;

    for (; cb > 0; --cb, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
    }

    *pchDst = 0;

    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// XnInAddrToString
// ---------------------------------------------------------------------------------------

void XnInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf)
{
    char    ach[16];
    BYTE *  pbSrc = (BYTE *)&ina;
    BYTE *  pbEnd = pbSrc + 4;
    char *  pbDst = (cchBuf < sizeof(ach)) ? ach : pchBuf;
    UINT    b;

    while (pbSrc < pbEnd)
    {
        b = *pbSrc++;

        if (b >= 10)
        {
            if (b >= 100) { *pbDst++ = '0' + (b / 100); b %= 100; }
            *pbDst++ = '0' + (b / 10); b %= 10;
        }

        *pbDst++ = '0' + b;
        *pbDst++ = '.';
    }

    pbDst[-1] = 0;

    if (cchBuf < sizeof(ach) && cchBuf > 0)
    {
        memcpy(pchBuf, ach, cchBuf);
        pchBuf[cchBuf - 1] = 0;
    }
}

// ---------------------------------------------------------------------------------------
// XnAddrStr
// ---------------------------------------------------------------------------------------

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * XnAddrStr(const XNADDR * pxnaddr)
{
    #define XNADDR_STR_BUFFS    4
    #define XNADDR_BUF_SIZE     128
    static char g_chXnAddrBuf[XNADDR_STR_BUFFS * XNADDR_BUF_SIZE];
    static LONG g_lXnAddrBufIndex = 0;
    char * pch = &g_chXnAddrBuf[(InterlockedIncrement(&g_lXnAddrBufIndex) % XNADDR_STR_BUFFS) * XNADDR_BUF_SIZE];

    memset(pch, 0, XNADDR_BUF_SIZE);

    _snprintf(pch, XNADDR_BUF_SIZE - strlen(pch) - 2, "{ %s ", ((CEnetAddr *)pxnaddr->abEnet)->Str());

    if (pxnaddr->ina.s_addr != 0)
    {
        _snprintf(&pch[strlen(pch)], XNADDR_BUF_SIZE - strlen(pch) - 2, "%s ",
                  CIpAddr(pxnaddr->ina.s_addr).Str());

        if (pxnaddr->inaOnline.s_addr != 0)
        {
            _snprintf(&pch[strlen(pch)], XNADDR_BUF_SIZE - strlen(pch) - 2, "NAT %s:%d SG %s ",
                      CIpAddr(pxnaddr->inaOnline.s_addr).Str(), NTOHS(pxnaddr->wPortOnline),
                      HexStr(pxnaddr->abOnline, sizeof(pxnaddr->abOnline)));
        }
    }

    _snprintf(&pch[strlen(pch)], XNADDR_BUF_SIZE - strlen(pch) - 2, "}");

    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CEnetAddr
// ---------------------------------------------------------------------------------------

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * CEnetAddr::Str() const
{
    #define ENETADDR_STR_BUFFS    32
    #define ENETADDR_BUF_SIZE     18
    static char g_chBuf[ENETADDR_STR_BUFFS * ENETADDR_BUF_SIZE];
    static LONG g_lBufIndex = 0;
    char * pch = &g_chBuf[(InterlockedIncrement(&g_lBufIndex) % ENETADDR_STR_BUFFS) * ENETADDR_BUF_SIZE];
    _snprintf(pch, ENETADDR_BUF_SIZE, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnBase (Timer)
// ---------------------------------------------------------------------------------------

void CXnBase::TimerSet(CTimer * pt, DWORD dwTick)
{
    ICHECK(BASE, UDPC|SDPC);

    Assert(sizeof(PFNTIMER) == sizeof(void *));
    AssertSz(dwTick >= _dwTick, "Attempt to set timer in the past");

    TraceSz2(Timer, "TimerSet %08lX dwTick=%08lX", pt, dwTick);

    if (pt->_le.Flink != NULL)
    {
        TraceSz1(Timer, "TimerDequeue %08lX", pt);
        AssertListEntry(&_leTimers, &pt->_le);
        RemoveEntryList(&pt->_le);
        pt->_le.Flink = NULL;
    }

    AssertList(&_leTimers);

    pt->_dwTick = dwTick;

    if (dwTick < 0xFFFFFFFF)
    {
        if (IsListEmpty(&_leTimers) || dwTick <= ((CTimer *)_leTimers.Flink)->_dwTick)
        {
            TraceSz1(Timer, "TimerEnqueue %08lX (Head)", pt);
            InsertHeadList(&_leTimers, &pt->_le)
        }
        else
        {
            CTimer * ptPrev = (CTimer *)_leTimers.Blink;

            while (dwTick < ptPrev->_dwTick)
            {
                ptPrev = (CTimer *)ptPrev->_le.Blink;
                Assert(ptPrev != (CTimer *)&_leTimers);
            }

            pt->_le.Flink = ptPrev->_le.Flink;
            pt->_le.Blink = &ptPrev->_le;
            ptPrev->_le.Flink->Blink = &pt->_le;
            ptPrev->_le.Flink = &pt->_le;

            TraceSz2(Timer, "TimerEnqueue %08lX (after %08lX)", pt, ptPrev);
        }

        AssertListEntry(&_leTimers, &pt->_le);
    }
}

DWORD CXnBase::TimerSetRelative(CTimer * pt, DWORD dwTicksFromNow)
{
    ICHECK(BASE, UDPC|SDPC);

    DWORD dwTick = _dwTick + dwTicksFromNow;

    if (dwTick < pt->_dwTick)
    {
        TimerSet(pt, dwTick);
    }

    return(dwTick);
}

void CXnBase::TimerDpc(PKDPC pkdpc, void * pvContext, void * pvParam1, void * pvParam2)
{
    ((CXnBase *)pvContext)->TimerPush();
}

void CXnBase::TimerPush()
{
    ICHECK(BASE, SDPC);

    _dwTickKe = KeQueryTickCount();
    DWORD dwTick = ++_dwTick;

    while (1)
    {
        AssertList(&_leTimers);

        CTimer * pt = (CTimer *)_leTimers.Flink;

        if (pt == (CTimer *)&_leTimers)
            break;

        if (dwTick < pt->_dwTick)
            break;

        TraceSz2(Timer, "TimerPush %08lX dwTick=%08lX", pt, dwTick);

        RemoveEntryList(&pt->_le);

        pt->_le.Flink = NULL;
        pt->_dwTick = TIMER_INFINITE;

        (this->*(pt->_pfn))(pt);
    }

    SecRegProbe();

    NicTimer();
}

// ---------------------------------------------------------------------------------------
// CXnBase
// ---------------------------------------------------------------------------------------

NTSTATUS CXnBase::BaseInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = HalInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_BASE);

    memcpy(&cfgSizeOfStruct, &s_XNetParamsDef.cfgSizeOfStruct, sizeof(XNetParams));

    if (pxnip->pxnp != NULL)
    {
        if (    pxnip->pxnp->cfgSizeOfStruct != sizeof(XNetStartupParams)
            &&  pxnip->pxnp->cfgSizeOfStruct != sizeof(XNetParams))
        {
            TraceSz(Warning, "Ignoring parameters because cfgSizeOfStruct is invalid");
        }
        else
        {
            BYTE * pbDef = (BYTE *)&s_XNetParamsDef.cfgSizeOfStruct;
            BYTE * pbMin = (BYTE *)&s_XNetParamsMin.cfgSizeOfStruct;
            BYTE * pbMax = (BYTE *)&s_XNetParamsMax.cfgSizeOfStruct;
            BYTE * pbSrc = (BYTE *)&pxnip->pxnp->cfgSizeOfStruct;
            BYTE * pbDst = (BYTE *)&cfgSizeOfStruct;
            int    c     = pxnip->pxnp->cfgSizeOfStruct;

            for (; --c >= 0; ++pbDef, ++pbMin, ++pbMax, ++pbSrc, ++pbDst)
            {
                if (*pbSrc == 0)
                    *pbDst = *pbDef;
                else if (*pbSrc < *pbMin)
                    *pbDst = *pbMin;
                else if (*pbSrc > *pbMax)
                    *pbDst = *pbMax;
                else
                    *pbDst = *pbSrc;
            }
        }
    }

#ifdef XNET_FEATURE_XBDM_SERVER
    cfgFlags |= XNET_STARTUP_BYPASS_SECURITY;
#endif

    RandInit(pxnip);

    InitializeListHead(&_leTimers);
    KeInitializeDpc(&_dpcTimer, TimerDpc, this);
    KeInitializeTimer(&_timerTimer);

    // Start the current timer tick at one day to allow timer routines to compute times
    // in the past and not have to worry about going negative.

    _dwTick = 24 * 60 * 60 * TICKS_PER_SECOND;
    _dwTickKe = KeQueryTickCount();

#ifdef XNET_FEATURE_ASSERT
    _leakinfo._pfnLeakTag = XnLeakTagToString;
#endif

    SetInitFlag(INITF_BASE_1);

    UINT        cbPool = cfgPrivatePoolSizeInPages * 4096;
    PoolEntry * ppe;
    UINT        n;

    ppe = (PoolEntry *)SysAlloc(cbPool, PTAG_Pool);

    if (ppe == NULL)
    {
        return(NETERR_MEMORY);
    }

    _pvPoolStart = ppe;
    _pvPoolEnd   = ((BYTE *)ppe + cbPool);

    SetInitFlag(INITF_BASE_2);

    // Initialize the free lists with a single big block

    for (n = 0; n <= MAX_SMALL_BLOCKS; n++)
    {
        InitializeListHead(&_aleFree[n]);
    }

    // NOTE: we reserved the very first and the very last
    // pool blocks. This saves us from a couple of extra checks
    // during alloc and free.

    MarkPoolEntryBusy(ppe);
    TagPoolEntry(ppe, PTAG_PoolStart);
    ppe->bOver = (1 << POOL_BLOCK_SHIFT);
    ppe->previousSize = 0;
    ppe->blockSize = 1;

    ppe = GetPoolEntryNext(ppe);
    n = (cbPool >> POOL_BLOCK_SHIFT) - 2;
    MarkPoolEntryFree(ppe);
    TagPoolEntry(ppe, 0);
    ppe->previousSize = 1;
    ppe->blockSize = (WORD)n;
    InsertFreePoolEntry(ppe);

    ppe = GetPoolEntryNext(ppe);
    MarkPoolEntryBusy(ppe);
    TagPoolEntry(ppe, PTAG_PoolEnd);
    ppe->bOver = (1 << POOL_BLOCK_SHIFT);
    ppe->previousSize = (WORD)n;
    ppe->blockSize = 1;

    return(NETERR_OK);
}

void CXnBase::BaseStart()
{
    ICHECK(BASE, USER);

    HalStart();

    Assert(!TestInitFlag(INITF_BASE_STOP));

    LARGE_INTEGER liDue;
    liDue.QuadPart = -10000000 / TICKS_PER_SECOND;
    KeSetTimerEx(&_timerTimer, liDue, 1000 / TICKS_PER_SECOND, &_dpcTimer);
}

void CXnBase::BaseStop()
{
    TCHECK(UDPC|SDPC);

    if (!TestInitFlag(INITF_BASE_STOP))
    {
        if (TestInitFlag(INITF_BASE_1))
        {
            KeCancelTimer(&_timerTimer);
            KeRemoveQueueDpc(&_dpcTimer);
        }

        SetInitFlag(INITF_BASE_STOP);
    }

    HalStop();
}

void CXnBase::BaseTerm()
{
    TCHECK(UDPC);

    BaseStop();

    Assert(IsListEmpty(&_leTimers));

    if (TestInitFlag(INITF_BASE_2))
    {
        SysFree(_pvPoolStart);
        _pvPoolStart = NULL;
        _pvPoolEnd = NULL;
    }

#ifdef XNET_FEATURE_ASSERT
    if (_leakinfo._cLeak > 0)
    {
        LeakTerm(&_leakinfo);
    }
#endif

    SetInitFlag(INITF_BASE_TERM);

    HalTerm();
}

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

char * __cdecl DbgAssertFmt(char const * pszFmt, ...)
{
    #define ASSERT_ENTRY_SIZE   512
    #define ASSERT_ENTRY_COUNT  8
    static char s_achAssert[ASSERT_ENTRY_SIZE * ASSERT_ENTRY_COUNT];
    static LONG s_lAssert = 0;
    char * pchBuf = &s_achAssert[(InterlockedIncrement(&s_lAssert) % ASSERT_ENTRY_COUNT) * ASSERT_ENTRY_SIZE];
    pchBuf[0] = 0;
    va_list va;
    va_start(va, pszFmt);
    _vsnprintf(pchBuf, ASSERT_ENTRY_SIZE - 1, pszFmt, va);
    va_end(va);
    pchBuf[ASSERT_ENTRY_SIZE - 1] = 0;
    return(pchBuf);
}

#endif

// ---------------------------------------------------------------------------------------
// Trace
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

void __cdecl DbgTrace(const char * pszTag, const char * pszFmt, ...)
{
    char ach[256];
    char * pchBuf = ach;
    int cchBuf = sizeof(ach);
    char * psz = (char *)pszFmt;
    va_list va;

    memset(ach, 0, sizeof(ach));

    if (*psz == '+')
        ++psz;
    else 
    {
        if (*psz == '\n')
        {
            *pchBuf++ = *psz++;
            cchBuf -= 1;
        }
#ifdef XNET_FEATURE_XBOX
        _snprintf(pchBuf, cchBuf - 2, "[" XNET_TRACE_PREFIX "] %s: ", pszTag);
#else
        _snprintf(pchBuf, cchBuf - 3, "[" XNET_TRACE_PREFIX ".%03X] %s: ", GetCurrentThreadId(), pszTag);
#endif
    }

    va_start(va, pszFmt);
    int cch = strlen(pchBuf);
    _vsnprintf(&pchBuf[cch], cchBuf - cch - 2, psz, va);
    va_end(va);

    cch = strlen(pchBuf);

    if (cch > 0 && *pszFmt && pszFmt[strlen(pszFmt) - 1] == '+')
        pchBuf[cch - 1] = 0;
    else
        strcpy(pchBuf + cch, "\n");

#ifdef XNET_FEATURE_XBDM_SERVER
    DbgPrintToKd(ach);
#else
    DbgPrint("%s", ach);
#endif
}

#endif

// ---------------------------------------------------------------------------------------
// DbgVerifyList
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

const char * DbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire)
{
    LIST_ENTRY * plePrev;
    LIST_ENTRY * pleThis;
    BOOL fFound = FALSE;
    UINT cEnt = 0;

    if (ple->Flink == NULL || ple->Blink == NULL)
        return("List Flink is NULL");
    else if (ple->Blink == NULL)
        return("List Blink is NULL");

    if (ple->Flink == ple || ple->Blink == ple)
    {
        if (ple->Flink != ple->Blink)
        {
            return("List head corrupt");
        }

        return((!pleRequire) ? NULL : "Required entry not found");
    }

    plePrev = ple;
    pleThis = ple->Flink;

    while (1)
    {
        if (pleThis == NULL)
        {
            return("List entry has an Flink that points to NULL");
        }

        if (plePrev != pleThis->Blink)
        {
            return("List entry has a Blink that doesn't point to previous entry");
            return(FALSE);
        }

        if (pleThis == ple)
            break;

        if (pleThis == pleRequire)
        {
            if (fFound)
            {
                return("List has required entry twice.  Cycle detected.");
            }

            fFound = TRUE;
        }

        plePrev = pleThis;
        pleThis = plePrev->Flink;

        if (++cEnt > 100000)
        {
            return("List has cycle");
        }
    }

    return((!pleRequire || fFound) ? NULL : "Required entry not found");
}

// ---------------------------------------------------------------------------------------
// DataToString
// ---------------------------------------------------------------------------------------

#if defined(XNET_FEATURE_TRACE)  || defined(XNET_FEATURE_ASSERT)

char * DataToString(BYTE * pb, UINT cb)
{
    #define DTS_ENTRY_SIZE   32
    #define DTS_ENTRY_COUNT  8
    static char s_achDts[DTS_ENTRY_SIZE * DTS_ENTRY_COUNT];
    static LONG s_lDts = 0;
    char * pbBuf = &s_achDts[(InterlockedIncrement(&s_lDts) % DTS_ENTRY_COUNT) * DTS_ENTRY_SIZE];
    char * pbDst = pbBuf;

    if (cb > DTS_ENTRY_SIZE - 1)
        cb = DTS_ENTRY_SIZE - 1;

    for (; cb > 0; ++pbDst, ++pb, --cb)
    {
        if (*pb >= 31 && *pb < 127)
            *pbDst = *pb;
        else
            *pbDst = '.';
    }

    *pbDst = 0;

    return(pbBuf);
}

#endif

// ---------------------------------------------------------------------------------------
// Push/Pop Recv Tags
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

void CXnBase::PushPktRecvTags(BOOL fBroadcast)
{
    ICHECK(BASE, UDPC|SDPC);

    Assert(_cbPushPop < sizeof(_abPushPop));

    _abPushPop[_cbPushPop++] = !!fBroadcast;

    if (fBroadcast && ++_cPushPopBroadcast == 1)
    {
        _pktRecvPushPop = Tag(pktRecv);
        _pktWarnPushPop = Tag(pktWarn);
        Tag(pktRecv)    = Tag(pktBroadcast);
        Tag(pktWarn)    = Tag(pktBroadcast);
    }
}

void CXnBase::PopPktRecvTags()
{
    ICHECK(BASE, UDPC|SDPC);

    Assert(_cbPushPop > 0);

    if (_abPushPop[--_cbPushPop])
    {
        Assert(_cPushPopBroadcast > 0);

        if (--_cPushPopBroadcast == 0)
        {
            Tag(pktRecv) = _pktRecvPushPop;
            Tag(pktWarn) = _pktWarnPushPop;
        }
    }
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\halw.cpp ===
// ---------------------------------------------------------------------------------------
// halw.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_WINDOWS

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <rsa.h>
#include <rc4.h>
#include <sha.h>
#include <modes.h>
#include <des.h>
#include <tripldes.h>
#include <benaloh.h>
#include <shahmac.h>
#include <cryptkeys.h>

// ---------------------------------------------------------------------------------------
// Hal Dpc Support
// ---------------------------------------------------------------------------------------

struct CHalDpc
{
    LONG                _lInitLock;             // Spin lock to synchronize VLanInit/VLanTerm
    UINT                _cRefs;                 // Number of times HalDpcInit called
    HANDLE              _hEvent;                // Handle to signalling event for dispatch thread
    HANDLE              _hThread;               // Thread handle for dispatch thread
    BOOL                _fShutdown;             // TRUE to shutdown the dispatch thread
    DWORD               _dwThreadId;            // Thread Id of dispatch thread
    DWORD               _dwDpcThreadId;         // Thread Id of thread currently at dispatch level
    INT                 _iThreadPriority;       // Old thread priority of thread at dispatch level
    LIST_ENTRY          _dpcq;                  // Queued KDPCs
    LIST_ENTRY          _timerq;                // Queued KTIMERs
    CRITICAL_SECTION    _cs;                    // Synchronization
};

CHalDpc                 g_HalDpc;

DWORD WINAPI HalDpcThreadProc(void *)
{
    PKDPC       pkdpc;
    PKTIMER     pktimer;
    DWORD       dwNow;
    DWORD       dwWait;
    LONG        lWait;

    while (1)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (g_HalDpc._fShutdown)
            break;

        Assert(g_HalDpc._dwThreadId == GetCurrentThreadId());
        Assert(g_HalDpc._dwDpcThreadId == 0);
        g_HalDpc._dwDpcThreadId = g_HalDpc._dwThreadId;
        Assert(g_HalDpc._dwDpcThreadId != 0);

        while (!IsListEmpty(&g_HalDpc._dpcq))
        {
            pkdpc = (PKDPC)RemoveHeadList(&g_HalDpc._dpcq);
            pkdpc->DpcListEntry.Flink = NULL;
            pkdpc->DeferredRoutine(pkdpc,
                                   pkdpc->DeferredContext,
                                   pkdpc->SystemArgument1,
                                   pkdpc->SystemArgument2);
        }

        dwWait = INFINITE;

        if (!IsListEmpty(&g_HalDpc._timerq))
        {
            while (1)
            {
                dwNow   = GetTickCount();
                dwWait  = INFINITE;
                pktimer = (PKTIMER)g_HalDpc._timerq.Flink;
                pkdpc   = NULL;

                while (pktimer != (PKTIMER)&g_HalDpc._timerq)
                {
                    lWait = (LONG)(pktimer->DueTime - dwNow);

                    if (lWait <= 0)
                    {
                        pktimer->DueTime = dwNow + pktimer->Period;
                        pkdpc = pktimer->Dpc;
                        break;
                    }

                    if (dwWait > (DWORD)lWait)
                        dwWait = (DWORD)lWait;

                    pktimer = (PKTIMER)pktimer->TimerListEntry.Flink;
                }

                if (pkdpc == NULL)
                    break;

                pkdpc->DeferredRoutine(pkdpc,
                                       pkdpc->DeferredContext,
                                       pkdpc->SystemArgument1,
                                       pkdpc->SystemArgument2);
            }
        }

        Assert(g_HalDpc._dwThreadId == GetCurrentThreadId());
        Assert(g_HalDpc._dwDpcThreadId == g_HalDpc._dwThreadId);
        g_HalDpc._dwDpcThreadId = 0;
        LeaveCriticalSection(&g_HalDpc._cs);
        WaitForSingleObject(g_HalDpc._hEvent, dwWait);
    }

    return(0);
}

void HalDpcCleanup()
{
    BOOL fResult = FALSE;

    if (g_HalDpc._hThread)
    {
        Assert(g_HalDpc._dwDpcThreadId == GetCurrentThreadId());
        g_HalDpc._fShutdown = TRUE;
        LeaveCriticalSection(&g_HalDpc._cs);
        SetEvent(g_HalDpc._hEvent);
        WaitForSingleObject(g_HalDpc._hThread, INFINITE);
        CloseHandle(g_HalDpc._hThread);
    }

    if (g_HalDpc._hEvent)
    {
        CloseHandle(g_HalDpc._hEvent);
    }

    DeleteCriticalSection(&g_HalDpc._cs);

    memset(&g_HalDpc, 0, sizeof(g_HalDpc));
}

BOOL HalDpcInit()
{
    BOOL fResult = FALSE;

    while (InterlockedCompareExchange(&g_HalDpc._lInitLock, 1, 0))
    {
        Sleep(10);
    }

    if (g_HalDpc._cRefs == 0)
    {
        InitializeCriticalSection(&g_HalDpc._cs);
        InitializeListHead(&g_HalDpc._dpcq);
        InitializeListHead(&g_HalDpc._timerq);

        g_HalDpc._hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (g_HalDpc._hEvent == NULL)
        {
            TraceSz1(Warning, "HalDpcInit - CreateEvent failed (%d)", GetLastError());
            goto ret;
        }

        g_HalDpc._hThread = CreateThread(NULL, 0, HalDpcThreadProc, NULL, 0, &g_HalDpc._dwThreadId);

        if (g_HalDpc._hThread == NULL)
        {
            TraceSz1(Warning, "HalDpcInit - CreateThread failed (%d)", GetLastError());
            goto ret;
        }

        // Increase the priority of the DPC thread so that is preempts any user thread, 
        // and also preempts the VLan thread (which runs at THREAD_PRIORITY_ABOVE_NORMAL).

        SetThreadPriority(g_HalDpc._hThread, THREAD_PRIORITY_HIGHEST);
    }

    g_HalDpc._cRefs += 1;
    fResult = TRUE;

ret:

    if (!fResult)
    {
        HalDpcCleanup();
    }

    g_HalDpc._lInitLock = 0;

    return(fResult);
}

BOOL HalDpcTerm()
{
    BOOL fResult = FALSE;

    while (InterlockedCompareExchange(&g_HalDpc._lInitLock, 1, 0))
    {
        Sleep(10);
    }

    Assert(g_HalDpc._cRefs > 0);

    if (--g_HalDpc._cRefs == 0)
    {
        HalDpcCleanup();
        fResult = TRUE;
    }

    g_HalDpc._lInitLock = 0;

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

NTSTATUS CXnHal::HalInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    if (!HalDpcInit())
    {
        return(NETERR_MEMORY);
    }

    strncpy(_achXbox, pxnip->pszXbox ? pxnip->pszXbox : "xb1@Lan", sizeof(_achXbox) - 1);

    SetInitFlag(INITF_HAL);

    return(NETERR_OK);
}

void CXnHal::HalTerm()
{
    TCHECK(UDPC);

    SetInitFlag(INITF_HAL_TERM);

    if (TestInitFlag(INITF_HAL))
    {
        if (HalDpcTerm())
        {
            SetInitFlag(INITF_HAL_STOP);
        }
    }
}

KIRQL CXnHal::KeGetCurrentIrql()
{
    ICHECK(HAL, USER|UDPC|SDPC);

    DWORD dwThreadId = GetCurrentThreadId();

    if (dwThreadId == g_HalDpc._dwDpcThreadId)
        return(DISPATCH_LEVEL);
    else
    {
        Assert(dwThreadId != g_HalDpc._dwThreadId);
        return(PASSIVE_LEVEL);
    }
}

KIRQL CXnHal::KeRaiseIrqlToDpcLevel()
{
    ICHECK(HAL, USER|UDPC|SDPC);

    DWORD dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&g_HalDpc._cs);

    Assert(dwThreadId != g_HalDpc._dwThreadId || dwThreadId == g_HalDpc._dwDpcThreadId);

    if (dwThreadId == g_HalDpc._dwDpcThreadId)
    {
        LeaveCriticalSection(&g_HalDpc._cs);
        Assert(DISPATCH_LEVEL != PASSIVE_LEVEL);
        return(DISPATCH_LEVEL);
    }

    g_HalDpc._dwDpcThreadId = dwThreadId;
    Assert(g_HalDpc._dwDpcThreadId != 0);
    Assert(dwThreadId != g_HalDpc._dwThreadId);

    if (dwThreadId != g_HalDpc._dwThreadId)
    {
        g_HalDpc._iThreadPriority = GetThreadPriority(GetCurrentThread());
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
    }

    return(PASSIVE_LEVEL);
}

void CXnHal::KeLowerIrql(KIRQL kirql)
{
    TCHECK(USER|UDPC|SDPC);

    if (TestInitFlag(INITF_HAL_STOP))
    {
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    }
    else if (kirql == PASSIVE_LEVEL)
    {
        DWORD dwThreadId = GetCurrentThreadId();
        Assert(dwThreadId != g_HalDpc._dwThreadId);
        Assert(dwThreadId == g_HalDpc._dwDpcThreadId);
        g_HalDpc._dwDpcThreadId = 0;

        if (dwThreadId != g_HalDpc._dwThreadId)
        {
            SetThreadPriority(GetCurrentThread(), g_HalDpc._iThreadPriority);
        }

        LeaveCriticalSection(&g_HalDpc._cs);
    }
}

void CXnHal::KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    Dpc->DeferredRoutine    = DeferredRoutine;
    Dpc->DeferredContext    = DeferredContext;
    Dpc->DpcListEntry.Flink = NULL;
}

BOOLEAN CXnHal::KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    if (Dpc->DpcListEntry.Flink == NULL)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (Dpc->DpcListEntry.Flink == NULL)
        {
            Dpc->SystemArgument1 = SystemArgument1;
            Dpc->SystemArgument2 = SystemArgument2;
            AssertList(&g_HalDpc._dpcq);
            InsertTailList(&g_HalDpc._dpcq, &Dpc->DpcListEntry);
        }

        LeaveCriticalSection(&g_HalDpc._cs);

        SetEvent(g_HalDpc._hEvent);
    }

    return(TRUE);
}

BOOLEAN CXnHal::KeRemoveQueueDpc(PRKDPC Dpc)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    if (Dpc->DpcListEntry.Flink != NULL)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (Dpc->DpcListEntry.Flink != NULL)
        {
            AssertListEntry(&g_HalDpc._dpcq, &Dpc->DpcListEntry);
            RemoveEntryList(&Dpc->DpcListEntry);
            Dpc->DpcListEntry.Flink = NULL;
        }

        LeaveCriticalSection(&g_HalDpc._cs);
    }

    return(TRUE);
}

void CXnHal::KeInitializeTimer(PKTIMER Timer)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    Timer->TimerListEntry.Flink = NULL;
}

BOOLEAN CXnHal::KeSetTimerEx(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    EnterCriticalSection(&g_HalDpc._cs);

    if (Timer->TimerListEntry.Flink == NULL)
    {
        AssertList(&g_HalDpc._timerq);
        Timer->DueTime = GetTickCount() + (DWORD)(DueTime.QuadPart / -10000);
        Timer->Period  = Period;
        Timer->Dpc     = Dpc;
        InsertTailList(&g_HalDpc._timerq, &Timer->TimerListEntry);
    }

    LeaveCriticalSection(&g_HalDpc._cs);

    SetEvent(g_HalDpc._hEvent);

    return(TRUE);
}

BOOLEAN CXnHal::KeCancelTimer(PKTIMER Timer)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    if (Timer->TimerListEntry.Flink != NULL)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (Timer->TimerListEntry.Flink != NULL)
        {
            AssertListEntry(&g_HalDpc._timerq, &Timer->TimerListEntry);
            RemoveEntryList(&Timer->TimerListEntry);
            Timer->TimerListEntry.Flink = NULL;
        }

        LeaveCriticalSection(&g_HalDpc._cs);
    }

    return(TRUE);
}

CRaiseToDpc::CRaiseToDpc(CXnHal * pXnHal)
{
    _pXnHal = pXnHal;
    _irql = pXnHal->KeRaiseIrqlToDpcLevel();
    Assert(_irql == PASSIVE_LEVEL || _irql == DISPATCH_LEVEL);
    Assert(GetCurrentThreadId() != g_HalDpc._dwThreadId || _irql == DISPATCH_LEVEL);
}

CRaiseToDpc::~CRaiseToDpc()
{
    Assert(GetCurrentThreadId() != g_HalDpc._dwThreadId || _irql == DISPATCH_LEVEL);
    Assert(_irql == PASSIVE_LEVEL || _irql == DISPATCH_LEVEL);
    _pXnHal->KeLowerIrql((KIRQL)_irql);
}

#ifdef XNET_FEATURE_ASSERT

BOOL CXnHal::HalThreadCheck(UINT uiCheck)
{
    DWORD dwThreadId = GetCurrentThreadId();

    if (dwThreadId != g_HalDpc._dwDpcThreadId)
        return(uiCheck & USER);
    else if (dwThreadId == g_HalDpc._dwThreadId)
        return(uiCheck & SDPC);
    else
        return(uiCheck & UDPC);
}

#endif

void CXnHal::HalEnterDpc()
{
    EnterCriticalSection(&g_HalDpc._cs);
}

BOOL CXnHal::HalTryEnterDpc()
{
    return(TryEnterCriticalSection(&g_HalDpc._cs));
}

void CXnHal::HalLeaveDpc()
{
    LeaveCriticalSection(&g_HalDpc._cs);
}

// ---------------------------------------------------------------------------------------
// CXnHal::SetInitFlag
// ---------------------------------------------------------------------------------------

void CXnHal::SetInitFlag(DWORD dwFlag)
{
    DWORD dwFlagsOld, dwFlagsNew;

    while (1)
    {
        dwFlagsOld = _dwInitFlags;

        Assert((dwFlagsOld & dwFlag) == 0);

        dwFlagsNew = dwFlagsOld | dwFlag;

        if (InterlockedCompareExchange((LONG *)&_dwInitFlags, (LONG)dwFlagsNew, (LONG)dwFlagsOld) == (LONG)dwFlagsOld)
            break;

        TraceSz(Warning, "CXnHal::SetInitFlag: Thread/DPC contention.  Retrying.");
    }
}

// ---------------------------------------------------------------------------------------
// Hal System Memory
// ---------------------------------------------------------------------------------------

DefineTag(VMem, 0);
DefineTag(VMemFront, 0);

DWORD g_dwVMem = 0;

BOOL VMemIsEnabled()
{
#ifdef XNET_FEATURE_VMEM
    if (g_dwVMem == 0)
    {
        char * pszVMem = getenv("VMEM");

        g_dwVMem = VMEM_CHECKED;

        if (pszVMem)
        {
            g_dwVMem |= VMEM_ENABLED;

            if (lstrcmpiA(pszVMem, "frontside") != 0)
            {
                g_dwVMem |= VMEM_BACKSIDESTRICT;
            }
        }
        else if (Tag(VMem))
        {
            g_dwVMem |= VMEM_ENABLED;

            if (!Tag(VMemFront))
                g_dwVMem |= VMEM_BACKSIDESTRICT;

        }

        if (g_dwVMem & VMEM_ENABLED)
        {
            TraceSz1(VMem, "Enabled for %s byte faults", (g_dwVMem & VMEM_BACKSIDESTRICT) ? "next" : "prev");
        }
    }

    return(g_dwVMem & VMEM_ENABLED);
#else
    return(FALSE);
#endif
}

void * HalAlloc(size_t cb, ULONG tag)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        return(VMemAlloc(cb));
    }
#endif

    return(LocalAlloc(LMEM_FIXED, cb));
}

void * HalAllocZ(size_t cb, ULONG tag)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        void * pv = VMemAlloc(cb);

        if (pv)
        {
            memset(pv, 0, cb);
        }

        return(pv);
    }
#endif

    return(LocalAlloc(LPTR, cb));
}

void HalFree(void * pv)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        VMemFree(pv);
        return;
    }
#endif

    if (pv)
    {
        LocalFree(pv);
    }
}

// ---------------------------------------------------------------------------------------
// Hal Randomness
// ---------------------------------------------------------------------------------------

UINT CXnHal::HalRandGather(BYTE * pb, UINT cb)
{
    memset(pb, 0xAA, cb);
    QueryPerformanceCounter((LARGE_INTEGER *)pb);
    GetSystemTimeAsFileTime((FILETIME *)(pb + sizeof(LARGE_INTEGER)));
    return(cb);
}

// ---------------------------------------------------------------------------------------
// Hal Crypto
// ---------------------------------------------------------------------------------------

void
XcSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    A_SHAInit((A_SHA_CTX*)pbSHAContext);
}
   
void
XcSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    A_SHAUpdate((A_SHA_CTX*)pbSHAContext, pbInput, dwInputLength);
}
   
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    A_SHAFinal((A_SHA_CTX*)pbSHAContext, pbDigest);
}
   
void
XcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}
   
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

// compute A = B ^ C mod D, N = len of params in DWORDs
ULONG
XcModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    //
    // compute A = B ^ C mod D
    //
    return BenalohModExp(pA, pB, pC, pD, dwN);
}
   
void
XcDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    desparityonkey(pbKey, dwKeyLength);
}
   
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    if (dwCipher == XC_SERVICE_DES_CIPHER)
    {
        deskey((DESTable*)pbKeyTable, pbKey);
    }
    else
    {
        // Assume XC_SERVICE_DES3_CIPHER:
        tripledes3key((PDES3TABLE)pbKeyTable, pbKey);
    }
}
   
void
XcBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    (*pCipher)( pbOutput, pbInput, pbKeyTable, dwOp );
}
   
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    BYTE *pbInputEnd = pbInput + dwInputLength;
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    while (pbInput < pbInputEnd)
    {
        CBC(pCipher, XC_SERVICE_DES_BLOCKLEN, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
        pbInput += XC_SERVICE_DES_BLOCKLEN;
        pbOutput += XC_SERVICE_DES_BLOCKLEN;
    }
}

DWORD
XcCalcKeyLen(
    IN  PBYTE  pbPublicKey
    )
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;

    return pPubKey->keylen;
}

//
// Reverse ASN.1 Encodings of possible hash identifiers.  
//
static char * shaEncodings[] = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" };

BOOL XcVerifyPKCS1SigningFmt(
    IN  BSAFE_PUB_KEY* pKey,
    IN  BYTE* pbDigest,
    IN  BYTE* pbPKCS1Format
    )
{
    BYTE**    rgEncOptions;
    BYTE      rgbTmpHash[A_SHA_DIGEST_LEN + 16];
    DWORD     i;
    DWORD     cb;
    BYTE*     pbStart;
    DWORD     cbTmp;

    rgEncOptions = (BYTE **)shaEncodings;

    // 
    // reverse the hash to match the signature.
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        rgbTmpHash[i] = pbDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    // 
    // see if it matches.
    //
    if (memcmp(rgbTmpHash, pbPKCS1Format, A_SHA_DIGEST_LEN)) {
        return FALSE;
    }

    cb = A_SHA_DIGEST_LEN;

    //
    // check for any signature type identifiers
    //
    for (i = 0; 0 != *rgEncOptions[i]; i += 1) {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp)) {
            // adjust the end of the hash data. 
            cb += cbTmp;   
            break;
        }
    }

    // 
    // check to make sure the rest of the PKCS #1 padding is correct
    //
    if ((0x00 != pbPKCS1Format[cb]) || (0x00 != pbPKCS1Format[pKey->datalen]) ||
         (0x1 != pbPKCS1Format[pKey->datalen - 1])) {
        return FALSE;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++) {
        if (0xff != pbPKCS1Format[i]) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
XcVerifyDigest(
    IN   PBYTE   pbSig,
    IN   PBYTE   pbPublicKey,
    IN   PBYTE   pbWorkspace,
    IN   PBYTE   pbCompareDigest
    )
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;
    PBYTE           pbOutput;
    PBYTE           pbInput;
    DWORD           dwSigLen;

    dwSigLen = (pPubKey->bitlen + 7) / 8;

    pbOutput = pbWorkspace;
    pbInput = (PBYTE)((ULONG_PTR)pbWorkspace + pPubKey->keylen);

    memset(pbInput, 0, pPubKey->keylen);
    memcpy(pbInput, pbSig, dwSigLen);

    if (!BSafeEncPublic(pPubKey, pbInput, pbOutput)) {
        return FALSE;
    }


    if (!XcVerifyPKCS1SigningFmt(pPubKey, pbCompareDigest, pbOutput)) {
        return FALSE;
    }

    return TRUE;
}

ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return XcCalcKeyLen(pbPubKey);
}

BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    BYTE* pbWorkspace = (BYTE *)_alloca( 2 * XcCalcKeyLen(pbPubKey) );
    if ( pbWorkspace == NULL )
    {
        return FALSE;
    }
    return XcVerifyDigest(pbSig, pbPubKey, pbWorkspace, pbDigest);
}
   
VOID WINAPI XShaHmacInitialize(
            IN PBYTE                pbKey,
            IN DWORD                cbKey,
            IN OUT XSHAHMAC_CONTEXT Shactx
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKipad[HMAC_K_PADSIZE];
    ULONG        dwBlock;

    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKipad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKipad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
    }

    // Initialize our SHA1 Hmac context
    XcSHAInit(Shactx);

    // Run our Kipad through this ...
    XcSHAUpdate(Shactx, rgbKipad, HMAC_K_PADSIZE);
}

//
// Function to update the Hmac
//
VOID WINAPI XShaHmacUpdate(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbData,
            IN DWORD            cbData
            )
{
    XcSHAUpdate(Shactx, pbData, cbData);
}
            
//
// Function to calculate the final Hmac
//
VOID WINAPI XShaHmacComputeFinal(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbKey,
            IN DWORD            cbKey,
            OUT PBYTE           pbHmac
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKopad[HMAC_K_PADSIZE + A_SHA_DIGEST_LEN];
    ULONG        dwBlock;

    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKopad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKopad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    // Finish off the hash, and place the result right
    // after the Kopad data
    XcSHAFinal(Shactx, rgbKopad + HMAC_K_PADSIZE);

    // Do another hash, now with the Kopad data
    XcSHAInit(Shactx);
    XcSHAUpdate(Shactx, rgbKopad, sizeof(rgbKopad));
    XcSHAFinal(Shactx, pbHmac);
}            

// ---------------------------------------------------------------------------------------
// VMem
//
// VMem allocates memory using the operating system's low-level virtual allocator. It
// arranges for an allocation to start at the very beginning of a page, with a non-
// accessable page just before it, or for it to end at the very end of a page, with a
// non-accessible page just after it.  The idea is to catch memory overwrites quickly.
//
// The layout of an allocation is as follows:
//
//  +--- page VMEMINFO structure
//  |
//  |                 +--- pv if using front-side-strict memory allocations
//  |                 |
//  |                 |                   +--- filled with pattern to detect back-side overwrite
//  v                 v                   v
// +--------+--------+--------+--------+--------+--------+
// |VMEMINFO|   NO   |[User's memory area]XXXXXX|   NO   |
// |        | ACCESS |XXXXXX[User's memory area]| ACCESS |
// +--------+--------+--------+--------+--------+--------+
//                    ^     ^
//                    |     +--- pv if using back-side-strict memory allocations
//                    |
//                    +--- filled with pattern to detect front-side overwrite
//
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VMEM

#define PAGE_SIZE       4096

DWORD
VMemQueryProtect(void * pv, DWORD cb)
{
    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQuery(pv, &mbi, sizeof(mbi));
    return (mbi.Protect ? mbi.Protect : mbi.AllocationProtect);
}

VMEMINFO *
VMemIsValid(void * pv)
{
    VMEMINFO * pvmi;
    BYTE * pb;
    UINT cb;

    if (pv == NULL)
    {
        return NULL;
    }

    pvmi = (VMEMINFO *)(((DWORD_PTR)pv & ~(PAGE_SIZE - 1)) - PAGE_SIZE * 2);

    if (VMemQueryProtect(pvmi, PAGE_SIZE) != PAGE_READONLY)
    {
        Rip("VMemIsValid - VMEMINFO page is not marked READONLY");
        return NULL;
    }

    if (pv != pvmi->pv)
    {
        Rip("VMemIsValid - VMEMINFO doesn't point back to pv");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE, PAGE_SIZE) != PAGE_NOACCESS)
    {
        Rip("VMemIsValid - can't detect first no-access page");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2, pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2) != PAGE_READWRITE)
    {
        Rip("VMemIsValid - user memory block is not all writable");
        return NULL;
    }

    if (pvmi->cbFill1)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2;
        cb = pvmi->cbFill1;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x1A)
            {
                Rip("VMemIsValid - detected user memory pre-data overwrite");
                return NULL;
            }
        }
    }

    if (pvmi->cbFill2)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb;
        cb = pvmi->cbFill2;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x3A)
            {
                Rip("VMemIsValid - detected user memory post-data overwrite");
                return NULL;
            }
        }
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2, PAGE_SIZE) != PAGE_NOACCESS)
    {
        Rip("VMemIsValid - can't detect second no-access page");
        return NULL;
    }

    return(pvmi);
}

void *
VMemAlloc(size_t cb)
{
    DWORD dwFlags = g_dwVMem;
    void * pv1, * pv2, * pv3;
    size_t cbUser, cbPage;
    DWORD dwOldProtect;
    VMEMINFO * pvmi;

    if (cb == 0)
    {
        cb = 1;
    }

    if (    (dwFlags & VMEM_BACKSIDESTRICT)
        &&  (dwFlags & VMEM_BACKSIDEALIGN8))
        cbUser = (cb + 7) & ~7;
    else
        cbUser = cb;

    cbPage = (cbUser + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

	pv1 = VirtualAlloc(0, cbPage + PAGE_SIZE * 3, MEM_RESERVE, PAGE_NOACCESS);

    if (pv1 == NULL)
    {
        return(NULL);
    }

	pv2 = VirtualAlloc(pv1, PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

    if (pv2 == NULL)
    {
        return(NULL);
    }

    pvmi          = (VMEMINFO *)pv2;
    pvmi->cb      = cb;
    pvmi->dwFlags = dwFlags;

    pv3 = VirtualAlloc((BYTE *)pv1 + PAGE_SIZE * 2, cbPage, MEM_COMMIT, PAGE_READWRITE);

    if (pv3 == NULL)
    {
        return(NULL);
    }

    if (dwFlags & VMEM_BACKSIDESTRICT)
    {
        pvmi->cbFill1 = cbPage - cbUser;
        pvmi->cbFill2 = cbUser - cb;
    }
    else
    {
        pvmi->cbFill1 = 0;
        pvmi->cbFill2 = cbPage - cbUser;
    }

    Assert(pvmi->cbFill1 + cb + pvmi->cbFill2 == cbPage);

    if (pvmi->cbFill1)
    {
        memset((BYTE *)pv3, 0x1A, pvmi->cbFill1);
    }

    memset((BYTE *)pv3 + pvmi->cbFill1, 0x2A, cb);

    if (pvmi->cbFill2)
    {
        memset((BYTE *)pv3 + pvmi->cbFill1 + cb, 0x3A, pvmi->cbFill2);
    }

    pvmi->pv = (BYTE *)pv3 + pvmi->cbFill1;

    VirtualProtect(pv1, PAGE_SIZE, PAGE_READONLY, &dwOldProtect);

    Assert(VMemIsValid(pvmi->pv));

    return(pvmi->pv);
}

void
VMemFree(void * pv)
{
    VMEMINFO * pvmi = VMemIsValid(pv);

    if (pvmi)
    {
        if (!VirtualFree(pvmi, 0, MEM_RELEASE))
        {
            Rip("VmemFree - VirtualFree failed");
        }
    }
}

#endif // XNET_FEATURE_VMEM

// ---------------------------------------------------------------------------------------
// Assert support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

struct MBOT { char * psz; int id; };

DWORD WINAPI DbgAssertPopOnThreadFn(MBOT * pmbot)
{
    pmbot->id = MessageBoxExA(NULL, pmbot->psz, "Assert",
                              MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_OKCANCEL|MB_ICONWARNING|MB_DEFBUTTON2,
                              0);
    return(0);
}

int DbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg)
{
    char ach[256];

    if (pszMsg)
        _snprintf(ach, sizeof(ach), "%s\n%s\n%s (%d)", pszExpr, pszMsg, pszFile, iLine);
    else
        _snprintf(ach, sizeof(ach), "%s\n%s (%d)", pszExpr, pszFile, iLine);

    MBOT  mbot = { ach, 0 };
    DWORD dwThread;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DbgAssertPopOnThreadFn,
                                  &mbot, 0, &dwThread);
    if (!hThread)
        DbgAssertPopOnThreadFn(&mbot);
    else
    {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }

    return(mbot.id == IDCANCEL);
}

#endif

// ---------------------------------------------------------------------------------------
// Trace support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

CTagInit::CTagInit(int * pi, const char * pszTag)
{
    int i = GetPrivateProfileIntA("tags", pszTag, -1, "\\xnettags.ini");

    if (i != -1)
    {
        *pi = i;
    }
}

#endif

// ---------------------------------------------------------------------------------------
// XBox File System Abstraction Layer
// ---------------------------------------------------------------------------------------

BOOL HalCreateDirectory(const char * pszDir, BOOL fHidden, BOOL * pfAlreadyExists)
{
    WIN32_FIND_DATA fd;
    HANDLE          hFind = FindFirstFile(pszDir, &fd);

    *pfAlreadyExists = FALSE;

    if (hFind == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            TraceSz2(Warning, "HalCreateDirectory: FindFirstFile '%s' failed (%08lX)", pszDir, GetLastError());
            return(FALSE);
        }

        if (!CreateDirectory(pszDir, NULL))
        {
            TraceSz2(Warning, "HalCreateDirectory: CreateDirectory '%s' failed (%08lX)", pszDir, GetLastError());
            return(FALSE);
        }

        if (fHidden && !SetFileAttributes(pszDir, FILE_ATTRIBUTE_HIDDEN))
        {
            TraceSz2(Warning, "HalCreateDirectory: SetFileAttributes '%s' failed (%08lX)", pszDir, GetLastError());
            return(FALSE);
        }
    }
    else
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            TraceSz1(Warning, "HalCreateDirectory: Cannot create directory '%s' because file exists there", pszDir);
            return(FALSE);
        }

        FindClose(hFind);

        *pfAlreadyExists = TRUE;
    }

    return(TRUE);
}

BOOL HalGetPath(const char * pszXbox, const char * pszPathIn, char * pszPathOut)
{
    char achXbox[MAX_PATH];
    char achRoot[MAX_PATH];
    char achTemp[MAX_PATH];
    char * pch;
    BOOL fAlreadyExists;

    strncpy(achXbox, pszXbox, sizeof(achXbox));
    for (pch = achXbox; *pch && *pch != '@'; ++pch) ;
    *pch = 0;

    // Make sure directory c:\$xbox exists

    strcpy(achRoot, "c:\\$xbox");
    HalCreateDirectory(achRoot, TRUE, &fAlreadyExists);

    // Make sure directory c:\$xbox\<pszXbox> exists

    strcat(achRoot, "\\");
    strcat(achRoot, achXbox);
    HalCreateDirectory(achRoot, FALSE, &fAlreadyExists);

    if (!fAlreadyExists)
    {
        char achDir[MAX_PATH];

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1\\TDATA");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1\\CACHE");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1\\devkit");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition2");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);
    }

    // Handle special "eeprom" path

    if (lstrcmpiA(pszPathIn, "eeprom") == 0)
    {
        sprintf(pszPathOut, "%s\\eeprom.bin", achRoot);
        return(TRUE);
    }

    // Handle special "volume" path

    if (lstrcmpiA(pszPathIn, "\\Device\\Harddisk0\\partition0") == 0)
    {
        sprintf(pszPathOut, "%s\\config.bin", achRoot);

        // Make sure this file exists and has room for all the config sectors

        HANDLE hFile = CreateFile(pszPathOut, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            TraceSz2(Warning, "HalGetPath: CreateFile '%s' failed (%08lX)", pszPathOut, GetLastError());
            return(FALSE);
        }

        DWORD dwSize   = GetFileSize(hFile, NULL);
        DWORD dwExpect = (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS) * XBOX_HD_SECTOR_SIZE;

        if (dwSize != dwExpect)
        {
            if (dwSize != 0)
            {
                TraceSz3(Warning, "HalGetPath: '%s' has incorrect size (%d bytes); should be %d bytes.  Repairing.",
                         pszPathOut, dwSize, dwExpect);
            }

            BYTE ab[(XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS) * XBOX_HD_SECTOR_SIZE];
            memset(ab, 0, sizeof(ab));

            if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
            {
                TraceSz2(Warning, "HalGetPath: SetFilePointer '%s' failed (%08lX)", pszPathOut, GetLastError());
                CloseHandle(hFile);
                return(FALSE);
            }

            if (!WriteFile(hFile, ab, sizeof(ab), &dwExpect, NULL))
            {
                TraceSz2(Warning, "HalGetPath: WriteFile '%s' failed (%08lX)", pszPathOut, GetLastError());
                CloseHandle(hFile);
                return(FALSE);
            }

            Assert(dwExpect == sizeof(ab));
        }

        CloseHandle(hFile);
        return(TRUE);
    }

    // Handle Harddisk0 paths

    if (_strnicmp(pszPathIn, "\\Device\\Harddisk0\\", 18) == 0)
    {
        sprintf(pszPathOut, "%s\\%s", achRoot, pszPathIn + 18);
        return(TRUE);
    }

    TraceSz1(Warning, "HalGetPath: Don't understand path '%s'", pszPathIn);
    return(FALSE);
}

HANDLE HalCreateFile(char * pszXbox, LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    char        achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, lpFileName, achPath))
    {
        TraceSz2(Warning, "HalCreateFile: HalGetPath('%s','%s') failed", pszXbox, lpFileName);
        return(INVALID_HANDLE_VALUE);
    }
    
    return(CreateFile(achPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
                      dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile));
}

NTSTATUS HalNtOpenFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
                       POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
                       ULONG ShareAccess, ULONG OpenOptions)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    char        achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, (char *)ObjectAttributes->ObjectName->Buffer, achPath))
    {
        TraceSz2(Warning, "HalNtOpenFile: HalGetPath('%s','%s') failed",
                 pszXbox, (char *)ObjectAttributes->ObjectName->Buffer);
        *FileHandle = INVALID_HANDLE_VALUE;
    }
    else
    {
        *FileHandle = CreateFile(achPath, DesiredAccess & (GENERIC_READ|GENERIC_WRITE),
                                 ShareAccess & (FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE),
                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (*FileHandle != INVALID_HANDLE_VALUE)
    {
        status = STATUS_SUCCESS;
    }

    return(status);
}

NTSTATUS HalNtCreateFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
                         POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
                         PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
                         ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    char        achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, (char *)ObjectAttributes->ObjectName->Buffer, achPath))
    {
        TraceSz2(Warning, "HalNtCreateFile: HalGetPath('%s','%s') failed",
                 pszXbox, (char *)ObjectAttributes->ObjectName->Buffer);
        *FileHandle = INVALID_HANDLE_VALUE;
    }
    else
    {
        DWORD dwDisposition = CREATE_ALWAYS;

        switch (CreateDisposition)
        {
            case FILE_SUPERSEDE:    dwDisposition = TRUNCATE_EXISTING;  break;
            case FILE_OPEN:         dwDisposition = OPEN_ALWAYS;        break;
            case FILE_CREATE:       dwDisposition = CREATE_NEW;         break;
            case FILE_OPEN_IF:      dwDisposition = CREATE_ALWAYS;      break;
            case FILE_OVERWRITE:    dwDisposition = CREATE_ALWAYS;      break;
            case FILE_OVERWRITE_IF: dwDisposition = TRUNCATE_EXISTING;  break;
        }

        *FileHandle = CreateFile(achPath, DesiredAccess & (GENERIC_READ|GENERIC_WRITE),
                                 ShareAccess & (FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE),
                                 NULL, dwDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (*FileHandle != INVALID_HANDLE_VALUE)
    {
        status = STATUS_SUCCESS;
    }

    return(status);
}

NTSTATUS HalNtReadFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
                       PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
                       PLARGE_INTEGER ByteOffset)
{
    if (SetFilePointer(FileHandle, ByteOffset->LowPart, &ByteOffset->HighPart, FILE_BEGIN) == 0xFFFFFFFF)
    {
        TraceSz1(Warning, "HalNtReadFile: SetFilePointer failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    DWORD dwRead;

    if (!ReadFile(FileHandle, Buffer, Length, &dwRead, NULL))
    {
        TraceSz1(Warning, "HalNtReadFile: ReadFile failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    if (dwRead != Length)
    {
        TraceSz2(Warning, "HalNtReadFile: ReadFile returned only %d bytes (%d requested)", dwRead, Length);
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS HalNtWriteFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
                        PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer,
                        ULONG Length, PLARGE_INTEGER ByteOffset)
{
    if (SetFilePointer(FileHandle, ByteOffset->LowPart, &ByteOffset->HighPart, FILE_BEGIN) == 0xFFFFFFFF)
    {
        TraceSz1(Warning, "HalNtWriteFile: SetFilePointer failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    DWORD dwWrite;

    if (!WriteFile(FileHandle, Buffer, Length, &dwWrite, NULL))
    {
        TraceSz1(Warning, "HalNtWriteFile: WriteFile failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    if (dwWrite != Length)
    {
        TraceSz2(Warning, "HalNtWriteFile: WriteFile wrote only %d bytes (%d requested)", dwWrite, Length);
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS HalNtClose(char * pszXbox, HANDLE Handle)
{
    if (Handle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(Handle);
    }

    return(STATUS_SUCCESS);
}

// ---------------------------------------------------------------------------------------
// EEPROM
// ---------------------------------------------------------------------------------------

BOOL HalSaveEEPROM(char * pszXbox, EEPROM_LAYOUT * peeprom)
{
    HANDLE  hFile   = INVALID_HANDLE_VALUE;
    BOOL    fResult = FALSE;
    DWORD   dwSize;
    char    achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, "eeprom", achPath))
    {
        TraceSz1(Warning, "HalSaveEEPROM: HalGetPath('%s','eeprom') failed", pszXbox);
        goto ret;
    }

    hFile = CreateFile(achPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,  NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TraceSz2(Warning, "HalSaveEEPROM: CreateFile '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    if (!WriteFile(hFile, peeprom, sizeof(EEPROM_LAYOUT), &dwSize, NULL))
    {
        TraceSz2(Warning, "HalSaveEEPROM: WriteFile '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    fResult = TRUE;

ret:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return(fResult);
}

BOOL HalLoadEEPROM(char * pszXbox, EEPROM_LAYOUT * peeprom)
{
    HANDLE  hFile   = INVALID_HANDLE_VALUE;
    BOOL    fResult = FALSE;
    DWORD   dwSize;
    char    achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, "eeprom", achPath))
    {
        TraceSz1(Warning, "HalLoadEEPROM: HalGetPath('%s','eeprom') failed", pszXbox);
        goto ret;
    }

    hFile = CreateFile(achPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,  NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TraceSz2(Warning, "HalLoadEEPROM: CreateFile '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        TraceSz2(Warning, "HalLoadEEPROM: SetFilePointer '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    dwSize = GetFileSize(hFile, NULL);

    if (dwSize == sizeof(EEPROM_LAYOUT))
    {
        if (!ReadFile(hFile, peeprom, sizeof(EEPROM_LAYOUT), &dwSize, NULL))
        {
            TraceSz2(Warning, "HalLoadEEPROM: ReadFile '%s' failed (%08lX)", achPath, GetLastError());
            goto ret;
        }
    }
    else
    {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        if (dwSize != 0)
        {
            TraceSz3(Warning, "HalLoadEEPROM: '%s' is incorrect size (%d bytes); should be %d bytes.  Repairing.",
                     achPath, dwSize, sizeof(EEPROM_LAYOUT));
        }

        memset(peeprom, 0, sizeof(EEPROM_LAYOUT));

        XBOX_ENCRYPTED_SETTINGS *   pes = (XBOX_ENCRYPTED_SETTINGS *)&peeprom->EncryptedSection;
        XBOX_FACTORY_SETTINGS *     pfs = (XBOX_FACTORY_SETTINGS *)&peeprom->FactorySection;

        memset(pfs->SerialNumber, '9', sizeof(pfs->SerialNumber));

        Assert(sizeof(pfs->OnlineKey) == DEVKIT_ONLINE_RAND_KEY_LEN);
        memcpy(pfs->OnlineKey, DEVKIT_ONLINE_RAND_KEY, sizeof(pfs->OnlineKey));

        BYTE abHdKey[16] = { 0 };

        MorphKeyByHardDriveKeyEx(abHdKey, pfs->OnlineKey, sizeof(pfs->OnlineKey));

        HalSaveEEPROM(pszXbox, peeprom);
    }

    fResult = TRUE;

ret:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return(fResult);
}

NTSTATUS HalExQueryNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength)
{
    EEPROM_LAYOUT   eeprom;
    NTSTATUS        status = STATUS_UNSUCCESSFUL;

    *Type = 0;
    *ResultLength = 0;

    if (HalLoadEEPROM(pszXbox, &eeprom))
    {
        XBOX_FACTORY_SETTINGS * pfs = (XBOX_FACTORY_SETTINGS *)&eeprom.FactorySection;

        switch (ValueIndex)
        {
            case XC_FACTORY_ETHERNET_ADDR:
            {
                if (ValueLength == sizeof(pfs->EthernetAddr))
                {
                    memcpy(Value, pfs->EthernetAddr, ValueLength);
                    *Type = REG_BINARY;
                    *ResultLength = ValueLength;
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_SERIAL_NUMBER:
            {
                if (ValueLength == sizeof(pfs->SerialNumber))
                {
                    memcpy(Value, pfs->SerialNumber, ValueLength);
                    *Type = REG_BINARY;
                    *ResultLength = ValueLength;
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_ONLINE_KEY:
            {
                if (ValueLength == sizeof(pfs->OnlineKey))
                {
                    memcpy(Value, pfs->OnlineKey, ValueLength);
                    *Type = REG_BINARY;
                    *ResultLength = ValueLength;
                    status = STATUS_SUCCESS;
                }
                break;
            }
        }

        AssertSz1(status == STATUS_SUCCESS, "HalExQueryNonVolatileSetting: Unrecognized ValueIndex (%d)", ValueIndex);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS HalExSaveNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength)
{
    EEPROM_LAYOUT   eeprom;
    NTSTATUS        status = STATUS_UNSUCCESSFUL;

    if (HalLoadEEPROM(pszXbox, &eeprom))
    {
        XBOX_FACTORY_SETTINGS * pfs = (XBOX_FACTORY_SETTINGS *)&eeprom.FactorySection;

        switch (ValueIndex)
        {
            case XC_FACTORY_ETHERNET_ADDR:
            {
                if (Type == REG_BINARY && ValueLength == sizeof(pfs->EthernetAddr))
                {
                    memcpy(pfs->EthernetAddr, Value, ValueLength);
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_SERIAL_NUMBER:
            {
                if (Type == REG_BINARY && ValueLength == sizeof(pfs->SerialNumber))
                {
                    memcpy(pfs->SerialNumber, Value, ValueLength);
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_ONLINE_KEY:
            {
                if (Type == REG_BINARY && ValueLength == sizeof(pfs->OnlineKey))
                {
                    memcpy(pfs->OnlineKey, Value, ValueLength);
                    status = STATUS_SUCCESS;
                }
                break;
            }
        }

        AssertSz2(status == STATUS_SUCCESS, "HalExSaveNonVolatileSetting: Unrecognized ValueIndex (%d) Type (%d)", ValueIndex, Type);
    }

    if (status == STATUS_SUCCESS && !HalSaveEEPROM(pszXbox, &eeprom))
    {
        status = STATUS_UNSUCCESSFUL;
    }

    return(status);
}

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\halx.h ===
// ---------------------------------------------------------------------------------------
// halx.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _HALX_H_
#define _HALX_H_

#ifdef XNET_FEATURE_XBDM_SERVER
#include <dm.h>
#endif

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

class CXnHal : public CXnVoid
{
    // Definitions -----------------------------------------------------------------------

    #define EvtInit(prke)               KeInitializeEvent(prke, NotificationEvent, FALSE)
    #define EvtTerm(prke)
    #define EvtSet(prke, pri)           KeSetEvent((prke), (pri), FALSE)
    #define EvtClear(prke)              KeClearEvent(prke)
    #define EvtRef(ke)                  &(ke)
    #define EvtDereference(prke)        ObDereferenceObject(prke)

#ifdef XNET_FEATURE_ASSERT
    #define USER                        0x0001
    #define UDPC                        0x0002
    #define SDPC                        0x0004
    #define TCHECK_(pXnBase, lev)       AssertSz((pXnBase)->HalThreadCheck(lev), "Not allowed to execute this code at the current level")
#else
    #define TCHECK_(pXnBase, lev)
#endif
    #define TCHECK(lev)                 TCHECK_(this, lev)

#ifdef XNET_FEATURE_ASSERT
    #define ICHECK_(pXnBase, lay, lev)  AssertSz((pXnBase)->TestInitFlag(INITF_##lay), "The " #lay " layer is not initialized"); \
                                        AssertSz(!(pXnBase)->TestInitFlag(INITF_##lay##_TERM), "The " #lay " layer has been terminated."); \
                                        TCHECK_(pXnBase, lev)
#else
    #define ICHECK_(pXnBase, lay, lev)
#endif
    #define ICHECK(lay, lev)            ICHECK_(this, lay, lev)

    #define HAL_DECLARE_NEW_DELETE(class) \
       INLINE void * operator new(size_t cb) { return(HalAllocZ(cb, PTAG_##class)); } \
       INLINE void operator delete(void * pv) { HalFree(pv); } \
       INLINE class() {} \
       INLINE ~class() {}

    // External --------------------------------------------------------------------------

public:

    INLINE PRKEVENT EvtFromHandle(HANDLE hEvent)
    {
        PRKEVENT kEvent;
        return(hEvent && ObReferenceObjectByHandle(hEvent, ExEventObjectType, (VOID**)&kEvent) == STATUS_SUCCESS ? kEvent : NULL);
    }

    INLINE BOOL EvtWait(PRKEVENT prke, UINT timeout)
    {
        LARGE_INTEGER waittime;
        waittime.QuadPart = Int32x32To64(timeout, -10000);
        return(KeWaitForSingleObject(prke, UserRequest, UserMode, FALSE, timeout ? &waittime : NULL) == STATUS_SUCCESS);
    }

#ifdef XNET_FEATURE_ASSERT
    BOOL                HalThreadCheck(UINT uiLevel);
    KIRQL               KeRaiseIrqlToDpcLevel();
    void                KeLowerIrql(KIRQL kirql);
#endif

    void                SetInitFlag(DWORD dwFlag);
    INLINE BOOL         TestInitFlag(DWORD dwFlag)      { return(!!(_dwInitFlags & dwFlag)); }

    UINT                HalRandGather(BYTE * pb, UINT cb);
    void                HalRandPersist(BYTE * pb, UINT cb);

protected:

    NTSTATUS            HalInit(XNetInitParams * pxnip) { return(NETERR_OK); }
    INLINE void         HalStart()  {};
    void                HalStop()   {};
    void                HalTerm()   {};

    // Data ------------------------------------------------------------------------------

    DWORD                       _dwInitFlags;

#ifdef XNET_FEATURE_ASSERT
    BOOL                        _fUserDpc;              // TRUE when user raised IRQL to DPC
#endif

};

// ---------------------------------------------------------------------------------------
// HAL System Memory
// ---------------------------------------------------------------------------------------

INLINE void * HalAlloc(size_t size, ULONG tag)
{
    return(ExAllocatePoolWithTag(size, tag));
}

INLINE void * HalAllocZ(size_t size, ULONG tag)
{
    void * pv = HalAlloc(size, tag);

    if (pv)
    {
        memset(pv, 0, size);
    }

    return(pv);
}

INLINE void HalFree(void * pv)
{
    if (pv)
    {
        ExFreePool(pv);
    }
}

// ---------------------------------------------------------------------------------------
// HAL Dma Memory
// ---------------------------------------------------------------------------------------

INLINE void * HalDmaAlloc(UINT cb, ULONG ulMax = MAXULONG_PTR)
{
    return(MmAllocateContiguousMemoryEx(cb, 0, ulMax, 0, PAGE_READWRITE));
}

INLINE void HalDmaFree(void * pv)
{
    MmFreeContiguousMemory(pv);
}

// ---------------------------------------------------------------------------------------
// CRaiseToDpc
// ---------------------------------------------------------------------------------------

class CRaiseToDpc
{

public:

    INLINE CRaiseToDpc(CXnHal * pXnHal)
    {
#ifdef XNET_FEATURE_ASSERT
        _pXnHal = pXnHal;
        _irql = pXnHal->KeRaiseIrqlToDpcLevel();
#else
        _irql = KeRaiseIrqlToDpcLevel();
#endif
    }

    INLINE ~CRaiseToDpc()
    {
#ifdef XNET_FEATURE_ASSERT
        _pXnHal->KeLowerIrql(_irql);
#else
        KeLowerIrql(_irql);
#endif
    }

private:

#ifdef XNET_FEATURE_ASSERT
    CXnHal * _pXnHal;
#endif
    KIRQL    _irql;
};

#define RaiseToDpc()  CRaiseToDpc __RaiseToDpc__(this)

// ---------------------------------------------------------------------------------------
// Miscellaneous
// ---------------------------------------------------------------------------------------

void DbgPrintToKd(const char * psz);
void HalQueryTsc(LARGE_INTEGER * pli);

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\ip.cpp ===
// ---------------------------------------------------------------------------------------
// ip.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(secStat, 0);
DefineTag(tcpRetrans, 0);
DefineTag(pktPreAuth, 0);
DefineTag(keyExDrop, 0);

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define ESPUDP_REPLAY_WINDOW        1024                // How far ahead sender can get

// ---------------------------------------------------------------------------------------
// CXnIp External
// ---------------------------------------------------------------------------------------

NTSTATUS CXnIp::IpInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = EnetInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_IP);

    status = RouteInit();
    if (!NT_SUCCESS(status))
        return(status);

    status = DhcpInit();
    if (!NT_SUCCESS(status))
        return(status);

    _pKeyReg = (CKeyReg *)SysAllocZ(cfgKeyRegMax * sizeof(CKeyReg), PTAG_CKeyReg);

    if (_pKeyReg == NULL)
    {
        TraceSz(Warning, "IpInit - Out of memory allocating CKeyReg vector");
        return(WSAENOBUFS);
    }

    _pSecReg = (CSecReg *)SysAllocZ(cfgSecRegMax * sizeof(CSecReg), PTAG_CSecReg);

    if (_pSecReg == NULL)
    {
        TraceSz(Warning, "IpInit - Out of memory allocating CSecReg vector");
        return(WSAENOBUFS);
    }

#if defined(XNET_FEATURE_XBOX) && !defined(XNET_FEATURE_XBDM_SERVER)

    // Generate the SHA and 3DES keys for LAN broadcast.  We do this by concatenating two digests:
    //
    //      HMAC(HMAC(ROM-LAN-KEY, CERT-LAN-KEY), 0 | CERT-LAN-KEY) |
    //      HMAC(HMAC(ROM-LAN-KEY, CERT-LAN-KEY), 1 | CERT-LAN-KEY)
    //
    // This produces 40 bytes of digest.  The first 16 bytes are used as a SHA key, and the
    // remaining 24 bytes as the 3DES key.

    BYTE    abCert[1 + XBEIMAGE_CERTIFICATE_KEY_LENGTH];
    BYTE    abHash[XC_SERVICE_DIGEST_SIZE * 2];

    memcpy(&abCert[1], XeImageHeader()->Certificate->LANKey, XBEIMAGE_CERTIFICATE_KEY_LENGTH);

    abCert[0] = 0;
    XcHMAC((BYTE *)*XboxLANKey, XBOX_KEY_LENGTH, abCert, sizeof(abCert), NULL, 0, &abHash[0]);
    abCert[0] = 1;
    XcHMAC((BYTE *)*XboxLANKey, XBOX_KEY_LENGTH, abCert, sizeof(abCert), NULL, 0, &abHash[XC_SERVICE_DIGEST_SIZE]);

    Assert(sizeof(abHash) == sizeof(_abKeyShaLan) + sizeof(_abKeyDesLan));
    memcpy(_abKeyShaLan, &abHash[0], sizeof(_abKeyShaLan));
    memcpy(_abKeyDesLan, &abHash[sizeof(_abKeyShaLan)], sizeof(_abKeyDesLan));
    XcDESKeyParity(_abKeyDesLan, sizeof(_abKeyDesLan));

#endif

    Rand((BYTE *)&_lNextDgramId, sizeof(_lNextDgramId));
    Rand((BYTE *)&_wSecRegUniq, sizeof(_wSecRegUniq));
    KeQuerySystemTime(&_liTime);

    _cSecRegProbeDenom = cfgSecRegVisitInSeconds * TICKS_PER_SECOND;

#if defined(XNET_FEATURE_SG) && defined(XNET_FEATURE_INSECURE)
    Rand(_abDhXNull, sizeof(_abDhXNull));
    XcModExp((DWORD *)_abDhGXNull, (DWORD *)g_abOakleyGroup1Base,
             (DWORD *)_abDhXNull, (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));
#endif

    return(NETERR_OK);
}

void CXnIp::IpStop()
{
    TCHECK(UDPC);

    if (TestInitFlag(INITF_IP) && !TestInitFlag(INITF_IP_STOP))
    {
        SecRegShutdown(FALSE);
        NicFlush();
        SetInitFlag(INITF_IP_STOP);
    }

    EnetStop();
}

void CXnIp::IpTerm()
{
    TCHECK(UDPC);

    IpStop();

    if (TestInitFlag(INITF_IP))
    {
        DhcpTerm();
        RouteTerm();
        FragTerm();

        if (_pKeyReg)
        {
            CKeyReg * pKeyReg = &_pKeyReg[_cKeyReg - 1];
            UINT      cKeyReg = _cKeyReg;

            for (; cKeyReg > 0; --pKeyReg, --cKeyReg)
            {
                TraceSz1(Warning, "IpTerm - XNKID %s was not unregistered before shutdown",
                         HexStr(pKeyReg->_xnkid.ab, sizeof(pKeyReg->_xnkid.ab)));
                IpUnregisterKey(&pKeyReg->_xnkid);
            }

            SysFree(_pKeyReg);
        }

        if (_pSecReg)
        {
            CSecReg * pSecReg = _pSecReg;
            UINT      cSecReg = cfgSecRegMax;

            for (; cSecReg > 0; ++pSecReg, --cSecReg)
            {
                if (pSecReg->_dwSpiRecv)
                {
                    SecRegFree(pSecReg);
                }
            }

            SysFree(_pSecReg);
        }
    }

    SetInitFlag(INITF_IP_TERM);

    EnetTerm();
}

// ---------------------------------------------------------------------------------------
// IpConfig
// ---------------------------------------------------------------------------------------

INT CXnIp::IpConfig(const XNetConfigParams * pxncp, DWORD dwFlags)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    INT err = NicConfig(pxncp);

#ifdef XNET_FEATURE_DHCP
    if (err == 0)
    {
        err = DhcpConfig(pxncp);
    }
#endif

    return(err);
}

INT CXnIp::IpGetConfigStatus(XNetConfigStatus * pxncs)
{
    ICHECK(IP, USER);
    TraceSz(Warning, "IpGetConfigStatus not yet implemented");
    memset(pxncs, 0, sizeof(XNetConfigStatus));
    pxncs->dwFlags = XNET_STATUS_PENDING;
    return(0);
}

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

void CXnIp::IpSetAddress(CIpAddr ipa, CIpAddr ipaMask)
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();

    if (ipa == 0)
    {
        ipaMask = 0;
    }
    else if (!ipa.IsValidUnicast())
    {
        TraceSz4(Warning, "IpSetAddress - Cannot set IP address to %s (reason %d/%d/%d)",
                 ipa.Str, ipa.IsBroadcast(), ipa.IsMulticast(), ipa.IsLoopback());
        ipa = 0;
        ipaMask = 0;
    }
    else if (ipaMask == 0 || !ipaMask.IsValidMask())
    {
        ipaMask = ipa.DefaultMask();
    }

    _ipa        = ipa;
    _ipaMask    = ipaMask;
    _ipaSubnet  = (ipa & ipaMask);

    if (ipa)
    {
#if DBG
        TraceSz(Warning, "+\n-------------------------------------------------------------------------");
        #ifdef XNET_FEATURE_XBDM_SERVER
        TraceSz3(Warning, "+XBOX DEBUG IP: %s / %s [%s]", ipa.Str(), ipaMask.Str(), _ea.Str());
        #else
        TraceSz3(Warning, "+XBOX TITLE IP: %s / %s [%s]", ipa.Str(), ipaMask.Str(), _ea.Str());
        #endif
        TraceSz(Warning, "+-------------------------------------------------------------------------\n");
#endif

        // Add a route for the local subnet

        RouteAdd(_ipaSubnet, _ipaMask, _ipa, RTEF_LOCAL, RTE_DEFAULT_METRIC);
    }
    else
    {
        // We've lost our subnet so clear the route list

        RouteListOrphan();
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpRecv
// ---------------------------------------------------------------------------------------

void CXnIp::IpRecv(CPacket * ppkt)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsIp());

    CIpHdr *        pIpHdr;
    CIpAddr         ipaDst;
    CIpAddr         ipaSrc;
    UINT            cbHdrLen;
    UINT            cbLen;

    if (ppkt->GetCb() < sizeof(CIpHdr))
    {
        TraceSz(pktWarn, "[DISCARD] Ethernet frame smaller than IP header");
        return;
    }

    pIpHdr = ppkt->GetIpHdr();
    cbHdrLen = pIpHdr->_bVerHdr;
    cbLen = pIpHdr->GetLen();

    if ((cbHdrLen & 0xF0) != 0x40)
    {
        TraceSz1(pktWarn, "[DISCARD] IP version (%d) is not IPv4", cbHdrLen >> 4);
        return;
    }

    cbHdrLen = (cbHdrLen & 0x0F) << 2;

    if (cbHdrLen < sizeof(CIpHdr) || cbHdrLen > cbLen || cbLen > ppkt->GetCb())
    {
        TraceSz3(pktWarn, "[DISCARD] IP header length is bad (%d,%d,%d)",
                cbHdrLen < sizeof(CIpHdr), cbHdrLen > cbLen, cbLen > ppkt->GetCb());
        return;
    }

    // Change the size of the packet to match the size specified in the IP header.  An
    // ethernet frame, especially a small one, can sometimes be longer than the IP
    // packet length.  We've already checked above that the ethernet frame is at least
    // as big as cbLen.

    ppkt->SetCb(cbLen);

    ipaDst = pIpHdr->_ipaDst;
    ipaSrc = pIpHdr->_ipaSrc;

    if (cbHdrLen > sizeof(CIpHdr))
    {
        TraceSz9(pktRecv, "[IP %s %s (%d %d %04X %04X) %d]{%d}[%d]",
                 ipaDst.Str(), ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
                 NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol,
                 cbHdrLen - sizeof(CIpHdr), cbLen - cbHdrLen);
        TraceSz(pktRecv, "IP header options are not supported.  Continuing as if no options.");
        ppkt->SetHdrOptLen(cbHdrLen - sizeof(CIpHdr));
    }
    else
    {
        TraceSz8(pktRecv, "[IP %s %s (%d %d %04X %04X) %d][%d]",
                 ipaDst.Str(), ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
                 NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol,
                 cbLen - cbHdrLen);
    }

    if (tcpipxsum(0, pIpHdr, cbHdrLen) != 0xffff)
    {
        TraceSz(pktWarn, "[DISCARD] IP header checksum failed");
        return;
    }

    Assert(!_ipa.IsBroadcast());
    Assert(!_ipa.IsMulticast());
    Assert(!_ipa.IsLoopback());

    if (ipaDst == 0)
    {
        TraceSz(pktWarn, "[DISCARD] Destination address is zero");
        return;
    }

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST) && !ipaDst.IsBroadcast())
    {
        TraceSz(pktRecv, "[DISCARD] IP-level unicast via link-level broadcast");
        return;
    }

    if (ipaSrc.IsBroadcast() || (ipaSrc == 0 && !IsGateway(0)))
    {
        TraceSz1(pktRecv, "[DISCARD] Source address is %s", ipaSrc == 0 ? "zero" : "broadcast");
        return;
    }

    if (!ppkt->TestFlags(PKTF_RECV_LOOPBACK))
    {
        if (ipaDst.IsLoopback() || ipaSrc.IsLoopback() || ipaSrc == _ipa)
        {
            TraceSz3(pktRecv, "[DISCARD] IP loopback addresses received via link-level (%d,%d,%d)",
                    ipaDst.IsLoopback(), ipaSrc.IsLoopback(), ipaSrc == _ipa);
            return;
        }

        if (!ppkt->TestFlags(PKTF_RECV_BROADCAST) && !ipaDst.IsBroadcast() && !IsGateway(0))
        {
            if (_ipa != ipaDst && (ipaDst != IPADDR_SECURE_DEFAULT || pIpHdr->_bProtocol != IPPROTOCOL_UDP))
            {
            #if DBG
                BYTE bProtocol = pIpHdr->_bProtocol;
                CUdpHdr * pUdpHdr = (bProtocol == IPPROTOCOL_UDP || bProtocol == IPPROTOCOL_TCP) ? (CUdpHdr *)(pIpHdr + 1) : NULL;
                TraceSz6(pktWarn, "[DISCARD] %s packet from %s:%d to %s:%d but my IP is %s",
                         bProtocol == IPPROTOCOL_UDP ? "UDP" : bProtocol == IPPROTOCOL_TCP ? "TCP " : "IP",
                         ipaSrc.Str(), pUdpHdr ? NTOHS(pUdpHdr->_ipportSrc) : bProtocol,
                         ipaDst.Str(), pUdpHdr ? NTOHS(pUdpHdr->_ipportDst) : bProtocol,
                         _ipa ? _ipa.Str() : "not yet acquired");
            #endif
                return;
            }
        }
    }

    if (pIpHdr->_wFragOff & HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK))
    {
#ifdef XNET_FEATURE_FRAG
    #ifdef XNET_FEATURE_FRAG_LOOPBACK
        if (ppkt->TestFlags(PKTF_RECV_BROADCAST))
    #else
        if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK))
    #endif
        {
            TraceSz1(pktWarn, "[DISCARD] Fragmented packet received via %s",
                    ppkt->TestFlags(PKTF_RECV_BROADCAST) ? "broadcast" : "loopback");
            return;
        }
        else
        {
            FragRecv(ppkt, pIpHdr, cbHdrLen, cbLen);
            return;
        }
#else
        TraceSz(pktWarn, "[DISCARD] No support for fragmented packets");
        return;
#endif
    }

    BYTE * pb = (BYTE *)pIpHdr + cbHdrLen;
    cbLen -= cbHdrLen;

    if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        ppkt->SetType(PKTF_TYPE_UDP);
        IpRecvUdp(ppkt, pIpHdr, (CUdpHdr *)pb, cbLen);
        return;
    }

    if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        ppkt->SetType(PKTF_TYPE_TCP);
        IpRecvTcp(ppkt, pIpHdr, (CTcpHdr *)pb, cbLen);
        return;
    }

    #ifdef XNET_FEATURE_ICMP

    if (pIpHdr->_bProtocol == IPPROTOCOL_ICMP)
    {
        IcmpRecv(ppkt, pIpHdr, pb, cbLen);
        return;
    }

    #endif

    TraceSz1(pktWarn, "[DISCARD] No support for protocol %d", pIpHdr->_bProtocol);
    return;
}

void CXnIp::IpRecvUdp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsUdp());

    if (    cbLen < sizeof(CUdpHdr)
        ||  pUdpHdr->GetLen() != cbLen
        ||  pUdpHdr->_ipportDst == 0
        ||  pUdpHdr->_ipportSrc == 0)
    {
        TraceSz4(pktWarn, "[DISCARD] UDP header is invalid (%d,%d,%d,%d)",
                 cbLen < sizeof(CUdpHdr), pUdpHdr->GetLen() != cbLen,
                 pUdpHdr->_ipportDst == 0, pUdpHdr->_ipportSrc == 0);
        return;
    }

    if (!ppkt->IsEsp())
    {
        if (pUdpHdr->_ipportDst == ESPUDP_CLIENT_PORT && !IsGateway(pUdpHdr->_ipportDst))
        {
            IpRecvEsp(ppkt, pIpHdr, (CEspHdr *)pUdpHdr, cbLen);
            return;
        }

        if (pIpHdr->_ipaDst == IPADDR_SECURE_DEFAULT)
        {
            TraceSz5(pktWarn, "[DISCARD] UDP packet from %s:%d to %s:%d but my IP is %s",
                     pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                     pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
                     _ipa ? _ipa.Str() : "not yet acquired");
            return;
        }

        if (!ppkt->TestFlags(PKTF_RECV_LOOPBACK))
        {
            if (pUdpHdr->_wChecksum)
            {
                CPseudoHeader ph;
                ph._ipaSrc    = pIpHdr->_ipaSrc;
                ph._ipaDst    = pIpHdr->_ipaDst;
                ph._bZero     = 0;
                ph._bProtocol = IPPROTOCOL_UDP;
                ph._wLen      = pUdpHdr->_wLen;

                Assert(cbLen == NTOHS(ph._wLen));

                if (tcpipxsum(tcpipxsum(0, &ph, sizeof(CPseudoHeader)), pUdpHdr, cbLen) != 0xFFFF)
                {
                    TraceSz(pktWarn, "[DISCARD] UDP header checksum failed");
                    return;
                }
            }

#ifdef XNET_FEATURE_DHCP
            if (pUdpHdr->_ipportDst == DHCP_CLIENT_PORT)
            {
                TraceSz(pktRecv, "[DHCPRECV]");
                DhcpRecv(ppkt, pUdpHdr, cbLen - sizeof(CUdpHdr));
                return;
            }
#endif

#ifdef XNET_FEATURE_DNS
            if (pUdpHdr->_ipportDst == DNS_CLIENT_PORT && !IsGateway(pUdpHdr->_ipportDst))
            {
                TraceSz(pktRecv, "[DNSRECV]");
                IpRecvDns(ppkt, pUdpHdr, cbLen - sizeof(CUdpHdr));
                return;
            }
#endif

            // This is an insecure packet.  If we are compiled for online, some sockets
            // can accept insecure packets, so we'll pass them up to UpdRecv and let it
            // decide.  Otherwise, unless we are compiled insecure and the client has
            // requested bypassing security, the insecure UDP packet stops right here.
            
#if !defined(XNET_FEATURE_ONLINE)
    #ifdef XNET_FEATURE_INSECURE
            if (!(cfgFlags & XNET_STARTUP_BYPASS_SECURITY))
    #endif
            {
                TraceSz3(pktWarn, "[DISCARD] Insecure UDP packet on port %d from %s:%d",
                         NTOHS(pUdpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(),
                         NTOHS(pUdpHdr->_ipportSrc));
                return;
            }
#endif
        }
    }

    UdpRecv(ppkt, pIpHdr, pUdpHdr, cbLen - sizeof(CUdpHdr));
}

void CXnIp::IpRecvTcp(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsTcp());

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST) || pIpHdr->_ipaDst.IsBroadcast())
    {
        TraceSz(pktRecv, "[DISCARD] TCP packet with broadcast destination address");
        return;
    }

    UINT cbHdrLen;

    if (    cbLen < sizeof(CTcpHdr)
        || (cbHdrLen = pTcpHdr->GetHdrLen()) < sizeof(CTcpHdr)
        ||  cbHdrLen > cbLen
        ||  pTcpHdr->_ipportDst == 0
        ||  pTcpHdr->_ipportSrc == 0)
    {
        TraceSz5(pktWarn, "[DISCARD] TCP header is invalid (%d,%d,%d,%d,%d)",
                 cbLen < sizeof(CTcpHdr), cbHdrLen < sizeof(CTcpHdr),
                 cbHdrLen > cbLen, pTcpHdr->_ipportDst == 0, pTcpHdr->_ipportSrc == 0);
        return;
    }

    if (!ppkt->TestFlags(PKTF_TYPE_ESP|PKTF_RECV_LOOPBACK))
    {
        CPseudoHeader ph;
        ph._ipaSrc    = pIpHdr->_ipaSrc;
        ph._ipaDst    = pIpHdr->_ipaDst;
        ph._bZero     = 0;
        ph._bProtocol = IPPROTOCOL_TCP;
        ph._wLen      = HTONS((WORD)cbLen);

        if (tcpipxsum(tcpipxsum(0, &ph, sizeof(CPseudoHeader)), pTcpHdr, cbLen) != 0xFFFF)
        {
            TraceSz(pktWarn, "[DISCARD] TCP header checksum failed");
            return;
        }

        // This is an insecure packet.  If we are compiled for online, some sockets
        // can accept insecure packets, so we'll pass them up to TcpRecv and let it
        // decide.  Otherwise, unless we are compiled insecure and the client has
        // requested bypassing security, the insecure TCP packet stops right here.
            
#if !defined(XNET_FEATURE_ONLINE)
    #ifdef XNET_FEATURE_INSECURE
        if (!(cfgFlags & XNET_STARTUP_BYPASS_SECURITY))
    #endif
        {
            TraceSz3(pktWarn, "[DISCARD] Insecure TCP packet on port %d from %s:%d",
                     NTOHS(pTcpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc));
            return;
        }
#endif
    }

    TcpRecv(ppkt, pIpHdr, pTcpHdr, cbHdrLen, cbLen - cbHdrLen);
}

void CXnIp::IpRecvEsp(CPacket * ppkt, CIpHdr * pIpHdr, CEspHdr * pEspHdr, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsUdp());
    Assert(pEspHdr->_ipportDst == ESPUDP_CLIENT_PORT);

    if (cbLen < sizeof(CEspHdr))
    {
        TraceSz(pktWarn, "[DISCARD] ESPUDP header length exceeds packet length");
        return;
    }

    if (pEspHdr->_dwSpi == 0)
    {
        if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK))
        {
            TraceSz1(pktWarn, "[DISCARD] KeyEx packet received via %s",
                     ppkt->TestFlags(PKTF_RECV_BROADCAST) ? "broadcast" : "loopback");
            return;
        }

        IpRecvKeyEx(ppkt, pIpHdr->_ipaSrc, pEspHdr->_ipportSrc,
                    (CKeyExHdr *)&pEspHdr->_dwSeq, cbLen - offsetof(CEspHdr, _dwSeq));
        return;
    }

    if ((cbLen & 3) != 0)
    {
        TraceSz1(pktWarn, "[DISCARD] ESPUDP packet is not four-byte aligned (%d)", cbLen);
        return;
    }

    ppkt->SetType(PKTF_TYPE_IP|PKTF_TYPE_ESP);

    CSecReg *   pSecReg     = NULL;
    CIpAddr     ipa         = pEspHdr->_dwSpi;
    BOOL        fBroadcast  = ipa.IsBroadcast();
    DWORD       dwSeq       = NTOHL(pEspHdr->_dwSeq);
    DWORD       dwBit       = 0;
    CEspTail *  pEspTail    = ppkt->GetEspTail();
    BYTE *      pb          = (BYTE *)(pEspHdr + 1);
    BYTE *      pbKeySha;
    UINT        cbKeySha;
    BYTE *      pbKeyDes;
    UINT        cbKeyDes;

    if (!!fBroadcast != !!pIpHdr->_ipaDst.IsBroadcast())
    {
        TraceSz2(pktWarn, "[DISCARD] ESPUDP packet has dwSpi %08X but ipaDst %s",
                 pEspHdr->_dwSpi, pIpHdr->_ipaDst.Str());
        return;
    }

    if (fBroadcast)
    {
        pbKeySha = _abKeyShaLan;
        cbKeySha = sizeof(_abKeyShaLan);
        pbKeyDes = _abKeyDesLan;
        cbKeyDes = sizeof(_abKeyDesLan);

        if (dwSeq != 0xFFFFFFFF)
        {
            TraceSz1(pktWarn, "[DISCARD] ESPUDP broadcast packet has invalid dwSeq (%08lX)", dwSeq);
            return;
        }
    }
    else
    {
        pSecReg = SecRegLookup(ipa);

        if (pSecReg == NULL)
        {
            TraceSz1(pktWarn, "[DISCARD] Secure packet sent to unregistered address (%s)",
                     ipa.Str());
            return;
        }

        if (!pSecReg->IsRecvReady())
        {
            TraceSz1(pktWarn, "[DISCARD] Secure packet to %s before key exchange is complete",
                     ipa.Str());
            return;
        }

        pbKeySha = pSecReg->_abKeyShaRecv;
        cbKeySha = sizeof(pSecReg->_abKeyShaRecv);
        pbKeyDes = pSecReg->_abKeyDesRecv;
        cbKeyDes = pSecReg->_cbKeyDesRecv;

        if (dwSeq < pSecReg->_dwSeqRecv)
        {
            TraceSz3(pktWarn, "[DISCARD] Secure packet to %s has dwSeq %d less than window base %d",
                     ipa.Str(), dwSeq, pSecReg->_dwSeqRecv);
            return;
        }

        dwBit = dwSeq - pSecReg->_dwSeqRecv;

        if (dwBit > ESPUDP_REPLAY_WINDOW)
        {
            TraceSz4(pktWarn, "[DISCARD] Secure packet to %s has dwSeq %d outside window (%d to %d)",
                     ipa.Str(), dwSeq, pSecReg->_dwSeqRecv, pSecReg->_dwSeqRecv + ESPUDP_REPLAY_WINDOW);
            return;
        }

        if (dwBit < 32 && (pSecReg->_dwSeqMask & (1 << dwBit)))
        {
            TraceSz2(pktWarn, "[DISCARD] Secure packet to %s has dwSeq %d which is replayed",
                     ipa.Str(), dwSeq);
            return;
        }
    }

    if (cbKeyDes)
    {
        ppkt->SetFlags(PKTF_CRYPT);

        if (cbLen < sizeof(CEspHdr) + ROUNDUP8(XC_SERVICE_DES_BLOCKLEN + offsetof(CEspTail, _abHash)) + sizeof(pEspTail->_abHash))
        {
            TraceSz1(pktWarn, "[DISCARD] ESPUDP crypt packet is too small (%d)", cbLen);
            return;
        }
    }
    else
    {
        if (cbLen < sizeof(CEspHdr) + ROUNDUP4(sizeof(CEspTail)))
        {
            TraceSz1(pktWarn, "[DISCARD] ESPUDP auth packet is too small (%d)", cbLen);
            return;
        }
    }

    cbLen -= sizeof(CEspHdr) + sizeof(pEspTail->_abHash);

    TraceSz4(pktRecv, "[ESP %s #%d]%s[%d][ESPT]",
             ipa.Str(), dwSeq, ppkt->TestFlags(PKTF_CRYPT) ? "[IV]" : "",
             cbLen - (ppkt->TestFlags(PKTF_CRYPT) ? XC_SERVICE_DES_BLOCKLEN : 0) - offsetof(CEspTail, _abHash));

    // Authenicate the packet from the [ESP] header to just before the _abHash in [ESPT]

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    Assert(sizeof(pEspTail->_abHash) <= sizeof(abHash));
    XcHMAC(pbKeySha, cbKeySha, (BYTE *)&pEspHdr->_dwSpi, (sizeof(CEspHdr) - sizeof(CUdpHdr)) + cbLen,
           NULL, 0, abHash);

    if (memcmp(pEspTail->_abHash, abHash, sizeof(pEspTail->_abHash)) != 0)
    {
        TraceSz1(pktWarn, "[DISCARD] Secure packet to %s failed to authenticate", ipa.Str());
        return;
    }

    if (cbKeyDes)
    {
        // Decrypt the packet from just after the [ESP] header to just before the _abHash in [ESPT]

        if (cbLen != ROUNDUP8(cbLen))
        {
            TraceSz1(pktWarn, "[DISCARD] Secure crypt packet has invalid payload size (%d)", cbLen);
            return;
        }

        CryptDes(XC_SERVICE_DECRYPT, pbKeyDes, cbKeyDes, pb, pb + XC_SERVICE_DES_BLOCKLEN, cbLen);

        pb += XC_SERVICE_DES_BLOCKLEN;
        cbLen -= XC_SERVICE_DES_BLOCKLEN;
    }

    cbLen -= offsetof(CEspTail, _abHash);

    if (    pEspTail->_bNextHeader != IPPROTOCOL_UDP
        &&  pEspTail->_bNextHeader != IPPROTOCOL_TCP
        &&  pEspTail->_bNextHeader != IPPROTOCOL_SECMSG)
    {
        TraceSz2(pktWarn, "[DISCARD] Secure packet to %s failed bNextHeader test (%d)",
                ipa.Str(), pEspTail->_bNextHeader);
        return;
    }

    if (cbLen < pEspTail->_bPadLen)
    {
        TraceSz3(pktWarn, "[DISCARD] Secure packet to %s failed bPadLen test (%d/%d)",
                 ipa.Str(), cbLen, pEspTail->_bPadLen);
        return;
    }

    if (pEspTail->_bPadLen > 0)
    {
        UINT    cbPad = pEspTail->_bPadLen;
        BYTE *  pbPad = (BYTE *)pEspTail;

        // Verify that the padding is the series of bytes 1, 2, 3, ...

        while (cbPad > 0 && *--pbPad == (BYTE)cbPad)
            cbPad--;
    
        if (cbPad)
        {
            TraceSz1(pktWarn, "[DISCARD] Secure packet to %s failed padding test", ipa.Str());
            return;
        }

        cbLen -= pEspTail->_bPadLen;
    }

    if (!fBroadcast)
    {
        if (dwBit < 32)
        {
            // Sequence number is within the current window.  Just set the bit.

            Assert((pSecReg->_dwSeqMask & (1 << dwBit)) == 0);
            pSecReg->_dwSeqMask |= (1 << dwBit);
        }
        else
        {
            // Sequence number is beyond the edge of the window.  Slide window so that the
            // edge is at the sequence number.

            if (dwBit >= 63)
                pSecReg->_dwSeqMask = 0x80000000;
            else
                pSecReg->_dwSeqMask = 0x80000000 | (pSecReg->_dwSeqMask >> (dwBit - 31));

            pSecReg->_dwSeqRecv += dwBit - 31;
        }

        if (pSecReg->_bState != SR_STATE_READY)
        {
            Assert(pSecReg->_bState == SR_STATE_INITWAIT || pSecReg->_bState == SR_STATE_RESPSENT);

            // We have successfully authenticated a packet while in the INITWAIT or RESPSENT
            // state.  That means the other side definitely knows the keys.  Go into the
            // ready state and release any pending packets.

#ifdef XNET_FEATURE_SG

            if (pSecReg->TestFlags(SRF_ONLINEPEER))
            {
                // Capture the address of the sender of this packet.  This will be used
                // as the return address for packets sent on this security association.

                Assert(pIpHdr->_ipaSrc != 0 && pEspHdr->_ipportSrc != 0);

                pSecReg->_ipaDst    = pIpHdr->_ipaSrc;
                pSecReg->_ipportDst = pEspHdr->_ipportSrc;
            }

#endif

            pSecReg->_bState = SR_STATE_READY;
            TimerSet(&pSecReg->_timer, TIMER_INFINITE);
            SecRegXmitQueue(pSecReg);
        }

        // Change the return address in the IP header to the secure address of the sender

        pIpHdr->_ipaSrc = CIpAddr(pSecReg->_dwSpiRecv);

        // Remember the last time a packet was received on this security association

        pSecReg->_dwTickRecv = TimerTick();
    }

    pIpHdr->_bProtocol = pEspTail->_bNextHeader;

    if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        ppkt->SetType(PKTF_TYPE_ESP|PKTF_TYPE_UDP);
        IpRecvUdp(ppkt, pIpHdr, (CUdpHdr *)pb, cbLen);
    }
    else if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        ppkt->SetType(PKTF_TYPE_ESP|PKTF_TYPE_TCP);
        IpRecvTcp(ppkt, pIpHdr, (CTcpHdr *)pb, cbLen);
    }
    else
    {
        Assert(pIpHdr->_bProtocol == IPPROTOCOL_SECMSG);
        ppkt->SetType(PKTF_TYPE_ESP);
        IpRecvSecMsg(ppkt, pSecReg, dwSeq, (CSecMsgHdr *)pb, cbLen);
    }
}

void CXnIp::IpRecvKeyEx(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExHdr * pKeyExHdr, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);

    if (cbKeyEx < sizeof(CKeyExHdr) || pKeyExHdr->_cbEnt < sizeof(CKeyExHdr) || pKeyExHdr->_cbEnt > cbKeyEx)
    {
        TraceSz5(pktWarn, "[DISCARD] KeyEx from %s:%d header entry is invalid (%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 pKeyExHdr->_cbEnt < sizeof(CKeyExHdr), pKeyExHdr->_cbEnt > cbKeyEx);
        return;
    }

    if (pKeyExHdr->_wType == KEYEX_TYPE_XBTOXB_INIT || pKeyExHdr->_wType == KEYEX_TYPE_XBTOXB_RESP)
    {
        IpRecvKeyExXbToXb(ppkt, ipaSrc, ipportSrc, (CKeyExXbToXb *)pKeyExHdr, cbKeyEx);
        return;
    }

#ifdef XNET_FEATURE_SG

    if (pKeyExHdr->_wType == KEYEX_TYPE_SGTOXB_RESP && ipaSrc != 0 && ipportSrc != 0)
    {
        IpRecvKeyExSgToXb(ppkt, ipaSrc, ipportSrc, (CKeyExSgToXbResp *)pKeyExHdr, cbKeyEx);
        return;
    }

    if (    (pKeyExHdr->_wType == KEYEX_TYPE_NATOPEN_INIT && ipaSrc == 0 && ipportSrc == 0)
        ||  (pKeyExHdr->_wType == KEYEX_TYPE_NATOPEN_RESP && ipaSrc != 0 && ipportSrc != 0))
    {
        IpRecvKeyExNatOpen(ppkt, ipaSrc, ipportSrc, (CKeyExNatOpen *)pKeyExHdr, cbKeyEx);
        return;
    }

#endif

    TraceSz3(pktWarn, "[DISCARD] KeyEx from %s:%d header type (%04X) is invalid",
             ipaSrc.Str(), NTOHS(ipportSrc), pKeyExHdr->_wType);
    return;
}

void CXnIp::IpRecvKeyExXbToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExXbToXb * pKeyExXbToXb, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(cbKeyEx >= pKeyExXbToXb->_cbEnt);

    if (pKeyExXbToXb->_cbEnt != sizeof(CKeyExXbToXb))
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d entry has an incorrect size (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), pKeyExXbToXb->_cbEnt, sizeof(CKeyExXbToXb));
        return;
    }

#ifdef XNET_FEATURE_SG

    if (XNetXnKidIsOnlinePeer(&pKeyExXbToXb->_xnkid) && _pSecRegLogon == NULL)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d ignoring request from online-peer while offline",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

#endif

    CKeyReg * pKeyReg = NULL;
    CSecReg * pSecReg = NULL;

    if (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT)
    {
        pKeyReg = KeyRegLookup(&pKeyExXbToXb->_xnkid);

        if (pKeyReg == NULL)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbInit from %s:%d to unregistered XNKID %s",
                     ipaSrc.Str(), NTOHS(ipportSrc), HexStr(pKeyExXbToXb->_xnkid.ab, sizeof(pKeyExXbToXb->_xnkid.ab)));
            return;
        }
    }
    else
    {
        pSecReg = SecRegLookup(pKeyExXbToXb->_dwSpiInit);

        if (pSecReg == NULL)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to unregistered address %s",
                     ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pKeyExXbToXb->_dwSpiInit).Str());
            return;
        }

    #ifdef XNET_FEATURE_SG

        if (ipaSrc == 0 || ipportSrc == 0)
        {
            TraceSz2(pktWarn, "[DISCARD] KeyExXbToXbResp received via SG forwarding (%d,%d)",
                     ipaSrc == 0, ipportSrc == 0);
            return;
        }

        if (!pSecReg->TestFlags(SRF_SYSTEMLINK|SRF_ONLINEPEER))
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to non peer-to-peer address %s",
                     ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pSecReg->_dwSpiRecv).Str());
            return;
        }

    #endif

        if (pKeyExXbToXb->_liTime.QuadPart <= pSecReg->_liTime.QuadPart)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s was replayed",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }

        if (pSecReg->_bState != SR_STATE_INITSENT && pSecReg->_bState != SR_STATE_INITWAIT)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s while not in ISENT or IWAIT state",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }

        Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExXbToXb->_abNonceInit));

        if (memcmp(pSecReg->_abNonceInit, pKeyExXbToXb->_abNonceInit, sizeof(pSecReg->_abNonceInit)) != 0)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s has incorrect nonce",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }

        pKeyReg = pSecReg->_pKeyReg;

        if (memcmp(pKeyReg->_xnkid.ab, pKeyExXbToXb->_xnkid.ab, sizeof(pKeyReg->_xnkid.ab)) != 0)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s has incorrect xnkid",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }
    }

    // Advance to the next entry.  It must contain the diffie-hellman g^X value.

    cbKeyEx -= pKeyExXbToXb->_cbEnt;
    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExXbToXb + pKeyExXbToXb->_cbEnt);

    if (    cbKeyEx < sizeof(CKeyExHdr)
        ||  pKeyExDh->_wType != KEYEX_TYPE_DH_GX
        ||  pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1
        ||  pKeyExDh->_cbEnt > cbKeyEx)
    {
        TraceSz6(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d DH entry is invalid (%d,%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_wType != KEYEX_TYPE_DH_GX,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt > cbKeyEx);
        return;
    }

    // Advance to the next entry.  It must contain the HMAC-SHA digest of the previous entries,
    // and it must also be the last entry.

    cbKeyEx -= pKeyExDh->_cbEnt;
    CKeyExHdr * pKeyExSha = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    if (    cbKeyEx < sizeof(CKeyExHdr)
        ||  pKeyExSha->_wType != KEYEX_TYPE_HMAC_SHA
        ||  pKeyExSha->_cbEnt != sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE
        ||  pKeyExSha->_cbEnt != cbKeyEx)
    {
        TraceSz6(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d SHA entry is invalid (%d,%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExSha->_wType != KEYEX_TYPE_HMAC_SHA,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExSha->_cbEnt != sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExSha->_cbEnt != cbKeyEx);
        return;
    }

    // Authenticate the key exchange message (all entries except the last) using the key-exchange-key
    // corresponding to the XNKID in the message.

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)pKeyExXbToXb,
           (BYTE *)pKeyExSha - (BYTE *)pKeyExXbToXb, NULL, 0, abHash);

    Assert(pKeyExSha->_cbEnt == sizeof(CKeyExHdr) + sizeof(abHash));

    if (memcmp((BYTE *)(pKeyExSha + 1), abHash, sizeof(abHash)) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d failed to authenticate",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    // Decrypt the portion of the first entry which contains the XNADDR structures

    CryptDes(XC_SERVICE_DECRYPT, pKeyReg->_abKeyDes, sizeof(pKeyReg->_abKeyDes),
             pKeyExXbToXb->_abIv, pKeyExXbToXb->_abIv + XC_SERVICE_DES_BLOCKLEN,
             sizeof(CKeyExXbToXb) - offsetof(CKeyExXbToXb, _abIv) - XC_SERVICE_DES_BLOCKLEN);

    // Verify that the sender knows the current XNADDR of this stack

    XNADDR xnaddr, * pxnaddr;
    IpGetXnAddr(&xnaddr);

    pxnaddr = (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT) ? &pKeyExXbToXb->_xnaddrResp : &pKeyExXbToXb->_xnaddrInit;

    if (memcmp(&xnaddr, pxnaddr, sizeof(XNADDR)) != 0)
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d target XNADDR mismatch; got %s expected %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), XnAddrStr(pxnaddr), XnAddrStr(&xnaddr));
        return;
    }

    // Verify that the sender's XNADDR is valid

    pxnaddr = (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT) ? &pKeyExXbToXb->_xnaddrInit : &pKeyExXbToXb->_xnaddrResp;

    if (XNetXnKidIsSystemLink(&pKeyExXbToXb->_xnkid))
    {
        CEnetHdr * pEnetHdr = ppkt->GetEnetHdr();

        if (!pEnetHdr->_eaSrc.IsEqual(pxnaddr->abEnet))
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d source XNADDR failed system-link test (%d)",
                     ipaSrc.Str(), NTOHS(ipportSrc), !pEnetHdr->_eaSrc.IsEqual(pxnaddr->abEnet));
            return;
        }
    }

#ifdef XNET_FEATURE_SG

    if (XNetXnKidIsOnlinePeer(&pKeyExXbToXb->_xnkid))
    {
        if (    !CIpAddr(pxnaddr->ina.s_addr).IsValidUnicast()
            ||  !CIpAddr(pxnaddr->inaOnline.s_addr).IsValidUnicast()
            ||  pxnaddr->wPortOnline == 0)
        {
            TraceSz5(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d source XNADDR failed online-peer tests (%d,%d,%d)",
                     ipaSrc.Str(), NTOHS(ipportSrc), !CIpAddr(pxnaddr->ina.s_addr).IsValidUnicast(),
                     !CIpAddr(pxnaddr->inaOnline.s_addr).IsValidUnicast(), pxnaddr->wPortOnline == 0);
            return;
        }
    }
                    
#endif

    if (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT)
    {
        // Try to find an existing CSecReg given the XNADDR of the initiator and the XNKID

        pSecReg = SecRegLookup(&pKeyExXbToXb->_xnaddrInit, &pKeyExXbToXb->_xnkid);

        if (pSecReg == NULL)
        {
            // Not found.  Allocate a new CSecReg.

            pSecReg = SecRegAlloc(&pKeyExXbToXb->_xnaddrInit, pKeyReg);

            if (pSecReg == NULL)
            {
                TraceSz2(pktWarn, "[DISCARD] KeyExXbToXbInit from %s:%d reached CSecReg limit",
                         ipaSrc.Str(), NTOHS(ipportSrc));
                return;
            }
        }
        else if (pKeyExXbToXb->_liTime.QuadPart <= pSecReg->_liTime.QuadPart)
        {
            TraceSz2(pktWarn, "[DISCARD] KeyExXbToXbInit from %s:%d is obsolete or replayed",
                     ipaSrc.Str(), NTOHS(ipportSrc));
            return;
        }
#ifdef XNET_FEATURE_SG
        else if (pSecReg->TestFlags(SRF_ONLINEPEER))
        {
            // Update the XNADDR for this CSecReg.  Is is possible that the online information
            // has changed since the last time the peer contacted us.

            pSecReg->_xnaddr = pKeyExXbToXb->_xnaddrInit;
        }
#endif

        pSecReg->_liTime = pKeyExXbToXb->_liTime;

        // If we are in the INITSENT state, then we have simultaneous initiator packets
        // being sent.  To resolve this, the side which has the highest ethernet address
        // is the initiator and the other side becomes the responder.

        if (pSecReg->_bState == SR_STATE_INITSENT)
        {
            if (memcmp(_ea._ab, pKeyExXbToXb->_xnaddrInit.abEnet, sizeof(CEnetAddr)) > 0)
            {
                // This side wins.  The other side will run the same computation and will
                // respond to our initiator packet.  We just discard theirs.

                TraceSz2(pktRecv, "[DISCARD] KeyExXbToXbInit from %s:%d simultaneous initiators",
                         ipaSrc.Str(), NTOHS(ipportSrc));
                return;
            }
        }

        // If we are in the RESPSENT state, this could be a retransmit of the initiator packet.
        // We verify this by checking the nonce of the initiator that we remembered from before.

        if (    pSecReg->_bState != SR_STATE_RESPSENT
            ||  memcmp(pSecReg->_abNonceInit, pKeyExXbToXb->_abNonceInit, sizeof(pSecReg->_abNonceInit)) != 0)
        {
            // This is a new key exchange initiation sequence.  Reset the security association.

            SecRegSetIdle(pSecReg);

            pSecReg->_bState    = SR_STATE_RESPSENT;
            pSecReg->_bRetry    = SecRegRexmitRetries(pSecReg);
            pSecReg->_dwSpiXmit = pKeyExXbToXb->_dwSpiInit;

            // Remember the nonce of the initiator in case we need to retransmit this reponse.
            // Generate a random nonce for the responder.

            Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExXbToXb->_abNonceInit));
            memcpy(pSecReg->_abNonceInit, pKeyExXbToXb->_abNonceInit, sizeof(pSecReg->_abNonceInit));
            Rand(pSecReg->_abNonceResp, sizeof(pSecReg->_abNonceResp));

            // Generate the SHA and DES keys for this security association

            SecRegSetKey(pSecReg, pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha),
                         pKeyReg->_abDhX, sizeof(pKeyReg->_abDhX),
                         (BYTE *)(pKeyExDh + 1), pKeyExDh->_cbEnt - sizeof(CKeyExHdr),
                         FALSE);

            // Set the retransmission timer.  This side is responsible for retransmitting
            // the key exchange response until it gets a secure packet from the other side.

            TimerSet(&pSecReg->_timer, TimerTick() + SecRegRexmitTimeoutInSeconds(pSecReg) * TICKS_PER_SECOND);
        }

#ifdef XNET_FEATURE_SG
        if (pSecReg->TestFlags(SRF_ONLINEPEER) && ipaSrc != 0 && ipportSrc != 0)
        {
            // Capture the return address information from the initiator packet if the packet
            // arrived directly (versus being forwarded through the security gateways).

            pSecReg->_ipaDst    = ipaSrc;
            pSecReg->_ipportDst = ipportSrc;
        }
#endif

        // Send a KeyEx XbToXb response packet back to the initiator

        IpXmitKeyExXbToXb(pSecReg);
    }
    else
    {
#if DBG
        if (Tag(keyExDrop) && pSecReg->_bRetry == SecRegRexmitRetries(pSecReg))
        {
            // Drop the first key-exchange response for testing purposes
            TraceSz(pktWarn, "[DISCARD] Dropping first KeyExXbToXbResp (debug only)");
            return;
        }
#endif

        pSecReg->_liTime = pKeyExXbToXb->_liTime;

#ifdef XNET_FEATURE_SG
        if (pSecReg->TestFlags(SRF_ONLINEPEER))
        {
            // Capture the return address information from the responder packet.  Responses are
            // always sent directly (as opposed to being forwarded through the security gateways).

            Assert(ipaSrc != 0 && ipportSrc != 0);

            pSecReg->_ipaDst    = ipaSrc;
            pSecReg->_ipportDst = ipportSrc;
        }
#endif

        // If we are in the INITWAIT state, this could be a retransmit of the responder packet.
        // We verify this by checking the nonce of the responder that we remembered from before.

        if (    pSecReg->_bState != SR_STATE_INITWAIT
            ||  memcmp(pSecReg->_abNonceResp, pKeyExXbToXb->_abNonceResp, sizeof(pSecReg->_abNonceResp)) != 0)
        {
            // This is the first time we've gotten a response from the other side to this
            // key exchange initiation.  Remember the nonce of the responder and the dwSpiXmit.

            Assert(sizeof(pSecReg->_abNonceResp) == sizeof(pKeyExXbToXb->_abNonceResp));
            memcpy(pSecReg->_abNonceResp, pKeyExXbToXb->_abNonceResp, sizeof(pSecReg->_abNonceResp));
            pSecReg->_dwSpiXmit = pKeyExXbToXb->_dwSpiResp;

            // Generate the SHA and DES keys for this security association

            SecRegSetKey(pSecReg, pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha),
                         pKeyReg->_abDhX, sizeof(pKeyReg->_abDhX),
                         (BYTE *)(pKeyExDh + 1), pKeyExDh->_cbEnt - sizeof(CKeyExHdr),
                         TRUE);

            // Switch to the INITWAIT state.  In this state, we know that the other side has computed
            // the same keys that we have, so we stop retransmitting the initiator packet.

            pSecReg->_bState = SR_STATE_INITWAIT;
            TimerSet(&pSecReg->_timer, TIMER_INFINITE);
        }

        // We must send a response.  If there are waiting packets, send those now.
        // Otherwise, send a SECMSG_TYPE_PULSE to let the other side know we're alive.

        if (pSecReg->_pqWait.IsEmpty())
            IpXmitSecMsg(pSecReg, SECMSG_TYPE_PULSE);
        else
            SecRegXmitQueue(pSecReg);
    }
}

#ifdef XNET_FEATURE_SG

void CXnIp::IpRecvKeyExNatOpen(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExNatOpen * pKeyExNatOpen, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_INIT || pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_RESP);
    Assert(cbKeyEx >= pKeyExNatOpen->_cbEnt);

    if (pKeyExNatOpen->_cbEnt != sizeof(CKeyExNatOpen))
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExNatOepn from %s:%d entry has an incorrect size (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), pKeyExNatOpen->_cbEnt, sizeof(CKeyExNatOpen));
        return;
    }

    CKeyReg * pKeyReg = KeyRegLookup(&pKeyExNatOpen->_xnkid);

    if (pKeyReg == NULL)
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d to unregistered XNKID %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), HexStr(pKeyExNatOpen->_xnkid.ab, sizeof(pKeyExNatOpen->_xnkid.ab)));
        return;
    }

    // Authenticate the message including the header using the key-exchange-key corresponding to
    // the XNKID in the message.

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)pKeyExNatOpen,
           offsetof(CKeyExNatOpen, _abHash), NULL, 0, abHash);

    Assert(sizeof(pKeyExNatOpen->_abHash) == sizeof(abHash));

    if (memcmp(abHash, pKeyExNatOpen->_abHash, sizeof(abHash)) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d failed to authenticate",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    if (pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_INIT)
    {
        Assert(ipaSrc == 0 && ipportSrc == 0);

        // Reply to this request by sending a CKeyExNatOpen packet to the destination address
        // specified.  We change the type to KEYEX_TYPE_NATOPEN_RESP and recompute the abHash
        // to prove to the requester that we know the key-exhcange-key associated with the xnkid.

        CPacket * ppktXmit = PacketAlloc(PTAG_CKeyExPacket, PKTF_TYPE_UDP|PKTF_POOLALLOC, sizeof(DWORD) + sizeof(CKeyExNatOpen));

        if (ppktXmit == NULL)
        {
            TraceSz(Warning, "IpRecvKeyExNatOpen - Out of memory allocating packet");
            return;
        }

        CEnetHdr *      pEnetHdr          = ppktXmit->GetEnetHdr();
        CIpHdr *        pIpHdr            = ppktXmit->GetIpHdr();
        CEspHdr *       pEspHdr           = (CEspHdr *)(pIpHdr + 1);
        CKeyExNatOpen * pKeyExNatOpenXmit = (CKeyExNatOpen *)&pEspHdr->_dwSeq;

        IpFillHdr(ppktXmit, pKeyExNatOpen->_ipaDst, IPPROTOCOL_UDP);

        pIpHdr->_ipaSrc     = _ipa;
        pEspHdr->_wLen      = NTOHS(sizeof(CUdpHdr) + sizeof(DWORD) + sizeof(CKeyExNatOpen));
        pEspHdr->_ipportSrc = ESPUDP_CLIENT_PORT;
        pEspHdr->_ipportDst = pKeyExNatOpen->_ipportDst;
        pEspHdr->_wChecksum = 0;
        pEspHdr->_dwSpi     = 0;

        memcpy(pKeyExNatOpenXmit, pKeyExNatOpen, offsetof(CKeyExNatOpen, _abHash));
        pKeyExNatOpenXmit->_wType = KEYEX_TYPE_NATOPEN_RESP;

        Assert(sizeof(pKeyExNatOpenXmit->_abHash) == XC_SERVICE_DIGEST_SIZE);
        XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)pKeyExNatOpenXmit,
               offsetof(CKeyExNatOpen, _abHash), NULL, 0, pKeyExNatOpenXmit->_abHash);

        TraceSz3(secStat, "Sending KeyExNatOpen RESP/%04X to %s:%d",
                 pKeyExNatOpenXmit->_wFlags, pIpHdr->_ipaDst.Str(), NTOHS(pEspHdr->_ipportDst));

        IpXmitIp(ppktXmit, NULL);
        return;
    }

    if (pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_RESP)
    {
        Assert(ipaSrc != 0 && ipportSrc != 0);

        if (pKeyExNatOpen->_wFlags & KNOF_XBTOXB_KEYEX)
        {
            // This message is the response from a NatOpen request we sent via the SG forwarding
            // mechanism.  Lookup the CSecReg associated from the _dwCtx.

            CSecReg * pSecReg = SecRegLookup(pKeyExNatOpen->_dwCtx);

            Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExNatOpen->_abNonce));

            if (     pSecReg == NULL
                ||   pSecReg->_bState != SR_STATE_INITSENT
                ||  !pSecReg->TestFlags(SRF_ONLINEPEER)
                ||   memcmp(pSecReg->_abNonceInit, pKeyExNatOpen->_abNonce, sizeof(pSecReg->_abNonceInit)) != 0)
            {
                TraceSz6(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d is obsolete or invalid (%d,%d,%d,%d)",
                         ipaSrc.Str(), NTOHS(ipportSrc), pSecReg == NULL,
                         pSecReg && pSecReg->_bState != SR_STATE_INITSENT,
                         pSecReg && !pSecReg->TestFlags(SRF_ONLINEPEER),
                         pSecReg && memcmp(pSecReg->_abNonceInit, pKeyExNatOpen->_abNonce, sizeof(pSecReg->_abNonceInit)) != 0);
                return;
            }

            // Capture the return address information from the sender, and retransmit the key exchange
            // initiator packet.  The hope is that the sender will have programmed his NAT to allow
            // this packet to get through.  It is still not guaranteed to get through, however, if our
            // NAT is agressively assigning ports and the other side is port filtering.

            pSecReg->_ipaDst    = ipaSrc;
            pSecReg->_ipportDst = ipportSrc;

            // Retransmit the key exchange initiator packet right now (instead of waiting for the
            // timeout to expire).  The second argument tells IpXmitKeyExXbToXb to not send a
            // CKeyExNatOpen message this time.  Sending it now could cause a storm of packets
            // flowing if communication is one-sided (i.e. this side can receive but not
            // transmit).

            IpXmitKeyExXbToXb(pSecReg, TRUE);
            return;
        }

        //@@@ Handle KNOF_XBTOXB_PROBE here
    }

    TraceSz4(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d type %04X is invalid (wFlags %04X)",
             ipaSrc.Str(), NTOHS(ipportSrc), pKeyExNatOpen->_wType, pKeyExNatOpen->_wFlags);
    return;
}

void CXnIp::IpRecvKeyExSgToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExSgToXbResp * pKeyExSgToXbResp, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(pKeyExSgToXbResp->_wType == KEYEX_TYPE_SGTOXB_RESP);
    Assert(cbKeyEx >= pKeyExSgToXbResp->_cbEnt);

    if (pKeyExSgToXbResp->_cbEnt != sizeof(CKeyExSgToXbResp))
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d entry has an incorrect size (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), pKeyExSgToXbResp->_cbEnt, sizeof(CKeyExSgToXbResp));
        return;
    }

    CSecReg * pSecReg = SecRegLookup(pKeyExSgToXbResp->_dwSpiInit);

    if (pSecReg == NULL)
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d to unregistered address %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pKeyExSgToXbResp->_dwSpiInit).Str());
        return;
    }

    if (!pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d to non online-server address %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pKeyExSgToXbResp->_dwSpiInit).Str());
        return;
    }

    if (pSecReg->_bState != SR_STATE_INITSENT)
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d to %s while not in ISENT state",
                 ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
        return;
    }

    Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExSgToXbResp->_abNonceInit));

    if (memcmp(pSecReg->_abNonceInit, pKeyExSgToXbResp->_abNonceInit, sizeof(pSecReg->_abNonceInit)) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d has incorrect nonce",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    // Advance to the next entry.  It must contain the diffie-hellman g^X value.

    cbKeyEx -= pKeyExSgToXbResp->_cbEnt;
    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExSgToXbResp + pKeyExSgToXbResp->_cbEnt);

    if (    cbKeyEx < sizeof(CKeyExHdr)
        ||  pKeyExDh->_wType != KEYEX_TYPE_DH_GX
        ||  pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1
        ||  pKeyExDh->_cbEnt > cbKeyEx)
    {
        TraceSz6(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d DH entry is invalid (%d,%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc),
                 cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_wType != KEYEX_TYPE_DH_GX,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt > cbKeyEx);
        return;
    }

    // Advance to the next entry.  It must contain the KERB_APREP and it must also be the last entry.

    cbKeyEx -= pKeyExDh->_cbEnt;
    CKeyExHdr * pKeyExApRep = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    if (cbKeyEx < sizeof(CKeyExHdr) || pKeyExApRep->_cbEnt != cbKeyEx)
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d ApRep entry is invalid (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExApRep->_cbEnt != cbKeyEx);
        return;
    }

    // Crack the ApRep 

    BYTE *  pbKeyHmac;          // Key to use to compute HMAC-SHA of key-exchange message
    UINT    cbKeyHmac;          // Size of pbKeyHmac
    BYTE *  pbShaApRep;         // HMAC-SHA from the AP reply
    UINT    cbShaApRep;         // Size of pbShaApRep
    BYTE *  pbDhX;              // Diffie-hellman X
    UINT    cbDhX;              // Size of pbDhX

#ifdef XNET_FEATURE_ONLINE

    XOKERBINFO *    pxokerbinfo;
    BYTE            abShaApRep[XC_SERVICE_DIGEST_SIZE];

    if (pKeyExApRep->_wType == KEYEX_TYPE_KERB_APREP)
    {
        pxokerbinfo = _pXoBase ? _pXoBase->XoKerbGetInfo(pSecReg->_dwServiceId) : NULL;

        if (pxokerbinfo == NULL)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d cannot find XOKERBINFO for service %08lX",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->_dwServiceId);
            return;
        }

        if (!_pXoBase->XoKerbCrackApRep(pSecReg->_dwServiceId, &pSecReg->_liTime, abShaApRep,
                                        sizeof(abShaApRep), (BYTE *)(pKeyExApRep + 1),
                                        pKeyExApRep->_cbEnt - sizeof(CKeyExHdr)))
        {
            TraceSz2(Warning, "[DISCARD] KeyExSgToXbResp from %s:%d XoKerbCrackApRep failed",
                     ipaSrc.Str(), NTOHS(ipportSrc));
            return;
        }

        pbKeyHmac  = pxokerbinfo->_abKey;
        cbKeyHmac  = sizeof(pxokerbinfo->_abKey);
        pbShaApRep = abShaApRep;
        cbShaApRep = sizeof(abShaApRep);
        pbDhX      = pxokerbinfo->_abDhX;
        cbDhX      = sizeof(pxokerbinfo->_abDhX);

        goto ApRepDone;
    }
#endif

#ifdef XNET_FEATURE_INSECURE

    if (pKeyExApRep->_wType == KEYEX_TYPE_NULL_APREP)
    {
        CKeyExNullApRep * pKeyExNullApRep = (CKeyExNullApRep *)pKeyExApRep;

        if (pKeyExNullApRep->_cbEnt != sizeof(CKeyExNullApRep))
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d NULL_APREP has invalid size (%d bytes)",
                     ipaSrc.Str(), NTOHS(ipportSrc), pKeyExApRep->_cbEnt);
            return;
        }

        if (pSecReg->_dwServiceId != 0)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d NULL_APREP unexpected for service %08lX",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->_dwServiceId);
            return;
        }

        pbKeyHmac   = _abKeyNull;
        cbKeyHmac   = sizeof(_abKeyNull);
        pbShaApRep  = pKeyExNullApRep->_abSha;
        cbShaApRep  = sizeof(pKeyExNullApRep->_abSha);
        pbDhX       = _abDhXNull;
        cbDhX       = sizeof(_abDhXNull);

        goto ApRepDone;
    }

#endif

    TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d APREP type (%d) not supported",
             ipaSrc.Str(), NTOHS(ipportSrc), pKeyExApRep->_wType);
    return;

ApRepDone:

    // Authenticate the key exchange message (all entries except the last).

    BYTE abSha[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pbKeyHmac, cbKeyHmac, (BYTE *)pKeyExSgToXbResp, (BYTE *)pKeyExApRep - (BYTE *)pKeyExSgToXbResp,
           NULL, 0, abSha);

    Assert(cbShaApRep <= sizeof(abSha));

    if (memcmp(abSha, pbShaApRep, cbShaApRep) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d failed to authenticate",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    if (pKeyExSgToXbResp->_dwFlags & SXRF_ENCRYPT_DES)
        pSecReg->_cbKeyDesRecv = pSecReg->_cbKeyDesXmit = XC_SERVICE_DES_KEYSIZE;
    else if (pKeyExSgToXbResp->_dwFlags & SXRF_ENCRYPT_3DES)
        pSecReg->_cbKeyDesRecv = pSecReg->_cbKeyDesXmit = XC_SERVICE_DES3_KEYSIZE;
    else
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d unrecognized encryption",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

#if DBG
    if (Tag(keyExDrop) && pSecReg->_bRetry == SecRegRexmitRetries(pSecReg))
    {
        // Drop the first key-exchange response for testing purposes
        TraceSz(pktWarn, "[DISCARD] Dropping first KeyExSgToXbResp (debug only)");
        return;
    }
#endif

    pSecReg->_dwSpiXmit           = pKeyExSgToXbResp->_dwSpiResp;
    pSecReg->_dwTickPulseTimeout  = pKeyExSgToXbResp->_wXbToSgPulseTimeoutInSecs * TICKS_PER_SECOND;
    pSecReg->_dwTickTimeout       = pKeyExSgToXbResp->_wXbToSgTimeoutInSecs * TICKS_PER_SECOND;
    pSecReg->_sgaddr              = pKeyExSgToXbResp->_sgaddrInit;
    pSecReg->_ipaNat              = pKeyExSgToXbResp->_inaInit.s_addr;
    pSecReg->_ipportNat           = pKeyExSgToXbResp->_wPortInit;

    Assert(sizeof(pSecReg->_abNonceResp) == sizeof(pKeyExSgToXbResp->_abNonceResp));
    memcpy(pSecReg->_abNonceResp, pKeyExSgToXbResp->_abNonceResp, sizeof(pSecReg->_abNonceResp));

    SecRegSetKey(pSecReg, pbKeyHmac, cbKeyHmac, pbDhX, cbDhX, (BYTE *)(pKeyExDh + 1),
                 pKeyExDh->_cbEnt - sizeof(CKeyExHdr), TRUE);

    pSecReg->_bState = SR_STATE_INITWAIT;
    TimerSet(&pSecReg->_timer, TIMER_INFINITE);

    if (pSecReg == _pSecRegLogon)
    {
        Assert(_uiLogonState == XN_LOGON_STATE_PENDING);

        _uiLogonState = XN_LOGON_STATE_ONLINE;

        if (_pEventLogon)
        {
            EvtSet(_pEventLogon, EVENT_INCREMENT);
        }
    }

    // We must respond with to the initiator.  If there are waiting packets, send those now.
    // Otherwise, send a SECMSG_TYPE_PULSE to let the other side know we're alive.

    if (pSecReg->_pqWait.IsEmpty())
        IpXmitSecMsg(pSecReg, SECMSG_TYPE_PULSE);
    else
        SecRegXmitQueue(pSecReg);
}

#endif

void CXnIp::IpRecvSecMsg(CPacket * ppkt, CSecReg * pSecReg, DWORD dwSeq, CSecMsgHdr * pSecMsgHdr, UINT cb)
{
    ICHECK(IP, UDPC|SDPC);
    
    if (cb < sizeof(CSecMsgHdr) || cb != pSecMsgHdr->_cbEnt)
    {
        TraceSz3(pktWarn, "[DISCARD] SecMsg to %s has wrong size (%d,%d)",
                 pSecReg->Str(), cb < sizeof(CSecMsgHdr),
                 cb >= sizeof(CSecMsgHdr) && cb != pSecMsgHdr->_cbEnt);
        return;
    }

    TraceSz3(pktRecv, "[SecMsg %s %04X]{+%d}", pSecReg->Str(), pSecMsgHdr->_wType, pSecMsgHdr->_cbEnt - sizeof(CSecMsgHdr));

    if (pSecMsgHdr->_wType == SECMSG_TYPE_DELETE)
    {
        if (cb != sizeof(CSecMsgDelete))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_DELETE to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        // The other side has disconnected from us.  Reset the CSecReg so that KeyEx will
        // be reinitiated next time a packet is transmitted.

        if (!pSecReg->TestFlags(SRF_OWNED))
            SecRegFree(pSecReg);
        else
            SecRegSetIdle(pSecReg);

        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_PULSE)
    {
        if (cb != sizeof(CSecMsgPulse))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_PULSE to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        // Nothing else to do with this message.  It was only sent to let us know that the
        // other side is still alive.

        return;
    }

#ifdef XNET_FEATURE_SG

    if (pSecMsgHdr->_wType == SECMSG_TYPE_SGTOXB_PULSE)
    {
        if (cb < sizeof(CSecMsgSgToXbPulse))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_SGTOXB_PULSE to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        if (pSecReg == _pSecRegLogon)
        {
            CSecMsgSgToXbPulse * pSecMsgSgToXbPulse = (CSecMsgSgToXbPulse *)pSecMsgHdr;

            if (pSecMsgSgToXbPulse->_dwSeqAck && pSecMsgSgToXbPulse->_dwSeqAck >= _dwSeqXbToSg)
            {
                _dwSeqXbToSg = 0;
                *(DWORD *)_abXbToSgPulse = 0;
            }

            cb -= sizeof(CSecMsgSgToXbPulse);

            if (cb > 0)
            {
                BYTE * pb = (BYTE *)(pSecMsgSgToXbPulse + 1);

                while (cb > 0)
                {
                    BYTE b = *pb++;
                    cb -= 1;

                    if ((b & ~(SGPULSE_USER_INDEX_MASK|SGPULSE_QFLAGS_CHANGE)) != 0)
                    {
                        TraceSz2(pktWarn, "SecMsg SECMSG_TYPE_SGTOXB_PULSE to %s has bad control byte (%02X)",
                                 pSecReg->Str(), b);
                        break;
                    }

                    if (b & SGPULSE_QFLAGS_CHANGE)
                    {
                        if (cb < 2*sizeof(DWORD))
                        {
                            TraceSz3(pktWarn, "SecMsg SECMSG_TYPE_SGTOXB_PULSE to %s ends prematurely (cb=%d,cbReq=%d)",
                                     pSecReg->Str(), cb, 2*sizeof(DWORD));
                            break;
                        }

                        DWORD dwQFlags = *(DWORD *)pb;
                        pb += sizeof(DWORD);
                        cb -= sizeof(DWORD);

                        DWORD dwSeqQFlags = *(DWORD *)pb;
                        pb += sizeof(DWORD);
                        cb -= sizeof(DWORD);

                        XOUSERINFO * pxouserinfo = &_axouserinfo[b & SGPULSE_USER_INDEX_MASK];

                        if (pxouserinfo->_dwSeqQFlags < dwSeqQFlags)
                        {
                            pxouserinfo->_dwSeqQFlags = dwSeqQFlags;
                            pxouserinfo->_dwQFlags    = dwQFlags;

                            if (_pEventLogon)
                            {
                                EvtSet(_pEventLogon, EVENT_INCREMENT);
                            }
                        }
                    }
                }

                _dwSeqSgToXb = dwSeq;
            }
        }

        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOXB_FORWARD)
    {
        if (cb < sizeof(CSecMsgXbToXbForward))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_XBTOXB_FORWARD to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        if (pSecReg != _pSecRegLogon)
        {
            TraceSz4(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_XBTOXB_FORWARD to %s received %s%s",
                     pSecReg->Str(), _pSecRegLogon ? "from wrong SG (expected " : "while offline",
                     _pSecRegLogon ? _pSecRegLogon->Str() : "", _pSecRegLogon ? ")" : "");
            return;
        }

        CSecMsgXbToXbForward * pSecMsgXbToXbForward = (CSecMsgXbToXbForward *)pSecMsgHdr;

        Assert(pSecReg->TestFlags(SRF_ONLINESERVER));
        Assert(memcmp(&pSecMsgXbToXbForward->_sgaddr, &pSecReg->_sgaddr, sizeof(SGADDR)) == 0);

        IpRecvKeyEx(ppkt, 0, 0, (CKeyExHdr *)(pSecMsgXbToXbForward + 1), cb - sizeof(CSecMsgXbToXbForward));
        return;
    }

#endif

    TraceSz3(pktWarn, "[DISCARD] SecMsg to %s has unrecognized type (%d, cb=%d)",
             pSecReg->Str(), pSecMsgHdr->_wType, pSecMsgHdr->_cbEnt - sizeof(CSecMsgHdr));
    return;
}

// ---------------------------------------------------------------------------------------
// CXnIp (Xmit)
// ---------------------------------------------------------------------------------------

void CXnIp::IpXmit(CPacket * ppkt, CRouteEntry ** pprte)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(ppkt->IsIp());

    ppkt->Validate();

    CIpHdr * pIpHdr = ppkt->GetIpHdr();
    CIpAddr  ipaDst = pIpHdr->_ipaDst;

    if (ipaDst.IsLoopback() || ipaDst == _ipa)
    {
        Assert(!ppkt->IsEsp());
        pIpHdr->_ipaSrc = ipaDst;
        IpXmitIp(ppkt, pprte);
        return;
    }

    if (ppkt->IsEsp())
    {
        if (ipaDst.IsBroadcast())
        {
            IpXmitEsp(ppkt, NULL, NULL);
            return;
        }

        CSecReg * pSecReg = SecRegLookup(ipaDst);
        
        if (pSecReg == NULL)
        {
            TraceSz1(pktWarn, "[DISCARD] %s is not a registered secure address", ipaDst.Str());
            EnetXmit(ppkt, 0);
            return;
        }

        if (pSecReg->IsXmitReady())
        {
            IpXmitEsp(ppkt, pSecReg, pprte);
            return;
        }

#ifdef XNET_FEATURE_SG

        if (pSecReg->TestFlags(SRF_ONLINESERVER) && _uiLogonState != XN_LOGON_STATE_ONLINE)
        {
            TraceSz2(pktWarn, "[DISCARD] Secure packet to %s %s", ipaDst.Str(),
                     _uiLogonState == XN_LOGON_STATE_IDLE ? "before XOnlineLogon" :
                     _uiLogonState == XN_LOGON_STATE_PENDING ? "before XOnlineLogon has connected" :
                     "after XOnlineLogon connection lost");
            EnetXmit(ppkt, 0);
            return;
        }

#endif

        SecRegEnqueue(pSecReg, ppkt);
        return;
    }

#ifdef XNET_FEATURE_INSECURE
    if (cfgFlags & XNET_STARTUP_BYPASS_SECURITY)
    {
        ppkt->SetFlags(PKTF_XMIT_INSECURE);
    }
#endif

#if defined(XNET_FEATURE_INSECURE) || defined(XNET_FEATURE_ICMP) || defined(XNET_FEATURE_DHCP) || defined(XNET_FEATURE_DNS) || defined(XNET_FEATURE_ONLINE)

    if (ppkt->TestFlags(PKTF_XMIT_INSECURE))
    {
        pIpHdr->_ipaSrc = _ipa;
        IpXmitIp(ppkt, pprte);
        return;
    }

#endif

    TraceSz1(pktWarn, "[DISCARD] %s is not a registered secure address", ipaDst.Str());
    EnetXmit(ppkt, 0);
}

void CXnIp::IpXmitEsp(CPacket * ppkt, CSecReg * pSecReg, CRouteEntry ** pprte)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(ppkt->IsIp());

    ppkt->Validate();

    CIpHdr *    pIpHdr   = ppkt->GetIpHdr();
    CEspHdr *   pEspHdr  = ppkt->GetEspHdr();
    CEspTail *  pEspTail = ppkt->GetEspTail();
    CEnetHdr *  pEnetHdr = ppkt->GetEnetHdr();
    BYTE *      pbKeySha;
    UINT        cbKeySha;
    BYTE *      pbKeyDes;
    UINT        cbKeyDes;
    BYTE *      pb;
    UINT        cb;

    if (pSecReg == NULL)
    {
        ppkt->SetFlags(PKTF_XMIT_FRAME);

        pEnetHdr->_eaSrc = _ea;
        pEnetHdr->_eaDst.SetBroadcast();
        pEnetHdr->_wType = ENET_TYPE_IP;

        pIpHdr->_ipaSrc = IPADDR_SECURE_DEFAULT;
        Assert(pIpHdr->_ipaDst.IsBroadcast());

        pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
        pEspHdr->_dwSpi     = 0xFFFFFFFF;
        pEspHdr->_dwSeq     = 0xFFFFFFFF;

        pbKeySha = _abKeyShaLan;
        cbKeySha = sizeof(_abKeyShaLan);
        pbKeyDes = _abKeyDesLan;
        cbKeyDes = sizeof(_abKeyDesLan);
    }
    else
    {
#ifdef XNET_FEATURE_SG
        if (pSecReg->TestFlags(SRF_ONLINESERVER|SRF_ONLINEPEER))
        {
            pIpHdr->_ipaSrc = _ipa;
        }
        else
#endif
        {
            pIpHdr->_ipaSrc = IPADDR_SECURE_DEFAULT;

            ppkt->SetFlags(PKTF_XMIT_FRAME);

            pEnetHdr->_eaDst = *(CEnetAddr *)pSecReg->_xnaddr.abEnet;
            pEnetHdr->_eaSrc = _ea;
            pEnetHdr->_wType = ENET_TYPE_IP;
        }

        Assert(pSecReg->_ipaDst != 0 && pSecReg->_ipportDst != 0);

        pIpHdr->_ipaDst     = pSecReg->_ipaDst;
        pEspHdr->_ipportDst = pSecReg->_ipportDst;
        pEspHdr->_dwSpi     = pSecReg->_dwSpiXmit;
        pEspHdr->_dwSeq     = HTONL(++pSecReg->_dwSeqXmit);

        pbKeySha = pSecReg->_abKeyShaXmit;
        cbKeySha = sizeof(pSecReg->_abKeyShaXmit);
        pbKeyDes = pSecReg->_abKeyDesXmit;
        cbKeyDes = pSecReg->_cbKeyDesXmit;

        pSecReg->_dwTickXmit = TimerTick();
    }

    Assert(!!(cbKeyDes != 0) == !!ppkt->IsCrypt());
    Assert(pIpHdr->GetOptLen() == 0);

    pb = (BYTE *)(pEspHdr + 1);
    cb = ppkt->GetCb() - sizeof(CIpHdr) - sizeof(CEspHdr) - sizeof(pEspTail->_abHash);

    Assert(cb == ROUNDUP4(cb));

    ppkt->Validate();

    pEspTail->_bNextHeader = pIpHdr->_bProtocol;
    pIpHdr->_bProtocol     = IPPROTOCOL_UDP;
    pEspHdr->_ipportSrc    = ESPUDP_CLIENT_PORT;
    pEspHdr->_wLen         = HTONS(ppkt->GetCb() - sizeof(CIpHdr));

    if (ppkt->IsCrypt())
    {
        // Encrypt the packet from just after the [ESP] header to just before the _abHash in [ESPT]

        if (pSecReg == NULL)
            Rand(pb, XC_SERVICE_DES_BLOCKLEN);
        else
            memcpy(pb, pSecReg->_abIv, XC_SERVICE_DES_BLOCKLEN);

        Assert(cb == ROUNDUP8(cb));

        CryptDes(XC_SERVICE_ENCRYPT, pbKeyDes, cbKeyDes,
                 pb, pb + XC_SERVICE_DES_BLOCKLEN, cb - XC_SERVICE_DES_BLOCKLEN);

        if (pSecReg)
        {
            // Remember the last DES block to initialize the next packet's IV.  This logically
            // extends the cipher-block-chaining and prevents us from having to call Rand
            // for each packet.

            memcpy(pSecReg->_abIv, pb + cb - XC_SERVICE_DES_BLOCKLEN, XC_SERVICE_DES_BLOCKLEN);
        }
    }

    // Authenicate the packet from the [ESP] header to just before the _abHash in [ESPT]

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    Assert(sizeof(pEspTail->_abHash) <= sizeof(abHash));

    XcHMAC(pbKeySha, cbKeySha, (BYTE *)&pEspHdr->_dwSpi, (sizeof(CEspHdr) - sizeof(CUdpHdr)) + cb,
           NULL, 0, abHash);
    memcpy(pEspTail->_abHash, abHash, sizeof(pEspTail->_abHash));

    TraceSz4(pktXmit, "[ESP %s #%d]%s[%d][ESPT]",
             CIpAddr(pEspHdr->_dwSpi).Str(), NTOHL(pEspHdr->_dwSeq),
             ppkt->TestFlags(PKTF_CRYPT) ? "[IV]" : "",
             cb - offsetof(CEspTail, _abHash) - (ppkt->TestFlags(PKTF_CRYPT) ? XC_SERVICE_DES_BLOCKLEN : 0));

    IpXmitIp(ppkt, pprte);
}

void CXnIp::IpXmitKeyEx(CSecReg * pSecReg)
{
    if (pSecReg->_bState == SR_STATE_IDLE)
    {
        pSecReg->_bState = SR_STATE_INITSENT;
        pSecReg->_bRetry = SecRegRexmitRetries(pSecReg);
        SecRegSetTicks(pSecReg);
        Rand(pSecReg->_abNonceInit, sizeof(pSecReg->_abNonceInit));
        TimerSet(&pSecReg->_timer, TimerTick() + SecRegRexmitTimeoutInSeconds(pSecReg) * TICKS_PER_SECOND);
    }

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        IpXmitKeyExXbToSg(pSecReg);
        return;
    }
#endif

    IpXmitKeyExXbToXb(pSecReg);
}

void CXnIp::IpXmitKeyExXbToXb(CSecReg * pSecReg, BOOL fInhibitNatOpen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(pSecReg->_bState == SR_STATE_INITSENT || pSecReg->_bState == SR_STATE_RESPSENT);
    Assert(pSecReg->_bState != SR_STATE_INITSENT || pSecReg->TestFlags(SRF_OWNED));

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINEPEER) && _uiLogonState != XN_LOGON_STATE_ONLINE)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExXbToXb%s to online-peer %s while offline",
                 pSecReg->_bState == SR_STATE_INITSENT ? "Init" : "Resp", pSecReg->Str());
        return;
    }
#endif

    UINT cbKeyEx = sizeof(CKeyExXbToXb) + sizeof(CKeyExHdr) + CBDHG1 + sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE;

    CPacket * ppkt = PacketAlloc(PTAG_CKeyExPacket, PKTF_TYPE_UDP|PKTF_POOLALLOC, sizeof(DWORD) + cbKeyEx);

    if (ppkt == NULL)
    {
        TraceSz(Warning, "IpXmitKeyExXbToXb - Out of memory allocating packet");
        return;
    }

    CEnetHdr *  pEnetHdr  = ppkt->GetEnetHdr();
    CIpHdr *    pIpHdr    = ppkt->GetIpHdr();
    CEspHdr *   pEspHdr   = (CEspHdr *)(pIpHdr + 1);

    IpFillHdr(ppkt, 0, IPPROTOCOL_UDP);

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINEPEER))
    {
        pIpHdr->_ipaSrc = _ipa;

        if (pSecReg->_ipaDst != 0)
        {
            // We've received a packet directly from the other side at least once, so we'll
            // send the response back there.

            Assert(pSecReg->_ipaDst != 0 && pSecReg->_ipportDst != 0);

            pIpHdr->_ipaDst     = pSecReg->_ipaDst;
            pEspHdr->_ipportDst = pSecReg->_ipportDst;
        }
        else if (pSecReg->_xnaddr.inaOnline.s_addr == _pSecRegLogon->_ipaNat)
        {
            // The other side has the same IP address as this side from the perspective
            // of the security gateways.  This implies that the two sides are behind the same
            // NAT, so we should address packets to the inner IP address behind the NAT (i.e.
            // the actual IP address of the xbox).

            Assert(pSecReg->_xnaddr.ina.s_addr != 0);

            pIpHdr->_ipaDst     = pSecReg->_xnaddr.ina.s_addr;
            pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
        }
        else
        {
            // Our best guess is to send a packet to the return IP address and port that the
            // security gateway the other side is connected to is reporting as its return address.
            // Depending on how strict a NAT device is in front of the xbox, if any, this
            // packet may or may not make it through.

            Assert(pSecReg->_xnaddr.inaOnline.s_addr != 0 && pSecReg->_xnaddr.wPortOnline != 0);

            pIpHdr->_ipaDst     = pSecReg->_xnaddr.inaOnline.s_addr;
            pEspHdr->_ipportDst = pSecReg->_xnaddr.wPortOnline;
        }

        if (    pSecReg->_bState == SR_STATE_INITSENT
            &&  pSecReg->_bRetry < cfgKeyExXbToXbRexmitRetries
            &&  pSecReg->_xnaddr.inaOnline.s_addr != _pSecRegLogon->_ipaNat
            && !fInhibitNatOpen)
        {
            // This is a retransmission of a key exchange initiator.  In case the other side
            // is behind a NAT (other than ours) that is not letting our packet through,
            // we'll transmit a CKeyExNatOpen message via the SG forwarding mechanism.  This
            // is guaranteed to arrive because every xbox that is online is maintaining a
            // bidirectional connection to a security gateway, and all security gateways have
            // direct access to each other.

            CKeyReg *       pKeyReg = pSecReg->_pKeyReg;
            CKeyExNatOpen   KeyExNatOpen;

            KeyExNatOpen._wType = KEYEX_TYPE_NATOPEN_INIT;
            KeyExNatOpen._cbEnt = sizeof(CKeyExNatOpen);
            KeyExNatOpen._xnkid = pSecReg->_pKeyReg->_xnkid;
            KeyExNatOpen._dwCtx = pSecReg->_dwSpiRecv;

            Assert(sizeof(KeyExNatOpen._abNonce) == sizeof(pSecReg->_abNonceInit));
            memcpy(KeyExNatOpen._abNonce, pSecReg->_abNonceInit, sizeof(KeyExNatOpen._abNonce));

            KeyExNatOpen._ipaDst    = _pSecRegLogon->_ipaNat;
            KeyExNatOpen._ipportDst = _pSecRegLogon->_ipportNat;
            KeyExNatOpen._wFlags    = KNOF_XBTOXB_KEYEX;

            Assert(sizeof(KeyExNatOpen._abHash) == XC_SERVICE_DIGEST_SIZE);
            XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)&KeyExNatOpen,
                   offsetof(CKeyExNatOpen, _abHash), NULL, 0, KeyExNatOpen._abHash);

            TraceSz3(secStat, "Sending KeyExNatOpen INIT/%04X packet to %s via SGADDR %s",
                     KeyExNatOpen._wFlags, pSecReg->Str(),
                     HexStr(pSecReg->_xnaddr.abOnline, sizeof(pSecReg->_xnaddr.abOnline)));

            IpXmitSecMsg(_pSecRegLogon, SECMSG_TYPE_XBTOXB_FORWARD,
                         pSecReg->_xnaddr.abOnline, sizeof(pSecReg->_xnaddr.abOnline),
                         &KeyExNatOpen, sizeof(CKeyExNatOpen));
        }
    }
    else
#endif
    {
        ppkt->SetFlags(PKTF_XMIT_FRAME);

        pEnetHdr->_eaDst    = *(CEnetAddr *)pSecReg->_xnaddr.abEnet;
        pEnetHdr->_eaSrc    = _ea;
        pEnetHdr->_wType    = ENET_TYPE_IP;

        pIpHdr->_ipaSrc     = IPADDR_SECURE_DEFAULT;
        pIpHdr->_ipaDst     = IPADDR_SECURE_DEFAULT;
        pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
    }

    // Fill in the UDP header plus the SPI = 0 indicator of the ESP header

    pEspHdr->_wLen      = NTOHS(sizeof(CUdpHdr) + sizeof(DWORD) + cbKeyEx);
    pEspHdr->_ipportSrc = ESPUDP_CLIENT_PORT;
    pEspHdr->_wChecksum = 0;
    pEspHdr->_dwSpi     = 0;

    IpFillKeyExXbToXb(pSecReg, (CKeyExXbToXb *)&pEspHdr->_dwSeq);

    TraceSz4(secStat, "Sending KeyExXbToXb%s packet to %s via %s:%d",
             pSecReg->_bState == SR_STATE_INITSENT ? "Init" : "Resp", pSecReg->Str(),
             pIpHdr->_ipaDst.Str(), NTOHS(pEspHdr->_ipportDst));

    IpXmitIp(ppkt, NULL);
}

void CXnIp::IpFillKeyExXbToXb(CSecReg * pSecReg, CKeyExXbToXb * pKeyExXbToXb)
{
    memset(pKeyExXbToXb, 0, sizeof(CKeyExXbToXb));

    CKeyReg * pKeyReg = pSecReg->_pKeyReg;

    pKeyExXbToXb->_cbEnt   = sizeof(CKeyExXbToXb);
    pKeyExXbToXb->_xnkid   = pKeyReg->_xnkid;
    pKeyExXbToXb->_liTime  = _liTime;
    _liTime.QuadPart      += 1;

    if (pSecReg->_bState == SR_STATE_INITSENT)
    {
        pKeyExXbToXb->_wType     = KEYEX_TYPE_XBTOXB_INIT;
        pKeyExXbToXb->_dwSpiInit = pSecReg->_dwSpiRecv;

        Assert(sizeof(pKeyExXbToXb->_abNonceInit) == sizeof(pSecReg->_abNonceInit));
        memcpy(pKeyExXbToXb->_abNonceInit, pSecReg->_abNonceInit, sizeof(pKeyExXbToXb->_abNonceInit));

        IpGetXnAddr(&pKeyExXbToXb->_xnaddrInit);
        pKeyExXbToXb->_xnaddrResp = pSecReg->_xnaddr;
    }
    else
    {
        pKeyExXbToXb->_wType     = KEYEX_TYPE_XBTOXB_RESP;
        pKeyExXbToXb->_dwSpiInit = pSecReg->_dwSpiXmit;
        pKeyExXbToXb->_dwSpiResp = pSecReg->_dwSpiRecv;

        Assert(sizeof(pKeyExXbToXb->_abNonceInit) == sizeof(pSecReg->_abNonceInit));
        memcpy(pKeyExXbToXb->_abNonceInit, pSecReg->_abNonceInit, sizeof(pKeyExXbToXb->_abNonceInit));
        Assert(sizeof(pKeyExXbToXb->_abNonceResp) == sizeof(pSecReg->_abNonceResp));
        memcpy(pKeyExXbToXb->_abNonceResp, pSecReg->_abNonceResp, sizeof(pKeyExXbToXb->_abNonceResp));

        pKeyExXbToXb->_xnaddrInit = pSecReg->_xnaddr;
        IpGetXnAddr(&pKeyExXbToXb->_xnaddrResp);
    }

    // Encrypt the portion of this entry which contains the XNADDR structures to prevent
    // observers from seeing any addressing information

    Rand(pKeyExXbToXb->_abIv, sizeof(pKeyExXbToXb->_abIv));
    CryptDes(XC_SERVICE_ENCRYPT, pKeyReg->_abKeyDes, sizeof(pKeyReg->_abKeyDes),
             pKeyExXbToXb->_abIv, pKeyExXbToXb->_abIv + XC_SERVICE_DES_BLOCKLEN,
             sizeof(CKeyExXbToXb) - offsetof(CKeyExXbToXb, _abIv) - XC_SERVICE_DES_BLOCKLEN);

    // Fill in the DH key exchange entry next

    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExXbToXb + pKeyExXbToXb->_cbEnt);

    pKeyExDh->_wType = KEYEX_TYPE_DH_GX;
    pKeyExDh->_cbEnt = sizeof(CKeyExHdr) + CBDHG1;

    Assert(sizeof(pKeyReg->_abDhGX) == CBDHG1);
    memcpy(pKeyExDh + 1, pKeyReg->_abDhGX, CBDHG1);

    // Fill in the HMAC_SHA key exchange entry

    CKeyExHdr * pKeyExSha = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    pKeyExSha->_wType = KEYEX_TYPE_HMAC_SHA;
    pKeyExSha->_cbEnt = sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE;
    XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha),
           (BYTE *)pKeyExXbToXb, (BYTE *)pKeyExSha - (BYTE *)pKeyExXbToXb,
           NULL, 0, (BYTE *)(pKeyExSha + 1));
}

#ifdef XNET_FEATURE_SG

void CXnIp::IpXmitKeyExXbToSg(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(pSecReg->_bState == SR_STATE_INITSENT);

    BYTE *  pbKeyHmac;
    UINT    cbKeyHmac;
    BYTE *  pbDhGX;
    UINT    cbDhGX;
    UINT    cbApReqMax;
    DWORD   dwUserPerm;
    
#ifdef XNET_FEATURE_INSECURE

    if (pSecReg->_dwServiceId == 0)
    {
        pbKeyHmac  = _abKeyNull;
        cbKeyHmac  = sizeof(_abKeyNull);
        pbDhGX     = _abDhGXNull;
        cbDhGX     = sizeof(_abDhGXNull);
        cbApReqMax = sizeof(CKeyExNullApReq); 
        dwUserPerm = 0xE0A06020;

        goto ServiceDone;
    }

#endif

#ifdef XNET_FEATURE_ONLINE
    {
        XOKERBINFO * pxokerbinfo = _pXoBase ? _pXoBase->XoKerbGetInfo(pSecReg->_dwServiceId) : NULL;

        if (pxokerbinfo != NULL)
        {
            pbKeyHmac  = pxokerbinfo->_abKey;
            cbKeyHmac  = sizeof(pxokerbinfo->_abKey);
            pbDhGX     = pxokerbinfo->_abDhGX;
            cbDhGX     = sizeof(pxokerbinfo->_abDhGX);
            cbApReqMax = sizeof(CKeyExHdr) + pxokerbinfo->_cbApReqMax;
            dwUserPerm = pxokerbinfo->_dwUserPerm;
            
            goto ServiceDone;
        }
    }

#endif

    TraceSz2(Warning, "IpXmitKeyExXbToSgInit to %s service %08lX is invalid",
             pSecReg->Str(), pSecReg->_dwServiceId);
    return;

ServiceDone:

    UINT cbKeyEx = sizeof(CKeyExXbToSgInit) + sizeof(CKeyExHdr) + CBDHG1 + cbApReqMax;

    CPacket * ppkt = PacketAlloc(PTAG_CKeyExPacket, PKTF_TYPE_UDP|PKTF_POOLALLOC, sizeof(DWORD) + cbKeyEx);

    if (ppkt == NULL)
    {
        TraceSz1(Warning, "IpXmitKeyExXbToSgInit to %s - Out of memory allocating packet", pSecReg->Str());
        return;
    }

    CIpHdr *    pIpHdr    = ppkt->GetIpHdr();
    CEspHdr *   pEspHdr   = (CEspHdr *)(pIpHdr + 1);
    CKeyExHdr * pKeyExHdr = (CKeyExHdr *)&pEspHdr->_dwSeq;

    // Fill in the IP header

    IpFillHdr(ppkt, pSecReg->_ipaDst, IPPROTOCOL_UDP);
    pIpHdr->_ipaSrc = _ipa;

    // Fill in the UDP header plus the SPI = 0 indicator of the ESP header

    pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
    pEspHdr->_ipportSrc = ESPUDP_CLIENT_PORT;
    pEspHdr->_wChecksum = 0;
    pEspHdr->_dwSpi     = 0;

    // Fill in the first key exchange entry

    CKeyExXbToSgInit * pKeyExXbToSgInit = (CKeyExXbToSgInit *)pKeyExHdr;

    pKeyExXbToSgInit->_wType   = KEYEX_TYPE_XBTOSG_INIT;
    pKeyExXbToSgInit->_cbEnt   = sizeof(CKeyExXbToSgInit);
    pKeyExXbToSgInit->_dwFlags = 0;

#ifdef XNET_FEATURE_SG
    if (_pSecRegLogon == pSecReg)
    {
        pKeyExXbToSgInit->_dwFlags |= XSIF_CONNECTION_SERVICE;
    }
#endif

    pKeyExXbToSgInit->_dwSpiInit = pSecReg->_dwSpiRecv;
    pKeyExXbToSgInit->_dwUserPerm = dwUserPerm;

    Assert(sizeof(pKeyExXbToSgInit->_abNonceInit) == sizeof(pSecReg->_abNonceInit));
    memcpy(pKeyExXbToSgInit->_abNonceInit, pSecReg->_abNonceInit, sizeof(pKeyExXbToSgInit->_abNonceInit));

    // Fill in the DH key exchange entry next

    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExHdr + pKeyExHdr->_cbEnt);

    pKeyExDh->_wType = KEYEX_TYPE_DH_GX;
    pKeyExDh->_cbEnt = sizeof(CKeyExHdr) + CBDHG1;

    Assert(cbDhGX == CBDHG1);
    memcpy(pKeyExDh + 1, pbDhGX, CBDHG1);

    // Fill in the APREQ key exchange entry

    CKeyExHdr * pKeyExApReq = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    BYTE abSha[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pbKeyHmac, cbKeyHmac, (BYTE *)pKeyExXbToSgInit, (BYTE *)pKeyExApReq - (BYTE *)pKeyExXbToSgInit,
           NULL, 0, abSha);

#ifdef XNET_FEATURE_INSECURE

    if (pSecReg->_dwServiceId == 0)
    {
        CKeyExNullApReq * pKeyExNullApReq = (CKeyExNullApReq *)pKeyExApReq;

        pKeyExNullApReq->_wType  = KEYEX_TYPE_NULL_APREQ;
        pKeyExNullApReq->_cbEnt  = sizeof(CKeyExNullApReq);
        pKeyExNullApReq->_liTime = _liTime;
        _liTime.QuadPart += 1;

        Assert(sizeof(pKeyExNullApReq->_abSha) == sizeof(abSha));
        memcpy(pKeyExNullApReq->_abSha, abSha, sizeof(pKeyExNullApReq->_abSha));

        memset(&pKeyExNullApReq->_AuthData, 0, sizeof(pKeyExNullApReq->_AuthData));
        pKeyExNullApReq->_AuthData.SetCb(sizeof(pKeyExNullApReq->_AuthData));
        pKeyExNullApReq->_AuthData.wAuthDataVersion = XONLINE_AUTHDATA_VERSION;
        pKeyExNullApReq->_AuthData.dwAuthDataSize = sizeof(XKERB_AD_XBOX);

        #ifdef XNET_FEATURE_ONLINE
        if (_pXoBase)
        {
            _pXoBase->XoKerbGetAuthData(&pKeyExNullApReq->_AuthData);
        }
        else
        #endif
        {
            memset(&pKeyExNullApReq->_AuthData.qwXboxID, 0xAA, sizeof(pKeyExNullApReq->_AuthData.qwXboxID));
            memcpy(&pKeyExNullApReq->_AuthData.qwXboxID, _ea._ab, sizeof(_ea));

            XOUSERINFO * pxouserinfo    = _axouserinfo;
            XOUSERINFO * pxouserinfoEnd = _axouserinfo + dimensionof(_axouserinfo);
            XUID *       pxuid          = pKeyExNullApReq->_AuthData.users;

            Assert(dimensionof(_axouserinfo) == dimensionof(pKeyExNullApReq->_AuthData.users));

            for (; pxouserinfo < pxouserinfoEnd; ++pxouserinfo, ++pxuid)
            {
                pxuid->qwUserID = pxouserinfo->_qwUserId;
            }
        }

        goto ApReqDone;
    }

#endif

#ifdef XNET_FEATURE_ONLINE

    {
        UINT cbApReq = cbApReqMax - sizeof(CKeyExHdr);

        if (!_pXoBase->XoKerbBuildApReq(pSecReg->_dwServiceId, &pSecReg->_liTime, abSha, sizeof(abSha),
                                    (BYTE *)(pKeyExApReq + 1), &cbApReq))
        {
            TraceSz1(Warning, "IpXmitKeyExXbToSgInit to %s - XoKerbBuildApReq failed", pSecReg->Str());
            return;
        }

        pKeyExApReq->_wType = KEYEX_TYPE_KERB_APREQ;
        pKeyExApReq->_cbEnt = sizeof(CKeyExHdr) + cbApReq;
        goto ApReqDone;
    }

#endif

ApReqDone:

    // Shrink the size of the packet if the ApReq is smaller than the space allocated

    Assert(cbApReqMax >= pKeyExApReq->_cbEnt);

    UINT cbExtra = cbApReqMax - pKeyExApReq->_cbEnt;
    ppkt->SetCb(ppkt->GetCb() - cbExtra);
    pEspHdr->_wLen = HTONS(sizeof(CUdpHdr) + sizeof(DWORD) + cbKeyEx - cbExtra);
    pIpHdr->_wLen = HTONS(pIpHdr->GetLen() - cbExtra);

    TraceSz3(secStat, "Sending KeyExXbToSgInit packet to %s via %s:%d",
             pSecReg->Str(), pIpHdr->_ipaDst.Str(), NTOHS(pEspHdr->_ipportDst));

    IpXmitIp(ppkt, NULL);
}

#endif

void CXnIp::IpXmitSecMsg(CSecReg * pSecReg, WORD wType, void * pv1, UINT cb1, void * pv2, UINT cb2)
{
    ICHECK(IP, UDPC|SDPC);

    TraceSz3(secStat, "Sending SecMsg packet to %s (%04X, cb=%d)", pSecReg->Str(), wType, cb1+cb2);

    CPacket * ppkt = PacketAlloc(PTAG_CSecMsgPacket, PKTF_POOLALLOC|PKTF_TYPE_ESP|PKTF_CRYPT, sizeof(CSecMsgHdr) + cb1 + cb2);

    if (ppkt == NULL)
    {
        TraceSz(Warning, "IpXmitSecMsg - Out of memory allocating packet");
        return;
    }

    // Fill in the IP header

    IpFillHdr(ppkt, pSecReg->_dwSpiRecv, IPPROTOCOL_SECMSG);

    // Fill in the payload

    CSecMsgHdr * pSecMsgHdr = (CSecMsgHdr *)((BYTE *)ppkt->GetEspHdr() + sizeof(CEspHdr) + XC_SERVICE_DES_BLOCKLEN);

    pSecMsgHdr->_wType = wType;
    pSecMsgHdr->_cbEnt = sizeof(CSecMsgHdr) + cb1 + cb2;

    if (cb1 > 0)
    {
        memcpy(pSecMsgHdr + 1, pv1, cb1);
    }

    if (cb2 > 0)
    {
        memcpy((BYTE *)(pSecMsgHdr + 1) + cb1, pv2, cb2);
    }

    TraceSz2(pktXmit, "[SecMsg %04X]{+%d}", wType, cb1 + cb2);

    IpXmitEsp(ppkt, pSecReg, NULL);
}

void CXnIp::IpXmitSecMsgDelete(CSecReg * pSecReg, DWORD dwReason)
{
    ICHECK(IP, UDPC|SDPC);

    IpXmitSecMsg(pSecReg, SECMSG_TYPE_DELETE, &dwReason, sizeof(dwReason));
}

#ifdef XNET_FEATURE_SG

void CXnIp::IpXmitSecMsgXbToSgPulse(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    BYTE                    ab[sizeof(CSecMsgXbToSgPulse) + dimensionof(_axouserinfo) * (1 + sizeof(DWORD) + sizeof(XNKID) + 1 + sizeof(_axouserinfo[0]._abData))];
    DWORD                   dwSeqXmit           = pSecReg->_dwSeqXmit;
    CSecMsgXbToSgPulse *    pSecMsgXbToSgPulse  = (CSecMsgXbToSgPulse *)ab;
    BYTE *                  pb                  = &ab[sizeof(CSecMsgXbToSgPulse)];

    if (pSecReg == _pSecRegLogon)
    {
        pSecMsgXbToSgPulse->_dwSeqAck = _dwSeqSgToXb;

        if (*(DWORD *)_abXbToSgPulse != 0)
        {
            XOUSERINFO * pxouserinfo    = _axouserinfo;
            XOUSERINFO * pxouserinfoEnd = _axouserinfo + dimensionof(_axouserinfo);
            BYTE *       pbXbToSgPulse  = _abXbToSgPulse;

            for (; pxouserinfo < pxouserinfoEnd; ++pxouserinfo, ++pbXbToSgPulse)
            {
                BYTE b = *pbXbToSgPulse;

                if (b != 0)
                {
                    Assert((b &  (XBPULSE_USER_INDEX_MASK)) == pxouserinfo - _axouserinfo);
                    Assert((b & ~(XBPULSE_USER_INDEX_MASK|XBPULSE_STATE_CHANGE|XBPULSE_XNKID_CHANGE|XBPULSE_TDATA_CHANGE)) == 0);
                    Assert((b &  (XBPULSE_STATE_CHANGE|XBPULSE_XNKID_CHANGE|XBPULSE_TDATA_CHANGE)) != 0);

                    *pb++ = b;

                    if (b & XBPULSE_STATE_CHANGE)
                    {
                        *(DWORD *)pb = pxouserinfo->_dwPState;
                        pb += sizeof(DWORD);
                    }

                    if (b & XBPULSE_XNKID_CHANGE)
                    {
                        *(XNKID *)pb = pxouserinfo->_xnkid;
                        pb += sizeof(XNKID);
                    }

                    if (b & XBPULSE_TDATA_CHANGE)
                    {
                        Assert(pxouserinfo->_cbData <= sizeof(pxouserinfo->_abData));

                        *pb++ = (BYTE)pxouserinfo->_cbData;

                        if (pxouserinfo->_cbData > 0)
                        {
                            memcpy(pb, pxouserinfo->_abData, pxouserinfo->_cbData);
                            pb += pxouserinfo->_cbData;
                        }
                    }
                }
            }
        }
    }
    else
    {
        pSecMsgXbToSgPulse->_dwSeqAck = 0;
    }

    Assert(pb - ab <= sizeof(ab));

    IpXmitSecMsg(pSecReg, SECMSG_TYPE_XBTOSG_PULSE, &ab[sizeof(CSecMsgHdr)], pb - ab - sizeof(CSecMsgHdr));

    if (pSecReg->_dwSeqXmit > dwSeqXmit)
    {
        Assert(pSecReg->_dwSeqXmit == dwSeqXmit + 1);

        pSecReg->_dwTickPulse = TimerTick();

        if (pSecReg == _pSecRegLogon)
        {
            _dwSeqSgToXb = 0;

            if (*(DWORD *)_abXbToSgPulse != 0)
            {
                _dwSeqXbToSg = pSecReg->_dwSeqXmit;
            }
        }
    }
}

#endif

void CXnIp::IpXmitIp(CPacket * ppkt, CRouteEntry ** pprte)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(ppkt->IsIp());
    
    CIpHdr *        pIpHdr   = ppkt->GetIpHdr();
    CIpAddr         ipaDst   = pIpHdr->_ipaDst;
    UINT            cbHdrLen = pIpHdr->GetHdrLen();
    UINT            cbLen    = ppkt->GetCb();
    UINT            uiChecksum;
    CPseudoHeader   ph;

    Assert(pIpHdr->_ipaSrc != 0 || _ipa == 0);
    Assert(pIpHdr->_ipaDst != 0);

    TraceIpHdr(pktXmit, pIpHdr, ppkt->GetCb() - pIpHdr->GetHdrLen());

    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, cbHdrLen);

    if (ppkt->IsUdp() || ppkt->IsEsp())
    {
        CUdpHdr * pUdpHdr   = (CUdpHdr *)((BYTE *)pIpHdr + cbHdrLen);
        ph._ipaSrc          = pIpHdr->_ipaSrc;
        ph._ipaDst          = ipaDst;
        ph._bZero           = 0;
        ph._bProtocol       = IPPROTOCOL_UDP;
        ph._wLen            = HTONS(cbLen - cbHdrLen);
        pUdpHdr->_wChecksum = 0;
        uiChecksum          = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), pUdpHdr, cbLen - cbHdrLen);
        pUdpHdr->_wChecksum = uiChecksum - (uiChecksum == 0);
    }
#ifdef XNET_FEATURE_INSECURE
    else if (ppkt->IsTcp())
    {
        CTcpHdr * pTcpHdr   = (CTcpHdr *)((BYTE *)pIpHdr + cbHdrLen);
        ph._ipaSrc          = pIpHdr->_ipaSrc;
        ph._ipaDst          = ipaDst;
        ph._bZero           = 0;
        ph._bProtocol       = IPPROTOCOL_TCP;
        ph._wLen            = HTONS(cbLen - cbHdrLen);
        pTcpHdr->_wChecksum = 0;
        pTcpHdr->_wChecksum = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), pTcpHdr, cbLen - cbHdrLen);
    }
#endif

#ifdef XNET_FEATURE_ROUTE

    if (    !ppkt->TestFlags(PKTF_XMIT_FRAME)
        &&   ipaDst != _ipa
        &&  !ipaDst.IsLoopback()
        &&  !ipaDst.IsBroadcast())
    {
        CRouteEntry * prte = pprte ? *pprte : NULL;

        Assert(!prte || prte->_ipaDst == (ipaDst & prte->_ipaMask));

        if (prte == NULL || prte->IsOrphan())
        {
            if (prte)
            {
                RouteRelease(prte);
            }

            prte = RouteLookup(ipaDst);

            if (pprte)
            {
                *pprte = prte;
            }

            if (prte == NULL)
            {
                TraceSz1(pktWarn, "[DISCARD] No route found to %s", ipaDst.Str());
                EnetXmit(ppkt, 0);
                return;
            }
        }

        if (!prte->IsLocal())
        {
            ipaDst = prte->_ipaNext;
        }

        if (prte && pprte == NULL)
        {
            RouteRelease(prte);
        }
    }

#endif

#ifdef XNET_FEATURE_TRACE
    if (Tag(tcpRetrans) && ppkt->IsTcp() && ppkt->IsEsp() && ppkt->IsCrypt() && !ppkt->TestFlags(PKTF_XMIT_PRIORITY))
    {
        // This causes encrypted TCP packets to fail on first transmit, and it used to
        // test the decrypt-before-retransmit code path.

        ppkt->ClearFlags(PKTF_XMIT_FRAME);
        ipaDst = 0;
    }
#endif

    EnetXmit(ppkt, ipaDst);
    return;
}

// --------------------------------------------------------------------------------------
// CXnIp (Xmit Helpers)
// --------------------------------------------------------------------------------------

void CXnIp::IpFillAndXmit(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol, CRouteEntry ** pprte)
{
    ICHECK(IP, USER|UDPC|SDPC);
    IpFillHdr(ppkt, ipaDst, bProtocol);
    RaiseToDpc();
    IpXmit(ppkt, pprte);
}

void CXnIp::IpFillHdr(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol)
{
    ICHECK(IP, USER|UDPC|SDPC);
    Assert(ppkt->IsIp());
    Assert(ppkt->GetHdrOptLen() == 0);

    CIpHdr * pIpHdr = ppkt->GetIpHdr();
    pIpHdr->SetHdrLen(sizeof(CIpHdr));
    pIpHdr->_bTos       = cfgIpDefaultTos;
    pIpHdr->_wLen       = HTONS((WORD)ppkt->GetCb());
    pIpHdr->_wId        = HTONS(GetNextDgramId());
    pIpHdr->_wFragOff   = 0;
    pIpHdr->_bTtl       = cfgIpDefaultTtl;
    pIpHdr->_bProtocol  = bProtocol;
    pIpHdr->_ipaSrc     = 0;
    pIpHdr->_ipaDst     = ipaDst;
}

// ---------------------------------------------------------------------------------------
// CXnIp (Frag)
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_FRAG

class CFragPacket : public CPacket
{
    friend class CXnIp;

    CTimer      _timer;         // reassembly timeout timer
    CIpAddr     _ipaSrc;        // source IP address
    CIpAddr     _ipaDst;        // destination IP address
    DWORD       _dwProtoId;     // protocol and datagram ID
    UINT        _cbHdrLen;      // length of reassembled datagram header
    UINT        _cbLen;         // length of reassembled datagram payload
    UINT        _cBitRecv;      // number of chunks of payload received so far
    UINT        _cBitTotal;     // total number of chunks of payload expected
    UINT        _iBitEnd;       // highest bit position filled so far
    BYTE        _abBits[1];     // vector of bit flags for which payload fragments have arrived

    INLINE void SetBit(UINT iBit)
    {
        BYTE * pb = &_abBits[iBit / 8];
        UINT iMask = (1 << (iBit % 8));
        _cBitRecv += !(*pb & iMask);
        *pb |= iMask;
    }
};

void CXnIp::FragTerm()
{
    TCHECK(UDPC);

    while (_cFrag > 0)
    {
        FragFree(_pqFrag.GetHead());
    }
}

void CXnIp::FragFree(CPacket * ppkt)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt != NULL);
    Assert(_cFrag > 0);
    Assert(_cFrag == _pqFrag.Count());

    _pqFrag.Dequeue(ppkt);
    _cFrag -= 1;

    Assert(_cFrag == _pqFrag.Count());

    TimerSet(&((CFragPacket *)ppkt)->_timer, TIMER_INFINITE);

#ifdef XNET_FEATURE_FRAG_LOOPBACK
    ppkt->ClearFlags(PKTF_RECV_LOOPBACK);
#endif

    PacketFree(ppkt);
}

void CXnIp::FragTimer(CTimer * pt)
{
    ICHECK(IP, UDPC|SDPC);

    CFragPacket * ppktFrag = (CFragPacket *)((BYTE *)pt - offsetof(CFragPacket, _timer));
    TraceSz3(Warning, "FragTimer - Packet reassembly timeout [IP %s %s (%08lX)]",
             ppktFrag->_ipaDst.Str(), ppktFrag->_ipaSrc.Str(), ppktFrag->_dwProtoId);
    FragFree(ppktFrag);
}

void CXnIp::FragRecv(CPacket * ppkt, CIpHdr * pIpHdr, UINT cbHdrLen, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    CFragPacket *   ppktFrag;
    DWORD           dwProtoId;
    UINT            uiFragOff;
    BOOL            fMoreFrag;
    UINT            cbPkt;
    UINT            ibEnd;
    UINT            iBit, iBitEnd;

    uiFragOff  = NTOHS(pIpHdr->_wFragOff);
    fMoreFrag  = !!(uiFragOff & MORE_FRAGMENTS);
    uiFragOff &= (uiFragOff & FRAGOFFSET_MASK);
    dwProtoId  = (NTOHS(pIpHdr->_wId) << 16) | pIpHdr->_bProtocol;
    ppktFrag   = (CFragPacket *)_pqFrag.GetHead();

    for (; ppktFrag; ppktFrag = (CFragPacket *)ppktFrag->GetNextPkt())
    {
        if (    ppktFrag->_dwProtoId == dwProtoId
            &&  ppktFrag->_ipaSrc == pIpHdr->_ipaSrc
            &&  ppktFrag->_ipaDst == pIpHdr->_ipaDst)
            break;
    }
    
    if (ppktFrag == NULL)
    {
        if (_cFrag >= cfgIpFragMaxSimultaneous)
        {
            TraceSz(pktWarn, "[DISCARD] Too many fragmented IP datagrams needing reassembly");
            return;
        }

        cbPkt  = offsetof(CFragPacket, _abBits);
        cbPkt += ((cfgIpFragMaxPacketDiv256 * 256) / 8 + 7) / 8;
        cbPkt  = ROUNDUP4(cbPkt);

        ppktFrag = (CFragPacket *)PacketAlloc(PTAG_CFragPacket, PKTF_TYPE_ENET|PKTF_POOLALLOC,
                                              cfgIpFragMaxPacketDiv256 * 256,
                                              cbPkt, (PFNPKTFREE)FragFree);

        if (ppktFrag == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] Out of memory allocating CFragPacket");
            return;
        }

#ifdef XNET_FEATURE_FRAG_LOOPBACK
        if (ppkt->TestFlags(PKTF_RECV_LOOPBACK))
        {
            ppktFrag->SetFlags(PKTF_RECV_LOOPBACK);
        }
#endif

        ppktFrag->_timer.Init((PFNTIMER)FragTimer);
        ppktFrag->_ipaSrc    = pIpHdr->_ipaSrc;
        ppktFrag->_ipaDst    = pIpHdr->_ipaDst;
        ppktFrag->_dwProtoId = dwProtoId;
        ppktFrag->_cbHdrLen  = 0;
        ppktFrag->_cbLen     = 0;
        ppktFrag->_cBitRecv  = 0;
        ppktFrag->_cBitTotal = 0;
        ppktFrag->_iBitEnd   = 0;
        memset(ppktFrag->_abBits, 0, cbPkt - offsetof(CFragPacket, _abBits));
        TimerSet(&ppktFrag->_timer, TimerTick() + cfgIpFragTimeoutInSeconds * TICKS_PER_SECOND);

        Assert(_cFrag == _pqFrag.Count());
        _pqFrag.InsertTail(ppktFrag);
        _cFrag += 1;
        Assert(_cFrag == _pqFrag.Count());
    }

    if (uiFragOff == 0)
    {
        if (ppktFrag->_cbHdrLen > 0)
        {
            if (ppktFrag->_cbHdrLen != cbHdrLen)
            {
                TraceSz2(pktWarn, "[DISCARD] Duplicate first fragment and header sizes don't match (%d vs. %d)",
                         ppktFrag->_cbHdrLen, cbHdrLen);
                goto fragfree;
            }

            TraceSz(pktWarn, "[DISCARD] Ignoring duplicate first fragment");
            return;
        }

        memcpy((BYTE *)ppktFrag->GetPv() + MAXIPHDRLEN - cbHdrLen, pIpHdr, cbHdrLen);
        ppktFrag->_cbHdrLen = cbHdrLen;
    }

    cbLen -= cbHdrLen;

    if (cbLen > 0)
    {
        ibEnd   = (uiFragOff * 8) + cbLen;
        iBit    = uiFragOff;
        iBitEnd = iBit + (cbLen + 7) / 8;

        if (MAXIPHDRLEN + ibEnd > ppktFrag->GetCb())
        {
            TraceSz1(pktWarn, "[DISCARD] Maximum reassembly size exceeded (%d)", ibEnd);
            goto fragfree;
        }

        if (fMoreFrag)
        {
            if ((cbLen % 8) != 0)
            {
                TraceSz1(pktWarn, "[DISCARD] Fragment with MF flag has non 8-byte multiple payload (%d)", cbLen);
                goto fragfree;
            }
        }
        else
        {
            if (ppktFrag->_cbLen == 0)
            {
                if (ppktFrag->_iBitEnd >= iBitEnd)
                {
                    TraceSz(pktWarn, "[DISCARD] Fragments received past end of last fragment");
                    goto fragfree;
                }

                ppktFrag->_cbLen     = ibEnd;
                ppktFrag->_cBitTotal = iBitEnd;
            }
            else if (ppktFrag->_cbLen != ibEnd)
            {
                TraceSz2(pktWarn, "[DISCARD] Last fragment was duplicated and has a different size (%d vs. %d)",
                         ppktFrag->_cbLen, ibEnd);
                goto fragfree;
            }
        }

        memcpy((BYTE *)ppktFrag->GetPv() + MAXIPHDRLEN + (uiFragOff * 8), (BYTE *)pIpHdr + cbHdrLen, cbLen);

        if (ppktFrag->_cBitTotal && iBitEnd > ppktFrag->_cBitTotal)
        {
            TraceSz(pktWarn, "[DISCARD] Fragment received past end of last fragment");
            goto fragfree;
        }

        if (ppktFrag->_iBitEnd < iBitEnd)
            ppktFrag->_iBitEnd = iBitEnd;

        for (; iBit < iBitEnd; ++iBit)
        {
            ppktFrag->SetBit(iBit);
            Assert(ppktFrag->_cBitTotal == 0 || ppktFrag->_cBitRecv <= ppktFrag->_cBitTotal);
        }
    }

    if (ppktFrag->_cbHdrLen && ppktFrag->_cbLen && ppktFrag->_cBitRecv == ppktFrag->_cBitTotal)
    {
        ppktFrag->SetPv((BYTE *)ppktFrag->GetPv() + MAXIPHDRLEN - ppktFrag->_cbHdrLen);
        ppktFrag->SetCb(ppktFrag->_cbHdrLen + ppktFrag->_cbLen);
        ppktFrag->SetType(PKTF_TYPE_IP);

        pIpHdr              = ppktFrag->GetIpHdr();
        pIpHdr->_wLen       = HTONS((WORD)ppktFrag->GetCb());
        pIpHdr->_wFragOff   = 0;
        pIpHdr->_wChecksum  = 0;
        pIpHdr->_wChecksum  = (WORD)~tcpipxsum(0, pIpHdr, ppktFrag->_cbHdrLen);

        TraceSz(pktRecv, "Fragment processing complete.  Processing reassembled packet.");
        IpRecv(ppktFrag);
        goto fragfree;
    }

    TraceSz4(pktRecv, "[FRAGHOLD] Waiting for more fragments (cbHdrLen=%ld,cBitRecv=%ld,cBitTotal=%ld,cbLen=%ld)",
             ppktFrag->_cbHdrLen, ppktFrag->_cBitRecv, ppktFrag->_cBitTotal, ppktFrag->_cbLen);
    return;

fragfree:
    FragFree(ppktFrag);
    return;
}

#endif // XNET_FEATURE_FRAG

// ---------------------------------------------------------------------------------------
// CXnIp (Route)
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ROUTE

NTSTATUS CXnIp::RouteInit()
{
    TCHECK(USER);

    InitializeListHead(&_leRouteList);
    Assert(_ipaDstLast == 0);
    Assert(_prteLast == NULL);

    return(NETERR_OK);
}

void CXnIp::RouteTerm()
{
    TCHECK(UDPC);
    RouteListOrphan();
}

void CXnIp::RouteInvalidateCache()
{
    ICHECK(IP, UDPC|SDPC);
    _ipaDstLast = 0;
    _prteLast = NULL;
}

void CXnIp::RouteListOrphan()
{
    ICHECK(IP, UDPC|SDPC);

    if (!IsListNull(&_leRouteList))
    {
        CRouteEntry * prte = (CRouteEntry *)_leRouteList.Flink;
        CRouteEntry * prteNext;

        while (prte != (CRouteEntry *)&_leRouteList)
        {
            prteNext = (CRouteEntry *)prte->_le.Flink;
            RouteEntryOrphan(prte);
            prte = prteNext;
        }
    }
}

void CXnIp::RouteEntryOrphan(CRouteEntry * prte)
{
    ICHECK(IP, UDPC|SDPC);

    RouteInvalidateCache();

    AssertListEntry(&_leRouteList, &prte->_le);
    RemoveEntryList(&prte->_le);

    prte->SetFlags(RTEF_ORPHAN);
    RouteRelease(prte);
}

CRouteEntry * CXnIp::RouteLookup(CIpAddr ipaDst)
{
    ICHECK(IP, UDPC|SDPC);

    CRouteEntry *    prte;
    CRouteEntry *    prteNext;
    CRouteEntry *    prteFound;

    if (ipaDst == 0)
    {
        return(NULL);
    }

    if (ipaDst == _ipaDstLast)
    {
        // _prteLast may be NULL if the last successful lookup for this IP address
        // failed to find any route for it.  RouteAdd will invalidate the cache
        // and force a slow lookup.  Until then, quickly keep responding that
        // there is no route entry for this IP address.

        if (_prteLast)
            _prteLast->AddRef();

        return(_prteLast);
    }

    prte = (CRouteEntry *)_leRouteList.Flink;
    prteFound = NULL;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if ((ipaDst & prte->_ipaMask) == prte->_ipaDst)
        {
            prteFound = prte;
            prte->AddRef();
            break;
        }

        prte = prteNext;
    }

    _ipaDstLast = ipaDst;
    _prteLast = prteFound;

    return(prteFound);
}

void CXnIp::RouteAdd(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext, WORD wFlags, WORD wMetric)
{
    ICHECK(IP, UDPC|SDPC);

    CRouteEntry *    prte;
    CRouteEntry *    prteNext;
    CRouteEntry *    prteNew;

    // Validate input parameters:
    //  - address mask must be of the form 111...000
    //      be careful about the byte order
    //  - next hop address cannot be a broadcast address

    ipaDst = ipaDst & ipaMask;

    if (    (!ipaDst.IsValidUnicast() && !(wFlags & RTEF_DEFAULT))
        ||  !ipaNext.IsValidUnicast()
        ||  !ipaMask.IsValidMask())
    {
        TraceSz1(Warning, "Bad route to %s:", ipaDst.Str());
        TraceSz1(Warning, "  mask = %s", ipaMask.Str());
        TraceSz1(Warning, "  nexthop = %s", ipaNext.Str());
        return;
    }

    // Find out if the specified route is already in the table
    
    AssertList(&_leRouteList);

    prte    = (CRouteEntry *)_leRouteList.Flink;
    prteNew = NULL;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if (    prte->_ipaDst == ipaDst
            &&  prte->_ipaMask == ipaMask
            &&  (ipaMask != 0 || prte->_ipaNext == ipaNext))
        {
            // Update the existing route information
            prteNew = prte;
            RemoveEntryList(&prte->_le);
            break;
        }

        prte = prteNext;
    }
    
    if (prteNew == NULL)
    {
        prteNew = (CRouteEntry *)PoolAllocZ(sizeof(CRouteEntry), PTAG_CRouteEntry);
        
        if (prteNew == NULL)
        {
            TraceSz(Warning, "CXnIp::RouteAdd - Out of memory allocating route entry");
            return;
        }

        prteNew->_cRefs = 1;
    }

    RouteInvalidateCache();

    prteNew->_wFlags  = wFlags;
    prteNew->_wMetric = wMetric;
    prteNew->_ipaDst  = ipaDst;
    prteNew->_ipaMask = ipaMask;
    prteNew->_ipaNext = ipaNext;

    // Insert the new route into the table
    //  sorted by the mask length and route metric

    AssertList(&_leRouteList);

    prte = (CRouteEntry *)_leRouteList.Flink;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if (    ipaMask > prte->_ipaMask
            ||  (   ipaMask == prte->_ipaMask
                 && wMetric < prte->_wMetric))
        {
            break;
        }

        prte = prteNext;
    }

    prteNew->_le.Flink = (LIST_ENTRY *)prte;
    prteNew->_le.Blink = prte->_le.Blink;
    prte->_le.Blink->Flink = (LIST_ENTRY *)prteNew;
    prte->_le.Blink = (LIST_ENTRY *)prteNew;

    AssertList(&_leRouteList);
}

void CXnIp::RouteDelete(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext)
{
    ICHECK(IP, UDPC|SDPC);

    CRouteEntry *    prte;
    CRouteEntry *    prteNext;

    RaiseToDpc();

    AssertList(&_leRouteList);

    prte = (CRouteEntry *)_leRouteList.Flink;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if (    prte->_ipaDst == ipaDst
            &&  prte->_ipaMask == ipaMask
            &&  prte->_ipaNext == ipaNext)
        {
            RouteEntryOrphan(prte);
            break;
        }

        prte = prteNext;
    }
}

void CXnIp::RouteRedirect(CIpAddr ipaDst, CIpAddr ipaOldGateway, CIpAddr ipaNewGateway)
{
    ICHECK(IP, SDPC);

    CRouteEntry * prte;

    // The redirected destination must be a unicast address
    if (!ipaDst.IsValidUnicast())
        return;

    // Validate the new gateway address:
    //  must be a unicast address on the same subnet
    //  through which the redirect message arrived
    if (    !ipaNewGateway.IsValidUnicast()
        ||  _ipaSubnet != (ipaNewGateway & _ipaMask))
        return;

    // Find the current route to the destination
    // and see if the sender of the redirect message
    // is the current next-hop gateway

    prte = RouteLookup(ipaDst);

    if (prte == NULL)
    {
        return;
    }
    else if (prte->_ipaNext != ipaOldGateway)
    {
        RouteRelease(prte);
        return;
    }

    // Add a new host route
    RouteAdd(ipaDst, 0xFFFFFFFF, ipaNewGateway, RTEF_HOST, RTE_DEFAULT_METRIC);
}

void CXnIp::RouteRelease(CRouteEntry * prte)
{
    ICHECK(IP, USER|UDPC|SDPC);

    if (InterlockedDecrement(&prte->_cRefs) == 0)
    {
        Assert(prte->IsOrphan());
        PoolFree(prte);
    }
}

#if DBG

void CXnIp::RouteListDump()
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();

    TraceSz(Verbose, "\n*** Route table:\n");

    CRouteEntry * prte = (CRouteEntry *)_leRouteList.Flink;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        TraceSz6(Verbose, "%s/%s/%s %02X %d %d", prte->_ipaDst.Str(), prte->_ipaMask.Str(),
                 prte->_ipaNext.Str(), prte->_wFlags, prte->_wMetric, prte->_cRefs);
        prte = (CRouteEntry *)prte->_le.Flink;
    }
}

#endif

#endif

// ---------------------------------------------------------------------------------------
// CXnIp (Register / Unregister Key)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey)
{
    ICHECK(IP, USER);

#ifdef XNET_FEATURE_SG
    if (!XNetXnKidIsSystemLink(pxnkid) && !XNetXnKidIsOnlinePeer(pxnkid))
#else
    if (!XNetXnKidIsSystemLink(pxnkid))
#endif
    {
        TraceSz1(Warning, "IpRegisterKey - XNKID %s is not peer-to-peer", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEINVAL);
    }

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    BYTE abDhX[CBDHG1];
    BYTE abDhGX[CBDHG1];

    // HMAC the key with the LAN keys as a precaution against the title not keeping
    // its key private (by sending it in cleartext over the network, for example).
    // This means that even if you intercept an XNKEY you still need to figure
    // out the LAN key to make use of it.

    XcHMAC(_abKeyShaLan, sizeof(_abKeyShaLan), (BYTE *)pxnkid->ab, sizeof(pxnkid->ab),
           (BYTE *)pxnkey->ab, sizeof(pxnkey->ab), abHash);

    // Generate a diffie-hellman X and g^X for use in key-exchange

    Rand(abDhX, sizeof(abDhX));
    XcModExp((DWORD *)abDhGX, (DWORD *)g_abOakleyGroup1Base, (DWORD *)abDhX,
             (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));

    RaiseToDpc();

    CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

    if (pKeyReg != NULL)
    {
        TraceSz1(Warning, "IpRegisterKey - XNKID %s is already registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEALREADY);
    }

    if (_cKeyReg == cfgKeyRegMax)
    {
        TraceSz1(Warning, "IpRegisterKey - Reached config limit for key registrations (%d)", cfgKeyRegMax);
        return(WSAENOMORE);
    }

    pKeyReg = &_pKeyReg[_cKeyReg++];
    pKeyReg->_xnkid = *pxnkid;
    memcpy(pKeyReg->_abKeySha, abHash, sizeof(pKeyReg->_abKeySha));
    memcpy(pKeyReg->_abKeyDes, &abHash[sizeof(abHash) - sizeof(pKeyReg->_abKeyDes)], sizeof(pKeyReg->_abKeyDes));
    memcpy(pKeyReg->_abDhX, abDhX, sizeof(pKeyReg->_abDhX));
    memcpy(pKeyReg->_abDhGX, abDhGX, sizeof(pKeyReg->_abDhGX));
    XcDESKeyParity(pKeyReg->_abKeyDes, sizeof(pKeyReg->_abKeyDes));
    pKeyReg->_pQosReg = NULL;

    TraceSz1(secStat, "XNKID %s: Registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));

    return(0);
}

INT CXnIp::IpCreateKey(XNKID * pxnkid, XNKEY * pxnkey)
{
    ICHECK(IP, USER|UDPC);
    Rand((BYTE *)pxnkid, sizeof(XNKID));
    Rand((BYTE *)pxnkey, sizeof(XNKEY));
    pxnkid->ab[0] &= ~XNET_XNKID_MASK;
    pxnkid->ab[0] |=  XNET_XNKID_SYSTEM_LINK;
    return(0);
}

INT CXnIp::IpUnregisterKey(const XNKID * pxnkid)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

    if (pKeyReg == NULL)
    {
        TraceSz1(Warning, "IpUnregisterKey - XNKID %s is not registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEINVAL);
    }

#if 0
//@@@
    if (pKeyReg->_pbQos)
    {
        SysFree(pKeyReg->_pbQos);
        pKeyReg->_pbQos = NULL;
        pKeyReg->_cbQos = 0;
    }
#endif

    TraceSz1(secStat, "XNKID %s: Unregistered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));

    CKeyReg *   pKeyRegLast = &_pKeyReg[--_cKeyReg];
    UINT        cSecReg     = cfgSecRegMax;
    CSecReg *   pSecReg     = _pSecReg;

    // Move the last entry to this spot to keep the table contiguous

    *pKeyReg = *pKeyRegLast;

    // Free any CSecReg that points at the deleted key entry.  Update any CSecReg that
    // pointed to the last CKeyReg that was just moved.

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv)
        {
            if (pSecReg->_pKeyReg == pKeyReg)
            {
                if (pSecReg->IsXmitReady() && !pSecReg->TestFlags(SRF_SECMSG_DELETE))
                {
                    pSecReg->SetFlags(SRF_SECMSG_DELETE);
                    IpXmitSecMsgDelete(pSecReg, SECMSG_DELETE_UNREGISTER);
                }

                SecRegFree(pSecReg);
            }
            else if (pSecReg->_pKeyReg == pKeyRegLast)
            {
                pSecReg->_pKeyReg = pKeyReg;
            }
        }
    }

    return(0);
}

// ---------------------------------------------------------------------------------------
// CXnIp (KeyRegLookup / KeyRegKey)
// ---------------------------------------------------------------------------------------

CXnIp::CKeyReg * CXnIp::KeyRegLookup(const XNKID * pxnkid)
{
    ICHECK(IP, UDPC|SDPC);

    CKeyReg *   pKeyReg = _pKeyReg;
    UINT        cKeyReg = _cKeyReg;

    for (; cKeyReg-- > 0; ++pKeyReg)
    {
        if (memcmp(pKeyReg->_xnkid.ab, pxnkid->ab, sizeof(XNKID)) == 0)
        {
            return(pKeyReg);
        }
    }

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// CXnIp (DES Encrypt / Decrypt)
// ---------------------------------------------------------------------------------------

void CXnIp::CryptDes(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb, UINT cb)
{
    Assert(cbKey == XC_SERVICE_DES_KEYSIZE || cbKey == XC_SERVICE_DES3_KEYSIZE);
    BYTE abDesTable[XC_SERVICE_DES3_TABLESIZE];
    BYTE abFeedback[XC_SERVICE_DES_BLOCKLEN];

    XcKeyTable(cbKey == XC_SERVICE_DES_KEYSIZE ? XC_SERVICE_DES_CIPHER : XC_SERVICE_DES3_CIPHER,
               abDesTable, pbKey);
    memcpy(abFeedback, pbIv, XC_SERVICE_DES_BLOCKLEN);
    XcBlockCryptCBC(cbKey == XC_SERVICE_DES_KEYSIZE ? XC_SERVICE_DES_CIPHER : XC_SERVICE_DES3_CIPHER,
                    cb, pb, pb, abDesTable, dwOp, abFeedback);
}

// ---------------------------------------------------------------------------------------
// CXnIp (InAddr)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, CIpAddr * pipa)
{
    ICHECK(IP, USER);

    // The InAddr for the local host is the loopback address

    if (_ea.IsEqual(pxna->abEnet))
    {
        *pipa = IPADDR_LOOPBACK;
        return(0);
    }

#ifdef XNET_FEATURE_SG

    if (XNetXnKidIsOnlinePeer(pxnkid) && pxna->inaOnline.s_addr == 0)
    {
        TraceSz2(Warning, "IpXnAddrToInAddr - XNKID %s is online-peer but XNADDR %s is system-link",
                 HexStr(pxnkid->ab, sizeof(pxnkid->ab)), XnAddrStr(pxna));
        return(WSAEINVAL);
    }

#endif

    RaiseToDpc();

    // See if we have a CSecReg already for this XNADDR and XNKID

    CSecReg * pSecReg = SecRegLookup(pxna, pxnkid);

    if (pSecReg == NULL)
    {
        CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

        if (pKeyReg == NULL)
        {
            TraceSz1(Warning, "IpXnAddrToInAddr - XNKID %s is not registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
            return(WSAEINVAL);
        }

        pSecReg = SecRegAlloc(pxna, pKeyReg);

        if (pSecReg == NULL)
        {
            return(WSAENOMORE);
        }
    }
    else
    {
        // Update the XNADDR of the CSecReg in case it has been updated with new
        // online information.

        pSecReg->_xnaddr = *pxna;
    }

    pSecReg->SetFlags(SRF_OWNED);

    *pipa = CIpAddr(pSecReg->_dwSpiRecv);

    return(0);
}

INT CXnIp::IpServerToInAddr(const CIpAddr ipa, DWORD dwServiceId, CIpAddr * pipa)
{
    ICHECK(IP, USER);

    if (!ipa.IsValidUnicast())
    {
        TraceSz1(Warning, "IpServerToInAddr - %s is not a valid unicast IP address", ipa.Str());
        return(WSAEINVAL);
    }

    RaiseToDpc();

#ifdef XNET_FEATURE_SG

    XOKERBINFO * pxokerbinfo;

#ifdef XNET_FEATURE_INSECURE

    if (dwServiceId == 0)
    {
        pxokerbinfo = NULL;
        goto ServiceDone;
    }

#endif

#ifdef XNET_FEATURE_ONLINE

    pxokerbinfo = _pXoBase ? _pXoBase->XoKerbGetInfo(dwServiceId) : NULL;

    if (pxokerbinfo != NULL)
        goto ServiceDone;

#endif

#endif

    TraceSz1(Warning, "IpServerToInAddr - dwServiceId %08lX is not available", dwServiceId);
    return(WSAEINVAL);

#ifdef XNET_FEATURE_SG

ServiceDone:

    // See if we have a CSecReg already for this XNADDR and XOKERBINFO

    CSecReg * pSecReg = SecRegLookup(ipa, dwServiceId, pxokerbinfo);

    if (pSecReg == NULL)
    {
        pSecReg = SecRegAlloc(ipa, dwServiceId);

        if (pSecReg == NULL)
        {
            return(WSAENOMORE);
        }
    }

    *pipa = CIpAddr(pSecReg->_dwSpiRecv);

    return(0);

#endif

}

INT CXnIp::IpInAddrToXnAddr(const CIpAddr ipa, XNADDR * pxna, XNKID * pxnkid)
{
    ICHECK(IP, USER|UDPC|SDPC);

    if (pxna)
    {
        memset(pxna, 0, sizeof(XNADDR));
    }

    if (pxnkid)
    {
        memset(pxnkid, 0, sizeof(XNKID));
    }

    if (ipa == IPADDR_LOOPBACK)
    {
        if (pxna)
        {
            IpGetXnAddr(pxna);
        }

        return(0);
    }

    RaiseToDpc();

    CSecReg * pSecReg = ipa.IsSecure() ? SecRegLookup(ipa) : NULL;

    if (pSecReg == NULL)
    {
        TraceSz1(Warning, "IpInAddrToXnAddr - %s is not a registered secure address", ipa.Str());
        return(WSAEINVAL);
    }

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        TraceSz1(Warning, "IpInAddrToXnAddr - %s is a secure address to a server.  Cannot convert to XNADDR.", ipa.Str());
        return(WSAEINVAL);
    }
#endif

    if (pxna)
    {
        *pxna = pSecReg->_xnaddr;
    }

    if (pxnkid)
    {
        *pxnkid = pSecReg->_pKeyReg->_xnkid;
    }

    return(0);
}

INT CXnIp::IpUnregisterInAddr(const CIpAddr ipa)
{
    ICHECK(IP, USER|UDPC|SDPC);
    
    RaiseToDpc();

    CSecReg * pSecReg = ipa.IsSecure() ? SecRegLookup(ipa) : NULL;

    if (pSecReg == NULL)
    {
        TraceSz1(Warning, "IpUnregisterInAddr - %s is not a registered secure address", ipa.Str());
        return(WSAEINVAL);
    }
    
#ifdef XNET_FEATURE_SG

    if (pSecReg == _pSecRegLogon)
    {
        TraceSz1(Warning, "IpUnregisterInAddr - %s cannot be manually unregistered", ipa.Str());
        return(WSAEINVAL);
    }

#endif

    if (pSecReg->_bState == SR_STATE_RESPSENT)
    {
        // The other side is in initiating key-exchange with us, so just forget that we have
        // seen this secure address.

        pSecReg->ClearFlags(SRF_OWNED);
    }
    else
    {
        // Shutdown the security association and let the other side know if necessary.

        if (pSecReg->IsXmitReady() && !pSecReg->TestFlags(SRF_SECMSG_DELETE))
        {
            IpXmitSecMsgDelete(pSecReg, SECMSG_DELETE_SHUTDOWN);
        }

        SecRegFree(pSecReg);
    }

    return(0);
}

// ---------------------------------------------------------------------------------------
// CXnIp (SecRegLookup / SecRegAlloc / SecRegFree)
// ---------------------------------------------------------------------------------------

CXnIp::CSecReg * CXnIp::SecRegLookup(const XNADDR * pxna, const XNKID * pxnkid)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0 || pSecReg->TestFlags(SRF_ONLINESERVER))
            continue;

        if (memcmp(pSecReg->_xnaddr.abEnet, pxna->abEnet, sizeof(CEnetAddr)) != 0)
            continue;

        if (memcmp(&pSecReg->_pKeyReg->_xnkid, pxnkid, sizeof(XNKID)) != 0)
            continue;

        return(pSecReg);
    }

    return(NULL);
}

#ifdef XNET_FEATURE_SG

CXnIp::CSecReg * CXnIp::SecRegLookup(const CIpAddr ipa, DWORD dwServiceId, const XOKERBINFO * pxokerbinfo)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0 || !pSecReg->TestFlags(SRF_ONLINESERVER))
            continue;

        if (pSecReg->_ipaDst != ipa)
            continue;

        if (pSecReg->_dwServiceId == dwServiceId)
            return(pSecReg);

#ifdef XNET_FEATURE_ONLINE
        XOKERBINFO * pxokerbinfoReg = _pXoBase ? _pXoBase->XoKerbGetInfo(pSecReg->_dwServiceId) : NULL;
        if (pxokerbinfoReg && pxokerbinfo->_dwTicketId == pxokerbinfoReg->_dwTicketId)
            return(pSecReg);
#endif
    }

    return(NULL);
}

#endif

CXnIp::CSecReg * CXnIp::SecRegLookup(DWORD dwSpiRecv)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg * pSecReg = NULL;

    if (_pSecReg && CIpAddr(dwSpiRecv).IsSecure())
    {
        UINT uiSlot = CIpAddr(dwSpiRecv).SecureSlot();

        if (uiSlot < cfgSecRegMax)
        {
            pSecReg = &_pSecReg[uiSlot];

            if (pSecReg->_dwSpiRecv != dwSpiRecv)
            {
                pSecReg = NULL;
            }
        }
    }

    return(pSecReg);
}

CXnIp::CSecReg * CXnIp::SecRegAlloc()
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0)
            break;
    }

    if (cSecReg == 0)
    {
        TraceSz1(Warning, "Reached config limit for secure address registrations (%d)", cfgSecRegMax);
        return(NULL);
    }

    pSecReg->_timer.Init((PFNTIMER)SecRegTimer);

    if (++_wSecRegUniq == 0)
        ++_wSecRegUniq;

    CIpAddr ipa(_wSecRegUniq, (BYTE)(pSecReg - _pSecReg));

    pSecReg->_dwSpiRecv = ipa;

    TraceSz1(secStat, "Allocated %s", pSecReg->Str());

    return(pSecReg);
}

CXnIp::CSecReg * CXnIp::SecRegAlloc(const XNADDR * pxna, CKeyReg * pKeyReg)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg * pSecReg = SecRegAlloc();

    if (pSecReg != NULL)
    {
        pSecReg->_wFlags       = SRF_SYSTEMLINK;
        pSecReg->_xnaddr       = *pxna;
        pSecReg->_pKeyReg      = pKeyReg;
        pSecReg->_cbKeyDesRecv = XC_SERVICE_DES_KEYSIZE;
        pSecReg->_cbKeyDesXmit = XC_SERVICE_DES_KEYSIZE;
        pSecReg->_ipaDst       = IPADDR_SECURE_DEFAULT;
        pSecReg->_ipportDst    = ESPUDP_CLIENT_PORT;

#ifdef XNET_FEATURE_SG
        // For an online peer we don't know for sure the address to send packets until the
        // key exchange process is complete.  During key exchange, the _ipaDst, _ipportDst,
        // and _ipportSrc fields of the CSecReg are updated as return address information
        // becomes available.

        if (XNetXnKidIsOnlinePeer(&pKeyReg->_xnkid))
        {
            pSecReg->_wFlags    = SRF_ONLINEPEER;
            pSecReg->_ipaDst    = 0;
            pSecReg->_ipportDst = 0;
        }
#endif
    }

    return(pSecReg);
}

#ifdef XNET_FEATURE_SG

CXnIp::CSecReg * CXnIp::SecRegAlloc(const CIpAddr ipa, DWORD dwServiceId)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg * pSecReg = SecRegAlloc();

    if (pSecReg != NULL)
    {
        pSecReg->_wFlags       = SRF_ONLINESERVER|SRF_OWNED;
        pSecReg->_dwServiceId  = dwServiceId;
        pSecReg->_cbKeyDesRecv = XC_SERVICE_DES3_KEYSIZE;
        pSecReg->_cbKeyDesXmit = XC_SERVICE_DES3_KEYSIZE;
        pSecReg->_ipaDst       = ipa;
        pSecReg->_ipportDst    = ESPUDP_CLIENT_PORT;
    }

    return(pSecReg);
}

#endif

void CXnIp::SecRegFree(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    if (pSecReg->_dwSpiRecv)
    {
        TraceSz1(secStat, "Deallocated %s", pSecReg->Str());
        SecRegSetIdle(pSecReg);
        memset(pSecReg, 0, sizeof(CSecReg));
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp (SecReg state machine)
// ---------------------------------------------------------------------------------------

void CXnIp::SecRegEnqueue(CSecReg * pSecReg, CPacket * ppkt)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(     pSecReg->_bState == SR_STATE_IDLE
           ||   pSecReg->_bState == SR_STATE_INITSENT
           ||   pSecReg->_bState == SR_STATE_RESPSENT);

    if (pSecReg->_bState == SR_STATE_IDLE)
    {
        IpXmitKeyEx(pSecReg);
    }

    // Insert the packet into the wait queue until we make it into the ready state

    pSecReg->_pqWait.InsertTail(ppkt);

    TraceSz2(secStat, "Packet enqueued to %s (%d waiting)", pSecReg->Str(), pSecReg->_pqWait.Count());
}

void CXnIp::SecRegXmitQueue(CSecReg * pSecReg)
{
    if (!pSecReg->_pqWait.IsEmpty())
    {
        TraceSz3(secStat, "Sending %d waiting packet%s to %s",
                 pSecReg->_pqWait.Count(), pSecReg->_pqWait.Count() == 1 ? "" : "s", pSecReg->Str());

        do
        {
            CPacket * ppkt = pSecReg->_pqWait.RemoveHead();
            IpXmit(ppkt, NULL);
        }
        while (!pSecReg->_pqWait.IsEmpty());
    }
}

void CXnIp::SecRegShutdown(BOOL fOnlineOnly)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0)
            continue;

        if (fOnlineOnly && !pSecReg->TestFlags(SRF_ONLINEPEER|SRF_ONLINESERVER))
            continue;

        if (pSecReg->IsXmitReady() && !pSecReg->TestFlags(SRF_SECMSG_DELETE))
        {
            pSecReg->SetFlags(SRF_SECMSG_DELETE);
            IpXmitSecMsgDelete(pSecReg, SECMSG_DELETE_SHUTDOWN);
        }

        if (fOnlineOnly)
        {
            SecRegFree(pSecReg);
        }
    }
}

void CXnIp::SecRegSetIdle(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    // Tell the sockets layer that this secure IP address has being disconnected.
    // Any TCP socket connected to this address will be reset.

    SockReset(CIpAddr(pSecReg->_dwSpiRecv));

    pSecReg->_wFlags   &= SRF_SYSTEMLINK|SRF_ONLINEPEER|SRF_ONLINESERVER|SRF_OWNED;
    pSecReg->_bState    = SR_STATE_IDLE;
    pSecReg->_bRetry    = 0;
    pSecReg->_dwSeqXmit = 0;
    pSecReg->_dwSeqRecv = 0;
    pSecReg->_dwSeqMask = 0;
    memset(pSecReg->_abNonceInit, 0, sizeof(pSecReg->_abNonceInit));
    memset(pSecReg->_abNonceResp, 0, sizeof(pSecReg->_abNonceResp));
    Rand(pSecReg->_abIv, sizeof(pSecReg->_abIv));
    TimerSet(&pSecReg->_timer, TIMER_INFINITE);
    pSecReg->_pqWait.Complete(this);
    SecRegSetTicks(pSecReg);

#ifdef XNET_FEATURE_SG
    if (pSecReg->_wFlags & SRF_ONLINEPEER)
    {
        pSecReg->_ipaDst    = 0;
        pSecReg->_ipportDst = 0;
    }

    if (_pSecRegLogon == pSecReg && _uiLogonState != XN_LOGON_STATE_IDLE)
    {
        _uiLogonState = XN_LOGON_STATE_OFFLINE;

        if (_pEventLogon)
        {
            EvtSet(_pEventLogon, EVENT_INCREMENT);
        }
    }

#endif
}

void CXnIp::SecRegSetTicks(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    pSecReg->_dwTickRecv         = TimerTick();
    pSecReg->_dwTickXmit         = TimerTick();
    pSecReg->_dwTickPulse        = TimerTick();
    pSecReg->_dwTickPulseTimeout = cfgSecRegPulseTimeoutInSeconds * TICKS_PER_SECOND;
    pSecReg->_dwTickTimeout      = cfgSecRegTimeoutInSecondsDiv10 * 10 * TICKS_PER_SECOND;
}

void CXnIp::SecRegSetOwned(CIpAddr ipa)
{
    ICHECK(IP, USER|UDPC|SDPC);

    if (ipa.IsSecure())
    {
        RaiseToDpc();

        CSecReg * pSecReg = SecRegLookup(ipa);

        if (pSecReg != NULL)
        {
            pSecReg->SetFlags(SRF_OWNED);
        }
    }
}

void CXnIp::SecRegSetKey(CSecReg * pSecReg, BYTE * pbKeyHmac, UINT cbKeyHmac, BYTE * pbDhX, UINT cbDhX,
                         BYTE * pbDhGY, UINT cbDhGY, BOOL fInitiator)
{
    ICHECK(IP, UDPC|SDPC);

    BYTE abDhGXY[CBDHG1];

    // Generate the diffie-hellman g^XY mod p = (g^Y)^X mod p

    Assert(cbDhX == CBDHG1);
    Assert(cbDhGY == CBDHG1);
    XcModExp((DWORD *)abDhGXY, (DWORD *)pbDhGY, (DWORD *)pbDhX, (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));

    BYTE * pbKeyOut = fInitiator ? pSecReg->_abKeyShaXmit : pSecReg->_abKeyShaRecv;

    for (int i = 0; i < 2; ++i)
    {
        for (int j = 0; j < 2; ++j)
        {
            XcHMAC(pbKeyHmac, cbKeyHmac, abDhGXY, sizeof(abDhGXY), pSecReg->_abNonceInit,
                   sizeof(pSecReg->_abNonceInit) + sizeof(pSecReg->_abNonceResp), pbKeyOut);
            pbKeyOut += XC_SERVICE_DIGEST_SIZE;
            abDhGXY[0] += 1;
        }

        pbKeyOut = fInitiator ? pSecReg->_abKeyShaRecv : pSecReg->_abKeyShaXmit;
    }

    XcDESKeyParity(pSecReg->_abKeyDesXmit, sizeof(pSecReg->_abKeyDesXmit));
    XcDESKeyParity(pSecReg->_abKeyDesRecv, sizeof(pSecReg->_abKeyDesRecv));
}

void CXnIp::SecRegTimer(CTimer * pt)
{
    ICHECK(IP, SDPC);

    CSecReg * pSecReg = (CSecReg *)((BYTE *)pt - offsetof(CSecReg, _timer));

    Assert(pSecReg->_bState == SR_STATE_INITSENT || pSecReg->_bState == SR_STATE_RESPSENT);

    TraceSz2(secStat, "KeyEx timeout to %s (bRetry %d)", pSecReg->Str(), pSecReg->_bRetry);

    if (pSecReg->_bRetry == 0)
    {
        TraceSz3(secStat, "Failed KeyEx to %s (%d packet%s flushed)",
                 pSecReg->Str(), pSecReg->_pqWait.Count(),
                 pSecReg->_pqWait.Count() == 1 ? "" : "s");

        if (!pSecReg->TestFlags(SRF_OWNED))
            SecRegFree(pSecReg);
        else
            SecRegSetIdle(pSecReg);
    }
    else
    {
        pSecReg->_bRetry -= 1;
        TimerSet(&pSecReg->_timer, TimerTick() + SecRegRexmitTimeoutInSeconds(pSecReg) * TICKS_PER_SECOND);
        IpXmitKeyEx(pSecReg);
    }
}

void CXnIp::SecRegProbe()
{
    ICHECK(IP, SDPC);

    _cSecRegProbeNumer += cfgSecRegMax;

    if (_cSecRegProbeNumer < _cSecRegProbeDenom)
        return;

    DWORD dwTickNow = TimerTick();

    UINT cSecReg = _cSecRegProbeNumer / _cSecRegProbeDenom;
    _cSecRegProbeNumer -= cSecReg * _cSecRegProbeDenom;
    Assert(_cSecRegProbeNumer < _cSecRegProbeDenom);

    CSecReg * pSecReg     = _pSecRegProbe ? _pSecRegProbe : _pSecReg;
    CSecReg * pSecRegLast = _pSecReg + cfgSecRegMax;

    for (; cSecReg > 0; --cSecReg, ++pSecReg)
    {
        if (pSecReg == pSecRegLast)
        {
            // We've run off the end of the CSecReg vector.  Start back at the beginning.

            pSecReg = _pSecReg;
        }

        if (pSecReg->_dwSpiRecv == 0)
        {
            // This CSecReg is not in use.  Go on to the next one.

            continue;
        }

        if (pSecReg->_bState < SR_STATE_INITWAIT)
        {
            // This CSecReg is in the middle of key exchange.  That process handles its
            // own timeouts.  Go on to the next one.

            continue;
        }

        if (pSecReg->_dwTickRecv <= dwTickNow - pSecReg->_dwTickTimeout)
        {
            // This CSecReg hasn't received a packet in a long enough time that the other
            // side should be considered down.

            TraceSz2(secStat, "Timeout after %d secs of no incoming packets from %s",
                     (dwTickNow - pSecReg->_dwTickRecv) / TICKS_PER_SECOND, pSecReg->Str());

            if (!pSecReg->TestFlags(SRF_OWNED))
                SecRegFree(pSecReg);
            else
                SecRegSetIdle(pSecReg);

            continue;
        }

        DWORD dwTickPulse = dwTickNow - pSecReg->_dwTickPulseTimeout;

        if (pSecReg->_dwTickPulse <= dwTickPulse)
        {
            // This CSecReg hasn't sent a pulse in a long enough time that now might be
            // a good time to send it.  We only need to send it if there have been no
            // packets transmitted recently, or if we have something to say.

#ifdef XNET_FEATURE_SG
            if (pSecReg->TestFlags(SRF_ONLINESERVER))
            {
                if (    pSecReg->_dwTickXmit <= dwTickPulse
                    || (pSecReg == _pSecRegLogon && (_dwSeqSgToXb || *(DWORD *)_abXbToSgPulse)))
                {
                    TraceSz3(secStat, "Sending pulse to %s (last xmit/pulse %d/%d secs ago)",
                             pSecReg->Str(), (dwTickNow - pSecReg->_dwTickXmit) / TICKS_PER_SECOND,
                             (dwTickNow - pSecReg->_dwTickPulse) / TICKS_PER_SECOND);
                    IpXmitSecMsgXbToSgPulse(pSecReg);
                }
                continue;
            }
#endif
            if (pSecReg->_dwTickXmit <= dwTickPulse)
            {
                TraceSz2(secStat, "Sending pulse to %s (last xmit/pulse %d/%d secs ago)",
                         pSecReg->Str(), (dwTickNow - pSecReg->_dwTickXmit) / TICKS_PER_SECOND);
                IpXmitSecMsg(pSecReg, SECMSG_TYPE_PULSE);
                pSecReg->_dwTickPulse = dwTickNow;
                continue;
            }
        }
    }

    _pSecRegProbe = pSecReg;
}

#ifdef XNET_FEATURE_TRACE

char * CXnIp::CSecReg::Str()
{
    #define SECREG_STR_BUFFS    32
    #define SECREG_BUF_SIZE     24
    static char g_chBufSecReg[SECREG_STR_BUFFS * SECREG_BUF_SIZE];
    static LONG g_lBufIndexSecReg = 0;
    char * pch = &g_chBufSecReg[(InterlockedIncrement(&g_lBufIndexSecReg) % SECREG_STR_BUFFS) * SECREG_BUF_SIZE];
    XnInAddrToString(*(IN_ADDR *)&_dwSpiRecv, pch, SECREG_BUF_SIZE);
    strcat(pch, _bState == SR_STATE_IDLE ? "/IDLE" : _bState == SR_STATE_INITSENT ? "/ISENT" :
           _bState == SR_STATE_RESPSENT ? "/RSENT" : "/READY");
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnIp (IpDecrypt)
// ---------------------------------------------------------------------------------------

BOOL CXnIp::IpDecrypt(CPacket * ppkt, CIpAddr ipaDst)
{
    ICHECK(IP, USER|UDPC|SDPC);

    Assert(ppkt->IsEsp() && ppkt->IsCrypt());
    
    CSecReg * pSecReg = SecRegLookup(ipaDst);

    if (pSecReg == NULL)
    {
        TraceSz1(pktWarn, "IpDecrypt: %s is not a valid secure address", ipaDst.Str());
        return(FALSE);
    }

    if (!pSecReg->IsXmitReady())
    {
        TraceSz1(pktWarn, "IpDecrypt: %s is not ready for transmit", ipaDst.Str());
        return(FALSE);
    }

    // Check that the packet authenticates with the transmit SHA key

    CEspHdr *   pEspHdr     = ppkt->GetEspHdr();
    CEspTail *  pEspTail    = ppkt->GetEspTail();

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    Assert(sizeof(pEspTail->_abHash) <= sizeof(abHash));

    XcHMAC(pSecReg->_abKeyShaXmit, sizeof(pSecReg->_abKeyShaXmit),
           (BYTE *)&pEspHdr->_dwSpi,
           (BYTE *)&pEspTail->_abHash - (BYTE *)&pEspHdr->_dwSpi,
           NULL, 0, abHash);

    if (memcmp(pEspTail->_abHash, abHash, sizeof(pEspTail->_abHash)) != 0)
    {
        TraceSz(pktWarn, "IpDecrypt: packet failed to authenticate");
        return(FALSE);
    }

    // Decrypt the packet with the transmit DES key

    BYTE * pb = (BYTE *)(pEspHdr + 1);
    CryptDes(XC_SERVICE_DECRYPT, pSecReg->_abKeyDesXmit, pSecReg->_cbKeyDesXmit,
             pb, pb + XC_SERVICE_DES_BLOCKLEN, (BYTE *)&pEspTail->_abHash - pb);

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// CXnIp (GetXnAddr)
// ---------------------------------------------------------------------------------------

DWORD CXnIp::IpGetXnAddr(XNADDR * pxna)
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();

    memset(pxna, 0, sizeof(XNADDR));
    pxna->ina.s_addr = _ipa;
    memcpy(pxna->abEnet, _ea._ab, sizeof(_ea));

    DWORD dwFlags = 0;

#ifdef XNET_FEATURE_SG

    if (_uiLogonState == XN_LOGON_STATE_ONLINE && _pSecRegLogon != NULL)
    {
        pxna->inaOnline.s_addr = _pSecRegLogon->_ipaNat;
        pxna->wPortOnline = _pSecRegLogon->_ipportNat;
        Assert(sizeof(pxna->abOnline) == sizeof(SGADDR));
        memcpy(pxna->abOnline, &_pSecRegLogon->_sgaddr, sizeof(pxna->abOnline));
        dwFlags |= XNET_GET_XNADDR_ONLINE;
    }

#endif

#ifdef XNET_FEATURE_DHCP

    if (_options._gatewayCount > 0)
        dwFlags |= XNET_GET_XNADDR_GATEWAY;

    if (_options._dnsServerCount > 0)
        dwFlags |= XNET_GET_XNADDR_DNS;

    if (ActiveDhcpAddr())
        dwFlags |= XNET_GET_XNADDR_DHCP;
    else if (ActiveAutonetAddr())
        dwFlags |= XNET_GET_XNADDR_AUTO;
    else if (ActiveStaticAddr())
        dwFlags |= XNET_GET_XNADDR_STATIC;
    else if (ActiveNoAddr())
        dwFlags |= XNET_GET_XNADDR_ETHERNET;

#else

    // For now on the XBOX if we are not configured for using DHCP there is no
    // way to acquire an IP address.  This is the common codepath for the secure
    // xnets.lib to take for the XTL 1.0 release.

    Assert(_ipa == 0);

    dwFlags |= XNET_GET_XNADDR_ETHERNET;

#endif

    return(dwFlags);
}

// ---------------------------------------------------------------------------------------
// Online Support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ONLINE

void CXnIp::IpSetXoBase(CXoBase * pXoBase)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    if (pXoBase == NULL)
    {
        IpLogoff();
    }

    _pXoBase = pXoBase;
}

#endif

#ifdef XNET_FEATURE_SG

void CXnIp::IpLogon(CIpAddr ipaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    Assert(_uiLogonState == XN_LOGON_STATE_IDLE);

    _pEventLogon = hEventLogon ? EvtFromHandle(hEventLogon) : NULL;

    if (_pEventLogon == NULL && hEventLogon != NULL)
    {
        TraceSz1(Warning, "IpLogon - invalid hEvent %08lX", hEventLogon);
    }

    if (ipaLogon != 0)
    {
        _pSecRegLogon = SecRegLookup(ipaLogon);

        if (_pSecRegLogon == NULL || !_pSecRegLogon->TestFlags(SRF_ONLINESERVER))
        {
            TraceSz1(Warning, "IpLogon - %s is not a valid secure address to an SG", ipaLogon.Str());
            _pSecRegLogon = NULL;
        }
    }

    if (_pSecRegLogon == NULL)
    {
        // This logon is not connecting to an SG providing connection services.  Just mark
        // the state machine as online.

        _uiLogonState = XN_LOGON_STATE_ONLINE;

        if (_pEventLogon)
        {
            EvtSet(_pEventLogon, EVENT_INCREMENT);
        }
    }
    else
    {
        _uiLogonState = XN_LOGON_STATE_PENDING;

        if (pqwUserId != NULL)
        {
            XOUSERINFO * pxouserinfo    = _axouserinfo;
            XOUSERINFO * pxouserinfoEnd = pxouserinfo + dimensionof(_axouserinfo);

            for (; pxouserinfo < pxouserinfoEnd; ++pxouserinfo, ++pqwUserId)
            {
                pxouserinfo->_qwUserId = *pqwUserId;
            }
        }

        // Kick off key exchange to the SG providing connection services.

        Assert(_pSecRegLogon->_bState == SR_STATE_IDLE);
        IpXmitKeyEx(_pSecRegLogon);
    }
}

DWORD CXnIp::IpLogonGetStatus(SGADDR * psgaddr)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (psgaddr != NULL)
    {
        if (_pSecRegLogon != NULL && _uiLogonState == XN_LOGON_STATE_ONLINE)
            *psgaddr = _pSecRegLogon->_sgaddr;
        else
            memset(psgaddr, 0, sizeof(SGADDR));
    }

    return(_uiLogonState);
}

BOOL CXnIp::IpLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (iUserId < dimensionof(_axouserinfo))
    {
        XOUSERINFO * pxouserinfo = &_axouserinfo[iUserId];

        if (pqwUserId != NULL)
        {
            *pqwUserId = pxouserinfo->_qwUserId;
        }

        if (pdwQFlags != NULL)
        {
            *pdwQFlags = pxouserinfo->_dwQFlags;
        }

        if (pdwSeqQFlags != NULL)
        {
            *pdwSeqQFlags = pxouserinfo->_dwSeqQFlags;
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL CXnIp::IpLogonSetQFlags(UINT iUserId, DWORD dwQFlags, DWORD dwSeqQFlags)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (iUserId < dimensionof(_axouserinfo))
    {
        XOUSERINFO * pxouserinfo = &_axouserinfo[iUserId];

        if (pxouserinfo->_dwSeqQFlags < dwSeqQFlags)
        {
            pxouserinfo->_dwSeqQFlags = dwSeqQFlags;
            pxouserinfo->_dwQFlags    = dwQFlags;

            if (_pEventLogon)
            {
                EvtSet(_pEventLogon, EVENT_INCREMENT);
            }
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL CXnIp::IpLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (iUserId < dimensionof(_axouserinfo) && cbData <= sizeof(_axouserinfo[0]._abData))
    {
        XOUSERINFO * pxouserinfo = &_axouserinfo[iUserId];
        BYTE *       pb          = &_abXbToSgPulse[iUserId];

        if (pxouserinfo->_dwPState != dwPState)
        {
            pxouserinfo->_dwPState = dwPState;

            *pb |= (BYTE)iUserId | XBPULSE_STATE_CHANGE;
        }

        if (memcmp(&pxouserinfo->_xnkid, pxnkid, sizeof(XNKID)) != 0)
        {
            pxouserinfo->_xnkid = *pxnkid;

            *pb |= (BYTE)iUserId | XBPULSE_XNKID_CHANGE;
        }

        if (cbData != pxouserinfo->_cbData || memcmp(pxouserinfo->_abData, pbData, cbData) != 0)
        {
            pxouserinfo->_cbData = cbData;

            if (cbData > 0)
            {
                memcpy(pxouserinfo->_abData, pbData, cbData);
            }

            *pb |= (BYTE)iUserId | XBPULSE_TDATA_CHANGE;
        }

        return(TRUE);
    }

    return(FALSE);
}

void CXnIp::IpLogoff()
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    _uiLogonState = XN_LOGON_STATE_IDLE;
    _pSecRegLogon = NULL;

    if (_pEventLogon)
    {
        EvtDereference(_pEventLogon);
        _pEventLogon = NULL;
    }

    memset(&_axouserinfo, 0, sizeof(_axouserinfo));
    *(DWORD *)_abXbToSgPulse = 0;
    _dwSeqXbToSg = 0;
    _dwSeqSgToXb = 0;

    SecRegShutdown(TRUE);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnIp::IpSetEventTimer / CXnIp::EventTimer
// ---------------------------------------------------------------------------------------

void CXnIp::IpSetEventTimer(CEventTimer * pEventTimer, WSAEVENT hEvent, DWORD dwTimeout)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    if (pEventTimer->IsNull())
    {
        pEventTimer->Init((PFNTIMER)EventTimer);
    }

    // Release the reference to the existing event.

    if (pEventTimer->_pEvent != NULL)
    {
        EvtDereference(pEventTimer->_pEvent);
        pEventTimer->_pEvent = NULL;
    }

    if (dwTimeout != TIMER_INFINITE)
    {
        // Compute the number of milliseconds until our timer next fires.

        DWORD dwTickKe = KeQueryTickCount() - _dwTickKe;

        dwTickKe = MSEC_PER_TICK - min(MSEC_PER_TICK, dwTickKe);

        // In order to compensate for edge effects between the kernel timer and our timer
        // we add 25 ms to the requested timeout.  This will guarantee that we don't set
        // the event prematurely with respect to the kernel millisecond timer.

        dwTimeout += 25;

        // Now compute the number of whole timer ticks we need to wait beyond the partial
        // tick we are in right now.  Note that we round up to the next timer tick.

        if (dwTimeout < dwTickKe)
        {
            dwTimeout = 0;
        }
        else
        {
            dwTimeout -= dwTickKe;
            dwTimeout += MSEC_PER_TICK - 1;
            dwTimeout  = (dwTimeout * TICKS_PER_SECOND) / 1000;
        }

        // Finally, add in the current timer tick plus one, which is the tick of the next
        // firing of our timer.

        dwTimeout += TimerTick() + 1;

        // Add a reference to the event handle

        pEventTimer->_pEvent = EvtFromHandle(hEvent);

        if (pEventTimer->_pEvent == NULL)
        {
            TraceSz1(Warning, "IpSetEventTimer - invalid hEvent %08lX", hEvent);
        }
    }

    // Set or cancel the timer

    TimerSet(pEventTimer, dwTimeout);
}

void CXnIp::EventTimer(CTimer * pt)
{
    ICHECK(IP, SDPC);

    CEventTimer * pEventTimer = (CEventTimer *)pt;

    if (pEventTimer->_pEvent != NULL)
    {
        EvtSet(pEventTimer->_pEvent, EVENT_INCREMENT);
      